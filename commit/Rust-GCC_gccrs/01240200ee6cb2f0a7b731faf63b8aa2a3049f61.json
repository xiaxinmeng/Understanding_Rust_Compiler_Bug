{"sha": "01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyNDAyMDBlZTZjYjJmMGE3YjczMWZhZjYzYjhhYTJhMzA0OWY2MQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-03T23:11:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-03T23:11:19Z"}, "message": "class.c (current_class_ptr, [...]): Clarify documentation.\n\n\t* class.c (current_class_ptr, current_class_ref): Clarify\n\tdocumentation.\n\t* cvt.c (ocp_convert): Don't expect fold to remove all trivial\n\tNOP type conversions.\n\t* decl.c (decls_match): Use comptypes directly; ignore\n\tqualifiers on the DECL.\n\t(duplicate_decls): Remove qualifier checks on DECL.\n\t(grokdeclarator): Make the type built up include top-level\n\tqualifiers.\n\t* decl2.c (do_dtors): Fix spelling error.\n\t* error.c (dump_simple_decl): Don't look at qualifiers on the decl\n\twhen printing type information.\n\t* init.c (build_new_1): Add documentation.  Deal with the fact\n\tthat type of allocated memory now contains qualifiers.\n\t* lex.c (is_global): Improve error-recovery.\n\t* sig.c (build_member_function_pointer): Don't cast away const\n\ton fields of sigtable_entry_type.\n\t* tree.c (lvalue_type): Don't look at top-level qualifiers on\n\texpressions.\n\t* typeck.c (decay_conversion): Likewise.\n\t(build_component_ref): Make sure the type of the COMPONENT_REF\n\tcontains top-level qualifiers, as appropriate.  Improve\n\terror-handling.\n\t(build_indirect_ref): Simplify.  Don't strip top-level qualifiers.\n\t(build_array_ref): Likewise.\n\t(build_unary_op): Improve error-recovery.\n\t(unary_complex_lvalue): Make taking the address a bound member\n\tfunction an error, not a sorry.\n\t(build_conditional_expr): Look at the type qualifiers, not the\n\tqualifiers on the expression itself.\n\nFrom-SVN: r22802", "tree": {"sha": "f8109fee965c4dbf574d2437c97abec84280e237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8109fee965c4dbf574d2437c97abec84280e237"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/comments", "author": null, "committer": null, "parents": [{"sha": "d5698b07533c991d016c0c16e0fa0d87d1457565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5698b07533c991d016c0c16e0fa0d87d1457565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5698b07533c991d016c0c16e0fa0d87d1457565"}], "stats": {"total": 266, "additions": 172, "deletions": 94}, "files": [{"sha": "7634176757c6ea4537de9bb195751e6ab9ec080f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -1,3 +1,36 @@\n+1998-10-03  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* class.c (current_class_ptr, current_class_ref): Clarify\n+\tdocumentation.\n+\t* cvt.c (ocp_convert): Don't expect fold to remove all trivial\n+\tNOP type conversions.\n+\t* decl.c (decls_match): Use comptypes directly; ignore\n+\tqualifiers on the DECL.\n+\t(duplicate_decls): Remove qualifier checks on DECL.\n+\t(grokdeclarator): Make the type built up include top-level\n+\tqualifiers.\n+\t* decl2.c (do_dtors): Fix spelling error.\n+\t* error.c (dump_simple_decl): Don't look at qualifiers on the decl\n+\twhen printing type information.\n+\t* init.c (build_new_1): Add documentation.  Deal with the fact\n+\tthat type of allocated memory now contains qualifiers.\n+\t* lex.c (is_global): Improve error-recovery.\n+\t* sig.c (build_member_function_pointer): Don't cast away const\n+\ton fields of sigtable_entry_type.\n+\t* tree.c (lvalue_type): Don't look at top-level qualifiers on\n+\texpressions.\n+\t* typeck.c (decay_conversion): Likewise.\n+\t(build_component_ref): Make sure the type of the COMPONENT_REF\n+\tcontains top-level qualifiers, as appropriate.  Improve\n+\terror-handling. \n+\t(build_indirect_ref): Simplify.  Don't strip top-level qualifiers.\n+\t(build_array_ref): Likewise.\n+\t(build_unary_op): Improve error-recovery.\n+\t(unary_complex_lvalue): Make taking the address a bound member\n+\tfunction an error, not a sorry.\n+\t(build_conditional_expr): Look at the type qualifiers, not the\n+\tqualifiers on the expression itself.\n+\t\n 1998-10-03  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (merge_functions): Remove duplicates."}, {"sha": "b64a91ad9a6cd29cc44828009a4b1ecae9ef40ad", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -48,8 +48,9 @@ static tree *current_class_base, *current_class_stack;\n static int current_class_stacksize;\n int current_class_depth;\n \n-/* The current_class_ptr is the pointer to the current class.\n-   current_class_ref is the actual current class.  */\n+/* When we're processing a member function, current_class_ptr is the\n+   PARM_DECL for the `this' pointer.  The current_class_ref is an\n+   expression for `*this'.  */\n tree current_class_ptr, current_class_ref;\n \n /* The following two can be derived from the previous one */"}, {"sha": "06c5290c4240a252b8b82c368d88419d85ff461b", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -664,9 +664,19 @@ ocp_convert (type, expr, convtype, flags)\n       && TYPE_HAS_CONSTRUCTOR (type))\n     /* We need a new temporary; don't take this shortcut.  */;\n   else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e)))\n-    /* Trivial conversion: cv-qualifiers do not matter on rvalues.  */\n-    return fold (build1 (NOP_EXPR, type, e));\n-  \n+    {\n+      if (comptypes (type, TREE_TYPE (e), 1))\n+\t/* The call to fold will not always remove the NOP_EXPR as\n+\t   might be expected, since if one of the types is a typedef;\n+\t   the comparsion in fold is just equality of pointers, not a\n+\t   call to comptypes.  */\n+\t;\n+      else\n+\te = build1 (NOP_EXPR, type, e);\n+\n+      return fold (e);\n+    }\n+\n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n     return build1 (CONVERT_EXPR, type, e);\n "}, {"sha": "71fe530e66e90c3c8925edac1898c2bff2fd9edd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -2571,20 +2571,9 @@ decls_match (newdecl, olddecl)\n \ttypes_match = TREE_TYPE (newdecl) == NULL_TREE;\n       else if (TREE_TYPE (newdecl) == NULL_TREE)\n \ttypes_match = 0;\n-      /* Qualifiers must match, and they may be present on either, the type\n-\t or the decl.  */\n-      else if ((TREE_READONLY (newdecl)\n-\t\t|| TYPE_READONLY (TREE_TYPE (newdecl)))\n-\t       == (TREE_READONLY (olddecl)\n-\t\t   || TYPE_READONLY (TREE_TYPE (olddecl)))\n-\t       && (TREE_THIS_VOLATILE (newdecl)\n-\t\t    || TYPE_VOLATILE (TREE_TYPE (newdecl)))\n-\t\t   == (TREE_THIS_VOLATILE (olddecl)\n-\t\t       || TYPE_VOLATILE (TREE_TYPE (olddecl))))\n-\ttypes_match = comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (newdecl)),\n-\t\t\t\t TYPE_MAIN_VARIANT (TREE_TYPE (olddecl)), 1);\n       else\n-\ttypes_match = 0;\n+\ttypes_match = comptypes (TREE_TYPE (newdecl),\n+\t\t\t\t TREE_TYPE (olddecl), 1);\n     }\n \n   return types_match;\n@@ -2908,13 +2897,6 @@ duplicate_decls (newdecl, olddecl)\n \t\t\t     olddecl);\n \t    }\n \t}\n-      /* These bits are logically part of the type for non-functions.  */\n-      else if (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n-\t       || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl))\n-\t{\n-\t  cp_pedwarn (\"type qualifiers for `%#D'\", newdecl);\n-\t  cp_pedwarn_at (\"conflict with previous decl `%#D'\", olddecl);\n-\t}\n     }\n \n   /* If new decl is `static' and an `extern' was seen previously,\n@@ -9084,7 +9066,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   constp = !! RIDBIT_SETP (RID_CONST, specbits) + TYPE_READONLY (type);\n   volatilep = !! RIDBIT_SETP (RID_VOLATILE, specbits) + TYPE_VOLATILE (type);\n-  type = build_type_variant (type, 0, 0);\n+  type = cp_build_type_variant (type, constp, volatilep);\n   staticp = 0;\n   inlinep = !! RIDBIT_SETP (RID_INLINE, specbits);\n   virtualp = RIDBIT_SETP (RID_VIRTUAL, specbits);\n@@ -9817,6 +9799,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    pedwarn (\"discarding `volatile' applied to a reference\");\n \t\t  constp = volatilep = 0;\n \t\t}\n+\t      type = cp_build_type_variant (type, constp, volatilep);\n \t    }\n \t  declarator = TREE_OPERAND (declarator, 0);\n \t  ctype = NULL_TREE;\n@@ -10903,7 +10886,11 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t\t\t NULL_TREE);\n \t\t  if (! decl)\n \t\t    continue;\n-\t\t  type = TREE_TYPE (decl);\n+\n+\t\t  /* Top-level qualifiers on the parameters are\n+\t\t     ignored for function types.  */\n+\t\t  type = TYPE_MAIN_VARIANT (TREE_TYPE (decl));\n+\n \t\t  if (TREE_CODE (type) == VOID_TYPE)\n \t\t    decl = void_type_node;\n \t\t  else if (TREE_CODE (type) == METHOD_TYPE)"}, {"sha": "492688b6c963b0a0521c301b97fae19d28de6ed4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -3192,7 +3192,7 @@ do_dtors (start)\n \n \t       Access control for implicit calls to the constructors,\n \t       the conversion functions, or the destructor called to\n-\t       create and destroy a static data member is per- formed as\n+\t       create and destroy a static data member is performed as\n \t       if these calls appeared in the scope of the member's\n \t       class.  \n "}, {"sha": "fb6995fe49fbf3674cbacdd11a2d58f778fbbadc", "filename": "gcc/cp/error.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -667,7 +667,6 @@ dump_simple_decl (t, type, v)\n     {\n       dump_type_prefix (type, v, 0);\n       OB_PUTC (' ');\n-      dump_readonly_or_volatile (t, after);\n     }\n   if (DECL_CLASS_SCOPE_P (t))\n     {"}, {"sha": "b6a20ba8687162693b06b1fa589874f2d481facb", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -2391,12 +2391,26 @@ build_new_1 (exp)\n       if (! TYPE_NEEDS_CONSTRUCTING (type)\n \t  && ! IS_AGGR_TYPE (type) && ! has_array)\n \t{\n-\t  /* New 2.0 interpretation: `new int (10)' means\n-\t     allocate an int, and initialize it with 10.  */\n+\t  /* We are processing something like `new int (10)', which\n+\t     means allocate an int, and initialize it with 10.  */\n \t  tree deref;\n+\t  tree deref_type;\n \n+\t  /* At present RVAL is a temporary variable, created to hold\n+\t     the value from the call to `operator new'.  We transform\n+\t     it to (*RVAL = INIT, RVAL).  */\n \t  rval = save_expr (rval);\n \t  deref = build_indirect_ref (rval, NULL_PTR);\n+\n+\t  /* Even for something like `new const int (10)' we must\n+\t     allow the expression to be non-const while we do the\n+\t     initialization.  */\n+\t  deref_type = TREE_TYPE (deref);\n+\t  if (TYPE_READONLY (deref_type))\n+\t    TREE_TYPE (deref) \n+\t      = cp_build_type_variant (deref_type,\n+\t\t\t\t       /*constp=*/0,\n+\t\t\t\t       TYPE_VOLATILE (deref_type));\n \t  TREE_READONLY (deref) = 0;\n \n \t  if (TREE_CHAIN (init) != NULL_TREE)"}, {"sha": "d69dc6ea452b977bfbc5adbbd33ddcabf0022806", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -2853,6 +2853,9 @@ is_global (d)\n   while (1)\n     switch (TREE_CODE (d))\n       {\n+      case ERROR_MARK:\n+\treturn 1;\n+\n       case OVERLOAD: d = OVL_FUNCTION (d); continue;\n       case TREE_LIST: d = TREE_VALUE (d); continue;\n       default:"}, {"sha": "e70ec3f17ed27a980430ec991ea59fea3bebedcf", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -321,7 +321,7 @@ build_member_function_pointer (member)\n   GNU_xref_ref (current_function_decl, name);\n \n   entry = build_lang_field_decl (FIELD_DECL, get_identifier (name),\n-\t\t\t\t TYPE_MAIN_VARIANT (sigtable_entry_type));\n+\t\t\t\t sigtable_entry_type);\n   TREE_CONSTANT (entry) = 1;\n   TREE_READONLY (entry) = 1;\n "}, {"sha": "00202b31bba6671599af4ebed8059a1d13c5661e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -2571,9 +2571,6 @@ lvalue_type (arg)\n   tree type = TREE_TYPE (arg);\n   if (TREE_CODE (arg) == OVERLOAD)\n     type = unknown_type_node;\n-  else if (TREE_CODE (type) != ARRAY_TYPE)\n-    type = cp_build_type_variant\n-      (type, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n   return type;\n }\n "}, {"sha": "d0be08addade57b5ff1a1cbecad32a8edde45322", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 75, "deletions": 59, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -1684,9 +1684,7 @@ decay_conversion (exp)\n   if (code == ARRAY_TYPE)\n     {\n       register tree adr;\n-      tree restype;\n       tree ptrtype;\n-      int constp, volatilep;\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n \t{\n@@ -1718,21 +1716,7 @@ decay_conversion (exp)\n \t  return error_mark_node;\n \t}\n \n-      constp = volatilep = 0;\n-      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'r'\n-\t  || TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n-\t{\n-\t  constp = TREE_READONLY (exp);\n-\t  volatilep = TREE_THIS_VOLATILE (exp);\n-\t}\n-\n-      restype = TREE_TYPE (type);\n-      if (TYPE_READONLY (type) || TYPE_VOLATILE (type)\n-\t  || constp || volatilep)\n-\trestype = cp_build_type_variant (restype,\n-\t\t\t\t\t TYPE_READONLY (type) || constp,\n-\t\t\t\t\t TYPE_VOLATILE (type) || volatilep);\n-      ptrtype = build_pointer_type (restype);\n+      ptrtype = build_pointer_type (TREE_TYPE (type));\n \n       if (TREE_CODE (exp) == VAR_DECL)\n \t{\n@@ -1954,14 +1938,24 @@ build_component_ref (datum, component, basetype_path, protect)\n      tree datum, component, basetype_path;\n      int protect;\n {\n-  register tree basetype = TREE_TYPE (datum);\n+  register tree basetype;\n   register enum tree_code code;\n   register tree field = NULL;\n   register tree ref;\n+  tree field_type;\n+  int constp;\n+  int volatilep;\n \n   if (processing_template_decl)\n     return build_min_nt (COMPONENT_REF, datum, component);\n+  \n+  if (datum == error_mark_node \n+      || TREE_TYPE (datum) == error_mark_node)\n+    return error_mark_node;\n \n+  /* BASETYPE holds the type of the class containing the COMPONENT.  */\n+  basetype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n+    \n   /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference\n      inside it.  */\n   switch (TREE_CODE (datum))\n@@ -1995,13 +1989,13 @@ build_component_ref (datum, component, basetype_path, protect)\n   if (code == REFERENCE_TYPE)\n     {\n       datum = convert_from_reference (datum);\n-      basetype = TREE_TYPE (datum);\n+      basetype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n       code = TREE_CODE (basetype);\n     }\n   if (TREE_CODE (datum) == OFFSET_REF)\n     {\n       datum = resolve_offset_ref (datum);\n-      basetype = TREE_TYPE (datum);\n+      basetype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n       code = TREE_CODE (basetype);\n     }\n \n@@ -2086,7 +2080,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t  tree access, fndecl;\n \n \t\t  /* Unique, so use this one now.  */\n-\t\t  basetype = TREE_PURPOSE (fndecls);\n+\t\t  basetype = TYPE_MAIN_VARIANT (TREE_PURPOSE (fndecls));\n \t\t  fndecl = TREE_VALUE (fndecls);\n \t\t  access = compute_access (TREE_PURPOSE (fndecls), fndecl);\n \t\t  if (access == access_public_node)\n@@ -2198,15 +2192,40 @@ build_component_ref (datum, component, basetype_path, protect)\n \t}\n     }\n \n-  ref = fold (build (COMPONENT_REF, TREE_TYPE (field),\n+  /* Compute the type of the field, as described in [expr.ref].  */\n+  constp = 0;\n+  volatilep = 0;\n+  field_type = TREE_TYPE (field);\n+  if (TREE_CODE (field_type) == REFERENCE_TYPE)\n+    /* The standard says that the type of the result should be the\n+       type referred to by the reference.  But for now, at least, we\n+       do the conversion from reference type later.  */\n+    ;\n+  else\n+    {\n+      /* A field is const (volatile) if the enclosing object, or the\n+\t field itself, is const (volatile).  But, a mutable field is\n+\t not const, even within a const object.  */\n+      constp = (!(DECL_LANG_SPECIFIC (field) \n+\t\t  && DECL_MUTABLE_P (field))\n+\t\t&& (TYPE_READONLY (field_type)\n+\t\t    || TYPE_READONLY (TREE_TYPE (datum))));\n+      volatilep = (TYPE_VOLATILE (field_type)\n+\t\t   || TYPE_VOLATILE (TREE_TYPE (datum)));\n+      if (!IS_SIGNATURE (field_type))\n+\tfield_type = cp_build_type_variant (field_type, constp, volatilep);\n+    }\n+\n+  ref = fold (build (COMPONENT_REF, field_type,\n \t\t     break_out_cleanups (datum), field));\n \n-  if (TREE_READONLY (datum) || TREE_READONLY (field))\n+  /* Mark the expression const or volatile, as appropriate.  Even\n+     though we've dealt with the type above, we still have to mark the\n+     expression itself.  */\n+  if (constp)\n     TREE_READONLY (ref) = 1;\n-  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (field))\n+  else if (volatilep)\n     TREE_THIS_VOLATILE (ref) = 1;\n-  if (DECL_LANG_SPECIFIC (field) && DECL_MUTABLE_P (field))\n-    TREE_READONLY (ref) = 0;\n \n   return ref;\n }\n@@ -2270,29 +2289,34 @@ build_indirect_ref (ptr, errorstring)\n \n   if (TREE_CODE (type) == POINTER_TYPE || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n+      /* [expr.unary.op]\n+\t \n+\t If the type of the expression is \"pointer to T,\" the type\n+\t of  the  result  is  \"T.\"   \n+\n+         We must use the canonical variant because certain parts of\n+\t the back end, like fold, do pointer comparisons between\n+\t types.  */\n+      tree t = canonical_type_variant (TREE_TYPE (type));\n+\n       if (TREE_CODE (pointer) == ADDR_EXPR\n \t  && !flag_volatile\n-\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (pointer, 0)))\n-\t      == TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n-\t  && (TREE_READONLY (TREE_OPERAND (pointer, 0))\n-\t      == TYPE_READONLY (TREE_TYPE (type)))\n-\t  && (TREE_THIS_VOLATILE (TREE_OPERAND (pointer, 0))\n-\t      == TYPE_VOLATILE (TREE_TYPE (type))))\n+\t  && comptypes (t, TREE_TYPE (TREE_OPERAND (pointer, 0)), 1))\n+\t/* The POINTER was something like `&x'.  We simplify `*&x' to\n+\t   `x'.  */\n \treturn TREE_OPERAND (pointer, 0);\n       else\n \t{\n-\t  tree t = TREE_TYPE (type);\n-\t  register tree ref = build1 (INDIRECT_REF,\n-\t\t\t\t      TYPE_MAIN_VARIANT (t), pointer);\n+\t  tree ref = build1 (INDIRECT_REF, t, pointer);\n \n \t  /* We *must* set TREE_READONLY when dereferencing a pointer to const,\n \t     so that we get the proper error message if the result is used\n \t     to assign to.  Also, &* is supposed to be a no-op.  */\n \t  TREE_READONLY (ref) = TYPE_READONLY (t);\n+\t  TREE_THIS_VOLATILE (ref) = TYPE_VOLATILE (t);\n \t  TREE_SIDE_EFFECTS (ref)\n-\t    = (TYPE_VOLATILE (t) || TREE_SIDE_EFFECTS (pointer)\n+\t    = (TREE_THIS_VOLATILE (ref) || TREE_SIDE_EFFECTS (pointer)\n \t       || flag_volatile);\n-\t  TREE_THIS_VOLATILE (ref) = TYPE_VOLATILE (t);\n \t  return ref;\n \t}\n     }\n@@ -2403,23 +2427,16 @@ build_array_ref (array, idx)\n \t    warning (\"subscripting array declared `register'\");\n \t}\n \n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (array)));\n+      type = TREE_TYPE (TREE_TYPE (array));\n       rval = build (ARRAY_REF, type, array, idx);\n       /* Array ref is const/volatile if the array elements are\n \t or if the array is..  */\n       TREE_READONLY (rval)\n-\t|= (TYPE_READONLY (TREE_TYPE (TREE_TYPE (array)))\n-\t    | TREE_READONLY (array));\n+\t|= (TYPE_READONLY (type) | TREE_READONLY (array));\n       TREE_SIDE_EFFECTS (rval)\n-\t|= (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (array)))\n-\t    | TREE_SIDE_EFFECTS (array));\n+\t|= (TYPE_VOLATILE (type) | TREE_SIDE_EFFECTS (array));\n       TREE_THIS_VOLATILE (rval)\n-\t|= (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (array)))\n-\t    /* This was added by rms on 16 Nov 91.\n-\t       It fixes  vol struct foo *a;  a->elts[1] \n-\t       in an inline function.\n-\t       Hope it doesn't break something else.  */\n-\t    | TREE_THIS_VOLATILE (array));\n+\t|= (TYPE_VOLATILE (type) | TREE_THIS_VOLATILE (array));\n       return require_complete_type (fold (rval));\n     }\n \n@@ -4720,7 +4737,8 @@ build_unary_op (code, xarg, noconvert)\n \t       && !lvalue_or_else (arg, \"unary `&'\"))\n \treturn error_mark_node;\n \n-      argtype = build_pointer_type (argtype);\n+      if (argtype != error_mark_node)\n+\targtype = build_pointer_type (argtype);\n \n       if (mark_addressable (arg) == 0)\n \treturn error_mark_node;\n@@ -4871,14 +4889,12 @@ unary_complex_lvalue (code, arg)\n \t  if (TREE_OPERAND (arg, 0)\n \t      && (TREE_CODE (TREE_OPERAND (arg, 0)) != NOP_EXPR\n \t\t  || (TREE_OPERAND (TREE_OPERAND (arg, 0), 0)\n-\t\t      != error_mark_node)))\n-\t    if (TREE_CODE (t) != FIELD_DECL)\n-\t      {\n-\t\t/* Don't know if this should return address to just\n-\t\t   _DECL, or actual address resolved in this expression.  */\n-\t\tsorry (\"address of bound pointer-to-member expression\");\n-\t\treturn error_mark_node;\n-\t      }\n+\t\t      != error_mark_node))\n+\t      && TREE_CODE (t) != FIELD_DECL)\n+\t    {\n+\t      cp_error (\"taking address of bound pointer-to-member expression\");\n+\t      return error_mark_node;\n+\t    }\n \n \t  /* Add in the offset to the field.  */\n \t  offset = convert (sizetype,\n@@ -5115,8 +5131,8 @@ build_conditional_expr (ifexp, op1, op2)\n       if (type1 != type2)\n \ttype1 = cp_build_type_variant\n \t\t\t(type1,\n-\t\t\t TREE_READONLY (op1) || TREE_READONLY (op2),\n-\t\t\t TREE_THIS_VOLATILE (op1) || TREE_THIS_VOLATILE (op2));\n+\t\t\t TYPE_READONLY (op1) || TYPE_READONLY (op2),\n+\t\t\t TYPE_VOLATILE (op1) || TYPE_VOLATILE (op2));\n       /* ??? This is a kludge to deal with the fact that\n \t we don't sort out integers and enums properly, yet.  */\n       result = fold (build (COND_EXPR, type1, ifexp, op1, op2));"}, {"sha": "a716917bc0a36c7255f8f74fb08fee8d604854ef", "filename": "gcc/testsuite/g++.old-deja/g++.pt/overload3.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01240200ee6cb2f0a7b731faf63b8aa2a3049f61/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload3.C?ref=01240200ee6cb2f0a7b731faf63b8aa2a3049f61", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+template <class T>\n+void g(T, T);\n+\n+template <class T>\n+void g(int*, T);\n+\n+struct S\n+{\n+  void f() const\n+    {\n+      g(X, X+3);\n+    }\n+\n+  double X[3];\n+};\n+"}]}