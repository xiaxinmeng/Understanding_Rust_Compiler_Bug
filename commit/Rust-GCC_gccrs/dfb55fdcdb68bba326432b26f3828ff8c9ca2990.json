{"sha": "dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiNTVmZGNkYjY4YmJhMzI2NDMyYjI2ZjM4MjhmZjhjOWNhMjk5MA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-06-21T19:24:55Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-06-21T19:24:55Z"}, "message": "re PR fortran/37577 ([meta-bug] change internal array descriptor format for better syntax, C interop TR, rank 15)\n\n2009-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/37577\n\tPort from fortran-dev\n\t* runtime/in_pack_generic (internal_pack):  Remove unnecessary\n\ttest for stride == 0.\n\t* runtime/in_unpack_generic.c (internal_unpack):  Likewise.\n\t* intrinsics/iso_c_binding.c (c_f_pointer_u0):  Take care\n\tof stride in \"shape\" argument.  Use array access macros for\n\taccessing array descriptors.\n\t* libgfortran.h (struct descriptor_dimension):  Change stride\n\tto _stride, lbound to _lbound and ubound to _ubound.\n\t(GFC_DIMENSION_LBOUND):  Use new name(s) in struct\n\tdescriptor_dimension.\n\t(GFC_DIMENSION_UBOUND):  Likewise.\n\t(GFC_DIMENSION_STRIDE):  Likewise.\n\t(GFC_DIMENSION_EXTENT):  Likewise.\n\t(GFC_DIMENSION_SET):  Likewise.\n\t(GFC_DESCRIPTOR_LBOUND):  Likewise.\n\t(GFC_DESCRIPTOR_UBOUND):  Likewise.\n\t(GFC_DESCRIPTOR_EXTENT):  Likewise.\n\t(GFC_DESCRIPTOR_STRIDE):  Likewise.\n\t* io/transfer.c (transfer_array):  Use array access macros.\n\tUse byte-sized strides.\n\t* intrinsics/eoshift0.c (eoshift0):  Use array access\n\tmacros everywhere.\n\t* m4/in_pack.m4 (internal_pack_'rtype_ccode`):  Use\n\tarray access macros for accessing array descriptors.\n\t* m4/in_unpack.m4 (internal_unpack_'rtype_ccode`):\n\tLikewise.\n\t* m4/matmull.m4 (matmul_'rtype_code`):  Likewise.\n\t* m4/matmul.m4 (matmul_'rtype_code`):  Likewise.\n\t* m4/unpack.m4 (unpack0_'rtype_code`):  Likewise.\n\t(unpack1_'rtype_code`):  Likewise.\n\t* m4/ifunction_logical.m4 (name`'rtype_qual`_'atype_code): Likewise.\n\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code): Use array access\n\tmacros everywhere.\n\t\t* intrinsics/dtime.c (dtime_sub):  Use array access macros\n\tfor accessing array descriptors.\n\t* intrinsics/cshift0 (cshift0):  Likewise.\n\t* intrinsics/etime.c:  Likewise.  Remove redundant calculation\n\tof rdim.\n\t* m4/cshift0.m4 (cshift0_'rtype_code`):  Use array access macros\n\tfor accessing array descriptors.\n\t* m4/pack.m4 (pack_'rtype_code`):  Likewise.\n\t* m4/spread.m4 (spread_'rtype_code`):  Likewise.\n\t(spread_scalar_'rtype_code`):  Likewise.\n\t* m4/transpose.m4 (transpose_'rtype_code`):  Likewise.\n\t* m4/iforeach.m4 (name`'rtype_qual`_'atype_code):  Likewise.\n\t* m4/eoshift1.m4 (eoshift1):  Likewise.  Remove size argument,\n\tcalculate within function.\n\t(eoshift1_'atype_kind`):  Remove size argument from call\n\tto eoshift1.\n\t(eoshift1_'atype_kind`_char):  Likewise.\n\t(eoshift1_'atype_kind`_char4):  Likewise.\n\t* m4/eoshift3.m4 (eoshift3):  Remove size argument, calculate\n\twithin function. Use array access macros for accessing array\n\tdescriptors.\n\t(eoshift3_'atype_kind`):  Remove size argument from call\n\tto eoshift1.\n\t(eoshift3_'atype_kind`_char):  Likewise.\n\t(eoshift3_'atype_kind`_char4):  Likewise.\n\t* m4/shape.m4 (shape_'rtype_kind`):  Use array access macros\n\tfor accessing array descriptors.\n\t* m4/cshift1.m4 (cshift1): Remove size argument, calculate\n\twithin function. Use array access macros for accessing array\n\tdescriptors.\n\t(cshift1_'atype_kind`):  Remove size argument from call to\n\tcshift1.\n\t(cshift1_'atype_kind`_char):  Remove size argument from call to\n\tcshift1.\n\t(cshift1_'atype_kind`_char4):  Remove size argument from call to\n\tcshift1.\n\t* m4/reshape.m4 (reshape_'rtype_ccode`):  Use array access macros\n\tfor accessing array descriptors.\n\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code):  Likewise.\n\t* intrinsics/pack_generic.c (pack_internal):  Use array access\n\tmacros for accessing array descriptors.\n\t(pack_s_internal):  Likewise.\n\t* intrinsics/transpose_generic.c (transpose_internal):  Remove\n\tsize argument, calculate from array descriptor. Use array\n\taccess macros for accessing array descriptors.\n\t(transpose):  Remove size argument from call.\n\t(transpoe_char):  Likewise.\n\t(transpose_char4):  Likewise.\n\t* intrinsics/move_alloc.c (move_alloc):  Use array access macros\n\tfor accessing array descriptors.\n\t* intrinsics/spread_generic.c (spread_internal):  Remove size\n\targument, calculate from array descriptor.  Use array access\n\tmacros for accessing array descriptors.\n\t(spread_internal_scalar):  Likewise.\n\t(spread):  Remove size argument from call to spread_internal.\n\t(spread_char):  Mark argument source_length as unused.\n\tRemove size argument from call to spread_internal.\n\t(spread_char4):  Likewise.\n\t(spread_char_scalar):  Likewise.\n\t(spread_char4_scalar):  Likewise.\n\t* intrinsics/unpack_generic.c (unpack_internal):  Use array access\n\tmacros for accessing array descriptors.\n\t* intrinsics/eoshift2.c (eoshift2):  Remove size argument, calculate\n\tfrom array descriptor instead.  Use array access macros for\n\taccessing array descriptors.\n\t(eoshift2_##N):  Remove size argument from call to eoshift2.\n\t(eoshift2_##N_##char):  Likewise.\n\t(eoshift2_##N_##char4):  Likewise.\n\t* intrinsics/reshape_generic.c (reshape_internal):  Use array\n\taccess macross for accessing array descriptors.\n\t* libgfortran.h:  Introduce new macros GFC_DIMENSION_LBOUND,\n\tGFC_DIMENSION_UBOUND,GFC_DIMENSION_STRIDE, GFC_DIMENSION_EXTENT,\n\tGFC_DIMENSION_SET, GFC_DESCRIPTOR_LBOUND, GFC_DESCRIPTOR_UBOUND,\n\tGFC_DESCRIPTOR_EXTENT, GFC_DESCRIPTOR_EXTENT_BYTES,\n\tGFC_DESCRIPTOR_STRIDE, GFC_DESCRIPTOR_STRIDE_BYTES\n\t* runtime/in_pack_generic.c (internal_pack):  Use new macros\n\tfor array descriptor access.\n\t* runtime/in_unpack_generic.c (internal_unpack):  Likewise.\n\t* intrinsics/dtime.c (dtime_sub):  Likewise.\n\t* intrinsics/cshift0 (cshift0):  Remove argument size,\n\tcalculate directly from the array descriptor.  Use new macros\n\tfor array descriptor access.\n\t* cshift0_##N:  Remove shift argument in call to cshift0.\n\t* cshift0_##N_char:  Mark array_length as unused.  Remove\n\tarray_length in call to cshift0.\n\t* cshift0_##N_char4:  Likewise.\n\t* intrisics/etime.c:  Use new macros for array descriptor access.\n\t* intrinsics/stat.c (stat_i4_sub_0):  Likewise.\n\t(stat_i8_sub_0):  Likewise.\n\t(fstat_i4_sub):  Likewise.\n\t(fstat_i8_sub):  Likewise.\n\t* intrinsics/date_and_time.c (date_and_time):  Likewise.\n\t(secnds):  Likewise.\n\t(itime_i4):  Likewise.\n\t(itime_i8):  Likewise.\n\t(idate_i4):  Likewise.\n\t(idate_i8):  Likewise.\n\t(gmtime_i4):  Likewise.\n\t(gmtime_i8):  Likewise.\n\t(ltime_i4):  Likewise.\n\t(litme_i8):  Likewise.\n\t* intrinsics/associated.c (associated):  Likewise.\n\t* intrinsics/eoshift0.c (eoshift0):  Likewise.\n\t* intriniscs/size.c (size0):  Likewise.\n\t* intrinsics/random.c (arandom_r4):  Likewise.\n\t(arandom_r8):  Likewise.\n\t(arandom_r10):  Likewise.\n\t(arandom_r16):  Likewise.\n\t(random_seed_i4):  Likewise.\n\t(random_seed_i8):  Likewise.\n\t* io/list_read.c (nml_parse_qualifier):  Likewise.\n\t(nml_touch_nodes):  Likewise.\n\t(nml_read_obj):  Likewise.\n\t(get_name):  Likewise.\n\t* io/transfer.c (transfer_array):  Likewise.\n\t(init_loop_spec):  Likewise.\n\t(st_set_nml_var_dim):  Likewise.\n\t* io/write.c (nml_write_obj):  Likewise.\n\t(obj_loop):  Likewise.\n\t* generated/all_l1.c: Regenerated.\n\t* generated/all_l16.c: Regenerated.\n\t* generated/all_l2.c: Regenerated.\n\t* generated/all_l4.c: Regenerated.\n\t* generated/all_l8.c: Regenerated.\n\t* generated/any_l1.c: Regenerated.\n\t* generated/any_l16.c: Regenerated.\n\t* generated/any_l2.c: Regenerated.\n\t* generated/any_l4.c: Regenerated.\n\t* generated/any_l8.c: Regenerated.\n\t* generated/count_16_l.c: Regenerated.\n\t* generated/count_1_l.c: Regenerated.\n\t* generated/count_2_l.c: Regenerated.\n\t* generated/count_4_l.c: Regenerated.\n\t* generated/count_8_l.c: Regenerated.\n\t* generated/cshift0_c10.c: Regenerated.\n\t* generated/cshift0_c16.c: Regenerated.\n\t* generated/cshift0_c4.c: Regenerated.\n\t* generated/cshift0_c8.c: Regenerated.\n\t* generated/cshift0_i1.c: Regenerated.\n\t* generated/cshift0_i16.c: Regenerated.\n\t* generated/cshift0_i2.c: Regenerated.\n\t* generated/cshift0_i4.c: Regenerated.\n\t* generated/cshift0_i8.c: Regenerated.\n\t* generated/cshift0_r10.c: Regenerated.\n\t* generated/cshift0_r16.c: Regenerated.\n\t* generated/cshift0_r4.c: Regenerated.\n\t* generated/cshift0_r8.c: Regenerated.\n\t* generated/cshift1_16.c: Regenerated.\n\t* generated/cshift1_4.c: Regenerated.\n\t* generated/cshift1_8.c: Regenerated.\n\t* generated/eoshift1_16.c: Regenerated.\n\t* generated/eoshift1_4.c: Regenerated.\n\t* generated/eoshift1_8.c: Regenerated.\n\t* generated/eoshift3_16.c: Regenerated.\n\t* generated/eoshift3_4.c: Regenerated.\n\t* generated/eoshift3_8.c: Regenerated.\n\t* generated/in_pack_c10.c: Regenerated.\n\t* generated/in_pack_c16.c: Regenerated.\n\t* generated/in_pack_c4.c: Regenerated.\n\t* generated/in_pack_c8.c: Regenerated.\n\t* generated/in_pack_i1.c: Regenerated.\n\t* generated/in_pack_i16.c: Regenerated.\n\t* generated/in_pack_i2.c: Regenerated.\n\t* generated/in_pack_i4.c: Regenerated.\n\t* generated/in_pack_i8.c: Regenerated.\n\t* generated/in_pack_r10.c: Regenerated.\n\t* generated/in_pack_r16.c: Regenerated.\n\t* generated/in_pack_r4.c: Regenerated.\n\t* generated/in_pack_r8.c: Regenerated.\n\t* generated/in_unpack_c10.c: Regenerated.\n\t* generated/in_unpack_c16.c: Regenerated.\n\t* generated/in_unpack_c4.c: Regenerated.\n\t* generated/in_unpack_c8.c: Regenerated.\n\t* generated/in_unpack_i1.c: Regenerated.\n\t* generated/in_unpack_i16.c: Regenerated.\n\t* generated/in_unpack_i2.c: Regenerated.\n\t* generated/in_unpack_i4.c: Regenerated.\n\t* generated/in_unpack_i8.c: Regenerated.\n\t* generated/in_unpack_r10.c: Regenerated.\n\t* generated/in_unpack_r16.c: Regenerated.\n\t* generated/in_unpack_r4.c: Regenerated.\n\t* generated/in_unpack_r8.c: Regenerated.\n\t* generated/matmul_c10.c: Regenerated.\n\t* generated/matmul_c16.c: Regenerated.\n\t* generated/matmul_c4.c: Regenerated.\n\t* generated/matmul_c8.c: Regenerated.\n\t* generated/matmul_i1.c: Regenerated.\n\t* generated/matmul_i16.c: Regenerated.\n\t* generated/matmul_i2.c: Regenerated.\n\t* generated/matmul_i4.c: Regenerated.\n\t* generated/matmul_i8.c: Regenerated.\n\t* generated/matmul_l16.c: Regenerated.\n\t* generated/matmul_l4.c: Regenerated.\n\t* generated/matmul_l8.c: Regenerated.\n\t* generated/matmul_r10.c: Regenerated.\n\t* generated/matmul_r16.c: Regenerated.\n\t* generated/matmul_r4.c: Regenerated.\n\t* generated/matmul_r8.c: Regenerated.\n\t* generated/maxloc0_16_i1.c: Regenerated.\n\t* generated/maxloc0_16_i16.c: Regenerated.\n\t* generated/maxloc0_16_i2.c: Regenerated.\n\t* generated/maxloc0_16_i4.c: Regenerated.\n\t* generated/maxloc0_16_i8.c: Regenerated.\n\t* generated/maxloc0_16_r10.c: Regenerated.\n\t* generated/maxloc0_16_r16.c: Regenerated.\n\t* generated/maxloc0_16_r4.c: Regenerated.\n\t* generated/maxloc0_16_r8.c: Regenerated.\n\t* generated/maxloc0_4_i1.c: Regenerated.\n\t* generated/maxloc0_4_i16.c: Regenerated.\n\t* generated/maxloc0_4_i2.c: Regenerated.\n\t* generated/maxloc0_4_i4.c: Regenerated.\n\t* generated/maxloc0_4_i8.c: Regenerated.\n\t* generated/maxloc0_4_r10.c: Regenerated.\n\t* generated/maxloc0_4_r16.c: Regenerated.\n\t* generated/maxloc0_4_r4.c: Regenerated.\n\t* generated/maxloc0_4_r8.c: Regenerated.\n\t* generated/maxloc0_8_i1.c: Regenerated.\n\t* generated/maxloc0_8_i16.c: Regenerated.\n\t* generated/maxloc0_8_i2.c: Regenerated.\n\t* generated/maxloc0_8_i4.c: Regenerated.\n\t* generated/maxloc0_8_i8.c: Regenerated.\n\t* generated/maxloc0_8_r10.c: Regenerated.\n\t* generated/maxloc0_8_r16.c: Regenerated.\n\t* generated/maxloc0_8_r4.c: Regenerated.\n\t* generated/maxloc0_8_r8.c: Regenerated.\n\t* generated/maxloc1_16_i1.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i2.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_4_i1.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i2.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_8_i1.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i2.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxval_i1.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i2.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc0_16_i1.c: Regenerated.\n\t* generated/minloc0_16_i16.c: Regenerated.\n\t* generated/minloc0_16_i2.c: Regenerated.\n\t* generated/minloc0_16_i4.c: Regenerated.\n\t* generated/minloc0_16_i8.c: Regenerated.\n\t* generated/minloc0_16_r10.c: Regenerated.\n\t* generated/minloc0_16_r16.c: Regenerated.\n\t* generated/minloc0_16_r4.c: Regenerated.\n\t* generated/minloc0_16_r8.c: Regenerated.\n\t* generated/minloc0_4_i1.c: Regenerated.\n\t* generated/minloc0_4_i16.c: Regenerated.\n\t* generated/minloc0_4_i2.c: Regenerated.\n\t* generated/minloc0_4_i4.c: Regenerated.\n\t* generated/minloc0_4_i8.c: Regenerated.\n\t* generated/minloc0_4_r10.c: Regenerated.\n\t* generated/minloc0_4_r16.c: Regenerated.\n\t* generated/minloc0_4_r4.c: Regenerated.\n\t* generated/minloc0_4_r8.c: Regenerated.\n\t* generated/minloc0_8_i1.c: Regenerated.\n\t* generated/minloc0_8_i16.c: Regenerated.\n\t* generated/minloc0_8_i2.c: Regenerated.\n\t* generated/minloc0_8_i4.c: Regenerated.\n\t* generated/minloc0_8_i8.c: Regenerated.\n\t* generated/minloc0_8_r10.c: Regenerated.\n\t* generated/minloc0_8_r16.c: Regenerated.\n\t* generated/minloc0_8_r4.c: Regenerated.\n\t* generated/minloc0_8_r8.c: Regenerated.\n\t* generated/minloc1_16_i1.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i2.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_4_i1.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i2.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_8_i1.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i2.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minval_i1.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i2.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/pack_c10.c: Regenerated.\n\t* generated/pack_c16.c: Regenerated.\n\t* generated/pack_c4.c: Regenerated.\n\t* generated/pack_c8.c: Regenerated.\n\t* generated/pack_i1.c: Regenerated.\n\t* generated/pack_i16.c: Regenerated.\n\t* generated/pack_i2.c: Regenerated.\n\t* generated/pack_i4.c: Regenerated.\n\t* generated/pack_i8.c: Regenerated.\n\t* generated/pack_r10.c: Regenerated.\n\t* generated/pack_r16.c: Regenerated.\n\t* generated/pack_r4.c: Regenerated.\n\t* generated/pack_r8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i1.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i2.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/reshape_c10.c: Regenerated.\n\t* generated/reshape_c16.c: Regenerated.\n\t* generated/reshape_c4.c: Regenerated.\n\t* generated/reshape_c8.c: Regenerated.\n\t* generated/reshape_i16.c: Regenerated.\n\t* generated/reshape_i4.c: Regenerated.\n\t* generated/reshape_i8.c: Regenerated.\n\t* generated/reshape_r10.c: Regenerated.\n\t* generated/reshape_r16.c: Regenerated.\n\t* generated/reshape_r4.c: Regenerated.\n\t* generated/reshape_r8.c: Regenerated.\n\t* generated/shape_i16.c: Regenerated.\n\t* generated/shape_i4.c: Regenerated.\n\t* generated/shape_i8.c: Regenerated.\n\t* generated/spread_c10.c: Regenerated.\n\t* generated/spread_c16.c: Regenerated.\n\t* generated/spread_c4.c: Regenerated.\n\t* generated/spread_c8.c: Regenerated.\n\t* generated/spread_i1.c: Regenerated.\n\t* generated/spread_i16.c: Regenerated.\n\t* generated/spread_i2.c: Regenerated.\n\t* generated/spread_i4.c: Regenerated.\n\t* generated/spread_i8.c: Regenerated.\n\t* generated/spread_r10.c: Regenerated.\n\t* generated/spread_r16.c: Regenerated.\n\t* generated/spread_r4.c: Regenerated.\n\t* generated/spread_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i1.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i2.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\t* generated/transpose_c10.c: Regenerated.\n\t* generated/transpose_c16.c: Regenerated.\n\t* generated/transpose_c4.c: Regenerated.\n\t* generated/transpose_c8.c: Regenerated.\n\t* generated/transpose_i16.c: Regenerated.\n\t* generated/transpose_i4.c: Regenerated.\n\t* generated/transpose_i8.c: Regenerated.\n\t* generated/transpose_r10.c: Regenerated.\n\t* generated/transpose_r16.c: Regenerated.\n\t* generated/transpose_r4.c: Regenerated.\n\t* generated/transpose_r8.c: Regenerated.\n\t* generated/unpack_c10.c: Regenerated.\n\t* generated/unpack_c16.c: Regenerated.\n\t* generated/unpack_c4.c: Regenerated.\n\t* generated/unpack_c8.c: Regenerated.\n\t* generated/unpack_i1.c: Regenerated.\n\t* generated/unpack_i16.c: Regenerated.\n\t* generated/unpack_i2.c: Regenerated.\n\t* generated/unpack_i4.c: Regenerated.\n\t* generated/unpack_i8.c: Regenerated.\n\t* generated/unpack_r10.c: Regenerated.\n\t* generated/unpack_r16.c: Regenerated.\n\t* generated/unpack_r4.c: Regenerated.\n\t* generated/unpack_r8.c: Regenerated.\n\nFrom-SVN: r148769", "tree": {"sha": "0f6ecc4005b1035630f9b5894ef6e31b9a0fc204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f6ecc4005b1035630f9b5894ef6e31b9a0fc204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/comments", "author": null, "committer": null, "parents": [{"sha": "ee372c4b96b57028beb3c22db6a8283916df15a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee372c4b96b57028beb3c22db6a8283916df15a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee372c4b96b57028beb3c22db6a8283916df15a6"}], "stats": {"total": 18821, "additions": 9238, "deletions": 9583}, "files": [{"sha": "4b4a3535d261f1c6f230c86136015cc8f37afb1a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -1,3 +1,455 @@\n+2009-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/37577\n+\tPort from fortran-dev\n+\t* runtime/in_pack_generic (internal_pack):  Remove unnecessary\n+\ttest for stride == 0.\n+\t* runtime/in_unpack_generic.c (internal_unpack):  Likewise.\n+\t* intrinsics/iso_c_binding.c (c_f_pointer_u0):  Take care\n+\tof stride in \"shape\" argument.  Use array access macros for\n+\taccessing array descriptors.\n+\t* libgfortran.h (struct descriptor_dimension):  Change stride\n+\tto _stride, lbound to _lbound and ubound to _ubound.\n+\t(GFC_DIMENSION_LBOUND):  Use new name(s) in struct\n+\tdescriptor_dimension.\n+\t(GFC_DIMENSION_UBOUND):  Likewise.\n+\t(GFC_DIMENSION_STRIDE):  Likewise.\n+\t(GFC_DIMENSION_EXTENT):  Likewise.\n+\t(GFC_DIMENSION_SET):  Likewise.\n+\t(GFC_DESCRIPTOR_LBOUND):  Likewise.\n+\t(GFC_DESCRIPTOR_UBOUND):  Likewise.\n+\t(GFC_DESCRIPTOR_EXTENT):  Likewise.\n+\t(GFC_DESCRIPTOR_STRIDE):  Likewise.\n+\t* io/transfer.c (transfer_array):  Use array access macros.\n+\tUse byte-sized strides.\n+\t* intrinsics/eoshift0.c (eoshift0):  Use array access\n+\tmacros everywhere.\n+\t* m4/in_pack.m4 (internal_pack_'rtype_ccode`):  Use\n+\tarray access macros for accessing array descriptors.\n+\t* m4/in_unpack.m4 (internal_unpack_'rtype_ccode`):\n+\tLikewise.\n+\t* m4/matmull.m4 (matmul_'rtype_code`):  Likewise.\n+\t* m4/matmul.m4 (matmul_'rtype_code`):  Likewise.\n+\t* m4/unpack.m4 (unpack0_'rtype_code`):  Likewise.\n+\t(unpack1_'rtype_code`):  Likewise.\n+\t* m4/ifunction_logical.m4 (name`'rtype_qual`_'atype_code): Likewise.\n+\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code): Use array access\n+\tmacros everywhere.\n+\t\t* intrinsics/dtime.c (dtime_sub):  Use array access macros\n+\tfor accessing array descriptors.\n+\t* intrinsics/cshift0 (cshift0):  Likewise.\n+\t* intrinsics/etime.c:  Likewise.  Remove redundant calculation\n+\tof rdim.\n+\t* m4/cshift0.m4 (cshift0_'rtype_code`):  Use array access macros\n+\tfor accessing array descriptors.\n+\t* m4/pack.m4 (pack_'rtype_code`):  Likewise.\n+\t* m4/spread.m4 (spread_'rtype_code`):  Likewise.\n+\t(spread_scalar_'rtype_code`):  Likewise.\n+\t* m4/transpose.m4 (transpose_'rtype_code`):  Likewise.\n+\t* m4/iforeach.m4 (name`'rtype_qual`_'atype_code):  Likewise.\n+\t* m4/eoshift1.m4 (eoshift1):  Likewise.  Remove size argument,\n+\tcalculate within function.\n+\t(eoshift1_'atype_kind`):  Remove size argument from call\n+\tto eoshift1.\n+\t(eoshift1_'atype_kind`_char):  Likewise.\n+\t(eoshift1_'atype_kind`_char4):  Likewise.\n+\t* m4/eoshift3.m4 (eoshift3):  Remove size argument, calculate\n+\twithin function. Use array access macros for accessing array\n+\tdescriptors.\n+\t(eoshift3_'atype_kind`):  Remove size argument from call\n+\tto eoshift1.\n+\t(eoshift3_'atype_kind`_char):  Likewise.\n+\t(eoshift3_'atype_kind`_char4):  Likewise.\n+\t* m4/shape.m4 (shape_'rtype_kind`):  Use array access macros\n+\tfor accessing array descriptors.\n+\t* m4/cshift1.m4 (cshift1): Remove size argument, calculate\n+\twithin function. Use array access macros for accessing array\n+\tdescriptors.\n+\t(cshift1_'atype_kind`):  Remove size argument from call to\n+\tcshift1.\n+\t(cshift1_'atype_kind`_char):  Remove size argument from call to\n+\tcshift1.\n+\t(cshift1_'atype_kind`_char4):  Remove size argument from call to\n+\tcshift1.\n+\t* m4/reshape.m4 (reshape_'rtype_ccode`):  Use array access macros\n+\tfor accessing array descriptors.\n+\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code):  Likewise.\n+\t* intrinsics/pack_generic.c (pack_internal):  Use array access\n+\tmacros for accessing array descriptors.\n+\t(pack_s_internal):  Likewise.\n+\t* intrinsics/transpose_generic.c (transpose_internal):  Remove\n+\tsize argument, calculate from array descriptor. Use array\n+\taccess macros for accessing array descriptors.\n+\t(transpose):  Remove size argument from call.\n+\t(transpoe_char):  Likewise.\n+\t(transpose_char4):  Likewise.\n+\t* intrinsics/move_alloc.c (move_alloc):  Use array access macros\n+\tfor accessing array descriptors.\n+\t* intrinsics/spread_generic.c (spread_internal):  Remove size\n+\targument, calculate from array descriptor.  Use array access\n+\tmacros for accessing array descriptors.\n+\t(spread_internal_scalar):  Likewise.\n+\t(spread):  Remove size argument from call to spread_internal.\n+\t(spread_char):  Mark argument source_length as unused.\n+\tRemove size argument from call to spread_internal.\n+\t(spread_char4):  Likewise.\n+\t(spread_char_scalar):  Likewise.\n+\t(spread_char4_scalar):  Likewise.\n+\t* intrinsics/unpack_generic.c (unpack_internal):  Use array access\n+\tmacros for accessing array descriptors.\n+\t* intrinsics/eoshift2.c (eoshift2):  Remove size argument, calculate\n+\tfrom array descriptor instead.  Use array access macros for\n+\taccessing array descriptors.\n+\t(eoshift2_##N):  Remove size argument from call to eoshift2.\n+\t(eoshift2_##N_##char):  Likewise.\n+\t(eoshift2_##N_##char4):  Likewise.\n+\t* intrinsics/reshape_generic.c (reshape_internal):  Use array\n+\taccess macross for accessing array descriptors.\n+\t* libgfortran.h:  Introduce new macros GFC_DIMENSION_LBOUND,\n+\tGFC_DIMENSION_UBOUND,GFC_DIMENSION_STRIDE, GFC_DIMENSION_EXTENT,\n+\tGFC_DIMENSION_SET, GFC_DESCRIPTOR_LBOUND, GFC_DESCRIPTOR_UBOUND,\n+\tGFC_DESCRIPTOR_EXTENT, GFC_DESCRIPTOR_EXTENT_BYTES,\n+\tGFC_DESCRIPTOR_STRIDE, GFC_DESCRIPTOR_STRIDE_BYTES\n+\t* runtime/in_pack_generic.c (internal_pack):  Use new macros\n+\tfor array descriptor access.\n+\t* runtime/in_unpack_generic.c (internal_unpack):  Likewise.\n+\t* intrinsics/dtime.c (dtime_sub):  Likewise.\n+\t* intrinsics/cshift0 (cshift0):  Remove argument size,\n+\tcalculate directly from the array descriptor.  Use new macros\n+\tfor array descriptor access.\n+\t* cshift0_##N:  Remove shift argument in call to cshift0.\n+\t* cshift0_##N_char:  Mark array_length as unused.  Remove\n+\tarray_length in call to cshift0.\n+\t* cshift0_##N_char4:  Likewise.\n+\t* intrisics/etime.c:  Use new macros for array descriptor access.\n+\t* intrinsics/stat.c (stat_i4_sub_0):  Likewise.\n+\t(stat_i8_sub_0):  Likewise.\n+\t(fstat_i4_sub):  Likewise.\n+\t(fstat_i8_sub):  Likewise.\n+\t* intrinsics/date_and_time.c (date_and_time):  Likewise.\n+\t(secnds):  Likewise.\n+\t(itime_i4):  Likewise.\n+\t(itime_i8):  Likewise.\n+\t(idate_i4):  Likewise.\n+\t(idate_i8):  Likewise.\n+\t(gmtime_i4):  Likewise.\n+\t(gmtime_i8):  Likewise.\n+\t(ltime_i4):  Likewise.\n+\t(litme_i8):  Likewise.\n+\t* intrinsics/associated.c (associated):  Likewise.\n+\t* intrinsics/eoshift0.c (eoshift0):  Likewise.\n+\t* intriniscs/size.c (size0):  Likewise.\n+\t* intrinsics/random.c (arandom_r4):  Likewise.\n+\t(arandom_r8):  Likewise.\n+\t(arandom_r10):  Likewise.\n+\t(arandom_r16):  Likewise.\n+\t(random_seed_i4):  Likewise.\n+\t(random_seed_i8):  Likewise.\n+\t* io/list_read.c (nml_parse_qualifier):  Likewise.\n+\t(nml_touch_nodes):  Likewise.\n+\t(nml_read_obj):  Likewise.\n+\t(get_name):  Likewise.\n+\t* io/transfer.c (transfer_array):  Likewise.\n+\t(init_loop_spec):  Likewise.\n+\t(st_set_nml_var_dim):  Likewise.\n+\t* io/write.c (nml_write_obj):  Likewise.\n+\t(obj_loop):  Likewise.\n+\t* generated/all_l1.c: Regenerated.\n+\t* generated/all_l16.c: Regenerated.\n+\t* generated/all_l2.c: Regenerated.\n+\t* generated/all_l4.c: Regenerated.\n+\t* generated/all_l8.c: Regenerated.\n+\t* generated/any_l1.c: Regenerated.\n+\t* generated/any_l16.c: Regenerated.\n+\t* generated/any_l2.c: Regenerated.\n+\t* generated/any_l4.c: Regenerated.\n+\t* generated/any_l8.c: Regenerated.\n+\t* generated/count_16_l.c: Regenerated.\n+\t* generated/count_1_l.c: Regenerated.\n+\t* generated/count_2_l.c: Regenerated.\n+\t* generated/count_4_l.c: Regenerated.\n+\t* generated/count_8_l.c: Regenerated.\n+\t* generated/cshift0_c10.c: Regenerated.\n+\t* generated/cshift0_c16.c: Regenerated.\n+\t* generated/cshift0_c4.c: Regenerated.\n+\t* generated/cshift0_c8.c: Regenerated.\n+\t* generated/cshift0_i1.c: Regenerated.\n+\t* generated/cshift0_i16.c: Regenerated.\n+\t* generated/cshift0_i2.c: Regenerated.\n+\t* generated/cshift0_i4.c: Regenerated.\n+\t* generated/cshift0_i8.c: Regenerated.\n+\t* generated/cshift0_r10.c: Regenerated.\n+\t* generated/cshift0_r16.c: Regenerated.\n+\t* generated/cshift0_r4.c: Regenerated.\n+\t* generated/cshift0_r8.c: Regenerated.\n+\t* generated/cshift1_16.c: Regenerated.\n+\t* generated/cshift1_4.c: Regenerated.\n+\t* generated/cshift1_8.c: Regenerated.\n+\t* generated/eoshift1_16.c: Regenerated.\n+\t* generated/eoshift1_4.c: Regenerated.\n+\t* generated/eoshift1_8.c: Regenerated.\n+\t* generated/eoshift3_16.c: Regenerated.\n+\t* generated/eoshift3_4.c: Regenerated.\n+\t* generated/eoshift3_8.c: Regenerated.\n+\t* generated/in_pack_c10.c: Regenerated.\n+\t* generated/in_pack_c16.c: Regenerated.\n+\t* generated/in_pack_c4.c: Regenerated.\n+\t* generated/in_pack_c8.c: Regenerated.\n+\t* generated/in_pack_i1.c: Regenerated.\n+\t* generated/in_pack_i16.c: Regenerated.\n+\t* generated/in_pack_i2.c: Regenerated.\n+\t* generated/in_pack_i4.c: Regenerated.\n+\t* generated/in_pack_i8.c: Regenerated.\n+\t* generated/in_pack_r10.c: Regenerated.\n+\t* generated/in_pack_r16.c: Regenerated.\n+\t* generated/in_pack_r4.c: Regenerated.\n+\t* generated/in_pack_r8.c: Regenerated.\n+\t* generated/in_unpack_c10.c: Regenerated.\n+\t* generated/in_unpack_c16.c: Regenerated.\n+\t* generated/in_unpack_c4.c: Regenerated.\n+\t* generated/in_unpack_c8.c: Regenerated.\n+\t* generated/in_unpack_i1.c: Regenerated.\n+\t* generated/in_unpack_i16.c: Regenerated.\n+\t* generated/in_unpack_i2.c: Regenerated.\n+\t* generated/in_unpack_i4.c: Regenerated.\n+\t* generated/in_unpack_i8.c: Regenerated.\n+\t* generated/in_unpack_r10.c: Regenerated.\n+\t* generated/in_unpack_r16.c: Regenerated.\n+\t* generated/in_unpack_r4.c: Regenerated.\n+\t* generated/in_unpack_r8.c: Regenerated.\n+\t* generated/matmul_c10.c: Regenerated.\n+\t* generated/matmul_c16.c: Regenerated.\n+\t* generated/matmul_c4.c: Regenerated.\n+\t* generated/matmul_c8.c: Regenerated.\n+\t* generated/matmul_i1.c: Regenerated.\n+\t* generated/matmul_i16.c: Regenerated.\n+\t* generated/matmul_i2.c: Regenerated.\n+\t* generated/matmul_i4.c: Regenerated.\n+\t* generated/matmul_i8.c: Regenerated.\n+\t* generated/matmul_l16.c: Regenerated.\n+\t* generated/matmul_l4.c: Regenerated.\n+\t* generated/matmul_l8.c: Regenerated.\n+\t* generated/matmul_r10.c: Regenerated.\n+\t* generated/matmul_r16.c: Regenerated.\n+\t* generated/matmul_r4.c: Regenerated.\n+\t* generated/matmul_r8.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Regenerated.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i2.c: Regenerated.\n+\t* generated/maxloc0_16_i4.c: Regenerated.\n+\t* generated/maxloc0_16_i8.c: Regenerated.\n+\t* generated/maxloc0_16_r10.c: Regenerated.\n+\t* generated/maxloc0_16_r16.c: Regenerated.\n+\t* generated/maxloc0_16_r4.c: Regenerated.\n+\t* generated/maxloc0_16_r8.c: Regenerated.\n+\t* generated/maxloc0_4_i1.c: Regenerated.\n+\t* generated/maxloc0_4_i16.c: Regenerated.\n+\t* generated/maxloc0_4_i2.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc0_4_r10.c: Regenerated.\n+\t* generated/maxloc0_4_r16.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/maxloc0_8_i1.c: Regenerated.\n+\t* generated/maxloc0_8_i16.c: Regenerated.\n+\t* generated/maxloc0_8_i2.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r10.c: Regenerated.\n+\t* generated/maxloc0_8_r16.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc0_16_i1.c: Regenerated.\n+\t* generated/minloc0_16_i16.c: Regenerated.\n+\t* generated/minloc0_16_i2.c: Regenerated.\n+\t* generated/minloc0_16_i4.c: Regenerated.\n+\t* generated/minloc0_16_i8.c: Regenerated.\n+\t* generated/minloc0_16_r10.c: Regenerated.\n+\t* generated/minloc0_16_r16.c: Regenerated.\n+\t* generated/minloc0_16_r4.c: Regenerated.\n+\t* generated/minloc0_16_r8.c: Regenerated.\n+\t* generated/minloc0_4_i1.c: Regenerated.\n+\t* generated/minloc0_4_i16.c: Regenerated.\n+\t* generated/minloc0_4_i2.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minloc0_4_r10.c: Regenerated.\n+\t* generated/minloc0_4_r16.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\t* generated/minloc0_8_i1.c: Regenerated.\n+\t* generated/minloc0_8_i16.c: Regenerated.\n+\t* generated/minloc0_8_i2.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/minloc0_8_r10.c: Regenerated.\n+\t* generated/minloc0_8_r16.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/pack_c10.c: Regenerated.\n+\t* generated/pack_c16.c: Regenerated.\n+\t* generated/pack_c4.c: Regenerated.\n+\t* generated/pack_c8.c: Regenerated.\n+\t* generated/pack_i1.c: Regenerated.\n+\t* generated/pack_i16.c: Regenerated.\n+\t* generated/pack_i2.c: Regenerated.\n+\t* generated/pack_i4.c: Regenerated.\n+\t* generated/pack_i8.c: Regenerated.\n+\t* generated/pack_r10.c: Regenerated.\n+\t* generated/pack_r16.c: Regenerated.\n+\t* generated/pack_r4.c: Regenerated.\n+\t* generated/pack_r8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/reshape_c10.c: Regenerated.\n+\t* generated/reshape_c16.c: Regenerated.\n+\t* generated/reshape_c4.c: Regenerated.\n+\t* generated/reshape_c8.c: Regenerated.\n+\t* generated/reshape_i16.c: Regenerated.\n+\t* generated/reshape_i4.c: Regenerated.\n+\t* generated/reshape_i8.c: Regenerated.\n+\t* generated/reshape_r10.c: Regenerated.\n+\t* generated/reshape_r16.c: Regenerated.\n+\t* generated/reshape_r4.c: Regenerated.\n+\t* generated/reshape_r8.c: Regenerated.\n+\t* generated/shape_i16.c: Regenerated.\n+\t* generated/shape_i4.c: Regenerated.\n+\t* generated/shape_i8.c: Regenerated.\n+\t* generated/spread_c10.c: Regenerated.\n+\t* generated/spread_c16.c: Regenerated.\n+\t* generated/spread_c4.c: Regenerated.\n+\t* generated/spread_c8.c: Regenerated.\n+\t* generated/spread_i1.c: Regenerated.\n+\t* generated/spread_i16.c: Regenerated.\n+\t* generated/spread_i2.c: Regenerated.\n+\t* generated/spread_i4.c: Regenerated.\n+\t* generated/spread_i8.c: Regenerated.\n+\t* generated/spread_r10.c: Regenerated.\n+\t* generated/spread_r16.c: Regenerated.\n+\t* generated/spread_r4.c: Regenerated.\n+\t* generated/spread_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\t* generated/transpose_c10.c: Regenerated.\n+\t* generated/transpose_c16.c: Regenerated.\n+\t* generated/transpose_c4.c: Regenerated.\n+\t* generated/transpose_c8.c: Regenerated.\n+\t* generated/transpose_i16.c: Regenerated.\n+\t* generated/transpose_i4.c: Regenerated.\n+\t* generated/transpose_i8.c: Regenerated.\n+\t* generated/transpose_r10.c: Regenerated.\n+\t* generated/transpose_r16.c: Regenerated.\n+\t* generated/transpose_r4.c: Regenerated.\n+\t* generated/transpose_r8.c: Regenerated.\n+\t* generated/unpack_c10.c: Regenerated.\n+\t* generated/unpack_c16.c: Regenerated.\n+\t* generated/unpack_c4.c: Regenerated.\n+\t* generated/unpack_c8.c: Regenerated.\n+\t* generated/unpack_i1.c: Regenerated.\n+\t* generated/unpack_i16.c: Regenerated.\n+\t* generated/unpack_i2.c: Regenerated.\n+\t* generated/unpack_i4.c: Regenerated.\n+\t* generated/unpack_i8.c: Regenerated.\n+\t* generated/unpack_r10.c: Regenerated.\n+\t* generated/unpack_r16.c: Regenerated.\n+\t* generated/unpack_r4.c: Regenerated.\n+\t* generated/unpack_r8.c: Regenerated.\n+\n 2009-06-14 Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n \n \t* fmain.c (main): Don't PREFIX set_args."}, {"sha": "486bab2e436227fed18d818f90cd0ffa1d27804b", "filename": "libgfortran/generated/all_l1.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ all_l1 (gfc_array_l1 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_1) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ all_l1 (gfc_array_l1 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ALL intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ all_l1 (gfc_array_l1 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "35f8a9621b45443ce32db333bde672fffe991884", "filename": "libgfortran/generated/all_l16.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ALL intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "81532ea431b6a0b003c25093a82eff57a36e1b10", "filename": "libgfortran/generated/all_l2.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ all_l2 (gfc_array_l2 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_2) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ all_l2 (gfc_array_l2 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ALL intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ all_l2 (gfc_array_l2 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "6657e15cd894f06054587729bdeb7bf515ad6533", "filename": "libgfortran/generated/all_l4.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ALL intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "4c3d5563f838102b65678b53f122f4543bea8f06", "filename": "libgfortran/generated/all_l8.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fall_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ALL intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "a69f22e6f82befb7d212eb8dadc52b7b85177b17", "filename": "libgfortran/generated/any_l1.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ any_l1 (gfc_array_l1 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_1) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ any_l1 (gfc_array_l1 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ANY intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ any_l1 (gfc_array_l1 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "b5ab5b214acb9dea03097a17edec64316495da05", "filename": "libgfortran/generated/any_l16.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ANY intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "05673e8daba57723a7c819ce86b4bbe221c15e74", "filename": "libgfortran/generated/any_l2.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ any_l2 (gfc_array_l2 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_2) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ any_l2 (gfc_array_l2 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ANY intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ any_l2 (gfc_array_l2 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "8f82741701fe7933b97803509f7c7a04ba03b30a", "filename": "libgfortran/generated/any_l4.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ANY intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "2a094f0a5fe38e087d587374c1f83971a955c987", "filename": "libgfortran/generated/any_l8.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fany_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_LOGICAL_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" ANY intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "8c3fc7d9a165ca2bd719631ea5ed62a8913a3bb2", "filename": "libgfortran/generated/count_16_l.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_16_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_16_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ count_16_l (gfc_array_i16 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ count_16_l (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" COUNT intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ count_16_l (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "faf9176943c3cac2de23319052251de1044f334b", "filename": "libgfortran/generated/count_1_l.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_1_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_1_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_1_l.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ count_1_l (gfc_array_i1 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ count_1_l (gfc_array_i1 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" COUNT intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ count_1_l (gfc_array_i1 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "0d1a22339e9edc294301c45eeccfd6c943e8856c", "filename": "libgfortran/generated/count_2_l.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_2_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_2_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_2_l.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ count_2_l (gfc_array_i2 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ count_2_l (gfc_array_i2 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" COUNT intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ count_2_l (gfc_array_i2 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "d4bfbd47ef34a119d9f5d6bf89fbe5e04ffcb64b", "filename": "libgfortran/generated/count_4_l.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_4_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_4_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ count_4_l (gfc_array_i4 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ count_4_l (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" COUNT intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ count_4_l (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "2a62ea87bd4894fb3915513a771b50a69e774d5d", "filename": "libgfortran/generated/count_8_l.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_8_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcount_8_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -60,55 +60,54 @@ count_8_l (gfc_array_i8 * const restrict retarray,\n \n   src_kind = GFC_DESCRIPTOR_SIZE (array);\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n \n-  delta = array->dim[dim].stride * src_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride * src_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride * src_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -128,8 +127,7 @@ count_8_l (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" COUNT intrinsic in dimension %d:\"\n@@ -142,7 +140,7 @@ count_8_l (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }"}, {"sha": "16c113deb6055807507a7f3d7fcb536d6d83dc23", "filename": "libgfortran/generated/cshift0_c10.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "df83ccb85f4431fa0b21156f013907bf321b77a6", "filename": "libgfortran/generated/cshift0_c16.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "52d277f1ce328dda8c64bce1dcfafb6e1841e368", "filename": "libgfortran/generated/cshift0_c4.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "9b9c3b2acced65e4b01e88b4bf2845720f0726bd", "filename": "libgfortran/generated/cshift0_c8.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "7ed44bddb781c9b728e6d65f47c9af532e2b16e1", "filename": "libgfortran/generated/cshift0_i1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "145724b6e81931e57292a4ef90e723fbc7fc4866", "filename": "libgfortran/generated/cshift0_i16.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "df3328175574f0d108823474dc39d0952487ad6d", "filename": "libgfortran/generated/cshift0_i2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "a1e118589c55cbabcd8c4525878a9521e2232073", "filename": "libgfortran/generated/cshift0_i4.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "cbe13f153f34c6f43f6da9287a3dd275f21bfb28", "filename": "libgfortran/generated/cshift0_i8.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "8ba544d2d8e90996c7bcdf53ce46b9ed6b1184dd", "filename": "libgfortran/generated/cshift0_r10.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "0725048c2abfe8046a383fbc311a026e2e99772f", "filename": "libgfortran/generated/cshift0_r16.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "515c36b41fca74b9d8ea3be06e11d92f843267b5", "filename": "libgfortran/generated/cshift0_r4.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "5a721e495897667c961bae7b22b437ec67f3c862", "filename": "libgfortran/generated/cshift0_r8.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift0_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,20 +69,20 @@ cshift0_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array, ssize_t shift,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride;\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n           if (roffset == 0)\n             roffset = 1;\n-          soffset = array->dim[dim].stride;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n           if (soffset == 0)\n             soffset = 1;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride;\n-          sstride[n] = array->dim[dim].stride;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n           n++;\n         }\n     }"}, {"sha": "df97dfa6b76866f7f17f38dad41e3333452acfd9", "filename": "libgfortran/generated/cshift1_16.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -35,8 +35,7 @@ static void\n cshift1 (gfc_array_char * const restrict ret, \n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i16 * const restrict h, \n-\tconst GFC_INTEGER_16 * const restrict pwhich, \n-\tindex_type size)\n+\tconst GFC_INTEGER_16 * const restrict pwhich)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -63,6 +62,7 @@ cshift1 (gfc_array_char * const restrict ret,\n   int which;\n   GFC_INTEGER_16 sh;\n   index_type arraysize;\n+  index_type size;\n \n   if (pwhich)\n     which = *pwhich - 1;\n@@ -72,6 +72,8 @@ cshift1 (gfc_array_char * const restrict ret,\n   if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   arraysize = size0 ((array_t *)array);\n \n   if (ret->data == NULL)\n@@ -83,13 +85,17 @@ cshift1 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+          ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+\t    str = GFC_DESCRIPTOR_EXTENT(ret,i-1) *\n+\t      GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n         }\n     }\n \n@@ -109,22 +115,22 @@ cshift1 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           n++;\n         }\n     }\n@@ -210,7 +216,7 @@ cshift1_16 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i16 * const restrict h, \n \tconst GFC_INTEGER_16 * const restrict pwhich)\n {\n-  cshift1 (ret, array, h, pwhich, GFC_DESCRIPTOR_SIZE (array));\n+  cshift1 (ret, array, h, pwhich);\n }\n \n \n@@ -228,9 +234,9 @@ cshift1_16_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i16 * const restrict h, \n \tconst GFC_INTEGER_16 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length)\n+\tGFC_INTEGER_4 array_length __attribute__((unused)))\n {\n-  cshift1 (ret, array, h, pwhich, array_length);\n+  cshift1 (ret, array, h, pwhich);\n }\n \n \n@@ -248,9 +254,9 @@ cshift1_16_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i16 * const restrict h, \n \tconst GFC_INTEGER_16 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length)\n+\tGFC_INTEGER_4 array_length __attribute__((unused)))\n {\n-  cshift1 (ret, array, h, pwhich, array_length * sizeof (gfc_char4_t));\n+  cshift1 (ret, array, h, pwhich);\n }\n \n #endif"}, {"sha": "f048e8e401f17ccf659c470c75e5d9fdd2d7f4d5", "filename": "libgfortran/generated/cshift1_4.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -35,8 +35,7 @@ static void\n cshift1 (gfc_array_char * const restrict ret, \n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i4 * const restrict h, \n-\tconst GFC_INTEGER_4 * const restrict pwhich, \n-\tindex_type size)\n+\tconst GFC_INTEGER_4 * const restrict pwhich)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -63,6 +62,7 @@ cshift1 (gfc_array_char * const restrict ret,\n   int which;\n   GFC_INTEGER_4 sh;\n   index_type arraysize;\n+  index_type size;\n \n   if (pwhich)\n     which = *pwhich - 1;\n@@ -72,6 +72,8 @@ cshift1 (gfc_array_char * const restrict ret,\n   if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   arraysize = size0 ((array_t *)array);\n \n   if (ret->data == NULL)\n@@ -83,13 +85,17 @@ cshift1 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+          ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+\t    str = GFC_DESCRIPTOR_EXTENT(ret,i-1) *\n+\t      GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n         }\n     }\n \n@@ -109,22 +115,22 @@ cshift1 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           n++;\n         }\n     }\n@@ -210,7 +216,7 @@ cshift1_4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i4 * const restrict h, \n \tconst GFC_INTEGER_4 * const restrict pwhich)\n {\n-  cshift1 (ret, array, h, pwhich, GFC_DESCRIPTOR_SIZE (array));\n+  cshift1 (ret, array, h, pwhich);\n }\n \n \n@@ -228,9 +234,9 @@ cshift1_4_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i4 * const restrict h, \n \tconst GFC_INTEGER_4 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length)\n+\tGFC_INTEGER_4 array_length __attribute__((unused)))\n {\n-  cshift1 (ret, array, h, pwhich, array_length);\n+  cshift1 (ret, array, h, pwhich);\n }\n \n \n@@ -248,9 +254,9 @@ cshift1_4_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i4 * const restrict h, \n \tconst GFC_INTEGER_4 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length)\n+\tGFC_INTEGER_4 array_length __attribute__((unused)))\n {\n-  cshift1 (ret, array, h, pwhich, array_length * sizeof (gfc_char4_t));\n+  cshift1 (ret, array, h, pwhich);\n }\n \n #endif"}, {"sha": "9667728f3921b5d959cd1efe01d8c55e65a51c33", "filename": "libgfortran/generated/cshift1_8.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fcshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -35,8 +35,7 @@ static void\n cshift1 (gfc_array_char * const restrict ret, \n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i8 * const restrict h, \n-\tconst GFC_INTEGER_8 * const restrict pwhich, \n-\tindex_type size)\n+\tconst GFC_INTEGER_8 * const restrict pwhich)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -63,6 +62,7 @@ cshift1 (gfc_array_char * const restrict ret,\n   int which;\n   GFC_INTEGER_8 sh;\n   index_type arraysize;\n+  index_type size;\n \n   if (pwhich)\n     which = *pwhich - 1;\n@@ -72,6 +72,8 @@ cshift1 (gfc_array_char * const restrict ret,\n   if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   arraysize = size0 ((array_t *)array);\n \n   if (ret->data == NULL)\n@@ -83,13 +85,17 @@ cshift1 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+          ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+\t    str = GFC_DESCRIPTOR_EXTENT(ret,i-1) *\n+\t      GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n         }\n     }\n \n@@ -109,22 +115,22 @@ cshift1 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           n++;\n         }\n     }\n@@ -210,7 +216,7 @@ cshift1_8 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i8 * const restrict h, \n \tconst GFC_INTEGER_8 * const restrict pwhich)\n {\n-  cshift1 (ret, array, h, pwhich, GFC_DESCRIPTOR_SIZE (array));\n+  cshift1 (ret, array, h, pwhich);\n }\n \n \n@@ -228,9 +234,9 @@ cshift1_8_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i8 * const restrict h, \n \tconst GFC_INTEGER_8 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length)\n+\tGFC_INTEGER_4 array_length __attribute__((unused)))\n {\n-  cshift1 (ret, array, h, pwhich, array_length);\n+  cshift1 (ret, array, h, pwhich);\n }\n \n \n@@ -248,9 +254,9 @@ cshift1_8_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict array,\n \tconst gfc_array_i8 * const restrict h, \n \tconst GFC_INTEGER_8 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length)\n+\tGFC_INTEGER_4 array_length __attribute__((unused)))\n {\n-  cshift1 (ret, array, h, pwhich, array_length * sizeof (gfc_char4_t));\n+  cshift1 (ret, array, h, pwhich);\n }\n \n #endif"}, {"sha": "02365cc237534f0de4cf73f63f377c6125a12363", "filename": "libgfortran/generated/eoshift1_16.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -37,7 +37,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i16 * const restrict h,\n \tconst char * const restrict pbound, \n \tconst GFC_INTEGER_16 * const restrict pwhich, \n-\tindex_type size, const char * filler, index_type filler_len)\n+\tconst char * filler, index_type filler_len)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -61,6 +61,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   index_type dim;\n   index_type len;\n   index_type n;\n+  index_type size;\n   int which;\n   GFC_INTEGER_16 sh;\n   GFC_INTEGER_16 delta;\n@@ -71,6 +72,8 @@ eoshift1 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   if (pwhich)\n     which = *pwhich - 1;\n   else\n@@ -88,13 +91,18 @@ eoshift1 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+\t  ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+            str = GFC_DESCRIPTOR_EXTENT(ret,i-1)\n+\t      * GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n+\n         }\n     }\n   else\n@@ -108,22 +116,22 @@ eoshift1 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           n++;\n         }\n     }\n@@ -241,8 +249,7 @@ eoshift1_16 (gfc_array_char * const restrict ret,\n \tconst char * const restrict pbound,\n \tconst GFC_INTEGER_16 * const restrict pwhich)\n {\n-  eoshift1 (ret, array, h, pbound, pwhich, GFC_DESCRIPTOR_SIZE (array),\n-\t    \"\\0\", 1);\n+  eoshift1 (ret, array, h, pbound, pwhich, \"\\0\", 1);\n }\n \n \n@@ -262,10 +269,10 @@ eoshift1_16_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_i16 * const restrict h,\n \tconst char *  const restrict pbound, \n \tconst GFC_INTEGER_16 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n-  eoshift1 (ret, array, h, pbound, pwhich, array_length, \" \", 1);\n+  eoshift1 (ret, array, h, pbound, pwhich, \" \", 1);\n }\n \n \n@@ -285,11 +292,11 @@ eoshift1_16_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i16 * const restrict h,\n \tconst char *  const restrict pbound, \n \tconst GFC_INTEGER_16 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n   static const gfc_char4_t space = (unsigned char) ' ';\n-  eoshift1 (ret, array, h, pbound, pwhich, array_length * sizeof (gfc_char4_t),\n+  eoshift1 (ret, array, h, pbound, pwhich,\n \t    (const char *) &space, sizeof (gfc_char4_t));\n }\n "}, {"sha": "e703db477861570617677de6b6f192ab26b67126", "filename": "libgfortran/generated/eoshift1_4.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -37,7 +37,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i4 * const restrict h,\n \tconst char * const restrict pbound, \n \tconst GFC_INTEGER_4 * const restrict pwhich, \n-\tindex_type size, const char * filler, index_type filler_len)\n+\tconst char * filler, index_type filler_len)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -61,6 +61,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   index_type dim;\n   index_type len;\n   index_type n;\n+  index_type size;\n   int which;\n   GFC_INTEGER_4 sh;\n   GFC_INTEGER_4 delta;\n@@ -71,6 +72,8 @@ eoshift1 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   if (pwhich)\n     which = *pwhich - 1;\n   else\n@@ -88,13 +91,18 @@ eoshift1 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+\t  ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+            str = GFC_DESCRIPTOR_EXTENT(ret,i-1)\n+\t      * GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n+\n         }\n     }\n   else\n@@ -108,22 +116,22 @@ eoshift1 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           n++;\n         }\n     }\n@@ -241,8 +249,7 @@ eoshift1_4 (gfc_array_char * const restrict ret,\n \tconst char * const restrict pbound,\n \tconst GFC_INTEGER_4 * const restrict pwhich)\n {\n-  eoshift1 (ret, array, h, pbound, pwhich, GFC_DESCRIPTOR_SIZE (array),\n-\t    \"\\0\", 1);\n+  eoshift1 (ret, array, h, pbound, pwhich, \"\\0\", 1);\n }\n \n \n@@ -262,10 +269,10 @@ eoshift1_4_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_i4 * const restrict h,\n \tconst char *  const restrict pbound, \n \tconst GFC_INTEGER_4 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n-  eoshift1 (ret, array, h, pbound, pwhich, array_length, \" \", 1);\n+  eoshift1 (ret, array, h, pbound, pwhich, \" \", 1);\n }\n \n \n@@ -285,11 +292,11 @@ eoshift1_4_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i4 * const restrict h,\n \tconst char *  const restrict pbound, \n \tconst GFC_INTEGER_4 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n   static const gfc_char4_t space = (unsigned char) ' ';\n-  eoshift1 (ret, array, h, pbound, pwhich, array_length * sizeof (gfc_char4_t),\n+  eoshift1 (ret, array, h, pbound, pwhich,\n \t    (const char *) &space, sizeof (gfc_char4_t));\n }\n "}, {"sha": "f8922b344a5c546b92092b9f624ece34d1bb9da1", "filename": "libgfortran/generated/eoshift1_8.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -37,7 +37,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i8 * const restrict h,\n \tconst char * const restrict pbound, \n \tconst GFC_INTEGER_8 * const restrict pwhich, \n-\tindex_type size, const char * filler, index_type filler_len)\n+\tconst char * filler, index_type filler_len)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -61,6 +61,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   index_type dim;\n   index_type len;\n   index_type n;\n+  index_type size;\n   int which;\n   GFC_INTEGER_8 sh;\n   GFC_INTEGER_8 delta;\n@@ -71,6 +72,8 @@ eoshift1 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   if (pwhich)\n     which = *pwhich - 1;\n   else\n@@ -88,13 +91,18 @@ eoshift1 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+\t  ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+            str = GFC_DESCRIPTOR_EXTENT(ret,i-1)\n+\t      * GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n+\n         }\n     }\n   else\n@@ -108,22 +116,22 @@ eoshift1 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           n++;\n         }\n     }\n@@ -241,8 +249,7 @@ eoshift1_8 (gfc_array_char * const restrict ret,\n \tconst char * const restrict pbound,\n \tconst GFC_INTEGER_8 * const restrict pwhich)\n {\n-  eoshift1 (ret, array, h, pbound, pwhich, GFC_DESCRIPTOR_SIZE (array),\n-\t    \"\\0\", 1);\n+  eoshift1 (ret, array, h, pbound, pwhich, \"\\0\", 1);\n }\n \n \n@@ -262,10 +269,10 @@ eoshift1_8_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_i8 * const restrict h,\n \tconst char *  const restrict pbound, \n \tconst GFC_INTEGER_8 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n-  eoshift1 (ret, array, h, pbound, pwhich, array_length, \" \", 1);\n+  eoshift1 (ret, array, h, pbound, pwhich, \" \", 1);\n }\n \n \n@@ -285,11 +292,11 @@ eoshift1_8_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i8 * const restrict h,\n \tconst char *  const restrict pbound, \n \tconst GFC_INTEGER_8 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n   static const gfc_char4_t space = (unsigned char) ' ';\n-  eoshift1 (ret, array, h, pbound, pwhich, array_length * sizeof (gfc_char4_t),\n+  eoshift1 (ret, array, h, pbound, pwhich,\n \t    (const char *) &space, sizeof (gfc_char4_t));\n }\n "}, {"sha": "c3efae9acbfeebea3b7b23b94ec5621e5c773d73", "filename": "libgfortran/generated/eoshift3_16.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift3_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift3_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -37,7 +37,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i16 * const restrict h,\n \tconst gfc_array_char * const restrict bound, \n \tconst GFC_INTEGER_16 * const restrict pwhich,\n-\tindex_type size, const char * filler, index_type filler_len)\n+\tconst char * filler, index_type filler_len)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -65,6 +65,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   index_type dim;\n   index_type len;\n   index_type n;\n+  index_type size;\n   int which;\n   GFC_INTEGER_16 sh;\n   GFC_INTEGER_16 delta;\n@@ -75,6 +76,8 @@ eoshift3 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   if (pwhich)\n     which = *pwhich - 1;\n   else\n@@ -89,13 +92,18 @@ eoshift3 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+\t  ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+            str = GFC_DESCRIPTOR_EXTENT(ret,i-1)\n+\t      * GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n+\n         }\n     }\n   else\n@@ -112,24 +120,24 @@ eoshift3 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           if (bound)\n-            bstride[n] = bound->dim[n].stride * size;\n+            bstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(bound,n);\n           else\n             bstride[n] = 0;\n           n++;\n@@ -260,8 +268,7 @@ eoshift3_16 (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_16 * const restrict pwhich)\n {\n-  eoshift3 (ret, array, h, bound, pwhich, GFC_DESCRIPTOR_SIZE (array),\n-\t    \"\\0\", 1);\n+  eoshift3 (ret, array, h, bound, pwhich, \"\\0\", 1);\n }\n \n \n@@ -281,10 +288,10 @@ eoshift3_16_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_i16 *  const restrict h,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_16 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n-  eoshift3 (ret, array, h, bound, pwhich, array_length, \" \", 1);\n+  eoshift3 (ret, array, h, bound, pwhich, \" \", 1);\n }\n \n \n@@ -304,11 +311,11 @@ eoshift3_16_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i16 *  const restrict h,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_16 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n   static const gfc_char4_t space = (unsigned char) ' ';\n-  eoshift3 (ret, array, h, bound, pwhich, array_length * sizeof (gfc_char4_t),\n+  eoshift3 (ret, array, h, bound, pwhich,\n \t    (const char *) &space, sizeof (gfc_char4_t));\n }\n "}, {"sha": "5038c0916bd9404165b7ed8dca7f9dd43852173f", "filename": "libgfortran/generated/eoshift3_4.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift3_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift3_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -37,7 +37,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i4 * const restrict h,\n \tconst gfc_array_char * const restrict bound, \n \tconst GFC_INTEGER_4 * const restrict pwhich,\n-\tindex_type size, const char * filler, index_type filler_len)\n+\tconst char * filler, index_type filler_len)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -65,6 +65,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   index_type dim;\n   index_type len;\n   index_type n;\n+  index_type size;\n   int which;\n   GFC_INTEGER_4 sh;\n   GFC_INTEGER_4 delta;\n@@ -75,6 +76,8 @@ eoshift3 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   if (pwhich)\n     which = *pwhich - 1;\n   else\n@@ -89,13 +92,18 @@ eoshift3 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+\t  ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+            str = GFC_DESCRIPTOR_EXTENT(ret,i-1)\n+\t      * GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n+\n         }\n     }\n   else\n@@ -112,24 +120,24 @@ eoshift3 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           if (bound)\n-            bstride[n] = bound->dim[n].stride * size;\n+            bstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(bound,n);\n           else\n             bstride[n] = 0;\n           n++;\n@@ -260,8 +268,7 @@ eoshift3_4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_4 * const restrict pwhich)\n {\n-  eoshift3 (ret, array, h, bound, pwhich, GFC_DESCRIPTOR_SIZE (array),\n-\t    \"\\0\", 1);\n+  eoshift3 (ret, array, h, bound, pwhich, \"\\0\", 1);\n }\n \n \n@@ -281,10 +288,10 @@ eoshift3_4_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_i4 *  const restrict h,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_4 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n-  eoshift3 (ret, array, h, bound, pwhich, array_length, \" \", 1);\n+  eoshift3 (ret, array, h, bound, pwhich, \" \", 1);\n }\n \n \n@@ -304,11 +311,11 @@ eoshift3_4_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i4 *  const restrict h,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_4 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n   static const gfc_char4_t space = (unsigned char) ' ';\n-  eoshift3 (ret, array, h, bound, pwhich, array_length * sizeof (gfc_char4_t),\n+  eoshift3 (ret, array, h, bound, pwhich,\n \t    (const char *) &space, sizeof (gfc_char4_t));\n }\n "}, {"sha": "f745a1d268f771bcfc3f78410808f263e8728ac0", "filename": "libgfortran/generated/eoshift3_8.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift3_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Feoshift3_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -37,7 +37,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i8 * const restrict h,\n \tconst gfc_array_char * const restrict bound, \n \tconst GFC_INTEGER_8 * const restrict pwhich,\n-\tindex_type size, const char * filler, index_type filler_len)\n+\tconst char * filler, index_type filler_len)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -65,6 +65,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   index_type dim;\n   index_type len;\n   index_type n;\n+  index_type size;\n   int which;\n   GFC_INTEGER_8 sh;\n   GFC_INTEGER_8 delta;\n@@ -75,6 +76,8 @@ eoshift3 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  size = GFC_DESCRIPTOR_SIZE(array);\n+\n   if (pwhich)\n     which = *pwhich - 1;\n   else\n@@ -89,13 +92,18 @@ eoshift3 (gfc_array_char * const restrict ret,\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n         {\n-          ret->dim[i].lbound = 0;\n-          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\t  index_type ub, str;\n+\n+\t  ub = GFC_DESCRIPTOR_EXTENT(array,i) - 1;\n \n           if (i == 0)\n-            ret->dim[i].stride = 1;\n+            str = 1;\n           else\n-            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+            str = GFC_DESCRIPTOR_EXTENT(ret,i-1)\n+\t      * GFC_DESCRIPTOR_STRIDE(ret,i-1);\n+\n+\t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n+\n         }\n     }\n   else\n@@ -112,24 +120,24 @@ eoshift3 (gfc_array_char * const restrict ret,\n     {\n       if (dim == which)\n         {\n-          roffset = ret->dim[dim].stride * size;\n+          roffset = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n           if (roffset == 0)\n             roffset = size;\n-          soffset = array->dim[dim].stride * size;\n+          soffset = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n           if (soffset == 0)\n             soffset = size;\n-          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n         }\n       else\n         {\n           count[n] = 0;\n-          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-          rstride[n] = ret->dim[dim].stride * size;\n-          sstride[n] = array->dim[dim].stride * size;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,dim);\n \n-          hstride[n] = h->dim[n].stride;\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n           if (bound)\n-            bstride[n] = bound->dim[n].stride * size;\n+            bstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(bound,n);\n           else\n             bstride[n] = 0;\n           n++;\n@@ -260,8 +268,7 @@ eoshift3_8 (gfc_array_char * const restrict ret,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_8 * const restrict pwhich)\n {\n-  eoshift3 (ret, array, h, bound, pwhich, GFC_DESCRIPTOR_SIZE (array),\n-\t    \"\\0\", 1);\n+  eoshift3 (ret, array, h, bound, pwhich, \"\\0\", 1);\n }\n \n \n@@ -281,10 +288,10 @@ eoshift3_8_char (gfc_array_char * const restrict ret,\n \tconst gfc_array_i8 *  const restrict h,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_8 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n-  eoshift3 (ret, array, h, bound, pwhich, array_length, \" \", 1);\n+  eoshift3 (ret, array, h, bound, pwhich, \" \", 1);\n }\n \n \n@@ -304,11 +311,11 @@ eoshift3_8_char4 (gfc_array_char * const restrict ret,\n \tconst gfc_array_i8 *  const restrict h,\n \tconst gfc_array_char * const restrict bound,\n \tconst GFC_INTEGER_8 * const restrict pwhich,\n-\tGFC_INTEGER_4 array_length,\n+\tGFC_INTEGER_4 array_length __attribute__((unused)),\n \tGFC_INTEGER_4 bound_length __attribute__((unused)))\n {\n   static const gfc_char4_t space = (unsigned char) ' ';\n-  eoshift3 (ret, array, h, bound, pwhich, array_length * sizeof (gfc_char4_t),\n+  eoshift3 (ret, array, h, bound, pwhich,\n \t    (const char *) &space, sizeof (gfc_char4_t));\n }\n "}, {"sha": "97ce9d1eaadf119b8163cc87122532678680e21c", "filename": "libgfortran/generated/in_pack_c10.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_c10 (gfc_array_c10 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "74e3cb67d5870a03c4e2c9a45990cb5c58256c22", "filename": "libgfortran/generated/in_pack_c16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_c16 (gfc_array_c16 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "ae52bc68940c34502f40d4046d64f8756486025e", "filename": "libgfortran/generated/in_pack_c4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_c4 (gfc_array_c4 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "142ad99cdf7202cffefd59ca88a3e22f1a4d2955", "filename": "libgfortran/generated/in_pack_c8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_c8 (gfc_array_c8 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "dc26c1af6df1504e56a1e94dbad052b8db2b3807", "filename": "libgfortran/generated/in_pack_i1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_1 (gfc_array_i1 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "32ce3a4ea3e91b43536ad68fc7c8d2cf8528b270", "filename": "libgfortran/generated/in_pack_i16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_16 (gfc_array_i16 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "3c39f8e610f55d692c6e5687df72461b524326aa", "filename": "libgfortran/generated/in_pack_i2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_2 (gfc_array_i2 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "4cd7dba479a4425a39f637facad00c9f4502017a", "filename": "libgfortran/generated/in_pack_i4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_4 (gfc_array_i4 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "17acc684f1d5399bb6b9c5217cd68b4618ee96cc", "filename": "libgfortran/generated/in_pack_i8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_8 (gfc_array_i8 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "557ccc2aae79134fda2c4e40e8d76692cd647f28", "filename": "libgfortran/generated/in_pack_r10.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_r10 (gfc_array_r10 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "b737cc7d22c3aba59017f6b009f5f413de87c132", "filename": "libgfortran/generated/in_pack_r16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_r16 (gfc_array_r16 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "68a7e5a0dca21e7d7b5069390936c40c8b375f9c", "filename": "libgfortran/generated/in_pack_r4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_r4 (gfc_array_r4 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "1453f86b582530301699c95f2d6dbcc21b937e5c", "filename": "libgfortran/generated/in_pack_r8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_pack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,8 +57,8 @@ internal_pack_r8 (gfc_array_r8 * source)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = source->dim[n].stride;\n-      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n       if (extent[n] <= 0)\n         {\n           /* Do nothing.  */"}, {"sha": "bcac6e7a5d4710ada62bf02378a28698530de77b", "filename": "libgfortran/generated/in_unpack_c10.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_c10 (gfc_array_c10 * d, const GFC_COMPLEX_10 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "1d09a800690d911d4668452d3360d904752a2df8", "filename": "libgfortran/generated/in_unpack_c16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_c16 (gfc_array_c16 * d, const GFC_COMPLEX_16 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "9ad8a33102f42d9f4def463dd24f1103f277bb89", "filename": "libgfortran/generated/in_unpack_c4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_c4 (gfc_array_c4 * d, const GFC_COMPLEX_4 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "6adae640e5e23e03cc8f255d9bb936747b7291ea", "filename": "libgfortran/generated/in_unpack_c8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_c8 (gfc_array_c8 * d, const GFC_COMPLEX_8 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "e632816c918a8f0927160d9481b46d28893476d2", "filename": "libgfortran/generated/in_unpack_i1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_1 (gfc_array_i1 * d, const GFC_INTEGER_1 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "c7199207e2ab4eec0e5d6238942c7a64229ce122", "filename": "libgfortran/generated/in_unpack_i16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_16 (gfc_array_i16 * d, const GFC_INTEGER_16 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "ec0c1c3aca94e666ffa6a35c816e7df393b49ff4", "filename": "libgfortran/generated/in_unpack_i2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_2 (gfc_array_i2 * d, const GFC_INTEGER_2 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "ce5d29df760aedd8de58a9d902bec0d543c51b74", "filename": "libgfortran/generated/in_unpack_i4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_4 (gfc_array_i4 * d, const GFC_INTEGER_4 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "347f0116cfc9338b93e7a22097f638ca3dcece2d", "filename": "libgfortran/generated/in_unpack_i8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_8 (gfc_array_i8 * d, const GFC_INTEGER_8 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "aa5f08eb25bacd5451b0ad024e945e6c140c8855", "filename": "libgfortran/generated/in_unpack_r10.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_r10 (gfc_array_r10 * d, const GFC_REAL_10 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "0b08228ce7060ca03ca7eaf42c031279fd548fbb", "filename": "libgfortran/generated/in_unpack_r16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_r16 (gfc_array_r16 * d, const GFC_REAL_16 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "f436c8afa85dab645acb3745aca1a3dd41fa6c29", "filename": "libgfortran/generated/in_unpack_r4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_r4 (gfc_array_r4 * d, const GFC_REAL_4 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "76aff2e59258eb20b7437696041b9c71e6f29f8d", "filename": "libgfortran/generated/in_unpack_r8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fin_unpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -52,8 +52,8 @@ internal_unpack_r8 (gfc_array_r8 * d, const GFC_REAL_8 * src)\n   for (n = 0; n < dim; n++)\n     {\n       count[n] = 0;\n-      stride[n] = d->dim[n].stride;\n-      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n       if (extent[n] <= 0)\n \treturn;\n "}, {"sha": "c54c78ed435a5b6a794a866d0e636345fba6eecc", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "880c0e12782fcf1f9ab1144bc8c01fb4f113920f", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "020033a770c183f825e4b3fa3067ccb659bca37f", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "1522dcd5a195dc066fdda2ba65ab3115fb8afb64", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "db56678510cd7d1f6e8638d7abc9c7a8b2eb56c5", "filename": "libgfortran/generated/matmul_i1.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "f607e27b81cd2909a8b838c4c7026e3a997f267b", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "58e340b77222937df4b9125426f653eebb246fdc", "filename": "libgfortran/generated/matmul_i2.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "46ed493d0e09f29b231eac19e49a335215b47fe5", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "54ffe6248f4e15c20a517a04a23b3e2d08ed0a18", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "5fbeeb7da1d3070864d826f07dc9f99c25e6f6b9", "filename": "libgfortran/generated/matmul_l16.c", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,25 +69,22 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n-          \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n           \n       retarray->data\n@@ -100,34 +97,34 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -165,46 +162,46 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n       rystride = rxstride;\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n   /* If we have rank 1 parameters, zero the absent stride, and set the size to\n      one.  */\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride * a_kind;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      astride = GFC_DESCRIPTOR_STRIDE_BYTES(a,0);\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n       xstride = 0;\n       rxstride = 0;\n       xcount = 1;\n     }\n   else\n     {\n-      astride = a->dim[1].stride * a_kind;\n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride * a_kind;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      astride = GFC_DESCRIPTOR_STRIDE_BYTES(a,1);\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xstride = GFC_DESCRIPTOR_STRIDE_BYTES(a,0);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride * b_kind;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+      bstride = GFC_DESCRIPTOR_STRIDE_BYTES(b,0);\n+      assert(count == GFC_DESCRIPTOR_EXTENT(b,0));\n       ystride = 0;\n       rystride = 0;\n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride * b_kind;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride * b_kind;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bstride = GFC_DESCRIPTOR_STRIDE_BYTES(b,0);\n+      assert(count == GFC_DESCRIPTOR_EXTENT(b,0));\n+      ystride = GFC_DESCRIPTOR_STRIDE_BYTES(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   for (y = 0; y < ycount; y++)"}, {"sha": "19ca9f1e577caba83ad18590001cf49d796f8672", "filename": "libgfortran/generated/matmul_l4.c", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,25 +69,22 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n-          \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n           \n       retarray->data\n@@ -100,34 +97,34 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -165,46 +162,46 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n       rystride = rxstride;\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n   /* If we have rank 1 parameters, zero the absent stride, and set the size to\n      one.  */\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride * a_kind;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      astride = GFC_DESCRIPTOR_STRIDE_BYTES(a,0);\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n       xstride = 0;\n       rxstride = 0;\n       xcount = 1;\n     }\n   else\n     {\n-      astride = a->dim[1].stride * a_kind;\n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride * a_kind;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      astride = GFC_DESCRIPTOR_STRIDE_BYTES(a,1);\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xstride = GFC_DESCRIPTOR_STRIDE_BYTES(a,0);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride * b_kind;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+      bstride = GFC_DESCRIPTOR_STRIDE_BYTES(b,0);\n+      assert(count == GFC_DESCRIPTOR_EXTENT(b,0));\n       ystride = 0;\n       rystride = 0;\n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride * b_kind;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride * b_kind;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bstride = GFC_DESCRIPTOR_STRIDE_BYTES(b,0);\n+      assert(count == GFC_DESCRIPTOR_EXTENT(b,0));\n+      ystride = GFC_DESCRIPTOR_STRIDE_BYTES(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   for (y = 0; y < ycount; y++)"}, {"sha": "558ed252e264d7a42e9878fddfb2d1d38fd343fd", "filename": "libgfortran/generated/matmul_l8.c", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -69,25 +69,22 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n-          \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n           \n       retarray->data\n@@ -100,34 +97,34 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -165,46 +162,46 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n       rystride = rxstride;\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n   /* If we have rank 1 parameters, zero the absent stride, and set the size to\n      one.  */\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride * a_kind;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      astride = GFC_DESCRIPTOR_STRIDE_BYTES(a,0);\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n       xstride = 0;\n       rxstride = 0;\n       xcount = 1;\n     }\n   else\n     {\n-      astride = a->dim[1].stride * a_kind;\n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride * a_kind;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      astride = GFC_DESCRIPTOR_STRIDE_BYTES(a,1);\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xstride = GFC_DESCRIPTOR_STRIDE_BYTES(a,0);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride * b_kind;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+      bstride = GFC_DESCRIPTOR_STRIDE_BYTES(b,0);\n+      assert(count == GFC_DESCRIPTOR_EXTENT(b,0));\n       ystride = 0;\n       rystride = 0;\n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride * b_kind;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride * b_kind;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bstride = GFC_DESCRIPTOR_STRIDE_BYTES(b,0);\n+      assert(count == GFC_DESCRIPTOR_EXTENT(b,0));\n+      ystride = GFC_DESCRIPTOR_STRIDE_BYTES(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   for (y = 0; y < ycount; y++)"}, {"sha": "8e325549ce526b8dec856cd25f8de7aa760204fd", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "c11553180d2bd1cc4dfc3cc41f067b152ba27412", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "54208725dfb1cfc0c13b35e42fab79534f1c8926", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "72ad1fd58f031feca64400529f341d57915f729e", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -105,25 +105,22 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n         }\n       else if (GFC_DESCRIPTOR_RANK (b) == 1)\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n         }\n       else\n         {\n-          retarray->dim[0].lbound = 0;\n-          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n-          retarray->dim[0].stride = 1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n \n-          retarray->dim[1].lbound = 0;\n-          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n-          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n         }\n \n       retarray->data\n@@ -136,34 +133,34 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \n \tif (GFC_DESCRIPTOR_RANK (a) == 1)\n \t  {\n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \t  }\n \telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n \t  }\n \telse\n \t  {\n-\t    arg_extent = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-\t    ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 1:\"\n \t\t\t     \" is %ld, should be %ld\",\n \t\t\t     (long int) ret_extent, (long int) arg_extent);\n \n-\t    arg_extent = b->dim[1].ubound + 1 - b->dim[1].lbound;\n-\t    ret_extent = retarray->dim[1].ubound + 1 - retarray->dim[1].lbound;\n+\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n \t    if (arg_extent != ret_extent)\n \t      runtime_error (\"Incorrect extent in return array in\"\n \t\t\t     \" MATMUL intrinsic for dimension 2:\"\n@@ -178,43 +175,43 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n       /* One-dimensional result may be addressed in the code below\n \t either as a row or a column matrix. We want both cases to\n \t work. */\n-      rxstride = rystride = retarray->dim[0].stride;\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n     }\n   else\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = retarray->dim[1].stride;\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n     }\n \n \n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n       /* Treat it as a a row matrix A[1,count]. */\n-      axstride = a->dim[0].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n       aystride = 1;\n \n       xcount = 1;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n   else\n     {\n-      axstride = a->dim[0].stride;\n-      aystride = a->dim[1].stride;\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n \n-      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n     }\n \n-  if (count != b->dim[0].ubound + 1 - b->dim[0].lbound)\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n     {\n-      if (count > 0 || b->dim[0].ubound + 1 - b->dim[0].lbound > 0)\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n \truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n     }\n \n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n       /* Treat it as a column matrix B[count,1] */\n-      bxstride = b->dim[0].stride;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n \n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n@@ -224,9 +221,9 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n     }\n   else\n     {\n-      bxstride = b->dim[0].stride;\n-      bystride = b->dim[1].stride;\n-      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n     }\n \n   abase = a->data;"}, {"sha": "b43f08337c70b64fb6142dce2175c07035be6f48", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "26941a741f93ff7952e9a1b908af4dcf6ea4a352", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "e1d329c583c0bf97146c512aa6026a2d4f7306b6", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "4d1d0a11acde8bbe02440627c800d003e94a1a96", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "12147a0e2fad92227cbe74b42f010b8058d47a0d", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "33c73083cc7db54cd01fa7d172d22bfc9e33e1c0", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "4f4f290fee92bec665e1bca21c959ce5b8d72b2c", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "86cedb3a420a5c5a27ae20ce4793bf0018a0223f", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "378024bff76809881b846b849a24c738e7d62192", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "7475059164c096afd0f50d9487c6d1142bd13a70", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "268f09af8def5d3fc00af74ab101207fe89b3adf", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "47fb135c50d9c50d05c64e860af9a5aba1323f89", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "55bc2752131cf6a9139f403c3f93f2013c999f69", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "f598f050fd47938988003b4e3b10a505f8b6d26e", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "5c99198b201f59d0ab6721054b91049b899e2aca", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "c7609c35dc3b4869090406e98ebe8eb26bf8b442", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "50f3c3b6d1a2593d5597238bcaf83077a98640af", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "30dc2976c3e352821b5f39a84e201f3a8f648a81", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -74,20 +72,20 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "eb1737d23e3bc159a91db80a6774da3dd4a3d586", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "6690c2da4b75234180556c2659d7345003fd62e4", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "b9bb230589f13abd682487d0fcb2eee9b98ee87c", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "57781469089ca3257fb468816bc9c9b932e01be9", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "ef7dedeb98467af6d665f6d08679e47ec61eb167", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "0c08d8e803a8debb40b2afd43b5380f637444bb1", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "da61d2b69835cec245222a023efcd15fc41c398e", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "a26b110220d691742d6f5675f9910e340e8efa9e", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "1198d624c54bd0227283e08d1a26917930f76775", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -74,20 +72,20 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -200,7 +196,7 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n@@ -358,13 +352,13 @@ smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "a776f4f1c7ae59aa0c8706e917764117d4d7fcf1", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "827b3e6708c57a70c9aa284d35b52435d07410b7", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "24a34e3343fd38cccf1391c6817c7bd662c3c993", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "0194f28fc27098e579321c65c56d41862ae089c2", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "bb1750028f1e2dc8e0167ee7a97def5a2f6fd760", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "dc8cd5dd425b966272c782b29413f3e57fb358a7", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "1664edb4b3527eeca84b6c94fa16a635be3c5a1b", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "58bfcc0f8ec37ae33785030af4de0bb9df0ab56e", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "d646d2547f8e9b63820000c1c47bcbd03fd95fa6", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "39291ff4db39b8914b343c9a3b41b8d4fe052488", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "059cacb22e5532d20911f0657eb0e3ce0b164d73", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "64cee3e872505689baba3994fe17d5501a618177", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "f8a843e5c5b391e208d56a77f029364450ebf101", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "293c2a9cb2e122cc8ceb33c445bafee00dc73d3e", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "89982795e818e1932563ed0a547088c6ec8ce26b", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "191ba9982423ceec1381d8d999e9e7c8f0d699ef", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "1f445e7306a99074309916599aa24d84d8b66900", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "170e3dfce1a8b8930d2af40dd408e0d111bc08f5", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "9924b7188474121dab432133f4470da47387088c", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "97946f3dd521bc9b1a972aacb14e3a31c807b8e9", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "d343b0b36c35ce0f87a0d3ca52731d7bce1946c7", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "682de41af38ea14bfe85358e11da1c32d5069285", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "e17ecc49915634ae6267d733025f15129860234b", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "cb4b69201ee8ea8436a43567007a0c1c8cd68119", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "5a99dafa388bfe790bf7fff872bb361772d37655", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "ba88d8ee41806d30c1df295d7e7f8342a8b03325", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "6d05b43051d5a7bd40455f292a59555fe84c7de0", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -58,55 +58,55 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -125,8 +125,7 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -139,7 +138,7 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -236,7 +235,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -253,45 +252,45 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -300,8 +299,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -319,8 +317,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -331,8 +328,8 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -345,7 +342,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -448,48 +445,48 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -509,8 +506,7 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n@@ -523,7 +519,7 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "10193fdf95d016ec7893312b1e6ac597e9b5980e", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "884ed6678f280a828f2a2fda04a611bc88af7a62", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "3abe6579749f9e5a69423b457b72c6c27ddaaac7", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "57aea5fb4291022c0a9b67aa38aae33af76e5556", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "9d7f57c1cba2257c886198ec2fea0322c184aa46", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "2259e8e2be5c25181c89079769066432371c565f", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "7efdd65718c0b7e228ddd6587082949da0a0de0c", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "623c25c7f8e4684115804d228a75c2df6258fbd4", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "bdbb26f06d00c2795ece41b0c7f906458be3af7a", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -57,55 +57,55 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len < 0)\n     len = 0;\n-  delta = array->dim[dim].stride;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+\t    str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n+\n \t}\n       else\n \tretarray->data = internal_malloc_size (alloc_size);\n@@ -124,8 +124,7 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -138,7 +137,7 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         len = 0;\n     }\n@@ -230,7 +229,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n   if (len <= 0)\n     return;\n \n@@ -247,45 +246,45 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride * mask_kind;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n \n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n-      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       retarray->offset = 0;\n@@ -294,8 +293,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -313,8 +311,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -325,8 +322,8 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n             {\n               index_type mask_extent, array_extent;\n \n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -339,7 +336,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n         return;\n     }\n@@ -437,48 +434,48 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n \n       if (extent[n] <= 0)\n \textent[n] = 0;\n     }\n \n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n         extent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n-      size_t alloc_size;\n+      size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n         {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n           if (n == 0)\n-            retarray->dim[n].stride = 1;\n+            str = 1;\n           else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n         }\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n \t{\n \t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n \t  return;\n \t}\n       else\n@@ -498,8 +495,7 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n \t    {\n \t      index_type ret_extent;\n \n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n \t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n@@ -512,7 +508,7 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n     }\n \n   dest = retarray->data;"}, {"sha": "961beb924d37059372c550f2c75ce8af983cc4d7", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "7303592131cc02da0f240f4c69977cedb5445001", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "ee9f46c00b0ee8a1179a07ba9275728466bc0b51", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "6d07bbe2669d3fc8cd5ae10c47e3b76e8e68e478", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "bbacc119ec13002f05be4362fab79bccf161898a", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "a77efcdc5c749af61c74640d9daa687766e2928f", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "1d29e07f29729b4ae7ca47e9eda4f62b97bbae59", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "1c451e9f76b9e26b401e7af98afac43bd5dca154", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "d6c7086958427dccb98df71b0ac86538560b5fba", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990", "patch": "@@ -55,9 +55,7 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -74,20 +72,20 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n \t\t\t   (long int) ret_extent, (long int) rank);\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -179,9 +177,7 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -200,7 +196,7 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t  if (ret_extent != rank)\n \t    runtime_error (\"Incorrect extent in return value of\"\n \t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n@@ -214,8 +210,8 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \t  for (n=0; n<rank; n++)\n \t    {\n-\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n+\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n \t      if (array_extent != mask_extent)\n \t\truntime_error (\"Incorrect extent in MASK argument of\"\n \t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n@@ -238,13 +234,13 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     runtime_error (\"Funny sized logical array\");\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride * mask_kind;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n       if (extent[n] <= 0)\n \t{\n@@ -339,9 +335,7 @@ sminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n@@ -358,13 +352,13 @@ sminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n \t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n \t    if (ret_extent != rank)\n \t      runtime_error (\"dimension of return array incorrect\");\n \t}\n     }\n \n-  dstride = retarray->dim[0].stride;\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n   dest = retarray->data;\n   for (n = 0; n<rank; n++)\n     dest[n * dstride] = 0 ;"}, {"sha": "418eb30d240050dbc1038c70ebd5f3e3664b3cbb", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "9a23b27e3d8c17e1624d9a5d000b5693067b6894", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "df081acb8145b0531c36adbac7c51c2b38cdbd18", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "b076dcf5955dd80f2a45915c7149a7d2f9821b5f", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "944694c5c9ded46ea5ca773cd16f79af8f03d5d1", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "03b8fd43afbc82493b33daf4132de0e2603e94c9", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "88059c623fe77b8416f4b08c144ee84e4e8a0d23", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "0b1e642ba2346f551df127ad101b5d227bd292a5", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "a6843b1d8043af1fd60a220edd3ddfa53c0efdd0", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "5617affe49b6bde03938449e2cbee1de94456320", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "bc2454a1367758b1e44303bba9647424760feed5", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "198c9b90cb9e4a375b03a120a5da36a657ecd15c", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c62fbcb116616902702a14079f5884aa4ff1f29b", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "ffc790088f9ca6ed79d62a476e9d95718c923bdb", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "68eb7b6ecab9801f31788d284b2ba61a12aec238", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "da7ae0667049aee6c4d35dfbd738c98f43bfd766", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "fbf5bab98af9f18085cc0f0585ad552a6d41de64", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "2dd4cfdf4061742c0ce605ed42f5c812e65d8b9e", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "5a5ff5e39e224167c4078cf05d82c669795d634b", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "25d4ceaae51968962f72fa5eaa9e4661183bfe74", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "228a582ed09bfe355ab03abe6f4067f1d660e5f5", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c8652722a860a3c5339f27983918cb4597e6e842", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "fa124441dd66be1b3da7b2791f75d597d562ca82", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "15862a89cb54f5b903e2d7d383badaf422b9d248", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f0b452fa09d2288cf72f652c9026cf722c623dd3", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "692259db8c8bb7ea5abe4aa8170a51a4b8857d5a", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c0189da58f722710696dc55a72bdcae7312e3f78", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "164f7ec31a2488b70ec366f3b52b07081cf6d3b7", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "899f2029bd3441d5158d5e68df1579626b2a7e93", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f900506de74e06c05ddf6cbba3ed499ec2808b60", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "7dedb8f1c5b1f1c8304b5c47dba1b7925dbf4717", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "70eaefa8ed6147b1d7b6391b943a68e8c55511bc", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1a0bdfa7ac157d0938cbeebf8f68411a9da03ede", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "b8849a56d352843f1a6791481672ffef280d3802", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "cc382dba224a0f76aea138fbad2653d9cbd046a1", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c36567ffee6bd5718fe6d544a61eefc6146d28f8", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "6e46c82b8638a14aa98c270e6253d24190c3eaac", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "8e8410aa66914834f1c4ceb83fd2427451ee4c9e", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "2a33e3c1fb7eb60cfa96616bc1d93fffd92fb4f6", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "70cdef68bc651e917882e0fa356ee66a2754a07d", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c1a01e9e436ff03a9aa028090e56823dd873bd24", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "b5a6c8d2d267daa346e1aeee51efab6c3cf8d027", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "0f4b036461d797fb85dc99c7ec7cf1f66308b737", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "300b5bebf0d53f423ad6aa37198d52b08be4c6fa", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "da498f661ac813e975a33761f43ab5840fe310b6", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "437232a89daa802eeeada5a204e53df4dc43f5db", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f0bd16fe00369a4e92d2c3da71de327b07196f88", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "08fd3a60b77497cc5793b3e654c4f45099fbab68", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "d7e1ef93966f1636e845f5685d9393c75724ab0e", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "7b6fdc5e5ae83490ea6272ff0672a692e5eb46ab", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1f6a75f0f6ca26f6a35465356be96054d4ce9c57", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "555d86fd66f5807946ea74dc9aac0c77d773c6d6", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "a7f729ee7320a1822831940f6e5651170fbd235f", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "69afca1bc50b99c25e9fffdb0f5c0c74b6871df7", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "008fb5c9236875d4e9ebb261197d8273ee51ee47", "filename": "libgfortran/generated/pack_c10.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e7d039f5becfe7b827dcaa1792fa03f269a7e9cc", "filename": "libgfortran/generated/pack_c16.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "fe1f68d4225343f3b31f0976a572ca8a5ac5c174", "filename": "libgfortran/generated/pack_c4.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f5a27eca6f51827294f955849e5abb06c34861f5", "filename": "libgfortran/generated/pack_c8.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "edc895082a469e33e4e75ac1e7a421af974ddd7b", "filename": "libgfortran/generated/pack_i1.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "8f38a2747ec06db676880abb81219a5312b555ae", "filename": "libgfortran/generated/pack_i16.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "149e9f6f67d5a51108dd4da85cfd2cbe4a974908", "filename": "libgfortran/generated/pack_i2.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "dad10d62d46a869ea615eb99c3dd9272d8b2360f", "filename": "libgfortran/generated/pack_i4.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "0a23aa5b72fb284f7acb5c1cfb7b96267540fd42", "filename": "libgfortran/generated/pack_i8.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e4bbe6fabcf3cbb1b1632d011480382f50ba1d0d", "filename": "libgfortran/generated/pack_r10.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "7dff30b70068be7f8950a854c9cfb7cf2ba71401", "filename": "libgfortran/generated/pack_r16.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "51d46a2721821d4bb2758ec2909e3c81fde5f358", "filename": "libgfortran/generated/pack_r4.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "582c2b9aeb1606bc618fa93f47841af827e5b500", "filename": "libgfortran/generated/pack_r8.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "69f7f8b70268860e8ac8738d9eecaf6c3f1ce518", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "efaed2cebdbf9f118309a8895c38b5e6423d0150", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "505647ecd2e513a9407721c6badcfa166a5f36a9", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "16c776ad839df7f798bbaa4f7b49afc669e266c1", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "cbc1ab120af1bbe8c518d56a2edb9acedb84b5fb", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e3b8c2a07e0515bc929304693b87b5bd324beca8", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "507d956cb81201f298d63a53775a025f323e3226", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "d5af367956199a57b107ec6734a9ca605fdb9be7", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "3308d91dff96c3e800d369a946670bd2c9d8424d", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "7bae90414b6b18d739a805993b96fb1d7f350894", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "bb678725d7c939acf108284324ff2342ee04eeee", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "333c13d2ffed43291edf2640a53f11b73c216b90", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "46258c00bbcf160b6509af9cea963366b5d2bc5b", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "34eff9086a0b707469a655349d8a661f29e0ba19", "filename": "libgfortran/generated/reshape_c10.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "569b76ce4a87595459569b83b1de8bf9afa3493c", "filename": "libgfortran/generated/reshape_c16.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c8b7355de37fb250cbcebb639ed055475b47417e", "filename": "libgfortran/generated/reshape_c4.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1a390b4509b0d5eb1ea454865c3bdf8ece460d84", "filename": "libgfortran/generated/reshape_c8.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "4f69ce0d287aa247612c549a03e279031b6446cd", "filename": "libgfortran/generated/reshape_i16.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "53016bdf597f2b396e30fd5f56e31193f29c030d", "filename": "libgfortran/generated/reshape_i4.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "34620cf6d4096f0a097349a3e2635c0693d895c4", "filename": "libgfortran/generated/reshape_i8.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "3bf319aa43406b88aef0489b588f1999ec72515b", "filename": "libgfortran/generated/reshape_r10.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "6794b506059862defac19b908f3bcf2630d87853", "filename": "libgfortran/generated/reshape_r16.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e7bfbfbf538271b14838eb06bbf83d3de07b67f9", "filename": "libgfortran/generated/reshape_r4.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "d0441c0fe5d561c73e33e1720230195cd0b746de", "filename": "libgfortran/generated/reshape_r8.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Freshape_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "9ce28577baa310eb8ec88f301d8cbbe2aeb92475", "filename": "libgfortran/generated/shape_i16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fshape_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fshape_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fshape_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1b23335de5684997af3f54b7be44240a48687af1", "filename": "libgfortran/generated/shape_i4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fshape_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fshape_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fshape_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "efe00a5dd331d3069ce2ba8aa7caa77687468e31", "filename": "libgfortran/generated/shape_i8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fshape_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fshape_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fshape_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "77a838f01a4370fecace3309df21c112e321a479", "filename": "libgfortran/generated/spread_c10.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1276e4dfb44e8dbcc70ce0f55f0db2b846f29647", "filename": "libgfortran/generated/spread_c16.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "5224e8477a90dca85b5c86af35c2848e695fb16b", "filename": "libgfortran/generated/spread_c4.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "96ecb3afb87bb7b9c89addc675669dc64d2ffbb6", "filename": "libgfortran/generated/spread_c8.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e002c146262b69d0358e8619142d12a179dccf74", "filename": "libgfortran/generated/spread_i1.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "bdefdac32715848963a6c7d524cce8580e9aafac", "filename": "libgfortran/generated/spread_i16.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "8482cfde8575efde08cd435a863fe0fa91f91073", "filename": "libgfortran/generated/spread_i2.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "6eff6326b2613e4dc66b5b03e92b9f54ce49a885", "filename": "libgfortran/generated/spread_i4.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "293126363064ff8ea86f08b1942b5469434d05cc", "filename": "libgfortran/generated/spread_i8.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "3c3f197b4c2269e012bbb2b8c2c1de4a62bfe471", "filename": "libgfortran/generated/spread_r10.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1316260969608c8f1268b3784b1ddd59f49229ab", "filename": "libgfortran/generated/spread_r16.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "cc0f1197b69df47e825c7a6939fac2d5fbb76ad5", "filename": "libgfortran/generated/spread_r4.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f38ef3885fc3ec5bac255eb23abd6e48d366bf77", "filename": "libgfortran/generated/spread_r8.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fspread_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c63bc695266ca3a1cdd284b622618589c1ef6350", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "9871d2d5d6a3ac3d1b533564daf73f481b0dd637", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "920a6fb492040055742319c0a6ca04679507d6b0", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c3e79237fb3887631080083e1aca94e89db6af27", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "913d732fa7fc9ce68e4bb7cdda7de7998ba0dc0f", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "060d45aa9ce4424abd81702c242d1313f3ad8807", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "5318283ccb8c0784274e84bf52106951b34388b0", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e8c60c3870e256a9db62cc223c20978d352ebc65", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "9ee3e934bc713b892d71f9b722dbdbf22d01409a", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "6a283049bfa37beb5526bdb3d0a25be5a7854fa2", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "35296c1d0d8d9ceed8493321022d64173890425c", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e7e2fe31b3a83c9636c8903d1bad648f9a34d2e5", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "86ae10924209d03ec89a3bddbb1555a21a1002b4", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e740d12a7e75ad9bfe4160258a1216a5aa986c9b", "filename": "libgfortran/generated/transpose_c10.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "31115bdfddeb193fda1eff57d3310ba37aaa3449", "filename": "libgfortran/generated/transpose_c16.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "a63f62c95ff38fdcb0bac127644b3631eb4da899", "filename": "libgfortran/generated/transpose_c4.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "832239403304ae5a86a63e1af261f8d3ca962ab0", "filename": "libgfortran/generated/transpose_c8.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f8cfd823f95dc0dc0defebba0ff7ed08279936cb", "filename": "libgfortran/generated/transpose_i16.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "9b15e470269c7cc18e70a23d859cbb071635bd01", "filename": "libgfortran/generated/transpose_i4.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "ddf772b0e425a062a2a3d103736db424b46ac8cb", "filename": "libgfortran/generated/transpose_i8.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "2b2e02d1c985efdb3563c7d76842dc95d203b6cb", "filename": "libgfortran/generated/transpose_r10.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "4d2e40660fb56f9ca72c0e0b694688ecf1300bc7", "filename": "libgfortran/generated/transpose_r16.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1748c1d0561eb8a99d43d865c3313058f7324fa8", "filename": "libgfortran/generated/transpose_r4.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "09054b6138e3e3e94dd5233b602b83eb5b36dbb2", "filename": "libgfortran/generated/transpose_r8.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Ftranspose_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "9b89a5bea79abb8591d78c443fc148025d1f349c", "filename": "libgfortran/generated/unpack_c10.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "2d9931f02ac29664eb0bac3f50961e6c691bfe37", "filename": "libgfortran/generated/unpack_c16.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "116f213f9fc584d2cad82b2efeed5f1c98a95597", "filename": "libgfortran/generated/unpack_c4.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "7298eeceedb314926831f6b00da067011c572358", "filename": "libgfortran/generated/unpack_c8.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f5dcb93df812f4545f336c0cdd342f72ce0b6572", "filename": "libgfortran/generated/unpack_i1.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i1.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "77920ea60d8e0ea449c180ba8d4c0387cb6765fc", "filename": "libgfortran/generated/unpack_i16.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "c7257bb2f013968044f16d46372e2b757e157878", "filename": "libgfortran/generated/unpack_i2.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i2.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "e3cdde67790adff095dce9da146fd469ce87069d", "filename": "libgfortran/generated/unpack_i4.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "2f720640370b89a1bf6808ded9b75719414b12cf", "filename": "libgfortran/generated/unpack_i8.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "796df2edd45b02828493f07636882f888da96191", "filename": "libgfortran/generated/unpack_r10.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r10.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "b25d2869ac98132b59203181c5f272f9a1f6c6a3", "filename": "libgfortran/generated/unpack_r16.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r16.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "f4b763fc1c5ff39bbc203b8d0affd3dcc0133b5d", "filename": "libgfortran/generated/unpack_r4.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r4.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "dc9b4d398cea11df2957c18d874d9afd4bcf3b90", "filename": "libgfortran/generated/unpack_r8.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fgenerated%2Funpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r8.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "0aade1d95b7d9160e538614786b5818f6679f796", "filename": "libgfortran/intrinsics/associated.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fassociated.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fassociated.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fassociated.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "1b7dbc1cec9232d1a0cfd26d6a63de82c6a267f1", "filename": "libgfortran/intrinsics/cshift0.c", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fcshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fcshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fcshift0.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "4bc6e6928c0dcdf28209621aca17d7b5fc179053", "filename": "libgfortran/intrinsics/date_and_time.c", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fdate_and_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fdate_and_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdate_and_time.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}, {"sha": "4b7000b446602b5d633372f3777d22bf1075a60e", "filename": "libgfortran/intrinsics/dtime.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fdtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb55fdcdb68bba326432b26f3828ff8c9ca2990/libgfortran%2Fintrinsics%2Fdtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdtime.c?ref=dfb55fdcdb68bba326432b26f3828ff8c9ca2990"}]}