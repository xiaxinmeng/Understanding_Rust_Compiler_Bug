{"sha": "f9d98fa74800041b39b67fa204c3ad8b527df400", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlkOThmYTc0ODAwMDQxYjM5YjY3ZmEyMDRjM2FkOGI1MjdkZjQwMA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-20T07:24:47Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-07-27T19:55:49Z"}, "message": "libstdc++: Review _Hashtable count, equal_range _M_erase(false_type,) code\n\nSimplify operator[] implementation using find method. Review several\n_Hashtable method implementations to limit the computation of bucket index.\nIntroduce _M_update_bbegin to simplify code.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/hashtable_policy.h (_Map_base<>::at): Use\n\t_Hashtable<>::find.\n\t(_Hashtable_base<>::_Equal_hash_code<>::_S_node_equals):New.\n\t(_Hashtable_base<>::_M_node_equals): New, use latter.\n\t(_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n\t_RehashPolicy, false>::_M_equal): Adapt to use latter.\n\t* include/bits/hashtable.h (_Hashtable<>::_M_update_bbegin): New.\n\t(_Hashtable<>::_M_assign): Use latter.\n\t(_Hashtable<>::_M_move_assign): Likewise.\n\t(_Hashtable<>(_Hashtable<>&&)): Likewise.\n\t(_Hashtable<>(_Hashtable<>&&, const allocator_type&)): Likewise.\n\t(_Hashtable<>::swap): Likewise.\n\t(_Hashtable<>::find): Build iterator directly from _M_find_node result.\n\t(_Hashtable<>::count): Use _Hashtable<>::find.\n\t(_Hashtable<>::equal_range): Likewise.\n\t(_Hashtable<>::_M_erase(false_type, const key_type&)): Use\n\t_M_node_equals.", "tree": {"sha": "71e7d3d1fecd16d52f516bf0e0db4e79b8ed7b63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71e7d3d1fecd16d52f516bf0e0db4e79b8ed7b63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9d98fa74800041b39b67fa204c3ad8b527df400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d98fa74800041b39b67fa204c3ad8b527df400", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d98fa74800041b39b67fa204c3ad8b527df400", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d98fa74800041b39b67fa204c3ad8b527df400/comments", "author": null, "committer": null, "parents": [{"sha": "d60758c74af849539f5dd71a8456eea954c0f674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60758c74af849539f5dd71a8456eea954c0f674", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60758c74af849539f5dd71a8456eea954c0f674"}], "stats": {"total": 220, "additions": 118, "deletions": 102}, "files": [{"sha": "248dd62589bca9261a8571aad520792935e93c55", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 81, "deletions": 82, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d98fa74800041b39b67fa204c3ad8b527df400/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d98fa74800041b39b67fa204c3ad8b527df400/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=f9d98fa74800041b39b67fa204c3ad8b527df400", "patch": "@@ -375,6 +375,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // numerous checks in the code to avoid 0 modulus.\n       __bucket_type\t\t_M_single_bucket\t= nullptr;\n \n+      void\n+      _M_update_bbegin()\n+      {\n+\tif (_M_begin())\n+\t  _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+      }\n+\n+      void\n+      _M_update_bbegin(__node_type* __n)\n+      {\n+\t_M_before_begin._M_nxt = __n;\n+\t_M_update_bbegin();\n+      }\n+\n       bool\n       _M_uses_single_bucket(__bucket_type* __bkts) const\n       { return __builtin_expect(__bkts == &_M_single_bucket, false); }\n@@ -671,7 +685,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __k) const;\n \n-    protected:\n+    private:\n       // Bucket index computation helpers.\n       size_type\n       _M_bucket_index(__node_type* __n) const noexcept\n@@ -1165,8 +1179,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __node_type* __this_n\n \t      = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));\n \t    this->_M_copy_code(__this_n, __ht_n);\n-\t    _M_before_begin._M_nxt = __this_n;\n-\t    _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;\n+\t    _M_update_bbegin(__this_n);\n \n \t    // Then deal with other nodes.\n \t    __node_base* __prev_n = __this_n;\n@@ -1227,15 +1240,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_buckets = &_M_single_bucket;\n \t  _M_single_bucket = __ht._M_single_bucket;\n \t}\n+\n       _M_bucket_count = __ht._M_bucket_count;\n       _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;\n       _M_element_count = __ht._M_element_count;\n       std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());\n \n-      // Fix buckets containing the _M_before_begin pointers that can't be\n-      // moved.\n-      if (_M_begin())\n-\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+      // Fix bucket containing the _M_before_begin pointer that can't be moved.\n+      _M_update_bbegin();\n       __ht._M_reset();\n     }\n \n@@ -1303,10 +1315,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_single_bucket = __ht._M_single_bucket;\n \t}\n \n-      // Update, if necessary, bucket pointing to before begin that hasn't\n-      // moved.\n-      if (_M_begin())\n-\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+      // Fix bucket containing the _M_before_begin pointer that can't be moved.\n+      _M_update_bbegin();\n \n       __ht._M_reset();\n     }\n@@ -1357,11 +1367,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  else\n \t    _M_buckets = __ht._M_buckets;\n \n-\t  _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;\n-\t  // Update, if necessary, bucket pointing to before begin that hasn't\n+\t  // Fix bucket containing the _M_before_begin pointer that can't be\n \t  // moved.\n-\t  if (_M_begin())\n-\t    _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\t  _M_update_bbegin(__ht._M_begin());\n+\n \t  __ht._M_reset();\n \t}\n       else\n@@ -1431,12 +1440,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Fix buckets containing the _M_before_begin pointers that can't be\n       // swapped.\n-      if (_M_begin())\n-\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n-\n-      if (__x._M_begin())\n-\t__x._M_buckets[__x._M_bucket_index(__x._M_begin())]\n-\t  = &__x._M_before_begin;\n+      _M_update_bbegin();\n+      __x._M_update_bbegin();\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1451,8 +1456,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__bkt, __k, __code);\n-      return __p ? iterator(__p) : end();\n+      return iterator(_M_find_node(__bkt, __k, __code));\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1467,8 +1471,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__bkt, __k, __code);\n-      return __p ? const_iterator(__p) : end();\n+      return const_iterator(_M_find_node(__bkt, __k, __code));\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1481,25 +1484,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     count(const key_type& __k) const\n     -> size_type\n     {\n-      __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_bucket_begin(__bkt);\n-      if (!__p)\n+      auto __it = find(__k);\n+      if (!__it._M_cur)\n \treturn 0;\n \n-      std::size_t __result = 0;\n-      for (;; __p = __p->_M_next())\n-\t{\n-\t  if (this->_M_equals(__k, __code, __p))\n-\t    ++__result;\n-\t  else if (__result)\n-\t    // All equivalent values are next to each other, if we\n-\t    // found a non-equivalent value after an equivalent one it\n-\t    // means that we won't find any new equivalent value.\n-\t    break;\n-\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)\n-\t    break;\n-\t}\n+      if (__unique_keys::value)\n+\treturn 1;\n+\n+      // All equivalent values are next to each other, if we find a\n+      // non-equivalent value after an equivalent one it means that we won't\n+      // find any new equivalent value.\n+      size_type __result = 1;\n+      for (auto __ref = __it++;\n+\t   __it._M_cur && this->_M_node_equals(__ref._M_cur, __it._M_cur);\n+\t   ++__it)\n+\t++__result;\n+\n       return __result;\n     }\n \n@@ -1513,21 +1513,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     equal_range(const key_type& __k)\n     -> pair<iterator, iterator>\n     {\n-      __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__bkt, __k, __code);\n+      auto __ite = find(__k);\n+      if (!__ite._M_cur)\n+\treturn { __ite, __ite };\n \n-      if (__p)\n-\t{\n-\t  __node_type* __p1 = __p->_M_next();\n-\t  while (__p1 && _M_bucket_index(__p1) == __bkt\n-\t\t && this->_M_equals(__k, __code, __p1))\n-\t    __p1 = __p1->_M_next();\n+      auto __beg = __ite++;\n+      if (__unique_keys::value)\n+\treturn { __beg, __ite };\n \n-\t  return std::make_pair(iterator(__p), iterator(__p1));\n-\t}\n-      else\n-\treturn std::make_pair(end(), end());\n+      // All equivalent values are next to each other, if we find a\n+      // non-equivalent value after an equivalent one it means that we won't\n+      // find any new equivalent value.\n+      while (__ite._M_cur && this->_M_node_equals(__beg._M_cur, __ite._M_cur))\n+\t++__ite;\n+\n+      return { __beg, __ite };\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1540,25 +1540,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     equal_range(const key_type& __k) const\n     -> pair<const_iterator, const_iterator>\n     {\n-      __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__bkt, __k, __code);\n+      auto __ite = find(__k);\n+      if (!__ite._M_cur)\n+\treturn { __ite, __ite };\n \n-      if (__p)\n-\t{\n-\t  __node_type* __p1 = __p->_M_next();\n-\t  while (__p1 && _M_bucket_index(__p1) == __bkt\n-\t\t && this->_M_equals(__k, __code, __p1))\n-\t    __p1 = __p1->_M_next();\n+      auto __beg = __ite++;\n+      if (__unique_keys::value)\n+\treturn { __beg, __ite };\n \n-\t  return std::make_pair(const_iterator(__p), const_iterator(__p1));\n-\t}\n-      else\n-\treturn std::make_pair(end(), end());\n+      // All equivalent values are next to each other, if we find a\n+      // non-equivalent value after an equivalent one it means that we won't\n+      // find any new equivalent value.\n+      while (__ite._M_cur && this->_M_node_equals(__beg._M_cur, __ite._M_cur))\n+\t++__ite;\n+\n+      return { __beg, __ite };\n     }\n \n-  // Find the node whose key compares equal to k in the bucket bkt.\n-  // Return nullptr if no node is found.\n+  // Find the node before the one whose key compares equal to k in the bucket\n+  // bkt. Return nullptr if no node is found.\n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n@@ -1584,6 +1584,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    break;\n \t  __prev_p = __p;\n \t}\n+\n       return nullptr;\n     }\n \n@@ -1610,10 +1611,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // contain _M_before_begin pointer.\n \t  __node->_M_nxt = _M_before_begin._M_nxt;\n \t  _M_before_begin._M_nxt = __node;\n+\n \t  if (__node->_M_nxt)\n \t    // We must update former begin bucket that is pointing to\n \t    // _M_before_begin.\n \t    _M_buckets[_M_bucket_index(__node->_M_next())] = __node;\n+\n \t  _M_buckets[__bkt] = &_M_before_begin;\n \t}\n     }\n@@ -1940,16 +1943,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // them so that the key stays valid during the first loop. It might be\n       // invalidated indirectly when destroying nodes.\n       __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n-      __node_type* __n_last = __n;\n-      std::size_t __n_last_bkt = __bkt;\n-      do\n-\t{\n-\t  __n_last = __n_last->_M_next();\n-\t  if (!__n_last)\n-\t    break;\n-\t  __n_last_bkt = _M_bucket_index(__n_last);\n-\t}\n-      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));\n+      __node_type* __n_last = __n->_M_next();\n+      while (__n_last && this->_M_node_equals(__n, __n_last))\n+\t__n_last = __n_last->_M_next();\n+\n+      std::size_t __n_last_bkt = __n_last ? _M_bucket_index(__n_last) : __bkt;\n \n       // Deallocate nodes.\n       size_type __result = 0;\n@@ -1959,13 +1957,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  this->_M_deallocate_node(__n);\n \t  __n = __p;\n \t  ++__result;\n-\t  --_M_element_count;\n \t}\n       while (__n != __n_last);\n \n+      _M_element_count -= __result;\n       if (__prev_n == _M_buckets[__bkt])\n \t_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);\n-      else if (__n_last && __n_last_bkt != __bkt)\n+      else if (__n_last_bkt != __bkt)\n \t_M_buckets[__n_last_bkt] = __prev_n;\n       __prev_n->_M_nxt = __n_last;\n       return __result;\n@@ -2111,6 +2109,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;\n \t      __new_buckets[__bkt]->_M_nxt = __p;\n \t    }\n+\n \t  __p = __next;\n \t}\n "}, {"sha": "a91ae21a9060cb68e5b65eb75ef4d1216d354adf", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d98fa74800041b39b67fa204c3ad8b527df400/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d98fa74800041b39b67fa204c3ad8b527df400/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=f9d98fa74800041b39b67fa204c3ad8b527df400", "patch": "@@ -758,13 +758,11 @@ namespace __detail\n     -> mapped_type&\n     {\n       __hashtable* __h = static_cast<__hashtable*>(this);\n-      __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n+      auto __ite = __h->find(__k);\n \n-      if (!__p)\n+      if (!__ite._M_cur)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n-      return __p->_M_v().second;\n+      return __ite->second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n@@ -777,13 +775,11 @@ namespace __detail\n     -> const mapped_type&\n     {\n       const __hashtable* __h = static_cast<const __hashtable*>(this);\n-      __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n+      auto __ite = __h->find(__k);\n \n-      if (!__p)\n+      if (!__ite._M_cur)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n-      return __p->_M_v().second;\n+      return __ite->second;\n     }\n \n   /**\n@@ -1796,17 +1792,26 @@ namespace __detail\n     template<typename _NodeT>\n       struct _Equal_hash_code\n       {\n-       static bool\n-       _S_equals(__hash_code, const _NodeT&)\n-       { return true; }\n+\tstatic bool\n+\t_S_equals(__hash_code, const _NodeT&)\n+\t{ return true; }\n+\n+\tstatic bool\n+\t_S_node_equals(const _NodeT&, const _NodeT&)\n+\t{ return true; }\n       };\n \n     template<typename _Ptr2>\n       struct _Equal_hash_code<_Hash_node<_Ptr2, true>>\n       {\n-       static bool\n-       _S_equals(__hash_code __c, const _Hash_node<_Ptr2, true>& __n)\n-       { return __c == __n._M_hash_code; }\n+\tstatic bool\n+\t_S_equals(__hash_code __c, const _Hash_node<_Ptr2, true>& __n)\n+\t{ return __c == __n._M_hash_code; }\n+\n+\tstatic bool\n+\t_S_node_equals(const _Hash_node<_Ptr2, true>& __lhn,\n+\t\t       const _Hash_node<_Ptr2, true>& __rhn)\n+\t{ return __lhn._M_hash_code == __rhn._M_hash_code; }\n       };\n \n   protected:\n@@ -1817,7 +1822,7 @@ namespace __detail\n     { }\n \n     bool\n-    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const\n+    _M_equals(const _Key& __k, __hash_code __c, const __node_type* __n) const\n     {\n       static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},\n \t  \"key equality predicate must be invocable with two arguments of \"\n@@ -1826,6 +1831,14 @@ namespace __detail\n \t&& _M_eq()(__k, this->_M_extract()(__n->_M_v()));\n     }\n \n+    bool\n+    _M_node_equals(const __node_type* __lhn, const __node_type* __rhn) const\n+    {\n+      return _Equal_hash_code<__node_type>::_S_node_equals(*__lhn, *__rhn)\n+\t&& _M_eq()(this->_M_extract()(__lhn->_M_v()),\n+\t\t   this->_M_extract()(__rhn->_M_v()));\n+    }\n+\n     void\n     _M_swap(_Hashtable_base& __x)\n     {\n@@ -1950,14 +1963,18 @@ namespace __detail\n \t    return false;\n \n \t  __node_type* __y_n = static_cast<__node_type*>(__y_prev_n->_M_nxt);\n-\t  for (;; __y_n = __y_n->_M_next())\n+\t  for (;;)\n \t    {\n \t      if (__this->key_eq()(_ExtractKey()(__y_n->_M_v()),\n \t\t\t\t   _ExtractKey()(*__itx)))\n \t\tbreak;\n \n-\t      if (!__y_n->_M_nxt\n-\t\t  || __other._M_bucket_index(__y_n->_M_next()) != __ybkt)\n+\t      __node_type* __y_ref_n = __y_n;\n+\t      for (__y_n = __y_n->_M_next(); __y_n; __y_n = __y_n->_M_next())\n+\t\tif (!__other._M_node_equals(__y_ref_n, __y_n))\n+\t\t  break;\n+\n+\t      if (!__y_n || __other._M_bucket_index(__y_n) != __ybkt)\n \t\treturn false;\n \t    }\n "}]}