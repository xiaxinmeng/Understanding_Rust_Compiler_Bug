{"sha": "fdb1c7b3589006cd3db587172626f22fff1f8988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRiMWM3YjM1ODkwMDZjZDNkYjU4NzE3MjYyNmYyMmZmZjFmODk4OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-24T15:31:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-24T15:31:04Z"}, "message": "emit-rtl.c (change_address, [...]): Return early when there is nothing to change.\n\n\t* emit-rtl.c (change_address, adjust_address_1, offset_address,\n\twiden_memory_access):  Return early when there is nothing to change.\n\nFrom-SVN: r76512", "tree": {"sha": "f05a3f300306fc4f9d1ee7e63305439f7119b17f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f05a3f300306fc4f9d1ee7e63305439f7119b17f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdb1c7b3589006cd3db587172626f22fff1f8988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb1c7b3589006cd3db587172626f22fff1f8988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdb1c7b3589006cd3db587172626f22fff1f8988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb1c7b3589006cd3db587172626f22fff1f8988/comments", "author": null, "committer": null, "parents": [{"sha": "8865bf80eeef29f6094b120cf7a32e22c868b76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8865bf80eeef29f6094b120cf7a32e22c868b76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8865bf80eeef29f6094b120cf7a32e22c868b76d"}], "stats": {"total": 22, "additions": 22, "deletions": 0}, "files": [{"sha": "54e0d4f1d84e7005804f54713b8fbd6f7a6f8148", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb1c7b3589006cd3db587172626f22fff1f8988/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb1c7b3589006cd3db587172626f22fff1f8988/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdb1c7b3589006cd3db587172626f22fff1f8988", "patch": "@@ -1,3 +1,8 @@\n+2004-01-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* emit-rtl.c (change_address, adjust_address_1, offset_address,\n+\twiden_memory_access):  Return early when there is nothing to change.\n+\n 2004-01-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* simplify-rtx.c (simplify_relational_operation): Don't"}, {"sha": "294577c2d5cfd4e0258332f06e09b4d1dea26499", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb1c7b3589006cd3db587172626f22fff1f8988/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb1c7b3589006cd3db587172626f22fff1f8988/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=fdb1c7b3589006cd3db587172626f22fff1f8988", "patch": "@@ -1872,6 +1872,10 @@ change_address (rtx memref, enum machine_mode mode, rtx addr)\n   rtx new = change_address_1 (memref, mode, addr, 1);\n   enum machine_mode mmode = GET_MODE (new);\n \n+  /* If there are no changes, just return the original memory reference.  */\n+  if (new == memref)\n+    return new;\n+\n   MEM_ATTRS (new)\n     = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0,\n \t\t     mmode == BLKmode ? 0 : GEN_INT (GET_MODE_SIZE (mmode)),\n@@ -1898,6 +1902,11 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n   rtx size = 0;\n   unsigned int memalign = MEM_ALIGN (memref);\n \n+  /* If there are no changes, just return the original memory reference.  */\n+  if (mode == GET_MODE (memref) && !offset\n+      && (!validate || memory_address_p (mode, addr)))\n+    return memref;\n+\n   /* ??? Prefer to create garbage instead of creating shared rtl.\n      This may happen even if offset is nonzero -- consider\n      (plus (plus reg reg) const_int) -- so do this always.  */\n@@ -1988,6 +1997,10 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n   update_temp_slot_address (XEXP (memref, 0), new);\n   new = change_address_1 (memref, VOIDmode, new, 1);\n \n+  /* If there are no changes, just return the original memory reference.  */\n+  if (new == memref)\n+    return new;\n+\n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */\n   MEM_ATTRS (new)\n@@ -2032,6 +2045,10 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n   rtx memoffset = MEM_OFFSET (new);\n   unsigned int size = GET_MODE_SIZE (mode);\n \n+  /* If there are no changes, just return the original memory reference.  */\n+  if (new == memref)\n+    return new;\n+\n   /* If we don't know what offset we were at within the expression, then\n      we can't know if we've overstepped the bounds.  */\n   if (! memoffset)"}]}