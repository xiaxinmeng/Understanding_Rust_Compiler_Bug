{"sha": "c67846f2826f296dbe8a2232310c6ffcfbb682a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY3ODQ2ZjI4MjZmMjk2ZGJlOGEyMjMyMzEwYzZmZmNmYmI2ODJhMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-07-13T18:19:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-07-13T18:19:27Z"}, "message": "calls.c (stored_args_map): New variable.\n\n\t* calls.c (stored_args_map): New variable.\n\t(check_sibcall_argument_overlap_1): New.\n\t(check_sibcall_argument_overlap): New.\n\t(expand_call): Initialize stored_args_map.\n\tCall check_sibcall_argument_overlap.\n\n\t* gcc.c-torture/execute/20000707-1.c: New test.\n\nFrom-SVN: r35017", "tree": {"sha": "367ba4c9422b7ad93273efb447abfe804fc2163b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/367ba4c9422b7ad93273efb447abfe804fc2163b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c67846f2826f296dbe8a2232310c6ffcfbb682a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67846f2826f296dbe8a2232310c6ffcfbb682a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c67846f2826f296dbe8a2232310c6ffcfbb682a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67846f2826f296dbe8a2232310c6ffcfbb682a2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7dec90a1bcc06b467c18ec3129f880c5ea9777b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dec90a1bcc06b467c18ec3129f880c5ea9777b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dec90a1bcc06b467c18ec3129f880c5ea9777b8"}], "stats": {"total": 169, "additions": 164, "deletions": 5}, "files": [{"sha": "355eb2ec0e2011c067cf7e4c282d12b33df1ddb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c67846f2826f296dbe8a2232310c6ffcfbb682a2", "patch": "@@ -1,3 +1,11 @@\n+2000-07-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* calls.c (stored_args_map): New variable.\n+\t(check_sibcall_argument_overlap_1): New.\n+\t(check_sibcall_argument_overlap): New.\n+\t(expand_call): Initialize stored_args_map.\n+\tCall check_sibcall_argument_overlap.\n+\n 2000-07-13  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/fixfixes.c: move EXIT_BROKEN to header, add sub-expr max count"}, {"sha": "784b3b165f8919253736f1e08e9d482a95884e2d", "filename": "gcc/calls.c", "status": "modified", "additions": 125, "deletions": 5, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c67846f2826f296dbe8a2232310c6ffcfbb682a2", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"tm_p.h\"\n #include \"timevar.h\"\n+#include \"sbitmap.h\"\n \n #ifndef ACCUMULATE_OUTGOING_ARGS\n #define ACCUMULATE_OUTGOING_ARGS 0\n@@ -145,6 +146,13 @@ static char *stack_usage_map;\n /* Size of STACK_USAGE_MAP.  */\n static int highest_outgoing_arg_in_use;\n \n+/* A bitmap of virtual-incoming stack space.  Bit is set if the corresponding\n+   stack location's tail call argument has been already stored into the stack.\n+   This bitmap is used to prevent sibling call optimization if function tries\n+   to use parent's incoming argument slots when they have been already\n+   overwritten with tail call arguments.  */\n+static sbitmap stored_args_map;\n+\n /* stack_arg_under_construction is nonzero when an argument may be\n    initialized with a constructor call (including a C function that\n    returns a BLKmode struct) and expand_call must take special action\n@@ -215,6 +223,9 @@ static int special_function_p\t\t\tPARAMS ((tree, int));\n static int flags_from_decl_or_type \t\tPARAMS ((tree));\n static rtx try_to_integrate\t\t\tPARAMS ((tree, tree, rtx,\n \t\t\t\t\t\t\t int, tree, rtx));\n+static int check_sibcall_argument_overlap_1\tPARAMS ((rtx));\n+static int check_sibcall_argument_overlap\tPARAMS ((rtx, struct arg_data *));\n+\n static int combine_pending_stack_adjustment_and_call\n                                                 PARAMS ((int, struct args_size *, int));\n \n@@ -1917,6 +1928,95 @@ combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n   return adjustment;\n }\n \n+/* Scan X expression if it does not dereference any argument slots\n+   we already clobbered by tail call arguments (as noted in stored_args_map\n+   bitmap).\n+   Return non-zero if X expression dereferences such argument slots,\n+   zero otherwise.  */\n+\n+static int\n+check_sibcall_argument_overlap_1 (x)\n+     rtx x;\n+{\n+  RTX_CODE code;\n+  int i, j;\n+  unsigned int k;\n+  const char *fmt;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+\n+  if (code == MEM)\n+    {\n+      if (XEXP (x, 0) == current_function_internal_arg_pointer)\n+\ti = 0;\n+      else if (GET_CODE (XEXP (x, 0)) == PLUS &&\n+\t       XEXP (XEXP (x, 0), 0) ==\n+\t\t current_function_internal_arg_pointer &&\n+\t       GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n+      else\n+\treturn 0;\n+\n+      for (k = 0; k < GET_MODE_SIZE (GET_MODE (x)); k++)\n+\tif (i + k < stored_args_map->n_bits\n+\t    && TEST_BIT (stored_args_map, i + k))\n+\t  return 1;\n+\n+      return 0;\n+    }\n+\n+  /* Scan all subexpressions. */\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n+    {\n+      if (*fmt == 'e')\n+        {\n+          if (check_sibcall_argument_overlap_1 (XEXP (x, i)))\n+            return 1;\n+        }\n+      else if (*fmt == 'E')\n+        {\n+          for (j = 0; j < XVECLEN (x, i); j++)\n+            if (check_sibcall_argument_overlap_1 (XVECEXP (x, i, j)))\n+              return 1;\n+        }\n+    }\n+  return 0;\n+\n+}\n+\n+/* Scan sequence after INSN if it does not dereference any argument slots\n+   we already clobbered by tail call arguments (as noted in stored_args_map\n+   bitmap).  Add stack slots for ARG to stored_args_map bitmap afterwards.\n+   Return non-zero if sequence after INSN dereferences such argument slots,\n+   zero otherwise.  */\n+\n+static int\n+check_sibcall_argument_overlap (insn, arg)\n+     rtx insn;\n+     struct arg_data *arg;\n+{     \n+  int low, high;\n+\n+  if (insn == NULL_RTX)\n+    insn = get_insns ();\n+  else\n+    insn = NEXT_INSN (insn);\n+\n+  for (; insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) &&\n+\tcheck_sibcall_argument_overlap_1 (PATTERN (insn)))\n+      break;\n+\n+  low = arg->offset.constant;\n+  for (high = low + arg->size.constant; low < high; low++)\n+    SET_BIT (stored_args_map, low);\n+  return insn != NULL_RTX;\n+}\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -2589,7 +2689,11 @@ expand_call (exp, target, ignore)\n       /* The argument block when performing a sibling call is the\n          incoming argument block.  */\n       if (pass == 0)\n-\targblock = virtual_incoming_args_rtx;\n+\t{\n+\t  argblock = virtual_incoming_args_rtx;\n+\t  stored_args_map = sbitmap_alloc (args_size.constant);\n+\t  sbitmap_zero (stored_args_map);\n+\t}\n \n       /* If we have no actual push instructions, or shouldn't use them,\n \t make space for all args right now.  */\n@@ -2840,8 +2944,15 @@ expand_call (exp, target, ignore)\n \n       for (i = 0; i < num_actuals; i++)\n \tif (args[i].reg == 0 || args[i].pass_on_stack)\n-\t  store_one_arg (&args[i], argblock, flags,\n-\t\t\t adjusted_args_size.var != 0, reg_parm_stack_space);\n+\t  {\n+\t    rtx before_arg = get_last_insn ();\n+\n+\t    store_one_arg (&args[i], argblock, flags,\n+\t\t\t   adjusted_args_size.var != 0, reg_parm_stack_space);\n+\t    if (pass == 0 &&\n+\t\tcheck_sibcall_argument_overlap (before_arg, &args[i]))\n+\t      sibcall_failure = 1;\n+\t  }\n \n       /* If we have a parm that is passed in registers but not in memory\n \t and whose alignment does not permit a direct copy into registers,\n@@ -2855,8 +2966,15 @@ expand_call (exp, target, ignore)\n       if (reg_parm_seen)\n \tfor (i = 0; i < num_actuals; i++)\n \t  if (args[i].partial != 0 && ! args[i].pass_on_stack)\n-\t    store_one_arg (&args[i], argblock, flags,\n-\t\t\t   adjusted_args_size.var != 0, reg_parm_stack_space);\n+\t    {\n+\t      rtx before_arg = get_last_insn ();\n+\n+\t      store_one_arg (&args[i], argblock, flags,\n+\t\t\t     adjusted_args_size.var != 0, reg_parm_stack_space);\n+\t      if (pass == 0 &&\n+\t\t  check_sibcall_argument_overlap (before_arg, &args[i]))\n+\t\tsibcall_failure = 1;\n+\t    }\n \n #ifdef PREFERRED_STACK_BOUNDARY\n       /* If we pushed args in forward order, perform stack alignment\n@@ -3234,6 +3352,8 @@ expand_call (exp, target, ignore)\n \t      args[i].aligned_regs = 0;\n \t      args[i].stack = 0;\n \t    }\n+\n+\t  sbitmap_free (stored_args_map);\n \t}\n       else\n \tnormal_call_insns = insns;"}, {"sha": "1f94bdbdaeb2bbfab3613d9ae56324fc5f293f3c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c67846f2826f296dbe8a2232310c6ffcfbb682a2", "patch": "@@ -1,3 +1,7 @@\n+2000-07-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/20000707-1.c: New test.\n+\n 2000-07-13  Neil Booth  <NeilB@earthling.net>\n \n \t* testsuite/gcc.dg/cpp/digraph1.c,"}, {"sha": "f1c50a923600ce596add7c7964761daa8b27184f", "filename": "gcc/testsuite/gcc.c-torture/execute/20000707-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000707-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67846f2826f296dbe8a2232310c6ffcfbb682a2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000707-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000707-1.c?ref=c67846f2826f296dbe8a2232310c6ffcfbb682a2", "patch": "@@ -0,0 +1,27 @@\n+extern void abort(void);\n+extern void exit(int);\n+\n+struct baz {\n+  int a, b, c;\n+};\n+\n+void\n+foo (int a, int b, int c)\n+{\n+  if (a != 4)\n+    abort ();\n+}\n+\n+void\n+bar (struct baz x, int b, int c)\n+{\n+  foo (x.b, b, c);\n+}\n+\n+int\n+main ()\n+{\n+  struct baz x = { 3, 4, 5 };\n+  bar (x, 1, 2);\n+  exit (0);\n+}"}]}