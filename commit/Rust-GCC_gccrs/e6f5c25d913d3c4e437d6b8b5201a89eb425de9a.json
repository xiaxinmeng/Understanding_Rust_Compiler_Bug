{"sha": "e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZmNWMyNWQ5MTNkM2M0ZTQzN2Q2YjhiNTIwMWE4OWViNDI1ZGU5YQ==", "commit": {"author": {"name": "Ilya Enkovich", "email": "enkovich.gnu@gmail.com", "date": "2015-11-10T12:17:30Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-11-10T12:17:30Z"}, "message": "optabs.c (expand_binop_directly): Allow scalar mode for vec_pack_trunc_optab.\n\ngcc/\n\n\t* optabs.c (expand_binop_directly): Allow scalar mode for\n\tvec_pack_trunc_optab.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Skip\n\tboolean vector producers from pattern sequence when computing VF.\n\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs) Add\n\tvect_recog_mask_conversion_pattern.\n\t(search_type_for_mask): Choose the smallest\n\ttype if different size types are mixed.\n\t(build_mask_conversion): New.\n\t(vect_recog_mask_conversion_pattern): New.\n\t(vect_pattern_recog_1): Allow scalar mode for boolean vectype.\n\t* tree-vect-stmts.c (vectorizable_mask_load_store): Support masked\n\tload with pattern.\n\t(vectorizable_conversion): Support boolean vectors.\n\t(free_stmt_vec_info): Allow patterns for statements with no lhs.\n\t* tree-vectorizer.h (NUM_PATTERNS): Increase to 14.\n\nFrom-SVN: r230103", "tree": {"sha": "76e1468bb4db0910939806b18fe2186d568dc3f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76e1468bb4db0910939806b18fe2186d568dc3f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/comments", "author": null, "committer": null, "parents": [{"sha": "f79fe06f4d803a294ec182cc61972c7d706ede70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f79fe06f4d803a294ec182cc61972c7d706ede70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f79fe06f4d803a294ec182cc61972c7d706ede70"}], "stats": {"total": 372, "additions": 345, "deletions": 27}, "files": [{"sha": "e868b5d460041af89fb0d49e224c6f7f157ac50a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "patch": "@@ -1,3 +1,22 @@\n+2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* optabs.c (expand_binop_directly): Allow scalar mode for\n+\tvec_pack_trunc_optab.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Skip\n+\tboolean vector producers from pattern sequence when computing VF.\n+\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs) Add\n+\tvect_recog_mask_conversion_pattern.\n+\t(search_type_for_mask): Choose the smallest\n+\ttype if different size types are mixed.\n+\t(build_mask_conversion): New.\n+\t(vect_recog_mask_conversion_pattern): New.\n+\t(vect_pattern_recog_1): Allow scalar mode for boolean vectype.\n+\t* tree-vect-stmts.c (vectorizable_mask_load_store): Support masked\n+\tload with pattern.\n+\t(vectorizable_conversion): Support boolean vectors.\n+\t(free_stmt_vec_info): Allow patterns for statements with no lhs.\n+\t* tree-vectorizer.h (NUM_PATTERNS): Increase to 14.\n+\n 2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* config/i386/i386-protos.h (ix86_expand_sse_movcc): New."}, {"sha": "554530282db8cbb0a889262c8d40492d85794418", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "patch": "@@ -1047,7 +1047,8 @@ expand_binop_directly (machine_mode mode, optab binoptab,\n       /* The mode of the result is different then the mode of the\n \t arguments.  */\n       tmp_mode = insn_data[(int) icode].operand[0].mode;\n-      if (GET_MODE_NUNITS (tmp_mode) != 2 * GET_MODE_NUNITS (mode))\n+      if (VECTOR_MODE_P (mode)\n+\t  && GET_MODE_NUNITS (tmp_mode) != 2 * GET_MODE_NUNITS (mode))\n \t{\n \t  delete_insns_since (last);\n \t  return NULL_RTX;"}, {"sha": "55e53093caaf663d592dccbf2c913f334f79b3d9", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "patch": "@@ -492,20 +492,27 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t}\n             }\n \n-\t  /* The vectorization factor is according to the smallest\n-\t     scalar type (or the largest vector size, but we only\n-\t     support one vector size per loop).  */\n-\t  if (!bool_result)\n-\t    scalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n-\t\t\t\t\t\t\t &dummy);\n-\t  if (dump_enabled_p ())\n+\t  /* Don't try to compute VF out scalar types if we stmt\n+\t     produces boolean vector.  Use result vectype instead.  */\n+\t  if (VECTOR_BOOLEAN_TYPE_P (vectype))\n+\t    vf_vectype = vectype;\n+\t  else\n \t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"get vectype for scalar type:  \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n-              dump_printf (MSG_NOTE, \"\\n\");\n+\t      /* The vectorization factor is according to the smallest\n+\t\t scalar type (or the largest vector size, but we only\n+\t\t support one vector size per loop).  */\n+\t      if (!bool_result)\n+\t\tscalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n+\t\t\t\t\t\t\t     &dummy);\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t   \"get vectype for scalar type:  \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n+\t\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t\t}\n+\t      vf_vectype = get_vectype_for_scalar_type (scalar_type);\n \t    }\n-\t  vf_vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vf_vectype)\n \t    {\n \t      if (dump_enabled_p ())"}, {"sha": "b9d900c1bad93ccedc9ee7f888fc05ad212618ff", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 270, "deletions": 5, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "patch": "@@ -66,6 +66,7 @@ static gimple *vect_recog_mult_pattern (vec<gimple *> *,\n static gimple *vect_recog_mixed_size_cond_pattern (vec<gimple *> *,\n \t\t\t\t\t\t  tree *, tree *);\n static gimple *vect_recog_bool_pattern (vec<gimple *> *, tree *, tree *);\n+static gimple *vect_recog_mask_conversion_pattern (vec<gimple *> *, tree *, tree *);\n static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_mult_pattern,\n \tvect_recog_widen_sum_pattern,\n@@ -79,7 +80,8 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_divmod_pattern,\n \tvect_recog_mult_pattern,\n \tvect_recog_mixed_size_cond_pattern,\n-\tvect_recog_bool_pattern};\n+\tvect_recog_bool_pattern,\n+\tvect_recog_mask_conversion_pattern};\n \n static inline void\n append_pattern_def_seq (stmt_vec_info stmt_info, gimple *stmt)\n@@ -3152,7 +3154,7 @@ search_type_for_mask (tree var, vec_info *vinfo)\n   enum vect_def_type dt;\n   tree rhs1;\n   enum tree_code rhs_code;\n-  tree res = NULL_TREE;\n+  tree res = NULL_TREE, res2;\n \n   if (TREE_CODE (var) != SSA_NAME)\n     return NULL_TREE;\n@@ -3185,13 +3187,26 @@ search_type_for_mask (tree var, vec_info *vinfo)\n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n-      if (!(res = search_type_for_mask (rhs1, vinfo)))\n-\tres = search_type_for_mask (gimple_assign_rhs2 (def_stmt), vinfo);\n+      res = search_type_for_mask (rhs1, vinfo);\n+      res2 = search_type_for_mask (gimple_assign_rhs2 (def_stmt), vinfo);\n+      if (!res || (res2 && TYPE_PRECISION (res) > TYPE_PRECISION (res2)))\n+\tres = res2;\n       break;\n \n     default:\n       if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n \t{\n+\t  tree comp_vectype, mask_type;\n+\n+\t  comp_vectype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n+\t  if (comp_vectype == NULL_TREE)\n+\t    return NULL_TREE;\n+\n+\t  mask_type = get_mask_type_for_scalar_type (TREE_TYPE (rhs1));\n+\t  if (!mask_type\n+\t      || !expand_vec_cmp_expr_p (comp_vectype, mask_type))\n+\t    return NULL_TREE;\n+\n \t  if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE\n \t      || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n \t    {\n@@ -3453,6 +3468,255 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n }\n \n \n+/* A helper for vect_recog_mask_conversion_pattern.  Build\n+   conversion of MASK to a type suitable for masking VECTYPE.\n+   Built statement gets required vectype and is appended to\n+   a pattern sequence of STMT_VINFO.\n+\n+   Return converted mask.  */\n+\n+static tree\n+build_mask_conversion (tree mask, tree vectype, stmt_vec_info stmt_vinfo,\n+\t\t       vec_info *vinfo)\n+{\n+  gimple *stmt;\n+  tree masktype, tmp;\n+  stmt_vec_info new_stmt_info;\n+\n+  masktype = build_same_sized_truth_vector_type (vectype);\n+  tmp = vect_recog_temp_ssa_var (TREE_TYPE (masktype), NULL);\n+  stmt = gimple_build_assign (tmp, CONVERT_EXPR, mask);\n+  new_stmt_info = new_stmt_vec_info (stmt, vinfo);\n+  set_vinfo_for_stmt (stmt, new_stmt_info);\n+  STMT_VINFO_VECTYPE (new_stmt_info) = masktype;\n+  append_pattern_def_seq (stmt_vinfo, stmt);\n+\n+  return tmp;\n+}\n+\n+\n+/* Function vect_recog_mask_conversion_pattern\n+\n+   Try to find statements which require boolean type\n+   converison.  Additional conversion statements are\n+   added to handle such cases.  For example:\n+\n+   bool m_1, m_2, m_3;\n+   int i_4, i_5;\n+   double d_6, d_7;\n+   char c_1, c_2, c_3;\n+\n+   S1   m_1 = i_4 > i_5;\n+   S2   m_2 = d_6 < d_7;\n+   S3   m_3 = m_1 & m_2;\n+   S4   c_1 = m_3 ? c_2 : c_3;\n+\n+   Will be transformed into:\n+\n+   S1   m_1 = i_4 > i_5;\n+   S2   m_2 = d_6 < d_7;\n+   S3'' m_2' = (_Bool[bitsize=32])m_2\n+   S3'  m_3' = m_1 & m_2';\n+   S4'' m_3'' = (_Bool[bitsize=8])m_3'\n+   S4'  c_1' = m_3'' ? c_2 : c_3;  */\n+\n+static gimple *\n+vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n+\t\t\t\t    tree *type_out)\n+{\n+  gimple *last_stmt = stmts->pop ();\n+  enum tree_code rhs_code;\n+  tree lhs, rhs1, rhs2, tmp, rhs1_type, rhs2_type, vectype1, vectype2;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  stmt_vec_info pattern_stmt_info;\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n+  gimple *pattern_stmt;\n+\n+  /* Check for MASK_LOAD ans MASK_STORE calls requiring mask conversion.  */\n+  if (is_gimple_call (last_stmt)\n+      && gimple_call_internal_p (last_stmt)\n+      && (gimple_call_internal_fn (last_stmt) == IFN_MASK_STORE\n+\t  || gimple_call_internal_fn (last_stmt) == IFN_MASK_LOAD))\n+    {\n+      bool load = (gimple_call_internal_fn (last_stmt) == IFN_MASK_LOAD);\n+\n+      if (load)\n+\t{\n+\t  lhs = gimple_call_lhs (last_stmt);\n+\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+\t}\n+      else\n+\t{\n+\t  rhs2 = gimple_call_arg (last_stmt, 3);\n+\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (rhs2));\n+\t}\n+\n+      rhs1 = gimple_call_arg (last_stmt, 2);\n+      rhs1_type = search_type_for_mask (rhs1, vinfo);\n+      if (!rhs1_type)\n+\treturn NULL;\n+      vectype2 = get_mask_type_for_scalar_type (rhs1_type);\n+\n+      if (!vectype1 || !vectype2\n+\t  || TYPE_VECTOR_SUBPARTS (vectype1) == TYPE_VECTOR_SUBPARTS (vectype2))\n+\treturn NULL;\n+\n+      tmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+\n+      if (load)\n+\t{\n+\t  lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+\t  pattern_stmt\n+\t    = gimple_build_call_internal (IFN_MASK_LOAD, 3,\n+\t\t\t\t\t  gimple_call_arg (last_stmt, 0),\n+\t\t\t\t\t  gimple_call_arg (last_stmt, 1),\n+\t\t\t\t\t  tmp);\n+\t  gimple_call_set_lhs (pattern_stmt, lhs);\n+\t}\n+      else\n+\t  pattern_stmt\n+\t    = gimple_build_call_internal (IFN_MASK_STORE, 4,\n+\t\t\t\t\t  gimple_call_arg (last_stmt, 0),\n+\t\t\t\t\t  gimple_call_arg (last_stmt, 1),\n+\t\t\t\t\t  tmp,\n+\t\t\t\t\t  gimple_call_arg (last_stmt, 3));\n+\n+\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n+      set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+      STMT_VINFO_DATA_REF (pattern_stmt_info)\n+\t= STMT_VINFO_DATA_REF (stmt_vinfo);\n+      STMT_VINFO_DR_BASE_ADDRESS (pattern_stmt_info)\n+\t= STMT_VINFO_DR_BASE_ADDRESS (stmt_vinfo);\n+      STMT_VINFO_DR_INIT (pattern_stmt_info) = STMT_VINFO_DR_INIT (stmt_vinfo);\n+      STMT_VINFO_DR_OFFSET (pattern_stmt_info)\n+\t= STMT_VINFO_DR_OFFSET (stmt_vinfo);\n+      STMT_VINFO_DR_STEP (pattern_stmt_info) = STMT_VINFO_DR_STEP (stmt_vinfo);\n+      STMT_VINFO_DR_ALIGNED_TO (pattern_stmt_info)\n+\t= STMT_VINFO_DR_ALIGNED_TO (stmt_vinfo);\n+      DR_STMT (STMT_VINFO_DATA_REF (stmt_vinfo)) = pattern_stmt;\n+\n+      *type_out = vectype1;\n+      *type_in = vectype1;\n+      stmts->safe_push (last_stmt);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"vect_recog_mask_conversion_pattern: detected:\\n\");\n+\n+      return pattern_stmt;\n+    }\n+\n+  if (!is_gimple_assign (last_stmt))\n+    return NULL;\n+\n+  lhs = gimple_assign_lhs (last_stmt);\n+  rhs1 = gimple_assign_rhs1 (last_stmt);\n+  rhs_code = gimple_assign_rhs_code (last_stmt);\n+\n+  /* Check for cond expression requiring mask conversion.  */\n+  if (rhs_code == COND_EXPR)\n+    {\n+      /* vect_recog_mixed_size_cond_pattern could apply.\n+\t Do nothing then.  */\n+      if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+\treturn NULL;\n+\n+      vectype1 = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+\n+      if (TREE_CODE (rhs1) == SSA_NAME)\n+\t{\n+\t  rhs1_type = search_type_for_mask (rhs1, vinfo);\n+\t  if (!rhs1_type)\n+\t    return NULL;\n+\t}\n+      else\n+\trhs1_type = TREE_TYPE (TREE_OPERAND (rhs1, 0));\n+\n+      vectype2 = get_mask_type_for_scalar_type (rhs1_type);\n+\n+      if (!vectype1 || !vectype2\n+\t  || TYPE_VECTOR_SUBPARTS (vectype1) == TYPE_VECTOR_SUBPARTS (vectype2))\n+\treturn NULL;\n+\n+      /* If rhs1 is a comparison we need to move it into a\n+\t separate statement.  */\n+      if (TREE_CODE (rhs1) != SSA_NAME)\n+\t{\n+\t  tmp = vect_recog_temp_ssa_var (TREE_TYPE (rhs1), NULL);\n+\t  pattern_stmt = gimple_build_assign (tmp, rhs1);\n+\t  rhs1 = tmp;\n+\n+\t  pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n+\t  set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+\t  STMT_VINFO_VECTYPE (pattern_stmt_info) = vectype2;\n+\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\t}\n+\n+      tmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+\n+      lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+      pattern_stmt = gimple_build_assign (lhs, COND_EXPR, tmp,\n+\t\t\t\t\t  gimple_assign_rhs2 (last_stmt),\n+\t\t\t\t\t  gimple_assign_rhs3 (last_stmt));\n+\n+      *type_out = vectype1;\n+      *type_in = vectype1;\n+      stmts->safe_push (last_stmt);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"vect_recog_mask_conversion_pattern: detected:\\n\");\n+\n+      return pattern_stmt;\n+    }\n+\n+  /* Now check for binary boolean operations requiring conversion for\n+     one of operands.  */\n+  if (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n+    return NULL;\n+\n+  if (rhs_code != BIT_IOR_EXPR\n+      && rhs_code != BIT_XOR_EXPR\n+      && rhs_code != BIT_AND_EXPR)\n+    return NULL;\n+\n+  rhs2 = gimple_assign_rhs2 (last_stmt);\n+\n+  rhs1_type = search_type_for_mask (rhs1, vinfo);\n+  rhs2_type = search_type_for_mask (rhs2, vinfo);\n+\n+  if (!rhs1_type || !rhs2_type\n+      || TYPE_PRECISION (rhs1_type) == TYPE_PRECISION (rhs2_type))\n+    return NULL;\n+\n+  if (TYPE_PRECISION (rhs1_type) < TYPE_PRECISION (rhs2_type))\n+    {\n+      vectype1 = get_mask_type_for_scalar_type (rhs1_type);\n+      if (!vectype1)\n+\treturn NULL;\n+      rhs2 = build_mask_conversion (rhs2, vectype1, stmt_vinfo, vinfo);\n+    }\n+  else\n+    {\n+      vectype1 = get_mask_type_for_scalar_type (rhs2_type);\n+      if (!vectype1)\n+\treturn NULL;\n+      rhs1 = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+    }\n+\n+  lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+  pattern_stmt = gimple_build_assign (lhs, rhs_code, rhs1, rhs2);\n+\n+  *type_out = vectype1;\n+  *type_in = vectype1;\n+  stmts->safe_push (last_stmt);\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"vect_recog_mask_conversion_pattern: detected:\\n\");\n+\n+  return pattern_stmt;\n+}\n+\n+\n /* Mark statements that are involved in a pattern.  */\n \n static inline void\n@@ -3548,7 +3812,8 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n   stmt_info = vinfo_for_stmt (stmt);\n   loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n  \n-  if (VECTOR_MODE_P (TYPE_MODE (type_in)))\n+  if (VECTOR_BOOLEAN_TYPE_P (type_in)\n+      || VECTOR_MODE_P (TYPE_MODE (type_in)))\n     {\n       /* No need to check target support (already checked by the pattern\n          recognition function).  */"}, {"sha": "cfe30e067ea7f838eb1186e26edb0b1dbfdb17d8", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "patch": "@@ -1974,6 +1974,11 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       /* Ensure that even with -fno-tree-dce the scalar MASK_LOAD is removed\n \t from the IL.  */\n+      if (STMT_VINFO_RELATED_STMT (stmt_info))\n+\t{\n+\t  stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+\t  stmt_info = vinfo_for_stmt (stmt);\n+\t}\n       tree lhs = gimple_call_lhs (stmt);\n       new_stmt = gimple_build_assign (lhs, build_zero_cst (TREE_TYPE (lhs)));\n       set_vinfo_for_stmt (new_stmt, stmt_info);\n@@ -2092,6 +2097,11 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       /* Ensure that even with -fno-tree-dce the scalar MASK_LOAD is removed\n \t from the IL.  */\n+      if (STMT_VINFO_RELATED_STMT (stmt_info))\n+\t{\n+\t  stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+\t  stmt_info = vinfo_for_stmt (stmt);\n+\t}\n       tree lhs = gimple_call_lhs (stmt);\n       new_stmt = gimple_build_assign (lhs, build_zero_cst (TREE_TYPE (lhs)));\n       set_vinfo_for_stmt (new_stmt, stmt_info);\n@@ -3565,12 +3575,13 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \t       && SCALAR_FLOAT_TYPE_P (rhs_type))))\n     return false;\n \n-  if ((INTEGRAL_TYPE_P (lhs_type)\n-       && (TYPE_PRECISION (lhs_type)\n-\t   != GET_MODE_PRECISION (TYPE_MODE (lhs_type))))\n-      || (INTEGRAL_TYPE_P (rhs_type)\n-\t  && (TYPE_PRECISION (rhs_type)\n-\t      != GET_MODE_PRECISION (TYPE_MODE (rhs_type)))))\n+  if (!VECTOR_BOOLEAN_TYPE_P (vectype_out)\n+      && ((INTEGRAL_TYPE_P (lhs_type)\n+\t   && (TYPE_PRECISION (lhs_type)\n+\t       != GET_MODE_PRECISION (TYPE_MODE (lhs_type))))\n+\t  || (INTEGRAL_TYPE_P (rhs_type)\n+\t      && (TYPE_PRECISION (rhs_type)\n+\t\t  != GET_MODE_PRECISION (TYPE_MODE (rhs_type))))))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3628,6 +3639,21 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n+  if (VECTOR_BOOLEAN_TYPE_P (vectype_out)\n+      && !VECTOR_BOOLEAN_TYPE_P (vectype_in))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"can't convert between boolean and non \"\n+\t\t\t   \"boolean vectors\");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t}\n+\n+      return false;\n+    }\n+\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_in < nunits_out)\n@@ -8217,7 +8243,7 @@ free_stmt_vec_info (gimple *stmt)\n \t  gimple *patt_stmt = STMT_VINFO_STMT (patt_info);\n \t  gimple_set_bb (patt_stmt, NULL);\n \t  tree lhs = gimple_get_lhs (patt_stmt);\n-\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t    release_ssa_name (lhs);\n \t  if (seq)\n \t    {\n@@ -8227,7 +8253,7 @@ free_stmt_vec_info (gimple *stmt)\n \t\t  gimple *seq_stmt = gsi_stmt (si);\n \t\t  gimple_set_bb (seq_stmt, NULL);\n \t\t  lhs = gimple_get_lhs (seq_stmt);\n-\t\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t\t    release_ssa_name (lhs);\n \t\t  free_stmt_vec_info (seq_stmt);\n \t\t}"}, {"sha": "6ad0cc452f1168ce6ee48cc03ae140fc947f2a8d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f5c25d913d3c4e437d6b8b5201a89eb425de9a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e6f5c25d913d3c4e437d6b8b5201a89eb425de9a", "patch": "@@ -1087,7 +1087,7 @@ extern gimple *vect_find_last_scalar_stmt_in_slp (slp_tree);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple *(* vect_recog_func_ptr) (vec<gimple *> *, tree *, tree *);\n-#define NUM_PATTERNS 13\n+#define NUM_PATTERNS 14\n void vect_pattern_recog (vec_info *);\n \n /* In tree-vectorizer.c.  */"}]}