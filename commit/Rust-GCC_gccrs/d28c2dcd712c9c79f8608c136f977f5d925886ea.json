{"sha": "d28c2dcd712c9c79f8608c136f977f5d925886ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4YzJkY2Q3MTJjOWM3OWY4NjA4YzEzNmY5NzdmNWQ5MjU4ODZlYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-01-02T17:53:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-01-02T17:53:16Z"}, "message": "DR 325 PR c++/51666\n\n\tDR 325\n\tPR c++/51666\n\t* parser.c (cp_parser_cache_defarg): Split out...\n\t(cp_parser_parameter_declaration): ...from here.\n\t(cp_parser_save_nsdmi): Use it.\n\t(cp_parser_cache_group): Remove CPP_COMMA support.\n\nFrom-SVN: r182809", "tree": {"sha": "c30554c93365fd0c34e6b77e07ded9f4919de105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c30554c93365fd0c34e6b77e07ded9f4919de105"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d28c2dcd712c9c79f8608c136f977f5d925886ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28c2dcd712c9c79f8608c136f977f5d925886ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d28c2dcd712c9c79f8608c136f977f5d925886ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28c2dcd712c9c79f8608c136f977f5d925886ea/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "358b9253c104e94701f6a52dfedac8c18269a0a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358b9253c104e94701f6a52dfedac8c18269a0a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358b9253c104e94701f6a52dfedac8c18269a0a7"}], "stats": {"total": 381, "additions": 213, "deletions": 168}, "files": [{"sha": "7668a7b6e089e1c2ceea72cab8ffb955f1c13934", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d28c2dcd712c9c79f8608c136f977f5d925886ea", "patch": "@@ -1,3 +1,12 @@\n+2012-01-02  Jason Merrill  <jason@redhat.com>\n+\n+\tDR 325\n+\tPR c++/51666\n+\t* parser.c (cp_parser_cache_defarg): Split out...\n+\t(cp_parser_parameter_declaration): ...from here.\n+\t(cp_parser_save_nsdmi): Use it.\n+\t(cp_parser_cache_group): Remove CPP_COMMA support.\n+\n 2012-01-02  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/51462"}, {"sha": "7e6915cf40557c9bc6d459db1e1ad057c105d496", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 179, "deletions": 168, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d28c2dcd712c9c79f8608c136f977f5d925886ea", "patch": "@@ -2249,6 +2249,8 @@ static void cp_parser_pre_parsed_nested_name_specifier\n   (cp_parser *);\n static bool cp_parser_cache_group\n   (cp_parser *, enum cpp_ttype, unsigned);\n+static tree cp_parser_cache_defarg\n+  (cp_parser *parser, bool nsdmi);\n static void cp_parser_parse_tentatively\n   (cp_parser *);\n static void cp_parser_commit_to_tentative_parse\n@@ -17267,159 +17269,18 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   /* If the next token is `=', then process a default argument.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n     {\n+      token = cp_lexer_peek_token (parser->lexer);\n       /* If we are defining a class, then the tokens that make up the\n \t default argument must be saved and processed later.  */\n       if (!template_parm_p && at_class_scope_p ()\n \t  && TYPE_BEING_DEFINED (current_class_type)\n \t  && !LAMBDA_TYPE_P (current_class_type))\n-\t{\n-\t  unsigned depth = 0;\n-\t  int maybe_template_id = 0;\n-\t  cp_token *first_token;\n-\t  cp_token *token;\n-\n-\t  /* Add tokens until we have processed the entire default\n-\t     argument.  We add the range [first_token, token).  */\n-\t  first_token = cp_lexer_peek_token (parser->lexer);\n-\t  while (true)\n-\t    {\n-\t      bool done = false;\n-\n-\t      /* Peek at the next token.  */\n-\t      token = cp_lexer_peek_token (parser->lexer);\n-\t      /* What we do depends on what token we have.  */\n-\t      switch (token->type)\n-\t\t{\n-\t\t  /* In valid code, a default argument must be\n-\t\t     immediately followed by a `,' `)', or `...'.  */\n-\t\tcase CPP_COMMA:\n-\t\t  if (depth == 0 && maybe_template_id)\n-\t\t    {\n-\t\t      /* If we've seen a '<', we might be in a\n-\t\t\t template-argument-list.  Until Core issue 325 is\n-\t\t\t resolved, we don't know how this situation ought\n-\t\t\t to be handled, so try to DTRT.  We check whether\n-\t\t\t what comes after the comma is a valid parameter\n-\t\t\t declaration list.  If it is, then the comma ends\n-\t\t\t the default argument; otherwise the default\n-\t\t\t argument continues.  */\n-\t\t      bool error = false;\n-\t\t      tree t;\n-\n-\t\t      /* Set ITALP so cp_parser_parameter_declaration_list\n-\t\t\t doesn't decide to commit to this parse.  */\n-\t\t      bool saved_italp = parser->in_template_argument_list_p;\n-\t\t      parser->in_template_argument_list_p = true;\n-\n-\t\t      cp_parser_parse_tentatively (parser);\n-\t\t      cp_lexer_consume_token (parser->lexer);\n-\t\t      begin_scope (sk_function_parms, NULL_TREE);\n-\t\t      cp_parser_parameter_declaration_list (parser, &error);\n-\t\t      for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n-\t\t\tpop_binding (DECL_NAME (t), t);\n-\t\t      leave_scope ();\n-\t\t      if (!cp_parser_error_occurred (parser) && !error)\n-\t\t\tdone = true;\n-\t\t      cp_parser_abort_tentative_parse (parser);\n-\n-\t\t      parser->in_template_argument_list_p = saved_italp;\n-\t\t      break;\n-\t\t    }\n-\t\tcase CPP_CLOSE_PAREN:\n-\t\tcase CPP_ELLIPSIS:\n-\t\t  /* If we run into a non-nested `;', `}', or `]',\n-\t\t     then the code is invalid -- but the default\n-\t\t     argument is certainly over.  */\n-\t\tcase CPP_SEMICOLON:\n-\t\tcase CPP_CLOSE_BRACE:\n-\t\tcase CPP_CLOSE_SQUARE:\n-\t\t  if (depth == 0)\n-\t\t    done = true;\n-\t\t  /* Update DEPTH, if necessary.  */\n-\t\t  else if (token->type == CPP_CLOSE_PAREN\n-\t\t\t   || token->type == CPP_CLOSE_BRACE\n-\t\t\t   || token->type == CPP_CLOSE_SQUARE)\n-\t\t    --depth;\n-\t\t  break;\n-\n-\t\tcase CPP_OPEN_PAREN:\n-\t\tcase CPP_OPEN_SQUARE:\n-\t\tcase CPP_OPEN_BRACE:\n-\t\t  ++depth;\n-\t\t  break;\n-\n-\t\tcase CPP_LESS:\n-\t\t  if (depth == 0)\n-\t\t    /* This might be the comparison operator, or it might\n-\t\t       start a template argument list.  */\n-\t\t    ++maybe_template_id;\n-\t\t  break;\n-\n-                case CPP_RSHIFT:\n-                  if (cxx_dialect == cxx98)\n-                    break;\n-                  /* Fall through for C++0x, which treats the `>>'\n-                     operator like two `>' tokens in certain\n-                     cases.  */\n-\n-\t\tcase CPP_GREATER:\n-\t\t  if (depth == 0)\n-\t\t    {\n-\t\t      /* This might be an operator, or it might close a\n-\t\t\t template argument list.  But if a previous '<'\n-\t\t\t started a template argument list, this will have\n-\t\t\t closed it, so we can't be in one anymore.  */\n-\t\t      maybe_template_id -= 1 + (token->type == CPP_RSHIFT);\n-\t\t      if (maybe_template_id < 0)\n-\t\t\tmaybe_template_id = 0;\n-\t\t    }\n-\t\t  break;\n-\n-\t\t  /* If we run out of tokens, issue an error message.  */\n-\t\tcase CPP_EOF:\n-\t\tcase CPP_PRAGMA_EOL:\n-\t\t  error_at (token->location, \"file ends in default argument\");\n-\t\t  done = true;\n-\t\t  break;\n-\n-\t\tcase CPP_NAME:\n-\t\tcase CPP_SCOPE:\n-\t\t  /* In these cases, we should look for template-ids.\n-\t\t     For example, if the default argument is\n-\t\t     `X<int, double>()', we need to do name lookup to\n-\t\t     figure out whether or not `X' is a template; if\n-\t\t     so, the `,' does not end the default argument.\n-\n-\t\t     That is not yet done.  */\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\n-\t      /* If we've reached the end, stop.  */\n-\t      if (done)\n-\t\tbreak;\n-\n-\t      /* Add the token to the token block.  */\n-\t      token = cp_lexer_consume_token (parser->lexer);\n-\t    }\n-\n-\t  /* Create a DEFAULT_ARG to represent the unparsed default\n-\t     argument.  */\n-\t  default_argument = make_node (DEFAULT_ARG);\n-\t  DEFARG_TOKENS (default_argument)\n-\t    = cp_token_cache_new (first_token, token);\n-\t  DEFARG_INSTANTIATIONS (default_argument) = NULL;\n-\t}\n+\tdefault_argument = cp_parser_cache_defarg (parser, /*nsdmi=*/false);\n       /* Outside of a class definition, we can just parse the\n \t assignment-expression.  */\n       else\n-\t{\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\t  default_argument \n-\t    = cp_parser_default_argument (parser, template_parm_p);\n-\t}\n+\tdefault_argument\n+\t  = cp_parser_default_argument (parser, template_parm_p);\n \n       if (!parser->default_arg_ok_p)\n \t{\n@@ -21630,25 +21491,9 @@ cp_parser_save_member_function_body (cp_parser* parser,\n static tree\n cp_parser_save_nsdmi (cp_parser* parser)\n {\n-  /* Save away the tokens that make up the body of the\n-     function.  */\n-  cp_token *first = parser->lexer->next_token;\n-  cp_token *last;\n-  tree node;\n-\n-  /* Save tokens until the next comma or semicolon.  */\n-  cp_parser_cache_group (parser, CPP_COMMA, /*depth=*/0);\n-\n-  last = parser->lexer->next_token;\n-\n-  node = make_node (DEFAULT_ARG);\n-  DEFARG_TOKENS (node) = cp_token_cache_new (first, last);\n-  DEFARG_INSTANTIATIONS (node) = NULL;\n-\n-  return node;\n+  return cp_parser_cache_defarg (parser, /*nsdmi=*/true);\n }\n \n-\n /* Parse a template-argument-list, as well as the trailing \">\" (but\n    not the opening \"<\").  See cp_parser_template_argument_list for the\n    return value.  */\n@@ -22758,12 +22603,6 @@ cp_parser_cache_group (cp_parser *parser,\n \t   kind of syntax error.  */\n \treturn true;\n \n-      /* If we're caching something finished by a comma (or semicolon),\n-\t such as an NSDMI, don't consume the comma.  */\n-      if (end == CPP_COMMA\n-\t  && (token->type == CPP_SEMICOLON || token->type == CPP_COMMA))\n-\treturn false;\n-\n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* See if it starts a new group.  */\n@@ -22789,6 +22628,178 @@ cp_parser_cache_group (cp_parser *parser,\n     }\n }\n \n+/* Like above, for caching a default argument or NSDMI.  Both of these are\n+   terminated by a non-nested comma, but it can be unclear whether or not a\n+   comma is nested in a template argument list unless we do more parsing.\n+   In order to handle this ambiguity, when we encounter a ',' after a '<'\n+   we try to parse what follows as a parameter-declaration-list (in the\n+   case of a default argument) or a member-declarator (in the case of an\n+   NSDMI).  If that succeeds, then we stop caching.  */\n+\n+static tree\n+cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n+{\n+  unsigned depth = 0;\n+  int maybe_template_id = 0;\n+  cp_token *first_token;\n+  cp_token *token;\n+  tree default_argument;\n+\n+  /* Add tokens until we have processed the entire default\n+     argument.  We add the range [first_token, token).  */\n+  first_token = cp_lexer_peek_token (parser->lexer);\n+  if (first_token->type == CPP_OPEN_BRACE)\n+    {\n+      /* For list-initialization, this is straightforward.  */\n+      cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+  else while (true)\n+    {\n+      bool done = false;\n+\n+      /* Peek at the next token.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+      /* What we do depends on what token we have.  */\n+      switch (token->type)\n+\t{\n+\t  /* In valid code, a default argument must be\n+\t     immediately followed by a `,' `)', or `...'.  */\n+\tcase CPP_COMMA:\n+\t  if (depth == 0 && maybe_template_id)\n+\t    {\n+\t      /* If we've seen a '<', we might be in a\n+\t\t template-argument-list.  Until Core issue 325 is\n+\t\t resolved, we don't know how this situation ought\n+\t\t to be handled, so try to DTRT.  We check whether\n+\t\t what comes after the comma is a valid parameter\n+\t\t declaration list.  If it is, then the comma ends\n+\t\t the default argument; otherwise the default\n+\t\t argument continues.  */\n+\t      bool error = false;\n+\t      tree t;\n+\n+\t      /* Set ITALP so cp_parser_parameter_declaration_list\n+\t\t doesn't decide to commit to this parse.  */\n+\t      bool saved_italp = parser->in_template_argument_list_p;\n+\t      parser->in_template_argument_list_p = true;\n+\n+\t      cp_parser_parse_tentatively (parser);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\n+\t      if (nsdmi)\n+\t\t{\n+\t\t  int ctor_dtor_or_conv_p;\n+\t\t  cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t&ctor_dtor_or_conv_p,\n+\t\t\t\t\t/*parenthesized_p=*/NULL,\n+\t\t\t\t\t/*member_p=*/true);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  begin_scope (sk_function_parms, NULL_TREE);\n+\t\t  cp_parser_parameter_declaration_list (parser, &error);\n+\t\t  for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n+\t\t    pop_binding (DECL_NAME (t), t);\n+\t\t  leave_scope ();\n+\t\t}\n+\t      if (!cp_parser_error_occurred (parser) && !error)\n+\t\tdone = true;\n+\t      cp_parser_abort_tentative_parse (parser);\n+\n+\t      parser->in_template_argument_list_p = saved_italp;\n+\t      break;\n+\t    }\n+\tcase CPP_CLOSE_PAREN:\n+\tcase CPP_ELLIPSIS:\n+\t  /* If we run into a non-nested `;', `}', or `]',\n+\t     then the code is invalid -- but the default\n+\t     argument is certainly over.  */\n+\tcase CPP_SEMICOLON:\n+\tcase CPP_CLOSE_BRACE:\n+\tcase CPP_CLOSE_SQUARE:\n+\t  if (depth == 0)\n+\t    done = true;\n+\t  /* Update DEPTH, if necessary.  */\n+\t  else if (token->type == CPP_CLOSE_PAREN\n+\t\t   || token->type == CPP_CLOSE_BRACE\n+\t\t   || token->type == CPP_CLOSE_SQUARE)\n+\t    --depth;\n+\t  break;\n+\n+\tcase CPP_OPEN_PAREN:\n+\tcase CPP_OPEN_SQUARE:\n+\tcase CPP_OPEN_BRACE:\n+\t  ++depth;\n+\t  break;\n+\n+\tcase CPP_LESS:\n+\t  if (depth == 0)\n+\t    /* This might be the comparison operator, or it might\n+\t       start a template argument list.  */\n+\t    ++maybe_template_id;\n+\t  break;\n+\n+\tcase CPP_RSHIFT:\n+\t  if (cxx_dialect == cxx98)\n+\t    break;\n+\t  /* Fall through for C++0x, which treats the `>>'\n+\t     operator like two `>' tokens in certain\n+\t     cases.  */\n+\n+\tcase CPP_GREATER:\n+\t  if (depth == 0)\n+\t    {\n+\t      /* This might be an operator, or it might close a\n+\t\t template argument list.  But if a previous '<'\n+\t\t started a template argument list, this will have\n+\t\t closed it, so we can't be in one anymore.  */\n+\t      maybe_template_id -= 1 + (token->type == CPP_RSHIFT);\n+\t      if (maybe_template_id < 0)\n+\t\tmaybe_template_id = 0;\n+\t    }\n+\t  break;\n+\n+\t  /* If we run out of tokens, issue an error message.  */\n+\tcase CPP_EOF:\n+\tcase CPP_PRAGMA_EOL:\n+\t  error_at (token->location, \"file ends in default argument\");\n+\t  done = true;\n+\t  break;\n+\n+\tcase CPP_NAME:\n+\tcase CPP_SCOPE:\n+\t  /* In these cases, we should look for template-ids.\n+\t     For example, if the default argument is\n+\t     `X<int, double>()', we need to do name lookup to\n+\t     figure out whether or not `X' is a template; if\n+\t     so, the `,' does not end the default argument.\n+\n+\t     That is not yet done.  */\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      /* If we've reached the end, stop.  */\n+      if (done)\n+\tbreak;\n+\n+      /* Add the token to the token block.  */\n+      token = cp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  /* Create a DEFAULT_ARG to represent the unparsed default\n+     argument.  */\n+  default_argument = make_node (DEFAULT_ARG);\n+  DEFARG_TOKENS (default_argument)\n+    = cp_token_cache_new (first_token, token);\n+  DEFARG_INSTANTIATIONS (default_argument) = NULL;\n+\n+  return default_argument;\n+}\n+\n /* Begin parsing tentatively.  We always save tokens while parsing\n    tentatively so that if the tentative parsing fails we can restore the\n    tokens.  */"}, {"sha": "e1e0dfeff7d2466af9e4d97fc77bd5ef213ee34b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d28c2dcd712c9c79f8608c136f977f5d925886ea", "patch": "@@ -1,3 +1,8 @@\n+2012-01-02  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/51666\n+\t* g++.dg/cpp0x/nsdmi-defer5.C: New.\n+\n 2012-01-02  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/51462"}, {"sha": "85abfbf86181c526c530c00719a1eeb28f25a135", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-defer5.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28c2dcd712c9c79f8608c136f977f5d925886ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer5.C?ref=d28c2dcd712c9c79f8608c136f977f5d925886ea", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/51666 (DR 325)\n+// { dg-options -std=c++0x }\n+\n+template<typename T, typename U>\n+struct tuple\n+{\n+  tuple(T, U) { }\n+};\n+\n+struct Y\n+{\n+  tuple<int, int> tt = tuple<int, int>{1, 2};\n+};\n+\n+struct A\n+{\n+  int i = 0;\n+  int j = i < 42, k;\t\t// OK, declares j and k\n+  int l = i < 42, 24;\t\t// { dg-error \"\" }\n+};"}]}