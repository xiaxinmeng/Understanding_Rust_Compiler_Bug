{"sha": "cd1bef27d286a40b2709a9ded77fed5a33a461c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QxYmVmMjdkMjg2YTQwYjI3MDlhOWRlZDc3ZmVkNWEzM2E0NjFjNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-10-01T12:49:35Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2018-10-01T12:49:35Z"}, "message": "Updated stack-clash implementation supporting 64k probes.\n\nThis patch implements the use of the stack clash mitigation for aarch64.\nIn Aarch64 we expect both the probing interval and the guard size to be 64KB\nand we enforce them to always be equal.\n\nWe also probe up by 1024 bytes in the general case when a probe is required.\n\nAArch64 has the following probing conditions:\n\n 1a) Any initial adjustment less than 63KB requires no probing.  An ABI defined\n     safe buffer of 1Kbytes is used and a page size of 64k is assumed.\n\n  b) Any final adjustment residual requires a probe at SP + 1KB.\n     We know this to be safe since you would have done at least one page worth\n     of allocations already to get to that point.\n\n  c) Any final adjustment more than remainder (total allocation amount) larger\n     than 1K - LR offset requires a probe at SP.\n\n\n  safe buffer mentioned in 1a is maintained by the storing of FP/LR.\n  In the case of -fomit-frame-pointer we can still count on LR being stored\n  if the function makes a call, even if it's a tail call.  The AArch64 frame\n  layout code guarantees this and tests have been added to check against\n  this particular case.\n\n 2) Any allocations larger than 1 page size, is done in increments of page size\n    and probed up by 1KB leaving the residuals.\n\n 3a) Any residual for initial adjustment that is less than guard-size - 1KB\n     requires no probing.  Essentially this is a sliding window.  The probing\n     range determines the ABI safe buffer, and the amount to be probed up.\n\nIncrementally allocating less than the probing thresholds, e.g. recursive functions will\nnot be an issue as the storing of LR counts as a probe.\n\n\n                            +-------------------+                                    \n                            |  ABI SAFE REGION  |                                    \n                  +------------------------------                                    \n                  |         |                   |                                    \n                  |         |                   |                                    \n                  |         |                   |                                    \n                  |         |                   |                                    \n                  |         |                   |                                    \n                  |         |                   |                                    \n maximum amount   |         |                   |                                    \n not needing a    |         |                   |                                    \n probe            |         |                   |                                    \n                  |         |                   |                                    \n                  |         |                   |                                    \n                  |         |                   |                                    \n                  |         |                   |        Probe offset when           \n                  |         ---------------------------- probe is required           \n                  |         |                   |                                    \n                  +-------- +-------------------+ --------  Point of first probe     \n                            |  ABI SAFE REGION  |                                    \n                            ---------------------                                    \n                            |                   |                                    \n                            |                   |                                    \n                            |                   |                                         \n\nBootstrapped Regtested on aarch64-none-linux-gnu and no issues.\nTarget was tested with stack clash on and off by default.\n\nGLIBC testsuite also ran with stack clash on by default and no new\nregressions.\n\n\nCo-Authored-By: Richard Sandiford <richard.sandiford@linaro.org>\nCo-Authored-By: Tamar Christina <tamar.christina@arm.com>\n\nFrom-SVN: r264747", "tree": {"sha": "7e0089f09fdfa1bc6e63bc11b4c0ed2848643b8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0089f09fdfa1bc6e63bc11b4c0ed2848643b8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd1bef27d286a40b2709a9ded77fed5a33a461c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1bef27d286a40b2709a9ded77fed5a33a461c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1bef27d286a40b2709a9ded77fed5a33a461c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1bef27d286a40b2709a9ded77fed5a33a461c5/comments", "author": null, "committer": null, "parents": [{"sha": "041bfa6f07787752743e8c32c7a75a47015ba65a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041bfa6f07787752743e8c32c7a75a47015ba65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041bfa6f07787752743e8c32c7a75a47015ba65a"}], "stats": {"total": 614, "additions": 593, "deletions": 21}, "files": [{"sha": "332f6dc707d449c6943ebb8c94e38a9ede7ae7b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -1,3 +1,19 @@\n+2018-10-01  Jeff Law  <law@redhat.com>\n+\t    Richard Sandiford <richard.sandiford@linaro.org>\n+\t    Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/86486\n+\t* config/aarch64/aarch64.md\n+\t(probe_stack_range): Add k (SP) constraint.\n+\t* config/aarch64/aarch64.h (STACK_CLASH_CALLER_GUARD,\n+\tSTACK_CLASH_MAX_UNROLL_PAGES): New.\n+\t* config/aarch64/aarch64.c (aarch64_output_probe_stack_range): Emit\n+\tstack probes for stack clash.\n+\t(aarch64_allocate_and_probe_stack_space): New.\n+\t(aarch64_expand_prologue): Use it.\n+\t(aarch64_expand_epilogue): Likewise and update IP regs re-use criteria.\n+\t(aarch64_sub_sp): Add emit_move_imm optional param.\n+\n 2018-10-01  MCC CS <deswurstes@users.noreply.github.com>\n \n \tPR tree-optimization/87261"}, {"sha": "9fd5cb20d84eac7bdc5f01e8a74b8205594821e3", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 259, "deletions": 14, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -2816,10 +2816,11 @@ aarch64_add_sp (rtx temp1, rtx temp2, poly_int64 delta, bool emit_move_imm)\n    if nonnull.  */\n \n static inline void\n-aarch64_sub_sp (rtx temp1, rtx temp2, poly_int64 delta, bool frame_related_p)\n+aarch64_sub_sp (rtx temp1, rtx temp2, poly_int64 delta, bool frame_related_p,\n+\t\tbool emit_move_imm = true)\n {\n   aarch64_add_offset (Pmode, stack_pointer_rtx, stack_pointer_rtx, -delta,\n-\t\t      temp1, temp2, frame_related_p);\n+\t\t      temp1, temp2, frame_related_p, emit_move_imm);\n }\n \n /* Set DEST to (vec_series BASE STEP).  */\n@@ -3979,13 +3980,33 @@ aarch64_output_probe_stack_range (rtx reg1, rtx reg2)\n   /* Loop.  */\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n \n+  HOST_WIDE_INT stack_clash_probe_interval\n+    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+\n   /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n   xops[0] = reg1;\n-  xops[1] = GEN_INT (PROBE_INTERVAL);\n+  HOST_WIDE_INT interval;\n+  if (flag_stack_clash_protection)\n+    interval = stack_clash_probe_interval;\n+  else\n+    interval = PROBE_INTERVAL;\n+\n+  gcc_assert (aarch64_uimm12_shift (interval));\n+  xops[1] = GEN_INT (interval);\n+\n   output_asm_insn (\"sub\\t%0, %0, %1\", xops);\n \n-  /* Probe at TEST_ADDR.  */\n-  output_asm_insn (\"str\\txzr, [%0]\", xops);\n+  /* If doing stack clash protection then we probe up by the ABI specified\n+     amount.  We do this because we're dropping full pages at a time in the\n+     loop.  But if we're doing non-stack clash probing, probe at SP 0.  */\n+  if (flag_stack_clash_protection)\n+    xops[1] = GEN_INT (STACK_CLASH_CALLER_GUARD);\n+  else\n+    xops[1] = CONST0_RTX (GET_MODE (xops[1]));\n+\n+  /* Probe at TEST_ADDR.  If we're inside the loop it is always safe to probe\n+     by this amount for each iteration.  */\n+  output_asm_insn (\"str\\txzr, [%0, %1]\", xops);\n \n   /* Test if TEST_ADDR == LAST_ADDR.  */\n   xops[1] = reg2;\n@@ -4794,6 +4815,188 @@ aarch64_set_handled_components (sbitmap components)\n       cfun->machine->reg_is_wrapped_separately[regno] = true;\n }\n \n+/* Allocate POLY_SIZE bytes of stack space using TEMP1 and TEMP2 as scratch\n+   registers.  If POLY_SIZE is not large enough to require a probe this function\n+   will only adjust the stack.  When allocating the stack space\n+   FRAME_RELATED_P is then used to indicate if the allocation is frame related.\n+   FINAL_ADJUSTMENT_P indicates whether we are allocating the outgoing\n+   arguments.  If we are then we ensure that any allocation larger than the ABI\n+   defined buffer needs a probe so that the invariant of having a 1KB buffer is\n+   maintained.\n+\n+   We emit barriers after each stack adjustment to prevent optimizations from\n+   breaking the invariant that we never drop the stack more than a page.  This\n+   invariant is needed to make it easier to correctly handle asynchronous\n+   events, e.g. if we were to allow the stack to be dropped by more than a page\n+   and then have multiple probes up and we take a signal somewhere in between\n+   then the signal handler doesn't know the state of the stack and can make no\n+   assumptions about which pages have been probed.  */\n+\n+static void\n+aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,\n+\t\t\t\t\tpoly_int64 poly_size,\n+\t\t\t\t\tbool frame_related_p,\n+\t\t\t\t\tbool final_adjustment_p)\n+{\n+  HOST_WIDE_INT guard_size\n+    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+  HOST_WIDE_INT guard_used_by_caller = STACK_CLASH_CALLER_GUARD;\n+  /* When doing the final adjustment for the outgoing argument size we can't\n+     assume that LR was saved at position 0.  So subtract it's offset from the\n+     ABI safe buffer so that we don't accidentally allow an adjustment that\n+     would result in an allocation larger than the ABI buffer without\n+     probing.  */\n+  HOST_WIDE_INT min_probe_threshold\n+    = final_adjustment_p\n+      ? guard_used_by_caller - cfun->machine->frame.reg_offset[LR_REGNUM]\n+      : guard_size - guard_used_by_caller;\n+\n+  poly_int64 frame_size = cfun->machine->frame.frame_size;\n+\n+  /* We should always have a positive probe threshold.  */\n+  gcc_assert (min_probe_threshold > 0);\n+\n+  if (flag_stack_clash_protection && !final_adjustment_p)\n+    {\n+      poly_int64 initial_adjust = cfun->machine->frame.initial_adjust;\n+      poly_int64 final_adjust = cfun->machine->frame.final_adjust;\n+\n+      if (known_eq (frame_size, 0))\n+\t{\n+\t  dump_stack_clash_frame_info (NO_PROBE_NO_FRAME, false);\n+\t}\n+      else if (known_lt (initial_adjust, guard_size - guard_used_by_caller)\n+\t       && known_lt (final_adjust, guard_used_by_caller))\n+\t{\n+\t  dump_stack_clash_frame_info (NO_PROBE_SMALL_FRAME, true);\n+\t}\n+    }\n+\n+  HOST_WIDE_INT size;\n+  /* If SIZE is not large enough to require probing, just adjust the stack and\n+     exit.  */\n+  if (!poly_size.is_constant (&size)\n+      || known_lt (poly_size, min_probe_threshold)\n+      || !flag_stack_clash_protection)\n+    {\n+      aarch64_sub_sp (temp1, temp2, poly_size, frame_related_p);\n+      return;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Stack clash AArch64 prologue: \" HOST_WIDE_INT_PRINT_DEC \" bytes\"\n+\t     \", probing will be required.\\n\", size);\n+\n+  /* Round size to the nearest multiple of guard_size, and calculate the\n+     residual as the difference between the original size and the rounded\n+     size.  */\n+  HOST_WIDE_INT rounded_size = ROUND_DOWN (size, guard_size);\n+  HOST_WIDE_INT residual = size - rounded_size;\n+\n+  /* We can handle a small number of allocations/probes inline.  Otherwise\n+     punt to a loop.  */\n+  if (rounded_size <= STACK_CLASH_MAX_UNROLL_PAGES * guard_size)\n+    {\n+      for (HOST_WIDE_INT i = 0; i < rounded_size; i += guard_size)\n+\t{\n+\t  aarch64_sub_sp (NULL, temp2, guard_size, true);\n+\t  emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t   guard_used_by_caller));\n+\t  emit_insn (gen_blockage ());\n+\t}\n+      dump_stack_clash_frame_info (PROBE_INLINE, size != rounded_size);\n+    }\n+  else\n+    {\n+      /* Compute the ending address.  */\n+      aarch64_add_offset (Pmode, temp1, stack_pointer_rtx, -rounded_size,\n+\t\t\t  temp1, NULL, false, true);\n+      rtx_insn *insn = get_last_insn ();\n+\n+      /* For the initial allocation, we don't have a frame pointer\n+\t set up, so we always need CFI notes.  If we're doing the\n+\t final allocation, then we may have a frame pointer, in which\n+\t case it is the CFA, otherwise we need CFI notes.\n+\n+\t We can determine which allocation we are doing by looking at\n+\t the value of FRAME_RELATED_P since the final allocations are not\n+\t frame related.  */\n+      if (frame_related_p)\n+\t{\n+\t  /* We want the CFA independent of the stack pointer for the\n+\t     duration of the loop.  */\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\tplus_constant (Pmode, temp1, rounded_size));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      /* This allocates and probes the stack.  Note that this re-uses some of\n+\t the existing Ada stack protection code.  However we are guaranteed not\n+\t to enter the non loop or residual branches of that code.\n+\n+\t The non-loop part won't be entered because if our allocation amount\n+\t doesn't require a loop, the case above would handle it.\n+\n+\t The residual amount won't be entered because TEMP1 is a mutliple of\n+\t the allocation size.  The residual will always be 0.  As such, the only\n+\t part we are actually using from that code is the loop setup.  The\n+\t actual probing is done in aarch64_output_probe_stack_range.  */\n+      insn = emit_insn (gen_probe_stack_range (stack_pointer_rtx,\n+\t\t\t\t\t       stack_pointer_rtx, temp1));\n+\n+      /* Now reset the CFA register if needed.  */\n+      if (frame_related_p)\n+\t{\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\tplus_constant (Pmode, stack_pointer_rtx, rounded_size));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      emit_insn (gen_blockage ());\n+      dump_stack_clash_frame_info (PROBE_LOOP, size != rounded_size);\n+    }\n+\n+  /* Handle any residuals.  Residuals of at least MIN_PROBE_THRESHOLD have to\n+     be probed.  This maintains the requirement that each page is probed at\n+     least once.  For initial probing we probe only if the allocation is\n+     more than GUARD_SIZE - buffer, and for the outgoing arguments we probe\n+     if the amount is larger than buffer.  GUARD_SIZE - buffer + buffer ==\n+     GUARD_SIZE.  This works that for any allocation that is large enough to\n+     trigger a probe here, we'll have at least one, and if they're not large\n+     enough for this code to emit anything for them, The page would have been\n+     probed by the saving of FP/LR either by this function or any callees.  If\n+     we don't have any callees then we won't have more stack adjustments and so\n+     are still safe.  */\n+  if (residual)\n+    {\n+      HOST_WIDE_INT residual_probe_offset = guard_used_by_caller;\n+      /* If we're doing final adjustments, and we've done any full page\n+\t allocations then any residual needs to be probed.  */\n+      if (final_adjustment_p && rounded_size != 0)\n+\tmin_probe_threshold = 0;\n+      /* If doing a small final adjustment, we always probe at offset 0.\n+\t This is done to avoid issues when LR is not at position 0 or when\n+\t the final adjustment is smaller than the probing offset.  */\n+      else if (final_adjustment_p && rounded_size == 0)\n+\tresidual_probe_offset = 0;\n+\n+      aarch64_sub_sp (temp1, temp2, residual, frame_related_p);\n+      if (residual >= min_probe_threshold)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Stack clash AArch64 prologue residuals: \"\n+\t\t     HOST_WIDE_INT_PRINT_DEC \" bytes, probing will be required.\"\n+\t\t     \"\\n\", residual);\n+\n+\t    emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     residual_probe_offset));\n+\t  emit_insn (gen_blockage ());\n+\t}\n+    }\n+}\n+\n /* Add a REG_CFA_EXPRESSION note to INSN to say that register REG\n    is saved at BASE + OFFSET.  */\n \n@@ -4821,7 +5024,7 @@ aarch64_add_cfa_expression (rtx_insn *insn, unsigned int reg,\n \t|  local variables              | <-- frame_pointer_rtx\n \t|                               |\n \t+-------------------------------+\n-\t|  padding0                     | \\\n+\t|  padding                      | \\\n \t+-------------------------------+  |\n \t|  callee-saved registers       |  | frame.saved_regs_size\n \t+-------------------------------+  |\n@@ -4840,7 +5043,23 @@ aarch64_add_cfa_expression (rtx_insn *insn, unsigned int reg,\n \n    Dynamic stack allocations via alloca() decrease stack_pointer_rtx\n    but leave frame_pointer_rtx and hard_frame_pointer_rtx\n-   unchanged.  */\n+   unchanged.\n+\n+   By default for stack-clash we assume the guard is at least 64KB, but this\n+   value is configurable to either 4KB or 64KB.  We also force the guard size to\n+   be the same as the probing interval and both values are kept in sync.\n+\n+   With those assumptions the callee can allocate up to 63KB (or 3KB depending\n+   on the guard size) of stack space without probing.\n+\n+   When probing is needed, we emit a probe at the start of the prologue\n+   and every PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE bytes thereafter.\n+\n+   We have to track how much space has been allocated and the only stores\n+   to the stack we track as implicit probes are the FP/LR stores.\n+\n+   For outgoing arguments we probe if the size is larger than 1KB, such that\n+   the ABI specified buffer is maintained for the next callee.  */\n \n /* Generate the prologue instructions for entry into a function.\n    Establish the stack frame by decreasing the stack pointer with a\n@@ -4889,7 +5108,16 @@ aarch64_expand_prologue (void)\n   rtx ip0_rtx = gen_rtx_REG (Pmode, IP0_REGNUM);\n   rtx ip1_rtx = gen_rtx_REG (Pmode, IP1_REGNUM);\n \n-  aarch64_sub_sp (ip0_rtx, ip1_rtx, initial_adjust, true);\n+  /* In theory we should never have both an initial adjustment\n+     and a callee save adjustment.  Verify that is the case since the\n+     code below does not handle it for -fstack-clash-protection.  */\n+  gcc_assert (known_eq (initial_adjust, 0) || callee_adjust == 0);\n+\n+  /* Will only probe if the initial adjustment is larger than the guard\n+     less the amount of the guard reserved for use by the caller's\n+     outgoing args.  */\n+  aarch64_allocate_and_probe_stack_space (ip0_rtx, ip1_rtx, initial_adjust,\n+\t\t\t\t\t  true, false);\n \n   if (callee_adjust != 0)\n     aarch64_push_regs (reg1, reg2, callee_adjust);\n@@ -4945,7 +5173,11 @@ aarch64_expand_prologue (void)\n \t\t\t     callee_adjust != 0 || emit_frame_chain);\n   aarch64_save_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n \t\t\t     callee_adjust != 0 || emit_frame_chain);\n-  aarch64_sub_sp (ip1_rtx, ip0_rtx, final_adjust, !frame_pointer_needed);\n+\n+  /* We may need to probe the final adjustment if it is larger than the guard\n+     that is assumed by the called.  */\n+  aarch64_allocate_and_probe_stack_space (ip1_rtx, ip0_rtx, final_adjust,\n+\t\t\t\t\t  !frame_pointer_needed, true);\n }\n \n /* Return TRUE if we can use a simple_return insn.\n@@ -4985,10 +5217,21 @@ aarch64_expand_epilogue (bool for_sibcall)\n   /* A stack clash protection prologue may not have left IP0_REGNUM or\n      IP1_REGNUM in a usable state.  The same is true for allocations\n      with an SVE component, since we then need both temporary registers\n-     for each allocation.  */\n+     for each allocation.  For stack clash we are in a usable state if\n+     the adjustment is less than GUARD_SIZE - GUARD_USED_BY_CALLER.  */\n+  HOST_WIDE_INT guard_size\n+    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+  HOST_WIDE_INT guard_used_by_caller = STACK_CLASH_CALLER_GUARD;\n+\n+  /* We can re-use the registers when the allocation amount is smaller than\n+     guard_size - guard_used_by_caller because we won't be doing any probes\n+     then.  In such situations the register should remain live with the correct\n+     value.  */\n   bool can_inherit_p = (initial_adjust.is_constant ()\n-\t\t\t&& final_adjust.is_constant ()\n-\t\t\t&& !flag_stack_clash_protection);\n+\t\t\t&& final_adjust.is_constant ())\n+\t\t\t&& (!flag_stack_clash_protection\n+\t\t\t     || known_lt (initial_adjust,\n+\t\t\t\t\t  guard_size - guard_used_by_caller));\n \n   /* We need to add memory barrier to prevent read from deallocated stack.  */\n   bool need_barrier_p\n@@ -5016,8 +5259,10 @@ aarch64_expand_epilogue (bool for_sibcall)\n \t\t\thard_frame_pointer_rtx, -callee_offset,\n \t\t\tip1_rtx, ip0_rtx, callee_adjust == 0);\n   else\n-    aarch64_add_sp (ip1_rtx, ip0_rtx, final_adjust,\n-\t\t    !can_inherit_p || df_regs_ever_live_p (IP1_REGNUM));\n+     /* The case where we need to re-use the register here is very rare, so\n+\tavoid the complicated condition and just always emit a move if the\n+\timmediate doesn't fit.  */\n+     aarch64_add_sp (ip1_rtx, ip0_rtx, final_adjust, true);\n \n   aarch64_restore_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t\tcallee_adjust != 0, &cfi_ops);"}, {"sha": "7b130be1691b7fedcd7169ad53ad0e80000f696a", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -84,6 +84,14 @@\n \n #define LONG_DOUBLE_TYPE_SIZE\t128\n \n+/* This value is the amount of bytes a caller is allowed to drop the stack\n+   before probing has to be done for stack clash protection.  */\n+#define STACK_CLASH_CALLER_GUARD 1024\n+\n+/* This value controls how many pages we manually unroll the loop for when\n+   generating stack clash probes.  */\n+#define STACK_CLASH_MAX_UNROLL_PAGES 4\n+\n /* The architecture reserves all bits of the address for hardware use,\n    so the vbit must go into the delta field of pointers to member\n    functions.  This is the same config as that in the AArch32"}, {"sha": "77c949738c5dabcb2cbb42815120425899f8433a", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -6503,7 +6503,7 @@\n )\n \n (define_insn \"probe_stack_range\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=rk\")\n \t(unspec_volatile:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n \t\t\t     (match_operand:DI 2 \"register_operand\" \"r\")]\n \t\t\t      UNSPECV_PROBE_STACK_RANGE))]"}, {"sha": "9d7f24606451d0cba26d6de061c3a1fbce64f4a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -1,3 +1,31 @@\n+2018-10-01  Jeff Law  <law@redhat.com>\n+\t    Richard Sandiford <richard.sandiford@linaro.org>\n+\t    Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/86486\n+\t* gcc.target/aarch64/stack-check-12.c: New.\n+\t* gcc.target/aarch64/stack-check-13.c: New.\n+\t* gcc.target/aarch64/stack-check-cfa-1.c: New.\n+\t* gcc.target/aarch64/stack-check-cfa-2.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-1.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-10.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-11.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-12.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-13.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-14.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-15.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-2.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-3.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-4.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-5.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-6.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-7.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-8.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue-9.c: New.\n+\t* gcc.target/aarch64/stack-check-prologue.h: New.\n+\t* lib/target-supports.exp\n+\t(check_effective_target_supports_stack_clash_protection): Add AArch64.\n+\n 2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n \n \t* lib/target-supports.exp (check_cached_effective_target_indexed): New."}, {"sha": "4e3abcbcef2eb216be9f0e01b4f1713c33f8b0b8", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-12.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-12.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -fno-asynchronous-unwind-tables -fno-unwind-tables\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+extern void arf (unsigned long int *, unsigned long int *);\n+void\n+frob ()\n+{\n+  unsigned long int num[10000];\n+  unsigned long int den[10000];\n+  arf (den, num);\n+}\n+\n+/* This verifies that the scheduler did not break the dependencies\n+   by adjusting the offsets within the probe and that the scheduler\n+   did not reorder around the stack probes.  */\n+/* { dg-final { scan-assembler-times {sub\\tsp, sp, #65536\\n\\tstr\\txzr, \\[sp, 1024\\]} 2 } } */\n+/* There is some residual allocation, but we don't care about that. Only that it's not probed.  */\n+/* { dg-final { scan-assembler-times {str\\txzr, } 2 } } */\n+\n+\n+"}, {"sha": "1fcbae6e3fc6c8423883542d16735e2a8ca0e013", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-13.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-13.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -fno-asynchronous-unwind-tables -fno-unwind-tables\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define ARG32(X) X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X\n+#define ARG192(X) ARG32(X),ARG32(X),ARG32(X),ARG32(X),ARG32(X),ARG32(X)\n+void out1(ARG192(__int128));\n+int t1(int);\n+\n+int t3(int x)\n+{\n+  if (x < 1000)\n+    return t1 (x) + 1;\n+\n+  out1 (ARG192(1));\n+  return 0;\n+}\n+\n+\n+\n+/* This test creates a large (> 1k) outgoing argument area that needs\n+   to be probed.  We don't test the exact size of the space or the\n+   exact offset to make the test a little less sensitive to trivial\n+   output changes.  */\n+/* { dg-final { scan-assembler-times \"sub\\\\tsp, sp, #....\\\\n\\\\tstr\\\\txzr, \\\\\\[sp\" 1 } } */\n+\n+\n+"}, {"sha": "6885894a97e0a53cf87fc3ff9ded156014864c4d", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-cfa-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-1.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -funwind-tables\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 128*1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 65536} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 131072} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 0} 1 } } */\n+\n+/* Checks that the CFA notes are correct for every sp adjustment.  */"}, {"sha": "5796a53be0676bace2197e9d07a63b4b1757fd0d", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-cfa-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-2.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -funwind-tables\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 1280*1024 + 512\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa [0-9]+, 1310720} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 1311232} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 1310720} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 0} 1 } } */\n+\n+/* Checks that the CFA notes are correct for every sp adjustment.  */"}, {"sha": "d2bfb788c6ff731ed0592e16813147e3e58b4df2", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-1.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 128\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr,} 0 } } */\n+\n+/* SIZE is smaller than guard-size - 1Kb so no probe expected.  */"}, {"sha": "c9c9a1b9161b2bec19e61bf648b26938dcf001b9", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-10.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-10.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE (6 * 64 * 1024) + (1 * 63 * 1024) + 512\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 2 } } */\n+\n+/* SIZE is more than 4x guard-size and remainder larger than guard-size - 1Kb,\n+   1 probe expected in a loop and 1 residual probe.  */"}, {"sha": "741f2f5fadc6960f1d2c34e1e93589cfcc6e1697", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-11.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-11.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE (6 * 64 * 1024) + (1 * 32 * 1024)\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* SIZE is more than 4x guard-size and remainder larger than guard-size - 1Kb,\n+   1 probe expected in a loop and 1 residual probe.  */"}, {"sha": "ece68003ade48799a0817c103a307a30537d6872", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-12.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-12.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -fomit-frame-pointer -momit-leaf-frame-pointer\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+void\n+f (void)\n+{\n+  volatile int x[16384 + 1000];\n+  x[0] = 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* SIZE is more than 1 guard-size, but only one 64KB page is used, expect only 1\n+   probe.  Leaf function and omitting leaf pointers.  */"}, {"sha": "0fc900c6943ee92609ce2d83c5c54d6397ce35c5", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-13.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-13.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -fomit-frame-pointer -momit-leaf-frame-pointer\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+void h (void) __attribute__ ((noreturn));\n+\n+void\n+f (void)\n+{\n+  volatile int x[16384 + 1000];\n+  x[30]=0;\n+  h ();\n+}\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {str\\s+x30, \\[sp\\]} 1 } } */\n+\n+/* SIZE is more than 1 guard-size, but only one 64KB page is used, expect only 1\n+   probe.  Leaf function and omitting leaf pointers, tail call to noreturn which\n+   may only omit an epilogue and not a prologue.  Checking for LR saving.  */\n\\ No newline at end of file"}, {"sha": "ea733f861e77a647cf5c661d23b116aabdfa31c2", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-14.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-14.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -fomit-frame-pointer -momit-leaf-frame-pointer\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+void h (void) __attribute__ ((noreturn));\n+\n+void\n+f (void)\n+{\n+  volatile int x[16384 + 1000];\n+  if (x[0])\n+     h ();\n+  x[345] = 1;\n+  h ();\n+}\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {str\\s+x30, \\[sp\\]} 1 } } */\n+\n+/* SIZE is more than 1 guard-size, two 64k pages used, expect only 1 explicit\n+   probe at 1024 and one implicit probe due to LR being saved.  Leaf function\n+   and omitting leaf pointers, tail call to noreturn which may only omit an\n+   epilogue and not a prologue and control flow in between.  Checking for\n+   LR saving.  */\n\\ No newline at end of file"}, {"sha": "63df4a5609a2377a7b0688bd0871d2757c9f1a51", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-15.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-15.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -fomit-frame-pointer -momit-leaf-frame-pointer\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+void g (volatile int *x) ;\n+void h (void) __attribute__ ((noreturn));\n+\n+void\n+f (void)\n+{\n+  volatile int x[16384 + 1000];\n+  g (x);\n+  h ();\n+}\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {str\\s+x30, \\[sp\\]} 1 } } */\n+\n+/* SIZE is more than 1 guard-size, two 64k pages used, expect only 1 explicit\n+   probe at 1024 and one implicit probe due to LR being saved.  Leaf function\n+   and omitting leaf pointers, normal function call followed by a tail call to\n+   noreturn which may only omit an epilogue and not a prologue and control flow\n+   in between.  Checking for LR saving.  */"}, {"sha": "61c52a251a7bf4f2d145e456c86049230d372ba4", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-2.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 2 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr,} 0 } } */\n+\n+/* SIZE is smaller than guard-size - 1Kb so no probe expected.  */"}, {"sha": "0bef3c5b60c2abab6c28abd41444b5e3569c3652", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-3.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 63 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr,} 1 } } */\n+\n+/* SIZE is exactly guard-size - 1Kb, boundary condition so 1 probe expected.\n+*/"}, {"sha": "5b8693a051c321cb5a2f701cd3272e3970a6a4de", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-4.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 63 * 1024 + 512\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* SIZE is more than guard-size - 1Kb and remainder is less than 1kB,\n+   1 probe expected.  */"}, {"sha": "2ee16350127c2e201da7d990dbcb042691b52348", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-5.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 64 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* SIZE is more than guard-size - 1Kb and remainder is zero,\n+   1 probe expected, boundary condition.  */"}, {"sha": "3c9b606cbe0e3b4f75c86c22dd1f69dde7e36310", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-6.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-6.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 65 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* SIZE is more than guard-size - 1Kb and remainder is equal to 1kB,\n+   1 probe expected.  */"}, {"sha": "6324c0367fada8a2726e689d39e46ad5f8e130b5", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-7.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-7.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 127 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 2 } } */\n+\n+/* SIZE is more than 1x guard-size and remainder equal than guard-size - 1Kb,\n+   2 probe expected, unrolled, no loop.  */"}, {"sha": "333f5fcc3607ee633c1b9374f6d5e8ac4a954b37", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-8.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-8.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 128 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 2 } } */\n+\n+/* SIZE is more than 2x guard-size and no remainder, unrolled, no loop.  */"}, {"sha": "a3ff89b558139e56d2d69c93307fcab79c89a103", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-9.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-9.c?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 6 * 64 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* SIZE is more than 4x guard-size and no remainder, 1 probe expected in a loop\n+   and no residual probe.  */"}, {"sha": "b7e06aedb81d7692ebd587b23d1065436b1c7218", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue.h?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -0,0 +1,5 @@\n+int f_test (int x)\n+{\n+  char arr[SIZE];\n+  return arr[x];\n+}"}, {"sha": "d741583c6f6f3546c5830bf4a57d18c992e9e9af", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1bef27d286a40b2709a9ded77fed5a33a461c5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=cd1bef27d286a40b2709a9ded77fed5a33a461c5", "patch": "@@ -8385,14 +8385,9 @@ proc check_effective_target_autoincdec { } {\n # \n proc check_effective_target_supports_stack_clash_protection { } {\n \n-   # Temporary until the target bits are fully ACK'd.\n-#  if { [istarget aarch*-*-*] } {\n-#\treturn 1\n-#  }\n-\n     if { [istarget x86_64-*-*] || [istarget i?86-*-*] \n \t  || [istarget powerpc*-*-*] || [istarget rs6000*-*-*]\n-\t  || [istarget s390*-*-*] } {\n+\t  || [istarget aarch64*-**] || [istarget s390*-*-*] } {\n \treturn 1\n     }\n   return 0"}]}