{"sha": "63511623299e3fd5994f1f96d956e21bf380aa4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1MTE2MjMyOTllM2ZkNTk5NGYxZjk2ZDk1NmUyMWJmMzgwYWE0Zg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@purist.soma.redhat.com", "date": "2000-08-16T04:12:51Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-08-16T04:12:51Z"}, "message": "codecvt.h: New file.\n\n\n2000-08-15  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* bits/codecvt.h: New file.\n\t* src/codecvt.cc: New file.\n\t* bits/std_locale.h: Add include here.\n\t* src/Makefile.am (headers): Add codecvt.h\n\t(sources): Add codecvt.cc.\n\t* src/Makefile.in: Regenerate.\n\t* bits/locale_facets.h (codecvt): Re-implement. Rename _Codecvt to\n\t__codecvt_abstract_base in an attempt to point some light this way...\n\tMove __enc_traits and codecvt bits to codecvt.h.\n\t* src/locale-inst.cc: Remove codecvt<wchar_t, wchar_t, mbstate_t>\n\texplicit instantiation. Separate out codecvt instantations, simplify.\n\t* src/locale.cc: Move codecvt bits to codecvt.cc\n\nFrom-SVN: r35737", "tree": {"sha": "e19f71e078697043ffd4a59617c22e4290adf158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e19f71e078697043ffd4a59617c22e4290adf158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63511623299e3fd5994f1f96d956e21bf380aa4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63511623299e3fd5994f1f96d956e21bf380aa4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63511623299e3fd5994f1f96d956e21bf380aa4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63511623299e3fd5994f1f96d956e21bf380aa4f/comments", "author": null, "committer": null, "parents": [{"sha": "fec1ce0a00615fde6d338965a44ebc12db3e1be4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec1ce0a00615fde6d338965a44ebc12db3e1be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fec1ce0a00615fde6d338965a44ebc12db3e1be4"}], "stats": {"total": 1154, "additions": 647, "deletions": 507}, "files": [{"sha": "3fe296f5eca986024535b735d79f8cb0555c46ec", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -1,3 +1,18 @@\n+2000-08-15  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+\n+\t* bits/codecvt.h: New file.\n+\t* src/codecvt.cc: New file.\n+\t* bits/std_locale.h: Add include here.\n+\t* src/Makefile.am (headers): Add codecvt.h\n+\t(sources): Add codecvt.cc.\n+\t* src/Makefile.in: Regenerate.\n+\t* bits/locale_facets.h (codecvt): Re-implement. Rename _Codecvt to\n+\t__codecvt_abstract_base in an attempt to point some light this way...\n+\tMove __enc_traits and codecvt bits to codecvt.h.\n+\t* src/locale-inst.cc: Remove codecvt<wchar_t, wchar_t, mbstate_t>\n+\texplicit instantiation. Separate out codecvt instantations, simplify.\n+\t* src/locale.cc: Move codecvt bits to codecvt.cc\n+\n 2000-08-15  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* src/Makefile.am (INCLUDES): New target file, with all -I flags."}, {"sha": "90245d639b0ea21b84c6b69f5b8df48ecf65547e", "filename": "libstdc++-v3/bits/codecvt.h", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fcodecvt.h?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -0,0 +1,438 @@\n+// Locale support (codecvt) -*- C++ -*-\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.2.1.5 Template class codecvt\n+//\n+\n+// Warning: this file is not meant for user inclusion.  Use <locale>.\n+\n+// Written by Benjamin Kosnik <bkoz@cygnus.com>\n+\n+#ifndef _CPP_BITS_CODECVT_H\n+#define _CPP_BITS_CODECVT_H\t1\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+// #include <localefwd.h>\n+// XXX include iconv here or higher up.... \n+#include <iconv.h>\t\t// For iconv, iconv_t\n+#endif\n+\n+namespace std\n+{\n+  // XXX __enc_traits may need to move up the locale header heirarchy,\n+  // depending on if ctype ends up using it.\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  // Extensions to use icov for dealing with character encodings,\n+  // including conversions and comparisons between various character\n+  // sets.  This object encapsulates data that may need to be shared between\n+  // char_traits, codecvt and ctype.\n+  template<typename _InternT, typename _ExternT>\n+  class __enc_traits\n+  {\n+  public:\n+    // Types:\n+    typedef _InternT\t__intc_type;\n+    typedef _ExternT\t__extc_type;\n+    typedef iconv_t\t__conv_type;\n+    typedef mbstate_t\t__state_type;\n+    \n+    // Data Members:\n+    // Max size of charset encoding name\n+    static const int \t__max_size = 32;\n+    // Name of internal character set encoding.\n+    char\t       \t__intc_enc[__max_size];\n+    // Name of external character set encoding.\n+    char  \t       \t__extc_enc[__max_size];\n+\n+    // Conversion descriptor between external encoding to internal encoding.\n+    __conv_type\t\t__in_conv;\n+    // Conversion descriptor between internal encoding to external encoding.\n+    __conv_type\t\t__out_conv;\n+\n+    __enc_traits()\n+    {\n+      // __intc_end = whatever we are using internally, which is\n+      // UCS4 (linux) \n+      // UCS2 (microsoft, java, aix, whatever...)\n+      // XXX Currently don't know how to get this data from target system...\n+      strcpy(__intc_enc, \"UCS4\");\n+\n+      // __extc_end = external codeset in current locale\n+      strcpy(__extc_enc, nl_langinfo(CODESET));\n+      __in_conv = iconv_open(__intc_enc, __extc_enc);\n+      __out_conv = iconv_open(__extc_enc, __intc_enc);\n+      if (__out_conv == (iconv_t) -1 || __in_conv == (iconv_t) -1)\n+\t{\n+\t  // XXX Extended error checking.\n+\t}\n+    }\n+\n+    __enc_traits(const char* __int, const char* __ext)\n+    {\n+      strcpy(__intc_enc, __int);\n+      strcpy(__extc_enc, __ext);\n+      __in_conv = iconv_open(__intc_enc, __extc_enc);\n+      __out_conv = iconv_open(__extc_enc, __intc_enc);\n+      if (__out_conv == (iconv_t) -1 || __in_conv == (iconv_t) -1)\n+\t{\n+\t  // XXX Extended error checking.\n+\t}\n+    }\n+\n+    ~__enc_traits()\n+    {\n+      iconv_close(__in_conv);\n+      iconv_close(__out_conv);\n+    } \n+\n+    const char* \n+    _M_get_intc_enc(void)\n+    { return __intc_enc; }\n+\n+    void\n+    _M_set_intc_enc(const char* __c)\n+    { strcpy(__intc_enc, __c); }\n+\n+    const char* \n+    _M_get_extc_enc(void)\n+    { return __extc_enc; }\n+\n+    void\n+    _M_set_extc_enc(const char* __c)\n+    { strcpy(__extc_enc, __c); }\n+   \n+  protected:\n+    // 21.1.2 traits typedefs\n+    // p4\n+    // typedef STATE_T state_type\n+    // requires: state_type shall meet the requirements of\n+    // CopyConstructible types (20.1.3)\n+    // XXX because of this, these might actually need to be filled out.\n+    __enc_traits(const __enc_traits&);\n+  };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+\n+  //  22.2.1.5  Template class codecvt\n+  class codecvt_base\n+  {\n+  public:\n+    enum result\n+    {\n+      ok,\n+      partial,\n+      error,\n+      noconv\n+    };\n+  };\n+\n+  // Template class __codecvt_abstract_base\n+  // NB: An abstract base class that fills in the public inlines, so\n+  // that the specializations don't have to re-copy the public\n+  // interface.\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class __codecvt_abstract_base \n+    : public locale::facet, public codecvt_base\n+    {\n+    public:\n+      // Types:\n+      typedef _InternT intern_type;\n+      typedef _ExternT extern_type;\n+      typedef _StateT  state_type;\n+      \n+      // 22.2.1.5.1 codecvt members\n+      result\n+      out(state_type& __state, const intern_type* __from, \n+\t  const intern_type* __from_end, const intern_type*& __from_next,\n+\t  extern_type* __to, extern_type* __to_limit, \n+\t  extern_type*& __to_next) const\n+      { \n+\treturn this->do_out(__state, __from, __from_end, __from_next, \n+\t\t\t    __to, __to_limit, __to_next); \n+      }\n+\n+      result\n+      unshift(state_type& __state, extern_type* __to, extern_type* __to_limit,\n+\t      extern_type*& __to_next) const\n+      { return this->do_unshift(__state, __to,__to_limit,__to_next); }\n+\n+      result\n+      in(state_type& __state, const extern_type* __from, \n+\t const extern_type* __from_end, const extern_type*& __from_next,\n+\t intern_type* __to, intern_type* __to_limit, \n+\t intern_type*& __to_next) const\n+      { \n+\treturn this->do_in(__state, __from, __from_end, __from_next,\n+\t\t\t   __to, __to_limit, __to_next); \n+      }\n+\n+      int \n+      encoding() const throw()\n+      { return this->do_encoding(); }\n+\n+      bool \n+      always_noconv() const throw()\n+      { return this->do_always_noconv(); }\n+\n+      int\n+      length(const state_type& __state, const extern_type* __from,\n+\t     const extern_type* __end, size_t __max) const\n+      { return this->do_length(__state, __from, __end, __max); }\n+\n+      int \n+      max_length() const throw()\n+      { return this->do_max_length(); }\n+\n+    protected:\n+      explicit \n+      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      virtual \n+      ~__codecvt_abstract_base() { }\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type*& __to_next) const = 0;\n+\n+      virtual result\n+      do_unshift(state_type& __state, extern_type* __to, \n+\t\t extern_type* __to_limit, extern_type*& __to_next) const = 0;\n+      \n+      virtual result\n+      do_in(state_type& __state, const extern_type* __from, \n+\t    const extern_type* __from_end, const extern_type*& __from_next, \n+\t    intern_type* __to, intern_type* __to_limit, \n+\t    intern_type*& __to_next) const = 0;\n+      \n+      virtual int \n+      do_encoding() const throw() = 0;\n+\n+      virtual bool \n+      do_always_noconv() const throw() = 0;\n+\n+      virtual int \n+      do_length(const state_type&, const extern_type* __from, \n+\t\tconst extern_type* __end, size_t __max) const = 0;\n+\n+      virtual int \n+      do_max_length() const throw() = 0;\n+    };\n+\n+  // 22.2.1.5 Template class codecvt\n+  // NB: Generic, mostly useless implementation.\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt \n+    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>\n+    {\n+    public:      \n+      // Types:\n+      typedef _InternT intern_type;\n+      typedef _ExternT extern_type;\n+      typedef _StateT  state_type;\n+\n+      // Data Members:\n+      static locale::id id;\n+\n+      explicit \n+      codecvt(size_t __refs = 0) \n+      : __codecvt_abstract_base<_InternT,_ExternT,_StateT> (__refs) { }\n+\n+    protected:\n+      virtual \n+      ~codecvt() { }\n+    };\n+\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    locale::id codecvt<_InternT, _ExternT, _StateT>::id;\n+\n+  // partial specialization\n+  template<typename _InternT, typename _ExternT>\n+  class codecvt<_InternT, _ExternT, __enc_traits<_InternT, _ExternT> >\n+  : public __codecvt_abstract_base<_InternT, \n+    \t\t\t\t   _ExternT, __enc_traits<_InternT, _ExternT> >\n+  { };\n+\n+  // codecvt<char, char, mbstate_t> required specialization\n+  template<>\n+    class codecvt<char, char, mbstate_t> \n+    : public __codecvt_abstract_base<char, char, mbstate_t>\n+    {\n+    public:      \n+      // Types:\n+      typedef char \tintern_type;\n+      typedef char \textern_type;\n+      typedef mbstate_t state_type;\n+\n+      // Data Members:\n+      static locale::id id;\n+\n+      explicit \n+      codecvt(size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt();\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state, extern_type* __to, \n+\t\t extern_type* __to_limit, extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state, const extern_type* __from, \n+\t    const extern_type* __from_end, const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_limit, \n+\t    intern_type*& __to_next) const;\n+\n+      virtual int \n+      do_encoding() const throw();\n+\n+      virtual bool \n+      do_always_noconv() const throw();\n+\n+      virtual int \n+      do_length(const state_type&, const extern_type* __from, \n+\t\tconst extern_type* __end, size_t __max) const;\n+\n+      virtual int \n+      do_max_length() const throw();\n+  };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  // codecvt<wchar_t, char, mbstate_t> required specialization\n+  template<>\n+    class codecvt<wchar_t, char, mbstate_t> \n+    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>\n+    {\n+    public:\n+      // Types:\n+      typedef wchar_t \tintern_type;\n+      typedef char \textern_type;\n+      typedef mbstate_t state_type;\n+\n+      // Data Members:\n+      static locale::id id;\n+\n+      explicit \n+      codecvt(size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt();\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state,\n+\t\t extern_type* __to, extern_type* __to_limit,\n+\t\t extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state,\n+\t     const extern_type* __from, const extern_type* __from_end,\n+\t     const extern_type*& __from_next,\n+\t     intern_type* __to, intern_type* __to_limit,\n+\t     intern_type*& __to_next) const;\n+\n+      virtual \n+      int do_encoding() const throw();\n+\n+      virtual \n+      bool do_always_noconv() const throw();\n+\n+      virtual \n+      int do_length(const state_type&, const extern_type* __from,\n+\t\t    const extern_type* __end, size_t __max) const;\n+\n+      virtual int \n+      do_max_length() const throw();\n+    };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+  // 22.2.1.6  Template class codecvt_byname\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0) \n+      : codecvt<_InternT,_ExternT,_StateT> (__refs) { }\n+    protected:\n+      virtual \n+      ~codecvt_byname() { }\n+    };\n+\n+  template<>\n+    class codecvt_byname<char, char, mbstate_t>\n+    : public codecvt<char, char, mbstate_t>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt_byname();\n+    };\n+  \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    class codecvt_byname<wchar_t, char, mbstate_t>\n+      : public codecvt<wchar_t, char, mbstate_t>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt_byname();\n+    };\n+#endif\n+\n+} // namespace std\n+\n+#endif // _CPP_BITS_CODECVT_H\n+\n+// Local Variables:\n+// mode:c++\n+// End:\n+"}, {"sha": "a8bf7bb13810297c2c137657128c55f379504405", "filename": "libstdc++-v3/bits/locale_facets.h", "status": "modified", "additions": 0, "deletions": 348, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -39,14 +39,9 @@\n #include <bits/std_ctime.h>\t// For struct tm\n #include <bits/std_typeinfo.h> \t// For bad_cast, which shouldn't be here.\n #include <bits/std_ios.h>\t// For ios_base\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-// XXX should break this out??\n-#include <iconv.h>\t\t// For iconv, iconv_t\n-#endif\n \n namespace std\n {\n-\n   // XXX This function is to be specialized for the \"required\" facets to \n   // be constructed lazily.   The specializations must be declared after \n   // the definitions of the facets themselves; but they shouldn't be \n@@ -80,98 +75,6 @@ namespace std\n     _Use_facet_failure_handler(const locale&)\n     { throw _Bad_use_facet(); }\n \n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  // Extensions to use icov for dealing with character encodings,\n-  // including conversions and comparisons between various character\n-  // sets.  This object encapsulates data that may need to be shared between\n-  // char_traits, codecvt and ctype.\n-  template<typename _IntT, typename _ExtT>\n-  class __enc_traits\n-  {\n-  public:\n-    // Types:\n-    typedef _IntT\t__intc_type;\n-    typedef _ExtT\t__extc_type;\n-    typedef iconv_t\t__conv_type;\n-    typedef mbstate_t\t__state_type;\n-    \n-    // Data Members:\n-    // Max size of charset encoding name\n-    static const int \t__max_size = 32;\n-    // Name of internal character set encoding.\n-    char\t       \t__intc_enc[__max_size];\n-    // Name of external character set encoding.\n-    char  \t       \t__extc_enc[__max_size];\n-\n-    // Conversion descriptor between external encoding to internal encoding.\n-    __conv_type\t\t__in_conv;\n-    // Conversion descriptor between internal encoding to external encoding.\n-    __conv_type\t\t__out_conv;\n-\n-    __enc_traits()\n-    {\n-      // __intc_end = whatever we are using internally, which is\n-      // UCS4 (linux) \n-      // UCS2 (microsoft, java, aix, whatever...)\n-      // XXX Currently don't know how to get this data from target system...\n-      strcpy(__intc_enc, \"UCS4\");\n-\n-      // __extc_end = external codeset in current locale\n-      strcpy(__extc_enc, nl_langinfo(CODESET));\n-      __in_conv = iconv_open(__intc_enc, __extc_enc);\n-      __out_conv = iconv_open(__extc_enc, __intc_enc);\n-      if (__out_conv == (iconv_t) -1 || __in_conv == (iconv_t) -1)\n-\t{\n-\t  // XXX Extended error checking.\n-\t}\n-    }\n-\n-    __enc_traits(const char* __int, const char* __ext)\n-    {\n-      strcpy(__intc_enc, __int);\n-      strcpy(__extc_enc, __ext);\n-      __in_conv = iconv_open(__intc_enc, __extc_enc);\n-      __out_conv = iconv_open(__extc_enc, __intc_enc);\n-      if (__out_conv == (iconv_t) -1 || __in_conv == (iconv_t) -1)\n-\t{\n-\t  // XXX Extended error checking.\n-\t}\n-    }\n-\n-    ~__enc_traits()\n-    {\n-      iconv_close(__in_conv);\n-      iconv_close(__out_conv);\n-    } \n-\n-    const char* \n-    _M_get_intc_enc(void)\n-    { return __intc_enc; }\n-\n-    void\n-    _M_set_intc_enc(const char* __c)\n-    { strcpy(__intc_enc, __c); }\n-\n-    const char* \n-    _M_get_extc_enc(void)\n-    { return __extc_enc; }\n-\n-    void\n-    _M_set_extc_enc(const char* __c)\n-    { strcpy(__extc_enc, __c); }\n-   \n-  protected:\n-    // 21.1.2 traits typedefs\n-    // p4\n-    // typedef STATE_T state_type\n-    // requires: state_type shall meet the requirements of\n-    // CopyConstructible types (20.1.3)\n-    // XXX because of this, these might actually need to be filled out.\n-    __enc_traits(const __enc_traits&);\n-  };\n-#endif //_GLIBCPP_USE_WCHAR_T\n-\n   // 22.2.1  The ctype category\n   // Include host-specific ctype enums for ctype_base.\n   #include <bits/ctype_base.h>\n@@ -582,257 +485,6 @@ namespace std\n #endif\n \n \n-  //  22.2.1.5  Template class codecvt\n-  class codecvt_base\n-  {\n-  public:\n-    enum result\n-    {\n-      ok,\n-      partial,\n-      error,\n-      noconv\n-    };\n-  };\n-\n-  template<typename _InternT, typename _ExternT, typename _StateT>\n-    class _Codecvt : public locale::facet, public codecvt_base\n-    {\n-    public:\n-      // Types:\n-      typedef _InternT intern_type;\n-      typedef _ExternT extern_type;\n-      typedef _StateT  state_type;\n-      \n-    protected:\n-      explicit \n-      _Codecvt (size_t __refs = 0) : locale::facet(__refs) { }\n-\n-    public:\n-      result\n-      out(state_type& __state, const intern_type* __from, \n-\t  const intern_type* __from_end, const intern_type* &__from_next,\n-\t  extern_type* __to, extern_type* __to_limit, \n-\t  extern_type*& __to_next) const\n-      { \n-\treturn do_out(__state, __from, __from_end, __from_next, __to, \n-\t\t      __to_limit, __to_next); \n-      }\n-\n-      result\n-      unshift(state_type& __state, extern_type* __to, extern_type* __to_limit,\n-\t      extern_type*& __to_next) const\n-      { return do_unshift(__state, __to,__to_limit,__to_next); }\n-\n-      result\n-      in(state_type& __state, const extern_type* __from, \n-\t const extern_type* __from_end, const extern_type*& __from_next,\n-\t intern_type* __to, intern_type* __to_limit,\n-\t intern_type*& __to_next) const\n-      { \n-\treturn do_in(__state, __from, __from_end, __from_next,\n-\t\t     __to, __to_limit, __to_next); \n-      }\n-\n-      int \n-      encoding() const throw()\n-      { return do_encoding(); }\n-\n-      bool \n-      always_noconv() const throw()\n-      { return do_always_noconv(); }\n-\n-      int\n-      length(const state_type& __state, const extern_type* __from,\n-\t     const extern_type* __end, size_t __max) const\n-      { return do_length(__state, __from, __end, __max); }\n-\n-      int \n-      max_length() const throw()\n-      { return do_max_length(); }\n-\n-    protected:\n-      virtual \n-      ~_Codecvt() { }\n-\n-      virtual result\n-      do_out(state_type& __state,\n-\t     const intern_type* __from, const intern_type* __from_end,\n-\t     const intern_type*& __from_next,\n-\t     extern_type* __to, extern_type* __to_limit,\n-\t     extern_type*& __to_next) const = 0;\n-\n-      virtual result\n-      do_unshift(state_type& __state,\n-\t\t extern_type* __to, extern_type* __to_limit,\n-\t\t extern_type*& __to_next) const = 0;\n-      \n-      virtual result\n-      do_in(state_type& __state,\n-\t    const extern_type* __from, const extern_type* __from_end,\n-\t    const extern_type*& __from_next,\n-\t    intern_type* __to, intern_type* __to_limit,\n-\t    intern_type*& __to_next) const = 0;\n-      \n-      virtual int \n-      do_encoding() const throw() = 0;\n-\n-      virtual bool \n-      do_always_noconv() const throw() = 0;\n-\n-      virtual int \n-      do_length(const state_type&, const extern_type* __from,\n-\t\tconst extern_type* __end, size_t __max) const = 0;\n-\n-      virtual int \n-      do_max_length() const throw() = 0;\n-    };\n-  \n-\n-  template<typename _InternT, typename _ExternT, typename _StateT>\n-    class codecvt : public _Codecvt<_InternT, _ExternT, _StateT>\n-    {\n-    public:      \n-      // Types:\n-      typedef _InternT intern_type;\n-      typedef _ExternT extern_type;\n-      typedef _StateT  state_type;\n-\n-      // Data Members:\n-      static locale::id id;\n-\n-      explicit \n-      codecvt(size_t __refs = 0) \n-      : _Codecvt<_InternT, _ExternT, _StateT> (__refs) { }\n-\n-    protected:\n-      virtual \n-      ~codecvt() { }\n-    };\n-\n-  // codecvt<char, char, mbstate_t> specialization\n-  template<>\n-    class codecvt<char, char, mbstate_t> \n-    : public _Codecvt<char, char, mbstate_t>\n-    {\n-    public:      \n-      // Types:\n-      typedef char \tintern_type;\n-      typedef char \textern_type;\n-      typedef mbstate_t state_type;\n-\n-      explicit codecvt (size_t __refs = 0);\n-      static locale::id id;\n-\n-    protected:\n-      virtual ~codecvt();\n-      virtual result\n-      do_out(state_type& __state, const intern_type* __from, \n-\t     const intern_type* __from_end, const intern_type*& __from_next,\n-\t     extern_type* __to, extern_type* __to_limit,\n-\t     extern_type*& __to_next) const;\n-\n-      virtual result\n-      do_unshift(state_type& __state, extern_type* __to, \n-\t\t extern_type* __to_limit, extern_type*& __to_next) const;\n-\n-      virtual result\n-      do_in(state_type& __state, const extern_type* __from, \n-\t    const extern_type* __from_end, const extern_type*& __from_next,\n-\t    intern_type* __to, intern_type* __to_limit, \n-\t    intern_type*& __to_next) const;\n-\n-      virtual int do_encoding() const throw();\n-      virtual bool do_always_noconv() const throw();\n-      virtual int do_length(const state_type&, const extern_type* __from,\n-\t\t\t    const extern_type* __end, size_t __max) const;\n-      virtual int do_max_length() const throw();\n-  };\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    class codecvt<wchar_t, char, mbstate_t> \n-    : public _Codecvt<wchar_t, char, mbstate_t>\n-    {\n-    public:\n-      // Types:\n-      typedef wchar_t \tintern_type;\n-      typedef char \textern_type;\n-      typedef mbstate_t state_type;\n-\n-      explicit codecvt(size_t __refs = 0);\n-      static locale::id id;\n-\n-    protected:\n-      virtual ~codecvt();\n-      virtual result\n-      do_out(state_type& __state, const intern_type* __from, \n-\t     const intern_type* __from_end, const intern_type*& __from_next,\n-\t     extern_type* __to, extern_type* __to_limit,\n-\t     extern_type*& __to_next) const;\n-\n-      virtual result\n-      do_unshift(state_type& __state,\n-\t\t extern_type* __to, extern_type* __to_limit,\n-\t\t extern_type*& __to_next) const;\n-\n-      virtual result\n-      do_in(state_type& __state,\n-\t     const extern_type* __from, const extern_type* __from_end,\n-\t     const extern_type*& __from_next,\n-\t     intern_type* __to, intern_type* __to_limit,\n-\t     intern_type*& __to_next) const;\n-\n-      virtual int do_encoding() const throw();\n-      virtual bool do_always_noconv() const throw();\n-      virtual int do_length(const state_type&, const extern_type* __from,\n-\t\t\t    const extern_type* __end, size_t __max) const;\n-      virtual int do_max_length() const throw();\n-    };\n-#endif //_GLIBCPP_USE_WCHAR_T\n-\n-\n-  // 22.2.1.6  Template class codecvt_byname\n-  template<typename _InternT, typename _ExternT, typename _StateT>\n-    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>\n-    {\n-    public:\n-      explicit \n-      codecvt_byname(const char*, size_t __refs = 0) \n-      : codecvt<_InternT,_ExternT,_StateT> (__refs) { }\n-    protected:\n-      virtual \n-      ~codecvt_byname() { }\n-    };\n-\n-  template<>\n-    class codecvt_byname<char, char, mbstate_t>\n-    : public codecvt<char, char, mbstate_t>\n-    {\n-    public:\n-      explicit \n-      codecvt_byname(const char*, size_t __refs = 0);\n-\n-    protected:\n-      virtual \n-      ~codecvt_byname();\n-    };\n-  \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    class codecvt_byname<wchar_t, char, mbstate_t>\n-      : public codecvt<wchar_t, char, mbstate_t>\n-    {\n-    public:\n-      explicit \n-      codecvt_byname(const char*, size_t __refs = 0);\n-\n-    protected:\n-      virtual \n-      ~codecvt_byname();\n-    };\n-#endif\n-\n   template<typename _CharT, typename _InIter>\n     class _Numeric_get;  // forward\n "}, {"sha": "9d98612da54abeffbdc54581f430d95b36805882", "filename": "libstdc++-v3/bits/locale_facets.tcc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -160,9 +160,6 @@ namespace std\n   template<typename _CharT>\n     locale::id ctype<_CharT>::id;\n \n-  template<typename _InternT, typename _ExternT, typename _StateT>\n-    locale::id codecvt<_InternT, _ExternT, _StateT>::id;\n-\n   template<typename _CharT>\n     int _Format_cache<_CharT>::_S_pword_ix;\n "}, {"sha": "dc3c9aa8af4900ad807bf092d986ae5607c166ef", "filename": "libstdc++-v3/bits/std_locale.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -36,6 +36,7 @@\n \n #include <bits/localefwd.h>\n #include <bits/locale_facets.h>\n+#include <bits/codecvt.h>\n \n #endif\n "}, {"sha": "e1950aa711ebe700d0fe665dfc03322866cabddb", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -21,7 +21,7 @@\n ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n ## USA.\n \n-## $Id: Makefile.am,v 1.25 2000/07/26 21:30:45 pme Exp $\n+## $Id: Makefile.am,v 1.26 2000/08/15 07:42:36 aoliva Exp $\n \n AUTOMAKE_OPTIONS = 1.3 gnits\n MAINT_CHARSET = latin1\n@@ -106,7 +106,7 @@ CXXLINK = $(LIBTOOL) --mode=link \"$(CC)\" @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CX\n headers = \\\n \tbits/cpp_type_traits.h \\\n \tbits/std_cctype.h bits/ctype_base.h bits/ctype_specializations.h \\\n-\tbits/char_traits.h \\\n+\tbits/char_traits.h bits/codecvt.h \\\n \tbits/basic_string.h bits/std_string.h  bits/string.tcc \\\n \tbits/generic_shadow.h bits/std_utility.h \\\n \tbits/std_complex.h \\\n@@ -207,7 +207,7 @@ sources = \\\n \tcomplex.cc complexf.cc complexl.cc complex_io.cc \\\n \tstdexcept.cc \\\n \tc++io.cc ios.cc stdstreams.cc strstream.cc \\\n-\tlocale.cc localename.cc  \\\n+\tlocale.cc localename.cc codecvt.cc \\\n \tlocale-inst.cc stl-inst.cc misc-inst.cc valarray-inst.cc string-inst.cc\n \n wstring_sources = \\"}, {"sha": "c456b00334e757d1fbd67fcd850bec4c69724bf9", "filename": "libstdc++-v3/src/codecvt.cc", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -0,0 +1,186 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Benjamin Kosnik <bkoz@cygnus.com>\n+\n+#include <bits/std_locale.h>\n+\n+namespace std {\n+\n+  locale::id codecvt<char, char, mbstate_t>::id;\n+\n+  codecvt<char, char, mbstate_t>::\n+  codecvt(size_t __refs)\n+  : __codecvt_abstract_base<char, char, mbstate_t>(__refs)\n+  { }\n+\n+  codecvt<char, char, mbstate_t>::\n+  ~codecvt() { }\n+  \n+  codecvt_base::result\n+  codecvt<char, char, mbstate_t>::\n+  do_out(state_type& /*__state*/, const intern_type* __from, \n+\t const intern_type* __from_end, const intern_type*& __from_next,\n+\t extern_type* __to, extern_type* __to_end, \n+\t extern_type*& __to_next) const\n+  { \n+    size_t __sizefrom = __from_end - __from;\n+    size_t __sizeto = __to_end - __to;\n+    size_t __length = __sizefrom <= __sizeto ? __sizefrom : __sizeto;\n+    memcpy(__to, __from, __length);\n+    __from_next = __from; \n+    __to_next = __to;\n+    return noconv;  \n+  }\n+  \n+  codecvt_base::result\n+  codecvt<char, char, mbstate_t>::\n+  do_unshift(state_type& /*__state*/, extern_type* __to,\n+             extern_type* /*__to_limit*/, extern_type*& __to_next) const\n+  { \n+    __to_next = __to; \n+    return noconv; \n+  }\n+  \n+  codecvt_base::result\n+  codecvt<char, char, mbstate_t>::\n+  do_in(state_type& /*__state*/, const extern_type* __from, \n+\tconst extern_type* __from_end, const extern_type*& __from_next,\n+\tintern_type* __to, intern_type* __to_end, \n+\tintern_type*& __to_next) const\n+  { \n+    size_t __sizefrom = __from_end - __from;\n+    size_t __sizeto = __to_end - __to;\n+    size_t __length = __sizefrom <= __sizeto ? __sizefrom : __sizeto;\n+    memcpy(__to, __from, __length);\n+    __from_next = __from; \n+    __to_next = __to;\n+    return noconv;  \n+  }\n+\n+  int \n+  codecvt<char, char, mbstate_t>::\n+  do_encoding() const throw() { return 1; }\n+  \n+  bool \n+  codecvt<char, char, mbstate_t>::\n+  do_always_noconv() const throw() { return true; }\n+  \n+  int \n+  codecvt<char, char, mbstate_t>::\n+  do_length (const state_type& /*__state*/, const extern_type* __from,\n+\t     const extern_type* __end, size_t __max) const\n+  { return (__max < size_t(__end - __from)) ? __max : __end - __from; }\n+  \n+  int \n+  codecvt<char, char, mbstate_t>::\n+  do_max_length() const throw() { return 1; }\n+  \n+  codecvt_byname<char, char, mbstate_t>::\n+  codecvt_byname(const char* /*__s*/, size_t __refs)\n+  : codecvt<char, char, mbstate_t>(__refs) { }\n+\n+  codecvt_byname<char, char, mbstate_t>::\n+  ~codecvt_byname() { }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  locale::id codecvt<wchar_t, char, mbstate_t>::id;\n+\n+  codecvt<wchar_t, char, mbstate_t>::\n+  codecvt(size_t __refs)\n+  : __codecvt_abstract_base<wchar_t, char, mbstate_t>(__refs) { }\n+\n+  codecvt<wchar_t, char, mbstate_t>::\n+  ~codecvt() { }\n+  \n+  codecvt_base::result\n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_out(state_type& /*__state*/, const intern_type* __from, \n+\t const intern_type* __from_end, const intern_type*& __from_next,\n+\t extern_type* __to, extern_type* __to_limit,\n+\t extern_type*& __to_next) const\n+  {\n+    for (; __from < __from_end && __to < __to_limit; ++__from, ++__to)\n+      *__to = static_cast<char>(*__from);\n+    __from_next = __from; __to_next = __to;\n+    return __from == __from_end ? ok : partial;\n+  }\n+  \n+  codecvt_base::result\n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_unshift (state_type& /*__state*/, extern_type* __to,\n+              extern_type* /*__to_limit*/, extern_type*& __to_next) const\n+  {\n+    __to_next = __to;\n+    return noconv;\n+  }\n+  \n+  codecvt_base::result\n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_in(state_type& /*__state*/, const extern_type* __from, \n+\tconst extern_type* __from_end, const extern_type*& __from_next,\n+\tintern_type* __to, intern_type* __to_limit,\n+\tintern_type*& __to_next) const\n+  {\n+    for (; __from < __from_end && __to < __to_limit; ++__from, ++__to)\n+      *__to = static_cast<wchar_t>(*__from);\n+    __from_next = __from; \n+    __to_next = __to;\n+    return __from == __from_end ? ok : partial;\n+  }\n+  \n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_encoding() const throw()\n+  { return 1; }\n+  \n+  bool \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_always_noconv() const throw()\n+  { return false; }\n+  \n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_length(const state_type& /*__state*/, const extern_type* __from,\n+\t    const extern_type* __end, size_t __max) const\n+  { return (__max < size_t(__end - __from)) ? __max : __end - __from; }\n+  \n+  int \n+  codecvt<wchar_t, char, mbstate_t>::do_max_length() const throw()\n+  { return 1; }\n+\n+  codecvt_byname<wchar_t, char, mbstate_t>::\n+  codecvt_byname(const char* /*__s*/, size_t __refs)\n+  : codecvt<wchar_t, char, mbstate_t> (__refs) { }\n+  \n+  codecvt_byname<wchar_t, char, mbstate_t>::\n+  ~codecvt_byname() { }\n+#endif //  _GLIBCPP_USE_WCHAR_T\n+\n+} // namespace std\n+\n+"}, {"sha": "a313aaf68d1c9a366cac9cc6a7f6119cb4b0e794", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -126,14 +126,16 @@ namespace std {\n   template class _Ctype<char>;\n   template class _Ctype_nois<char>;\n   template class ctype_byname<char>;\n-  template class _Codecvt<char, char, mbstate_t>;\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class _Ctype<wchar_t>;\n   template class _Ctype_nois<wchar_t>;\n   template class ctype_byname<wchar_t>;\n-  template class _Codecvt<wchar_t, char, mbstate_t>;\n #endif\n   \n+  // codecvt\n+  template class __codecvt_abstract_base<char, char, mbstate_t>;\n+  template class __codecvt_abstract_base<wchar_t, char, mbstate_t>;\n+\n   // collate\n   template class _Collate<char>;\n   template class collate_byname<char>;\n@@ -173,9 +175,6 @@ namespace std {\n   template\n     const ctype<wchar_t>&\n     use_facet<ctype<wchar_t> >(const locale& __loc);\n-  template\n-    const codecvt<wchar_t, wchar_t, mbstate_t>& \n-    use_facet<codecvt<wchar_t, wchar_t, mbstate_t> >(locale const &);\n   template\n     const codecvt<wchar_t, char, mbstate_t>& \n     use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const &);"}, {"sha": "6ceaf12dcc23544fc0193e0ec5687cd402b635af", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63511623299e3fd5994f1f96d956e21bf380aa4f/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=63511623299e3fd5994f1f96d956e21bf380aa4f", "patch": "@@ -501,82 +501,6 @@ namespace std {\n   : ctype<char>(new mask[table_size], true, __refs)\n   { }\n \n-  locale::id codecvt<char, char, mbstate_t>::id;\n-\n-  codecvt<char, char, mbstate_t>::\n-  codecvt(size_t __refs)\n-  : _Codecvt<char, char, mbstate_t>(__refs)\n-  { }\n-\n-  codecvt<char, char, mbstate_t>::\n-  ~codecvt() { }\n-  \n-  codecvt_base::result\n-  codecvt<char, char, mbstate_t>::\n-  do_out(state_type& /*__state*/, const intern_type* __from, \n-\t const intern_type* __from_end, const intern_type*& __from_next,\n-\t extern_type* __to, extern_type* __to_end, \n-\t extern_type*& __to_next) const\n-  { \n-    size_t __sizefrom = __from_end - __from;\n-    size_t __sizeto = __to_end - __to;\n-    size_t __length = __sizefrom <= __sizeto ? __sizefrom : __sizeto;\n-    memcpy(__to, __from, __length);\n-    __from_next = __from; \n-    __to_next = __to;\n-    return noconv;  \n-  }\n-  \n-  codecvt_base::result\n-  codecvt<char, char, mbstate_t>::\n-  do_unshift(state_type& /*__state*/, extern_type* __to,\n-             extern_type* /*__to_limit*/, extern_type*& __to_next) const\n-  { \n-    __to_next = __to; \n-    return noconv; \n-  }\n-  \n-  codecvt_base::result\n-  codecvt<char, char, mbstate_t>::\n-  do_in(state_type& /*__state*/, const extern_type* __from, \n-\tconst extern_type* __from_end, const extern_type*& __from_next,\n-\tintern_type* __to, intern_type* __to_end, \n-\tintern_type*& __to_next) const\n-  { \n-    size_t __sizefrom = __from_end - __from;\n-    size_t __sizeto = __to_end - __to;\n-    size_t __length = __sizefrom <= __sizeto ? __sizefrom : __sizeto;\n-    memcpy(__to, __from, __length);\n-    __from_next = __from; \n-    __to_next = __to;\n-    return noconv;  \n-  }\n-  \n-\n-  int \n-  codecvt<char, char, mbstate_t>::\n-  do_encoding() const throw() { return 1; }\n-  \n-  bool \n-  codecvt<char, char, mbstate_t>::\n-  do_always_noconv() const throw() { return true; }\n-  \n-  int \n-  codecvt<char, char, mbstate_t>::\n-  do_length (const state_type& /*__state*/, const extern_type* __from,\n-\t     const extern_type* __end, size_t __max) const\n-  { return (__max < size_t(__end - __from)) ? __max : __end - __from; }\n-  \n-  int \n-  codecvt<char, char, mbstate_t>::\n-  do_max_length() const throw() { return 1; }\n-  \n-  codecvt_byname<char, char, mbstate_t>::\n-  codecvt_byname(const char* /*__s*/, size_t __refs)\n-  : codecvt<char, char, mbstate_t>(__refs) { }\n-\n-  codecvt_byname<char, char, mbstate_t>::\n-  ~codecvt_byname() { }\n \n   locale::id collate<char>::id;\n \n@@ -748,78 +672,6 @@ namespace std {\n   ctype_byname(const char* /*__s*/, size_t __refs)\n   : ctype<wchar_t>(__refs) { }\n \n-  locale::id codecvt<wchar_t, char, mbstate_t>::id;\n-\n-  codecvt<wchar_t, char, mbstate_t>::\n-  codecvt(size_t __refs)\n-  : _Codecvt<wchar_t, char, mbstate_t>(__refs) { }\n-\n-  codecvt<wchar_t, char, mbstate_t>::\n-  ~codecvt() { }\n-  \n-  codecvt_base::result\n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_out(state_type& /*__state*/, const intern_type* __from, \n-\t const intern_type* __from_end, const intern_type*& __from_next,\n-\t extern_type* __to, extern_type* __to_limit,\n-\t extern_type*& __to_next) const\n-  {\n-    for (; __from < __from_end && __to < __to_limit; ++__from, ++__to)\n-      *__to = static_cast<char>(*__from);\n-    __from_next = __from; __to_next = __to;\n-    return __from == __from_end ? ok : partial;\n-  }\n-  \n-  codecvt_base::result\n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_unshift (state_type& /*__state*/, extern_type* __to,\n-              extern_type* /*__to_limit*/, extern_type*& __to_next) const\n-  {\n-    __to_next = __to;\n-    return noconv;\n-  }\n-  \n-  codecvt_base::result\n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_in(state_type& /*__state*/, const extern_type* __from, \n-\tconst extern_type* __from_end, const extern_type*& __from_next,\n-\tintern_type* __to, intern_type* __to_limit,\n-\tintern_type*& __to_next) const\n-  {\n-    for (; __from < __from_end && __to < __to_limit; ++__from, ++__to)\n-      *__to = static_cast<wchar_t>(*__from);\n-    __from_next = __from; \n-    __to_next = __to;\n-    return __from == __from_end ? ok : partial;\n-  }\n-  \n-  int \n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_encoding() const throw()\n-  { return 1; }\n-  \n-  bool \n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_always_noconv() const throw()\n-  { return false; }\n-  \n-  int \n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_length(const state_type& /*__state*/, const extern_type* __from,\n-\t    const extern_type* __end, size_t __max) const\n-  { return (__max < size_t(__end - __from)) ? __max : __end - __from; }\n-  \n-  int \n-  codecvt<wchar_t, char, mbstate_t>::do_max_length() const throw()\n-  { return 1; }\n-\n-  codecvt_byname<wchar_t, char, mbstate_t>::\n-  codecvt_byname(const char* /*__s*/, size_t __refs)\n-  : codecvt<wchar_t, char, mbstate_t> (__refs) { }\n-  \n-  codecvt_byname<wchar_t, char, mbstate_t>::\n-  ~codecvt_byname() { }\n-\n   locale::id collate<wchar_t>::id;\n \n   collate<wchar_t>::"}]}