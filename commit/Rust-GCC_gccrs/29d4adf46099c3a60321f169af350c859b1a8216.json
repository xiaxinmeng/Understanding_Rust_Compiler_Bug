{"sha": "29d4adf46099c3a60321f169af350c859b1a8216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkNGFkZjQ2MDk5YzNhNjAzMjFmMTY5YWYzNTBjODU5YjFhODIxNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-03-22T13:07:13Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-03-22T13:07:13Z"}, "message": "acinclude.m4 (GLIBCXX_ENABLE_ALLOCATOR): Add pool_allocator.\n\n2004-03-22  Paolo Carlini  <pcarlini@suse.de>\n\n\t* acinclude.m4 (GLIBCXX_ENABLE_ALLOCATOR): Add pool_allocator.\n\t* configure: Regenerate.\n\t* config/allocator/pool_allocator_base.h: New.\n\t* include/ext/pool_allocator.h: Convert to a standard-conforming\n\tallocator.\n\t* src/allocator.cc: Tweak instantiations.\n\t* testsuite/performance/20_util/allocator/insert.cc: Add __pool_alloc.\n\t* testsuite/performance/20_util/allocator/insert_insert.cc: Ditto.\n\t* testsuite/performance/20_util/allocator/list_sort_search.cc: Ditto.\n\t* testsuite/performance/20_util/allocator/map_mt_find.cc: Ditto.\n\t* testsuite/performance/20_util/allocator/map_thread.cc: Ditto.\n\t* testsuite/performance/20_util/allocator/producer_consumer.cc: Ditto.\n\nFrom-SVN: r79824", "tree": {"sha": "283a7f15508ca3106ca88d333c661466d5fa6329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/283a7f15508ca3106ca88d333c661466d5fa6329"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29d4adf46099c3a60321f169af350c859b1a8216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d4adf46099c3a60321f169af350c859b1a8216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29d4adf46099c3a60321f169af350c859b1a8216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d4adf46099c3a60321f169af350c859b1a8216/comments", "author": null, "committer": null, "parents": [{"sha": "1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda"}], "stats": {"total": 2564, "additions": 1700, "deletions": 864}, "files": [{"sha": "eab7a977fb05994252b4cd8a0129f879fb55fa09", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -1,3 +1,18 @@\n+2004-03-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* acinclude.m4 (GLIBCXX_ENABLE_ALLOCATOR): Add pool_allocator.\n+\t* configure: Regenerate.\n+\t* config/allocator/pool_allocator_base.h: New.\n+\t* include/ext/pool_allocator.h: Convert to a standard-conforming\n+\tallocator.\n+\t* src/allocator.cc: Tweak instantiations.\n+\t* testsuite/performance/20_util/allocator/insert.cc: Add __pool_alloc.\n+\t* testsuite/performance/20_util/allocator/insert_insert.cc: Ditto.\n+\t* testsuite/performance/20_util/allocator/list_sort_search.cc: Ditto.\n+\t* testsuite/performance/20_util/allocator/map_mt_find.cc: Ditto.\n+\t* testsuite/performance/20_util/allocator/map_thread.cc: Ditto.\n+\t* testsuite/performance/20_util/allocator/producer_consumer.cc: Ditto.\n+\n 2004-03-22  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cpu/cris/atomicity.h (__atomic_add): Remove \"static"}, {"sha": "93b437ff21791bc0e55feb66eb1e38a1d26f2b78", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -1183,7 +1183,7 @@ AC_DEFUN([GLIBCXX_ENABLE_ALLOCATOR], [\n   AC_MSG_CHECKING([for std::allocator base class to use])\n   GLIBCXX_ENABLE(libstdcxx-allocator,auto,[=KIND],\n     [use KIND for target std::allocator base],\n-    [permit new|malloc|mt|bitmap|yes|no|auto])\n+    [permit new|malloc|mt|bitmap|pool|yes|no|auto])\n   # If they didn't use this option switch, or if they specified --enable\n   # with no specific model, we'll have to look for one.  If they\n   # specified --disable (???), do likewise.\n@@ -1224,6 +1224,10 @@ AC_DEFUN([GLIBCXX_ENABLE_ALLOCATOR], [\n       ALLOCATOR_H=config/allocator/new_allocator_base.h\n       ALLOCATOR_NAME=__gnu_cxx::new_allocator\n       ;;\n+    pool)\n+      ALLOCATOR_H=config/allocator/pool_allocator_base.h\n+      ALLOCATOR_NAME=__gnu_cxx::__pool_alloc\n+      ;;\t\n   esac\n \n   AC_SUBST(ALLOCATOR_H)"}, {"sha": "77c74b2d512021c3d0a8769a1e41eaf006144819", "filename": "libstdc++-v3/config/allocator/pool_allocator_base.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Fconfig%2Fallocator%2Fpool_allocator_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Fconfig%2Fallocator%2Fpool_allocator_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fallocator%2Fpool_allocator_base.h?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -0,0 +1,37 @@\n+// Base to std::allocator -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CXX_ALLOCATOR_H\n+#define _CXX_ALLOCATOR_H 1\n+\n+// Define new_allocator as the base class to std::allocator.\n+#include <ext/pool_allocator.h>\n+#define ___glibcxx_base_allocator  __gnu_cxx::__pool_alloc\n+\n+#endif"}, {"sha": "6517ce5ca00a8977c4add06838ace9de6958eb05", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1377, "deletions": 691, "changes": 2068, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=29d4adf46099c3a60321f169af350c859b1a8216"}, {"sha": "a18e1c3a638210d4a60351186e890e13376633d1", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 132, "deletions": 104, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -59,9 +59,8 @@ namespace __gnu_cxx\n \n   /**\n    *  @if maint\n-   *  Default node allocator.  \"SGI\" style.  Uses various allocators to\n-   *  fulfill underlying requests (and makes as few requests as possible\n-   *  when in default high-speed pool mode).\n+   *  Uses various allocators to fulfill underlying requests (and makes as\n+   *  few requests as possible when in default high-speed pool mode).\n    *\n    *  Important implementation properties:\n    *  0. If globally mandated, then allocate objects from new\n@@ -72,25 +71,59 @@ namespace __gnu_cxx\n    *     information that we can return the object to the proper free list\n    *     without permanently losing part of the object.\n    *\n-   *  The first template parameter specifies whether more than one thread may\n-   *  use this allocator.  It is safe to allocate an object from one instance\n-   *  of a default_alloc and deallocate it with another one.  This effectively\n-   *  transfers its ownership to the second one.  This may have undesirable\n-   *  effects on reference locality.\n-   *\n-   *  The second parameter is unused and serves only to allow the\n-   *  creation of multiple default_alloc instances.  Note that\n-   *  containers built on different allocator instances have different\n-   *  types, limiting the utility of this approach.  If you do not\n-   *  wish to share the free lists with the main default_alloc\n-   *  instance, instantiate this with a non-zero __inst.\n-   *\n    *  @endif\n    *  (See @link Allocators allocators info @endlink for more.)\n    */\n-  template<bool __threads, int __inst>\n+  template<typename _Tp>\n     class __pool_alloc\n     {\n+    public:\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef __pool_alloc<_Tp1> other; };\n+\n+      __pool_alloc() throw() { }\n+\n+      __pool_alloc(const __pool_alloc&) throw() { }\n+\n+      template<typename _Tp1>\n+        __pool_alloc(const __pool_alloc<_Tp1>&) throw() { }\n+\n+      ~__pool_alloc() throw() { }\n+\n+      pointer\n+      address(reference __x) const { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+\n+      size_type\n+      max_size() const throw() \n+      { return size_t(-1) / sizeof(_Tp); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 402. wrong new expression in [some_] allocator::construct\n+      void \n+      construct(pointer __p, const _Tp& __val) \n+      { ::new(__p) _Tp(__val); }\n+\n+      void \n+      destroy(pointer __p) { __p->~_Tp(); }\n+\n+      pointer\n+      allocate(size_type __n, const void* = 0);\n+\n+      void\n+      deallocate(pointer __p, size_type __n);      \n+\n     private:\n       enum {_S_align = 8};\n       enum {_S_max_bytes = 128};\n@@ -134,40 +167,28 @@ namespace __gnu_cxx\n       // test whether threads are in use.\n       struct _Lock\n       {\n-        _Lock() { if (__threads) _S_lock._M_acquire_lock(); }\n-        ~_Lock() { if (__threads) _S_lock._M_release_lock(); }\n+        _Lock() { _S_lock._M_acquire_lock(); }\n+        ~_Lock() { _S_lock._M_release_lock(); }\n       } __attribute__ ((__unused__));\n       friend struct _Lock;\n-\n-    public:\n-      // __n must be > 0\n-      static void*\n-      allocate(size_t __n);\n-\n-      // __p may not be 0\n-      static void\n-      deallocate(void* __p, size_t __n);\n     };\n \n-  template<bool __threads, int __inst>\n+  template<typename _Tp>\n     inline bool\n-    operator==(const __pool_alloc<__threads,__inst>&,\n-\t       const __pool_alloc<__threads,__inst>&)\n+    operator==(const __pool_alloc<_Tp>&, const __pool_alloc<_Tp>&)\n     { return true; }\n \n-  template<bool __threads, int __inst>\n+  template<typename _Tp>\n     inline bool\n-    operator!=(const __pool_alloc<__threads,__inst>&,\n-               const __pool_alloc<__threads,__inst>&)\n+    operator!=(const __pool_alloc<_Tp>&, const __pool_alloc<_Tp>&)\n     { return false; }\n \n-\n   // Allocate memory in large chunks in order to avoid fragmenting the\n   // heap too much.  Assume that __n is properly aligned.  We hold\n   // the allocation lock.\n-  template<bool __threads, int __inst>\n+  template<typename _Tp>\n     char*\n-    __pool_alloc<__threads, __inst>::_S_chunk_alloc(size_t __n, int& __nobjs)\n+    __pool_alloc<_Tp>::_S_chunk_alloc(size_t __n, int& __nobjs)\n     {\n       char* __result;\n       size_t __total_bytes = __n * __nobjs;\n@@ -238,9 +259,9 @@ namespace __gnu_cxx\n   // Returns an object of size __n, and optionally adds to \"size\n   // __n\"'s free list.  We assume that __n is properly aligned.  We\n   // hold the allocation lock.\n-  template<bool __threads, int __inst>\n+  template<typename _Tp>\n     void*\n-    __pool_alloc<__threads, __inst>::_S_refill(size_t __n)\n+    __pool_alloc<_Tp>::_S_refill(size_t __n)\n     {\n       int __nobjs = 20;\n       char* __chunk = _S_chunk_alloc(__n, __nobjs);\n@@ -272,92 +293,99 @@ namespace __gnu_cxx\n       return __result;\n     }\n \n-  template<bool __threads, int __inst>\n-    void*\n-    __pool_alloc<__threads, __inst>::allocate(size_t __n)\n+  template<typename _Tp>\n+    _Tp*\n+    __pool_alloc<_Tp>::allocate(size_type __n, const void*)\n     {\n-      void* __ret = 0;\n-\n-      // If there is a race through here, assume answer from getenv\n-      // will resolve in same direction.  Inspired by techniques\n-      // to efficiently support threading found in basic_string.h.\n-      if (_S_force_new == 0)\n-\t{\n-\t  if (getenv(\"GLIBCXX_FORCE_NEW\"))\n-\t    __atomic_add(&_S_force_new, 1);\n-\t  else\n-\t    __atomic_add(&_S_force_new, -1);\n-\t}\n-\n-      if ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t__ret = ::operator new(__n);\n-      else\n+      pointer __ret = 0;\n+      if (__n)\n \t{\n-\t  _Obj* volatile* __free_list = _S_free_list + _S_freelist_index(__n);\n-\t  // Acquire the lock here with a constructor call.  This\n-\t  // ensures that it is released in exit or during stack\n-\t  // unwinding.\n-\t  _Lock __lock_instance;\n-\t  _Obj* __restrict__ __result = *__free_list;\n-\t  if (__builtin_expect(__result == 0, 0))\n-\t    __ret = _S_refill(_S_round_up(__n));\n-\t  else\n+\t  if (__n <= max_size())\n \t    {\n-\t      *__free_list = __result -> _M_free_list_link;\n-\t      __ret = __result;\n+\t      const size_t __bytes = __n * sizeof(_Tp);\n+\t      // If there is a race through here, assume answer from getenv\n+\t      // will resolve in same direction.  Inspired by techniques\n+\t      // to efficiently support threading found in basic_string.h.\n+\t      if (_S_force_new == 0)\n+\t\t{\n+\t\t  if (getenv(\"GLIBCXX_FORCE_NEW\"))\n+\t\t    __atomic_add(&_S_force_new, 1);\n+\t\t  else\n+\t\t    __atomic_add(&_S_force_new, -1);\n+\t\t}\n+\t      \n+\t      if ((__bytes > (size_t) _S_max_bytes) || (_S_force_new > 0))\n+\t\t__ret = static_cast<_Tp*>(::operator new(__bytes));\n+\t      else\n+\t\t{\n+\t\t  _Obj* volatile* __free_list = (_S_free_list\n+\t\t\t\t\t\t + _S_freelist_index(__bytes));\n+\t\t  // Acquire the lock here with a constructor call.  This\n+\t\t  // ensures that it is released in exit or during stack\n+\t\t  // unwinding.\n+\t\t  _Lock __lock_instance;\n+\t\t  _Obj* __restrict__ __result = *__free_list;\n+\t\t  if (__builtin_expect(__result == 0, 0))\n+\t\t    __ret = static_cast<_Tp*>(_S_refill(_S_round_up(__bytes)));\n+\t\t  else\n+\t\t    {\n+\t\t      *__free_list = __result -> _M_free_list_link;\n+\t\t      __ret = reinterpret_cast<_Tp*>(__result);\n+\t\t    }\n+\t\t  if (__builtin_expect(__ret == 0, 0))\n+\t\t    __throw_bad_alloc();\n+\t\t}\n \t    }\n-\t  if (__builtin_expect(__ret == 0, 0))\n+\t  else\n \t    __throw_bad_alloc();\n \t}\n       return __ret;\n     }\n \n-  template<bool __threads, int __inst>\n+  template<typename _Tp>\n     void\n-    __pool_alloc<__threads, __inst>::deallocate(void* __p, size_t __n)\n+    __pool_alloc<_Tp>::deallocate(pointer __p, size_type __n)\n     {\n-      if ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t::operator delete(__p);\n-      else\n+      if (__n)\n \t{\n-\t  _Obj* volatile* __free_list = _S_free_list + _S_freelist_index(__n);\n-\t  _Obj* __q = (_Obj*)__p;\n-\n-\t  // Acquire the lock here with a constructor call.  This\n-\t  // ensures that it is released in exit or during stack\n-\t  // unwinding.\n-\t  _Lock __lock_instance;\n-\t  __q -> _M_free_list_link = *__free_list;\n-\t  *__free_list = __q;\n+\t  const size_t __bytes = __n * sizeof(_Tp);\n+\t  if ((__bytes > (size_t) _S_max_bytes) || (_S_force_new > 0))\n+\t    ::operator delete(__p);\n+\t  else\n+\t    {\n+\t      _Obj* volatile* __free_list = (_S_free_list\n+\t\t\t\t\t     + _S_freelist_index(__bytes));\n+\t      _Obj* __q = (_Obj*)__p;\n+\n+\t      // Acquire the lock here with a constructor call.  This\n+\t      // ensures that it is released in exit or during stack\n+\t      // unwinding.\n+\t      _Lock __lock_instance;\n+\t      __q -> _M_free_list_link = *__free_list;\n+\t      *__free_list = __q;\n+\t    }\n \t}\n     }\n \n-  template<bool __threads, int __inst>\n-    typename __pool_alloc<__threads, __inst>::_Obj* volatile\n-    __pool_alloc<__threads, __inst>::_S_free_list[_S_freelists];\n+  template<typename _Tp>\n+    typename __pool_alloc<_Tp>::_Obj* volatile\n+    __pool_alloc<_Tp>::_S_free_list[_S_freelists];\n \n-  template<bool __threads, int __inst>\n-    char* __pool_alloc<__threads, __inst>::_S_start_free = 0;\n+  template<typename _Tp>\n+    char* __pool_alloc<_Tp>::_S_start_free = 0;\n \n-  template<bool __threads, int __inst>\n-    char* __pool_alloc<__threads, __inst>::_S_end_free = 0;\n+  template<typename _Tp>\n+    char* __pool_alloc<_Tp>::_S_end_free = 0;\n \n-  template<bool __threads, int __inst>\n-    size_t __pool_alloc<__threads, __inst>::_S_heap_size = 0;\n+  template<typename _Tp>\n+    size_t __pool_alloc<_Tp>::_S_heap_size = 0;\n \n-  template<bool __threads, int __inst>\n+  template<typename _Tp>\n     _STL_mutex_lock\n-    __pool_alloc<__threads, __inst>::_S_lock __STL_MUTEX_INITIALIZER;\n+    __pool_alloc<_Tp>::_S_lock __STL_MUTEX_INITIALIZER;\n \n-  template<bool __threads, int __inst> _Atomic_word\n-  __pool_alloc<__threads, __inst>::_S_force_new = 0;\n-\n-  // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.\n-  // NB: This syntax is a GNU extension.\n-#if _GLIBCXX_EXTERN_TEMPLATE\n-  extern template class __pool_alloc<true, 0>;\n-#endif\n+  template<typename _Tp> _Atomic_word\n+  __pool_alloc<_Tp>::_S_force_new = 0;\n } // namespace __gnu_cxx\n \n #endif"}, {"sha": "66a64fe3a9be927ccec9a9cc726094472e9b014c", "filename": "libstdc++-v3/src/allocator.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -44,5 +44,6 @@ namespace __gnu_cxx\n   template class __mt_alloc<wchar_t>;\n \n   // Static members of __pool_alloc.\n-  template class __pool_alloc<true, 0>;\n+  template class __pool_alloc<char>;\n+  template class __pool_alloc<wchar_t>;\n } // namespace __gnu_cxx"}, {"sha": "d9c8ceddb19e662147c24dbd55a9075a643ec3a4", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/insert.cc", "status": "modified", "additions": 64, "deletions": 33, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -44,6 +44,7 @@\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n #include <ext/bitmap_allocator.h>\n+#include <ext/pool_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n@@ -148,6 +149,7 @@ int main(void)\n   typedef __gnu_cxx::new_allocator<test_type> n_alloc_type;\n   typedef __gnu_cxx::__mt_alloc<test_type> so_alloc_type;\n   typedef __gnu_cxx::bitmap_allocator<test_type> bit_alloc_type;\n+  typedef __gnu_cxx::__pool_alloc<test_type> po_alloc_type;\n \n #ifdef TEST_B0\n   test_container(vector<test_type, m_alloc_type>());\n@@ -161,59 +163,74 @@ int main(void)\n #ifdef TEST_B3\n   test_container(vector<test_type, bit_alloc_type>());\n #endif\n-\n #ifdef TEST_B4\n-  test_container(list<test_type, m_alloc_type>());\n+  test_container(vector<test_type, po_alloc_type>());\n #endif\n+\n #ifdef TEST_B5\n-  test_container(list<test_type, n_alloc_type>());\n+  test_container(list<test_type, m_alloc_type>());\n #endif\n #ifdef TEST_B6\n-  test_container(list<test_type, so_alloc_type>());\n+  test_container(list<test_type, n_alloc_type>());\n #endif\n #ifdef TEST_B7\n+  test_container(list<test_type, so_alloc_type>());\n+#endif\n+#ifdef TEST_B8\n   test_container(list<test_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_B9\n+  test_container(list<test_type, po_alloc_type>());\n+#endif\n \n-#ifdef TEST_B8\n+#ifdef TEST_B10\n   test_container(deque<test_type, m_alloc_type>());\n #endif\n-#ifdef TEST_B9\n+#ifdef TEST_B11\n   test_container(deque<test_type, n_alloc_type>());\n #endif\n-#ifdef TEST_B10\n+#ifdef TEST_B12\n   test_container(deque<test_type, so_alloc_type>());\n #endif\n-#ifdef TEST_B11\n+#ifdef TEST_B13\n   test_container(deque<test_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_B14\n+  test_container(deque<test_type, po_alloc_type>());\n+#endif\n \n   typedef less<test_type> compare_type;\n-#ifdef TEST_B12\n+#ifdef TEST_B15\n   test_container(map<test_type, test_type, compare_type, m_alloc_type>());\n #endif\n-#ifdef TEST_B13\n+#ifdef TEST_B16\n   test_container(map<test_type, test_type, compare_type, n_alloc_type>());\n #endif\n-#ifdef TEST_B14\n+#ifdef TEST_B17\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>());\n #endif\n-#ifdef TEST_B15\n+#ifdef TEST_B18\n   test_container(map<test_type, test_type, compare_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_B19\n+  test_container(map<test_type, test_type, compare_type, po_alloc_type>());\n+#endif\n \n-#ifdef TEST_B16\n+#ifdef TEST_B20\n   test_container(set<test_type, compare_type, m_alloc_type>());\n #endif\n-#ifdef TEST_B17\n+#ifdef TEST_B21\n   test_container(set<test_type, compare_type, n_alloc_type>());\n #endif\n-#ifdef TEST_B18\n+#ifdef TEST_B22\n   test_container(set<test_type, compare_type, so_alloc_type>());\n #endif\n-#ifdef TEST_B19\n+#ifdef TEST_B23\n   test_container(set<test_type, compare_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_B24\n+  test_container(set<test_type, compare_type, po_alloc_type>());\n+#endif\n \n #ifdef TEST_T0\n   test_container(vector<test_type, m_alloc_type>(), true);\n@@ -227,59 +244,73 @@ int main(void)\n #ifdef TEST_T3\n   test_container(vector<test_type, bit_alloc_type>(), true);\n #endif\n-\n #ifdef TEST_T4\n-  test_container(list<test_type, m_alloc_type>(), true);\n+  test_container(vector<test_type, po_alloc_type>(), true);\n #endif\n+\n #ifdef TEST_T5\n-  test_container(list<test_type, n_alloc_type>(), true);\n+  test_container(list<test_type, m_alloc_type>(), true);\n #endif\n #ifdef TEST_T6\n-  test_container(list<test_type, so_alloc_type>(), true);\n+  test_container(list<test_type, n_alloc_type>(), true);\n #endif\n #ifdef TEST_T7\n+  test_container(list<test_type, so_alloc_type>(), true);\n+#endif\n+#ifdef TEST_T8\n   test_container(list<test_type, bit_alloc_type>(), true);\n #endif\n+#ifdef TEST_T9\n+  test_container(list<test_type, po_alloc_type>(), true);\n+#endif\n \n-#ifdef TEST_T8\n+#ifdef TEST_T10\n   test_container(deque<test_type, m_alloc_type>(), true);\n #endif\n-#ifdef TEST_T9\n+#ifdef TEST_T11\n   test_container(deque<test_type, n_alloc_type>(), true);\n #endif\n-#ifdef TEST_T10\n+#ifdef TEST_T12\n   test_container(deque<test_type, so_alloc_type>(), true);\n #endif\n-#ifdef TEST_T11\n+#ifdef TEST_T13\n   test_container(deque<test_type, bit_alloc_type>(), true);\n #endif\n+#ifdef TEST_T14\n+  test_container(deque<test_type, po_alloc_type>(), true);\n+#endif\n \n   typedef less<test_type> compare_type;\n-#ifdef TEST_T12\n+#ifdef TEST_T15\n   test_container(map<test_type, test_type, compare_type, m_alloc_type>(), true);\n #endif\n-#ifdef TEST_T13\n+#ifdef TEST_T16\n   test_container(map<test_type, test_type, compare_type, n_alloc_type>(), true);\n #endif\n-#ifdef TEST_T14\n+#ifdef TEST_T17\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>(), true);\n #endif\n-#ifdef TEST_T15\n+#ifdef TEST_T18\n   test_container(map<test_type, test_type, compare_type, bit_alloc_type>(), true);\n #endif\n+#ifdef TEST_T19\n+  test_container(map<test_type, test_type, compare_type, po_alloc_type>(), true);\n+#endif\n \n-#ifdef TEST_T16\n+#ifdef TEST_T20\n   test_container(set<test_type, compare_type, m_alloc_type>(), true);\n #endif\n-#ifdef TEST_T17\n+#ifdef TEST_T21\n   test_container(set<test_type, compare_type, n_alloc_type>(), true);\n #endif\n-#ifdef TEST_T18\n+#ifdef TEST_T22\n   test_container(set<test_type, compare_type, so_alloc_type>(), true);\n #endif\n-#ifdef TEST_T19\n+#ifdef TEST_T23\n   test_container(set<test_type, compare_type, bit_alloc_type>(), true);\n #endif\n-\n+#ifdef TEST_T24\n+  test_container(set<test_type, compare_type, po_alloc_type>(), true);\n+#endif\n   return 0;\n }"}, {"sha": "ef1ff52dbce667159cd2d1a7ef8562666911aaa2", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/insert_insert.cc", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -44,6 +44,7 @@\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n #include <ext/bitmap_allocator.h>\n+#include <ext/pool_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n@@ -119,6 +120,7 @@ int main(void)\n   typedef __gnu_cxx::new_allocator<test_type> n_alloc_type;\n   typedef __gnu_cxx::__mt_alloc<test_type> so_alloc_type;\n   typedef __gnu_cxx::bitmap_allocator<test_type> bit_alloc_type;\n+  typedef __gnu_cxx::__pool_alloc<test_type> po_alloc_type;\n \n #ifdef TEST_S0\n   test_container(vector<test_type, m_alloc_type>());\n@@ -132,62 +134,73 @@ int main(void)\n #ifdef TEST_S3\n   test_container(vector<test_type, bit_alloc_type>());\n #endif\n-\n-\n #ifdef TEST_S4\n-  test_container(list<test_type, m_alloc_type>());\n+  test_container(vector<test_type, po_alloc_type>());\n #endif\n+\n #ifdef TEST_S5\n-  test_container(list<test_type, n_alloc_type>());\n+  test_container(list<test_type, m_alloc_type>());\n #endif\n #ifdef TEST_S6\n-  test_container(list<test_type, so_alloc_type>());\n+  test_container(list<test_type, n_alloc_type>());\n #endif\n #ifdef TEST_S7\n+  test_container(list<test_type, so_alloc_type>());\n+#endif\n+#ifdef TEST_S8\n   test_container(list<test_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_S9\n+  test_container(list<test_type, po_alloc_type>());\n+#endif\n \n-\n-#ifdef TEST_S8\n+#ifdef TEST_S10\n   test_container(deque<test_type, m_alloc_type>());\n #endif\n-#ifdef TEST_S9\n+#ifdef TEST_S11\n   test_container(deque<test_type, n_alloc_type>());\n #endif\n-#ifdef TEST_S10\n+#ifdef TEST_S12\n   test_container(deque<test_type, so_alloc_type>());\n #endif\n-#ifdef TEST_S11\n+#ifdef TEST_S13\n   test_container(deque<test_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_S14\n+  test_container(deque<test_type, po_alloc_type>());\n+#endif\n \n   typedef less<test_type> compare_type;\n-#ifdef TEST_S12\n+#ifdef TEST_S15\n   test_container(map<test_type, test_type, compare_type, m_alloc_type>());\n #endif\n-#ifdef TEST_S13\n+#ifdef TEST_S16\n   test_container(map<test_type, test_type, compare_type, n_alloc_type>());\n #endif\n-#ifdef TEST_S14\n+#ifdef TEST_S17\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>());\n #endif\n-#ifdef TEST_S15\n+#ifdef TEST_S18\n   test_container(map<test_type, test_type, compare_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_S19\n+  test_container(map<test_type, test_type, compare_type, po_alloc_type>());\n+#endif\n \n-\n-#ifdef TEST_S12\n+#ifdef TEST_S20\n   test_container(set<test_type, compare_type, m_alloc_type>());\n #endif\n-#ifdef TEST_S13\n+#ifdef TEST_S21\n   test_container(set<test_type, compare_type, n_alloc_type>());\n #endif\n-#ifdef TEST_S14\n+#ifdef TEST_S22\n   test_container(set<test_type, compare_type, so_alloc_type>());\n #endif\n-#ifdef TEST_S14\n+#ifdef TEST_S23\n   test_container(set<test_type, compare_type, bit_alloc_type>());\n #endif\n-\n+#ifdef TEST_S24\n+  test_container(set<test_type, compare_type, po_alloc_type>());\n+#endif\n   return 0;\n }"}, {"sha": "f39e814752aaaa7df66050940e34283d2b5cef8a", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/list_sort_search.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Flist_sort_search.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Flist_sort_search.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Flist_sort_search.cc?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -34,11 +34,13 @@\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n #include <ext/bitmap_allocator.h>\n+#include <ext/pool_allocator.h>\n \n using namespace std;\n using __gnu_cxx::malloc_allocator;\n using __gnu_cxx::__mt_alloc;\n using __gnu_cxx::bitmap_allocator;\n+using __gnu_cxx::__pool_alloc;\n \n typedef int test_type;\n \n@@ -105,7 +107,6 @@ void do_test ()\n   report_performance(__FILE__, string(), time, resource);\n }\n \n-\n int main ()\n {\n #ifdef TEST_S0\n@@ -120,6 +121,9 @@ int main ()\n #ifdef TEST_S3\n   do_test<__mt_alloc<int> >();\n #endif\n+#ifdef TEST_S4\n+  do_test<__pool_alloc<int> >();\n+#endif\n }\n \n "}, {"sha": "35bba56e473bdc2597bd56bde19ea19a4b39ecd7", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/map_mt_find.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_mt_find.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_mt_find.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_mt_find.cc?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -40,11 +40,13 @@\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n #include <ext/bitmap_allocator.h>\n+#include <ext/pool_allocator.h>\n \n using namespace std;\n using __gnu_cxx::malloc_allocator;\n using __gnu_cxx::__mt_alloc;\n using __gnu_cxx::bitmap_allocator;\n+using __gnu_cxx::__pool_alloc;\n \n typedef int test_type;\n \n@@ -145,4 +147,7 @@ int main()\n #ifdef TEST_T3\n   exec_tests<__mt_alloc<int> >();\n #endif\n+#ifdef TEST_T4\n+  exec_tests<__pool_alloc<int> >();\n+#endif\n }"}, {"sha": "667d50b171e4b092758cd62c82b69de92bb91e4e", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/map_thread.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -41,6 +41,7 @@\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n #include <ext/bitmap_allocator.h>\n+#include <ext/pool_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n@@ -49,6 +50,7 @@ using __gnu_cxx::__mt_alloc;\n using __gnu_cxx::new_allocator;\n using __gnu_cxx::malloc_allocator;\n using __gnu_cxx::bitmap_allocator;\n+using __gnu_cxx::__pool_alloc;\n \n // The number of iterations to be performed.\n int iterations = 10000;\n@@ -125,7 +127,8 @@ int main(void)\n #ifdef TEST_T5\n   test_container(map<int, int, less<const int>, bitmap_allocator<int> >());\n #endif\n-\n-\n+#ifdef TEST_T6\n+  test_container(map<int, int, less<const int>, __pool_alloc<int> >());\n+#endif\n   return 0;\n }"}, {"sha": "5295e7e1fad2cd2e6cdd9485fefb02d5cd0d8467", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/producer_consumer.cc", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d4adf46099c3a60321f169af350c859b1a8216/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc?ref=29d4adf46099c3a60321f169af350c859b1a8216", "patch": "@@ -42,6 +42,7 @@\n #include <ext/new_allocator.h>\n #include <ext/malloc_allocator.h>\n #include <ext/bitmap_allocator.h>\n+#include <ext/pool_allocator.h>\n #include <cxxabi.h>\n #include <testsuite_performance.h>\n \n@@ -51,6 +52,7 @@ using __gnu_cxx::__mt_alloc;\n using __gnu_cxx::new_allocator;\n using __gnu_cxx::malloc_allocator;\n using __gnu_cxx::bitmap_allocator;\n+using __gnu_cxx::__pool_alloc;\n using abi::__cxa_demangle;\n \n typedef int test_type;\n@@ -59,6 +61,7 @@ typedef malloc_allocator<test_type> malloc_alloc_type;\n typedef new_allocator<test_type> new_alloc_type;\n typedef __mt_alloc<test_type> so_alloc_type;\n typedef bitmap_allocator<test_type> bit_alloc_type;\n+typedef __pool_alloc<test_type> po_alloc_type;\n \n // The number of iterations to be performed.\n int iterations = 10000;\n@@ -298,35 +301,41 @@ int main(void)\n #ifdef TEST_T4\n   test_container(vector<test_type, bit_alloc_type>());\n #endif\n-\n-\n #ifdef TEST_T5\n-  test_container(list<test_type, malloc_alloc_type>());\n+  test_container(vector<test_type, po_alloc_type>());\n #endif\n+\n #ifdef TEST_T6\n-  test_container(list<test_type, new_alloc_type>());\n+  test_container(list<test_type, malloc_alloc_type>());\n #endif\n #ifdef TEST_T7\n-  test_container(list<test_type, so_alloc_type>());\n+  test_container(list<test_type, new_alloc_type>());\n #endif\n #ifdef TEST_T8\n+  test_container(list<test_type, so_alloc_type>());\n+#endif\n+#ifdef TEST_T9\n   test_container(list<test_type, bit_alloc_type>());\n #endif\n+#ifdef TEST_T10\n+  test_container(list<test_type, po_alloc_type>());\n+#endif\n \n-\n-#ifdef TEST_T9\n+#ifdef TEST_T11\n   test_container(map<test_type, test_type, compare_type, malloc_alloc_type>());\n #endif\n-#ifdef TEST_T10\n+#ifdef TEST_T12\n   test_container(map<test_type, test_type, compare_type, new_alloc_type>());\n #endif\n-#ifdef TEST_T11\n+#ifdef TEST_T13\n   test_container(map<test_type, test_type, compare_type, so_alloc_type>());\n #endif\n-#ifdef TEST_T12\n+#ifdef TEST_T14\n   test_container(map<test_type, test_type, compare_type, bit_alloc_type>());\n #endif\n-\n+#ifdef TEST_T15\n+  test_container(map<test_type, test_type, compare_type, po_alloc_type>());\n+#endif\n \n   return 0;\n }"}]}