{"sha": "ce6ecbac46ad1b9b6838e2adfe31ee7441da5524", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2ZWNiYWM0NmFkMWI5YjY4MzhlMmFkZmUzMWVlNzQ0MWRhNTUyNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2018-01-29T22:30:34Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-01-29T22:30:34Z"}, "message": "re PR target/81550 (gcc.target/powerpc/loop_align.c fails starting with r250482)\n\n2018-01-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/81550\n\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): If DFmode\n\tand SFmode can go in Altivec registers (-mcpu=power7 for DFmode,\n\t-mcpu=power8 for SFmode) don't set the PRE_INCDEC or PRE_MODIFY\n\tflags.  This restores the settings used before the 2017-07-24.\n\tTurning off pre increment/decrement/modify allows IVOPTS to\n\toptimize DF/SF loops where the index is an int.\n\nFrom-SVN: r257166", "tree": {"sha": "ddc2ba0a978313c55b2e2fbc8a755c71fb068e4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddc2ba0a978313c55b2e2fbc8a755c71fb068e4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524/comments", "author": null, "committer": null, "parents": [{"sha": "74d82e6b688546121764363c154af4bfe2d480f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d82e6b688546121764363c154af4bfe2d480f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74d82e6b688546121764363c154af4bfe2d480f1"}], "stats": {"total": 22, "additions": 21, "deletions": 1}, "files": [{"sha": "aafaa36975ab3ba06a046c7426ffe5ee58a5fac7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce6ecbac46ad1b9b6838e2adfe31ee7441da5524", "patch": "@@ -1,3 +1,13 @@\n+2018-01-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/81550\n+\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): If DFmode\n+\tand SFmode can go in Altivec registers (-mcpu=power7 for DFmode,\n+\t-mcpu=power8 for SFmode) don't set the PRE_INCDEC or PRE_MODIFY\n+\tflags.  This restores the settings used before the 2017-07-24.\n+\tTurning off pre increment/decrement/modify allows IVOPTS to\n+\toptimize DF/SF loops where the index is an int.\n+\n 2018-01-29  Richard Biener <rguenther@suse.de>\n \t    Kelvin Nilsen  <kelvin@gcc.gnu.org>\n "}, {"sha": "145ac86d41d89606d9f43d5f65cd5805373f10a4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce6ecbac46ad1b9b6838e2adfe31ee7441da5524/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ce6ecbac46ad1b9b6838e2adfe31ee7441da5524", "patch": "@@ -2982,14 +2982,24 @@ rs6000_setup_reg_addr_masks (void)\n \n \t      /* Figure out if we can do PRE_INC, PRE_DEC, or PRE_MODIFY\n \t\t addressing.  If we allow scalars into Altivec registers,\n-\t\t don't allow PRE_INC, PRE_DEC, or PRE_MODIFY.  */\n+\t\t don't allow PRE_INC, PRE_DEC, or PRE_MODIFY.\n+\n+\t\t For VSX systems, we don't allow update addressing for\n+\t\t DFmode/SFmode if those registers can go in both the\n+\t\t traditional floating point registers and Altivec registers.\n+\t\t The load/store instructions for the Altivec registers do not\n+\t\t have update forms.  If we allowed update addressing, it seems\n+\t\t to break IV-OPT code using floating point if the index type is\n+\t\t int instead of long (PR target/81550 and target/84042).  */\n \n \t      if (TARGET_UPDATE\n \t\t  && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR)\n \t\t  && msize <= 8\n \t\t  && !VECTOR_MODE_P (m2)\n \t\t  && !FLOAT128_VECTOR_P (m2)\n \t\t  && !complex_p\n+\t\t  && (m != E_DFmode || !TARGET_VSX)\n+\t\t  && (m != E_SFmode || !TARGET_P8_VECTOR)\n \t\t  && !small_int_vsx_p)\n \t\t{\n \t\t  addr_mask |= RELOAD_REG_PRE_INCDEC;"}]}