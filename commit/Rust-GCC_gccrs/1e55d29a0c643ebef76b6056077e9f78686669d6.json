{"sha": "1e55d29a0c643ebef76b6056077e9f78686669d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU1NWQyOWEwYzY0M2ViZWY3NmI2MDU2MDc3ZTlmNzg2ODY2NjlkNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-04-27T18:08:39Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-04-27T18:08:39Z"}, "message": "sem_aux.adb (Is_By_Reference_Type): Also return true for a tagged incomplete type without full view.\n\n\t* sem_aux.adb (Is_By_Reference_Type): Also return true for a tagged\n\tincomplete type without full view.\n\t* sem_ch6.adb (Exchange_Limited_Views): Change into a function and\n\treturn the list of changes.\n\t(Restore_Limited_Views): New procedure to undo the transformation made\n\tby Exchange_Limited_Views.\n\t(Analyze_Subprogram_Body_Helper): Adjust call to Exchange_Limited_Views\n\tand call Restore_Limited_Views at the end, if need be.\n\t(Possible_Freeze): Do not delay freezing because of incomplete types.\n\t(Process_Formals): Remove kludges for class-wide types.\n\t* types.h (By_Copy_Return): Delete.\n\t* gcc-interface/ada-tree.h (TYPE_MAX_ALIGN): Move around.\n\t(TYPE_DUMMY_IN_PROFILE_P): New macro.\n\t* gcc-interface/gigi.h (update_profiles_with): Declare.\n\t(finish_subprog_decl): Likewise.\n\t(get_minimal_subprog_decl): Delete.\n\t(create_subprog_type): Likewise.\n\t(create_param_decl): Adjust prototype.\n\t(create_subprog_decl): Likewise.\n\t* gcc-interface/decl.c (defer_limited_with): Rename into...\n\t(defer_limited_with_list): ...this.\n\t(gnat_to_gnu_entity): Adjust to above renaming.\n\t(finalize_from_limited_with): Likewise.\n\t(tree_entity_vec_map): New structure.\n\t(gt_pch_nx): New helpers.\n\t(dummy_to_subprog_map): New hash table.\n\t(gnat_to_gnu_param): Set the SLOC here.  Remove MECH parameter and\n\tadd FIRST parameter.  Deal with the mechanism here instead of...\n\tDo not make read-only variant of types.  Simplify expressions.\n\tIn the by-ref case, test the mechanism before must_pass_by_ref\n\tand also TYPE_IS_BY_REFERENCE_P before building the reference type.\n\t(gnat_to_gnu_subprog_type): New static function extracted from...\n\tDo not special-case the type_annotate_only mode.  Call\n\tgnat_to_gnu_profile_type instead of gnat_to_gnu_type on return type.\n\tDeal with dummy return types.  Likewise for parameter types.  Deal\n\twith by-reference types explicitly and add a kludge for null procedures\n\twith untagged incomplete types.  Remove assertion on the types and be\n\tprepared for multiple elaboration of the declarations.  Skip the whole\n\tCICO processing if the profile is incomplete.  Handle the completion of\n\ta previously incomplete profile.\n\t(gnat_to_gnu_entity) <E_Variable>: Rename local variable.\n\tAdjust couple of calls to create_param_decl.\n\t<E_Access_Subprogram_Type, E_Anonymous_Access_Subprogram_Type>:\n\tRemove specific deferring code.\n\t<E_Access_Type>: Also deal with E_Subprogram_Type designated type.\n\tSimplify handling of dummy types and remove obsolete comment.\n\tConstify a couple of variables.  Do not set TYPE_UNIVERSAL_ALIASING_P\n\ton dummy types.\n\t<E_Access_Subtype>: Tweak comment and simplify condition.\n\t<E_Subprogram_Type>: ...here.  Call it and clean up handling.  Remove\n\tobsolete comment and adjust call to gnat_to_gnu_param.  Adjust call to\n\tcreate_subprog_decl.\n\t<E_Incomplete_Type>: Add a couple of 'const' qualifiers and get rid of\n\tinner break statements.  Tidy up condition guarding direct use of the\n\tfull view.\n\t(get_minimal_subprog_decl): Delete.\n\t(finalize_from_limited_with): Call update_profiles_with on dummy types\n\twith TYPE_DUMMY_IN_PROFILE_P set.\n\t(is_from_limited_with_of_main): Delete.\n\t(associate_subprog_with_dummy_type): New function.\n\t(update_profile): Likewise.\n\t(update_profiles_with): Likewise.\n\t(gnat_to_gnu_profile_type): Likewise.\n\t(init_gnat_decl): Initialize dummy_to_subprog_map.\n\t(destroy_gnat_decl): Destroy dummy_to_subprog_map.\n\t* gcc-interface/misc.c (gnat_get_alias_set): Add guard for accessing\n\tTYPE_UNIVERSAL_ALIASING_P.\n\t(gnat_get_array_descr_info): Minor tweak.\n\t* gcc-interface/trans.c (gigi): Adjust calls to create_subprog_decl.\n\t(build_raise_check): Likewise.\n\t(Compilation_Unit_to_gnu): Likewise.\n\t(Identifier_to_gnu): Accept mismatches coming from a limited context.\n\t(Attribute_to_gnu): Remove kludge for dispatch table entities.\n\t(process_freeze_entity): Do not retrieve old definition if there is an\n\taddress clause on the entity.  Call update_profiles_with on dummy types\n\twith TYPE_DUMMY_IN_PROFILE_P set.\n\t* gcc-interface/utils.c (build_dummy_unc_pointer_types): Also set\n\tTYPE_REFERENCE_TO to the fat pointer type.\n\t(create_subprog_type): Delete.\n\t(create_param_decl): Remove READONLY parameter.\n\t(finish_subprog_decl): New function extracted from...\n\t(create_subprog_decl): ...here.  Call it.  Remove CONST_FLAG and\n\tVOLATILE_FLAG parameters and adjust.\n\t(update_pointer_to): Also clear TYPE_REFERENCE_TO in the unconstrained\n\tcase.\n\nFrom-SVN: r235521", "tree": {"sha": "c55480876dc3fe6269c2e5c4075b0b3b34bf2b5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c55480876dc3fe6269c2e5c4075b0b3b34bf2b5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e55d29a0c643ebef76b6056077e9f78686669d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e55d29a0c643ebef76b6056077e9f78686669d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e55d29a0c643ebef76b6056077e9f78686669d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e55d29a0c643ebef76b6056077e9f78686669d6/comments", "author": null, "committer": null, "parents": [{"sha": "e306693a820abb242c4ccfce28bbd0f9cec7bda9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e306693a820abb242c4ccfce28bbd0f9cec7bda9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e306693a820abb242c4ccfce28bbd0f9cec7bda9"}], "stats": {"total": 2067, "additions": 1169, "deletions": 898}, "files": [{"sha": "f277eaf2ed335007fdf4d847b0fa6e10b8be6d47", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -1,3 +1,91 @@\n+2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_aux.adb (Is_By_Reference_Type): Also return true for a tagged\n+\tincomplete type without full view.\n+\t* sem_ch6.adb (Exchange_Limited_Views): Change into a function and\n+\treturn the list of changes.\n+\t(Restore_Limited_Views): New procedure to undo the transformation made\n+\tby Exchange_Limited_Views.\n+\t(Analyze_Subprogram_Body_Helper): Adjust call to Exchange_Limited_Views\n+\tand call Restore_Limited_Views at the end, if need be.\n+\t(Possible_Freeze): Do not delay freezing because of incomplete types.\n+\t(Process_Formals): Remove kludges for class-wide types.\n+\t* types.h (By_Copy_Return): Delete.\n+\t* gcc-interface/ada-tree.h (TYPE_MAX_ALIGN): Move around.\n+\t(TYPE_DUMMY_IN_PROFILE_P): New macro.\n+\t* gcc-interface/gigi.h (update_profiles_with): Declare.\n+\t(finish_subprog_decl): Likewise.\n+\t(get_minimal_subprog_decl): Delete.\n+\t(create_subprog_type): Likewise.\n+\t(create_param_decl): Adjust prototype.\n+\t(create_subprog_decl): Likewise.\n+\t* gcc-interface/decl.c (defer_limited_with): Rename into...\n+\t(defer_limited_with_list): ...this.\n+\t(gnat_to_gnu_entity): Adjust to above renaming.\n+\t(finalize_from_limited_with): Likewise.\n+\t(tree_entity_vec_map): New structure.\n+\t(gt_pch_nx): New helpers.\n+\t(dummy_to_subprog_map): New hash table.\n+\t(gnat_to_gnu_param): Set the SLOC here.  Remove MECH parameter and\n+\tadd FIRST parameter.  Deal with the mechanism here instead of...\n+\tDo not make read-only variant of types.  Simplify expressions.\n+\tIn the by-ref case, test the mechanism before must_pass_by_ref\n+\tand also TYPE_IS_BY_REFERENCE_P before building the reference type.\n+\t(gnat_to_gnu_subprog_type): New static function extracted from...\n+\tDo not special-case the type_annotate_only mode.  Call\n+\tgnat_to_gnu_profile_type instead of gnat_to_gnu_type on return type.\n+\tDeal with dummy return types.  Likewise for parameter types.  Deal\n+\twith by-reference types explicitly and add a kludge for null procedures\n+\twith untagged incomplete types.  Remove assertion on the types and be\n+\tprepared for multiple elaboration of the declarations.  Skip the whole\n+\tCICO processing if the profile is incomplete.  Handle the completion of\n+\ta previously incomplete profile.\n+\t(gnat_to_gnu_entity) <E_Variable>: Rename local variable.\n+\tAdjust couple of calls to create_param_decl.\n+\t<E_Access_Subprogram_Type, E_Anonymous_Access_Subprogram_Type>:\n+\tRemove specific deferring code.\n+\t<E_Access_Type>: Also deal with E_Subprogram_Type designated type.\n+\tSimplify handling of dummy types and remove obsolete comment.\n+\tConstify a couple of variables.  Do not set TYPE_UNIVERSAL_ALIASING_P\n+\ton dummy types.\n+\t<E_Access_Subtype>: Tweak comment and simplify condition.\n+\t<E_Subprogram_Type>: ...here.  Call it and clean up handling.  Remove\n+\tobsolete comment and adjust call to gnat_to_gnu_param.  Adjust call to\n+\tcreate_subprog_decl.\n+\t<E_Incomplete_Type>: Add a couple of 'const' qualifiers and get rid of\n+\tinner break statements.  Tidy up condition guarding direct use of the\n+\tfull view.\n+\t(get_minimal_subprog_decl): Delete.\n+\t(finalize_from_limited_with): Call update_profiles_with on dummy types\n+\twith TYPE_DUMMY_IN_PROFILE_P set.\n+\t(is_from_limited_with_of_main): Delete.\n+\t(associate_subprog_with_dummy_type): New function.\n+\t(update_profile): Likewise.\n+\t(update_profiles_with): Likewise.\n+\t(gnat_to_gnu_profile_type): Likewise.\n+\t(init_gnat_decl): Initialize dummy_to_subprog_map.\n+\t(destroy_gnat_decl): Destroy dummy_to_subprog_map.\n+\t* gcc-interface/misc.c (gnat_get_alias_set): Add guard for accessing\n+\tTYPE_UNIVERSAL_ALIASING_P.\n+\t(gnat_get_array_descr_info): Minor tweak.\n+\t* gcc-interface/trans.c (gigi): Adjust calls to create_subprog_decl.\n+\t(build_raise_check): Likewise.\n+\t(Compilation_Unit_to_gnu): Likewise.\n+\t(Identifier_to_gnu): Accept mismatches coming from a limited context.\n+\t(Attribute_to_gnu): Remove kludge for dispatch table entities.\n+\t(process_freeze_entity): Do not retrieve old definition if there is an\n+\taddress clause on the entity.  Call update_profiles_with on dummy types\n+\twith TYPE_DUMMY_IN_PROFILE_P set.\n+\t* gcc-interface/utils.c (build_dummy_unc_pointer_types): Also set\n+\tTYPE_REFERENCE_TO to the fat pointer type.\n+\t(create_subprog_type): Delete.\n+\t(create_param_decl): Remove READONLY parameter.\n+\t(finish_subprog_decl): New function extracted from...\n+\t(create_subprog_decl): ...here.  Call it.  Remove CONST_FLAG and\n+\tVOLATILE_FLAG parameters and adjust.\n+\t(update_pointer_to): Also clear TYPE_REFERENCE_TO in the unconstrained\n+\tcase.\n+\n 2016-04-27  Arnaud Charlet  <charlet@adacore.com>\n \n \t* aa_util.adb, aa_util.ads: Removed, no longer used."}, {"sha": "cf75ea4000b8fd69a7ffca289a04130d3625ee89", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -180,12 +180,11 @@ do {\t\t\t\t\t\t\t \\\n #define TYPE_IS_PADDING_P(NODE) \\\n   (TREE_CODE (NODE) == RECORD_TYPE && TYPE_PADDING_P (NODE))\n \n-/* True if TYPE can alias any other types.  */\n+/* True for a non-dummy type if TYPE can alias any other types.  */\n #define TYPE_UNIVERSAL_ALIASING_P(NODE) TYPE_LANG_FLAG_6 (NODE)\n \n-/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, this holds the maximum\n-   alignment value the type ought to have.  */\n-#define TYPE_MAX_ALIGN(NODE) (TYPE_PRECISION (RECORD_OR_UNION_CHECK (NODE)))\n+/* True for a dummy type if TYPE appears in a profile.  */\n+#define TYPE_DUMMY_IN_PROFILE_P(NODE) TYPE_LANG_FLAG_6 (NODE)\n \n /* True for types that implement a packed array and for original packed array\n    types.  */\n@@ -196,6 +195,10 @@ do {\t\t\t\t\t\t\t \\\n /* True for types that can hold a debug type.  */\n #define TYPE_CAN_HAVE_DEBUG_TYPE_P(NODE) (!TYPE_IMPL_PACKED_ARRAY_P (NODE))\n \n+/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, this holds the maximum\n+   alignment value the type ought to have.  */\n+#define TYPE_MAX_ALIGN(NODE) (TYPE_PRECISION (RECORD_OR_UNION_CHECK (NODE)))\n+\n /* For an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the\n    template and the object.\n "}, {"sha": "14bc1281a9e1e94205d1b168a97d543037723fe6", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 806, "deletions": 661, "changes": 1467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -96,13 +96,13 @@ struct incomplete\n };\n \n /* These variables are used to defer recursively expanding incomplete types\n-   while we are processing an array, a record or a subprogram type.  */\n+   while we are processing a record, an array or a subprogram type.  */\n static int defer_incomplete_level = 0;\n static struct incomplete *defer_incomplete_list;\n \n /* This variable is used to delay expanding From_Limited_With types until the\n    end of the spec.  */\n-static struct incomplete *defer_limited_with;\n+static struct incomplete *defer_limited_with_list;\n \n typedef struct subst_pair_d {\n   tree discriminant;\n@@ -125,8 +125,7 @@ typedef struct variant_desc_d {\n } variant_desc;\n \n \n-/* A hash table used to cache the result of annotate_value.  */\n-\n+/* A map used to cache the result of annotate_value.  */\n struct value_annotation_hasher : ggc_cache_ptr_hash<tree_int_map>\n {\n   static inline hashval_t\n@@ -150,6 +149,47 @@ struct value_annotation_hasher : ggc_cache_ptr_hash<tree_int_map>\n \n static GTY ((cache)) hash_table<value_annotation_hasher> *annotate_value_cache;\n \n+/* A map used to associate a dummy type with a list of subprogram entities.  */\n+struct GTY((for_user)) tree_entity_vec_map\n+{\n+  struct tree_map_base base;\n+  vec<Entity_Id, va_gc_atomic> *to;\n+};\n+\n+void\n+gt_pch_nx (Entity_Id &)\n+{\n+}\n+\n+void\n+gt_pch_nx (Entity_Id *x, gt_pointer_operator op, void *cookie)\n+{\n+  op (x, cookie);\n+}\n+\n+struct dummy_type_hasher : ggc_cache_ptr_hash<tree_entity_vec_map>\n+{\n+  static inline hashval_t\n+  hash (tree_entity_vec_map *m)\n+  {\n+    return htab_hash_pointer (m->base.from);\n+  }\n+\n+  static inline bool\n+  equal (tree_entity_vec_map *a, tree_entity_vec_map *b)\n+  {\n+    return a->base.from == b->base.from;\n+  }\n+\n+  static int\n+  keep_cache_entry (tree_entity_vec_map *&m)\n+  {\n+    return ggc_marked_p (m->base.from);\n+  }\n+};\n+\n+static GTY ((cache)) hash_table<dummy_type_hasher> *dummy_to_subprog_map;\n+\n static void prepend_one_attribute (struct attrib **,\n \t\t\t\t   enum attrib_type, tree, tree, Node_Id);\n static void prepend_one_attribute_pragma (struct attrib **, Node_Id);\n@@ -162,10 +202,8 @@ static tree elaborate_expression_2 (tree, Entity_Id, const char *, bool, bool,\n \t\t\t\t    unsigned int);\n static tree elaborate_reference (tree, Entity_Id, bool, tree *);\n static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n-static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n-\t\t\t       bool *);\n+static tree gnat_to_gnu_subprog_type (Entity_Id, bool, bool, tree *);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);\n-static bool is_from_limited_with_of_main (Entity_Id);\n static tree change_qualified_type (tree, int);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (tree, Entity_Id);\n@@ -1127,10 +1165,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tif (definition && Present (Address_Clause (gnat_entity)))\n \t  {\n \t    const Node_Id gnat_clause = Address_Clause (gnat_entity);\n-\t    Node_Id gnat_expr = Expression (gnat_clause);\n+\t    Node_Id gnat_address = Expression (gnat_clause);\n \t    tree gnu_address\n \t      = present_gnu_tree (gnat_entity)\n-\t\t? get_gnu_tree (gnat_entity) : gnat_to_gnu (gnat_expr);\n+\t\t? get_gnu_tree (gnat_entity) : gnat_to_gnu (gnat_address);\n \n \t    save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n@@ -1144,7 +1182,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    used_by_ref = true;\n \t    const_flag\n \t      = (!Is_Public (gnat_entity)\n-\t\t || compile_time_known_address_p (gnat_expr));\n+\t\t || compile_time_known_address_p (gnat_address));\n \t    volatile_flag = false;\n \t    gnu_size = NULL_TREE;\n \n@@ -1453,7 +1491,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    && !optimize\n \t    && !flag_generate_lto)\n \t  {\n-\t    tree param = create_param_decl (gnu_entity_name, gnu_type, false);\n+\t    tree param = create_param_decl (gnu_entity_name, gnu_type);\n \t    gnat_pushdecl (param, gnat_entity);\n \t    SET_DECL_VALUE_EXPR (param, gnu_decl);\n \t    DECL_HAS_VALUE_EXPR_P (param) = 1;\n@@ -3769,6 +3807,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       break;\n \n     case E_Access_Subprogram_Type:\n+    case E_Anonymous_Access_Subprogram_Type:\n       /* Use the special descriptor type for dispatch tables if needed,\n \t that is to say for the Prim_Ptr of a-tags.ads and its clones.\n \t Note that we are only required to do so for static tables in\n@@ -3785,34 +3824,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n       /* ... fall through ... */\n \n-    case E_Anonymous_Access_Subprogram_Type:\n-      /* If we are not defining this entity, and we have incomplete\n-\t entities being processed above us, make a dummy type and\n-\t fill it in later.  */\n-      if (!definition && defer_incomplete_level != 0)\n-\t{\n-\t  struct incomplete *p = XNEW (struct incomplete);\n-\n-\t  gnu_type\n-\t    = build_pointer_type\n-\t      (make_dummy_type (Directly_Designated_Type (gnat_entity)));\n-\t  gnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n-\t\t\t\t       artificial_p, debug_info_p,\n-\t\t\t\t       gnat_entity);\n-\t  this_made_decl = true;\n-\t  gnu_type = TREE_TYPE (gnu_decl);\n-\t  save_gnu_tree (gnat_entity, gnu_decl, false);\n-\t  saved = true;\n-\n-\t  p->old_type = TREE_TYPE (gnu_type);\n-\t  p->full_type = Directly_Designated_Type (gnat_entity);\n-\t  p->next = defer_incomplete_list;\n-\t  defer_incomplete_list = p;\n-\t  break;\n-\t}\n-\n-      /* ... fall through ... */\n-\n     case E_Allocator_Type:\n     case E_Access_Type:\n     case E_Access_Attribute_Type:\n@@ -3823,7 +3834,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tEntity_Id gnat_desig_type = Directly_Designated_Type (gnat_entity);\n \tEntity_Id gnat_desig_equiv = Gigi_Equivalent_Type (gnat_desig_type);\n \t/* Whether it comes from a limited with.  */\n-\tbool is_from_limited_with\n+\tconst bool is_from_limited_with\n \t  = (IN (Ekind (gnat_desig_equiv), Incomplete_Kind)\n \t     && From_Limited_With (gnat_desig_equiv));\n \t/* The \"full view\" of the designated type.  If this is an incomplete\n@@ -3851,7 +3862,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tEntity_Id gnat_desig_rep;\n \t/* We want to know if we'll be seeing the freeze node for any\n \t   incomplete type we may be pointing to.  */\n-\tbool in_main_unit\n+\tconst bool in_main_unit\n \t  = (Present (gnat_desig_full)\n \t     ? In_Extended_Main_Code_Unit (gnat_desig_full)\n \t     : In_Extended_Main_Code_Unit (gnat_desig_type));\n@@ -3899,14 +3910,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  && Present (gnat_desig_full)\n \t\t  && (Is_Record_Type (gnat_desig_full)\n \t\t      || Is_Array_Type (gnat_desig_full)))\n-\t\t /* Likewise if we are pointing to a record or array and we are\n-\t\t    to defer elaborating incomplete types.  We do this as this\n-\t\t    access type may be the full view of a private type.  */\n+\t\t /* Likewise if this is a reference to a record, an array or a\n+\t\t    subprogram type and we are to defer elaborating incomplete\n+\t\t    types.  We do this because this access type may be the full\n+\t\t    view of a private type.  */\n \t\t || ((!in_main_unit || imported_p)\n \t\t     && defer_incomplete_level != 0\n \t\t     && !present_gnu_tree (gnat_desig_equiv)\n \t\t     && (Is_Record_Type (gnat_desig_rep)\n-\t\t\t || Is_Array_Type (gnat_desig_rep)))\n+\t\t\t || Is_Array_Type (gnat_desig_rep)\n+\t\t\t || Ekind (gnat_desig_rep) == E_Subprogram_Type))\n \t\t /* If this is a reference from a limited_with type back to our\n \t\t    main unit and there's a freeze node for it, either we have\n \t\t    already processed the declaration and made the dummy type,\n@@ -3950,77 +3963,44 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    break;\n \t  }\n \n-\t/* For an unconstrained array, make dummy fat & thin pointer types.  */\n+\t/* Access-to-unconstrained-array types need a special treatment.  */\n \tif (Is_Array_Type (gnat_desig_rep) && !Is_Constrained (gnat_desig_rep))\n \t  {\n \t    /* If the processing above got something that has a pointer, then\n \t       we are done.  This could have happened either because the type\n \t       was elaborated or because somebody else executed the code.  */\n \t    if (!TYPE_POINTER_TO (gnu_desig_type))\n \t      build_dummy_unc_pointer_types (gnat_desig_equiv, gnu_desig_type);\n+\n \t    gnu_type = TYPE_POINTER_TO (gnu_desig_type);\n \t  }\n \n \t/* If we haven't done it yet, build the pointer type the usual way.  */\n \telse if (!gnu_type)\n \t  {\n \t    /* Modify the designated type if we are pointing only to constant\n-\t       objects, but don't do it for unconstrained arrays.  */\n+\t       objects, but don't do it for a dummy type.  */\n \t    if (Is_Access_Constant (gnat_entity)\n-\t\t&& TREE_CODE (gnu_desig_type) != UNCONSTRAINED_ARRAY_TYPE)\n-\t      {\n-\t\tgnu_desig_type\n-\t\t  = change_qualified_type (gnu_desig_type, TYPE_QUAL_CONST);\n-\n-\t\t/* Some extra processing is required if we are building a\n-\t\t   pointer to an incomplete type (in the GCC sense).  We might\n-\t\t   have such a type if we just made a dummy, or directly out\n-\t\t   of the call to gnat_to_gnu_type above if we are processing\n-\t\t   an access type for a record component designating the\n-\t\t   record type itself.  */\n-\t\tif (TYPE_MODE (gnu_desig_type) == VOIDmode)\n-\t\t  {\n-\t\t    /* We must ensure that the pointer to variant we make will\n-\t\t       be processed by update_pointer_to when the initial type\n-\t\t       is completed.  Pretend we made a dummy and let further\n-\t\t       processing act as usual.  */\n-\t\t    made_dummy = true;\n-\n-\t\t    /* We must ensure that update_pointer_to will not retrieve\n-\t\t       the dummy variant when building a properly qualified\n-\t\t       version of the complete type.  We take advantage of the\n-\t\t       fact that get_qualified_type is requiring TYPE_NAMEs to\n-\t\t       match to influence build_qualified_type and then also\n-\t\t       update_pointer_to here.  */\n-\t\t    TYPE_NAME (gnu_desig_type)\n-\t\t      = create_concat_name (gnat_desig_type, \"INCOMPLETE_CST\");\n-\t\t  }\n-\t      }\n+\t\t&& !TYPE_IS_DUMMY_P (gnu_desig_type))\n+\t      gnu_desig_type\n+\t\t= change_qualified_type (gnu_desig_type, TYPE_QUAL_CONST);\n \n \t    gnu_type\n \t      = build_pointer_type_for_mode (gnu_desig_type, p_mode,\n \t\t\t\t\t     No_Strict_Aliasing (gnat_entity));\n \t  }\n \n-\t/* If we are not defining this object and we have made a dummy pointer,\n-\t   save our current definition, evaluate the actual type, and replace\n-\t   the tentative type we made with the actual one.  If we are to defer\n-\t   actually looking up the actual type, make an entry in the deferred\n-\t   list.  If this is from a limited with, we may have to defer to the\n-\t   end of the current unit.  */\n-\tif ((!in_main_unit || is_from_limited_with) && made_dummy)\n+\t/* If the designated type is not declared in the main unit and we made\n+\t   a dummy node for it, save our definition, elaborate the actual type\n+\t   and replace the dummy type we made with the actual one.  But if we\n+\t   are to defer actually looking up the actual type, make an entry in\n+\t   the deferred list instead.  If this is from a limited with, we may\n+\t   have to defer until the end of the current unit.  */\n+\tif (!in_main_unit && made_dummy)\n \t  {\n-\t    tree gnu_old_desig_type;\n-\n-\t    if (TYPE_IS_FAT_POINTER_P (gnu_type))\n-\t      {\n-\t\tgnu_old_desig_type = TYPE_UNCONSTRAINED_ARRAY (gnu_type);\n-\t\tif (esize == POINTER_SIZE)\n-\t\t  gnu_type = build_pointer_type\n-\t\t\t     (TYPE_OBJECT_RECORD_TYPE (gnu_old_desig_type));\n-\t      }\n-\t    else\n-\t      gnu_old_desig_type = TREE_TYPE (gnu_type);\n+\t    if (TYPE_IS_FAT_POINTER_P (gnu_type) && esize == POINTER_SIZE)\n+\t      gnu_type\n+\t\t= build_pointer_type (TYPE_OBJECT_RECORD_TYPE (gnu_desig_type));\n \n \t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \t    gnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n@@ -4031,29 +4011,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    save_gnu_tree (gnat_entity, gnu_decl, false);\n \t    saved = true;\n \n-\t    /* Note that the call to gnat_to_gnu_type on gnat_desig_equiv might\n-\t       update gnu_old_desig_type directly, in which case it will not be\n-\t       a dummy type any more when we get into update_pointer_to.\n-\n-\t       This can happen e.g. when the designated type is a record type,\n-\t       because their elaboration starts with an initial node from\n-\t       make_dummy_type, which may be the same node as the one we got.\n-\n-\t       Besides, variants of this non-dummy type might have been created\n-\t       along the way.  update_pointer_to is expected to properly take\n-\t       care of those situations.  */\n \t    if (defer_incomplete_level == 0 && !is_from_limited_with)\n \t      {\n-\t\tupdate_pointer_to (TYPE_MAIN_VARIANT (gnu_old_desig_type),\n+\t\tupdate_pointer_to (TYPE_MAIN_VARIANT (gnu_desig_type),\n \t\t\t\t   gnat_to_gnu_type (gnat_desig_equiv));\n \t      }\n \t    else\n \t      {\n \t\tstruct incomplete *p = XNEW (struct incomplete);\n \t\tstruct incomplete **head\n \t\t  = (is_from_limited_with\n-\t\t     ? &defer_limited_with : &defer_incomplete_list);\n-\t\tp->old_type = gnu_old_desig_type;\n+\t\t     ? &defer_limited_with_list : &defer_incomplete_list);\n+\n+\t\tp->old_type = gnu_desig_type;\n \t\tp->full_type = gnat_desig_equiv;\n \t\tp->next = *head;\n \t\t*head = p;\n@@ -4064,15 +4034,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n     case E_Access_Protected_Subprogram_Type:\n     case E_Anonymous_Access_Protected_Subprogram_Type:\n+      /* The run-time representation is the equivalent type.  */\n       if (type_annotate_only && No (gnat_equiv_type))\n \tgnu_type = ptr_type_node;\n       else\n \t{\n-\t  /* The run-time representation is the equivalent type.  */\n \t  gnu_type = gnat_to_gnu_type (gnat_equiv_type);\n \t  maybe_present = true;\n \t}\n \n+      /* The designated subtype must be elaborated as well, if it does\n+\t not have its own freeze node.  */\n       if (Is_Itype (Directly_Designated_Type (gnat_entity))\n \t  && !present_gnu_tree (Directly_Designated_Type (gnat_entity))\n \t  && No (Freeze_Node (Directly_Designated_Type (gnat_entity)))\n@@ -4083,29 +4055,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       break;\n \n     case E_Access_Subtype:\n-\n       /* We treat this as identical to its base type; any constraint is\n-\t meaningful only to the front-end.\n+\t meaningful only to the front-end.  */\n+      gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n \n-\t The designated type must be elaborated as well, if it does\n-\t not have its own freeze node.  Designated (sub)types created\n+      /* The designated subtype must be elaborated as well, if it does\n+\t not have its own freeze node.  But designated subtypes created\n \t for constrained components of records with discriminants are\n-\t not frozen by the front-end and thus not elaborated by gigi,\n-\t because their use may appear before the base type is frozen,\n-\t and because it is not clear that they are needed anywhere in\n-\t gigi.  With the current model, there is no correct place where\n-\t they could be elaborated.  */\n-\n-      gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n+\t not frozen by the front-end and not elaborated here, because\n+\t their use may appear before the base type is frozen and it is\n+\t not clear that they are needed in gigi.  With the current model,\n+\t there is no correct place where they could be elaborated.  */\n       if (Is_Itype (Directly_Designated_Type (gnat_entity))\n \t  && !present_gnu_tree (Directly_Designated_Type (gnat_entity))\n \t  && Is_Frozen (Directly_Designated_Type (gnat_entity))\n \t  && No (Freeze_Node (Directly_Designated_Type (gnat_entity))))\n \t{\n-\t  /* If we are not defining this entity, and we have incomplete\n-\t     entities being processed above us, make a dummy type and\n-\t     elaborate it later.  */\n-\t  if (!definition && defer_incomplete_level != 0)\n+\t  /* If we are to defer elaborating incomplete types, make a dummy\n+\t     type node and elaborate it later.  */\n+\t  if (defer_incomplete_level != 0)\n \t    {\n \t      struct incomplete *p = XNEW (struct incomplete);\n \n@@ -4169,31 +4137,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n     case E_Function:\n     case E_Procedure:\n       {\n-\t/* The type returned by a function or else Standard_Void_Type for a\n-\t   procedure.  */\n-\tEntity_Id gnat_return_type = Etype (gnat_entity);\n-\ttree gnu_return_type;\n-\t/* The first GCC parameter declaration (a PARM_DECL node).  The\n-\t   PARM_DECL nodes are chained through the DECL_CHAIN field, so this\n-\t   actually is the head of this parameter list.  */\n-\ttree gnu_param_list = NULL_TREE;\n-\t/* Non-null for subprograms containing parameters passed by copy-in\n-\t   copy-out (Ada In Out or Out parameters not passed by reference),\n-\t   in which case it is the list of nodes used to specify the values\n-\t   of the In Out/Out parameters that are returned as a record upon\n-\t   procedure return.  The TREE_PURPOSE of an element of this list is\n-\t   a field of the record and the TREE_VALUE is the PARM_DECL\n-\t   corresponding to that field.  This list will be saved in the\n-\t   TYPE_CI_CO_LIST field of the FUNCTION_TYPE node we create.  */\n-\ttree gnu_cico_list = NULL_TREE;\n-\t/* List of fields in return type of procedure with copy-in copy-out\n-\t   parameters.  */\n-\ttree gnu_field_list = NULL_TREE;\n-\t/* If an import pragma asks to map this subprogram to a GCC builtin,\n-\t   this is the builtin DECL node.  */\n-\ttree gnu_builtin_decl = NULL_TREE;\n \ttree gnu_ext_name = create_concat_name (gnat_entity, NULL);\n-\tEntity_Id gnat_param;\n \tenum inline_status_t inline_status\n \t  = Has_Pragma_No_Inline (gnat_entity)\n \t    ? is_suppressed\n@@ -4208,20 +4152,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t     || imported_p\n \t     || (Convention (gnat_entity) == Convention_Intrinsic\n \t\t && Has_Pragma_Inline_Always (gnat_entity)));\n-       /* The semantics of \"pure\" in Ada essentially matches that of \"const\"\n-          in the back-end.  In particular, both properties are orthogonal to\n-          the \"nothrow\" property if the EH circuitry is explicit in the\n-          internal representation of the back-end.  If we are to completely\n-          hide the EH circuitry from it, we need to declare that calls to pure\n-          Ada subprograms that can throw have side effects since they can\n-          trigger an \"abnormal\" transfer of control flow; thus they can be\n-          neither \"const\" nor \"pure\" in the back-end sense.  */\n-\tbool const_flag = (Back_End_Exceptions () && Is_Pure (gnat_entity));\n-\tbool volatile_flag = No_Return (gnat_entity);\n-\tbool return_by_direct_ref_p = false;\n-\tbool return_by_invisi_ref_p = false;\n-\tbool return_unconstrained_p = false;\n-\tint parmnum;\n+\ttree gnu_param_list;\n \n \t/* A parameter may refer to this type, so defer completion of any\n \t   incomplete types.  */\n@@ -4283,345 +4214,53 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    break;\n \t  }\n \n+\t/* Get the GCC tree for the (underlying) subprogram type.  If the\n+\t   entity is an actual subprogram, also get the parameter list.  */\n+\tgnu_type\n+\t  = gnat_to_gnu_subprog_type (gnat_entity, definition, debug_info_p,\n+\t\t\t\t      &gnu_param_list);\n+\n \t/* If this subprogram is expectedly bound to a GCC builtin, fetch the\n-\t   corresponding DECL node.  Proper generation of calls later on need\n-\t   proper parameter associations so we don't \"break;\" here.  */\n+\t   corresponding DECL node and check the parameter association.  */\n \tif (Convention (gnat_entity) == Convention_Intrinsic\n \t    && Present (Interface_Name (gnat_entity)))\n \t  {\n-\t    gnu_builtin_decl = builtin_decl_for (gnu_ext_name);\n-\n-\t    /* Inability to find the builtin decl most often indicates a\n-\t       genuine mistake, but imports of unregistered intrinsics are\n-\t       sometimes issued on purpose to allow hooking in alternate\n-\t       bodies.  We post a warning conditioned on Wshadow in this case,\n-\t       to let developers be notified on demand without risking false\n-\t       positives with common default sets of options.  */\n-\n-\t    if (!gnu_builtin_decl && warn_shadow)\n-\t      post_error (\"?gcc intrinsic not found for&!\", gnat_entity);\n-\t  }\n-\n-\t/* ??? What if we don't find the builtin node above ? warn ? err ?\n-\t   In the current state we neither warn nor err, and calls will just\n-\t   be handled as for regular subprograms.  */\n-\n-\t/* Look into the return type and get its associated GCC tree.  If it\n-\t   is not void, compute various flags for the subprogram type.  */\n-\tif (Ekind (gnat_return_type) == E_Void)\n-\t  gnu_return_type = void_type_node;\n-\telse\n-\t  {\n-\t    /* Ada 2012 (AI05-0151): Incomplete types coming from a limited\n-\t       context may now appear in parameter and result profiles.  If\n-\t       we are only annotating types, break circularities here.  */\n-\t    if (type_annotate_only\n-\t        && is_from_limited_with_of_main (gnat_return_type))\n-\t      gnu_return_type = void_type_node;\n-\t    else\n-\t      gnu_return_type = gnat_to_gnu_type (gnat_return_type);\n-\n-\t    /* If this function returns by reference, make the actual return\n-\t       type the pointer type and make a note of that.  */\n-\t    if (Returns_By_Ref (gnat_entity))\n-\t      {\n-\t\tgnu_return_type = build_reference_type (gnu_return_type);\n-\t\treturn_by_direct_ref_p = true;\n-\t      }\n-\n-\t    /* If the return type is an unconstrained array type, the return\n-\t       value will be allocated on the secondary stack so the actual\n-\t       return type is the fat pointer type.  */\n-\t    else if (TREE_CODE (gnu_return_type) == UNCONSTRAINED_ARRAY_TYPE)\n-\t      {\n-\t\tgnu_return_type = TREE_TYPE (gnu_return_type);\n-\t\treturn_unconstrained_p = true;\n-\t      }\n-\n-\t    /* Likewise, if the return type requires a transient scope, the\n-\t       return value will also be allocated on the secondary stack so\n-\t       the actual return type is the pointer type.  */\n-\t    else if (Requires_Transient_Scope (gnat_return_type))\n-\t      {\n-\t\tgnu_return_type = build_reference_type (gnu_return_type);\n-\t\treturn_unconstrained_p = true;\n-\t      }\n-\n-\t    /* If the Mechanism is By_Reference, ensure this function uses the\n-\t       target's by-invisible-reference mechanism, which may not be the\n-\t       same as above (e.g. it might be passing an extra parameter).  */\n-\t    else if (kind == E_Function\n-\t\t     && Mechanism (gnat_entity) == By_Reference)\n-\t      return_by_invisi_ref_p = true;\n-\n-\t    /* Likewise, if the return type is itself By_Reference.  */\n-\t    else if (TYPE_IS_BY_REFERENCE_P (gnu_return_type))\n-\t      return_by_invisi_ref_p = true;\n-\n-\t    /* If the type is a padded type and the underlying type would not\n-\t       be passed by reference or the function has a foreign convention,\n-\t       return the underlying type.  */\n-\t    else if (TYPE_IS_PADDING_P (gnu_return_type)\n-\t\t     && (!default_pass_by_ref\n-\t\t\t  (TREE_TYPE (TYPE_FIELDS (gnu_return_type)))\n-\t\t\t || Has_Foreign_Convention (gnat_entity)))\n-\t      gnu_return_type = TREE_TYPE (TYPE_FIELDS (gnu_return_type));\n-\n-\t    /* If the return type is unconstrained, that means it must have a\n-\t       maximum size.  Use the padded type as the effective return type.\n-\t       And ensure the function uses the target's by-invisible-reference\n-\t       mechanism to avoid copying too much data when it returns.  */\n-\t    if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_return_type)))\n-\t      {\n-\t\ttree orig_type = gnu_return_type;\n-\t\ttree max_return_size\n-\t\t  = max_size (TYPE_SIZE (gnu_return_type), true);\n-\n-\t\t/* If the size overflows to 0, set it to an arbitrary positive\n-\t\t   value so that assignments in the type are preserved.  Their\n-\t\t   actual size is independent of this positive value.  */\n-\t\tif (TREE_CODE (max_return_size) == INTEGER_CST\n-\t\t    && TREE_OVERFLOW (max_return_size)\n-\t\t    && integer_zerop (max_return_size))\n-\t\t  {\n-\t\t    max_return_size = copy_node (bitsize_unit_node);\n-\t\t    TREE_OVERFLOW (max_return_size) = 1;\n-\t\t  }\n+\t    tree gnu_builtin_decl = builtin_decl_for (gnu_ext_name);\n \n-\t\tgnu_return_type\n-\t\t  = maybe_pad_type (gnu_return_type, max_return_size, 0,\n-\t\t\t\t    gnat_entity, false, false, definition,\n-\t\t\t\t    true);\n-\n-\t\t/* Declare it now since it will never be declared otherwise.\n-\t\t   This is necessary to ensure that its subtrees are properly\n-\t\t   marked.  */\n-\t\tif (gnu_return_type != orig_type\n-\t\t    && !DECL_P (TYPE_NAME (gnu_return_type)))\n-\t\t  create_type_decl (TYPE_NAME (gnu_return_type),\n-\t\t\t\t    gnu_return_type, true, debug_info_p,\n-\t\t\t\t    gnat_entity);\n-\n-\t\treturn_by_invisi_ref_p = true;\n-\t      }\n-\n-\t    /* If the return type has a size that overflows, we cannot have\n-\t       a function that returns that type.  This usage doesn't make\n-\t       sense anyway, so give an error here.  */\n-\t    if (!return_by_invisi_ref_p\n-\t\t&& TYPE_SIZE_UNIT (gnu_return_type)\n-\t\t&& TREE_CODE (TYPE_SIZE_UNIT (gnu_return_type)) == INTEGER_CST\n-\t\t&& !valid_constant_size_p (TYPE_SIZE_UNIT (gnu_return_type)))\n-\t      {\n-\t\tpost_error (\"cannot return type whose size overflows\",\n-\t\t\t    gnat_entity);\n-\t\tgnu_return_type = copy_type (gnu_return_type);\n-\t\tTYPE_SIZE (gnu_return_type) = bitsize_zero_node;\n-\t\tTYPE_SIZE_UNIT (gnu_return_type) = size_zero_node;\n-\t      }\n-\t  }\n-\n-\t/* Loop over the parameters and get their associated GCC tree.  While\n-\t   doing this, build a copy-in copy-out structure if we need one.  */\n-\tfor (gnat_param = First_Formal_With_Extras (gnat_entity), parmnum = 0;\n-\t     Present (gnat_param);\n-\t     gnat_param = Next_Formal_With_Extras (gnat_param), parmnum++)\n-\t  {\n-\t    Entity_Id gnat_param_type = Etype (gnat_param);\n-\t    tree gnu_param_name = get_entity_name (gnat_param);\n-\t    tree gnu_param_type, gnu_param, gnu_field;\n-\t    Mechanism_Type mech = Mechanism (gnat_param);\n-  \t    bool copy_in_copy_out = false, fake_param_type;\n-\n-\t    /* Ada 2012 (AI05-0151): Incomplete types coming from a limited\n-\t       context may now appear in parameter and result profiles.  If\n-\t       we are only annotating types, break circularities here.  */\n-\t    if (type_annotate_only\n-\t        && is_from_limited_with_of_main (gnat_param_type))\n-\t      {\n-\t\tgnu_param_type = void_type_node;\n-\t\tfake_param_type = true;\n-\t      }\n-\t    else\n-\t      {\n-\t\tgnu_param_type = gnat_to_gnu_type (gnat_param_type);\n-\t\tfake_param_type = false;\n-\t      }\n-\n-\t    /* Builtins are expanded inline and there is no real call sequence\n-\t       involved.  So the type expected by the underlying expander is\n-\t       always the type of each argument \"as is\".  */\n+\t    /* If we have a builtin DECL for that function, use it.  Check if\n+\t       the profiles are compatible and warn if they are not.  Note that\n+\t       the checker is expected to post diagnostics in this case.  */\n \t    if (gnu_builtin_decl)\n-\t      mech = By_Copy;\n-\t    /* Handle the first parameter of a valued procedure specially.  */\n-\t    else if (Is_Valued_Procedure (gnat_entity) && parmnum == 0)\n-\t      mech = By_Copy_Return;\n-\t    /* Otherwise, see if a Mechanism was supplied that forced this\n-\t       parameter to be passed one way or another.  */\n-\t    else if (mech == Default\n-\t\t     || mech == By_Copy\n-\t\t     || mech == By_Reference)\n-\t      ;\n-\t    else if (mech > 0)\n-\t      {\n-\t\tif (TREE_CODE (gnu_param_type) == UNCONSTRAINED_ARRAY_TYPE\n-\t\t    || TREE_CODE (TYPE_SIZE (gnu_param_type)) != INTEGER_CST\n-\t\t    || 0 < compare_tree_int (TYPE_SIZE (gnu_param_type),\n-\t\t\t\t\t     mech))\n-\t\t  mech = By_Reference;\n-\t\telse\n-\t\t  mech = By_Copy;\n-\t      }\n-\t    else\n-\t      {\n-\t\tpost_error (\"unsupported mechanism for&\", gnat_param);\n-\t\tmech = Default;\n-\t      }\n-\n-\t    /* Do not call gnat_to_gnu_param for a fake parameter type since\n-\t       it will try to use the real type again.  */\n-\t    if (fake_param_type)\n-\t      {\n-\t\tif (Ekind (gnat_param) == E_Out_Parameter)\n-\t\t  gnu_param = NULL_TREE;\n-\t\telse\n-\t\t  {\n-\t\t    gnu_param\n-\t\t      = create_param_decl (gnu_param_name, gnu_param_type,\n-\t\t\t\t\t   false);\n-\t\t    Set_Mechanism (gnat_param,\n-\t\t\t\t   mech == Default ? By_Copy : mech);\n-\t\t    if (Ekind (gnat_param) == E_In_Out_Parameter)\n-\t\t      copy_in_copy_out = true;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      gnu_param\n-\t\t= gnat_to_gnu_param (gnat_param, mech, gnat_entity,\n-\t\t\t\t     Has_Foreign_Convention (gnat_entity),\n-\t\t\t\t     &copy_in_copy_out);\n-\n-\t    /* We are returned either a PARM_DECL or a type if no parameter\n-\t       needs to be passed; in either case, adjust the type.  */\n-\t    if (DECL_P (gnu_param))\n-\t      gnu_param_type = TREE_TYPE (gnu_param);\n-\t    else\n \t      {\n-\t\tgnu_param_type = gnu_param;\n-\t\tgnu_param = NULL_TREE;\n-\t      }\n+\t\tintrin_binding_t inb\n+\t\t  = { gnat_entity, gnu_type, TREE_TYPE (gnu_builtin_decl) };\n \n-\t    /* The failure of this assertion will very likely come from an\n-\t       order of elaboration issue for the type of the parameter.  */\n-\t    gcc_assert (kind == E_Subprogram_Type\n-\t\t\t|| !TYPE_IS_DUMMY_P (gnu_param_type)\n-\t\t\t|| type_annotate_only);\n+\t\tif (!intrin_profiles_compatible_p (&inb))\n+\t\t  post_error\n+\t\t    (\"?profile of& doesn''t match the builtin it binds!\",\n+\t\t     gnat_entity);\n \n-\t    if (gnu_param)\n-\t      {\n-\t\tgnu_param_list = chainon (gnu_param, gnu_param_list);\n-\t\tSloc_to_locus (Sloc (gnat_param),\n-\t\t\t       &DECL_SOURCE_LOCATION (gnu_param));\n-\t\tsave_gnu_tree (gnat_param, gnu_param, false);\n-\n-\t\t/* If a parameter is a pointer, this function may modify\n-\t\t   memory through it and thus shouldn't be considered\n-\t\t   a const function.  Also, the memory may be modified\n-\t\t   between two calls, so they can't be CSE'ed.  The latter\n-\t\t   case also handles by-ref parameters.  */\n-\t\tif (POINTER_TYPE_P (gnu_param_type)\n-\t\t    || TYPE_IS_FAT_POINTER_P (gnu_param_type))\n-\t\t  const_flag = false;\n+\t\tgnu_decl = gnu_builtin_decl;\n+\t\tgnu_type = TREE_TYPE (gnu_builtin_decl);\n+\t\tbreak;\n \t      }\n \n-\t    if (copy_in_copy_out)\n-\t      {\n-\t\tif (!gnu_cico_list)\n-\t\t  {\n-\t\t    tree gnu_new_ret_type = make_node (RECORD_TYPE);\n-\n-\t\t    /* If this is a function, we also need a field for the\n-\t\t       return value to be placed.  */\n-\t\t    if (TREE_CODE (gnu_return_type) != VOID_TYPE)\n-\t\t      {\n-\t\t\tgnu_field\n-\t\t\t  = create_field_decl (get_identifier (\"RETVAL\"),\n-\t\t\t\t\t       gnu_return_type,\n-\t\t\t\t\t       gnu_new_ret_type, NULL_TREE,\n-\t\t\t\t\t       NULL_TREE, 0, 0);\n-\t\t\tSloc_to_locus (Sloc (gnat_entity),\n-\t\t\t\t       &DECL_SOURCE_LOCATION (gnu_field));\n-\t\t\tgnu_field_list = gnu_field;\n-\t\t\tgnu_cico_list\n-\t\t\t  = tree_cons (gnu_field, void_type_node, NULL_TREE);\n-\t\t      }\n-\n-\t\t    gnu_return_type = gnu_new_ret_type;\n-\t\t    TYPE_NAME (gnu_return_type) = get_identifier (\"RETURN\");\n-\t\t    /* Set a default alignment to speed up accesses.  But we\n-\t\t       shouldn't increase the size of the structure too much,\n-\t\t       lest it doesn't fit in return registers anymore.  */\n-\t\t    SET_TYPE_ALIGN (gnu_return_type,\n-\t\t\t\t    get_mode_alignment (ptr_mode));\n-\t\t  }\n-\n-\t\tgnu_field\n-\t\t  = create_field_decl (gnu_param_name, gnu_param_type,\n-\t\t\t\t       gnu_return_type, NULL_TREE, NULL_TREE,\n-\t\t\t\t       0, 0);\n-\t\tSloc_to_locus (Sloc (gnat_param),\n-\t\t\t       &DECL_SOURCE_LOCATION (gnu_field));\n-\t\tDECL_CHAIN (gnu_field) = gnu_field_list;\n-\t\tgnu_field_list = gnu_field;\n-\t\tgnu_cico_list\n-\t\t  = tree_cons (gnu_field, gnu_param, gnu_cico_list);\n-\t      }\n+\t    /* Inability to find the builtin DECL most often indicates a\n+\t       genuine mistake, but imports of unregistered intrinsics are\n+\t       sometimes issued on purpose to allow hooking in alternate\n+\t       bodies.  We post a warning conditioned on Wshadow in this case,\n+\t       to let developers be notified on demand without risking false\n+\t       positives with common default sets of options.  */\n+\t    else if (warn_shadow)\n+\t      post_error (\"?gcc intrinsic not found for&!\", gnat_entity);\n \t  }\n \n-\tif (gnu_cico_list)\n-\t  {\n-\t    /* If we have a CICO list but it has only one entry, we convert\n-\t       this function into a function that returns this object.  */\n-\t    if (list_length (gnu_cico_list) == 1)\n-\t      gnu_return_type = TREE_TYPE (TREE_PURPOSE (gnu_cico_list));\n-\n-\t    /* Do not finalize the return type if the subprogram is stubbed\n-\t       since structures are incomplete for the back-end.  */\n-\t    else if (Convention (gnat_entity) != Convention_Stubbed)\n-\t      {\n-\t\tfinish_record_type (gnu_return_type, nreverse (gnu_field_list),\n-\t\t\t\t    0, false);\n-\n-\t        /* Try to promote the mode of the return type if it is passed\n-\t\t   in registers, again to speed up accesses.  */\n-\t\tif (TYPE_MODE (gnu_return_type) == BLKmode\n-\t\t    && !targetm.calls.return_in_memory (gnu_return_type,\n-\t\t\t\t\t\t\tNULL_TREE))\n-\t\t  {\n-\t\t    unsigned int size\n-\t\t      = TREE_INT_CST_LOW (TYPE_SIZE (gnu_return_type));\n-\t\t    unsigned int i = BITS_PER_UNIT;\n-\t\t    machine_mode mode;\n-\n-\t\t    while (i < size)\n-\t\t      i <<= 1;\n-\t\t    mode = mode_for_size (i, MODE_INT, 0);\n-\t\t    if (mode != BLKmode)\n-\t\t      {\n-\t\t\tSET_TYPE_MODE (gnu_return_type, mode);\n-\t\t\tSET_TYPE_ALIGN (gnu_return_type,\n-\t\t\t\t\tGET_MODE_ALIGNMENT (mode));\n-\t\t\tTYPE_SIZE (gnu_return_type)\n-\t\t\t  = bitsize_int (GET_MODE_BITSIZE (mode));\n-\t\t\tTYPE_SIZE_UNIT (gnu_return_type)\n-\t\t\t  = size_int (GET_MODE_SIZE (mode));\n-\t\t      }\n-\t\t  }\n-\n-\t        if (debug_info_p)\n-\t\t  rest_of_record_type_compilation (gnu_return_type);\n-\t      }\n-\t  }\n+\t/* If there was no specified Interface_Name and the external and\n+\t   internal names of the subprogram are the same, only use the\n+\t   internal name to allow disambiguation of nested subprograms.  */\n+\tif (No (Interface_Name (gnat_entity))\n+\t    && gnu_ext_name == gnu_entity_name)\n+\t  gnu_ext_name = NULL_TREE;\n \n \t/* Deal with platform-specific calling conventions.  */\n \tif (Has_Stdcall_Convention (gnat_entity))\n@@ -4651,59 +4290,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  prepend_one_attribute_pragma (&attr_list,\n \t\t\t\t\tLinker_Section_Pragma (gnat_entity));\n \n-\t/* The lists have been built in reverse.  */\n-\tgnu_param_list = nreverse (gnu_param_list);\n-\tgnu_cico_list = nreverse (gnu_cico_list);\n-\n-\tif (kind == E_Function)\n-\t  Set_Mechanism (gnat_entity, return_unconstrained_p\n-\t\t\t\t      || return_by_direct_ref_p\n-\t\t\t\t      || return_by_invisi_ref_p\n-\t\t\t\t      ? By_Reference : By_Copy);\n-\tgnu_type\n-\t  = create_subprog_type (gnu_return_type, gnu_param_list,\n-\t\t\t\t gnu_cico_list, return_unconstrained_p,\n-\t\t\t\t return_by_direct_ref_p,\n-\t\t\t\t return_by_invisi_ref_p);\n-\n-\t/* A procedure (something that doesn't return anything) shouldn't be\n-\t   considered const since there would be no reason for calling such a\n-\t   subprogram.  Note that procedures with Out (or In Out) parameters\n-\t   have already been converted into a function with a return type.\n-\t   Similarly, if the function returns an unconstrained type, then the\n-\t   function will allocate the return value on the secondary stack and\n-\t   thus calls to it cannot be CSE'ed, lest the stack be reclaimed.  */\n-\tif (TREE_CODE (gnu_return_type) == VOID_TYPE || return_unconstrained_p)\n-\t  const_flag = false;\n-\n-\t/* If we have a builtin decl for that function, use it.  Check if the\n-\t   profiles are compatible and warn if they are not.  The checker is\n-\t   expected to post extra diagnostics in this case.  */\n-\tif (gnu_builtin_decl)\n-\t  {\n-\t    intrin_binding_t inb;\n-\n-\t    inb.gnat_entity = gnat_entity;\n-\t    inb.ada_fntype = gnu_type;\n-\t    inb.btin_fntype = TREE_TYPE (gnu_builtin_decl);\n-\n-\t    if (!intrin_profiles_compatible_p (&inb))\n-\t      post_error\n-\t\t(\"?profile of& doesn''t match the builtin it binds!\",\n-\t\t gnat_entity);\n-\n-\t    gnu_decl = gnu_builtin_decl;\n-\t    gnu_type = TREE_TYPE (gnu_builtin_decl);\n-\t    break;\n-\t  }\n-\n-\t/* If there was no specified Interface_Name and the external and\n-\t   internal names of the subprogram are the same, only use the\n-\t   internal name to allow disambiguation of nested subprograms.  */\n-\tif (No (Interface_Name (gnat_entity))\n-\t    && gnu_ext_name == gnu_entity_name)\n-\t  gnu_ext_name = NULL_TREE;\n-\n \t/* If we are defining the subprogram and it has an Address clause\n \t   we must get the address expression from the saved GCC tree for the\n \t   subprogram if it has a Freeze_Node.  Otherwise, we elaborate\n@@ -4742,29 +4328,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  {\n \t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \n-\t    if (const_flag || volatile_flag)\n-\t      {\n-\t\tconst int quals\n-\t\t  = (const_flag ? TYPE_QUAL_CONST : 0)\n-\t\t     | (volatile_flag ? TYPE_QUAL_VOLATILE : 0);\n-\t\tgnu_type = change_qualified_type (gnu_type, quals);\n-\t      }\n-\n \t    gnu_decl\n \t      = create_type_decl (gnu_entity_name, gnu_type, artificial_p,\n \t\t\t\t  debug_info_p, gnat_entity);\n \t  }\n+\n \telse\n \t  {\n \t    gnu_decl\n \t      = create_subprog_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t     gnu_param_list, inline_status, const_flag,\n-\t\t\t\t     public_flag, extern_flag, volatile_flag,\n+\t\t\t\t     gnu_param_list, inline_status,\n+\t\t\t\t     public_flag, extern_flag,\n \t\t\t\t     artificial_p, debug_info_p,\n \t\t\t\t     attr_list, gnat_entity);\n-\t    /* This is unrelated to the stub built right above.  */\n+\n \t    DECL_STUBBED_P (gnu_decl)\n-\t      = Convention (gnat_entity) == Convention_Stubbed;\n+\t      = (Convention (gnat_entity) == Convention_Stubbed);\n \t  }\n       }\n       break;\n@@ -4778,14 +4357,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n     case E_Record_Type_With_Private:\n     case E_Record_Subtype_With_Private:\n       {\n-\tbool is_from_limited_with\n+\tconst bool is_from_limited_with\n \t  = (IN (kind, Incomplete_Kind) && From_Limited_With (gnat_entity));\n \t/* Get the \"full view\" of this entity.  If this is an incomplete\n \t   entity from a limited with, treat its non-limited view as the\n \t   full view.  Otherwise, use either the full view or the underlying\n \t   full view, whichever is present.  This is used in all the tests\n \t   below.  */\n-\tEntity_Id full_view\n+\tconst Entity_Id full_view\n \t  = is_from_limited_with\n \t    ? Non_Limited_View (gnat_entity)\n \t    : Present (Full_View (gnat_entity))\n@@ -4810,43 +4389,39 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, false);\n \t\tmaybe_present = true;\n \t      }\n-\t    break;\n \t  }\n \n-\t/* If we already made a type for the full view, reuse it.  */\n+\t/* Or else, if we already made a type for the full view, reuse it.  */\n \telse if (present_gnu_tree (full_view))\n-\t  {\n-\t    gnu_decl = get_gnu_tree (full_view);\n-\t    break;\n-\t  }\n+\t  gnu_decl = get_gnu_tree (full_view);\n \n-\t/* Otherwise, if we are not defining the type now, get the type\n-\t   from the full view.  But always get the type from the full view\n-\t   for define on use types, since otherwise we won't see them.\n-\t   Likewise if this is a non-limited view not declared in the main\n-\t   unit, which can happen for incomplete formal types instantiated\n-\t   on a type coming from a limited_with clause.  */\n+\t/* Or else, if we are not defining the type or there is no freeze\n+\t   node on it, get the type for the full view.  Likewise if this is\n+\t   a limited_with'ed type not declared in the main unit, which can\n+\t   happen for incomplete formal types instantiated on a type coming\n+\t   from a limited_with clause.  */\n \telse if (!definition\n-\t\t || (Is_Itype (full_view) && No (Freeze_Node (gnat_entity)))\n-\t\t || (Is_Itype (gnat_entity) && No (Freeze_Node (full_view)))\n+\t\t || No (Freeze_Node (full_view))\n \t\t || (is_from_limited_with\n \t\t     && !In_Extended_Main_Code_Unit (full_view)))\n \t  {\n \t    gnu_decl = gnat_to_gnu_entity (full_view, NULL_TREE, false);\n \t    maybe_present = true;\n-\t    break;\n \t  }\n \n-\t/* For incomplete types, make a dummy type entry which will be\n-\t   replaced later.  Save it as the full declaration's type so\n-\t   we can do any needed updates when we see it.  */\n-\tgnu_type = make_dummy_type (gnat_entity);\n-\tgnu_decl = TYPE_STUB_DECL (gnu_type);\n-\tif (Has_Completion_In_Body (gnat_entity))\n-\t  DECL_TAFT_TYPE_P (gnu_decl) = 1;\n-\tsave_gnu_tree (full_view, gnu_decl, 0);\n-\tbreak;\n+\t/* Otherwise, make a dummy type entry which will be replaced later.\n+\t   Save it as the full declaration's type so we can do any needed\n+\t   updates when we see it.  */\n+\telse\n+\t  {\n+\t    gnu_type = make_dummy_type (gnat_entity);\n+\t    gnu_decl = TYPE_STUB_DECL (gnu_type);\n+\t    if (Has_Completion_In_Body (gnat_entity))\n+\t      DECL_TAFT_TYPE_P (gnu_decl) = 1;\n+\t    save_gnu_tree (full_view, gnu_decl, 0);\n+\t  }\n       }\n+      break;\n \n     case E_Class_Wide_Type:\n       /* Class-wide types are always transformed into their root type.  */\n@@ -5171,7 +4746,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  if (Present (Alignment_Clause (gnat_entity)))\n \t    TYPE_USER_ALIGN (gnu_type) = 1;\n \n-\t  if (Universal_Aliasing (gnat_entity))\n+\t  if (Universal_Aliasing (gnat_entity) && !TYPE_IS_DUMMY_P (gnu_type))\n \t    TYPE_UNIVERSAL_ALIASING_P (gnu_type) = 1;\n \n \t  /* If it is passed by reference, force BLKmode to ensure that\n@@ -5456,7 +5031,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    p->old_type = NULL_TREE;\n \t  }\n \n-      for (p = defer_limited_with; p; p = p->next)\n+      for (p = defer_limited_with_list; p; p = p->next)\n \tif (p->old_type && Non_Limited_View (p->full_type) == gnat_entity)\n \t  {\n \t    update_pointer_to (TYPE_MAIN_VARIANT (p->old_type),\n@@ -5525,47 +5100,6 @@ get_unpadded_type (Entity_Id gnat_entity)\n   return type;\n }\n \n-/* Return the DECL associated with the public subprogram GNAT_ENTITY but whose\n-   type has been changed to that of the parameterless procedure, except if an\n-   alias is already present, in which case it is returned instead.  */\n-\n-tree\n-get_minimal_subprog_decl (Entity_Id gnat_entity)\n-{\n-  tree gnu_entity_name, gnu_ext_name;\n-  struct attrib *attr_list = NULL;\n-\n-  /* See the E_Function/E_Procedure case of gnat_to_gnu_entity for the model\n-     of the handling applied here.  */\n-\n-  while (Present (Alias (gnat_entity)))\n-    {\n-      gnat_entity = Alias (gnat_entity);\n-      if (present_gnu_tree (gnat_entity))\n-\treturn get_gnu_tree (gnat_entity);\n-    }\n-\n-  gnu_entity_name = get_entity_name (gnat_entity);\n-  gnu_ext_name = create_concat_name (gnat_entity, NULL);\n-\n-  if (Has_Stdcall_Convention (gnat_entity))\n-    prepend_one_attribute (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n-\t\t\t   get_identifier (\"stdcall\"), NULL_TREE,\n-\t\t\t   gnat_entity);\n-  else if (Has_Thiscall_Convention (gnat_entity))\n-    prepend_one_attribute (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n-\t\t\t   get_identifier (\"thiscall\"), NULL_TREE,\n-\t\t\t   gnat_entity);\n-\n-  if (No (Interface_Name (gnat_entity)) && gnu_ext_name == gnu_entity_name)\n-    gnu_ext_name = NULL_TREE;\n-\n-  return\n-    create_subprog_decl (gnu_entity_name, gnu_ext_name, void_ftype, NULL_TREE,\n-\t\t\t is_disabled, false, true, true, false, true, false,\n-\t\t\t attr_list, gnat_entity);\n-}\n-\n /* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n    a C++ imported method or equivalent.\n \n@@ -5622,16 +5156,21 @@ finalize_from_limited_with (void)\n {\n   struct incomplete *p, *next;\n \n-  p = defer_limited_with;\n-  defer_limited_with = NULL;\n+  p = defer_limited_with_list;\n+  defer_limited_with_list = NULL;\n \n   for (; p; p = next)\n     {\n       next = p->next;\n \n       if (p->old_type)\n-\tupdate_pointer_to (TYPE_MAIN_VARIANT (p->old_type),\n-\t\t\t   gnat_to_gnu_type (p->full_type));\n+\t{\n+\t  update_pointer_to (TYPE_MAIN_VARIANT (p->old_type),\n+\t\t\t     gnat_to_gnu_type (p->full_type));\n+\t  if (TYPE_DUMMY_IN_PROFILE_P (p->old_type))\n+\t    update_profiles_with (p->old_type);\n+\t}\n+\n       free (p);\n     }\n }\n@@ -5786,22 +5325,24 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n   return gnu_type;\n }\n \n-/* Return a GCC tree for a parameter corresponding to GNAT_PARAM and\n-   using MECH as its passing mechanism, to be placed in the parameter\n-   list built for GNAT_SUBPROG.  Assume a foreign convention for the\n-   latter if FOREIGN is true.  Also set CICO to true if the parameter\n+/* Return a GCC tree for a parameter corresponding to GNAT_PARAM, to be placed\n+   in the parameter list built for GNAT_SUBPROG.  FIRST is true if GNAT_PARAM\n+   is the first parameter in the list.  Also set CICO to true if the parameter\n    must use the copy-in copy-out implementation mechanism.\n \n    The returned tree is a PARM_DECL, except for those cases where no\n    parameter needs to be actually passed to the subprogram; the type\n    of this \"shadow\" parameter is then returned instead.  */\n \n static tree\n-gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n-\t\t   Entity_Id gnat_subprog, bool foreign, bool *cico)\n+gnat_to_gnu_param (Entity_Id gnat_param, bool first, Entity_Id gnat_subprog,\n+\t\t   bool *cico)\n {\n+  Entity_Id gnat_param_type = Etype (gnat_param);\n+  Mechanism_Type mech = Mechanism (gnat_param);\n   tree gnu_param_name = get_entity_name (gnat_param);\n-  tree gnu_param_type = gnat_to_gnu_type (Etype (gnat_param));\n+  tree gnu_param_type = gnat_to_gnu_type (gnat_param_type);\n+  bool foreign = Has_Foreign_Convention (gnat_subprog);\n   bool in_param = (Ekind (gnat_param) == E_In_Parameter);\n   /* The parameter can be indirectly modified if its address is taken.  */\n   bool ro_param = in_param && !Address_Taken (gnat_param);\n@@ -5810,15 +5351,45 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   bool restricted_aliasing_p = false;\n   tree gnu_param;\n \n-  /* Copy-return is used only for the first parameter of a valued procedure.\n-     It's a copy mechanism for which a parameter is never allocated.  */\n-  if (mech == By_Copy_Return)\n+  /* Builtins are expanded inline and there is no real call sequence involved.\n+     So the type expected by the underlying expander is always the type of the\n+     argument \"as is\".  */\n+  if (Convention (gnat_subprog) == Convention_Intrinsic\n+      && Present (Interface_Name (gnat_subprog)))\n+    mech = By_Copy;\n+\n+  /* Handle the first parameter of a valued procedure specially: it's a copy\n+     mechanism for which the parameter is never allocated.  */\n+  else if (first && Is_Valued_Procedure (gnat_subprog))\n     {\n       gcc_assert (Ekind (gnat_param) == E_Out_Parameter);\n       mech = By_Copy;\n       by_return = true;\n     }\n \n+  /* Or else, see if a Mechanism was supplied that forced this parameter\n+     to be passed one way or another.  */\n+  else if (mech == Default || mech == By_Copy || mech == By_Reference)\n+    ;\n+\n+  /* Positive mechanism means by copy for sufficiently small parameters.  */\n+  else if (mech > 0)\n+    {\n+      if (TREE_CODE (gnu_param_type) == UNCONSTRAINED_ARRAY_TYPE\n+\t  || TREE_CODE (TYPE_SIZE (gnu_param_type)) != INTEGER_CST\n+\t  || compare_tree_int (TYPE_SIZE (gnu_param_type), mech) > 0)\n+\tmech = By_Reference;\n+      else\n+\tmech = By_Copy;\n+    }\n+\n+  /* Otherwise, it's an unsupported mechanism so error out.  */\n+  else\n+    {\n+      post_error (\"unsupported mechanism for&\", gnat_param);\n+      mech = Default;\n+    }\n+\n   /* If this is either a foreign function or if the underlying type won't\n      be passed by reference and is as aligned as the original type, strip\n      off possible padding type.  */\n@@ -5852,7 +5423,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   /* For GCC builtins, pass Address integer types as (void *)  */\n   if (Convention (gnat_subprog) == Convention_Intrinsic\n       && Present (Interface_Name (gnat_subprog))\n-      && Is_Descendant_Of_Address (Etype (gnat_param)))\n+      && Is_Descendant_Of_Address (gnat_param_type))\n     gnu_param_type = ptr_type_node;\n \n   /* Arrays are passed as pointers to element type for foreign conventions.  */\n@@ -5879,14 +5450,14 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n     gnu_param_type\n       = make_type_from_size (gnu_param_type, size_int (POINTER_SIZE), 0);\n \n-  /* If we must pass or were requested to pass by reference, do so.\n+  /* If we were requested or muss pass by reference, do so.\n      If we were requested to pass by copy, do so.\n      Otherwise, for foreign conventions, pass In Out or Out parameters\n      or aggregates by reference.  For COBOL and Fortran, pass all\n      integer and FP types that way too.  For Convention Ada, use\n      the standard Ada default.  */\n-  else if (must_pass_by_ref (gnu_param_type)\n-\t   || mech == By_Reference\n+  else if (mech == By_Reference\n+\t   || must_pass_by_ref (gnu_param_type)\n \t   || (mech != By_Copy\n \t       && ((foreign\n \t\t    && (!in_param || AGGREGATE_TYPE_P (gnu_param_type)))\n@@ -5898,12 +5469,12 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n \t\t   || (!foreign\n \t\t       && default_pass_by_ref (gnu_param_type)))))\n     {\n-      gnu_param_type = build_reference_type (gnu_param_type);\n       /* We take advantage of 6.2(12) by considering that references built for\n \t parameters whose type isn't by-ref and for which the mechanism hasn't\n \t been forced to by-ref allow only a restricted form of aliasing.  */\n       restricted_aliasing_p\n \t= !TYPE_IS_BY_REFERENCE_P (gnu_param_type) && mech != By_Reference;\n+      gnu_param_type = build_reference_type (gnu_param_type);\n       by_ref = true;\n     }\n \n@@ -5938,20 +5509,21 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n       && (by_return\n \t  || (!POINTER_TYPE_P (gnu_param_type)\n \t      && !AGGREGATE_TYPE_P (gnu_param_type)\n-\t      && !Has_Default_Aspect (Etype (gnat_param))))\n-      && !(Is_Array_Type (Etype (gnat_param))\n-\t   && Is_Packed (Etype (gnat_param))\n-\t   && Is_Composite_Type (Component_Type (Etype (gnat_param)))))\n+\t      && !Has_Default_Aspect (gnat_param_type)))\n+      && !(Is_Array_Type (gnat_param_type)\n+\t   && Is_Packed (gnat_param_type)\n+\t   && Is_Composite_Type (Component_Type (gnat_param_type))))\n     return gnu_param_type;\n \n-  gnu_param = create_param_decl (gnu_param_name, gnu_param_type,\n-\t\t\t\t ro_param || by_ref || by_component_ptr);\n+  gnu_param = create_param_decl (gnu_param_name, gnu_param_type);\n+  TREE_READONLY (gnu_param) = ro_param || by_ref || by_component_ptr;\n   DECL_BY_REF_P (gnu_param) = by_ref;\n   DECL_BY_COMPONENT_PTR_P (gnu_param) = by_component_ptr;\n   DECL_POINTS_TO_READONLY_P (gnu_param)\n     = (ro_param && (by_ref || by_component_ptr));\n   DECL_CAN_NEVER_BE_NULL_P (gnu_param) = Can_Never_Be_Null (gnat_param);\n   DECL_RESTRICTED_ALIASING_P (gnu_param) = restricted_aliasing_p;\n+  Sloc_to_locus (Sloc (gnat_param), &DECL_SOURCE_LOCATION (gnu_param));\n \n   /* If no Mechanism was specified, indicate what we're using, then\n      back-annotate it.  */\n@@ -5962,28 +5534,594 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   return gnu_param;\n }\n \n-/* Return true if GNAT_ENTITY is an incomplete entity coming from a limited\n-   with of the main unit and whose full view has not been elaborated yet.  */\n+/* Associate GNAT_SUBPROG with GNU_TYPE, which must be a dummy type, so that\n+   GNAT_SUBPROG is updated when TYPE is completed.  */\n \n-static bool\n-is_from_limited_with_of_main (Entity_Id gnat_entity)\n+static void\n+associate_subprog_with_dummy_type (Entity_Id gnat_subprog, tree gnu_type)\n {\n-  /* Class-wide types are always transformed into their root type.  */\n-  if (Ekind (gnat_entity) == E_Class_Wide_Type)\n-    gnat_entity = Root_Type (gnat_entity);\n+  gcc_assert (TYPE_IS_DUMMY_P (gnu_type));\n \n-  if (IN (Ekind (gnat_entity), Incomplete_Kind)\n-      && From_Limited_With (gnat_entity))\n+  struct tree_entity_vec_map in;\n+  in.base.from = gnu_type;\n+  struct tree_entity_vec_map **slot\n+    = dummy_to_subprog_map->find_slot (&in, INSERT);\n+  if (!*slot)\n     {\n-      Entity_Id gnat_full_view = Non_Limited_View (gnat_entity);\n+      tree_entity_vec_map *e = ggc_alloc<tree_entity_vec_map> ();\n+      e->base.from = gnu_type;\n+      e->to = NULL;\n+      *slot = e;\n+      TYPE_DUMMY_IN_PROFILE_P (gnu_type) = 1;\n+    }\n+  vec<Entity_Id, va_gc_atomic> *v = (*slot)->to;\n \n-      if (present_gnu_tree (gnat_full_view))\n-\treturn false;\n+  /* Make sure GNAT_SUBPROG is not associated twice with the same dummy type,\n+     since this would mean updating twice its profile.  */\n+  if (v)\n+    {\n+      const unsigned len = v->length ();\n+      unsigned int l = 0, u = len;\n+\n+      /* Entity_Id is a simple integer so we can implement a stable order on\n+\t the vector with an ordered insertion scheme and binary search.  */\n+      while (l < u)\n+\t{\n+\t  unsigned int m = (l + u) / 2;\n+\t  int diff = (int) (*v)[m] - (int) gnat_subprog;\n+\t  if (diff > 0)\n+\t    u = m;\n+\t  else if (diff < 0)\n+\t    l = m + 1;\n+\t  else\n+\t    return;\n+\t}\n \n-      return In_Extended_Main_Code_Unit (gnat_full_view);\n+      /* l == u and therefore is the insertion point.  */\n+      vec_safe_insert (v, l, gnat_subprog);\n     }\n+  else\n+    vec_safe_push (v, gnat_subprog);\n \n-  return false;\n+  (*slot)->to = v;\n+}\n+\n+/* Update the GCC tree previously built for the profile of GNAT_SUBPROG.  */\n+\n+static void\n+update_profile (Entity_Id gnat_subprog)\n+{\n+  tree gnu_param_list;\n+  tree gnu_type = gnat_to_gnu_subprog_type (gnat_subprog, true,\n+\t\t\t\t\t    Needs_Debug_Info (gnat_subprog),\n+\t\t\t\t\t    &gnu_param_list);\n+  tree gnu_subprog = get_gnu_tree (gnat_subprog);\n+\n+  TREE_TYPE (gnu_subprog) = gnu_type;\n+\n+  /* If GNAT_SUBPROG is an actual subprogram, GNU_SUBPROG is a FUNCTION_DECL\n+     and needs to be adjusted too.  */\n+  if (Ekind (gnat_subprog) != E_Subprogram_Type)\n+    {\n+      DECL_ARGUMENTS (gnu_subprog) = gnu_param_list;\n+      finish_subprog_decl (gnu_subprog, gnu_type);\n+    }\n+}\n+\n+/* Update the GCC trees previously built for the profiles involving GNU_TYPE,\n+   a dummy type which appears in profiles.  */\n+\n+void\n+update_profiles_with (tree gnu_type)\n+{\n+  struct tree_entity_vec_map in;\n+  in.base.from = gnu_type;\n+  struct tree_entity_vec_map *e = dummy_to_subprog_map->find (&in);\n+  gcc_assert (e);\n+  vec<Entity_Id, va_gc_atomic> *v = e->to;\n+  e->to = NULL;\n+  TYPE_DUMMY_IN_PROFILE_P (gnu_type) = 0;\n+\n+  unsigned int i;\n+  Entity_Id *iter;\n+  FOR_EACH_VEC_ELT (*v, i, iter)\n+    update_profile (*iter);\n+\n+  vec_free (v);\n+}\n+\n+/* Return the GCC tree for GNAT_TYPE present in the profile of a subprogram.\n+\n+   Ada 2012 (AI05-0151) says that incomplete types coming from a limited\n+   context may now appear as parameter and result types.  As a consequence,\n+   we may need to defer their translation until after a freeze node is seen\n+   or to the end of the current unit.  We also aim at handling temporarily\n+   incomplete types created by the usual delayed elaboration scheme.  */\n+\n+static tree\n+gnat_to_gnu_profile_type (Entity_Id gnat_type)\n+{\n+  /* This is the same logic as the E_Access_Type case of gnat_to_gnu_entity\n+     so the rationale is exposed in that place.  These processings probably\n+     ought to be merged at some point.  */\n+  Entity_Id gnat_equiv = Gigi_Equivalent_Type (gnat_type);\n+  const bool is_from_limited_with\n+    = (IN (Ekind (gnat_equiv), Incomplete_Kind)\n+       && From_Limited_With (gnat_equiv));\n+  Entity_Id gnat_full_direct_first\n+    = (is_from_limited_with\n+       ? Non_Limited_View (gnat_equiv)\n+       : (IN (Ekind (gnat_equiv), Incomplete_Or_Private_Kind)\n+\t  ? Full_View (gnat_equiv) : Empty));\n+  Entity_Id gnat_full_direct\n+    = ((is_from_limited_with\n+\t&& Present (gnat_full_direct_first)\n+\t&& IN (Ekind (gnat_full_direct_first), Private_Kind))\n+       ? Full_View (gnat_full_direct_first)\n+       : gnat_full_direct_first);\n+  Entity_Id gnat_full = Gigi_Equivalent_Type (gnat_full_direct);\n+  Entity_Id gnat_rep = Present (gnat_full) ? gnat_full : gnat_equiv;\n+  const bool in_main_unit = In_Extended_Main_Code_Unit (gnat_rep);\n+  tree gnu_type;\n+\n+  if (Present (gnat_full) && present_gnu_tree (gnat_full))\n+    gnu_type = TREE_TYPE (get_gnu_tree (gnat_full));\n+\n+  else if (is_from_limited_with\n+\t   && ((!in_main_unit\n+\t        && !present_gnu_tree (gnat_equiv)\n+\t\t&& Present (gnat_full)\n+\t\t&& (Is_Record_Type (gnat_full) || Is_Array_Type (gnat_full)))\n+\t       || (in_main_unit && Present (Freeze_Node (gnat_rep)))))\n+    {\n+      gnu_type = make_dummy_type (gnat_equiv);\n+\n+      if (!in_main_unit)\n+\t{\n+\t  struct incomplete *p = XNEW (struct incomplete);\n+\n+\t  p->old_type = gnu_type;\n+\t  p->full_type = gnat_equiv;\n+\t  p->next = defer_limited_with_list;\n+\t  defer_limited_with_list = p;\n+\t}\n+    }\n+\n+  else if (type_annotate_only && No (gnat_equiv))\n+    gnu_type = void_type_node;\n+\n+  else\n+    gnu_type = gnat_to_gnu_type (gnat_equiv);\n+\n+  /* Access-to-unconstrained-array types need a special treatment.  */\n+  if (Is_Array_Type (gnat_rep) && !Is_Constrained (gnat_rep))\n+    {\n+      if (!TYPE_POINTER_TO (gnu_type))\n+\tbuild_dummy_unc_pointer_types (gnat_equiv, gnu_type);\n+    }\n+\n+  return gnu_type;\n+}\n+\n+/* Return a GCC tree for a subprogram type corresponding to GNAT_SUBPROG.\n+   DEFINITION is true if this is for a subprogram being defined.  DEBUG_INFO_P\n+   is true if we need to write debug information for other types that we may\n+   create in the process.  Also set PARAM_LIST to the list of parameters.  */\n+\n+static tree\n+gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n+\t\t\t  bool debug_info_p, tree *param_list)\n+{\n+  const Entity_Kind kind = Ekind (gnat_subprog);\n+  Entity_Id gnat_return_type = Etype (gnat_subprog);\n+  Entity_Id gnat_param;\n+  tree gnu_return_type;\n+  tree gnu_param_type_list = NULL_TREE;\n+  tree gnu_param_list = NULL_TREE;\n+  /* Non-null for subprograms containing parameters passed by copy-in copy-out\n+     (In Out or Out parameters not passed by reference), in which case it is\n+     the list of nodes used to specify the values of the In Out/Out parameters\n+     that are returned as a record upon procedure return.  The TREE_PURPOSE of\n+     an element of this list is a FIELD_DECL of the record and the TREE_VALUE\n+     is the PARM_DECL corresponding to that field.  This list will be saved in\n+     the TYPE_CI_CO_LIST field of the FUNCTION_TYPE node we create.  */\n+  tree gnu_cico_list = NULL_TREE;\n+  /* Fields in return type of procedure with copy-in copy-out parameters.  */\n+  tree gnu_field_list = NULL_TREE;\n+  /* The semantics of \"pure\" in Ada essentially matches that of \"const\"\n+     in the back-end.  In particular, both properties are orthogonal to\n+     the \"nothrow\" property if the EH circuitry is explicit in the\n+     internal representation of the back-end.  If we are to completely\n+     hide the EH circuitry from it, we need to declare that calls to pure\n+     Ada subprograms that can throw have side effects since they can\n+     trigger an \"abnormal\" transfer of control flow; thus they can be\n+     neither \"const\" nor \"pure\" in the back-end sense.  */\n+  bool const_flag = (Back_End_Exceptions () && Is_Pure (gnat_subprog));\n+  bool return_by_direct_ref_p = false;\n+  bool return_by_invisi_ref_p = false;\n+  bool return_unconstrained_p = false;\n+  bool incomplete_profile_p = false;\n+  unsigned int num;\n+\n+  /* Look into the return type and get its associated GCC tree.  If it is not\n+     void, compute various flags for the subprogram type.  */\n+  if (Ekind (gnat_return_type) == E_Void)\n+    gnu_return_type = void_type_node;\n+  else\n+    {\n+      gnu_return_type = gnat_to_gnu_profile_type (gnat_return_type);\n+\n+      /* If this function returns by reference, make the actual return type\n+\t the reference type and make a note of that.  */\n+      if (Returns_By_Ref (gnat_subprog))\n+\t{\n+\t  gnu_return_type = build_reference_type (gnu_return_type);\n+\t  return_by_direct_ref_p = true;\n+\t}\n+\n+      /* If the return type is an unconstrained array type, the return value\n+\t will be allocated on the secondary stack so the actual return type\n+\t is the fat pointer type.  */\n+      else if (TREE_CODE (gnu_return_type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t{\n+\t  gnu_return_type = TYPE_REFERENCE_TO (gnu_return_type);\n+\t  return_unconstrained_p = true;\n+\t}\n+\n+      /* This is the same unconstrained array case, but for a dummy type.  */\n+      else if (TYPE_REFERENCE_TO (gnu_return_type)\n+\t       && TYPE_IS_FAT_POINTER_P (TYPE_REFERENCE_TO (gnu_return_type)))\n+\t{\n+\t  gnu_return_type = TYPE_REFERENCE_TO (gnu_return_type);\n+\t  return_unconstrained_p = true;\n+\t}\n+\n+      /* Likewise, if the return type requires a transient scope, the return\n+\t value will also be allocated on the secondary stack so the actual\n+\t return type is the reference type.  */\n+      else if (Requires_Transient_Scope (gnat_return_type))\n+\t{\n+\t  gnu_return_type = build_reference_type (gnu_return_type);\n+\t  return_unconstrained_p = true;\n+\t}\n+\n+      /* If the Mechanism is By_Reference, ensure this function uses the\n+\t target's by-invisible-reference mechanism, which may not be the\n+\t same as above (e.g. it might be passing an extra parameter).  */\n+      else if (kind == E_Function && Mechanism (gnat_subprog) == By_Reference)\n+\treturn_by_invisi_ref_p = true;\n+\n+      /* Likewise, if the return type is itself By_Reference.  */\n+      else if (TYPE_IS_BY_REFERENCE_P (gnu_return_type))\n+\treturn_by_invisi_ref_p = true;\n+\n+      /* If the type is a padded type and the underlying type would not be\n+\t passed by reference or the function has a foreign convention, return\n+\t the underlying type.  */\n+      else if (TYPE_IS_PADDING_P (gnu_return_type)\n+\t       && (!default_pass_by_ref\n+\t\t      (TREE_TYPE (TYPE_FIELDS (gnu_return_type)))\n+\t\t   || Has_Foreign_Convention (gnat_subprog)))\n+\tgnu_return_type = TREE_TYPE (TYPE_FIELDS (gnu_return_type));\n+\n+      /* If the return type is unconstrained, it must have a maximum size.\n+\t Use the padded type as the effective return type.  And ensure the\n+\t function uses the target's by-invisible-reference mechanism to\n+\t avoid copying too much data when it returns.  */\n+      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_return_type)))\n+\t{\n+\t  tree orig_type = gnu_return_type;\n+\t  tree max_return_size = max_size (TYPE_SIZE (gnu_return_type), true);\n+\n+\t  /* If the size overflows to 0, set it to an arbitrary positive\n+\t     value so that assignments in the type are preserved.  Their\n+\t     actual size is independent of this positive value.  */\n+\t  if (TREE_CODE (max_return_size) == INTEGER_CST\n+\t      && TREE_OVERFLOW (max_return_size)\n+\t      && integer_zerop (max_return_size))\n+\t    {\n+\t      max_return_size = copy_node (bitsize_unit_node);\n+\t      TREE_OVERFLOW (max_return_size) = 1;\n+\t    }\n+\n+\t  gnu_return_type = maybe_pad_type (gnu_return_type, max_return_size,\n+\t\t\t\t\t    0, gnat_subprog, false, false,\n+\t\t\t\t\t    definition, true);\n+\n+\t  /* Declare it now since it will never be declared otherwise.  This\n+\t     is necessary to ensure that its subtrees are properly marked.  */\n+\t  if (gnu_return_type != orig_type\n+\t      && !DECL_P (TYPE_NAME (gnu_return_type)))\n+\t    create_type_decl (TYPE_NAME (gnu_return_type), gnu_return_type,\n+\t\t\t      true, debug_info_p, gnat_subprog);\n+\n+\t  return_by_invisi_ref_p = true;\n+\t}\n+\n+      /* If the return type has a size that overflows, we usually cannot have\n+\t a function that returns that type.  This usage doesn't really make\n+\t sense anyway, so issue an error here.  */\n+      if (!return_by_invisi_ref_p\n+\t  && TYPE_SIZE_UNIT (gnu_return_type)\n+\t  && TREE_CODE (TYPE_SIZE_UNIT (gnu_return_type)) == INTEGER_CST\n+\t  && !valid_constant_size_p (TYPE_SIZE_UNIT (gnu_return_type)))\n+\t{\n+\t  post_error (\"cannot return type whose size overflows\", gnat_subprog);\n+\t  gnu_return_type = copy_type (gnu_return_type);\n+\t  TYPE_SIZE (gnu_return_type) = bitsize_zero_node;\n+\t  TYPE_SIZE_UNIT (gnu_return_type) = size_zero_node;\n+\t}\n+\n+      /* If the return type is incomplete, there are 2 cases: if the function\n+\t returns by reference, then the return type is only linked indirectly\n+\t in the profile, so the profile can be seen as complete since it need\n+\t not be further modified, only the reference types need be adjusted;\n+\t otherwise the profile itself is incomplete and need be adjusted.  */\n+      if (TYPE_IS_DUMMY_P (gnu_return_type))\n+\t{\n+\t  associate_subprog_with_dummy_type (gnat_subprog, gnu_return_type);\n+\t  incomplete_profile_p = true;\n+\t}\n+\n+      if (kind == E_Function)\n+\tSet_Mechanism (gnat_subprog, return_unconstrained_p\n+\t\t\t\t     || return_by_direct_ref_p\n+\t\t\t\t     || return_by_invisi_ref_p\n+\t\t\t\t     ? By_Reference : By_Copy);\n+    }\n+\n+  /* A procedure (something that doesn't return anything) shouldn't be\n+     considered const since there would be no reason for calling such a\n+     subprogram.  Note that procedures with Out (or In Out) parameters\n+     have already been converted into a function with a return type.\n+     Similarly, if the function returns an unconstrained type, then the\n+     function will allocate the return value on the secondary stack and\n+     thus calls to it cannot be CSE'ed, lest the stack be reclaimed.  */\n+  if (TREE_CODE (gnu_return_type) == VOID_TYPE || return_unconstrained_p)\n+    const_flag = false;\n+\n+  /* Loop over the parameters and get their associated GCC tree.  While doing\n+     this, build a copy-in copy-out structure if we need one.  */\n+  for (gnat_param = First_Formal_With_Extras (gnat_subprog), num = 0;\n+       Present (gnat_param);\n+       gnat_param = Next_Formal_With_Extras (gnat_param), num++)\n+    {\n+      Entity_Id gnat_param_type = Etype (gnat_param);\n+      tree gnu_param_name = get_entity_name (gnat_param);\n+      tree gnu_param_type = gnat_to_gnu_profile_type (gnat_param_type);\n+      tree gnu_param, gnu_field;\n+      bool cico = false;\n+\n+      /* If the parameter type is incomplete, there are 2 cases: if it is\n+\t passed by reference, then the type is only linked indirectly in\n+\t the profile, so the profile can be seen as complete since it need\n+\t not be further modified, only the reference types need be adjusted;\n+\t otherwise the profile itself is incomplete and need be adjusted.  */\n+      if (TYPE_IS_DUMMY_P (gnu_param_type))\n+\t{\n+\t  Node_Id gnat_decl;\n+\n+\t  if (Mechanism (gnat_param) == By_Reference\n+\t      || (TYPE_REFERENCE_TO (gnu_param_type)\n+\t\t  && TYPE_IS_FAT_POINTER_P (TYPE_REFERENCE_TO (gnu_param_type)))\n+\t      || TYPE_IS_BY_REFERENCE_P (gnu_param_type))\n+\t    {\n+\t      gnu_param_type = build_reference_type (gnu_param_type);\n+\t      gnu_param = create_param_decl (gnu_param_name, gnu_param_type);\n+\t      TREE_READONLY (gnu_param) = 1;\n+\t      DECL_BY_REF_P (gnu_param) = 1;\n+\t      DECL_POINTS_TO_READONLY_P (gnu_param)\n+\t\t= (Ekind (gnat_param) == E_In_Parameter\n+\t\t   && !Address_Taken (gnat_param));\n+\t      Set_Mechanism (gnat_param, By_Reference);\n+\t      Sloc_to_locus (Sloc (gnat_param),\n+\t\t\t     &DECL_SOURCE_LOCATION (gnu_param));\n+\t    }\n+\n+\t  /* ??? This is a kludge to support null procedures in spec taking a\n+\t     parameter with an untagged incomplete type coming from a limited\n+\t     context.  The front-end creates a body without knowing anything\n+\t     about the non-limited view, which is illegal Ada and cannot be\n+\t     reasonably supported.  Create a parameter with a fake type.  */\n+\t  else if (kind == E_Procedure\n+\t\t   && (gnat_decl = Parent (gnat_subprog))\n+\t\t   && Nkind (gnat_decl) == N_Procedure_Specification\n+\t\t   && Null_Present (gnat_decl)\n+\t\t   && IN (Ekind (gnat_param_type), Incomplete_Kind))\n+\t    gnu_param = create_param_decl (gnu_param_name, ptr_type_node);\n+\n+\t  else\n+\t    {\n+\t      gnu_param = create_param_decl (gnu_param_name, gnu_param_type);\n+\t      associate_subprog_with_dummy_type (gnat_subprog, gnu_param_type);\n+\t      incomplete_profile_p = true;\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  gnu_param\n+\t    = gnat_to_gnu_param (gnat_param, num == 0, gnat_subprog, &cico);\n+\n+\t  /* We are returned either a PARM_DECL or a type if no parameter\n+\t     needs to be passed; in either case, adjust the type.  */\n+\t  if (DECL_P (gnu_param))\n+\t    gnu_param_type = TREE_TYPE (gnu_param);\n+\t  else\n+\t    {\n+\t      gnu_param_type = gnu_param;\n+\t      gnu_param = NULL_TREE;\n+\t    }\n+\t}\n+\n+      /* If we built a GCC tree for the parameter, register it.  */\n+      if (gnu_param)\n+\t{\n+\t  gnu_param_type_list\n+\t    = tree_cons (NULL_TREE, gnu_param_type, gnu_param_type_list);\n+\t  gnu_param_list = chainon (gnu_param, gnu_param_list);\n+\t  save_gnu_tree (gnat_param, NULL_TREE, false);\n+\t  save_gnu_tree (gnat_param, gnu_param, false);\n+\n+\t  /* If a parameter is a pointer, a function may modify memory through\n+\t     it and thus shouldn't be considered a const function.   Also, the\n+\t     memory may be modified between two calls, so they can't be CSE'ed.\n+\t     The latter case also handles by-ref parameters.  */\n+\t  if (POINTER_TYPE_P (gnu_param_type)\n+\t      || TYPE_IS_FAT_POINTER_P (gnu_param_type))\n+\t    const_flag = false;\n+\t}\n+\n+      /* If the parameter uses the copy-in copy-out mechanism, allocate a field\n+\t for it in the return type and register the association.  */\n+      if (cico && !incomplete_profile_p)\n+\t{\n+\t  if (!gnu_cico_list)\n+\t    {\n+\t      tree gnu_new_ret_type = make_node (RECORD_TYPE);\n+\n+\t      /* If this is a function, we also need a field for the\n+\t\t return value to be placed.  */\n+\t      if (TREE_CODE (gnu_return_type) != VOID_TYPE)\n+\t\t{\n+\t\t  gnu_field\n+\t\t    = create_field_decl (get_identifier (\"RETVAL\"),\n+\t\t\t\t         gnu_return_type,\n+\t\t\t\t         gnu_new_ret_type, NULL_TREE,\n+\t\t\t\t         NULL_TREE, 0, 0);\n+\t\t  Sloc_to_locus (Sloc (gnat_subprog),\n+\t\t\t         &DECL_SOURCE_LOCATION (gnu_field));\n+\t\t  gnu_field_list = gnu_field;\n+\t\t  gnu_cico_list\n+\t\t    = tree_cons (gnu_field, void_type_node, NULL_TREE);\n+\t\t}\n+\n+\t      gnu_return_type = gnu_new_ret_type;\n+\t      TYPE_NAME (gnu_return_type) = get_identifier (\"RETURN\");\n+\t      /* Set a default alignment to speed up accesses.  But we should\n+\t\t not increase the size of the structure too much, lest it does\n+\t\t not fit in return registers anymore.  */\n+\t      SET_TYPE_ALIGN (gnu_return_type, get_mode_alignment (ptr_mode));\n+\t    }\n+\n+\t  gnu_field\n+\t    = create_field_decl (gnu_param_name, gnu_param_type,\n+\t\t\t\t gnu_return_type, NULL_TREE, NULL_TREE, 0, 0);\n+\t  Sloc_to_locus (Sloc (gnat_param),\n+\t\t\t &DECL_SOURCE_LOCATION (gnu_field));\n+\t  DECL_CHAIN (gnu_field) = gnu_field_list;\n+\t  gnu_field_list = gnu_field;\n+\t  gnu_cico_list = tree_cons (gnu_field, gnu_param, gnu_cico_list);\n+\t}\n+    }\n+\n+  /* If the subprogram uses the copy-in copy-out mechanism, possibly adjust\n+     and finish up the return type.  */\n+  if (gnu_cico_list && !incomplete_profile_p)\n+    {\n+      /* If we have a CICO list but it has only one entry, we convert\n+\t this function into a function that returns this object.  */\n+      if (list_length (gnu_cico_list) == 1)\n+\tgnu_return_type = TREE_TYPE (TREE_PURPOSE (gnu_cico_list));\n+\n+      /* Do not finalize the return type if the subprogram is stubbed\n+\t since structures are incomplete for the back-end.  */\n+      else if (Convention (gnat_subprog) != Convention_Stubbed)\n+\t{\n+\t  finish_record_type (gnu_return_type, nreverse (gnu_field_list), 0,\n+\t\t\t      false);\n+\n+\t  /* Try to promote the mode of the return type if it is passed\n+\t     in registers, again to speed up accesses.  */\n+\t  if (TYPE_MODE (gnu_return_type) == BLKmode\n+\t      && !targetm.calls.return_in_memory (gnu_return_type, NULL_TREE))\n+\t    {\n+\t      unsigned int size\n+\t\t= TREE_INT_CST_LOW (TYPE_SIZE (gnu_return_type));\n+\t      unsigned int i = BITS_PER_UNIT;\n+\t      machine_mode mode;\n+\n+\t      while (i < size)\n+\t\ti <<= 1;\n+\t      mode = mode_for_size (i, MODE_INT, 0);\n+\t      if (mode != BLKmode)\n+\t\t{\n+\t\t  SET_TYPE_MODE (gnu_return_type, mode);\n+\t\t  SET_TYPE_ALIGN (gnu_return_type, GET_MODE_ALIGNMENT (mode));\n+\t\t  TYPE_SIZE (gnu_return_type)\n+\t\t    = bitsize_int (GET_MODE_BITSIZE (mode));\n+\t\t  TYPE_SIZE_UNIT (gnu_return_type)\n+\t\t    = size_int (GET_MODE_SIZE (mode));\n+\t\t}\n+\t    }\n+\n+\t  if (debug_info_p)\n+\t    rest_of_record_type_compilation (gnu_return_type);\n+\t}\n+    }\n+\n+  /* The lists have been built in reverse.  */\n+  gnu_param_type_list = nreverse (gnu_param_type_list);\n+  gnu_param_type_list = chainon (gnu_param_type_list, void_list_node);\n+  *param_list = nreverse (gnu_param_list);\n+  gnu_cico_list = nreverse (gnu_cico_list);\n+\n+  /* If the profile is incomplete, we only set the (temporary) return and\n+     parameter types; otherwise, we build the full type.  In either case,\n+     we reuse an already existing GCC tree that we built previously here.  */\n+  tree gnu_type = present_gnu_tree (gnat_subprog)\n+\t\t  ? TREE_TYPE (get_gnu_tree (gnat_subprog)) : NULL_TREE;\n+\n+  if (incomplete_profile_p)\n+    {\n+      if (gnu_type && TREE_CODE (gnu_type) == FUNCTION_TYPE)\n+\t;\n+      else\n+\tgnu_type = make_node (FUNCTION_TYPE);\n+      TREE_TYPE (gnu_type) = gnu_return_type;\n+      TYPE_ARG_TYPES (gnu_type) = gnu_param_type_list;\n+    }\n+  else\n+    {\n+      if (gnu_type && TREE_CODE (gnu_type) == FUNCTION_TYPE)\n+\t{\n+\t  TREE_TYPE (gnu_type) = gnu_return_type;\n+\t  TYPE_ARG_TYPES (gnu_type) = gnu_param_type_list;\n+\t  TYPE_CI_CO_LIST (gnu_type) = gnu_cico_list;\n+\t  TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n+\t  TYPE_RETURN_BY_DIRECT_REF_P (gnu_type) = return_by_direct_ref_p;\n+\t  TREE_ADDRESSABLE (gnu_type) = return_by_invisi_ref_p;\n+\t  TYPE_CANONICAL (gnu_type) = gnu_type;\n+\t  layout_type (gnu_type);\n+\t}\n+      else\n+\t{\n+\t  gnu_type\n+\t    = build_function_type (gnu_return_type, gnu_param_type_list);\n+\n+\t  /* GNU_TYPE may be shared since GCC hashes types.  Unshare it if it\n+\t     has a different TYPE_CI_CO_LIST or flags.  */\n+\t  if (!fntype_same_flags_p (gnu_type, gnu_cico_list,\n+\t\t\t\t    return_unconstrained_p,\n+\t\t\t\t    return_by_direct_ref_p,\n+\t\t\t\t    return_by_invisi_ref_p))\n+\t    {\n+\t      gnu_type = copy_type (gnu_type);\n+\t      TYPE_CI_CO_LIST (gnu_type) = gnu_cico_list;\n+\t      TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n+\t      TYPE_RETURN_BY_DIRECT_REF_P (gnu_type) = return_by_direct_ref_p;\n+\t      TREE_ADDRESSABLE (gnu_type) = return_by_invisi_ref_p;\n+\t    }\n+\t}\n+\n+      if (const_flag)\n+\tgnu_type = change_qualified_type (gnu_type, TYPE_QUAL_CONST);\n+\n+      if (No_Return (gnat_subprog))\n+\tgnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n+    }\n+\n+  return gnu_type;\n }\n \n /* Like build_qualified_type, but TYPE_QUALS is added to the existing\n@@ -9202,6 +9340,9 @@ init_gnat_decl (void)\n {\n   /* Initialize the cache of annotated values.  */\n   annotate_value_cache = hash_table<value_annotation_hasher>::create_ggc (512);\n+\n+  /* Initialize the association of dummy types with subprograms.  */\n+  dummy_to_subprog_map = hash_table<dummy_type_hasher>::create_ggc (512);\n }\n \n /* Destroy data structures of the decl.c module.  */\n@@ -9212,6 +9353,10 @@ destroy_gnat_decl (void)\n   /* Destroy the cache of annotated values.  */\n   annotate_value_cache->empty ();\n   annotate_value_cache = NULL;\n+\n+  /* Destroy the association of dummy types with subprograms.  */\n+  dummy_to_subprog_map->empty ();\n+  dummy_to_subprog_map = NULL;\n }\n \n #include \"gt-ada-decl.h\""}, {"sha": "9cc744b24f26762d20ed017ea848ff78bb248858", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -49,6 +49,10 @@ extern tree gnat_to_gnu_field_decl (Entity_Id gnat_entity);\n    the GCC type corresponding to that entity.  */\n extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n \n+/* Update the GCC tree previously built for the profiles involving GNU_TYPE,\n+   a dummy type which appears in profiles.  */\n+extern void update_profiles_with (tree gnu_type);\n+\n /* Start a new statement group chained to the previous group.  */\n extern void start_stmt_group (void);\n \n@@ -109,11 +113,6 @@ extern void elaborate_entity (Entity_Id gnat_entity);\n /* Get the unpadded version of a GNAT type.  */\n extern tree get_unpadded_type (Entity_Id gnat_entity);\n \n-/* Return the DECL associated with the public subprogram GNAT_ENTITY but whose\n-   type has been changed to that of the parameterless procedure, except if an\n-   alias is already present, in which case it is returned instead.  */\n-extern tree get_minimal_subprog_decl (Entity_Id gnat_entity);\n-\n /* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n    a C++ imported method or equivalent.  */\n extern bool is_cplusplus_method (Entity_Id gnat_entity);\n@@ -631,20 +630,6 @@ extern void rest_of_record_type_compilation (tree record_type);\n /* Append PARALLEL_TYPE on the chain of parallel types for TYPE.  */\n extern void add_parallel_type (tree type, tree parallel_type);\n \n-/* Return a FUNCTION_TYPE node.  RETURN_TYPE is the type returned by the\n-   subprogram.  If it is VOID_TYPE, then we are dealing with a procedure,\n-   otherwise we are dealing with a function.  PARAM_DECL_LIST is a list of\n-   PARM_DECL nodes that are the subprogram parameters.  CICO_LIST is the\n-   copy-in/copy-out list to be stored into the TYPE_CICO_LIST field.\n-   RETURN_UNCONSTRAINED_P is true if the function returns an unconstrained\n-   object.  RETURN_BY_DIRECT_REF_P is true if the function returns by direct\n-   reference.  RETURN_BY_INVISI_REF_P is true if the function returns by\n-   invisible reference.  */\n-extern tree create_subprog_type (tree return_type, tree param_decl_list,\n-\t\t\t\t tree cico_list, bool return_unconstrained_p,\n-\t\t\t\t bool return_by_direct_ref_p,\n-\t\t\t\t bool return_by_invisi_ref_p);\n-\n /* Return a copy of TYPE, but safe to modify in any way.  */\n extern tree copy_type (tree type);\n \n@@ -717,10 +702,8 @@ extern tree create_field_decl (tree name, tree type, tree record_type,\n \t\t\t       tree size, tree pos, int packed,\n \t\t\t       int addressable);\n \n-/* Return a PARM_DECL node.  NAME is the name of the parameter and TYPE is\n-   its type.  READONLY is true if the parameter is readonly (either an In\n-   parameter or an address of a pass-by-ref parameter).  */\n-extern tree create_param_decl (tree name, tree type, bool readonly);\n+/* Return a PARM_DECL node with NAME and TYPE.  */\n+extern tree create_param_decl (tree name, tree type);\n \n /* Return a LABEL_DECL with NAME.  GNAT_NODE is used for the position of\n    the decl.  */\n@@ -733,8 +716,10 @@ extern tree create_label_decl (tree name, Node_Id gnat_node);\n \n    INLINE_STATUS describes the inline flags to be set on the FUNCTION_DECL.\n \n-   CONST_FLAG, PUBLIC_FLAG, EXTERN_FLAG, VOLATILE_FLAG are used to set the\n-   appropriate flags on the FUNCTION_DECL.\n+   PUBLIC_FLAG is true if this is for a reference to a public entity or for a\n+   definition to be made visible outside of the current compilation unit.\n+\n+   EXTERN_FLAG is true when processing an external subprogram declaration.\n \n    ARTIFICIAL_P is true if the subprogram was generated by the compiler.\n \n@@ -746,11 +731,14 @@ extern tree create_label_decl (tree name, Node_Id gnat_node);\n extern tree create_subprog_decl (tree name, tree asm_name, tree type,\n \t\t\t\t tree param_decl_list,\n \t\t\t\t enum inline_status_t inline_status,\n-\t\t\t\t bool const_flag, bool public_flag,\n-\t\t\t\t bool extern_flag, bool volatile_flag,\n+\t\t\t\t bool public_flag, bool extern_flag,\n \t\t\t\t bool artificial_p, bool debug_info_p,\n \t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n \n+/* Given a subprogram declaration DECL and its TYPE, finish constructing the\n+   subprogram declaration from TYPE.  */\n+extern void finish_subprog_decl (tree decl, tree type);\n+\n /* Process the attributes in ATTR_LIST for NODE, which is either a DECL or\n    a TYPE.  If IN_PLACE is true, the tree pointed to by NODE should not be\n    changed.  GNAT_NODE is used for the position of error messages.  */"}, {"sha": "279a114e3b8f789786efc129f19d25aa4fd33181", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -718,7 +718,9 @@ gnat_get_alias_set (tree type)\n       get_alias_set (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type)))));\n \n   /* If the type can alias any other types, return the alias set 0.  */\n-  else if (TYPE_P (type) && TYPE_UNIVERSAL_ALIASING_P (type))\n+  else if (TYPE_P (type)\n+\t   && !TYPE_IS_DUMMY_P (type)\n+\t   && TYPE_UNIVERSAL_ALIASING_P (type))\n     return 0;\n \n   return -1;\n@@ -932,7 +934,7 @@ gnat_get_array_descr_info (const_tree const_type,\n \t     and XUA types.  */\n \t  if (TYPE_CONTEXT (first_dimen)\n \t      && TREE_CODE (TYPE_CONTEXT (first_dimen)) != RECORD_TYPE\n-\t      && contains_placeholder_p (TYPE_MIN_VALUE (index_type))\n+\t      && CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (index_type))\n \t      && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t    {\n \t      info->dimen[i].lower_bound = NULL_TREE;"}, {"sha": "f31f70c3b01c3d4cc95096da2f8421485fbdf23e", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 62, "deletions": 83, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -398,8 +398,8 @@ gigi (Node_Id gnat_root,\n   malloc_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n \t\t\t   ftype,\n-\t\t\t   NULL_TREE, is_disabled, false, true, true, false,\n-\t\t\t   true, false, NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n   /* free is a function declaration tree for a function to free memory.  */\n@@ -408,17 +408,17 @@ gigi (Node_Id gnat_root,\n \t\t\t   build_function_type_list (void_type_node,\n \t\t\t\t\t\t     ptr_type_node,\n \t\t\t\t\t\t     NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, false, true, true, false,\n-\t\t\t   true, false, NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n \n   /* This is used for 64-bit multiplication with overflow checking.  */\n   int64_type = gnat_type_for_size (64, 0);\n   mulv64_decl\n     = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n \t\t\t   build_function_type_list (int64_type, int64_type,\n \t\t\t\t\t\t     int64_type, NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, false, true, true, false,\n-\t\t\t   true, false, NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n \n   /* Name of the _Parent field in tagged record types.  */\n   parent_name_id = get_identifier (Get_Name_String (Name_uParent));\n@@ -441,24 +441,21 @@ gigi (Node_Id gnat_root,\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, false, true, true, false, true, false,\n-       NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (void_type_node, jmpbuf_ptr_type,\n \t\t\t\t\t    NULL_TREE),\n-       NULL_TREE, is_disabled, false, true, true, false, true, false,\n-       NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   get_excptr_decl\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n        build_function_type_list (build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, false, true, true, false, true, false,\n-       NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   not_handled_by_others_decl = get_identifier (\"not_handled_by_others\");\n   for (t = TYPE_FIELDS (except_type_node); t; t = DECL_CHAIN (t))\n@@ -476,8 +473,7 @@ gigi (Node_Id gnat_root,\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n        build_function_type_list (integer_type_node, jmpbuf_ptr_type,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, false, true, true, false, true, false,\n-       NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n \n@@ -487,56 +483,51 @@ gigi (Node_Id gnat_root,\n     = create_subprog_decl\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n        build_function_type_list (void_type_node, jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, false, true, true, false, true, false,\n-       NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n   /* Indicate that it never returns.  */\n+  ftype = build_function_type_list (void_type_node,\n+\t\t\t\t    build_pointer_type (except_type_node),\n+\t\t\t\t    NULL_TREE);\n+  ftype = build_qualified_type (ftype, TYPE_QUAL_VOLATILE);\n   raise_nodefer_decl\n     = create_subprog_decl\n-      (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n-       build_function_type_list (void_type_node,\n-\t\t\t\t build_pointer_type (except_type_node),\n-\t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, false, true, true, true, true, false,\n-       NULL, Empty);\n-\n-  /* Indicate that these never return.  */\n-  reraise_zcx_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, false, true, true, true, true, false,\n-\t\t\t   NULL, Empty);\n+      (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE, ftype,\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   set_exception_parameter_decl\n     = create_subprog_decl\n       (get_identifier (\"__gnat_set_exception_parameter\"), NULL_TREE,\n        build_function_type_list (void_type_node, ptr_type_node, ptr_type_node,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, false, true, true, false, true, false,\n-       NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   /* Hooks to call when entering/leaving an exception handler.  */\n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n \n   begin_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n \t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, false, true, true, false, true, false,\n-\t\t\t   NULL, Empty);\n+\t\t\t   is_disabled, true, true, true, false, NULL, Empty);\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n \t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, false, true, true, false, true, false,\n-\t\t\t   NULL, Empty);\n+\t\t\t   is_disabled, true, true, true, false, NULL, Empty);\n \n   unhandled_except_decl\n     = create_subprog_decl (get_identifier (\"__gnat_unhandled_except_handler\"),\n \t\t\t   NULL_TREE, ftype, NULL_TREE,\n-\t\t\t   is_disabled, false, true, true, false, true, false,\n-\t\t\t   NULL, Empty);\n+\t\t\t   is_disabled, true, true, true, false, NULL, Empty);\n+\n+  /* Indicate that it never returns.  */\n+  ftype = build_qualified_type (ftype, TYPE_QUAL_VOLATILE);\n+  reraise_zcx_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n+\t\t\t   ftype, NULL_TREE,\n+\t\t\t   is_disabled, true, true, true, false, NULL, Empty);\n \n   /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n      tables.  These are exported by a-exexpr-gcc.adb, so see this unit for\n@@ -567,14 +558,15 @@ gigi (Node_Id gnat_root,\n      this procedure will never be called in this mode.  */\n   if (No_Exception_Handlers_Set ())\n     {\n+      /* Indicate that it never returns.  */\n+      ftype = build_function_type_list (void_type_node,\n+\t\t\t\t\tbuild_pointer_type (char_type_node),\n+\t\t\t\t\tinteger_type_node, NULL_TREE);\n+      ftype = build_qualified_type (ftype, TYPE_QUAL_VOLATILE);\n       tree decl\n \t= create_subprog_decl\n-\t  (get_identifier (\"__gnat_last_chance_handler\"), NULL_TREE,\n-\t   build_function_type_list (void_type_node,\n-\t\t\t\t     build_pointer_type (char_type_node),\n-\t\t\t\t     integer_type_node, NULL_TREE),\n-\t   NULL_TREE, is_disabled, false, true, true, true, true, false,\n-\t   NULL, Empty);\n+\t  (get_identifier (\"__gnat_last_chance_handler\"), NULL_TREE, ftype,\n+\t   NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n       for (i = 0; i < (int) ARRAY_SIZE (gnat_raise_decls); i++)\n \tgnat_raise_decls[i] = decl;\n     }\n@@ -736,10 +728,10 @@ build_raise_check (int check, enum exception_info_kind kind)\n     }\n \n   /* Indicate that it never returns.  */\n+  ftype = build_qualified_type (ftype, TYPE_QUAL_VOLATILE);\n   result\n-    = create_subprog_decl (get_identifier (Name_Buffer), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, false, true, true, true, true, false,\n+    = create_subprog_decl (get_identifier (Name_Buffer), NULL_TREE, ftype,\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n \n   return result;\n@@ -1020,15 +1012,15 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      address clause when the parent doesn't require an lvalue.  */\n   bool use_constant_initializer = false;\n \n-  /* If the Etype of this node does not equal the Etype of the Entity,\n-     something is wrong with the entity map, probably in generic\n-     instantiation. However, this does not apply to types. Since we sometime\n-     have strange Ekind's, just do this test for objects. Also, if the Etype of\n-     the Entity is private, the Etype of the N_Identifier is allowed to be the\n-     full type and also we consider a packed array type to be the same as the\n-     original type. Similarly, a class-wide type is equivalent to a subtype of\n-     itself. Finally, if the types are Itypes, one may be a copy of the other,\n-     which is also legal.  */\n+  /* If the Etype of this node is not the same as that of the Entity, then\n+     something went wrong, probably in generic instantiation.  However, this\n+     does not apply to types.  Since we sometime have strange Ekind's, just\n+     do this test for objects.  Moreover, if the Etype of the Entity is private\n+     or incomplete coming from a limited context, the Etype of the N_Identifier\n+     is allowed to be the full/non-limited view and we also consider a packed\n+     array type to be the same as the original type.  Similarly, a CW type is\n+     equivalent to a subtype of itself.  Finally, if the types are Itypes, one\n+     may be a copy of the other, which is also legal.  */\n   gnat_temp = ((Nkind (gnat_node) == N_Defining_Identifier\n \t\t|| Nkind (gnat_node) == N_Defining_Operator_Symbol)\n \t       ? gnat_node : Entity (gnat_node));\n@@ -1046,6 +1038,10 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t  && (Etype (gnat_node)\n \t\t\t      == Packed_Array_Impl_Type\n \t\t\t           (Full_View (gnat_temp_type))))))\n+\t      || (IN (Ekind (gnat_temp_type), Incomplete_Kind)\n+\t\t  && From_Limited_With (gnat_temp_type)\n+\t\t  && Present (Non_Limited_View (gnat_temp_type))\n+\t\t  && Etype (gnat_node) == Non_Limited_View (gnat_temp_type))\n \t      || (Is_Itype (Etype (gnat_node)) && Is_Itype (gnat_temp_type))\n \t      || !(Ekind (gnat_temp) == E_Variable\n \t\t   || Ekind (gnat_temp) == E_Component\n@@ -1569,25 +1565,11 @@ static tree\n Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n {\n   const Node_Id gnat_prefix = Prefix (gnat_node);\n-  tree gnu_prefix, gnu_type, gnu_expr;\n-  tree gnu_result_type, gnu_result = error_mark_node;\n+  tree gnu_prefix = gnat_to_gnu (gnat_prefix);\n+  tree gnu_type = TREE_TYPE (gnu_prefix);\n+  tree gnu_expr, gnu_result_type, gnu_result = error_mark_node;\n   bool prefix_unused = false;\n \n-  /* ??? If this is an access attribute for a public subprogram to be used in\n-     a dispatch table, do not translate its type as it's useless in this case\n-     and the parameter types might be incomplete types coming from a limited\n-     context in Ada 2012 (AI05-0151).  */\n-  if (Ekind (Etype (gnat_node)) == E_Access_Subprogram_Type\n-      && Is_Dispatch_Table_Entity (Etype (gnat_node))\n-      && Nkind (gnat_prefix) == N_Identifier\n-      && Is_Subprogram (Entity (gnat_prefix))\n-      && Is_Public (Entity (gnat_prefix))\n-      && !present_gnu_tree (Entity (gnat_prefix)))\n-    gnu_prefix = get_minimal_subprog_decl (Entity (gnat_prefix));\n-  else\n-    gnu_prefix = gnat_to_gnu (gnat_prefix);\n-  gnu_type = TREE_TYPE (gnu_prefix);\n-\n   /* If the input is a NULL_EXPR, make a new one.  */\n   if (TREE_CODE (gnu_prefix) == NULL_EXPR)\n     {\n@@ -5340,8 +5322,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n     = create_subprog_decl\n       (create_concat_name (gnat_unit_entity, body_p ? \"elabb\" : \"elabs\"),\n        NULL_TREE, void_ftype, NULL_TREE,\n-       is_disabled, false, true, false, false, true, true,\n-       NULL, gnat_unit);\n+       is_disabled, true, false, true, true, NULL, gnat_unit);\n   struct elab_info *info;\n \n   vec_safe_push (gnu_elab_proc_stack, gnu_elab_proc_decl);\n@@ -6340,8 +6321,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t (Entity (Prefix (gnat_node)),\n \t\t\t\t  attr == Attr_Elab_Body ? \"elabb\" : \"elabs\"),\n \t\t\t\t NULL_TREE, void_ftype, NULL_TREE, is_disabled,\n-\t\t\t\t false, true, true, false, true, true,\n-\t\t\t\t NULL, gnat_node);\n+\t\t\t\t true, true, true, true, NULL, gnat_node);\n \n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attr);\n       }\n@@ -8554,14 +8534,11 @@ process_freeze_entity (Node_Id gnat_node)\n   if (kind == E_Class_Wide_Type)\n     return;\n \n-  /* Check for an old definition.  This freeze node might be for an Itype.  */\n+  /* Check for an old definition if this isn't an object with address clause,\n+     since the saved GCC tree is the address expression in that case.  */\n   gnu_old\n-    = present_gnu_tree (gnat_entity) ? get_gnu_tree (gnat_entity) : NULL_TREE;\n-\n-  /* If this entity has an address representation clause, GNU_OLD is the\n-     address, so discard it here.  */\n-  if (Present (Address_Clause (gnat_entity)))\n-    gnu_old = NULL_TREE;\n+    = present_gnu_tree (gnat_entity) && No (Address_Clause (gnat_entity))\n+      ? get_gnu_tree (gnat_entity) : NULL_TREE;\n \n   /* Don't do anything for subprograms that may have been elaborated before\n      their freeze nodes.  This can happen, for example, because of an inner\n@@ -8671,6 +8648,8 @@ process_freeze_entity (Node_Id gnat_node)\n     {\n       update_pointer_to (TYPE_MAIN_VARIANT (TREE_TYPE (gnu_old)),\n \t\t\t TREE_TYPE (gnu_new));\n+      if (TYPE_DUMMY_IN_PROFILE_P (TREE_TYPE (gnu_old)))\n+\tupdate_profiles_with (TREE_TYPE (gnu_old));\n       if (DECL_TAFT_TYPE_P (gnu_old))\n \tused_types_insert (TREE_TYPE (gnu_new));\n     }"}, {"sha": "8c36149a18c0d659e513b3374c314db4044812b8", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 34, "deletions": 67, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -428,6 +428,7 @@ build_dummy_unc_pointer_types (Entity_Id gnat_desig_type, tree gnu_desig_type)\n   TYPE_DUMMY_P (gnu_object_type) = 1;\n \n   TYPE_POINTER_TO (gnu_desig_type) = gnu_fat_type;\n+  TYPE_REFERENCE_TO (gnu_desig_type) = gnu_fat_type;\n   TYPE_OBJECT_RECORD_TYPE (gnu_desig_type) = gnu_object_type;\n }\n \f\n@@ -2221,47 +2222,6 @@ split_plus (tree in, tree *pvar)\n     return bitsize_zero_node;\n }\n \f\n-/* Return a FUNCTION_TYPE node.  RETURN_TYPE is the type returned by the\n-   subprogram.  If it is VOID_TYPE, then we are dealing with a procedure,\n-   otherwise we are dealing with a function.  PARAM_DECL_LIST is a list of\n-   PARM_DECL nodes that are the subprogram parameters.  CICO_LIST is the\n-   copy-in/copy-out list to be stored into the TYPE_CICO_LIST field.\n-   RETURN_UNCONSTRAINED_P is true if the function returns an unconstrained\n-   object.  RETURN_BY_DIRECT_REF_P is true if the function returns by direct\n-   reference.  RETURN_BY_INVISI_REF_P is true if the function returns by\n-   invisible reference.  */\n-\n-tree\n-create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n-\t\t     bool return_unconstrained_p, bool return_by_direct_ref_p,\n-\t\t     bool return_by_invisi_ref_p)\n-{\n-  /* A list of the data type nodes of the subprogram formal parameters.\n-     This list is generated by traversing the input list of PARM_DECL\n-     nodes.  */\n-  vec<tree, va_gc> *param_type_list = NULL;\n-  tree t, type;\n-\n-  for (t = param_decl_list; t; t = DECL_CHAIN (t))\n-    vec_safe_push (param_type_list, TREE_TYPE (t));\n-\n-  type = build_function_type_vec (return_type, param_type_list);\n-\n-  /* TYPE may have been shared since GCC hashes types.  If it has a different\n-     CICO_LIST, make a copy.  Likewise for the various flags.  */\n-  if (!fntype_same_flags_p (type, cico_list, return_unconstrained_p,\n-\t\t\t    return_by_direct_ref_p, return_by_invisi_ref_p))\n-    {\n-      type = copy_type (type);\n-      TYPE_CI_CO_LIST (type) = cico_list;\n-      TYPE_RETURN_UNCONSTRAINED_P (type) = return_unconstrained_p;\n-      TYPE_RETURN_BY_DIRECT_REF_P (type) = return_by_direct_ref_p;\n-      TREE_ADDRESSABLE (type) = return_by_invisi_ref_p;\n-    }\n-\n-  return type;\n-}\n-\f\n /* Return a copy of TYPE but safe to modify in any way.  */\n \n tree\n@@ -2742,12 +2702,10 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n   return field_decl;\n }\n \f\n-/* Return a PARM_DECL node.  NAME is the name of the parameter and TYPE is\n-   its type.  READONLY is true if the parameter is readonly (either an In\n-   parameter or an address of a pass-by-ref parameter).  */\n+/* Return a PARM_DECL node with NAME and TYPE.  */\n \n tree\n-create_param_decl (tree name, tree type, bool readonly)\n+create_param_decl (tree name, tree type)\n {\n   tree param_decl = build_decl (input_location, PARM_DECL, name, type);\n \n@@ -2775,7 +2733,6 @@ create_param_decl (tree name, tree type, bool readonly)\n     }\n \n   DECL_ARG_TYPE (param_decl) = type;\n-  TREE_READONLY (param_decl) = readonly;\n   return param_decl;\n }\n \f\n@@ -3151,8 +3108,10 @@ create_label_decl (tree name, Node_Id gnat_node)\n \n    INLINE_STATUS describes the inline flags to be set on the FUNCTION_DECL.\n \n-   CONST_FLAG, PUBLIC_FLAG, EXTERN_FLAG, VOLATILE_FLAG are used to set the\n-   appropriate flags on the FUNCTION_DECL.\n+   PUBLIC_FLAG is true if this is for a reference to a public entity or for a\n+   definition to be made visible outside of the current compilation unit.\n+\n+   EXTERN_FLAG is true when processing an external subprogram declaration.\n \n    ARTIFICIAL_P is true if the subprogram was generated by the compiler.\n \n@@ -3164,18 +3123,20 @@ create_label_decl (tree name, Node_Id gnat_node)\n \n tree\n create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n-\t\t     enum inline_status_t inline_status, bool const_flag,\n-\t\t     bool public_flag, bool extern_flag, bool volatile_flag,\n-\t\t     bool artificial_p, bool debug_info_p,\n+\t\t     enum inline_status_t inline_status, bool public_flag,\n+\t\t     bool extern_flag, bool artificial_p, bool debug_info_p,\n \t\t     struct attrib *attr_list, Node_Id gnat_node)\n {\n   tree subprog_decl = build_decl (input_location, FUNCTION_DECL, name, type);\n-  tree result_decl\n-    = build_decl (input_location, RESULT_DECL, NULL_TREE, TREE_TYPE (type));\n   DECL_ARGUMENTS (subprog_decl) = param_decl_list;\n+  finish_subprog_decl (subprog_decl, type);\n \n   DECL_ARTIFICIAL (subprog_decl) = artificial_p;\n   DECL_EXTERNAL (subprog_decl) = extern_flag;\n+  TREE_PUBLIC (subprog_decl) = public_flag;\n+\n+  if (!debug_info_p)\n+    DECL_IGNORED_P (subprog_decl) = 1;\n \n   switch (inline_status)\n     {\n@@ -3204,20 +3165,6 @@ create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n       gcc_unreachable ();\n     }\n \n-  if (!debug_info_p)\n-    DECL_IGNORED_P (subprog_decl) = 1;\n-\n-  TREE_READONLY (subprog_decl) = TYPE_READONLY (type) | const_flag;\n-  TREE_PUBLIC (subprog_decl) = public_flag;\n-  TREE_SIDE_EFFECTS (subprog_decl)\n-    = TREE_THIS_VOLATILE (subprog_decl)\n-    = TYPE_VOLATILE (type) | volatile_flag;\n-\n-  DECL_ARTIFICIAL (result_decl) = 1;\n-  DECL_IGNORED_P (result_decl) = 1;\n-  DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);\n-  DECL_RESULT (subprog_decl) = result_decl;\n-\n   process_attributes (&subprog_decl, &attr_list, true, gnat_node);\n \n   /* Add this decl to the current binding level.  */\n@@ -3246,6 +3193,25 @@ create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n \n   return subprog_decl;\n }\n+\n+/* Given a subprogram declaration DECL and its TYPE, finish constructing the\n+   subprogram declaration from TYPE.  */\n+\n+void\n+finish_subprog_decl (tree decl, tree type)\n+{\n+  tree result_decl\n+    = build_decl (DECL_SOURCE_LOCATION (decl), RESULT_DECL, NULL_TREE,\n+\t\t  TREE_TYPE (type));\n+\n+  DECL_ARTIFICIAL (result_decl) = 1;\n+  DECL_IGNORED_P (result_decl) = 1;\n+  DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);\n+  DECL_RESULT (decl) = result_decl;\n+\n+  TREE_READONLY (decl) = TYPE_READONLY (type);\n+  TREE_SIDE_EFFECTS (decl) = TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);\n+}\n \f\n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n    body.  This routine needs to be invoked before processing the declarations\n@@ -3992,6 +3958,7 @@ update_pointer_to (tree old_type, tree new_type)\n \t\t\t TYPE_OBJECT_RECORD_TYPE (new_type));\n \n       TYPE_POINTER_TO (old_type) = NULL_TREE;\n+      TYPE_REFERENCE_TO (old_type) = NULL_TREE;\n     }\n }\n \f"}, {"sha": "c700245fef528775984542cc22cb4bd02b958d87", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -933,8 +933,12 @@ package body Sem_Aux is\n          declare\n             Ftyp : constant Entity_Id := Full_View (Btype);\n          begin\n+            --  Return true for a tagged incomplete type built as a shadow\n+            --  entity in Build_Limited_Views. It can appear in the profile\n+            --  of a thunk and the back end needs to know how it is passed.\n+\n             if No (Ftyp) then\n-               return False;\n+               return Is_Tagged_Type (Btype);\n             else\n                return Is_By_Reference_Type (Ftyp);\n             end if;"}, {"sha": "9b821485155e23377e4e950bf6c97a60ff8974ee", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -2148,6 +2148,7 @@ package body Sem_Ch6 is\n       Body_Spec    : Node_Id             := Specification (N);\n       Body_Id      : Entity_Id           := Defining_Entity (Body_Spec);\n       Prev_Id      : constant Entity_Id  := Current_Entity_In_Scope (Body_Id);\n+      Exch_Views   : Elist_Id            := No_Elist;\n       Conformant   : Boolean;\n       HSS          : Node_Id;\n       Prot_Typ     : Entity_Id := Empty;\n@@ -2214,16 +2215,20 @@ package body Sem_Ch6 is\n       --  mechanism is used to find the corresponding spec of the primitive\n       --  body.\n \n-      procedure Exchange_Limited_Views (Subp_Id : Entity_Id);\n+      function Exchange_Limited_Views (Subp_Id : Entity_Id) return Elist_Id;\n       --  Ada 2012 (AI05-0151): Detect whether the profile of Subp_Id contains\n-      --  incomplete types coming from a limited context and swap their limited\n-      --  views with the non-limited ones.\n+      --  incomplete types coming from a limited context and replace their\n+      --  limited views with the non-limited ones. Return the list of changes\n+      --  to be used to undo the transformation.\n \n       function Is_Private_Concurrent_Primitive\n         (Subp_Id : Entity_Id) return Boolean;\n       --  Determine whether subprogram Subp_Id is a primitive of a concurrent\n       --  type that implements an interface and has a private view.\n \n+      procedure Restore_Limited_Views (Restore_List : Elist_Id);\n+      --  Undo the transformation done by Exchange_Limited_Views.\n+\n       procedure Set_Trivial_Subprogram (N : Node_Id);\n       --  Sets the Is_Trivial_Subprogram flag in both spec and body of the\n       --  subprogram whose body is being analyzed. N is the statement node\n@@ -2870,7 +2875,9 @@ package body Sem_Ch6 is\n       -- Exchange_Limited_Views --\n       ----------------------------\n \n-      procedure Exchange_Limited_Views (Subp_Id : Entity_Id) is\n+      function Exchange_Limited_Views (Subp_Id : Entity_Id) return Elist_Id is\n+         Result : Elist_Id := No_Elist;\n+\n          procedure Detect_And_Exchange (Id : Entity_Id);\n          --  Determine whether Id's type denotes an incomplete type associated\n          --  with a limited with clause and exchange the limited view with the\n@@ -2890,6 +2897,12 @@ package body Sem_Ch6 is\n               and then Has_Non_Limited_View (Typ)\n               and then not From_Limited_With (Scope (Typ))\n             then\n+               if No (Result) then\n+                  Result := New_Elmt_List;\n+               end if;\n+\n+               Prepend_Elmt (Typ, Result);\n+               Prepend_Elmt (Id, Result);\n                Set_Etype (Id, Non_Limited_View (Typ));\n             end if;\n          end Detect_And_Exchange;\n@@ -2902,13 +2915,13 @@ package body Sem_Ch6 is\n \n       begin\n          if No (Subp_Id) then\n-            return;\n+            return No_Elist;\n \n          --  Do not process subprogram bodies as they already use the non-\n          --  limited view of types.\n \n          elsif not Ekind_In (Subp_Id, E_Function, E_Procedure) then\n-            return;\n+            return No_Elist;\n          end if;\n \n          --  Examine all formals and swap views when applicable\n@@ -2925,6 +2938,8 @@ package body Sem_Ch6 is\n          if Ekind (Subp_Id) = E_Function then\n             Detect_And_Exchange (Subp_Id);\n          end if;\n+\n+         return Result;\n       end Exchange_Limited_Views;\n \n       -------------------------------------\n@@ -2960,6 +2975,23 @@ package body Sem_Ch6 is\n          return False;\n       end Is_Private_Concurrent_Primitive;\n \n+      ---------------------------\n+      -- Restore_Limited_Views --\n+      ---------------------------\n+\n+      procedure Restore_Limited_Views (Restore_List : Elist_Id) is\n+         Elmt : Elmt_Id := First_Elmt (Restore_List);\n+         Id   : Entity_Id;\n+\n+      begin\n+         while Present (Elmt) loop\n+            Id := Node (Elmt);\n+            Next_Elmt (Elmt);\n+            Set_Etype (Id, Node (Elmt));\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end Restore_Limited_Views;\n+\n       ----------------------------\n       -- Set_Trivial_Subprogram --\n       ----------------------------\n@@ -3887,7 +3919,7 @@ package body Sem_Ch6 is\n       --  spec, swap any limited views with their non-limited counterpart.\n \n       if Ada_Version >= Ada_2012 then\n-         Exchange_Limited_Views (Spec_Id);\n+         Exch_Views := Exchange_Limited_Views (Spec_Id);\n       end if;\n \n       --  Analyze any aspect specifications that appear on the subprogram body\n@@ -4152,6 +4184,13 @@ package body Sem_Ch6 is\n          end if;\n       end;\n \n+      --  Restore the limited views in the spec, if any, to let the back end\n+      --  process it without running into circularities.\n+\n+      if Exch_Views /= No_Elist then\n+         Restore_Limited_Views (Exch_Views);\n+      end if;\n+\n       Ghost_Mode := Save_Ghost_Mode;\n    end Analyze_Subprogram_Body_Helper;\n \n@@ -5269,10 +5308,7 @@ package body Sem_Ch6 is\n       procedure Possible_Freeze (T : Entity_Id);\n       --  T is the type of either a formal parameter or of the return type.\n       --  If T is not yet frozen and needs a delayed freeze, then the\n-      --  subprogram itself must be delayed. If T is the limited view of an\n-      --  incomplete type (or of a CW type thereof) the subprogram must be\n-      --  frozen as well, because T may depend on local types that have not\n-      --  been frozen yet.\n+      --  subprogram itself must be delayed.\n \n       ---------------------\n       -- Possible_Freeze --\n@@ -5288,20 +5324,6 @@ package body Sem_Ch6 is\n            and then not Is_Frozen (Designated_Type (T))\n          then\n             Set_Has_Delayed_Freeze (Designator);\n-\n-         elsif (Ekind (T) = E_Incomplete_Type\n-                 or else Ekind (T) = E_Class_Wide_Type)\n-           and then From_Limited_With (T)\n-         then\n-            Set_Has_Delayed_Freeze (Designator);\n-\n-         --  AI05-0151: In Ada 2012, Incomplete types can appear in the profile\n-         --  of a subprogram or entry declaration.\n-\n-         elsif Ekind (T) = E_Incomplete_Type\n-           and then Ada_Version >= Ada_2012\n-         then\n-            Set_Has_Delayed_Freeze (Designator);\n          end if;\n \n       end Possible_Freeze;\n@@ -10451,9 +10473,7 @@ package body Sem_Ch6 is\n                --  it is still the case that untagged incomplete types cannot\n                --  be Taft-amendment types and must be completed in private\n                --  part, so the subprogram must appear in the list of private\n-               --  dependents of the type. If the type is class-wide, it is\n-               --  not a primitive, but the freezing of the subprogram must\n-               --  also be delayed to force the creation of a freeze node.\n+               --  dependents of the type.\n \n                if Is_Tagged_Type (Formal_Type)\n                  or else (Ada_Version >= Ada_2012\n@@ -10462,19 +10482,14 @@ package body Sem_Ch6 is\n                then\n                   if Ekind (Scope (Current_Scope)) = E_Package\n                     and then not Is_Generic_Type (Formal_Type)\n+                    and then not Is_Class_Wide_Type (Formal_Type)\n                   then\n                      if not Nkind_In\n                        (Parent (T), N_Access_Function_Definition,\n                                     N_Access_Procedure_Definition)\n                      then\n-                        --  A limited view has no private dependents\n-\n-                        if not Is_Class_Wide_Type (Formal_Type)\n-                          and then not From_Limited_With (Formal_Type)\n-                        then\n-                           Append_Elmt (Current_Scope,\n-                             Private_Dependents (Base_Type (Formal_Type)));\n-                        end if;\n+                        Append_Elmt (Current_Scope,\n+                          Private_Dependents (Base_Type (Formal_Type)));\n \n                         --  Freezing is delayed to ensure that Register_Prim\n                         --  will get called for this operation, which is needed\n@@ -10728,19 +10743,6 @@ package body Sem_Ch6 is\n \n       if Nkind (Related_Nod) = N_Function_Specification then\n          Analyze_Return_Type (Related_Nod);\n-\n-         --  If return type is class-wide, subprogram freezing may be\n-         --  delayed as well, unless the declaration is a compilation unit\n-         --  in which case the freeze node would appear too late.\n-\n-         if Is_Class_Wide_Type (Etype (Current_Scope))\n-           and then not Is_Thunk (Current_Scope)\n-           and then not Is_Compilation_Unit (Current_Scope)\n-           and then Nkind (Unit_Declaration_Node (Current_Scope)) =\n-             N_Subprogram_Declaration\n-         then\n-            Set_Has_Delayed_Freeze (Current_Scope);\n-         end if;\n       end if;\n \n       --  Now set the kind (mode) of each formal"}, {"sha": "c207235ed78e434ae2aa80acd45fcb6146eabf43", "filename": "gcc/ada/types.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -351,9 +351,6 @@ typedef Int Mechanism_Type;\n #define By_Short_Descriptor_NCA  (-18)\n #define By_Short_Descriptor_Last (-18)\n \n-/* Internal to Gigi.  */\n-#define By_Copy_Return     (-128)\n-\n /* Definitions of Reason codes for Raise_xxx_Error nodes */\n #define CE_Access_Check_Failed              0\n #define CE_Access_Parameter_Is_Null         1"}, {"sha": "b1ab13d203e4d1e6dba14ed4e4838d5fd843f898", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -1,3 +1,8 @@\n+2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/limited_with4.ad[sb]: New test.\n+\t* gnat.dg/limited_with4_pkg.ads: New helper.\n+\n 2016-04-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/70155"}, {"sha": "0d3f530c4f4250f6f369f314c2eec2547951eab0", "filename": "gcc/testsuite/gnat.dg/limited_with4.adb", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4.adb?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -0,0 +1,43 @@\n+-- { dg-do compile }\n+\n+with Limited_With4_Pkg;\n+\n+package body Limited_With4 is\n+\n+  procedure Proc1 (A : Limited_With4_Pkg.Rec12 ; I : Integer) is\n+  begin\n+    if A.R.I /= I then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+  function Func1 (I : Integer) return Limited_With4_Pkg.Rec12 is\n+  begin\n+    return (I => I, R => (I => I));\n+  end;\n+\n+  procedure Proc2 (A : Limited_With4_Pkg.Rec22 ; I : Integer) is\n+  begin\n+    if A.R.I /= I then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+  function Func2 (I : Integer) return Limited_With4_Pkg.Rec22 is\n+  begin\n+    return (I => I, R => (I => I));\n+  end;\n+\n+  procedure Proc3 (A : Limited_With4_Pkg.Rec12 ; B : Limited_With4_Pkg.Rec22) is\n+  begin\n+    if A.R.I /= B.R.I then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+  function Func3 (A : Limited_With4_Pkg.Rec12) return Limited_With4_Pkg.Rec22 is\n+  begin\n+    return (I => A.R.I, R => (I => A.R.I));\n+  end;\n+\n+end Limited_With4;"}, {"sha": "bcf77e585c64530cf2b32ef71221951fa24da4af", "filename": "gcc/testsuite/gnat.dg/limited_with4.ads", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4.ads?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -0,0 +1,29 @@\n+limited with Limited_With4_Pkg;\n+\n+package Limited_With4 is\n+\n+  type Ptr1 is access procedure (A : Limited_With4_Pkg.Rec12; I : Integer);\n+\n+  type Ptr2 is access procedure (A : Limited_With4_Pkg.Rec22; I : Integer);\n+\n+  type Rec1 is record\n+    I : Integer;\n+  end record;\n+\n+  procedure Proc1 (A : Limited_With4_Pkg.Rec12 ; I : Integer);\n+\n+  function Func1 (I : Integer) return Limited_With4_Pkg.Rec12;\n+\n+  procedure Proc2 (A : Limited_With4_Pkg.Rec22 ; I : Integer);\n+\n+  function Func2 (I : Integer) return Limited_With4_Pkg.Rec22;\n+\n+  type Rec2 is record\n+    I : Integer;\n+  end record;\n+\n+  procedure Proc3 (A : Limited_With4_Pkg.Rec12 ; B : Limited_With4_Pkg.Rec22);\n+\n+  function Func3 (A : Limited_With4_Pkg.Rec12) return Limited_With4_Pkg.Rec22;\n+\n+end Limited_With4;"}, {"sha": "38fe7aeeb4c14d6e515541b2715640bf9fefb295", "filename": "gcc/testsuite/gnat.dg/limited_with4_pkg.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e55d29a0c643ebef76b6056077e9f78686669d6/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with4_pkg.ads?ref=1e55d29a0c643ebef76b6056077e9f78686669d6", "patch": "@@ -0,0 +1,19 @@\n+with Limited_With4;\n+\n+package Limited_With4_Pkg is\n+\n+  P1 : Limited_With4.Ptr1 := Limited_With4.Proc1'Access;\n+\n+  P2 : Limited_With4.Ptr2 := Limited_With4.Proc2'Access;\n+\n+  type Rec12 is record\n+    I : Integer;\n+    R : Limited_With4.Rec1;\n+  end record;\n+\n+  type Rec22 is record\n+    I : Integer;\n+    R : Limited_With4.Rec2;\n+  end record;\n+\n+end Limited_With4_Pkg;"}]}