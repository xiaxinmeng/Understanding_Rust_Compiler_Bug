{"sha": "fe985a236327c9d95a1b667abe7eb31afc9eb61c", "node_id": "C_kwDOANBUbNoAKGZlOTg1YTIzNjMyN2M5ZDk1YTFiNjY3YWJlN2ViMzFhZmM5ZWI2MWM", "commit": {"author": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2022-10-04T17:15:12Z"}, "committer": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2022-11-21T16:00:37Z"}, "message": "Remove prototype for number_of_iterations_popcount\n\ngcc/ChangeLog:\n\n\t* tree-ssa-loop-niter.cc (ssa_defined_by_minus_one_stmt_p): Move\n\t(number_of_iterations_popcount): Move, and remove separate prototype.", "tree": {"sha": "be8a7af2cae688e4f5b5d04c1fd1352de4550ee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be8a7af2cae688e4f5b5d04c1fd1352de4550ee5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe985a236327c9d95a1b667abe7eb31afc9eb61c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe985a236327c9d95a1b667abe7eb31afc9eb61c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe985a236327c9d95a1b667abe7eb31afc9eb61c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe985a236327c9d95a1b667abe7eb31afc9eb61c/comments", "author": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0e4f676aab589e53dbd67610378a1769030f462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0e4f676aab589e53dbd67610378a1769030f462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0e4f676aab589e53dbd67610378a1769030f462"}], "stats": {"total": 396, "additions": 194, "deletions": 202}, "files": [{"sha": "0af34e46580bb9a6f9b40e09c9f29b8454a4aaf6", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 194, "deletions": 202, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe985a236327c9d95a1b667abe7eb31afc9eb61c/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe985a236327c9d95a1b667abe7eb31afc9eb61c/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=fe985a236327c9d95a1b667abe7eb31afc9eb61c", "patch": "@@ -63,11 +63,6 @@ struct bounds\n   mpz_t below, up;\n };\n \n-static bool number_of_iterations_popcount (loop_p loop, edge exit,\n-\t\t\t\t\t   enum tree_code code,\n-\t\t\t\t\t   class tree_niter_desc *niter);\n-\n-\n /* Splits expression EXPR to a variable part VAR and constant OFFSET.  */\n \n static void\n@@ -2031,6 +2026,200 @@ number_of_iterations_cond (class loop *loop,\n   return ret;\n }\n \n+/* Utility function to check if OP is defined by a stmt\n+   that is a val - 1.  */\n+\n+static bool\n+ssa_defined_by_minus_one_stmt_p (tree op, tree val)\n+{\n+  gimple *stmt;\n+  return (TREE_CODE (op) == SSA_NAME\n+\t  && (stmt = SSA_NAME_DEF_STMT (op))\n+\t  && is_gimple_assign (stmt)\n+\t  && (gimple_assign_rhs_code (stmt) == PLUS_EXPR)\n+\t  && val == gimple_assign_rhs1 (stmt)\n+\t  && integer_minus_onep (gimple_assign_rhs2 (stmt)));\n+}\n+\n+/* See if LOOP is a popcout implementation, determine NITER for the loop\n+\n+   We match:\n+   <bb 2>\n+   goto <bb 4>\n+\n+   <bb 3>\n+   _1 = b_11 + -1\n+   b_6 = _1 & b_11\n+\n+   <bb 4>\n+   b_11 = PHI <b_5(D)(2), b_6(3)>\n+\n+   exit block\n+   if (b_11 != 0)\n+\tgoto <bb 3>\n+   else\n+\tgoto <bb 5>\n+\n+   OR we match copy-header version:\n+   if (b_5 != 0)\n+\tgoto <bb 3>\n+   else\n+\tgoto <bb 4>\n+\n+   <bb 3>\n+   b_11 = PHI <b_5(2), b_6(3)>\n+   _1 = b_11 + -1\n+   b_6 = _1 & b_11\n+\n+   exit block\n+   if (b_6 != 0)\n+\tgoto <bb 3>\n+   else\n+\tgoto <bb 4>\n+\n+   If popcount pattern, update NITER accordingly.\n+   i.e., set NITER to  __builtin_popcount (b)\n+   return true if we did, false otherwise.\n+\n+ */\n+\n+static bool\n+number_of_iterations_popcount (loop_p loop, edge exit,\n+\t\t\t       enum tree_code code,\n+\t\t\t       class tree_niter_desc *niter)\n+{\n+  bool adjust = true;\n+  tree iter;\n+  HOST_WIDE_INT max;\n+  adjust = true;\n+  tree fn = NULL_TREE;\n+\n+  /* Check loop terminating branch is like\n+     if (b != 0).  */\n+  gimple *stmt = last_stmt (exit->src);\n+  if (!stmt\n+      || gimple_code (stmt) != GIMPLE_COND\n+      || code != NE_EXPR\n+      || !integer_zerop (gimple_cond_rhs (stmt))\n+      || TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME)\n+    return false;\n+\n+  gimple *and_stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));\n+\n+  /* Depending on copy-header is performed, feeding PHI stmts might be in\n+     the loop header or loop latch, handle this.  */\n+  if (gimple_code (and_stmt) == GIMPLE_PHI\n+      && gimple_bb (and_stmt) == loop->header\n+      && gimple_phi_num_args (and_stmt) == 2\n+      && (TREE_CODE (gimple_phi_arg_def (and_stmt,\n+\t\t\t\t\t loop_latch_edge (loop)->dest_idx))\n+\t  == SSA_NAME))\n+    {\n+      /* SSA used in exit condition is defined by PHI stmt\n+\tb_11 = PHI <b_5(D)(2), b_6(3)>\n+\tfrom the PHI stmt, get the and_stmt\n+\tb_6 = _1 & b_11.  */\n+      tree t = gimple_phi_arg_def (and_stmt, loop_latch_edge (loop)->dest_idx);\n+      and_stmt = SSA_NAME_DEF_STMT (t);\n+      adjust = false;\n+    }\n+\n+  /* Make sure it is indeed an and stmt (b_6 = _1 & b_11).  */\n+  if (!is_gimple_assign (and_stmt)\n+      || gimple_assign_rhs_code (and_stmt) != BIT_AND_EXPR)\n+    return false;\n+\n+  tree b_11 = gimple_assign_rhs1 (and_stmt);\n+  tree _1 = gimple_assign_rhs2 (and_stmt);\n+\n+  /* Check that _1 is defined by _b11 + -1 (_1 = b_11 + -1).\n+     Also make sure that b_11 is the same in and_stmt and _1 defining stmt.\n+     Also canonicalize if _1 and _b11 are revrsed.  */\n+  if (ssa_defined_by_minus_one_stmt_p (b_11, _1))\n+    std::swap (b_11, _1);\n+  else if (ssa_defined_by_minus_one_stmt_p (_1, b_11))\n+    ;\n+  else\n+    return false;\n+  /* Check the recurrence:\n+   ... = PHI <b_5(2), b_6(3)>.  */\n+  gimple *phi = SSA_NAME_DEF_STMT (b_11);\n+  if (gimple_code (phi) != GIMPLE_PHI\n+      || (gimple_bb (phi) != loop_latch_edge (loop)->dest)\n+      || (gimple_assign_lhs (and_stmt)\n+\t  != gimple_phi_arg_def (phi, loop_latch_edge (loop)->dest_idx)))\n+    return false;\n+\n+  /* We found a match. Get the corresponding popcount builtin.  */\n+  tree src = gimple_phi_arg_def (phi, loop_preheader_edge (loop)->dest_idx);\n+  if (TYPE_PRECISION (TREE_TYPE (src)) <= TYPE_PRECISION (integer_type_node))\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNT);\n+  else if (TYPE_PRECISION (TREE_TYPE (src))\n+\t   == TYPE_PRECISION (long_integer_type_node))\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTL);\n+  else if (TYPE_PRECISION (TREE_TYPE (src))\n+\t   == TYPE_PRECISION (long_long_integer_type_node)\n+\t   || (TYPE_PRECISION (TREE_TYPE (src))\n+\t       == 2 * TYPE_PRECISION (long_long_integer_type_node)))\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTLL);\n+\n+  if (!fn)\n+    return false;\n+\n+  /* Update NITER params accordingly  */\n+  tree utype = unsigned_type_for (TREE_TYPE (src));\n+  src = fold_convert (utype, src);\n+  if (TYPE_PRECISION (TREE_TYPE (src)) < TYPE_PRECISION (integer_type_node))\n+    src = fold_convert (unsigned_type_node, src);\n+  tree call;\n+  if (TYPE_PRECISION (TREE_TYPE (src))\n+      == 2 * TYPE_PRECISION (long_long_integer_type_node))\n+    {\n+      int prec = TYPE_PRECISION (long_long_integer_type_node);\n+      tree src1 = fold_convert (long_long_unsigned_type_node,\n+\t\t\t\tfold_build2 (RSHIFT_EXPR, TREE_TYPE (src),\n+\t\t\t\t\t     unshare_expr (src),\n+\t\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t    prec)));\n+      tree src2 = fold_convert (long_long_unsigned_type_node, src);\n+      call = build_call_expr (fn, 1, src1);\n+      call = fold_build2 (PLUS_EXPR, TREE_TYPE (call), call,\n+\t\t\t  build_call_expr (fn, 1, src2));\n+      call = fold_convert (utype, call);\n+    }\n+  else\n+    call = fold_convert (utype, build_call_expr (fn, 1, src));\n+  if (adjust)\n+    iter = fold_build2 (MINUS_EXPR, utype, call, build_int_cst (utype, 1));\n+  else\n+    iter = call;\n+\n+  if (TREE_CODE (call) == INTEGER_CST)\n+    max = tree_to_uhwi (call);\n+  else\n+    max = TYPE_PRECISION (TREE_TYPE (src));\n+  if (adjust)\n+    max = max - 1;\n+\n+  niter->niter = iter;\n+  niter->assumptions = boolean_true_node;\n+\n+  if (adjust)\n+    {\n+      tree may_be_zero = fold_build2 (EQ_EXPR, boolean_type_node, src,\n+\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n+      niter->may_be_zero\n+\t= simplify_using_initial_conditions (loop, may_be_zero);\n+    }\n+  else\n+    niter->may_be_zero = boolean_false_node;\n+\n+  niter->max = max;\n+  niter->bound = NULL_TREE;\n+  niter->cmp = ERROR_MARK;\n+  return true;\n+}\n+\n /* Substitute NEW_TREE for OLD in EXPR and fold the result.\n    If VALUEIZE is non-NULL then OLD and NEW_TREE are ignored and instead\n    all SSA names are replaced with the result of calling the VALUEIZE\n@@ -2648,203 +2837,6 @@ number_of_iterations_exit_assumptions (class loop *loop, edge exit,\n   return (!integer_zerop (niter->assumptions));\n }\n \n-\n-/* Utility function to check if OP is defined by a stmt\n-   that is a val - 1.  */\n-\n-static bool\n-ssa_defined_by_minus_one_stmt_p (tree op, tree val)\n-{\n-  gimple *stmt;\n-  return (TREE_CODE (op) == SSA_NAME\n-\t  && (stmt = SSA_NAME_DEF_STMT (op))\n-\t  && is_gimple_assign (stmt)\n-\t  && (gimple_assign_rhs_code (stmt) == PLUS_EXPR)\n-\t  && val == gimple_assign_rhs1 (stmt)\n-\t  && integer_minus_onep (gimple_assign_rhs2 (stmt)));\n-}\n-\n-\n-/* See if LOOP is a popcout implementation, determine NITER for the loop\n-\n-   We match:\n-   <bb 2>\n-   goto <bb 4>\n-\n-   <bb 3>\n-   _1 = b_11 + -1\n-   b_6 = _1 & b_11\n-\n-   <bb 4>\n-   b_11 = PHI <b_5(D)(2), b_6(3)>\n-\n-   exit block\n-   if (b_11 != 0)\n-\tgoto <bb 3>\n-   else\n-\tgoto <bb 5>\n-\n-   OR we match copy-header version:\n-   if (b_5 != 0)\n-\tgoto <bb 3>\n-   else\n-\tgoto <bb 4>\n-\n-   <bb 3>\n-   b_11 = PHI <b_5(2), b_6(3)>\n-   _1 = b_11 + -1\n-   b_6 = _1 & b_11\n-\n-   exit block\n-   if (b_6 != 0)\n-\tgoto <bb 3>\n-   else\n-\tgoto <bb 4>\n-\n-   If popcount pattern, update NITER accordingly.\n-   i.e., set NITER to  __builtin_popcount (b)\n-   return true if we did, false otherwise.\n-\n- */\n-\n-static bool\n-number_of_iterations_popcount (loop_p loop, edge exit,\n-\t\t\t       enum tree_code code,\n-\t\t\t       class tree_niter_desc *niter)\n-{\n-  bool adjust = true;\n-  tree iter;\n-  HOST_WIDE_INT max;\n-  adjust = true;\n-  tree fn = NULL_TREE;\n-\n-  /* Check loop terminating branch is like\n-     if (b != 0).  */\n-  gimple *stmt = last_stmt (exit->src);\n-  if (!stmt\n-      || gimple_code (stmt) != GIMPLE_COND\n-      || code != NE_EXPR\n-      || !integer_zerop (gimple_cond_rhs (stmt))\n-      || TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME)\n-    return false;\n-\n-  gimple *and_stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));\n-\n-  /* Depending on copy-header is performed, feeding PHI stmts might be in\n-     the loop header or loop latch, handle this.  */\n-  if (gimple_code (and_stmt) == GIMPLE_PHI\n-      && gimple_bb (and_stmt) == loop->header\n-      && gimple_phi_num_args (and_stmt) == 2\n-      && (TREE_CODE (gimple_phi_arg_def (and_stmt,\n-\t\t\t\t\t loop_latch_edge (loop)->dest_idx))\n-\t  == SSA_NAME))\n-    {\n-      /* SSA used in exit condition is defined by PHI stmt\n-\tb_11 = PHI <b_5(D)(2), b_6(3)>\n-\tfrom the PHI stmt, get the and_stmt\n-\tb_6 = _1 & b_11.  */\n-      tree t = gimple_phi_arg_def (and_stmt, loop_latch_edge (loop)->dest_idx);\n-      and_stmt = SSA_NAME_DEF_STMT (t);\n-      adjust = false;\n-    }\n-\n-  /* Make sure it is indeed an and stmt (b_6 = _1 & b_11).  */\n-  if (!is_gimple_assign (and_stmt)\n-      || gimple_assign_rhs_code (and_stmt) != BIT_AND_EXPR)\n-    return false;\n-\n-  tree b_11 = gimple_assign_rhs1 (and_stmt);\n-  tree _1 = gimple_assign_rhs2 (and_stmt);\n-\n-  /* Check that _1 is defined by _b11 + -1 (_1 = b_11 + -1).\n-     Also make sure that b_11 is the same in and_stmt and _1 defining stmt.\n-     Also canonicalize if _1 and _b11 are revrsed.  */\n-  if (ssa_defined_by_minus_one_stmt_p (b_11, _1))\n-    std::swap (b_11, _1);\n-  else if (ssa_defined_by_minus_one_stmt_p (_1, b_11))\n-    ;\n-  else\n-    return false;\n-  /* Check the recurrence:\n-   ... = PHI <b_5(2), b_6(3)>.  */\n-  gimple *phi = SSA_NAME_DEF_STMT (b_11);\n-  if (gimple_code (phi) != GIMPLE_PHI\n-      || (gimple_bb (phi) != loop_latch_edge (loop)->dest)\n-      || (gimple_assign_lhs (and_stmt)\n-\t  != gimple_phi_arg_def (phi, loop_latch_edge (loop)->dest_idx)))\n-    return false;\n-\n-  /* We found a match. Get the corresponding popcount builtin.  */\n-  tree src = gimple_phi_arg_def (phi, loop_preheader_edge (loop)->dest_idx);\n-  if (TYPE_PRECISION (TREE_TYPE (src)) <= TYPE_PRECISION (integer_type_node))\n-    fn = builtin_decl_implicit (BUILT_IN_POPCOUNT);\n-  else if (TYPE_PRECISION (TREE_TYPE (src))\n-\t   == TYPE_PRECISION (long_integer_type_node))\n-    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTL);\n-  else if (TYPE_PRECISION (TREE_TYPE (src))\n-\t   == TYPE_PRECISION (long_long_integer_type_node)\n-\t   || (TYPE_PRECISION (TREE_TYPE (src))\n-\t       == 2 * TYPE_PRECISION (long_long_integer_type_node)))\n-    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTLL);\n-\n-  if (!fn)\n-    return false;\n-\n-  /* Update NITER params accordingly  */\n-  tree utype = unsigned_type_for (TREE_TYPE (src));\n-  src = fold_convert (utype, src);\n-  if (TYPE_PRECISION (TREE_TYPE (src)) < TYPE_PRECISION (integer_type_node))\n-    src = fold_convert (unsigned_type_node, src);\n-  tree call;\n-  if (TYPE_PRECISION (TREE_TYPE (src))\n-      == 2 * TYPE_PRECISION (long_long_integer_type_node))\n-    {\n-      int prec = TYPE_PRECISION (long_long_integer_type_node);\n-      tree src1 = fold_convert (long_long_unsigned_type_node,\n-\t\t\t\tfold_build2 (RSHIFT_EXPR, TREE_TYPE (src),\n-\t\t\t\t\t     unshare_expr (src),\n-\t\t\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t\t\t    prec)));\n-      tree src2 = fold_convert (long_long_unsigned_type_node, src);\n-      call = build_call_expr (fn, 1, src1);\n-      call = fold_build2 (PLUS_EXPR, TREE_TYPE (call), call,\n-\t\t\t  build_call_expr (fn, 1, src2));\n-      call = fold_convert (utype, call);\n-    }\n-  else\n-    call = fold_convert (utype, build_call_expr (fn, 1, src));\n-  if (adjust)\n-    iter = fold_build2 (MINUS_EXPR, utype, call, build_int_cst (utype, 1));\n-  else\n-    iter = call;\n-\n-  if (TREE_CODE (call) == INTEGER_CST)\n-    max = tree_to_uhwi (call);\n-  else\n-    max = TYPE_PRECISION (TREE_TYPE (src));\n-  if (adjust)\n-    max = max - 1;\n-\n-  niter->niter = iter;\n-  niter->assumptions = boolean_true_node;\n-\n-  if (adjust)\n-    {\n-      tree may_be_zero = fold_build2 (EQ_EXPR, boolean_type_node, src,\n-\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n-      niter->may_be_zero\n-\t= simplify_using_initial_conditions (loop, may_be_zero);\n-    }\n-  else\n-    niter->may_be_zero = boolean_false_node;\n-\n-  niter->max = max;\n-  niter->bound = NULL_TREE;\n-  niter->cmp = ERROR_MARK;\n-  return true;\n-}\n-\n-\n /* Like number_of_iterations_exit_assumptions, but return TRUE only if\n    the niter information holds unconditionally.  */\n "}]}