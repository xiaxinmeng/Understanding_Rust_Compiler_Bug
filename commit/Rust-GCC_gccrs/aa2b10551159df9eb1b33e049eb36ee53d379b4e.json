{"sha": "aa2b10551159df9eb1b33e049eb36ee53d379b4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyYjEwNTUxMTU5ZGY5ZWIxYjMzZTA0OWViMzZlZTUzZDM3OWI0ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-04-23T20:49:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-04-23T20:49:38Z"}, "message": "PR c++/69560 - wrong alignof(double) on x86.\n\n\tCWG 1879 - Inadequate definition of alignment requirement.\n\t* cp-tree.h (ALIGNOF_EXPR_STD_P): New.\n\t* typeck.c (cxx_sizeof_or_alignof_type): Add std_alignof parm.\n\t(cxx_sizeof_expr, cxx_sizeof_nowarn, cxx_alignas_expr)\n\t(cxx_alignof_expr): Pass it.\n\t* parser.c (cp_parser_unary_expression): Pass it.\n\t* pt.c (tsubst_copy): Copy it.\n\t(tsubst_copy_and_build): Pass it.\n\t* decl.c (fold_sizeof_expr): Pass it.\n\nFrom-SVN: r259578", "tree": {"sha": "57df381f854d498e1870295c71d1c59e390e02d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57df381f854d498e1870295c71d1c59e390e02d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa2b10551159df9eb1b33e049eb36ee53d379b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2b10551159df9eb1b33e049eb36ee53d379b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2b10551159df9eb1b33e049eb36ee53d379b4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2b10551159df9eb1b33e049eb36ee53d379b4e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71fbbf65fa775dfe4a3fde9f20008389f9e0e53f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fbbf65fa775dfe4a3fde9f20008389f9e0e53f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71fbbf65fa775dfe4a3fde9f20008389f9e0e53f"}], "stats": {"total": 72, "additions": 55, "deletions": 17}, "files": [{"sha": "365592f5657e5fbf90be462b700ac700e92f66ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -1,3 +1,16 @@\n+2018-04-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/69560 - wrong alignof(double) on x86.\n+\tCWG 1879 - Inadequate definition of alignment requirement.\n+\t* cp-tree.h (ALIGNOF_EXPR_STD_P): New.\n+\t* typeck.c (cxx_sizeof_or_alignof_type): Add std_alignof parm.\n+\t(cxx_sizeof_expr, cxx_sizeof_nowarn, cxx_alignas_expr)\n+\t(cxx_alignof_expr): Pass it.\n+\t* parser.c (cp_parser_unary_expression): Pass it.\n+\t* pt.c (tsubst_copy): Copy it.\n+\t(tsubst_copy_and_build): Pass it.\n+\t* decl.c (fold_sizeof_expr): Pass it.\n+\n 2018-04-23  Jakub Jelinek  <jakub@redhat.com>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "37770770acbeeb95217135c92b4a57151065be22", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -372,6 +372,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       TEMPLATE_TYPE_PARM_FOR_CLASS (TEMPLATE_TYPE_PARM)\n       DECL_NAMESPACE_INLINE_P (in NAMESPACE_DECL)\n       SWITCH_STMT_ALL_CASES_P (in SWITCH_STMT)\n+      ALIGNOF_EXPR_STD_P (in ALIGNOF_EXPR)\n    1: IDENTIFIER_KIND_BIT_1 (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -4954,6 +4955,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define SIZEOF_EXPR_TYPE_P(NODE) \\\n   TREE_LANG_FLAG_0 (SIZEOF_EXPR_CHECK (NODE))\n \n+/* True if the ALIGNOF_EXPR was spelled \"alignof\".  */\n+#define ALIGNOF_EXPR_STD_P(NODE) \\\n+  TREE_LANG_FLAG_0 (ALIGNOF_EXPR_CHECK (NODE))\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types {\n   none_type = 0, /* Not a tag type.  */\n@@ -7195,7 +7200,7 @@ extern int comp_cv_qualification\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(int, int);\n extern int comp_cv_qual_signature\t\t(tree, tree);\n extern tree cxx_sizeof_or_alignof_expr\t\t(tree, enum tree_code, bool);\n-extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n+extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool, bool);\n extern tree cxx_alignas_expr                    (tree);\n extern tree cxx_sizeof_nowarn                   (tree);\n extern tree is_bitfield_expr_with_lowered_type  (const_tree);\n@@ -7292,7 +7297,7 @@ extern tree cp_build_binary_op                  (location_t,\n extern tree build_x_vec_perm_expr               (location_t,\n \t\t\t\t\t\t tree, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n-#define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, true)\n+#define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, false, true)\n extern tree build_simple_component_ref\t\t(tree, tree);\n extern tree build_ptrmemfunc_access_expr\t(tree, tree);\n extern tree build_address\t\t\t(tree);"}, {"sha": "55e234334ac626e25ff5144b81cca6ba8e5dcaec", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -9542,10 +9542,10 @@ fold_sizeof_expr (tree t)\n   tree r;\n   if (SIZEOF_EXPR_TYPE_P (t))\n     r = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (t, 0)),\n-\t\t\t\t    SIZEOF_EXPR, false);\n+\t\t\t\t    SIZEOF_EXPR, false, false);\n   else if (TYPE_P (TREE_OPERAND (t, 0)))\n     r = cxx_sizeof_or_alignof_type (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n-\t\t\t\t    false);\n+\t\t\t\t    false, false);\n   else\n     r = cxx_sizeof_or_alignof_expr (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n \t\t\t\t    false);"}, {"sha": "d8ce28a6d61a11b0a9a711218587ffd302ce7cca", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -7993,19 +7993,22 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t    location_t start_loc = token->location;\n \n \t    op = keyword == RID_ALIGNOF ? ALIGNOF_EXPR : SIZEOF_EXPR;\n+\t    bool std_alignof = id_equal (token->u.value, \"alignof\");\n+\n \t    /* Consume the token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Parse the operand.  */\n \t    operand = cp_parser_sizeof_operand (parser, keyword);\n \n \t    if (TYPE_P (operand))\n-\t      ret = cxx_sizeof_or_alignof_type (operand, op, true);\n+\t      ret = cxx_sizeof_or_alignof_type (operand, op, std_alignof,\n+\t\t\t\t\t\ttrue);\n \t    else\n \t      {\n \t\t/* ISO C++ defines alignof only with types, not with\n \t\t   expressions. So pedwarn if alignof is used with a non-\n \t\t   type expression. However, __alignof__ is ok.  */\n-\t\tif (id_equal (token->u.value, \"alignof\"))\n+\t\tif (std_alignof)\n \t\t  pedwarn (token->location, OPT_Wpedantic,\n \t\t\t   \"ISO C++ does not allow %<alignof%> \"\n \t\t\t   \"with a non-type\");"}, {"sha": "9fb819722ecbaecbbafbf5ca02159a078bbbf7b3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -15598,7 +15598,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\texpanded = make_argument_pack (expanded);\n \n \t      if (TYPE_P (expanded))\n-\t\treturn cxx_sizeof_or_alignof_type (expanded, SIZEOF_EXPR, \n+\t\treturn cxx_sizeof_or_alignof_type (expanded, SIZEOF_EXPR,\n+\t\t\t\t\t\t   false,\n \t\t\t\t\t\t   complain & tf_error);\n \t      else\n \t\treturn cxx_sizeof_or_alignof_expr (expanded, SIZEOF_EXPR,\n@@ -15636,7 +15637,10 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\treturn build1 (code, type, op0);\n+\tr = build1 (code, type, op0);\n+\tif (code == ALIGNOF_EXPR)\n+\t  ALIGNOF_EXPR_STD_P (r) = ALIGNOF_EXPR_STD_P (t);\n+\treturn r;\n       }\n \n     case COMPONENT_REF:\n@@ -18002,6 +18006,8 @@ tsubst_copy_and_build (tree t,\n \top1 = TREE_OPERAND (t, 0);\n \tif (TREE_CODE (t) == SIZEOF_EXPR && SIZEOF_EXPR_TYPE_P (t))\n \t  op1 = TREE_TYPE (op1);\n+\tbool std_alignof = (TREE_CODE (t) == ALIGNOF_EXPR\n+\t\t\t    && ALIGNOF_EXPR_STD_P (t));\n         if (!args)\n \t  {\n \t    /* When there are no ARGS, we are trying to evaluate a\n@@ -18025,7 +18031,7 @@ tsubst_copy_and_build (tree t,\n \t    --c_inhibit_evaluation_warnings;\n \t  }\n         if (TYPE_P (op1))\n-\t  r = cxx_sizeof_or_alignof_type (op1, TREE_CODE (t),\n+\t  r = cxx_sizeof_or_alignof_type (op1, TREE_CODE (t), std_alignof,\n \t\t\t\t\t  complain & tf_error);\n \telse\n \t  r = cxx_sizeof_or_alignof_expr (op1, TREE_CODE (t),"}, {"sha": "01baf6c17a39e36bc13c5abed827c9648039c3d1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -1597,10 +1597,13 @@ compparms (const_tree parms1, const_tree parms2)\n \n \f\n /* Process a sizeof or alignof expression where the operand is a\n-   type.  */\n+   type. STD_ALIGNOF indicates whether an alignof has C++11 (minimum alignment)\n+   or GNU (preferred alignment) semantics; it is ignored if op is\n+   SIZEOF_EXPR.  */\n \n tree\n-cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n+cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool std_alignof,\n+\t\t\t    bool complain)\n {\n   tree value;\n   bool dependent_p;\n@@ -1637,11 +1640,13 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n     {\n       value = build_min (op, size_type_node, type);\n       TREE_READONLY (value) = 1;\n+      if (op == ALIGNOF_EXPR && std_alignof)\n+\tALIGNOF_EXPR_STD_P (value) = true;\n       return value;\n     }\n \n   return c_sizeof_or_alignof_type (input_location, complete_type (type),\n-\t\t\t\t   op == SIZEOF_EXPR, false,\n+\t\t\t\t   op == SIZEOF_EXPR, std_alignof,\n \t\t\t\t   complain);\n }\n \n@@ -1659,7 +1664,7 @@ cxx_sizeof_nowarn (tree type)\n   else if (!COMPLETE_TYPE_P (type))\n     return size_zero_node;\n   else\n-    return cxx_sizeof_or_alignof_type (type, SIZEOF_EXPR, false);\n+    return cxx_sizeof_or_alignof_type (type, SIZEOF_EXPR, false, false);\n }\n \n /* Process a sizeof expression where the operand is an expression.  */\n@@ -1725,7 +1730,7 @@ cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n   else\n     e = TREE_TYPE (e);\n \n-  return cxx_sizeof_or_alignof_type (e, SIZEOF_EXPR, complain & tf_error);\n+  return cxx_sizeof_or_alignof_type (e, SIZEOF_EXPR, false, complain & tf_error);\n }\n \n /* Implement the __alignof keyword: Return the minimum required\n@@ -1786,7 +1791,7 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)\n       t = size_one_node;\n     }\n   else\n-    return cxx_sizeof_or_alignof_type (TREE_TYPE (e), ALIGNOF_EXPR, \n+    return cxx_sizeof_or_alignof_type (TREE_TYPE (e), ALIGNOF_EXPR, false,\n                                        complain & tf_error);\n \n   return fold_convert (size_type_node, t);\n@@ -1825,7 +1830,7 @@ cxx_alignas_expr (tree e)\n \t   alignas(type-id ), it shall have the same effect as\n \t   alignas(alignof(type-id )).  */\n \n-    return cxx_sizeof_or_alignof_type (e, ALIGNOF_EXPR, false);\n+    return cxx_sizeof_or_alignof_type (e, ALIGNOF_EXPR, true, false);\n   \n   /* If we reach this point, it means the alignas expression if of\n      the form \"alignas(assignment-expression)\", so we should follow"}, {"sha": "c9f3a8fae24b22ee20a051b55ad3b6dcf98d0f3d", "filename": "gcc/testsuite/g++.dg/abi/align2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Falign2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Falign2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Falign2.C?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/69560\n+// { dg-do compile { target { ia32 && c++11 } } }\n+\n+#define SA(X) static_assert ((X), #X)\n+SA(alignof(double) == 4);"}, {"sha": "10341477c56dc5455fddfe6c962e9ae9c8b8583d", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2b10551159df9eb1b33e049eb36ee53d379b4e/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2b10551159df9eb1b33e049eb36ee53d379b4e/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=aa2b10551159df9eb1b33e049eb36ee53d379b4e", "patch": "@@ -3046,7 +3046,8 @@ plugin_build_unary_type_expr (cc1_plugin::connection *self,\n       break;\n \n     default:\n-      result = cxx_sizeof_or_alignof_type (type, opcode, true);\n+      /* Use the C++11 alignof semantics.  */\n+      result = cxx_sizeof_or_alignof_type (type, opcode, true, true);\n     }\n \n   if (template_dependent_p)"}]}