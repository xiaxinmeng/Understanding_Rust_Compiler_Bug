{"sha": "1b4dbccc1f828fa00e6acc8b88d24301c65552df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI0ZGJjY2MxZjgyOGZhMDBlNmFjYzhiODhkMjQzMDFjNjU1NTJkZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-26T16:52:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-26T16:52:50Z"}, "message": "tree-vect-loop.c (vect_analyze_loop_operations): Analyze loop-closed PHIs that are vect_internal_def.\n\n2019-09-26  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Analyze\n\tloop-closed PHIs that are vect_internal_def.\n\t(vect_create_epilog_for_reduction): Exit early for nested cycles.\n\tSimplify.\n\t(vectorizable_lc_phi): New.\n\t* tree-vect-stmts.c (vect_analyze_stmt): Call vectorize_lc_phi.\n\t(vect_transform_stmt): Likewise.\n\t* tree-vectorizer.h (stmt_vec_info_type): Add lc_phi_info_type.\n\t(vectorizable_lc_phi): Declare.\n\nFrom-SVN: r276157", "tree": {"sha": "7ca3a6bc14aab35bbbe7b501af5cd37bee20bcdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ca3a6bc14aab35bbbe7b501af5cd37bee20bcdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b4dbccc1f828fa00e6acc8b88d24301c65552df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4dbccc1f828fa00e6acc8b88d24301c65552df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b4dbccc1f828fa00e6acc8b88d24301c65552df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4dbccc1f828fa00e6acc8b88d24301c65552df/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26cdf7bd5e9cb47f2a8761d8d5d2babf0bf5bb15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26cdf7bd5e9cb47f2a8761d8d5d2babf0bf5bb15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26cdf7bd5e9cb47f2a8761d8d5d2babf0bf5bb15"}], "stats": {"total": 120, "additions": 104, "deletions": 16}, "files": [{"sha": "66d7d86ba2f9d936f0fdd73af0ecb0faa94d5b9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b4dbccc1f828fa00e6acc8b88d24301c65552df", "patch": "@@ -1,3 +1,15 @@\n+2019-09-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Analyze\n+\tloop-closed PHIs that are vect_internal_def.\n+\t(vect_create_epilog_for_reduction): Exit early for nested cycles.\n+\tSimplify.\n+\t(vectorizable_lc_phi): New.\n+\t* tree-vect-stmts.c (vect_analyze_stmt): Call vectorize_lc_phi.\n+\t(vect_transform_stmt): Likewise.\n+\t* tree-vectorizer.h (stmt_vec_info_type): Add lc_phi_info_type.\n+\t(vectorizable_lc_phi): Declare.\n+\n 2019-09-26  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-loop.c (vect_analyze_loop_operations): Also call"}, {"sha": "237d28b3ce3d96e7d9496207e901a85c845a0742", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 83, "deletions": 15, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1b4dbccc1f828fa00e6acc8b88d24301c65552df", "patch": "@@ -1519,12 +1519,16 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n                   phi_op = PHI_ARG_DEF (phi, 0);\n \t\t  stmt_vec_info op_def_info = loop_vinfo->lookup_def (phi_op);\n \t\t  if (!op_def_info)\n-\t\t    return opt_result::failure_at (phi, \"unsupported phi\");\n+\t\t    return opt_result::failure_at (phi, \"unsupported phi\\n\");\n \n \t\t  if (STMT_VINFO_RELEVANT (op_def_info) != vect_used_in_outer\n \t\t      && (STMT_VINFO_RELEVANT (op_def_info)\n \t\t\t  != vect_used_in_outer_by_reduction))\n-\t\t    return opt_result::failure_at (phi, \"unsupported phi\");\n+\t\t    return opt_result::failure_at (phi, \"unsupported phi\\n\");\n+\n+\t\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def\n+\t\t      && !vectorizable_lc_phi (stmt_info, NULL, NULL))\n+\t\t    return opt_result::failure_at (phi, \"unsupported phi\\n\");\n                 }\n \n               continue;\n@@ -4396,6 +4400,10 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n         }\n     }\n \n+  /* For vectorizing nested cycles the above is all we need to do.  */\n+  if (nested_in_vect_loop && !double_reduc)\n+    return;\n+\n   /* For cond reductions we want to create a new vector (INDEX_COND_EXPR)\n      which is updated with the current index of the loop for every match of\n      the original loop's cond_expr (VEC_STMT).  This results in a vector\n@@ -4588,16 +4596,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n   new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n   bitsize = TYPE_SIZE (scalar_type);\n \n-  /* In case this is a reduction in an inner-loop while vectorizing an outer\n-     loop - we don't need to extract a single scalar result at the end of the\n-     inner-loop (unless it is double reduction, i.e., the use of reduction is\n-     outside the outer-loop).  The final vector of partial results will be used\n-     in the vectorized outer-loop, or reduced to a scalar result at the end of\n-     the outer-loop.  */\n-  if (nested_in_vect_loop && !double_reduc)\n-    ;\n-  else\n-    {\n   /* SLP reduction without reduction chain, e.g.,\n      # a1 = phi <a2, a0>\n      # b1 = phi <b2, b0>\n@@ -5313,7 +5311,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \n       new_phis[0] = epilog_stmt;\n     }\n-    }\n \n   if (double_reduc)\n     loop = loop->inner;\n@@ -5473,7 +5470,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n           if (double_reduc)\n             loop = outer_loop;\n           else\n-            continue;\n+\t    gcc_unreachable ();\n         }\n \n       phis.create (3);\n@@ -7167,6 +7164,76 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   return true;\n }\n \n+/* Vectorizes LC PHIs of nested cycles (sofar).  */\n+\n+bool\n+vectorizable_lc_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n+\t\t     slp_tree slp_node)\n+{\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  if (!loop_vinfo\n+      || !is_a <gphi *> (stmt_info->stmt)\n+      || gimple_phi_num_args (stmt_info->stmt) != 1)\n+    return false;\n+\n+  /* To handle the nested_cycle_def for double-reductions we have to\n+     refactor epilogue generation more.  */\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n+      /* && STMT_VINFO_DEF_TYPE (stmt_info) != vect_double_reduction_def */)\n+    return false;\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = lc_phi_info_type;\n+      return true;\n+    }\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree scalar_dest = gimple_phi_result (stmt_info->stmt);\n+  basic_block bb = gimple_bb (stmt_info->stmt);\n+  edge e = single_pred_edge (bb);\n+  tree vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  vec<tree> vec_oprnds = vNULL;\n+  vect_get_vec_defs (gimple_phi_arg_def (stmt_info->stmt, 0), NULL_TREE,\n+\t\t     stmt_info, &vec_oprnds, NULL, slp_node);\n+  if (slp_node)\n+    {\n+      unsigned vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+      gcc_assert (vec_oprnds.length () == vec_num);\n+      for (unsigned i = 0; i < vec_num; i++)\n+\t{\n+\t  /* Create the vectorized LC PHI node.  */\n+\t  gphi *new_phi = create_phi_node (vec_dest, bb);\n+\t  add_phi_arg (new_phi, vec_oprnds[i], e, UNKNOWN_LOCATION);\n+\t  stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n+\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n+\t}\n+    }\n+  else\n+    {\n+      unsigned ncopies = vect_get_num_copies (loop_vinfo, vectype);\n+      stmt_vec_info prev_phi_info = NULL;\n+      for (unsigned i = 0; i < ncopies; i++)\n+\t{\n+\t  if (i != 0)\n+\t    vect_get_vec_defs_for_stmt_copy (loop_vinfo, &vec_oprnds, NULL);\n+\t  /* Create the vectorized LC PHI node.  */\n+\t  gphi *new_phi = create_phi_node (vec_dest, bb);\n+\t  add_phi_arg (new_phi, vec_oprnds[0], e, UNKNOWN_LOCATION);\n+\t  stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n+\t  if (i == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_phi_info;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi_info;\n+\t  prev_phi_info = new_phi_info;\n+\t}\n+    }\n+  vec_oprnds.release ();\n+\n+  return true;\n+}\n+\n+\n /* Function vect_min_worthwhile_factor.\n \n    For a loop where we could vectorize the operation indicated by CODE,\n@@ -8399,7 +8466,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t  if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def\n-\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def)\n \t      && ! PURE_SLP_STMT (stmt_info))\n \t    {\n \t      if (dump_enabled_p ())"}, {"sha": "5734068eabc1253d25d509d8e19078b4aa0b1d7a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=1b4dbccc1f828fa00e6acc8b88d24301c65552df", "patch": "@@ -10671,7 +10671,8 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t  || vectorizable_condition (stmt_info, NULL, NULL, false, -1, node,\n \t\t\t\t     cost_vec)\n \t  || vectorizable_comparison (stmt_info, NULL, NULL, node,\n-\t\t\t\t      cost_vec));\n+\t\t\t\t      cost_vec)\n+\t  || vectorizable_lc_phi (stmt_info, NULL, node));\n   else\n     {\n       if (bb_vinfo)\n@@ -10820,6 +10821,11 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       gcc_assert (done);\n       break;\n \n+    case lc_phi_info_type:\n+      done = vectorizable_lc_phi (stmt_info, &vec_stmt, slp_node);\n+      gcc_assert (done);\n+      break;\n+\n     default:\n       if (!STMT_VINFO_LIVE_P (stmt_info))\n \t{"}, {"sha": "1ab4af7236f95af90aa9c5f958a21ec405aee231", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4dbccc1f828fa00e6acc8b88d24301c65552df/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1b4dbccc1f828fa00e6acc8b88d24301c65552df", "patch": "@@ -694,6 +694,7 @@ enum stmt_vec_info_type {\n   type_promotion_vec_info_type,\n   type_demotion_vec_info_type,\n   type_conversion_vec_info_type,\n+  lc_phi_info_type,\n   loop_exit_ctrl_vec_info_type\n };\n \n@@ -1653,6 +1654,7 @@ extern bool vectorizable_reduction (stmt_vec_info, gimple_stmt_iterator *,\n extern bool vectorizable_induction (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n+extern bool vectorizable_lc_phi (stmt_vec_info, stmt_vec_info *, slp_tree);\n extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,"}]}