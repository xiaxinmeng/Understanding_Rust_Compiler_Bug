{"sha": "0669bebef6c745891bea707a1b65e44073fe2332", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY2OWJlYmVmNmM3NDU4OTFiZWE3MDdhMWI2NWU0NDA3M2ZlMjMzMg==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2007-04-06T09:17:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:17:46Z"}, "message": "exp_ch4.adb (Expand_N_Type_Conversion): Remove special processing for conversion of a Float_Type'Truncation to integer.\n\n2007-04-06  Geert Bosch  <bosch@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Remove special processing\n\tfor conversion of a Float_Type'Truncation to integer.\n\n\t* exp_attr.adb (Is_Inline_Floating_Point_Attribute): New function to\n\tcheck if a node is an attribute that can be handled directly by the\n\tback end.\n\t(Expand_N_Attribute_Reference): Suppress expansion of floating-point\n\tattributes that can be handled directly by the back end.\n\t(Expand_N_Attribute_Reference, case 'Access and 'Unchecked_Access):\n\tuse new predicate Is_Access_Protected_Subprogram_Type.\n\t(Expand_N_Attribute_Reference, case 'Write): The reference is legal for\n\tand Unchecked_Union if it is generated as part of the default  Output\n\tprocedure for a type with default discriminants.\n\t(Expand_N_Attribute_Reference): Avoid the expansion of dispatching calls\n\tif we are compiling under restriction No_Dispatching_Calls.\n\t(Constrained): Use Underlying_Type, in case the type is private without\n\tdiscriminants, but the full type has discriminants.\n\t(Expand_N_Attribute_Reference): Replace call to Get_Access_Level by\n\tcall to Build_Get_Access_Level.\n\t(Expand_N_Attribute_Reference): The use of 'Address with class-wide\n\tinterface objects requires a call to the run-time subprogram that\n\treturns the base address of the object.\n\t(Valid_Conversion): Improve error message on illegal attempt to store\n\tan anonymous access to subprogram value into a record component.\n\n\t* sem_res.adb (Resolve_Equality_Op): Detect ambiguity for \"X'Access =\n\tnull\".\n\t(Simplify_Type_Conversion): New procedure that performs simplification\n\tof Int_Type (Float_Type'Truncation (X)).\n\t(Resolve_Type_Conversion): Call above procedure after resolving operand\n\tand before performing checks. This replaces the existing ineffective\n\tcode in Exp_Ch4.\n\t(Set_String_Literal_Subtype): When creating the internal static lower\n\tbound subtype for a string literal, use a newly created copy of the\n\tsubtree representing the lower bound.\n\t(Resolve_Call): Exclude build-in-place function calls from transient\n\tscope treatment. Update comments to describe this exception.\n\t(Resolve_Equality_Op): In case of dispatching call check violation of\n\trestriction No_Dispatching_Calls.\n\t(Resolve_Call): If the call returns an array, the context imposes the\n\tcomponent type of the array, and the function has one non-defaulted\n\tparameter, rewrite the call as the indexing of a call with a single\n\tparameter, to handle an Ada 2005 syntactic ambiguity for calls written\n\tin prefix form.\n\t(Resolve_Actuals): If an actual is an allocator for an access parameter,\n\tthe master of the created object is the innermost enclosing statement.\n\t(Remove_Conversions): For a binary operator, check if type of second\n\tformal is numeric, to check if an abstract interpretation is present\n\tin the case of exponentiation as well.\n\nFrom-SVN: r123552", "tree": {"sha": "8d323a61f87bf7f4da3a4e44ae1186e4fef7cf39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d323a61f87bf7f4da3a4e44ae1186e4fef7cf39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0669bebef6c745891bea707a1b65e44073fe2332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0669bebef6c745891bea707a1b65e44073fe2332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0669bebef6c745891bea707a1b65e44073fe2332", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0669bebef6c745891bea707a1b65e44073fe2332/comments", "author": null, "committer": null, "parents": [{"sha": "ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea1941af7fd5244b8d6875fcc1dad0a597180cd1"}], "stats": {"total": 915, "additions": 735, "deletions": 180}, "files": [{"sha": "79096e9d6f79412cd976f21ff0015a6cbe786e08", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 126, "deletions": 31, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0669bebef6c745891bea707a1b65e44073fe2332/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0669bebef6c745891bea707a1b65e44073fe2332/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=0669bebef6c745891bea707a1b65e44073fe2332", "patch": "@@ -28,6 +28,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Imgv; use Exp_Imgv;\n@@ -160,6 +161,12 @@ package body Exp_Attr is\n    --  Utility for array attributes, returns true on packed constrained\n    --  arrays, and on access to same.\n \n+   function Is_Inline_Floating_Point_Attribute (N : Node_Id) return Boolean;\n+   --  Returns true iff the given node refers to an attribute call that\n+   --  can be expanded directly by the back end and does not need front end\n+   --  expansion. Typically used for rounding and truncation attributes that\n+   --  appear directly inside a conversion to integer.\n+\n    ----------------------------------\n    -- Compile_Stream_Body_In_Scope --\n    ----------------------------------\n@@ -497,7 +504,7 @@ package body Exp_Attr is\n    -- Expand_Fpt_Attribute_RR --\n    -----------------------------\n \n-   --  The two arguments is converted to their root types to call the\n+   --  The two arguments are converted to their root types to call the\n    --  appropriate runtime function, with the actual call being built\n    --  by Expand_Fpt_Attribute\n \n@@ -665,7 +672,7 @@ package body Exp_Attr is\n \n       when Attribute_Access =>\n \n-         if Ekind (Btyp) = E_Access_Protected_Subprogram_Type then\n+         if Is_Access_Protected_Subprogram_Type (Btyp) then\n             Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n          elsif Ekind (Btyp) = E_General_Access_Type then\n@@ -795,6 +802,23 @@ package body Exp_Attr is\n \n                Analyze_And_Resolve (N, Addr);\n             end;\n+\n+         --  Ada 2005 (AI-251): Class-wide interface objects are always\n+         --  \"displaced\" to reference the tag associated with the interface\n+         --  type. In order to obtain the real address of such objects we\n+         --  generate a call to a run-time subprogram that returns the base\n+         --  address of the object.\n+\n+         elsif Is_Class_Wide_Type (Etype (Pref))\n+            and then Is_Interface (Etype (Pref))\n+         then\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name => New_Reference_To (RTE (RE_Base_Address), Loc),\n+                Parameter_Associations => New_List (\n+                  Relocate_Node (N))));\n+            Analyze (N);\n+            return;\n          end if;\n \n          --  Deal with packed array reference, other cases are handled by gigi\n@@ -829,6 +853,15 @@ package body Exp_Attr is\n          --  operation _Alignment applied to X.\n \n          elsif Is_Class_Wide_Type (Ptyp) then\n+\n+            --  No need to do anything else compiling under restriction\n+            --  No_Dispatching_Calls. During the semantic analysis we\n+            --  already notified such violation.\n+\n+            if Restriction_Active (No_Dispatching_Calls) then\n+               return;\n+            end if;\n+\n             New_Node :=\n               Make_Function_Call (Loc,\n                 Name => New_Reference_To\n@@ -1327,8 +1360,13 @@ package body Exp_Attr is\n                --  not accurate (the procedure formal case), has been\n                --  handled above.\n \n+               --  We use the Underlying_Type here (and below) in case the\n+               --  type is private without discriminants, but the full type\n+               --  has discriminants. This case is illegal, but we generate it\n+               --  internally for passing to the Extra_Constrained parameter.\n+\n                else\n-                  Res := Is_Constrained (Etype (Ent));\n+                  Res := Is_Constrained (Underlying_Type (Etype (Ent)));\n                end if;\n \n                Rewrite (N,\n@@ -1350,7 +1388,7 @@ package body Exp_Attr is\n                      (Nkind (Pref) = N_Explicit_Dereference\n                         and then\n                           not Has_Constrained_Partial_View (Base_Type (Typ)))\n-                    or else Is_Constrained (Typ)),\n+                    or else Is_Constrained (Underlying_Type (Typ))),\n                 Loc));\n          end if;\n \n@@ -2013,6 +2051,14 @@ package body Exp_Attr is\n \n             elsif Is_Class_Wide_Type (P_Type) then\n \n+               --  No need to do anything else compiling under restriction\n+               --  No_Dispatching_Calls. During the semantic analysis we\n+               --  already notified such violation.\n+\n+               if Restriction_Active (No_Dispatching_Calls) then\n+                  return;\n+               end if;\n+\n                declare\n                   Rtyp : constant Entity_Id := Root_Type (P_Type);\n                   Dnn  : Entity_Id;\n@@ -2430,10 +2476,13 @@ package body Exp_Attr is\n \n       --  Transforms 'Machine_Rounding into a call to the floating-point\n       --  attribute function Machine_Rounding in Fat_xxx (where xxx is the root\n-      --  type).\n+      --  type). Expansion is avoided for cases the back end can handle\n+      --  directly.\n \n       when Attribute_Machine_Rounding =>\n-         Expand_Fpt_Attribute_R (N);\n+         if not Is_Inline_Floating_Point_Attribute (N) then\n+            Expand_Fpt_Attribute_R (N);\n+         end if;\n \n       ------------------\n       -- Machine_Size --\n@@ -2707,6 +2756,15 @@ package body Exp_Attr is\n             --  to the appropriate primitive Output function (RM 13.13.2(31)).\n \n             elsif Is_Class_Wide_Type (P_Type) then\n+\n+               --  No need to do anything else compiling under restriction\n+               --  No_Dispatching_Calls. During the semantic analysis we\n+               --  already notified such violation.\n+\n+               if Restriction_Active (No_Dispatching_Calls) then\n+                  return;\n+               end if;\n+\n                Tag_Write : declare\n                   Strm : constant Node_Id := First (Exprs);\n                   Item : constant Node_Id := Next (Strm);\n@@ -2730,21 +2788,18 @@ package body Exp_Attr is\n                          Condition =>\n                            Make_Op_Ne (Loc,\n                              Left_Opnd  =>\n-                               Make_Function_Call (Loc,\n-                                 Name =>\n-                                   New_Reference_To\n-                                     (RTE (RE_Get_Access_Level), Loc),\n-                                 Parameter_Associations =>\n-                                   New_List (Make_Attribute_Reference (Loc,\n-                                               Prefix         =>\n-                                                 Relocate_Node (\n-                                                   Duplicate_Subexpr (Item,\n-                                                     Name_Req => True)),\n-                                               Attribute_Name =>\n-                                                  Name_Tag))),\n+                               Build_Get_Access_Level (Loc,\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                     Relocate_Node (\n+                                       Duplicate_Subexpr (Item,\n+                                         Name_Req => True)),\n+                                   Attribute_Name => Name_Tag)),\n+\n                              Right_Opnd =>\n-                               Make_Integer_Literal\n-                                 (Loc, Type_Access_Level (P_Type))),\n+                               Make_Integer_Literal (Loc,\n+                                 Type_Access_Level (P_Type))),\n+\n                          Then_Statements =>\n                            New_List (Make_Raise_Statement (Loc,\n                                        New_Occurrence_Of (\n@@ -2775,9 +2830,9 @@ package body Exp_Attr is\n             elsif Is_Tagged_Type (U_Type) then\n                Pname := Find_Prim_Op (U_Type, TSS_Stream_Output);\n \n---              --  All other record type cases, including protected records.\n---              --  The latter only arise for expander generated code for\n---              --  handling shared passive partition access.\n+            --  All other record type cases, including protected records.\n+            --  The latter only arise for expander generated code for\n+            --  handling shared passive partition access.\n \n             else\n                pragma Assert\n@@ -3450,6 +3505,15 @@ package body Exp_Attr is\n          --  X'Size into a call to the primitive operation _Size applied to X.\n \n          elsif Is_Class_Wide_Type (Ptyp) then\n+\n+            --  No need to do anything else compiling under restriction\n+            --  No_Dispatching_Calls. During the semantic analysis we\n+            --  already notified such violation.\n+\n+            if Restriction_Active (No_Dispatching_Calls) then\n+               return;\n+            end if;\n+\n             New_Node :=\n               Make_Function_Call (Loc,\n                 Name => New_Reference_To\n@@ -3912,21 +3976,27 @@ package body Exp_Attr is\n       ----------------\n \n       --  Transforms 'Truncation into a call to the floating-point attribute\n-      --  function Truncation in Fat_xxx (where xxx is the root type)\n+      --  function Truncation in Fat_xxx (where xxx is the root type).\n+      --  Expansion is avoided for cases the back end can handle directly.\n \n       when Attribute_Truncation =>\n-         Expand_Fpt_Attribute_R (N);\n+         if not Is_Inline_Floating_Point_Attribute (N) then\n+            Expand_Fpt_Attribute_R (N);\n+         end if;\n \n       -----------------------\n       -- Unbiased_Rounding --\n       -----------------------\n \n       --  Transforms 'Unbiased_Rounding into a call to the floating-point\n       --  attribute function Unbiased_Rounding in Fat_xxx (where xxx is the\n-      --  root type)\n+      --  root type). Expansion is avoided for cases the back end can handle\n+      --  directly.\n \n       when Attribute_Unbiased_Rounding =>\n-         Expand_Fpt_Attribute_R (N);\n+         if not Is_Inline_Floating_Point_Attribute (N) then\n+            Expand_Fpt_Attribute_R (N);\n+         end if;\n \n       ----------------------\n       -- Unchecked_Access --\n@@ -3999,7 +4069,7 @@ package body Exp_Attr is\n \n       when Attribute_Unrestricted_Access =>\n \n-         if Ekind (Btyp) = E_Access_Protected_Subprogram_Type then\n+         if Is_Access_Protected_Subprogram_Type (Btyp) then\n             Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n          --  Ada 2005 (AI-251): If the designated type is an interface, then\n@@ -4184,7 +4254,7 @@ package body Exp_Attr is\n                   --  to call the special routine Unaligned_Valid, which makes\n                   --  the needed copy, being careful not to load the value into\n                   --  any floating-point register. The argument in this case is\n-                  --  obj'Address (see Unchecked_Valid routine in Fat_Gen).\n+                  --  obj'Address (see Unaligned_Valid routine in Fat_Gen).\n \n                   if Is_Possibly_Unaligned_Object (Pref) then\n                      Set_Attribute_Name (N, Name_Unaligned_Valid);\n@@ -4667,9 +4737,14 @@ package body Exp_Attr is\n \n                --  Ada 2005 (AI-216): Program_Error is raised when executing\n                --  the default implementation of the Write attribute of an\n-               --  Unchecked_Union type.\n+               --  Unchecked_Union type. However, if the 'Write reference is\n+               --  within the generated Output stream procedure, Write outputs\n+               --  the components, and the default values of the discriminant\n+               --  are streamed by the Output procedure itself.\n \n-               if Is_Unchecked_Union (Base_Type (U_Type)) then\n+               if Is_Unchecked_Union (Base_Type (U_Type))\n+                 and not Is_TSS (Current_Scope, TSS_Stream_Output)\n+               then\n                   Insert_Action (N,\n                     Make_Raise_Program_Error (Loc,\n                       Reason => PE_Unchecked_Union_Restriction));\n@@ -5038,4 +5113,24 @@ package body Exp_Attr is\n         and then Present (Packed_Array_Type (Arr));\n    end Is_Constrained_Packed_Array;\n \n+   ----------------------------------------\n+   -- Is_Inline_Floating_Point_Attribute --\n+   ----------------------------------------\n+\n+   function Is_Inline_Floating_Point_Attribute (N : Node_Id) return Boolean is\n+      Id : constant Attribute_Id := Get_Attribute_Id (Attribute_Name (N));\n+\n+   begin\n+      if Nkind (Parent (N)) /= N_Type_Conversion\n+        or else not Is_Integer_Type (Etype (Parent (N)))\n+      then\n+         return False;\n+      end if;\n+\n+      --  Should also support 'Machine_Rounding and 'Unbiased_Rounding, but\n+      --  required back end support has not been implemented yet ???\n+\n+      return Id = Attribute_Truncation;\n+   end Is_Inline_Floating_Point_Attribute;\n+\n end Exp_Attr;"}, {"sha": "d508c348098e1481703242549b445701834689e6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 207, "deletions": 54, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0669bebef6c745891bea707a1b65e44073fe2332/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0669bebef6c745891bea707a1b65e44073fe2332/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0669bebef6c745891bea707a1b65e44073fe2332", "patch": "@@ -30,6 +30,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -46,6 +47,8 @@ with Inline;   use Inline;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n@@ -481,37 +484,47 @@ package body Exp_Ch4 is\n          --  type, generate an accessibility check to verify that the level of\n          --  the type of the created object is not deeper than the level of the\n          --  access type. If the type of the qualified expression is class-\n-         --  wide, then always generate the check. Otherwise, only generate the\n-         --  check if the level of the qualified expression type is statically\n-         --  deeper than the access type. Although the static accessibility\n-         --  will generally have been performed as a legality check, it won't\n-         --  have been done in cases where the allocator appears in generic\n-         --  body, so a run-time check is needed in general.\n+         --  wide, then always generate the check (except in the case where it\n+         --  is known to be unnecessary, see comment below). Otherwise, only\n+         --  generate the check if the level of the qualified expression type\n+         --  is statically deeper than the access type. Although the static\n+         --  accessibility will generally have been performed as a legality\n+         --  check, it won't have been done in cases where the allocator\n+         --  appears in generic body, so a run-time check is needed in general.\n+         --  One special case is when the access type is declared in the same\n+         --  scope as the class-wide allocator, in which case the check can\n+         --  never fail, so it need not be generated. As an open issue, there\n+         --  seem to be cases where the static level associated with the\n+         --  class-wide object's underlying type is not sufficient to perform\n+         --  the proper accessibility check, such as for allocators in nested\n+         --  subprograms or accept statements initialized by class-wide formals\n+         --  when the actual originates outside at a deeper static level. The\n+         --  nested subprogram case might require passing accessibility levels\n+         --  along with class-wide parameters, and the task case seems to be\n+         --  an actual gap in the language rules that needs to be fixed by the\n+         --  ARG. ???\n \n          if Ada_Version >= Ada_05\n            and then Is_Class_Wide_Type (DesigT)\n            and then not Scope_Suppress (Accessibility_Check)\n            and then\n-             (Is_Class_Wide_Type (Etype (Exp))\n-                or else\n-              Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT))\n+             (Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT)\n+               or else\n+                 (Is_Class_Wide_Type (Etype (Exp))\n+                   and then Scope (PtrT) /= Current_Scope))\n          then\n             Insert_Action (N,\n                Make_Raise_Program_Error (Loc,\n                  Condition =>\n                    Make_Op_Gt (Loc,\n                      Left_Opnd  =>\n-                       Make_Function_Call (Loc,\n-                         Name =>\n-                           New_Reference_To (RTE (RE_Get_Access_Level), Loc),\n-                         Parameter_Associations =>\n-                           New_List (Make_Attribute_Reference (Loc,\n-                                       Prefix         =>\n-                                          New_Reference_To (Temp, Loc),\n-                                       Attribute_Name =>\n-                                          Name_Tag))),\n+                       Build_Get_Access_Level (Loc,\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix => New_Reference_To (Temp, Loc),\n+                           Attribute_Name => Name_Tag)),\n                      Right_Opnd =>\n-                       Make_Integer_Literal (Loc, Type_Access_Level (PtrT))),\n+                       Make_Integer_Literal (Loc,\n+                         Type_Access_Level (PtrT))),\n                  Reason => PE_Accessibility_Check_Failed));\n          end if;\n \n@@ -2489,6 +2502,72 @@ package body Exp_Ch4 is\n       Temp  : Entity_Id;\n       Node  : Node_Id;\n \n+      function Is_Local_Access_Discriminant (N : Node_Id) return Boolean;\n+      --  If the allocator is for an access discriminant of a stack-allocated\n+      --  object, the discriminant can be allocated locally as well, to ensure\n+      --  that its lifetime does not exceed that of the enclosing object.\n+      --  This is an optimization mandated / suggested by Ada 2005 AI-162.\n+\n+      ----------------------------------\n+      -- Is_Local_Access_Discriminant --\n+      ----------------------------------\n+\n+      function Is_Local_Access_Discriminant (N : Node_Id) return Boolean is\n+         Decl : Node_Id;\n+         Temp : Entity_Id;\n+\n+      begin\n+         if Nkind (Parent (N)) = N_Index_Or_Discriminant_Constraint\n+           and then not Is_Coextension (N)\n+           and then not Is_Record_Type (Current_Scope)\n+         then\n+            Temp :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('T'));\n+\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Aliased_Present     => True,\n+                Object_Definition   => New_Occurrence_Of (Etyp, Loc));\n+\n+            if Nkind (Expression (N)) = N_Qualified_Expression then\n+               Set_Expression (Decl, Expression (Expression (N)));\n+            end if;\n+\n+            declare\n+               Nod : Node_Id;\n+\n+            begin\n+               Nod := Parent (N);\n+               while Present (Nod) loop\n+                  exit when\n+                      Nkind (Nod) in N_Statement_Other_Than_Procedure_Call\n+                    or else Nkind (Nod) = N_Procedure_Call_Statement\n+                    or else Nkind (Nod) in N_Declaration;\n+                  Nod := Parent (Nod);\n+               end loop;\n+\n+               Insert_Before (Nod, Decl);\n+               Analyze (Decl);\n+            end;\n+\n+            Rewrite (N,\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Occurrence_Of (Temp, Loc),\n+                Attribute_Name => Name_Unrestricted_Access));\n+\n+            Analyze_And_Resolve (N, PtrT);\n+\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Local_Access_Discriminant;\n+\n+   --  Start of processing for Expand_N_Allocator\n+\n    begin\n       --  RM E.2.3(22). We enforce that the expected type of an allocator\n       --  shall not be a remote access-to-class-wide-limited-private type\n@@ -2581,6 +2660,14 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Same if the allocator is an access discriminant for a local object:\n+      --  instead of an allocator we create a local value and constrain the\n+      --  the enclosing object with the corresponding access attribute.\n+\n+      if Is_Local_Access_Discriminant (N) then\n+         return;\n+      end if;\n+\n       --  Handle case of qualified expression (other than optimization above)\n \n       if Nkind (Expression (N)) = N_Qualified_Expression then\n@@ -2721,6 +2808,7 @@ package body Exp_Ch4 is\n                      --  The designated type was an incomplete type, and the\n                      --  access type did not get expanded. Salvage it now.\n \n+                     pragma Assert (Present (Parent (Base_Type (PtrT))));\n                      Expand_N_Full_Type_Declaration\n                        (Parent (Base_Type (PtrT)));\n                   end if;\n@@ -2895,11 +2983,26 @@ package body Exp_Ch4 is\n \n                if Controlled_Type (T) then\n                   Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n-                  if Ekind (PtrT) = E_Anonymous_Access_Type then\n+\n+                  --  Anonymous access types created for access parameters\n+                  --  are attached to an explicitly constructed controller,\n+                  --  which ensures that they can be finalized properly, even\n+                  --  if their deallocation might not happen. The list\n+                  --  associated with the controller is doubly-linked. For\n+                  --  other anonymous access types, the object may end up\n+                  --  on the global final list which is singly-linked.\n+                  --  Work needed for access discriminants in Ada 2005 ???\n+\n+                  if Ekind (PtrT) = E_Anonymous_Access_Type\n+                      and then\n+                        Nkind (Associated_Node_For_Itype (PtrT))\n+                          not in N_Subprogram_Specification\n+                  then\n                      Attach_Level := Uint_1;\n                   else\n                      Attach_Level := Uint_2;\n                   end if;\n+\n                   Insert_Actions (N,\n                     Make_Init_Call (\n                       Ref          => New_Copy_Tree (Arg1),\n@@ -4571,6 +4674,14 @@ package body Exp_Ch4 is\n \n          if Is_Tagged_Type (Typl) then\n \n+            --  No need to do anything else compiling under restriction\n+            --  No_Dispatching_Calls. During the semantic analysis we\n+            --  already notified such violation.\n+\n+            if Restriction_Active (No_Dispatching_Calls) then\n+               return;\n+            end if;\n+\n             --  If this is derived from an untagged private type completed\n             --  with a tagged type, it does not have a full view, so we\n             --  use the primitive operations of the private type.\n@@ -6420,6 +6531,18 @@ package body Exp_Ch4 is\n         and then (not Is_Entity_Name (Pfx)\n                    or else not Index_Checks_Suppressed (Entity (Pfx)))\n         and then Nkind (Discrete_Range (N)) /= N_Subtype_Indication\n+\n+         --  Do not enable range check to nodes associated with the frontend\n+         --  expansion of the dispatch table. We first check if Ada.Tags is\n+         --  already loaded to avoid the addition of an undesired dependence\n+         --  on such run-time unit.\n+\n+        and then not\n+          (RTU_Loaded (Ada_Tags)\n+            and then Nkind (Prefix (N)) = N_Selected_Component\n+            and then Present (Entity (Selector_Name (Prefix (N))))\n+            and then Entity (Selector_Name (Prefix (N))) =\n+                                         RTE_Record_Component (RE_Prims_Ptr))\n       then\n          Enable_Range_Check (Discrete_Range (N));\n       end if;\n@@ -6431,7 +6554,7 @@ package body Exp_Ch4 is\n       --       situation correctly in the assignment statement expansion).\n \n       --    2. Prefix of indexed component (the slide is optimized away\n-      --       in this case, see the start of Expand_N_Slice.\n+      --       in this case, see the start of Expand_N_Slice.)\n \n       --    3. Object renaming declaration, since we want the name of\n       --       the slice, not the value.\n@@ -6906,7 +7029,7 @@ package body Exp_Ch4 is\n             return;\n          end if;\n \n-         --  Oherwise, proceed with processing tagged conversion\n+         --  Otherwise, proceed with processing tagged conversion\n \n          declare\n             Actual_Operand_Type : Entity_Id;\n@@ -7072,32 +7195,16 @@ package body Exp_Ch4 is\n             or else\n           (Is_Fixed_Point_Type (Target_Type) and then Conversion_OK (N)))\n       then\n-         --  Special processing required if the conversion is the expression\n-         --  of a Truncation attribute reference. In this case we replace:\n-\n-         --     ityp (ftyp'Truncation (x))\n-\n-         --  by\n-\n-         --     ityp (x)\n-\n-         --  with the Float_Truncate flag set. This is clearly more efficient\n-\n-         if Nkind (Operand) = N_Attribute_Reference\n-           and then Attribute_Name (Operand) = Name_Truncation\n-         then\n-            Rewrite (Operand,\n-              Relocate_Node (First (Expressions (Operand))));\n-            Set_Float_Truncate (N, True);\n-         end if;\n-\n          --  One more check here, gcc is still not able to do conversions of\n          --  this type with proper overflow checking, and so gigi is doing an\n          --  approximation of what is required by doing floating-point compares\n          --  with the end-point. But that can lose precision in some cases, and\n          --  give a wrong result. Converting the operand to Universal_Real is\n          --  helpful, but still does not catch all cases with 64-bit integers\n-         --  on targets with only 64-bit floats ???\n+         --  on targets with only 64-bit floats\n+\n+         --  The above comment seems obsoleted by Apply_Float_Conversion_Check\n+         --  Can this code be removed ???\n \n          if Do_Range_Check (Operand) then\n             Rewrite (Operand,\n@@ -8358,6 +8465,11 @@ package body Exp_Ch4 is\n    --  is usually implemented by looking in the ancestor tables contained in\n    --  the dispatch table pointed by Left_Expr.Tag for Typ'Tag\n \n+   --  Ada 2005 (AI-251): If it is a class-wide interface type we use the RT\n+   --  function IW_Membership which is usually implemented by looking in the\n+   --  table of abstract interface types plus the ancestor table contained in\n+   --  the dispatch table pointed by Left_Expr.Tag for Typ'Tag\n+\n    function Tagged_Membership (N : Node_Id) return Node_Id is\n       Left  : constant Node_Id    := Left_Opnd  (N);\n       Right : constant Node_Id    := Right_Opnd (N);\n@@ -8383,11 +8495,44 @@ package body Exp_Ch4 is\n \n       if Is_Class_Wide_Type (Right_Type) then\n \n+         --  No need to issue a run-time check if we statically know that the\n+         --  result of this membership test is always true. For example,\n+         --  considering the following declarations:\n+\n+         --    type Iface is interface;\n+         --    type T     is tagged null record;\n+         --    type DT    is new T and Iface with null record;\n+\n+         --    Obj1 : T;\n+         --    Obj2 : DT;\n+\n+         --  These membership tests are always true:\n+\n+         --    Obj1 in T'Class\n+         --    Obj2 in T'Class;\n+         --    Obj2 in Iface'Class;\n+\n+         --  We do not need to handle cases where the membership is illegal.\n+         --  For example:\n+\n+         --    Obj1 in DT'Class;     --  Compile time error\n+         --    Obj1 in Iface'Class;  --  Compile time error\n+\n+         if not Is_Class_Wide_Type (Left_Type)\n+           and then (Is_Parent (Etype (Right_Type), Left_Type)\n+                       or else (Is_Interface (Etype (Right_Type))\n+                                 and then Interface_Present_In_Ancestor\n+                                           (Typ   => Left_Type,\n+                                            Iface => Etype (Right_Type))))\n+         then\n+            return New_Reference_To (Standard_True, Loc);\n+         end if;\n+\n          --  Ada 2005 (AI-251): Class-wide applied to interfaces\n \n          if Is_Interface (Etype (Class_Wide_Type (Right_Type)))\n \n-            --   Give support to: \"Iface_CW_Typ in Typ'Class\"\n+            --   Support to: \"Iface_CW_Typ in Typ'Class\"\n \n            or else Is_Interface (Left_Type)\n          then\n@@ -8415,23 +8560,31 @@ package body Exp_Ch4 is\n \n          else\n             return\n-              Make_Function_Call (Loc,\n-                 Name => New_Occurrence_Of (RTE (RE_CW_Membership), Loc),\n-                 Parameter_Associations => New_List (\n-                   Obj_Tag,\n+              Build_CW_Membership (Loc,\n+                Obj_Tag_Node => Obj_Tag,\n+                Typ_Tag_Node =>\n                    New_Reference_To (\n                      Node (First_Elmt\n                             (Access_Disp_Table (Root_Type (Right_Type)))),\n-                     Loc)));\n+                     Loc));\n          end if;\n \n+      --  Right_Type is not a class-wide type\n+\n       else\n-         return\n-           Make_Op_Eq (Loc,\n-             Left_Opnd  => Obj_Tag,\n-             Right_Opnd =>\n-               New_Reference_To\n-                 (Node (First_Elmt (Access_Disp_Table (Right_Type))), Loc));\n+         --  No need to check the tag of the object if Right_Typ is abstract\n+\n+         if Is_Abstract_Type (Right_Type) then\n+            return New_Reference_To (Standard_False, Loc);\n+\n+         else\n+            return\n+              Make_Op_Eq (Loc,\n+                Left_Opnd  => Obj_Tag,\n+                Right_Opnd =>\n+                  New_Reference_To\n+                    (Node (First_Elmt (Access_Disp_Table (Right_Type))), Loc));\n+         end if;\n       end if;\n    end Tagged_Membership;\n "}, {"sha": "8a0f531b9206b826b7875365a536c21676a33328", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 402, "deletions": 95, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0669bebef6c745891bea707a1b65e44073fe2332/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0669bebef6c745891bea707a1b65e44073fe2332/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=0669bebef6c745891bea707a1b65e44073fe2332", "patch": "@@ -32,6 +32,7 @@ with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Disp; use Exp_Disp;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n@@ -66,7 +67,6 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -215,6 +215,11 @@ package body Sem_Res is\n    procedure Set_Slice_Subtype (N : Node_Id);\n    --  Build subtype of array type, with the range specified by the slice\n \n+   procedure Simplify_Type_Conversion (N : Node_Id);\n+   --  Called after N has been resolved and evaluated, but before range checks\n+   --  have been applied. Currently simplifies a combination of floating-point\n+   --  to integer conversion and Truncation attribute.\n+\n    function Unique_Fixed_Point_Type (N : Node_Id) return Entity_Id;\n    --  A universal_fixed expression in an universal context is unambiguous\n    --  if there is only one applicable fixed point type. Determining whether\n@@ -821,15 +826,9 @@ package body Sem_Res is\n    --  Start of processing for Check_Initialization_Call\n \n    begin\n-      --  Nothing to do if functions do not use the secondary stack for\n-      --  returns (i.e. they use a depressed stack pointer instead).\n-\n-      if Functions_Return_By_DSP_On_Target then\n-         return;\n+      --  Establish a transient scope if the type needs it\n \n-      --  Otherwise establish a transient scope if the type needs it\n-\n-      elsif Uses_SS (Typ) then\n+      if Uses_SS (Typ) then\n          Establish_Transient_Scope (First_Actual (N), Sec_Stack => True);\n       end if;\n    end Check_Initialization_Call;\n@@ -1835,24 +1834,29 @@ package body Sem_Res is\n                               N, It.Nam);\n                         end if;\n \n-                        Error_Msg_N\n-                          (\"\\\\possible interpretation#!\", N);\n                         Ambiguous := True;\n+\n+                        if Nkind (Parent (Seen)) = N_Full_Type_Declaration then\n+                           Error_Msg_N\n+                             (\"\\\\possible interpretation (inherited)#!\", N);\n+                        else\n+                           Error_Msg_N (\"\\\\possible interpretation#!\", N);\n+                        end if;\n                      end if;\n \n                      Error_Msg_Sloc := Sloc (It.Nam);\n \n                      --  By default, the error message refers to the candidate\n-                     --  interpretation. But if it is a  predefined operator,\n-                     --  it is implicitly declared at the declaration of\n-                     --  the type of the operand. Recover the sloc of that\n-                     --  declaration for the error message.\n+                     --  interpretation. But if it is a predefined operator, it\n+                     --  is implicitly declared at the declaration of the type\n+                     --  of the operand. Recover the sloc of that declaration\n+                     --  for the error message.\n \n                      if Nkind (N) in N_Op\n                        and then Scope (It.Nam) = Standard_Standard\n                        and then not Is_Overloaded (Right_Opnd (N))\n-                       and then  Scope (Base_Type (Etype (Right_Opnd (N))))\n-                            /= Standard_Standard\n+                       and then Scope (Base_Type (Etype (Right_Opnd (N)))) /=\n+                                                             Standard_Standard\n                      then\n                         Err_Type := First_Subtype (Etype (Right_Opnd (N)));\n \n@@ -1865,8 +1869,8 @@ package body Sem_Res is\n                      elsif Nkind (N) in N_Binary_Op\n                        and then Scope (It.Nam) = Standard_Standard\n                        and then not Is_Overloaded (Left_Opnd (N))\n-                       and then Scope (Base_Type (Etype (Left_Opnd (N))))\n-                            /= Standard_Standard\n+                       and then Scope (Base_Type (Etype (Left_Opnd (N)))) /=\n+                                                             Standard_Standard\n                      then\n                         Err_Type := First_Subtype (Etype (Left_Opnd (N)));\n \n@@ -1888,7 +1892,6 @@ package body Sem_Res is\n                         Err_Type := It.Nam;\n                         Error_Msg_Sloc :=\n                           Sloc (Associated_Node_For_Itype (Err_Type));\n-\n                      else\n                         Err_Type := Empty;\n                      end if;\n@@ -1912,11 +1915,11 @@ package body Sem_Res is\n                   end if;\n                end if;\n \n-               --  We have a matching interpretation, Expr_Type is the\n-               --  type from this interpretation, and Seen is the entity.\n+               --  We have a matching interpretation, Expr_Type is the type\n+               --  from this interpretation, and Seen is the entity.\n \n-               --  For an operator, just set the entity name. The type will\n-               --  be set by the specific operator resolution routine.\n+               --  For an operator, just set the entity name. The type will be\n+               --  set by the specific operator resolution routine.\n \n                if Nkind (N) in N_Op then\n                   Set_Entity (N, Seen);\n@@ -1926,9 +1929,9 @@ package body Sem_Res is\n                   Set_Etype (N, Expr_Type);\n \n                --  For an explicit dereference, attribute reference, range,\n-               --  short-circuit form (which is not an operator node),\n-               --  or a call with a name that is an explicit dereference,\n-               --  there is nothing to be done at this point.\n+               --  short-circuit form (which is not an operator node), or call\n+               --  with a name that is an explicit dereference, there is\n+               --  nothing to be done at this point.\n \n                elsif     Nkind (N) = N_Explicit_Dereference\n                  or else Nkind (N) = N_Attribute_Reference\n@@ -1942,8 +1945,8 @@ package body Sem_Res is\n                then\n                   null;\n \n-               --  For procedure or function calls, set the type of the\n-               --  name, and also the entity pointer for the prefix\n+               --  For procedure or function calls, set the type of the name,\n+               --  and also the entity pointer for the prefix\n \n                elsif (Nkind (N) = N_Procedure_Call_Statement\n                        or else Nkind (N) = N_Function_Call)\n@@ -1985,11 +1988,10 @@ package body Sem_Res is\n       if not Found then\n          if Typ /= Any_Type then\n \n-            --  If type we are looking for is Void, then this is the\n-            --  procedure call case, and the error is simply that what\n-            --  we gave is not a procedure name (we think of procedure\n-            --  calls as expressions with types internally, but the user\n-            --  doesn't think of them this way!)\n+            --  If type we are looking for is Void, then this is the procedure\n+            --  call case, and the error is simply that what we gave is not a\n+            --  procedure name (we think of procedure calls as expressions with\n+            --  types internally, but the user doesn't think of them this way!)\n \n             if Typ = Standard_Void_Type then\n \n@@ -2003,8 +2005,8 @@ package body Sem_Res is\n                     (\"cannot use function & in a procedure call\",\n                      Name (N), Entity (Name (N)));\n \n-               --  Otherwise give general message (not clear what cases\n-               --  this covers, but no harm in providing for them!)\n+               --  Otherwise give general message (not clear what cases this\n+               --  covers, but no harm in providing for them!)\n \n                else\n                   Error_Msg_N (\"expect procedure name in procedure call\", N);\n@@ -2014,11 +2016,11 @@ package body Sem_Res is\n \n             --  Otherwise we do have a subexpression with the wrong type\n \n-            --  Check for the case of an allocator which uses an access\n-            --  type instead of the designated type. This is a common\n-            --  error and we specialize the message, posting an error\n-            --  on the operand of the allocator, complaining that we\n-            --  expected the designated type of the allocator.\n+            --  Check for the case of an allocator which uses an access type\n+            --  instead of the designated type. This is a common error and we\n+            --  specialize the message, posting an error on the operand of the\n+            --  allocator, complaining that we expected the designated type of\n+            --  the allocator.\n \n             elsif Nkind (N) = N_Allocator\n               and then Ekind (Typ) in Access_Kind\n@@ -2028,8 +2030,8 @@ package body Sem_Res is\n                Wrong_Type (Expression (N), Designated_Type (Typ));\n                Found := True;\n \n-            --  Check for view mismatch on Null in instances, for\n-            --  which the view-swapping mechanism has no identifier.\n+            --  Check for view mismatch on Null in instances, for which the\n+            --  view-swapping mechanism has no identifier.\n \n             elsif (In_Instance or else In_Inlined_Body)\n               and then (Nkind (N) = N_Null)\n@@ -2087,10 +2089,10 @@ package body Sem_Res is\n                         Elmt := First (Component_Associations (Aggr));\n                         while Present (Elmt) loop\n \n-                           --  Nothing to check is this is a default-\n-                           --  initialized component. The box will be\n-                           --  be replaced by the appropriate call during\n-                           --  late expansion.\n+                           --  If this is a default-initialized component, then\n+                           --  there is nothing to check. The box will be\n+                           --  replaced by the appropriate call during late\n+                           --  expansion.\n \n                            if not Box_Present (Elmt) then\n                               Check_Elmt (Expression (Elmt));\n@@ -2293,15 +2295,15 @@ package body Sem_Res is\n             when N_Identifier\n                              => Resolve_Entity_Name              (N, Ctx_Type);\n \n-            when N_Membership_Test\n-                             => Resolve_Membership_Op            (N, Ctx_Type);\n-\n             when N_Indexed_Component\n                              => Resolve_Indexed_Component        (N, Ctx_Type);\n \n             when N_Integer_Literal\n                              => Resolve_Integer_Literal          (N, Ctx_Type);\n \n+            when N_Membership_Test\n+                             => Resolve_Membership_Op            (N, Ctx_Type);\n+\n             when N_Null      => Resolve_Null                     (N, Ctx_Type);\n \n             when N_Op_And | N_Op_Or | N_Op_Xor\n@@ -2773,6 +2775,16 @@ package body Sem_Res is\n                           Directly_Designated_Type (Etype (A)));\n                         Set_Etype (A, New_Itype);\n                      end if;\n+\n+                     --  Ada 2005, AI-162:If the actual is an allocator, the\n+                     --  innermost enclosing statement is the master of the\n+                     --  created object.\n+\n+                     if Is_Controlled (DDT)\n+                       or else Has_Task (DDT)\n+                     then\n+                        Establish_Transient_Scope (A, False);\n+                     end if;\n                   end;\n                end if;\n \n@@ -2959,8 +2971,28 @@ package body Sem_Res is\n             --  Check that subprograms don't have improper controlling\n             --  arguments (RM 3.9.2 (9))\n \n+            --  A primitive operation may have an access parameter of an\n+            --  incomplete tagged type, but a dispatching call is illegal\n+            --  if the type is still incomplete.\n+\n             if Is_Controlling_Formal (F) then\n                Set_Is_Controlling_Actual (A);\n+\n+               if Ekind (Etype (F)) = E_Anonymous_Access_Type then\n+                  declare\n+                     Desig : constant Entity_Id := Designated_Type (Etype (F));\n+                  begin\n+                     if Ekind (Desig) = E_Incomplete_Type\n+                       and then No (Full_View (Desig))\n+                       and then No (Non_Limited_View (Desig))\n+                     then\n+                        Error_Msg_NE\n+                          (\"premature use of incomplete type& \" &\n+                           \"in dispatching call\", A, Desig);\n+                     end if;\n+                  end;\n+               end if;\n+\n             elsif Nkind (A) = N_Explicit_Dereference then\n                Validate_Remote_Access_To_Class_Wide_Type (A);\n             end if;\n@@ -3070,7 +3102,7 @@ package body Sem_Res is\n          Set_Etype (N, Base_Type (Typ));\n       end if;\n \n-      if Is_Abstract (Typ) then\n+      if Is_Abstract_Type (Typ) then\n          Error_Msg_N (\"type of allocator cannot be abstract\",  N);\n       end if;\n \n@@ -3924,7 +3956,7 @@ package body Sem_Res is\n       --  when the type of the component is an access to the array type. In\n       --  this case the call is truly ambiguous.\n \n-      elsif Needs_No_Actuals (Nam)\n+      elsif (Needs_No_Actuals (Nam) or else Needs_One_Actual (Nam))\n         and then\n           ((Is_Array_Type (Etype (Nam))\n                    and then Covers (Typ, Component_Type (Etype (Nam))))\n@@ -3950,12 +3982,33 @@ package body Sem_Res is\n                Set_Entity (Subp, Nam);\n \n                if Component_Type (Ret_Type) /= Any_Type then\n-                  Index_Node :=\n-                    Make_Indexed_Component (Loc,\n-                      Prefix =>\n-                        Make_Function_Call (Loc,\n-                          Name => New_Subp),\n-                      Expressions => Parameter_Associations (N));\n+                  if Needs_No_Actuals (Nam) then\n+\n+                     --  Indexed call to a parameterless function\n+\n+                     Index_Node :=\n+                       Make_Indexed_Component (Loc,\n+                         Prefix =>\n+                           Make_Function_Call (Loc,\n+                             Name => New_Subp),\n+                         Expressions => Parameter_Associations (N));\n+                  else\n+                     --  An Ada 2005 prefixed call to a primitive operation\n+                     --  whose first parameter is the prefix. This prefix was\n+                     --  prepended to the parameter list, which is actually a\n+                     --  list of indices. Remove the prefix in order to build\n+                     --  the proper indexed component.\n+\n+                     Index_Node :=\n+                        Make_Indexed_Component (Loc,\n+                          Prefix =>\n+                            Make_Function_Call (Loc,\n+                               Name => New_Subp,\n+                               Parameter_Associations =>\n+                                 New_List\n+                                   (Remove_Head (Parameter_Associations (N)))),\n+                           Expressions => Parameter_Associations (N));\n+                  end if;\n \n                   --  Since we are correcting a node classification error made\n                   --  by the parser, we call Replace rather than Rewrite.\n@@ -4110,12 +4163,16 @@ package body Sem_Res is\n \n       --  Create a transient scope if the resulting type requires it\n \n-      --  There are 3 notable exceptions: in init procs, the transient scope\n+      --  There are 4 notable exceptions: in init procs, the transient scope\n       --  overhead is not needed and even incorrect due to the actual expansion\n-      --  of adjust calls; the second case is enumeration literal pseudo calls,\n-      --  the other case is intrinsic subprograms (Unchecked_Conversion and\n+      --  of adjust calls; the second case is enumeration literal pseudo calls;\n+      --  the third case is intrinsic subprograms (Unchecked_Conversion and\n       --  source information functions) that do not use the secondary stack\n-      --  even though the return type is unconstrained.\n+      --  even though the return type is unconstrained; the fourth case is a\n+      --  call to a build-in-place function, since such functions may allocate\n+      --  their result directly in a target object, and cases where the result\n+      --  does get allocated in the secondary stack are checked for within the\n+      --  specialized Exp_Ch6 procedures for expanding build-in-place calls.\n \n       --  If this is an initialization call for a type whose initialization\n       --  uses the secondary stack, we also need to create a transient scope\n@@ -4136,12 +4193,12 @@ package body Sem_Res is\n       elsif Expander_Active\n         and then Is_Type (Etype (Nam))\n         and then Requires_Transient_Scope (Etype (Nam))\n+        and then not Is_Build_In_Place_Function (Nam)\n         and then Ekind (Nam) /= E_Enumeration_Literal\n         and then not Within_Init_Proc\n         and then not Is_Intrinsic_Subprogram (Nam)\n       then\n-         Establish_Transient_Scope\n-           (N, Sec_Stack => not Functions_Return_By_DSP_On_Target);\n+         Establish_Transient_Scope (N, Sec_Stack => True);\n \n          --  If the call appears within the bounds of a loop, it will\n          --  be rewritten and reanalyzed, nothing left to do here.\n@@ -4213,7 +4270,8 @@ package body Sem_Res is\n       then\n          Check_Dispatching_Call (N);\n \n-      elsif Is_Abstract (Nam)\n+      elsif Ekind (Nam) /= E_Subprogram_Type\n+        and then Is_Abstract_Subprogram (Nam)\n         and then not In_Instance\n       then\n          Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Nam);\n@@ -4978,8 +5036,7 @@ package body Sem_Res is\n       elsif Expander_Active\n         and then Requires_Transient_Scope (Etype (Nam))\n       then\n-         Establish_Transient_Scope (N,\n-           Sec_Stack => not Functions_Return_By_DSP_On_Target);\n+         Establish_Transient_Scope (N, Sec_Stack => True);\n       end if;\n    end Resolve_Entry_Call;\n \n@@ -5073,6 +5130,7 @@ package body Sem_Res is\n \n          elsif T = Any_Access\n            or else Ekind (T) = E_Allocator_Type\n+           or else Ekind (T) = E_Access_Attribute_Type\n          then\n             T := Find_Unique_Access_Type;\n \n@@ -5086,6 +5144,14 @@ package body Sem_Res is\n          Resolve (L, T);\n          Resolve (R, T);\n \n+         --  If the unique type is a class-wide type then it will be expanded\n+         --  into a dispatching call to the predefined primitive. Therefore we\n+         --  check here for potential violation of such restriction.\n+\n+         if Is_Class_Wide_Type (T) then\n+            Check_Restriction (No_Dispatching_Calls, N);\n+         end if;\n+\n          if Warn_On_Redundant_Constructs\n            and then Comes_From_Source (N)\n            and then Is_Entity_Name (R)\n@@ -5112,7 +5178,7 @@ package body Sem_Res is\n          then\n             Eval_Relational_Op (N);\n          elsif Nkind (N) = N_Op_Ne\n-           and then Is_Abstract (Entity (N))\n+           and then Is_Abstract_Subprogram (Entity (N))\n          then\n             Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Entity (N));\n          end if;\n@@ -5341,8 +5407,18 @@ package body Sem_Res is\n          end loop;\n       end if;\n \n-      Warn_On_Suspicious_Index (Name, First (Expressions (N)));\n-      Eval_Indexed_Component (N);\n+      --  Do not generate the warning on suspicious index if we are analyzing\n+      --  package Ada.Tags; otherwise we will report the warning with the\n+      --  Prims_Ptr field of the dispatch table.\n+\n+      if Scope (Etype (Prefix (N))) = Standard_Standard\n+        or else not\n+          Is_RTU (Cunit_Entity (Get_Source_Unit (Etype (Prefix (N)))),\n+                  Ada_Tags)\n+      then\n+         Warn_On_Suspicious_Index (Name, First (Expressions (N)));\n+         Eval_Indexed_Component (N);\n+      end if;\n    end Resolve_Indexed_Component;\n \n    -----------------------------\n@@ -6498,7 +6574,20 @@ package body Sem_Res is\n          Index := First_Index (Array_Type);\n          Resolve (Drange, Base_Type (Etype (Index)));\n \n-         if Nkind (Drange) = N_Range then\n+         if Nkind (Drange) = N_Range\n+\n+            --  Do not apply the range check to nodes associated with the\n+            --  frontend expansion of the dispatch table. We first check\n+            --  if Ada.Tags is already loaded to void the addition of an\n+            --  undesired dependence on such run-time unit.\n+\n+           and then not\n+             (RTU_Loaded (Ada_Tags)\n+              and then Nkind (Prefix (N)) = N_Selected_Component\n+              and then Present (Entity (Selector_Name (Prefix (N))))\n+              and then Entity (Selector_Name (Prefix (N)))\n+                         = RTE_Record_Component (RE_Prims_Ptr))\n+         then\n             Apply_Range_Check (Drange, Etype (Index));\n          end if;\n       end if;\n@@ -6881,6 +6970,15 @@ package body Sem_Res is\n \n       Eval_Type_Conversion (N);\n \n+      --  Even when evaluation is not possible, we may be able to simplify\n+      --  the conversion or its expression. This needs to be done before\n+      --  applying checks, since otherwise the checks may use the original\n+      --  expression and defeat the simplifications. The is specifically\n+      --  the case for elimination of the floating-point Truncation\n+      --  attribute in float-to-int conversions.\n+\n+      Simplify_Type_Conversion (N);\n+\n       --  If after evaluation, we still have a type conversion, then we\n       --  may need to apply checks required for a subtype conversion.\n \n@@ -6929,8 +7027,13 @@ package body Sem_Res is\n       end if;\n \n       --  Ada 2005 (AI-251): Handle conversions to abstract interface types\n+      --  No need to perform any interface conversion if the type of the\n+      --  expression coincides with the target type.\n \n-      if Ada_Version >= Ada_05 and then Expander_Active then\n+      if Ada_Version >= Ada_05\n+        and then Expander_Active\n+        and then Opnd_Type /= Target_Type\n+      then\n          if Is_Access_Type (Target_Type) then\n             Target_Type := Directly_Designated_Type (Target_Type);\n          end if;\n@@ -6994,18 +7097,7 @@ package body Sem_Res is\n       Hi    : Uint;\n \n    begin\n-      --  Generate warning for expressions like -5 mod 3\n-\n-      if Warn_On_Questionable_Missing_Parens\n-        and then Paren_Count (N) = 0\n-        and then (Nkind (N) = N_Op_Minus or else Nkind (N) = N_Op_Plus)\n-        and then Paren_Count (Right_Opnd (N)) = 0\n-        and then Nkind (Right_Opnd (N)) in N_Multiplying_Operator\n-        and then Comes_From_Source (N)\n-      then\n-         Error_Msg_N\n-           (\"?unary minus expression should be parenthesized here\", N);\n-      end if;\n+      --  Deal with intrincis unary operators\n \n       if Comes_From_Source (N)\n         and then Ekind (Entity (N)) = E_Function\n@@ -7016,8 +7108,11 @@ package body Sem_Res is\n          return;\n       end if;\n \n+      --  Deal with universal cases\n+\n       if Etype (R) = Universal_Integer\n-           or else Etype (R) = Universal_Real\n+           or else\n+         Etype (R) = Universal_Real\n       then\n          Check_For_Visible_Operator (N, B_Typ);\n       end if;\n@@ -7038,6 +7133,8 @@ package body Sem_Res is\n          end if;\n       end if;\n \n+      --  Deal with reference generation\n+\n       Check_Unset_Reference (R);\n       Generate_Operator_Reference (N, B_Typ);\n       Eval_Unary_Op (N);\n@@ -7051,6 +7148,135 @@ package body Sem_Res is\n             Enable_Overflow_Check (N);\n          end if;\n       end if;\n+\n+      --  Generate warning for expressions like -5 mod 3 for integers. No\n+      --  need to worry in the floating-point case, since parens do not affect\n+      --  the result so there is no point in giving in a warning.\n+\n+      declare\n+         Norig : constant Node_Id := Original_Node (N);\n+         Rorig : Node_Id;\n+         Val   : Uint;\n+         HB    : Uint;\n+         LB    : Uint;\n+         Lval  : Uint;\n+         Opnd  : Node_Id;\n+\n+      begin\n+         if Warn_On_Questionable_Missing_Parens\n+           and then Comes_From_Source (Norig)\n+           and then Is_Integer_Type (Typ)\n+           and then Nkind (Norig) = N_Op_Minus\n+         then\n+            Rorig := Original_Node (Right_Opnd (Norig));\n+\n+            --  We are looking for cases where the right operand is not\n+            --  parenthesized, and is a bianry operator, multiply, divide, or\n+            --  mod. These are the cases where the grouping can affect results.\n+\n+            if Paren_Count (Rorig) = 0\n+              and then (Nkind (Rorig) = N_Op_Mod\n+                          or else\n+                        Nkind (Rorig) = N_Op_Multiply\n+                          or else\n+                        Nkind (Rorig) = N_Op_Divide)\n+            then\n+               --  For mod, we always give the warning, since the value is\n+               --  affected by the parenthesization (e.g. (-5) mod 315 /=\n+               --  (5 mod 315)). But for the other cases, the only concern is\n+               --  overflow, e.g. for the case of 8 big signed (-(2 * 64)\n+               --  overflows, but (-2) * 64 does not). So we try to give the\n+               --  message only when overflow is possible.\n+\n+               if Nkind (Rorig) /= N_Op_Mod\n+                 and then Compile_Time_Known_Value (R)\n+               then\n+                  Val := Expr_Value (R);\n+\n+                  if Compile_Time_Known_Value (Type_High_Bound (Typ)) then\n+                     HB := Expr_Value (Type_High_Bound (Typ));\n+                  else\n+                     HB := Expr_Value (Type_High_Bound (Base_Type (Typ)));\n+                  end if;\n+\n+                  if Compile_Time_Known_Value (Type_Low_Bound (Typ)) then\n+                     LB := Expr_Value (Type_Low_Bound (Typ));\n+                  else\n+                     LB := Expr_Value (Type_Low_Bound (Base_Type (Typ)));\n+                  end if;\n+\n+                  --  Note that the test below is deliberately excluding\n+                  --  the largest negative number, since that is a potentially\n+                  --  troublesome case (e.g. -2 * x, where the result is the\n+                  --  largest negative integer has an overflow with 2 * x).\n+\n+                  if Val > LB and then Val <= HB then\n+                     return;\n+                  end if;\n+               end if;\n+\n+               --  For the multiplication case, the only case we have to worry\n+               --  about is when (-a)*b is exactly the largest negative number\n+               --  so that -(a*b) can cause overflow. This can only happen if\n+               --  a is a power of 2, and more generally if any operand is a\n+               --  constant that is not a power of 2, then the parentheses\n+               --  cannot affect whether overflow occurs. We only bother to\n+               --  test the left most operand\n+\n+               --  Loop looking at left operands for one that has known value\n+\n+               Opnd := Rorig;\n+               Opnd_Loop : while Nkind (Opnd) = N_Op_Multiply loop\n+                  if Compile_Time_Known_Value (Left_Opnd (Opnd)) then\n+                     Lval := UI_Abs (Expr_Value (Left_Opnd (Opnd)));\n+\n+                     --  Operand value of 0 or 1 skips warning\n+\n+                     if Lval <= 1 then\n+                        return;\n+\n+                     --  Otherwise check power of 2, if power of 2, warn, if\n+                     --  anything else, skip warning.\n+\n+                     else\n+                        while Lval /= 2 loop\n+                           if Lval mod 2 = 1 then\n+                              return;\n+                           else\n+                              Lval := Lval / 2;\n+                           end if;\n+                        end loop;\n+\n+                        exit Opnd_Loop;\n+                     end if;\n+                  end if;\n+\n+                  --  Keep looking at left operands\n+\n+                  Opnd := Left_Opnd (Opnd);\n+               end loop Opnd_Loop;\n+\n+               --  For rem or \"/\" we can only have a problematic situation\n+               --  if the divisor has a value of minus one or one. Otherwise\n+               --  overflow is impossible (divisor > 1) or we have a case of\n+               --  division by zero in any case.\n+\n+               if (Nkind (Rorig) = N_Op_Divide\n+                    or else\n+                   Nkind (Rorig) = N_Op_Rem)\n+                 and then Compile_Time_Known_Value (Right_Opnd (Rorig))\n+                 and then UI_Abs (Expr_Value (Right_Opnd (Rorig))) /= 1\n+               then\n+                  return;\n+               end if;\n+\n+               --  If we fall through warning should be issued\n+\n+               Error_Msg_N\n+                 (\"?unary minus expression should be parenthesized here\", N);\n+            end if;\n+         end if;\n+      end;\n    end Resolve_Unary_Op;\n \n    ----------------------------------\n@@ -7318,7 +7544,7 @@ package body Sem_Res is\n          begin\n             Index_Subtype :=\n               Create_Itype (Subtype_Kind (Ekind (Index_Type)), N);\n-            Drange := Make_Range (Loc, Low_Bound, High_Bound);\n+            Drange := Make_Range (Loc, New_Copy_Tree (Low_Bound), High_Bound);\n             Set_Scalar_Range (Index_Subtype, Drange);\n             Set_Parent (Drange, N);\n             Analyze_And_Resolve (Drange, Index_Type);\n@@ -7347,6 +7573,47 @@ package body Sem_Res is\n       end if;\n    end Set_String_Literal_Subtype;\n \n+   ------------------------------\n+   -- Simplify_Type_Conversion --\n+   ------------------------------\n+\n+   procedure Simplify_Type_Conversion (N : Node_Id) is\n+   begin\n+      if Nkind (N) = N_Type_Conversion then\n+         declare\n+            Operand    : constant Node_Id   := Expression (N);\n+            Target_Typ : constant Entity_Id := Etype (N);\n+            Opnd_Typ   : constant Entity_Id := Etype (Operand);\n+\n+         begin\n+            if Is_Floating_Point_Type (Opnd_Typ)\n+              and then\n+                (Is_Integer_Type (Target_Typ)\n+                   or else (Is_Fixed_Point_Type (Target_Typ)\n+                              and then Conversion_OK (N)))\n+              and then Nkind (Operand) = N_Attribute_Reference\n+              and then Attribute_Name (Operand) = Name_Truncation\n+\n+            --  Special processing required if the conversion is the expression\n+            --  of a Truncation attribute reference. In this case we replace:\n+\n+            --     ityp (ftyp'Truncation (x))\n+\n+            --  by\n+\n+            --     ityp (x)\n+\n+            --  with the Float_Truncate flag set, which is more efficient\n+\n+            then\n+               Rewrite (Operand,\n+                 Relocate_Node (First (Expressions (Operand))));\n+               Set_Float_Truncate (N, True);\n+            end if;\n+         end;\n+      end if;\n+   end Simplify_Type_Conversion;\n+\n    -----------------------------\n    -- Unique_Fixed_Point_Type --\n    -----------------------------\n@@ -7643,10 +7910,10 @@ package body Sem_Res is\n               Conversion_Check (False,\n                 \"downward conversion of tagged objects not allowed\");\n \n-         --  Ada 2005 (AI-251): The conversion of a tagged type to an\n-         --  abstract interface type is always valid\n+         --  Ada 2005 (AI-251): The conversion to/from interface types is\n+         --  always valid\n \n-         elsif Is_Interface (Target_Type) then\n+         elsif Is_Interface (Target_Type) or else Is_Interface (Opnd_Type) then\n             return True;\n \n          elsif Is_Access_Type (Opnd_Type)\n@@ -7988,15 +8255,38 @@ package body Sem_Res is\n          end if;\n \n          declare\n-            Target : constant Entity_Id := Designated_Type (Target_Type);\n-            Opnd   : constant Entity_Id := Designated_Type (Opnd_Type);\n+            function Full_Designated_Type (T : Entity_Id) return Entity_Id;\n+            --  Helper function to handle limited views\n+\n+            --------------------------\n+            -- Full_Designated_Type --\n+            --------------------------\n+\n+            function Full_Designated_Type (T : Entity_Id) return Entity_Id is\n+               Desig : constant Entity_Id := Designated_Type (T);\n+            begin\n+               if From_With_Type (Desig)\n+                 and then Is_Incomplete_Type (Desig)\n+                 and then Present (Non_Limited_View (Desig))\n+               then\n+                  return Non_Limited_View (Desig);\n+               else\n+                  return Desig;\n+               end if;\n+            end Full_Designated_Type;\n+\n+            Target : constant Entity_Id := Full_Designated_Type (Target_Type);\n+            Opnd   : constant Entity_Id := Full_Designated_Type (Opnd_Type);\n+\n+            Same_Base : constant Boolean :=\n+                          Base_Type (Target) = Base_Type (Opnd);\n \n          begin\n             if Is_Tagged_Type (Target) then\n                return Valid_Tagged_Conversion (Target, Opnd);\n \n             else\n-               if Base_Type (Target) /= Base_Type (Opnd) then\n+               if not Same_Base then\n                   Error_Msg_NE\n                     (\"target designated type not compatible with }\",\n                      N, Base_Type (Opnd));\n@@ -8031,10 +8321,27 @@ package body Sem_Res is\n                or else\n              Ekind (Target_Type) = E_Anonymous_Access_Subprogram_Type)\n         and then No (Corresponding_Remote_Type (Opnd_Type))\n-        and then Conversion_Check\n-                   (Ekind (Base_Type (Opnd_Type)) = E_Access_Subprogram_Type,\n-                    \"illegal operand for access subprogram conversion\")\n       then\n+         if\n+           Ekind (Base_Type (Opnd_Type)) = E_Anonymous_Access_Subprogram_Type\n+         then\n+            Error_Msg_N\n+              (\"illegal attempt to store anonymous access to subprogram\",\n+               Operand);\n+            Error_Msg_N\n+              (\"\\value has deeper accessibility than any master \" &\n+               \"('R'M 3.10.2 (13))\",\n+               Operand);\n+\n+            if Is_Entity_Name (Operand)\n+              and then Ekind (Entity (Operand)) = E_In_Parameter\n+            then\n+               Error_Msg_NE\n+                 (\"\\use named access type for& instead of access parameter\",\n+                  Operand, Entity (Operand));\n+            end if;\n+         end if;\n+\n          --  Check that the designated types are subtype conformant\n \n          Check_Subtype_Conformant (New_Id  => Designated_Type (Target_Type),"}]}