{"sha": "f6b640be240d14ff992b96cdd27d644f3eee1318", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZiNjQwYmUyNDBkMTRmZjk5MmI5NmNkZDI3ZDY0NGYzZWVlMTMxOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-11-11T23:38:34Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-11-11T23:38:34Z"}, "message": "Make std::mem_fn work with varargs functions.\n\n\t* include/std/functional (_Mem_fn_traits): Add partial specializations\n\tfor varargs functions.\n\t(_Mem_fn_base): Do not check arguments are convertible for varargs.\n\t(_Bind_check_arity): Add partial specializations for varargs functions.\n\t* include/std/type_traits (__bool_constant): Add alias template.\n\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error.\n\t* testsuite/20_util/bind/refqual.cc: New, test ref-qualifiers.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Adjust dg-error.\n\t* testsuite/20_util/function_objects/mem_fn/refqual.cc: Test varargs.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n\tdg-error.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc: Adjust\n\tdg-error.\n\nFrom-SVN: r217393", "tree": {"sha": "535810f72152d6ec7ff4a29780a15f8e44eab830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/535810f72152d6ec7ff4a29780a15f8e44eab830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6b640be240d14ff992b96cdd27d644f3eee1318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b640be240d14ff992b96cdd27d644f3eee1318", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6b640be240d14ff992b96cdd27d644f3eee1318", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b640be240d14ff992b96cdd27d644f3eee1318/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d00119cfbbcadccb56e5a0b8fe447ad7554d681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d00119cfbbcadccb56e5a0b8fe447ad7554d681", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d00119cfbbcadccb56e5a0b8fe447ad7554d681"}], "stats": {"total": 309, "additions": 151, "deletions": 158}, "files": [{"sha": "f19aabc7e26fb93f3855ddc4782e49098f001ffc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -1,3 +1,19 @@\n+2014-11-11  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/functional (_Mem_fn_traits): Add partial specializations\n+\tfor varargs functions.\n+\t(_Mem_fn_base): Do not check arguments are convertible for varargs.\n+\t(_Bind_check_arity): Add partial specializations for varargs functions.\n+\t* include/std/type_traits (__bool_constant): Add alias template.\n+\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error.\n+\t* testsuite/20_util/bind/refqual.cc: New, test ref-qualifiers.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Adjust dg-error.\n+\t* testsuite/20_util/function_objects/mem_fn/refqual.cc: Test varargs.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n+\tdg-error.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc: Adjust\n+\tdg-error.\n+\n 2014-11-11  Siva Chandra Reddy  <sivachandra@google.com>\n \n \t* testsuite/libstdc++-xmethods/associative-containers.cc: Add new"}, {"sha": "92489b7d4b9a7922a2b51940dc529a0db4516e0e", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 78, "deletions": 149, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -512,113 +512,38 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;\n     };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)>\n-    : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...);\n-      using __lvalue = true_type;\n-      using __rvalue = true_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const>\n-    : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const;\n-      using __lvalue = true_type;\n-      using __rvalue = true_type;\n+#define _GLIBCXX_MEM_FN_TRAITS2(_CV, _REF, _LVAL, _RVAL)\t\t\\\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\t\\\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) _CV _REF>\t\\\n+    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) _CV _REF;\t\\\n+      using __lvalue = _LVAL;\t\t\t\t\t\t\\\n+      using __rvalue = _RVAL;\t\t\t\t\t\t\\\n+      using __vararg = false_type;\t\t\t\t\t\\\n+    };\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\t\\\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) _CV _REF>\t\\\n+    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes... ...) _CV _REF;\t\\\n+      using __lvalue = _LVAL;\t\t\t\t\t\t\\\n+      using __rvalue = _RVAL;\t\t\t\t\t\t\\\n+      using __vararg = true_type;\t\t\t\t\t\\\n     };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile>\n-    : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) volatile;\n-      using __lvalue = true_type;\n-      using __rvalue = true_type;\n-    };\n+#define _GLIBCXX_MEM_FN_TRAITS(_REF, _LVAL, _RVAL)\t\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(\t\t, _REF, _LVAL, _RVAL)\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(const\t\t, _REF, _LVAL, _RVAL)\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(volatile\t, _REF, _LVAL, _RVAL)\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(const volatile, _REF, _LVAL, _RVAL)\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile>\n-    : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const volatile;\n-      using __lvalue = true_type;\n-      using __rvalue = true_type;\n-    };\n+_GLIBCXX_MEM_FN_TRAITS( , true_type, true_type)\n+_GLIBCXX_MEM_FN_TRAITS(&, true_type, false_type)\n+_GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)&>\n-    : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...)&;\n-      using __lvalue = true_type;\n-      using __rvalue = false_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const&>\n-    : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const&;\n-      using __lvalue = true_type;\n-      using __rvalue = false_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile&>\n-    : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) volatile&;\n-      using __lvalue = true_type;\n-      using __rvalue = false_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile&>\n-    : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const volatile&;\n-      using __lvalue = true_type;\n-      using __rvalue = false_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)&&>\n-    : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...)&&;\n-      using __lvalue = false_type;\n-      using __rvalue = true_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const&&>\n-    : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const&&;\n-      using __lvalue = false_type;\n-      using __rvalue = true_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile&&>\n-    : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) volatile&&;\n-      using __lvalue = false_type;\n-      using __rvalue = true_type;\n-    };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile&&>\n-    : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>\n-    {\n-      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const volatile&&;\n-      using __lvalue = false_type;\n-      using __rvalue = true_type;\n-    };\n+#undef _GLIBCXX_MEM_FN_TRAITS\n+#undef _GLIBCXX_MEM_FN_TRAITS2\n \n   template<typename _MemFunPtr,\n \t   bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>\n@@ -627,62 +552,40 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n       using _Traits = _Mem_fn_traits<_MemFunPtr>;\n \n-    public:\n-      using result_type = typename _Traits::__result_type;\n-      using _Arity = typename _Traits::__arity;\n-\n-    private:\n       using _Class = typename _Traits::__class_type;\n       using _ArgTypes = typename _Traits::__arg_types;\n       using _Pmf = typename _Traits::__pmf_type;\n \n-      template<typename _Tp, typename... _Args>\n-\tresult_type\n-\t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_Args&&... __args) const\n-\t{\n-\t  return (std::forward<_Tp>(__object).*_M_pmf)\n-\t    (std::forward<_Args>(__args)...);\n-\t}\n-\n-      template<typename _Tp, typename... _Args>\n-\tresult_type\n-\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n-\t{ return ((*__ptr).*_M_pmf)(std::forward<_Args>(__args)...); }\n-\n-      // Require each _Args to be convertible to corresponding _ArgTypes\n-      template<typename... _Args>\n-\tusing _RequireValidArgs\n-\t  = _Require<_AllConvertible<_Pack<_Args...>, _ArgTypes>>;\n+      using _Arity = typename _Traits::__arity;\n+      using _Varargs = typename _Traits::__vararg;\n \n-      // Require each _Args to be convertible to corresponding _ArgTypes\n-      // and require _Tp is not _Class, _Class& or _Class*\n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs2\n-\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _ArgTypes>>;\n+      template<typename _Func, typename... _BoundArgs>\n+\tfriend struct _Bind_check_arity;\n \n-      // Require each _Args to be convertible to corresponding _ArgTypes\n-      // and require _Tp is _Class or derived from _Class\n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs3\n-\t  = _Require<is_base_of<_Class, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _ArgTypes>>;\n+      // for varargs functions we just check the number of arguments,\n+      // otherwise we also check they are convertible.\n+      template<typename _Args>\n+\tusing _CheckArgs = typename conditional<_Varargs::value,\n+\t  __bool_constant<(_Args::value >= _ArgTypes::value)>,\n+\t  _AllConvertible<_Args, _ArgTypes>\n+\t>::type;\n \n     public:\n+      using result_type = typename _Traits::__result_type;\n+\n       explicit _Mem_fn_base(_Pmf __pmf) : _M_pmf(__pmf) { }\n \n       // Handle objects\n       template<typename... _Args, typename _Req\n                = _Require<typename _Traits::__lvalue,\n-                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+                          _CheckArgs<_Pack<_Args...>>>>\n \tresult_type\n \toperator()(_Class& __object, _Args&&... __args) const\n \t{ return (__object.*_M_pmf)(std::forward<_Args>(__args)...); }\n \n       template<typename... _Args, typename _Req\n                = _Require<typename _Traits::__rvalue,\n-                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+                          _CheckArgs<_Pack<_Args...>>>>\n \tresult_type\n \toperator()(_Class&& __object, _Args&&... __args) const\n \t{\n@@ -692,16 +595,15 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       // Handle pointers\n       template<typename... _Args, typename _Req\n                = _Require<typename _Traits::__lvalue,\n-                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+                          _CheckArgs<_Pack<_Args...>>>>\n \tresult_type\n \toperator()(_Class* __object, _Args&&... __args) const\n \t{ return (__object->*_M_pmf)(std::forward<_Args>(__args)...); }\n \n       // Handle smart pointers, references and pointers to derived\n-      // TODO how to constrain to lvalue/rvalue here? constrain _M_call?\n       template<typename _Tp, typename... _Args, typename _Req\n                = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n-                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+                          _CheckArgs<_Pack<_Args...>>>>\n \tresult_type\n \toperator()(_Tp&& __object, _Args&&... __args) const\n \t{\n@@ -711,14 +613,27 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Handle reference wrappers\n       template<typename _Tp, typename... _Args, typename _Req\n-               = _Require<is_base_of<_Class, _Tp>,\n-                          typename _Traits::__lvalue,\n-                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+               = _Require<is_base_of<_Class, _Tp>, typename _Traits::__lvalue,\n+                          _CheckArgs<_Pack<_Args...>>>>\n \tresult_type\n \toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n \t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n \n     private:\n+      template<typename _Tp, typename... _Args>\n+\tresult_type\n+\t_M_call(_Tp&& __object, const volatile _Class *,\n+\t\t_Args&&... __args) const\n+\t{\n+\t  return (std::forward<_Tp>(__object).*_M_pmf)\n+\t    (std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename _Tp, typename... _Args>\n+\tresult_type\n+\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n+\t{ return ((*__ptr).*_M_pmf)(std::forward<_Args>(__args)...); }\n+\n       _Pmf _M_pmf;\n     };\n \n@@ -750,9 +665,13 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t-> decltype((*__ptr).*std::declval<__pm_type&>())\n \t{ return (*__ptr).*_M_pm; }\n \n-    public:\n       using _Arity = integral_constant<size_t, 0>;\n+      using _Varargs = false_type;\n+\n+      template<typename _Func, typename... _BoundArgs>\n+\tfriend struct _Bind_check_arity;\n \n+    public:\n       explicit\n       _Mem_fn_base(_Res _Class::*__pm) noexcept : _M_pm(__pm) { }\n \n@@ -1493,12 +1412,22 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n                    \"Wrong number of arguments for function\");\n     };\n \n+  template<typename _Ret, typename... _Args, typename... _BoundArgs>\n+    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>\n+    {\n+      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),\n+                   \"Wrong number of arguments for function\");\n+    };\n+\n   template<typename _Tp, typename _Class, typename... _BoundArgs>\n     struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>\n     {\n       using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;\n-      static_assert(sizeof...(_BoundArgs) == _Arity::value + 1,\n-                   \"Wrong number of arguments for pointer-to-member\");\n+      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;\n+      static_assert(_Varargs::value\n+\t\t    ? sizeof...(_BoundArgs) >= _Arity::value + 1\n+\t\t    : sizeof...(_BoundArgs) == _Arity::value + 1,\n+\t\t    \"Wrong number of arguments for pointer-to-member\");\n     };\n \n   // Trait type used to remove std::bind() from overload set via SFINAE"}, {"sha": "cecc7dc2697de995e508aa94ac8381e4b02a0cd6", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -89,6 +89,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// The type used as a compile-time boolean with false value.\n   typedef integral_constant<bool, false>    false_type;\n \n+  template<bool __v>\n+    using __bool_constant = integral_constant<bool, __v>;\n+\n   // Meta programming helper types.\n \n   template<bool, typename, typename>"}, {"sha": "7810968663d1ead1b7191319e6b6e7118624a826", "filename": "libstdc++-v3/testsuite/20_util/bind/ref_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -30,10 +30,10 @@ void test01()\n {\n   const int dummy = 0;\n   std::bind(&inc, _1)(0);               // { dg-error  \"no match\" }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1207 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1221 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1235 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1249 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1126 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1140 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1154 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1168 }\n   std::bind(&inc, std::ref(dummy))();\t// { dg-error  \"no match\" }\n }\n "}, {"sha": "76f4f5c4093beb775688fd8e87c9946eff958db2", "filename": "libstdc++-v3/testsuite/20_util/bind/refqual.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Frefqual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Frefqual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Frefqual.cc?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -0,0 +1,43 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  int f() const& { return 0; }\n+  int g(int i, ...)& { return i; }\n+};\n+\n+void\n+test01()\n+{\n+  X x;\n+  auto b = std::bind(&X::f, &x);\n+  VERIFY( b() == 0 );\n+  auto bb = std::bind(&X::g, &x, 1, 2);\n+  VERIFY( bb() == 1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "cdcbdbe87f7c63666cdd991f79488cffa15c9495", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 2201 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 2204 }\n \n #include <utility>\n "}, {"sha": "4f3a64bacfa384b36f7502cfbea869ff51b488ca", "filename": "libstdc++-v3/testsuite/20_util/function_objects/mem_fn/refqual.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Frefqual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Frefqual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Frefqual.cc?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -24,11 +24,13 @@ struct Foo\n {\n   void r()&& { }\n   int l() const& { return 0; }\n+  void lv(int, ...)& { }\n };\n \n void test01()\n {\n   Foo f;\n   int i = std::mem_fn(&Foo::l)( f );\n   std::mem_fn(&Foo::r)( std::move(f) );\n+  std::mem_fn(&Foo::lv)( f, 1, 2, 3 );\n }"}, {"sha": "b38ffdf87d82b83798243f8534cd99d2d687d430", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1866 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1830 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1869 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1833 }"}, {"sha": "d2e11a698a98189ea64e6816c4901270d1995c47", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b640be240d14ff992b96cdd27d644f3eee1318/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=f6b640be240d14ff992b96cdd27d644f3eee1318", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1754 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1718 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1757 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1721 }"}]}