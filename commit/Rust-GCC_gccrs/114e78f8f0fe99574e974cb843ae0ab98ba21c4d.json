{"sha": "114e78f8f0fe99574e974cb843ae0ab98ba21c4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0ZTc4ZjhmMGZlOTk1NzRlOTc0Y2I4NDNhZTBhYjk4YmEyMWM0ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-12-18T15:38:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-18T15:38:40Z"}, "message": "* libgcc2.c (__bb_exit_func): Kill -ax dumping code.\n\nFrom-SVN: r48159", "tree": {"sha": "92a03a1dfcd2bca1c99ba0e0f628242f160873d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92a03a1dfcd2bca1c99ba0e0f628242f160873d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/114e78f8f0fe99574e974cb843ae0ab98ba21c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114e78f8f0fe99574e974cb843ae0ab98ba21c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114e78f8f0fe99574e974cb843ae0ab98ba21c4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114e78f8f0fe99574e974cb843ae0ab98ba21c4d/comments", "author": null, "committer": null, "parents": [{"sha": "b1bf2706e8a6c5bc3322d1b129f5efa447bf45ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1bf2706e8a6c5bc3322d1b129f5efa447bf45ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1bf2706e8a6c5bc3322d1b129f5efa447bf45ea"}], "stats": {"total": 325, "additions": 100, "deletions": 225}, "files": [{"sha": "87586aa7f762b4fc7b1945b1988cfb2d80eb3e45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114e78f8f0fe99574e974cb843ae0ab98ba21c4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114e78f8f0fe99574e974cb843ae0ab98ba21c4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=114e78f8f0fe99574e974cb843ae0ab98ba21c4d", "patch": "@@ -1,3 +1,7 @@\n+Tue Dec 18 16:37:42 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* libgcc2.c (__bb_exit_func): Kill -ax dumping code.\n+\n 2001-12-18  Jason Merrill  <jason@redhat.com>\n \n \tC++ ABI change: destroy value arguments in caller."}, {"sha": "9376fa0e743740542195ab0542d4eeb21e72cf68", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 96, "deletions": 225, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114e78f8f0fe99574e974cb843ae0ab98ba21c4d/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114e78f8f0fe99574e974cb843ae0ab98ba21c4d/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=114e78f8f0fe99574e974cb843ae0ab98ba21c4d", "patch": "@@ -1332,275 +1332,146 @@ static int num_digits (long long value, int base) __attribute__ ((const));\n void\n __bb_exit_func (void)\n {\n-  FILE *da_file, *file;\n+  FILE *da_file;\n   long time_value;\n   int i;\n+  struct bb *ptr;\n \n   if (bb_head == 0)\n     return;\n \n   i = strlen (bb_head->filename) - 3;\n \n-  if (!strcmp (bb_head->filename+i, \".da\"))\n-    {\n-      /* Must be -fprofile-arcs not -a.\n-\t Dump data in a form that gcov expects.  */\n-\n-      struct bb *ptr;\n \n-      for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n+  for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n+    {\n+      int firstchar;\n+\n+      /* Make sure the output file exists -\n+         but don't clobber exiting data.  */\n+      if ((da_file = fopen (ptr->filename, \"a\")) != 0)\n+\tfclose (da_file);\n+\n+      /* Need to re-open in order to be able to write from the start.  */\n+      da_file = fopen (ptr->filename, \"r+b\");\n+      /* Some old systems might not allow the 'b' mode modifier.\n+         Therefore, try to open without it.  This can lead to a race\n+         condition so that when you delete and re-create the file, the\n+         file might be opened in text mode, but then, you shouldn't\n+         delete the file in the first place.  */\n+      if (da_file == 0)\n+\tda_file = fopen (ptr->filename, \"r+\");\n+      if (da_file == 0)\n \t{\n-\t  int firstchar;\n-\n-\t  /* Make sure the output file exists -\n-\t     but don't clobber exiting data.  */\n-\t  if ((da_file = fopen (ptr->filename, \"a\")) != 0)\n-\t    fclose (da_file);\n-\n-\t  /* Need to re-open in order to be able to write from the start.  */\n-\t  da_file = fopen (ptr->filename, \"r+b\");\n-\t  /* Some old systems might not allow the 'b' mode modifier.\n-\t     Therefore, try to open without it.  This can lead to a race\n-\t     condition so that when you delete and re-create the file, the\n-\t     file might be opened in text mode, but then, you shouldn't\n-\t     delete the file in the first place.  */\n-\t  if (da_file == 0)\n-\t    da_file = fopen (ptr->filename, \"r+\");\n-\t  if (da_file == 0)\n-\t    {\n-\t      fprintf (stderr, \"arc profiling: Can't open output file %s.\\n\",\n-\t\t       ptr->filename);\n-\t      continue;\n-\t    }\n+\t  fprintf (stderr, \"arc profiling: Can't open output file %s.\\n\",\n+\t\t   ptr->filename);\n+\t  continue;\n+\t}\n \n-\t  /* After a fork, another process might try to read and/or write\n-\t     the same file simultanously.  So if we can, lock the file to\n-\t     avoid race conditions.  */\n+      /* After a fork, another process might try to read and/or write\n+         the same file simultanously.  So if we can, lock the file to\n+         avoid race conditions.  */\n #if defined (TARGET_HAS_F_SETLKW)\n-\t  {\n-\t    struct flock s_flock;\n+      {\n+\tstruct flock s_flock;\n \n-\t    s_flock.l_type = F_WRLCK;\n-\t    s_flock.l_whence = SEEK_SET;\n-\t    s_flock.l_start = 0;\n-\t    s_flock.l_len = 1;\n-\t    s_flock.l_pid = getpid ();\n+\ts_flock.l_type = F_WRLCK;\n+\ts_flock.l_whence = SEEK_SET;\n+\ts_flock.l_start = 0;\n+\ts_flock.l_len = 1;\n+\ts_flock.l_pid = getpid ();\n \n-\t    while (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n-\t\t   && errno == EINTR);\n-\t  }\n+\twhile (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n+\t       && errno == EINTR);\n+      }\n #endif\n \n-\t  /* If the file is not empty, and the number of counts in it is the\n-\t     same, then merge them in.  */\n-\t  firstchar = fgetc (da_file);\n-\t  if (firstchar == EOF)\n+      /* If the file is not empty, and the number of counts in it is the\n+         same, then merge them in.  */\n+      firstchar = fgetc (da_file);\n+      if (firstchar == EOF)\n+\t{\n+\t  if (ferror (da_file))\n \t    {\n-\t      if (ferror (da_file))\n-\t\t{\n-\t\t  fprintf (stderr, \"arc profiling: Can't read output file \");\n-\t\t  perror (ptr->filename);\n-\t\t}\n+\t      fprintf (stderr, \"arc profiling: Can't read output file \");\n+\t      perror (ptr->filename);\n \t    }\n-\t  else\n-\t    {\n-\t      long n_counts = 0;\n-\n-\t      if (ungetc (firstchar, da_file) == EOF)\n-\t\trewind (da_file);\n-\t      if (__read_long (&n_counts, da_file, 8) != 0)\n-\t\t{\n-\t\t  fprintf (stderr, \"arc profiling: Can't read output file %s.\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (n_counts == ptr->ncounts)\n-\t\t{\n-\t\t  int i;\n-\n-\t\t  for (i = 0; i < n_counts; i++)\n-\t\t    {\n-\t\t      gcov_type v = 0;\n-\n-\t\t      if (__read_gcov_type (&v, da_file, 8) != 0)\n-\t\t\t{\n-\t\t\t  fprintf (stderr, \"arc profiling: Can't read output file %s.\\n\",\n-\t\t\t\t   ptr->filename);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      ptr->counts[i] += v;\n-\t\t    }\n-\t\t}\n-\n-\t    }\n-\n-\t  rewind (da_file);\n-\n-\t  /* ??? Should first write a header to the file.  Preferably, a 4 byte\n-\t     magic number, 4 bytes containing the time the program was\n-\t     compiled, 4 bytes containing the last modification time of the\n-\t     source file, and 4 bytes indicating the compiler options used.\n-\n-\t     That way we can easily verify that the proper source/executable/\n-\t     data file combination is being used from gcov.  */\n+\t}\n+      else\n+\t{\n+\t  long n_counts = 0;\n \n-\t  if (__write_gcov_type (ptr->ncounts, da_file, 8) != 0)\n+\t  if (ungetc (firstchar, da_file) == EOF)\n+\t    rewind (da_file);\n+\t  if (__read_long (&n_counts, da_file, 8) != 0)\n \t    {\n-\n-\t      fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n+\t      fprintf (stderr, \"arc profiling: Can't read output file %s.\\n\",\n \t\t       ptr->filename);\n+\t      continue;\n \t    }\n-\t  else\n+\n+\t  if (n_counts == ptr->ncounts)\n \t    {\n-\t      int j;\n-\t      gcov_type *count_ptr = ptr->counts;\n-\t      int ret = 0;\n-\t      for (j = ptr->ncounts; j > 0; j--)\n+\t      int i;\n+\n+\t      for (i = 0; i < n_counts; i++)\n \t\t{\n-\t\t  if (__write_gcov_type (*count_ptr, da_file, 8) != 0)\n+\t\t  gcov_type v = 0;\n+\n+\t\t  if (__read_gcov_type (&v, da_file, 8) != 0)\n \t\t    {\n-\t\t      ret=1;\n+\t\t      fprintf (stderr,\n+\t\t\t       \"arc profiling: Can't read output file %s.\\n\",\n+\t\t\t       ptr->filename);\n \t\t      break;\n \t\t    }\n-\t\t  count_ptr++;\n+\t\t  ptr->counts[i] += v;\n \t\t}\n-\t      if (ret)\n-\t\tfprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n-\t\t\t ptr->filename);\n \t    }\n \n-\t  if (fclose (da_file) == EOF)\n-\t    fprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n-\t\t     ptr->filename);\n \t}\n \n-      return;\n-    }\n-\n-  /* Must be basic block profiling.  Emit a human readable output file.  */\n-\n-  file = fopen (\"bb.out\", \"a\");\n-\n-  if (!file)\n-    perror (\"bb.out\");\n-\n-  else\n-    {\n-      struct bb *ptr;\n+      rewind (da_file);\n \n-      /* This is somewhat type incorrect, but it avoids worrying about\n-\t exactly where time.h is included from.  It should be ok unless\n-\t a void * differs from other pointer formats, or if sizeof (long)\n-\t is < sizeof (time_t).  It would be nice if we could assume the\n-\t use of rationale standards here.  */\n+      /* ??? Should first write a header to the file.  Preferably, a 4 byte\n+         magic number, 4 bytes containing the time the program was\n+         compiled, 4 bytes containing the last modification time of the\n+         source file, and 4 bytes indicating the compiler options used.\n \n-      time ((void *) &time_value);\n-      fprintf (file, \"Basic block profiling finished on %s\\n\",\n-\t       ctime ((void *) &time_value));\n+         That way we can easily verify that the proper source/executable/\n+         data file combination is being used from gcov.  */\n \n-      /* We check the length field explicitly in order to allow compatibility\n-\t with older GCC's which did not provide it.  */\n+      if (__write_gcov_type (ptr->ncounts, da_file, 8) != 0)\n+\t{\n \n-      for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n+\t  fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n+\t\t   ptr->filename);\n+\t}\n+      else\n \t{\n-\t  int i;\n-\t  int func_p\t= (ptr->nwords >= (long) sizeof (struct bb)\n-\t\t\t   && ptr->nwords <= 1000\n-\t\t\t   && ptr->functions);\n-\t  int line_p\t= (func_p && ptr->line_nums);\n-\t  int file_p\t= (func_p && ptr->filenames);\n-\t  int addr_p\t= (ptr->addresses != 0);\n-\t  long ncounts\t= ptr->ncounts;\n-\t  gcov_type cnt_max  = 0;\n-\t  long line_max = 0;\n-\t  long addr_max = 0;\n-\t  int file_len\t= 0;\n-\t  int func_len\t= 0;\n-\t  int blk_len\t= num_digits (ncounts, 10);\n-\t  int cnt_len;\n-\t  int line_len;\n-\t  int addr_len;\n-\n-\t  fprintf (file, \"File %s, %ld basic blocks \\n\\n\",\n-\t\t   ptr->filename, ncounts);\n-\n-\t  /* Get max values for each field.  */\n-\t  for (i = 0; i < ncounts; i++)\n+\t  int j;\n+\t  gcov_type *count_ptr = ptr->counts;\n+\t  int ret = 0;\n+\t  for (j = ptr->ncounts; j > 0; j--)\n \t    {\n-\t      const char *p;\n-\t      int len;\n-\n-\t      if (cnt_max < ptr->counts[i])\n-\t\tcnt_max = ptr->counts[i];\n-\n-\t      if (addr_p && (unsigned long) addr_max < ptr->addresses[i])\n-\t\taddr_max = ptr->addresses[i];\n-\n-\t      if (line_p && line_max < ptr->line_nums[i])\n-\t\tline_max = ptr->line_nums[i];\n-\n-\t      if (func_p)\n+\t      if (__write_gcov_type (*count_ptr, da_file, 8) != 0)\n \t\t{\n-\t\t  p = (ptr->functions[i]) ? (ptr->functions[i]) : \"<none>\";\n-\t\t  len = strlen (p);\n-\t\t  if (func_len < len)\n-\t\t    func_len = len;\n+\t\t  ret = 1;\n+\t\t  break;\n \t\t}\n-\n-\t      if (file_p)\n-\t\t{\n-\t\t  p = (ptr->filenames[i]) ? (ptr->filenames[i]) : \"<none>\";\n-\t\t  len = strlen (p);\n-\t\t  if (file_len < len)\n-\t\t    file_len = len;\n-\t\t}\n-\t    }\n-\n-\t  addr_len = num_digits (addr_max, 16);\n-\t  cnt_len  = num_digits (cnt_max, 10);\n-\t  line_len = num_digits (line_max, 10);\n-\n-\t  /* Now print out the basic block information.  */\n-\t  for (i = 0; i < ncounts; i++)\n-\t    {\n-#if LONG_TYPE_SIZE == GCOV_TYPE_SIZE\n-\t      fprintf (file,\n-\t\t       \"    Block #%*d: executed %*ld time(s)\",\n-\t\t       blk_len, i+1,\n-\t\t       cnt_len, ptr->counts[i]);\n-#else\n-\t      fprintf (file,\n-\t\t       \"    Block #%*d: executed %*lld time(s)\",\n-\t\t       blk_len, i+1,\n-\t\t       cnt_len, ptr->counts[i]);\n-#endif\n-\n-\t      if (addr_p)\n-\t\tfprintf (file, \" address= 0x%.*lx\", addr_len,\n-\t\t\t ptr->addresses[i]);\n-\n-\t      if (func_p)\n-\t\tfprintf (file, \" function= %-*s\", func_len,\n-\t\t\t (ptr->functions[i]) ? ptr->functions[i] : \"<none>\");\n-\n-\t      if (line_p)\n-\t\tfprintf (file, \" line= %*ld\", line_len, ptr->line_nums[i]);\n-\n-\t      if (file_p)\n-\t\tfprintf (file, \" file= %s\",\n-\t\t\t (ptr->filenames[i]) ? ptr->filenames[i] : \"<none>\");\n-\n-\t      fprintf (file, \"\\n\");\n+\t      count_ptr++;\n \t    }\n-\n-\t  fprintf (file, \"\\n\");\n-\t  fflush (file);\n+\t  if (ret)\n+\t    fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n+\t\t     ptr->filename);\n \t}\n \n-      fprintf (file, \"\\n\\n\");\n-      fclose (file);\n+      if (fclose (da_file) == EOF)\n+\tfprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n+\t\t ptr->filename);\n     }\n+\n+  return;\n }\n \n void"}]}