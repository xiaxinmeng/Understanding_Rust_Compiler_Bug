{"sha": "71dea1dd60888030f3130f16933becdf597538ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkZWExZGQ2MDg4ODAzMGYzMTMwZjE2OTMzYmVjZGY1OTc1MzhhYg==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-10-05T12:31:05Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-10-05T12:31:05Z"}, "message": "Move all existing strchr and strrchr folding from builtins.c to gimple-fold.c.\n\n    gcc/\n        * builtins.c (fold_builtin_strchr): Remove function.\n        (fold_builtin_strrchr): Likewise.\n        (fold_builtin2): Remove strchr, index, strrchr, rindex cases.\n        * gimple-fold.c (target_char_cst_p): New function.\n        (gimple_fold_builtin_strchr) Add more foldings.\n        (gimple_fold_builtin): Add index, strrchr, rindex cases.\n\nFrom-SVN: r240782", "tree": {"sha": "2e5b327406e5695e411f9f03cf0000a0eb1aafa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e5b327406e5695e411f9f03cf0000a0eb1aafa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71dea1dd60888030f3130f16933becdf597538ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dea1dd60888030f3130f16933becdf597538ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71dea1dd60888030f3130f16933becdf597538ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dea1dd60888030f3130f16933becdf597538ab/comments", "author": null, "committer": null, "parents": [{"sha": "92805612f4e0cdd33e10282eaf2cc0369bca3293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92805612f4e0cdd33e10282eaf2cc0369bca3293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92805612f4e0cdd33e10282eaf2cc0369bca3293"}], "stats": {"total": 206, "additions": 70, "deletions": 136}, "files": [{"sha": "81e4235d2e45bdd2080edcca899ab54e46f0ade8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dea1dd60888030f3130f16933becdf597538ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dea1dd60888030f3130f16933becdf597538ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71dea1dd60888030f3130f16933becdf597538ab", "patch": "@@ -1,3 +1,12 @@\n+2016-10-05  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* builtins.c (fold_builtin_strchr): Remove function.\n+\t(fold_builtin_strrchr): Likewise.\n+\t(fold_builtin2): Remove strchr, index, strrchr, rindex cases.\n+\t* gimple-fold.c (target_char_cst_p): New function.\n+\t(gimple_fold_builtin_strchr) Add more foldings.\n+\t(gimple_fold_builtin): Add index, strrchr, rindex cases.\n+\n 2016-10-05  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/77863"}, {"sha": "facecd3cfef711fdb9190ab2e80c07778be3fffe", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dea1dd60888030f3130f16933becdf597538ab/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dea1dd60888030f3130f16933becdf597538ab/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=71dea1dd60888030f3130f16933becdf597538ab", "patch": "@@ -148,7 +148,6 @@ static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n static bool validate_arg (const_tree, enum tree_code code);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n-static tree fold_builtin_strchr (location_t, tree, tree, tree);\n static tree fold_builtin_memchr (location_t, tree, tree, tree, tree);\n static tree fold_builtin_memcmp (location_t, tree, tree, tree);\n static tree fold_builtin_strcmp (location_t, tree, tree);\n@@ -168,7 +167,6 @@ static tree fold_builtin_varargs (location_t, tree, tree*, int);\n \n static tree fold_builtin_strpbrk (location_t, tree, tree, tree);\n static tree fold_builtin_strstr (location_t, tree, tree, tree);\n-static tree fold_builtin_strrchr (location_t, tree, tree, tree);\n static tree fold_builtin_strspn (location_t, tree, tree);\n static tree fold_builtin_strcspn (location_t, tree, tree);\n \n@@ -8395,14 +8393,6 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n     case BUILT_IN_STRCSPN:\n       return fold_builtin_strcspn (loc, arg0, arg1);\n \n-    case BUILT_IN_STRCHR:\n-    case BUILT_IN_INDEX:\n-      return fold_builtin_strchr (loc, arg0, arg1, type);\n-\n-    case BUILT_IN_STRRCHR:\n-    case BUILT_IN_RINDEX:\n-      return fold_builtin_strrchr (loc, arg0, arg1, type);\n-\n     case BUILT_IN_STRCMP:\n       return fold_builtin_strcmp (loc, arg0, arg1);\n \n@@ -8895,124 +8885,6 @@ fold_builtin_strstr (location_t loc, tree s1, tree s2, tree type)\n     }\n }\n \n-/* Simplify a call to the strchr builtin.  S1 and S2 are the arguments to\n-   the call, and TYPE is its return type.\n-\n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-static tree\n-fold_builtin_strchr (location_t loc, tree s1, tree s2, tree type)\n-{\n-  if (!validate_arg (s1, POINTER_TYPE)\n-      || !validate_arg (s2, INTEGER_TYPE))\n-    return NULL_TREE;\n-  else\n-    {\n-      const char *p1;\n-\n-      if (TREE_CODE (s2) != INTEGER_CST)\n-\treturn NULL_TREE;\n-\n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  char c;\n-\t  const char *r;\n-\t  tree tem;\n-\n-\t  if (target_char_cast (s2, &c))\n-\t    return NULL_TREE;\n-\n-\t  r = strchr (p1, c);\n-\n-\t  if (r == NULL)\n-\t    return build_int_cst (TREE_TYPE (s1), 0);\n-\n-\t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold_build_pointer_plus_hwi_loc (loc, s1, r - p1);\n-\t  return fold_convert_loc (loc, type, tem);\n-\t}\n-      return NULL_TREE;\n-    }\n-}\n-\n-/* Simplify a call to the strrchr builtin.  S1 and S2 are the arguments to\n-   the call, and TYPE is its return type.\n-\n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-static tree\n-fold_builtin_strrchr (location_t loc, tree s1, tree s2, tree type)\n-{\n-  if (!validate_arg (s1, POINTER_TYPE)\n-      || !validate_arg (s2, INTEGER_TYPE))\n-    return NULL_TREE;\n-  else\n-    {\n-      tree fn;\n-      const char *p1;\n-\n-      if (TREE_CODE (s2) != INTEGER_CST)\n-\treturn NULL_TREE;\n-\n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  char c;\n-\t  const char *r;\n-\t  tree tem;\n-\n-\t  if (target_char_cast (s2, &c))\n-\t    return NULL_TREE;\n-\n-\t  r = strrchr (p1, c);\n-\n-\t  if (r == NULL)\n-\t    return build_int_cst (TREE_TYPE (s1), 0);\n-\n-\t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold_build_pointer_plus_hwi_loc (loc, s1, r - p1);\n-\t  return fold_convert_loc (loc, type, tem);\n-\t}\n-\n-      if (! integer_zerop (s2))\n-\treturn NULL_TREE;\n-\n-      fn = builtin_decl_implicit (BUILT_IN_STRCHR);\n-      if (!fn)\n-\treturn NULL_TREE;\n-\n-      /* Transform strrchr(s1, '\\0') to strchr(s1, '\\0').  */\n-      return build_call_expr_loc (loc, fn, 2, s1, s2);\n-    }\n-}\n-\n /* Simplify a call to the strpbrk builtin.  S1 and S2 are the arguments\n    to the call, and TYPE is its return type.\n "}, {"sha": "59c4cb80a362063c52e99eaf5775cb9bee197ab7", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dea1dd60888030f3130f16933becdf597538ab/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dea1dd60888030f3130f16933becdf597538ab/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=71dea1dd60888030f3130f16933becdf597538ab", "patch": "@@ -57,6 +57,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n \n \n+/* Return true if T is a constant and the value cast to a target char\n+   can be represented by a host char.\n+   Store the casted char constant in *P if so.  */\n+\n+static bool\n+target_char_cst_p (tree t, char *p)\n+{\n+  if (!tree_fits_uhwi_p (t) || CHAR_TYPE_SIZE != HOST_BITS_PER_CHAR)\n+    return false;\n+\n+  *p = (char)tree_to_uhwi (t);\n+  return true;\n+}\n+\n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n    We can get declarations that are not possible to reference for various\n@@ -1457,23 +1471,61 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n   return true;\n }\n \n-/* Simplify strchr (str, 0) into str + strlen (str).\n+/* Fold function call to builtin strchr or strrchr.\n+   If both arguments are constant, evaluate and fold the result,\n+   otherwise simplify str(r)chr (str, 0) into str + strlen (str).\n    In general strlen is significantly faster than strchr\n    due to being a simpler operation.  */\n static bool\n-gimple_fold_builtin_strchr (gimple_stmt_iterator *gsi)\n+gimple_fold_builtin_strchr (gimple_stmt_iterator *gsi, bool is_strrchr)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   tree str = gimple_call_arg (stmt, 0);\n   tree c = gimple_call_arg (stmt, 1);\n   location_t loc = gimple_location (stmt);\n+  const char *p;\n+  char ch;\n \n-  if (optimize_function_for_size_p (cfun))\n+  if (!gimple_call_lhs (stmt))\n     return false;\n \n-  if (!integer_zerop (c) || !gimple_call_lhs (stmt))\n+  if ((p = c_getstr (str)) && target_char_cst_p (c, &ch))\n+    {\n+      const char *p1 = is_strrchr ? strrchr (p, ch) : strchr (p, ch);\n+\n+      if (p1 == NULL)\n+\t{\n+\t  replace_call_with_value (gsi, integer_zero_node);\n+\t  return true;\n+\t}\n+\n+      tree len = build_int_cst (size_type_node, p1 - p);\n+      gimple_seq stmts = NULL;\n+      gimple *new_stmt = gimple_build_assign (gimple_call_lhs (stmt),\n+\t\t\t\t\t      POINTER_PLUS_EXPR, str, len);\n+      gimple_seq_add_stmt_without_update (&stmts, new_stmt);\n+      gsi_replace_with_seq_vops (gsi, stmts);\n+      return true;\n+    }\n+\n+  if (!integer_zerop (c))\n     return false;\n \n+  /* Transform strrchr (s, 0) to strchr (s, 0) when optimizing for size.  */\n+  if (optimize_function_for_size_p (cfun))\n+    {\n+      tree strchr_fn = builtin_decl_implicit (BUILT_IN_STRCHR);\n+\n+      if (is_strrchr && strchr_fn)\n+\t{\n+\t  gimple *repl = gimple_build_call (strchr_fn, 2, str, c);\n+\t  replace_call_with_call_and_fold (gsi, repl);\n+\t  return true;\n+\t}\n+\n+      return false;\n+    }\n+\n   tree len;\n   tree strlen_fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n \n@@ -2947,11 +2999,12 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \t\t\t\t\t gimple_call_arg (stmt, 1));\n     case BUILT_IN_STRNCAT:\n       return gimple_fold_builtin_strncat (gsi);\n+    case BUILT_IN_INDEX:\n     case BUILT_IN_STRCHR:\n-      if (gimple_fold_builtin_strchr (gsi))\n-\treturn true;\n-      /* Perform additional folding in builtin.c.  */\n-      break;\n+      return gimple_fold_builtin_strchr (gsi, false);\n+    case BUILT_IN_RINDEX:\n+    case BUILT_IN_STRRCHR:\n+      return gimple_fold_builtin_strchr (gsi, true);\n     case BUILT_IN_FPUTS:\n       return gimple_fold_builtin_fputs (gsi, gimple_call_arg (stmt, 0),\n \t\t\t\t\tgimple_call_arg (stmt, 1), false);"}]}