{"sha": "690ddf3e4ef9900f777f2476decc5f8e3aac401c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwZGRmM2U0ZWY5OTAwZjc3N2YyNDc2ZGVjYzVmOGUzYWFjNDAxYw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-08-10T01:56:14Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-08-10T01:56:14Z"}, "message": "Initial revision\n\nFrom-SVN: r5124", "tree": {"sha": "98531e6971505bc9252c6543916ee37bab3d71c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98531e6971505bc9252c6543916ee37bab3d71c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/690ddf3e4ef9900f777f2476decc5f8e3aac401c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690ddf3e4ef9900f777f2476decc5f8e3aac401c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/690ddf3e4ef9900f777f2476decc5f8e3aac401c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690ddf3e4ef9900f777f2476decc5f8e3aac401c/comments", "author": null, "committer": null, "parents": [{"sha": "633b477b0264ac08a5182e7f38fcfd401d7fdba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/633b477b0264ac08a5182e7f38fcfd401d7fdba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/633b477b0264ac08a5182e7f38fcfd401d7fdba1"}], "stats": {"total": 149, "additions": 149, "deletions": 0}, "files": [{"sha": "be02123a6e2f11cc1b482d9416629a2b6e8569fd", "filename": "gcc/scan-types.sh", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690ddf3e4ef9900f777f2476decc5f8e3aac401c/gcc%2Fscan-types.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690ddf3e4ef9900f777f2476decc5f8e3aac401c/gcc%2Fscan-types.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-types.sh?ref=690ddf3e4ef9900f777f2476decc5f8e3aac401c", "patch": "@@ -0,0 +1,149 @@\n+#! /bin/sh\n+# Deduce values of standard ANSI and POSIX types (e.g. size_t, pid_t).\n+# Emits macros definitions for these, and some other types.\n+# Intended to be used to massage the sys-protos.h file.\n+\n+CC=${CC-./xgcc}\n+CPP=${CPP-`echo ${CC} -E`}\n+SED=sed\n+\n+# Generate definitions for the standard types (such as mode_t)\n+# compatible with those in the standard C header files.\n+# It works by a dummy program through the C pre-processor, and then\n+# using sed to search for typedefs in the output.\n+\n+cat >dummy.c <<!EOF!\n+#include <sys/types.h>\n+#include <stddef.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <time.h>\n+#include <signal.h>\n+#ifdef size_t\n+typedef size_t Xsize_t;\n+#elif defined(__SIZE_TYPE__)\n+typedef __SIZE_TYPE__ Xsize_t;\n+#endif\n+#ifdef ptrdiff_t\n+typedef ptrdiff_t Xptrdiff_t;\n+#elif defined(__PTRDIFF_TYPE__)\n+typedef __PTRDIFF_TYPE__ Xptrdiff_t;\n+#endif\n+#ifdef wchar_t\n+typedef wchar_t Xwchar_t;\n+#elif defined(__WCHAR_TYPE__)\n+typedef __WCHAR_TYPE__ Xwchar_t;\n+#endif\n+#ifdef va_list\n+typedef va_list XXXva_list;\n+#endif\n+!EOF!\n+\n+if ${CPP} dummy.c >TMP ; then true\n+else\n+  echo \"gen-params: could not invoke ${CPP} on dummy.c\" 1>&2 ; exit 1\n+fi\n+tr '\t' ' ' <TMP >dummy.out\n+\n+for TYPE in dev_t clock_t fpos_t gid_t ino_t mode_t nlink_t off_t pid_t ptrdiff_t sigset_t size_t ssize_t time_t uid_t va_list wchar_t int32_t uint_32_t ; do\n+    IMPORTED=`eval 'echo $'\"$TYPE\"`\n+    if [ -n \"${IMPORTED}\" ] ; then\n+\teval \"$TYPE='$IMPORTED\"\n+    else\n+\t# Search dummy.out for a typedef for $TYPE, and write it out\n+\t# to TMP in #define syntax.\n+\trm -f TMP\n+\t${SED} -n -e \"s|.*typedef  *\\(.*\\) X*$TYPE *;.*|\\1|w TMP\" <dummy.out>/dev/null\n+\t# Now select the first definition.\n+        if [ -s TMP ]; then\n+\t    # VALUE is now the typedef'd definition of $TYPE.\n+            eval \"VALUE='`${SED} -e 's| *$||' -e '2,$d' <TMP`'\"\n+\t    # Unless VALUE contains a blank, look for a typedef for it\n+\t    # in turn (this could be a loop, but that would be over-kill).\n+\t    if echo $VALUE | grep \" \" >/dev/null ; then true\n+\t    else\n+\t\trm -f TMP\n+\t\t${SED} -n -e \"s|.*typedef[ \t][ \t]*\\(.*[^a-zA-Z0-9_]\\)${VALUE}[ \t]*;.*|\\1|w TMP\" <dummy.out>/dev/null\n+\t\tif [ -s TMP ]; then\n+\t\t    eval \"VALUE='`${SED} -e '2,$d' -e 's|[ \t]*$||' <TMP`'\"\n+\t\tfi\n+\t    fi\n+\t    eval \"$TYPE='$VALUE'\"\n+\tfi\n+    fi\n+done\n+\n+cat <<!EOF!\n+#define ${macro_prefix}clock_t ${clock_t-int /* default */}\n+#define ${macro_prefix}dev_t ${dev_t-int /* default */}\n+#define ${macro_prefix}fpos_t ${fpos_t-long /* default */}\n+#define ${macro_prefix}gid_t ${gid_t-int /* default */}\n+#define ${macro_prefix}ino_t ${ino_t-int /* default */}\n+#define ${macro_prefix}mode_t ${mode_t-int /* default */}\n+#define ${macro_prefix}nlink_t ${nlink_t-int /* default */}\n+#define ${macro_prefix}off_t ${off_t-long /* default */}\n+#define ${macro_prefix}pid_t ${pid_t-int /* default */}\n+#define ${macro_prefix}ptrdiff_t ${ptrdiff_t-long int /* default */}\n+#define ${macro_prefix}sigset_t ${sigset_t-int /* default */}\n+#define ${macro_prefix}size_t ${size_t-unsigned long /* default */}\n+#define ${macro_prefix}time_t ${time_t-int /* default */}\n+#define ${macro_prefix}uid_t ${uid_t-int /* default */}\n+#define ${macro_prefix}wchar_t ${wchar_t-int /* default */}\n+#define ${macro_prefix}int32_t ${int32_t-int /* default */}\n+#define ${macro_prefix}uint32_t ${uint32_t-unsigned int /* default */}\n+!EOF!\n+\n+# (wait_arg_t*) should be (int*), according to Posix, but\n+# BSD traditionally used (union wait*).  Use (void*) to allow either usage.\n+echo \"#define ${macro_prefix}wait_arg_t void\"\n+\n+# ssize_t is the signed version of size_t\n+if [ -n \"${ssize_t}\" ] ; then\n+    echo \"#define ${macro_prefix}ssize_t ${ssize_t}\"\n+elif [ -z \"${size_t}\" ] ; then\n+    echo \"#define ${macro_prefix}ssize_t long\"\n+else\n+    # Remove \"unsigned\" from ${size_t} to get ${ssize_t}.\n+    tmp=\"`echo ${size_t} | ${SED} -e 's|unsigned||g' -e 's|  | |g'`\"\n+    if [ -z \"$tmp\" ] ; then\n+\ttmp=int\n+    else\n+\t# check $tmp doesn't conflict with <unistd.h>\n+\techo \"#include <unistd.h>\n+\textern $tmp read();\" >dummy.c\n+\t${CC} -c dummy.c >/dev/null 2>&1 || tmp=int\n+    fi\n+    echo \"#define ${macro_prefix}ssize_t $tmp /* default */\"\n+fi\n+\n+# va_list can cause problems (e.g. some systems have va_list as a struct).\n+# Check to see if ${va_list-char*} really is compatible with stdarg.h.\n+cat >dummy.c <<!EOF!\n+#define X_va_list ${va_list-char* /* default */}\n+extern long foo(X_va_list ap); /* Check that X_va_list compiles on its own */\n+#include <stdarg.h>\n+long foo(X_va_list ap) { return va_arg(ap, long); }\n+long bar(int i, ...)\n+{ va_list ap; long j; va_start(ap, i); j = foo(ap); va_end(ap); return j; }\n+!EOF!\n+if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n+  # Ok: We have something that works.\n+  echo \"#define ${macro_prefix}va_list ${va_list-char* /* default */}\"\n+else\n+  # No, it breaks.  Indicate that <stdarg.h> must be included.\n+  echo \"#define ${macro_prefix}NEED_STDARG_H\n+#define ${macro_prefix}va_list va_list\"\n+fi\n+\n+# stuff needed for curses.h\n+\n+# This isn't correct for SVR4 (for example).  However, we only\n+# use this when adding a missing prototype, so it shouldn't matter.\n+echo \"#define chtype int\"\n+# sys-protos.h uses non-standard names (due to the CHTYPE argument problem).\n+echo \"#define box32 box\"\n+echo \"#define initscr32 initscr\"\n+echo \"#define w32addch waddch\"\n+echo \"#define w32insch winsch\"\n+\n+rm -f dummy.c dummy.o TMP dummy.out"}]}