{"sha": "66b1156afefc078e6fcf7d9e041b15aea1f3897c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZiMTE1NmFmZWZjMDc4ZTZmY2Y3ZDllMDQxYjE1YWVhMWYzODk3Yw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-05-12T09:08:47Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-05-12T09:08:47Z"}, "message": "generic.texi: Rename TYPE_PTRMEM_P to TYPE_PTRDATAMEM_P.\n\n2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* doc/generic.texi: Rename TYPE_PTRMEM_P to TYPE_PTRDATAMEM_P.\n\n/cp\n2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* cp-tree.h (TYPE_PTRMEM_P): Rename to TYPE_PTRDATAMEM_P.\n\t(TYPE_PTR_TO_MEMBER_P): Rename to TYPE_PTRMEM_P.\n\t(TYPE_PTR_OR_PTRMEM_P): Add.\n\t* typeck.c (composite_pointer_type_r, composite_pointer_type,\n\tcommon_pointer_type, cp_build_indirect_ref, cp_build_binary_op,\n\tcp_truthvalue_conversion, convert_ptrmem, build_static_cast_1,\n\tbuild_reinterpret_cast_1, build_const_cast_1, comp_ptr_ttypes_real,\n\tcasts_away_constness_r, casts_away_constness): Adjust.\n\t* init.c (build_zero_init_1): Adjust.\n\t* class.c (check_field_decls): Likewise.\n\t* decl.c (check_default_argument): Likewise.\n\t* rtti.c (target_incomplete_p): Likewise.\n\t* tree.c (zero_init_p): Likewise.\n\t* cxx-pretty-print.c (pp_cxx_ptr_operator,\n\tpp_cxx_abstract_declarator): Likewise.\n\t* typeck2.c (build_m_component_ref): Likewise.\n\t* pt.c (convert_nontype_argument, invalid_nontype_parm_type_p,\n\tdependent_type_p_r): Likewise.\n\t* call.c (null_member_pointer_value_p, standard_conversion,\n\tadd_builtin_candidate, build_conditional_expr_1, compare_ics):\n\tLikewise.\n\t* cp-objcp-common.c (cp_var_mod_type_p): Likewise.\n\t* cvt.c (cp_convert_to_pointer, ocp_convert,\n\tperform_qualification_conversions): Likewise.\n\t* mangle.c (write_type): Likewise.\n\t* name-lookup.c (arg_assoc_type): Likewise.\n\nFrom-SVN: r187425", "tree": {"sha": "7486149a6f3808912b77376a39b4f2c61c6cf9c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7486149a6f3808912b77376a39b4f2c61c6cf9c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66b1156afefc078e6fcf7d9e041b15aea1f3897c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66b1156afefc078e6fcf7d9e041b15aea1f3897c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66b1156afefc078e6fcf7d9e041b15aea1f3897c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66b1156afefc078e6fcf7d9e041b15aea1f3897c/comments", "author": null, "committer": null, "parents": [{"sha": "498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c"}], "stats": {"total": 192, "additions": 111, "deletions": 81}, "files": [{"sha": "57c9ec10a0040083cb3c4fcf331d82b8679a2e95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -1,3 +1,7 @@\n+2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* doc/generic.texi: Rename TYPE_PTRMEM_P to TYPE_PTRDATAMEM_P.\n+\n 2012-05-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_emit_conditional_branch): Handle"}, {"sha": "3555be4c22f3d8c954b4c866515acdb553184d12", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -1,3 +1,32 @@\n+2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* cp-tree.h (TYPE_PTRMEM_P): Rename to TYPE_PTRDATAMEM_P.\n+\t(TYPE_PTR_TO_MEMBER_P): Rename to TYPE_PTRMEM_P.\n+\t(TYPE_PTR_OR_PTRMEM_P): Add.\n+\t* typeck.c (composite_pointer_type_r, composite_pointer_type,\n+\tcommon_pointer_type, cp_build_indirect_ref, cp_build_binary_op,\n+\tcp_truthvalue_conversion, convert_ptrmem, build_static_cast_1,\n+\tbuild_reinterpret_cast_1, build_const_cast_1, comp_ptr_ttypes_real,\n+\tcasts_away_constness_r, casts_away_constness): Adjust.\n+\t* init.c (build_zero_init_1): Adjust.\n+\t* class.c (check_field_decls): Likewise.\n+\t* decl.c (check_default_argument): Likewise.\n+\t* rtti.c (target_incomplete_p): Likewise.\n+\t* tree.c (zero_init_p): Likewise.\n+\t* cxx-pretty-print.c (pp_cxx_ptr_operator,\n+\tpp_cxx_abstract_declarator): Likewise.\n+\t* typeck2.c (build_m_component_ref): Likewise.\n+\t* pt.c (convert_nontype_argument, invalid_nontype_parm_type_p,\n+\tdependent_type_p_r): Likewise.\n+\t* call.c (null_member_pointer_value_p, standard_conversion,\n+\tadd_builtin_candidate, build_conditional_expr_1, compare_ics):\n+\tLikewise.\n+\t* cp-objcp-common.c (cp_var_mod_type_p): Likewise.\n+\t* cvt.c (cp_convert_to_pointer, ocp_convert,\n+\tperform_qualification_conversions): Likewise.\n+\t* mangle.c (write_type): Likewise.\n+\t* name-lookup.c (arg_assoc_type): Likewise.\n+\n 2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* parser.c (struct cp_parser_expression_stack_entry): Add location_t"}, {"sha": "daaae2b6eadd5f81fa04fd44468c6c498a28b8ac", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -578,7 +578,7 @@ null_member_pointer_value_p (tree t)\n   else if (TYPE_PTRMEMFUNC_P (type))\n     return (TREE_CODE (t) == CONSTRUCTOR\n \t    && integer_zerop (CONSTRUCTOR_ELT (t, 0)->value));\n-  else if (TYPE_PTRMEM_P (type))\n+  else if (TYPE_PTRDATAMEM_P (type))\n     return integer_all_onesp (t);\n   else\n     return false;\n@@ -1162,7 +1162,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n      A null pointer constant can be converted to a pointer type; ... A\n      null pointer constant of integral type can be converted to an\n      rvalue of type std::nullptr_t. */\n-  if ((tcode == POINTER_TYPE || TYPE_PTR_TO_MEMBER_P (to)\n+  if ((tcode == POINTER_TYPE || TYPE_PTRMEM_P (to)\n        || NULLPTR_TYPE_P (to))\n       && expr && null_ptr_cst_p (expr))\n     conv = build_conv (ck_std, to, conv);\n@@ -1182,7 +1182,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       conv->bad_p = true;\n     }\n   else if ((tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n-\t   || (TYPE_PTRMEM_P (to) && TYPE_PTRMEM_P (from)))\n+\t   || (TYPE_PTRDATAMEM_P (to) && TYPE_PTRDATAMEM_P (from)))\n     {\n       tree to_pointee;\n       tree from_pointee;\n@@ -1192,7 +1192,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t\t\t\t\t\t\tTREE_TYPE (to)))\n \t;\n       else if (VOID_TYPE_P (TREE_TYPE (to))\n-\t       && !TYPE_PTRMEM_P (from)\n+\t       && !TYPE_PTRDATAMEM_P (from)\n \t       && TREE_CODE (TREE_TYPE (from)) != FUNCTION_TYPE)\n \t{\n \t  tree nfrom = TREE_TYPE (from);\n@@ -1201,7 +1201,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t\t\t              cp_type_quals (nfrom)));\n \t  conv = build_conv (ck_ptr, from, conv);\n \t}\n-      else if (TYPE_PTRMEM_P (from))\n+      else if (TYPE_PTRDATAMEM_P (from))\n \t{\n \t  tree fbase = TYPE_PTRMEM_CLASS_TYPE (from);\n \t  tree tbase = TYPE_PTRMEM_CLASS_TYPE (to);\n@@ -1307,12 +1307,12 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       if (ARITHMETIC_TYPE_P (from)\n \t  || UNSCOPED_ENUM_P (from)\n \t  || fcode == POINTER_TYPE\n-\t  || TYPE_PTR_TO_MEMBER_P (from)\n+\t  || TYPE_PTRMEM_P (from)\n \t  || NULLPTR_TYPE_P (from))\n \t{\n \t  conv = build_conv (ck_std, to, conv);\n \t  if (fcode == POINTER_TYPE\n-\t      || TYPE_PTRMEM_P (from)\n+\t      || TYPE_PTRDATAMEM_P (from)\n \t      || (TYPE_PTRMEMFUNC_P (from)\n \t\t  && conv->rank < cr_pbool)\n \t      || NULLPTR_TYPE_P (from))\n@@ -2334,7 +2334,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \n     case MEMBER_REF:\n       if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && TYPE_PTR_TO_MEMBER_P (type2))\n+\t  && TYPE_PTRMEM_P (type2))\n \t{\n \t  tree c1 = TREE_TYPE (type1);\n \t  tree c2 = TYPE_PTRMEM_CLASS_TYPE (type2);\n@@ -2406,14 +2406,14 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n     case EQ_EXPR:\n     case NE_EXPR:\n       if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n-\t  || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2)))\n+\t  || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2)))\n \tbreak;\n-      if (TYPE_PTR_TO_MEMBER_P (type1) && null_ptr_cst_p (args[1]))\n+      if (TYPE_PTRMEM_P (type1) && null_ptr_cst_p (args[1]))\n \t{\n \t  type2 = type1;\n \t  break;\n \t}\n-      if (TYPE_PTR_TO_MEMBER_P (type2) && null_ptr_cst_p (args[0]))\n+      if (TYPE_PTRMEM_P (type2) && null_ptr_cst_p (args[0]))\n \t{\n \t  type1 = type2;\n \t  break;\n@@ -2552,7 +2552,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t    break;\n \t  if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n \t      || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n-\t      || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n+\t      || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2))\n \t      || ((TYPE_PTRMEMFUNC_P (type1)\n \t\t   || TREE_CODE (type1) == POINTER_TYPE)\n \t\t  && null_ptr_cst_p (args[1])))\n@@ -2589,8 +2589,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \tbreak;\n \n       /* Otherwise, the types should be pointers.  */\n-      if (!(TYPE_PTR_P (type1) || TYPE_PTR_TO_MEMBER_P (type1))\n-\t  || !(TYPE_PTR_P (type2) || TYPE_PTR_TO_MEMBER_P (type2)))\n+      if (!TYPE_PTR_OR_PTRMEM_P (type1) || !TYPE_PTR_OR_PTRMEM_P (type2))\n \treturn;\n \n       /* We don't check that the two types are the same; the logic\n@@ -2615,12 +2614,12 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n       && TREE_CODE (type1) == TREE_CODE (type2)\n       && (TREE_CODE (type1) == REFERENCE_TYPE\n \t  || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n-\t  || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n+\t  || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2))\n \t  || TYPE_PTRMEMFUNC_P (type1)\n \t  || MAYBE_CLASS_TYPE_P (type1)\n \t  || TREE_CODE (type1) == ENUMERAL_TYPE))\n     {\n-      if (TYPE_PTR_P (type1) || TYPE_PTR_TO_MEMBER_P (type1))\n+      if (TYPE_PTR_OR_PTRMEM_P (type1))\n \t{\n \t  tree cptype = composite_pointer_type (type1, type2,\n \t\t\t\t\t\terror_mark_node,\n@@ -4733,11 +4732,11 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n        cv-qualification of either the second or the third operand.\n        The result is of the common type.  */\n   else if ((null_ptr_cst_p (arg2)\n-\t    && (TYPE_PTR_P (arg3_type) || TYPE_PTR_TO_MEMBER_P (arg3_type)))\n+\t    && TYPE_PTR_OR_PTRMEM_P (arg3_type))\n \t   || (null_ptr_cst_p (arg3)\n-\t       && (TYPE_PTR_P (arg2_type) || TYPE_PTR_TO_MEMBER_P (arg2_type)))\n+\t       && TYPE_PTR_OR_PTRMEM_P (arg2_type))\n \t   || (TYPE_PTR_P (arg2_type) && TYPE_PTR_P (arg3_type))\n-\t   || (TYPE_PTRMEM_P (arg2_type) && TYPE_PTRMEM_P (arg3_type))\n+\t   || (TYPE_PTRDATAMEM_P (arg2_type) && TYPE_PTRDATAMEM_P (arg3_type))\n \t   || (TYPE_PTRMEMFUNC_P (arg2_type) && TYPE_PTRMEMFUNC_P (arg3_type)))\n     {\n       result_type = composite_pointer_type (arg2_type, arg3_type, arg2,\n@@ -7857,8 +7856,8 @@ compare_ics (conversion *ics1, conversion *ics2)\n      for pointers A*, except opposite: if B is derived from A then\n      A::* converts to B::*, not vice versa.  For that reason, we\n      switch the from_ and to_ variables here.  */\n-  else if ((TYPE_PTRMEM_P (from_type1) && TYPE_PTRMEM_P (from_type2)\n-\t    && TYPE_PTRMEM_P (to_type1) && TYPE_PTRMEM_P (to_type2))\n+  else if ((TYPE_PTRDATAMEM_P (from_type1) && TYPE_PTRDATAMEM_P (from_type2)\n+\t    && TYPE_PTRDATAMEM_P (to_type1) && TYPE_PTRDATAMEM_P (to_type2))\n \t   || (TYPE_PTRMEMFUNC_P (from_type1)\n \t       && TYPE_PTRMEMFUNC_P (from_type2)\n \t       && TYPE_PTRMEMFUNC_P (to_type1)"}, {"sha": "5aef0fe71f4af5ef116c5ecf095ef5a58afa2cf0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -3219,8 +3219,7 @@ check_field_decls (tree t, tree *access_decls,\n \t to members which might hold dynamic memory. So do not warn\n \t for pointers to functions or pointers to members.  */\n       if (TYPE_PTR_P (type)\n-\t  && !TYPE_PTRFN_P (type)\n-\t  && !TYPE_PTR_TO_MEMBER_P (type))\n+\t  && !TYPE_PTRFN_P (type))\n \thas_pointers = true;\n \n       if (CLASS_TYPE_P (type))"}, {"sha": "9b7d361939cba44856155114c4ea1edbd3bfcd01", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -1,5 +1,5 @@\n /* Some code common to C++ and ObjC++ front ends.\n-   Copyright (C) 2004, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2004, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Ziemowit Laski  <zlaski@apple.com>\n \n@@ -118,7 +118,7 @@ cp_var_mod_type_p (tree type, tree fn)\n {\n   /* If TYPE is a pointer-to-member, it is variably modified if either\n      the class or the member are variably modified.  */\n-  if (TYPE_PTR_TO_MEMBER_P (type))\n+  if (TYPE_PTRMEM_P (type))\n     return (variably_modified_type_p (TYPE_PTRMEM_CLASS_TYPE (type), fn)\n \t    || variably_modified_type_p (TYPE_PTRMEM_POINTED_TO_TYPE (type),\n \t\t\t\t\t fn));"}, {"sha": "e5ec1d4841f6dbe7b75c1f504efd8370aeac5df1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -3191,7 +3191,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    \n    Keep these checks in ascending code order.  */\n #define SCALAR_TYPE_P(TYPE)\t\t\t\\\n-  (TYPE_PTRMEM_P (TYPE)\t\t\t\t\\\n+  (TYPE_PTRDATAMEM_P (TYPE)\t\t\t\\\n    || TREE_CODE (TYPE) == ENUMERAL_TYPE\t\t\\\n    || ARITHMETIC_TYPE_P (TYPE)\t\t\t\\\n    || TYPE_PTR_P (TYPE)\t\t\t\t\\\n@@ -3376,7 +3376,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (TYPE_HAS_COPY_ASSIGN (NODE) && ! TYPE_HAS_COMPLEX_COPY_ASSIGN (NODE))\n \n /* Returns true if NODE is a pointer-to-data-member.  */\n-#define TYPE_PTRMEM_P(NODE)\t\t\t\\\n+#define TYPE_PTRDATAMEM_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == OFFSET_TYPE)\n /* Returns true if NODE is a pointer.  */\n #define TYPE_PTR_P(NODE)\t\t\t\\\n@@ -3434,8 +3434,12 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (LANG_TYPE_CLASS_CHECK (NODE)->ptrmemfunc_flag)\n \n /* Returns true if NODE is a pointer-to-member.  */\n-#define TYPE_PTR_TO_MEMBER_P(NODE) \\\n-  (TYPE_PTRMEM_P (NODE) || TYPE_PTRMEMFUNC_P (NODE))\n+#define TYPE_PTRMEM_P(NODE) \\\n+  (TYPE_PTRDATAMEM_P (NODE) || TYPE_PTRMEMFUNC_P (NODE))\n+\n+/* Returns true if NODE is a pointer or a pointer-to-member.  */\n+#define TYPE_PTR_OR_PTRMEM_P(NODE) \\\n+  (TYPE_PTR_P (NODE) || TYPE_PTRMEM_P (NODE))\n \n /* Indicates when overload resolution may resolve to a pointer to\n    member function. [expr.unary.op]/3 */\n@@ -3473,13 +3477,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    TYPE_PTRMEM_POINTED_TO_TYPE; there, the first parameter will have\n    type `const X*'.  */\n #define TYPE_PTRMEM_CLASS_TYPE(NODE)\t\t\t\\\n-  (TYPE_PTRMEM_P (NODE)\t\t\t\t\t\\\n+  (TYPE_PTRDATAMEM_P (NODE)\t\t\t\t\t\\\n    ? TYPE_OFFSET_BASETYPE (NODE)\t\t\\\n    : TYPE_PTRMEMFUNC_OBJECT_TYPE (NODE))\n \n /* For a pointer-to-member type of the form `T X::*', this is `T'.  */\n #define TYPE_PTRMEM_POINTED_TO_TYPE(NODE)\t\t\\\n-   (TYPE_PTRMEM_P (NODE)\t\t\t\t\\\n+   (TYPE_PTRDATAMEM_P (NODE)\t\t\t\t\\\n     ? TREE_TYPE (NODE)\t\t\t\t\t\\\n     : TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (NODE)))\n "}, {"sha": "ebd750529c6feac55427a1a1f938f685a68e6635", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -175,7 +175,7 @@ cp_convert_to_pointer (tree type, tree expr)\n \n       return build_nop (type, expr);\n     }\n-  else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+  else if ((TYPE_PTRDATAMEM_P (type) && TYPE_PTRDATAMEM_P (intype))\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     return convert_ptrmem (type, expr, /*allow_inverse_p=*/false,\n \t\t\t   /*c_cast_p=*/false, tf_warning_or_error);\n@@ -210,7 +210,7 @@ cp_convert_to_pointer (tree type, tree expr)\n \treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0,\n \t\t\t\t /*c_cast_p=*/false, tf_warning_or_error);\n \n-      if (TYPE_PTRMEM_P (type))\n+      if (TYPE_PTRDATAMEM_P (type))\n \t{\n \t  /* A NULL pointer-to-member is represented by -1, not by\n \t     zero.  */\n@@ -221,7 +221,7 @@ cp_convert_to_pointer (tree type, tree expr)\n \n       return expr;\n     }\n-  else if (TYPE_PTR_TO_MEMBER_P (type) && INTEGRAL_CODE_P (form))\n+  else if (TYPE_PTRMEM_P (type) && INTEGRAL_CODE_P (form))\n     {\n       error_at (loc, \"invalid conversion from %qT to %qT\", intype, type);\n       return error_mark_node;\n@@ -767,7 +767,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n     }\n   if (NULLPTR_TYPE_P (type) && e && null_ptr_cst_p (e))\n     return nullptr_node;\n-  if (POINTER_TYPE_P (type) || TYPE_PTR_TO_MEMBER_P (type))\n+  if (POINTER_TYPE_P (type) || TYPE_PTRMEM_P (type))\n     return fold_if_not_in_template (cp_convert_to_pointer (type, e));\n   if (code == VECTOR_TYPE)\n     {\n@@ -1722,8 +1722,7 @@ perform_qualification_conversions (tree type, tree expr)\n   else if (TYPE_PTR_P (type) && TYPE_PTR_P (expr_type)\n \t   && comp_ptr_ttypes (TREE_TYPE (type), TREE_TYPE (expr_type)))\n     return build_nop (type, expr);\n-  else if (TYPE_PTR_TO_MEMBER_P (type)\n-\t   && TYPE_PTR_TO_MEMBER_P (expr_type)\n+  else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (expr_type)\n \t   && same_type_p (TYPE_PTRMEM_CLASS_TYPE (type),\n \t\t\t   TYPE_PTRMEM_CLASS_TYPE (expr_type))\n \t   && comp_ptr_ttypes (TYPE_PTRMEM_POINTED_TO_TYPE (type),"}, {"sha": "eef3489e7620cc6d358c133627cfe04af615336f", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -1345,8 +1345,7 @@ pp_cxx_ptr_operator (cxx_pretty_printer *pp, tree t)\n     {\n     case REFERENCE_TYPE:\n     case POINTER_TYPE:\n-      if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n-\t  || TYPE_PTR_TO_MEMBER_P (TREE_TYPE (t)))\n+      if (TYPE_PTR_OR_PTRMEM_P (TREE_TYPE (t)))\n \tpp_cxx_ptr_operator (pp, TREE_TYPE (t));\n       pp_c_attributes_display (pp_c_base (pp),\n \t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (t)));\n@@ -1368,7 +1367,7 @@ pp_cxx_ptr_operator (cxx_pretty_printer *pp, tree t)\n \t  break;\n \t}\n     case OFFSET_TYPE:\n-      if (TYPE_PTR_TO_MEMBER_P (t))\n+      if (TYPE_PTRMEM_P (t))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \t    pp_cxx_left_paren (pp);\n@@ -1641,7 +1640,7 @@ pp_cxx_function_definition (cxx_pretty_printer *pp, tree t)\n static void\n pp_cxx_abstract_declarator (cxx_pretty_printer *pp, tree t)\n {\n-  if (TYPE_PTRMEM_P (t) || TYPE_PTRMEMFUNC_P (t))\n+  if (TYPE_PTRMEM_P (t))\n     pp_cxx_right_paren (pp);\n   else if (POINTER_TYPE_P (t))\n     {"}, {"sha": "8d7d745176892207b62b178f39c93a84269d1389", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -10619,7 +10619,7 @@ check_default_argument (tree decl, tree arg)\n \n   if (warn_zero_as_null_pointer_constant\n       && c_inhibit_evaluation_warnings == 0\n-      && (TYPE_PTR_P (decl_type) || TYPE_PTR_TO_MEMBER_P (decl_type))\n+      && TYPE_PTR_OR_PTRMEM_P (decl_type)\n       && null_ptr_cst_p (arg)\n       && !NULLPTR_TYPE_P (TREE_TYPE (arg)))\n     {"}, {"sha": "ca6f14af3706ee74246d96e82ed63cc2760f1f3a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -178,7 +178,7 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n        items with static storage duration that are not otherwise\n        initialized are initialized to zero.  */\n     ;\n-  else if (TYPE_PTR_P (type) || TYPE_PTR_TO_MEMBER_P (type))\n+  else if (TYPE_PTR_OR_PTRMEM_P (type))\n     init = convert (type, nullptr_node);\n   else if (SCALAR_TYPE_P (type))\n     init = convert (type, integer_zero_node);"}, {"sha": "c8018483b81c0f2c80aabcd344766403905fe0ec", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -1845,7 +1845,7 @@ write_type (tree type)\n       if (TREE_CODE (type) == RECORD_TYPE && TYPE_TRANSPARENT_AGGR (type))\n \ttype = TREE_TYPE (first_field (type));\n \n-      if (TYPE_PTRMEM_P (type))\n+      if (TYPE_PTRDATAMEM_P (type))\n \twrite_pointer_to_member_type (type);\n       else\n         {"}, {"sha": "6930502012bad02aa83dc54bc9d545e4cc8cc420", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -5309,7 +5309,7 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n   if (!type)\n     return false;\n \n-  if (TYPE_PTRMEM_P (type))\n+  if (TYPE_PTRDATAMEM_P (type))\n     {\n       /* Pointer to member: associate class type and value type.  */\n       if (arg_assoc_type (k, TYPE_PTRMEM_CLASS_TYPE (type)))"}, {"sha": "051abb8a05c121e0abed546e6ddf44271fa75769", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -5720,8 +5720,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n   /* 14.3.2/5: The null pointer{,-to-member} conversion is applied\n      to a non-type argument of \"nullptr\".  */\n-  if (expr == nullptr_node\n-      && (TYPE_PTR_P (type) || TYPE_PTR_TO_MEMBER_P (type)))\n+  if (expr == nullptr_node && TYPE_PTR_OR_PTRMEM_P (type))\n     expr = convert (type, expr);\n \n   /* In C++11, integral or enumeration non-type template arguments can be\n@@ -5737,8 +5736,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t   CONSTRUCTOR.  */;\n       else if (INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n \texpr = maybe_constant_value (expr);\n-      else if (TYPE_PTR_P (type)\n-\t       || TYPE_PTR_TO_MEMBER_P (type))\n+      else if (TYPE_PTR_OR_PTRMEM_P (type))\n \t{\n \t  tree folded = maybe_constant_value (expr);\n \t  if (TYPE_PTR_P (type) ? integer_zerop (folded)\n@@ -6073,7 +6071,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n      For a non-type template-parameter of type pointer to data member,\n      qualification conversions (_conv.qual_) are applied.  */\n-  else if (TYPE_PTRMEM_P (type))\n+  else if (TYPE_PTRDATAMEM_P (type))\n     {\n       /* [temp.arg.nontype] bullet 1 says the pointer to member\n          expression must be a pointer-to-member constant.  */\n@@ -19169,7 +19167,7 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n     return 0;\n   else if (POINTER_TYPE_P (type))\n     return 0;\n-  else if (TYPE_PTR_TO_MEMBER_P (type))\n+  else if (TYPE_PTRMEM_P (type))\n     return 0;\n   else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n     return 0;\n@@ -19218,7 +19216,7 @@ dependent_type_p_r (tree type)\n \tdependent.  */\n   type = TYPE_MAIN_VARIANT (type);\n   /* -- a compound type constructed from any dependent type.  */\n-  if (TYPE_PTR_TO_MEMBER_P (type))\n+  if (TYPE_PTRMEM_P (type))\n     return (dependent_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n \t    || dependent_type_p (TYPE_PTRMEM_POINTED_TO_TYPE\n \t\t\t\t\t   (type)));"}, {"sha": "bdeea713da8b694ea570924e3eb864428cd9da63", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -816,7 +816,7 @@ static bool\n target_incomplete_p (tree type)\n {\n   while (true)\n-    if (TYPE_PTRMEM_P (type))\n+    if (TYPE_PTRDATAMEM_P (type))\n       {\n \tif (!COMPLETE_TYPE_P (TYPE_PTRMEM_CLASS_TYPE (type)))\n \t  return true;"}, {"sha": "ad8f82db1d509542a4d8ad4fa22d4b1a6b8cf6d1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -2773,7 +2773,7 @@ zero_init_p (const_tree t)\n     return 1;\n \n   /* NULL pointers to data members are initialized with -1.  */\n-  if (TYPE_PTRMEM_P (t))\n+  if (TYPE_PTRDATAMEM_P (t))\n     return 0;\n \n   /* Classes that contain types that can't be zero-initialized, cannot"}, {"sha": "c50373884ec120bb681410635a8b9dba0a6ffd94", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -509,8 +509,7 @@ composite_pointer_type_r (tree t1, tree t2,\n     result_type = pointee1;\n   else if ((TREE_CODE (pointee1) == POINTER_TYPE\n \t    && TREE_CODE (pointee2) == POINTER_TYPE)\n-\t   || (TYPE_PTR_TO_MEMBER_P (pointee1)\n-\t       && TYPE_PTR_TO_MEMBER_P (pointee2)))\n+\t   || (TYPE_PTRMEM_P (pointee1) && TYPE_PTRMEM_P (pointee2)))\n     {\n       result_type = composite_pointer_type_r (pointee1, pointee2, operation,\n \t\t\t\t\t      complain);\n@@ -530,7 +529,7 @@ composite_pointer_type_r (tree t1, tree t2,\n \t\t\t\t\t  | cp_type_quals (pointee2)));\n   /* If the original types were pointers to members, so is the\n      result.  */\n-  if (TYPE_PTR_TO_MEMBER_P (t1))\n+  if (TYPE_PTRMEM_P (t1))\n     {\n       if (!same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n \t\t\tTYPE_PTRMEM_CLASS_TYPE (t2)))\n@@ -666,7 +665,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n     }\n   /* [expr.eq] permits the application of a pointer-to-member\n      conversion to change the class type of one of the types.  */\n-  else if (TYPE_PTR_TO_MEMBER_P (t1)\n+  else if (TYPE_PTRMEM_P (t1)\n            && !same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n \t\t\t    TYPE_PTRMEM_CLASS_TYPE (t2)))\n     {\n@@ -931,7 +930,7 @@ tree\n common_pointer_type (tree t1, tree t2)\n {\n   gcc_assert ((TYPE_PTR_P (t1) && TYPE_PTR_P (t2))\n-              || (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2))\n+              || (TYPE_PTRDATAMEM_P (t1) && TYPE_PTRDATAMEM_P (t2))\n               || (TYPE_PTRMEMFUNC_P (t1) && TYPE_PTRMEMFUNC_P (t2)));\n \n   return composite_pointer_type (t1, t2, error_mark_node, error_mark_node,\n@@ -2835,7 +2834,7 @@ cp_build_indirect_ref (tree ptr, ref_operator errorstring,\n     ;\n   /* `pointer' won't be an error_mark_node if we were given a\n      pointer to member, so it's cool to check for this here.  */\n-  else if (TYPE_PTR_TO_MEMBER_P (type))\n+  else if (TYPE_PTRMEM_P (type))\n     switch (errorstring)\n       {\n          case RO_ARRAY_INDEXING:\n@@ -3839,9 +3838,9 @@ cp_build_binary_op (location_t location,\n \t   && code != EQ_EXPR && code != NE_EXPR && code != MINUS_EXPR) \n \t  /* Or if one of OP0 or OP1 is neither a pointer nor NULL.  */\n \t  || (!null_ptr_cst_p (orig_op0)\n-\t      && !TYPE_PTR_P (type0) && !TYPE_PTR_TO_MEMBER_P (type0))\n+\t      && !TYPE_PTR_OR_PTRMEM_P (type0))\n \t  || (!null_ptr_cst_p (orig_op1) \n-\t      && !TYPE_PTR_P (type1) && !TYPE_PTR_TO_MEMBER_P (type1)))\n+\t      && !TYPE_PTR_OR_PTRMEM_P (type1)))\n       && (complain & tf_warning))\n     {\n       source_location loc =\n@@ -4075,10 +4074,10 @@ cp_build_binary_op (location_t location,\n \t      || code1 == COMPLEX_TYPE || code1 == ENUMERAL_TYPE))\n \tshort_compare = 1;\n       else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n-\t       || (TYPE_PTRMEM_P (type0) && TYPE_PTRMEM_P (type1)))\n+\t       || (TYPE_PTRDATAMEM_P (type0) && TYPE_PTRDATAMEM_P (type1)))\n \tresult_type = composite_pointer_type (type0, type1, op0, op1,\n \t\t\t\t\t      CPO_COMPARISON, complain);\n-      else if ((code0 == POINTER_TYPE || TYPE_PTRMEM_P (type0))\n+      else if ((code0 == POINTER_TYPE || TYPE_PTRDATAMEM_P (type0))\n \t       && null_ptr_cst_p (op1))\n \t{\n \t  if (TREE_CODE (op0) == ADDR_EXPR\n@@ -4091,7 +4090,7 @@ cp_build_binary_op (location_t location,\n \t    }\n \t  result_type = type0;\n \t}\n-      else if ((code1 == POINTER_TYPE || TYPE_PTRMEM_P (type1))\n+      else if ((code1 == POINTER_TYPE || TYPE_PTRDATAMEM_P (type1))\n \t       && null_ptr_cst_p (op0))\n \t{\n \t  if (TREE_CODE (op1) == ADDR_EXPR \n@@ -4769,7 +4768,7 @@ tree\n cp_truthvalue_conversion (tree expr)\n {\n   tree type = TREE_TYPE (expr);\n-  if (TYPE_PTRMEM_P (type))\n+  if (TYPE_PTRDATAMEM_P (type))\n     return build_binary_op (EXPR_LOCATION (expr),\n \t\t\t    NE_EXPR, expr, nullptr_node, 1);\n   else if (TYPE_PTR_P (type) || TYPE_PTRMEMFUNC_P (type))\n@@ -5855,7 +5854,7 @@ tree\n convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n \t\tbool c_cast_p, tsubst_flags_t complain)\n {\n-  if (TYPE_PTRMEM_P (type))\n+  if (TYPE_PTRDATAMEM_P (type))\n     {\n       tree delta;\n \n@@ -6088,7 +6087,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       return cp_fold_convert(type, expr);\n     }\n \n-  if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+  if ((TYPE_PTRDATAMEM_P (type) && TYPE_PTRDATAMEM_P (intype))\n       || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     {\n       tree c1;\n@@ -6099,7 +6098,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       c1 = TYPE_PTRMEM_CLASS_TYPE (intype);\n       c2 = TYPE_PTRMEM_CLASS_TYPE (type);\n \n-      if (TYPE_PTRMEM_P (type))\n+      if (TYPE_PTRDATAMEM_P (type))\n \t{\n \t  t1 = (build_ptrmem_type\n \t\t(c1,\n@@ -6345,14 +6344,14 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     /* OK */\n     ;\n   else if ((INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n-\t    || TYPE_PTR_P (type) || TYPE_PTR_TO_MEMBER_P (type))\n+\t    || TYPE_PTR_OR_PTRMEM_P (type))\n \t   && same_type_p (type, intype))\n     /* DR 799 */\n     return fold_if_not_in_template (build_nop (type, expr));\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     return fold_if_not_in_template (build_nop (type, expr));\n-  else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+  else if ((TYPE_PTRDATAMEM_P (type) && TYPE_PTRDATAMEM_P (intype))\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n       tree sexpr = expr;\n@@ -6460,7 +6459,7 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n   if (valid_p)\n     *valid_p = false;\n \n-  if (!POINTER_TYPE_P (dst_type) && !TYPE_PTRMEM_P (dst_type))\n+  if (!POINTER_TYPE_P (dst_type) && !TYPE_PTRDATAMEM_P (dst_type))\n     {\n       if (complain & tf_error)\n \terror (\"invalid use of const_cast with type %qT, \"\n@@ -6530,7 +6529,7 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n \treturn error_mark_node;\n     }\n \n-  if (TYPE_PTR_P (src_type) || TYPE_PTRMEM_P (src_type))\n+  if (TYPE_PTR_P (src_type) || TYPE_PTRDATAMEM_P (src_type))\n     {\n       if (comp_ptr_ttypes_const (dst_type, src_type))\n \t{\n@@ -8191,7 +8190,7 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n       if (TREE_CODE (to) == VECTOR_TYPE)\n \tis_opaque_pointer = vector_targets_convertible_p (to, from);\n \n-      if (TREE_CODE (to) != POINTER_TYPE && !TYPE_PTRMEM_P (to))\n+      if (TREE_CODE (to) != POINTER_TYPE && !TYPE_PTRDATAMEM_P (to))\n \treturn ((constp >= 0 || to_more_cv_qualified)\n \t\t&& (is_opaque_pointer\n \t\t    || same_type_ignoring_top_level_qualifiers_p (to, from)));\n@@ -8460,8 +8459,8 @@ casts_away_constness_r (tree *t1, tree *t2, tsubst_flags_t complain)\n      to\n \n \t    Tcv2,(M-K+1) * cv2,(M-K+2) * ... cv2,M *.  */\n-  if ((!TYPE_PTR_P (*t1) && !TYPE_PTRMEM_P (*t1))\n-      || (!TYPE_PTR_P (*t2) && !TYPE_PTRMEM_P (*t2)))\n+  if ((!TYPE_PTR_P (*t1) && !TYPE_PTRDATAMEM_P (*t1))\n+      || (!TYPE_PTR_P (*t2) && !TYPE_PTRDATAMEM_P (*t2)))\n     {\n       *t1 = cp_build_qualified_type (void_type_node,\n \t\t\t\t     cp_type_quals (*t1));\n@@ -8473,11 +8472,11 @@ casts_away_constness_r (tree *t1, tree *t2, tsubst_flags_t complain)\n   quals1 = cp_type_quals (*t1);\n   quals2 = cp_type_quals (*t2);\n \n-  if (TYPE_PTRMEM_P (*t1))\n+  if (TYPE_PTRDATAMEM_P (*t1))\n     *t1 = TYPE_PTRMEM_POINTED_TO_TYPE (*t1);\n   else\n     *t1 = TREE_TYPE (*t1);\n-  if (TYPE_PTRMEM_P (*t2))\n+  if (TYPE_PTRDATAMEM_P (*t2))\n     *t2 = TYPE_PTRMEM_POINTED_TO_TYPE (*t2);\n   else\n     *t2 = TREE_TYPE (*t2);\n@@ -8514,7 +8513,7 @@ casts_away_constness (tree t1, tree t2, tsubst_flags_t complain)\n \t\t\t\t   complain);\n     }\n \n-  if (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2))\n+  if (TYPE_PTRDATAMEM_P (t1) && TYPE_PTRDATAMEM_P (t2))\n     /* [expr.const.cast]\n \n        Casting from an rvalue of type \"pointer to data member of X"}, {"sha": "c942c0f1cfcbe23051543f756ce0662553e867b3", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66b1156afefc078e6fcf7d9e041b15aea1f3897c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=66b1156afefc078e6fcf7d9e041b15aea1f3897c", "patch": "@@ -1573,7 +1573,7 @@ build_m_component_ref (tree datum, tree component, tsubst_flags_t complain)\n   component = mark_rvalue_use (component);\n \n   ptrmem_type = TREE_TYPE (component);\n-  if (!TYPE_PTR_TO_MEMBER_P (ptrmem_type))\n+  if (!TYPE_PTRMEM_P (ptrmem_type))\n     {\n       if (complain & tf_error)\n \terror (\"%qE cannot be used as a member pointer, since it is of \"\n@@ -1615,7 +1615,7 @@ build_m_component_ref (tree datum, tree component, tsubst_flags_t complain)\n \treturn error_mark_node;\n     }\n \n-  if (TYPE_PTRMEM_P (ptrmem_type))\n+  if (TYPE_PTRDATAMEM_P (ptrmem_type))\n     {\n       bool is_lval = real_lvalue_p (datum);\n       tree ptype;"}]}