{"sha": "355a76735231beec33c140af2d9e6adca486225c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1YTc2NzM1MjMxYmVlYzMzYzE0MGFmMmQ5ZTZhZGNhNDg2MjI1Yw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-05-02T16:41:48Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-05-02T16:41:48Z"}, "message": "coretypes.h (gimple_seq, [...]): Typedef as gimple.\n\n\t* coretypes.h (gimple_seq, const_gimple_seq): Typedef as gimple.\n\t* gimple.h (struct gimple_seq_node_d, struct gimple_seq_d): Remove.\n\t(const_gimple_seq_node): Remove.\n\t(gimple_seq_node): Typedef as gimple.\n\t(struct gimple_statement_base): Add next and prev members,\n\tadjust all WORD markers in using structs.\n\t(union gimple_statement_d): Link via gsbase.next field for GC and PCH.\n\t(gimple_seq_first, gimple_seq_first_stmt, gimple_seq_last,\n\tgimple_seq_last_stmt): Adjust as gimple_seq, gimple_seq_node and\n\tgimple are the same.\n\t(gimple_seq_set_last, gimple_seq_set_first): Don't allocate\n\tgimple_seq, adjust.\n\t(gimple_init_singleton): New function.\n\t(gsi_start_1, gsi_last_1, gsi_end_p, gsi_one_before_end_p): Adjust.\n\t(gsi_next, gsi_prev): Adjust, handle prev cyclic list correctly.\n\t(gsi_stmt): Adjust.\n\t(gsi_stmt_ptr): Remove.\n\t(enum gimple_alloc_kind): Remove gimple_alloc_kind_seq member.\n\n\t* gimple-iterator.c (update_bb_for_stmts): Take last parameter\n\tagain, adjust for above changes.\n\t(update_call_edge_frequencies): Adjust for above changes.\n\t(gsi_insert_seq_nodes_before): Rewrite for new data structure.\n\t(gsi_insert_seq_nodes_after): Ditto.\n\t(gsi_split_seq_after): Ditto.\n\t(gsi_set_stmt): Ditto.\n\t(gsi_split_seq_before): Ditto.\n\t(gsi_remove): Ditto.\n\t(gsi_insert_seq_before_without_update): Don't free sequence.\n\t(gsi_insert_seq_after_without_update): Ditto.\n\t(gsi_replace): Assert some more invariants.\n\t(gsi_insert_before_without_update, gsi_insert_after_without_update):\n\tTidy.\n\t(gsi_for_stmt): Don't search for stmt.\n\t(gsi_insert_on_edge_immediate): Tidy.\n\n\t* gimple.c (gimple_alloc_k): Remove \"sequences\".\n\t(gimple_seq_cache): Remove.\n\t(gimple_alloc_stat): Make stmt a singleton sequence.\n\t(gimple_seq_alloc, gimple_seq_free): Remove.\n\t(gimple_assign_set_rhs_with_ops_1): Ensure new stmt is a singleton.\n\t(gimple_copy): Ditto.\n\t* gimplify.c (gimplify_cleanup_point_expr): Use gsi_set_stmt,\n\tcreate iterator from correct sequence.\n\t* tree-phinodes.c (make_phi_node): Make stmt a singleton.\n\n\n\t* gimple.h (gimple_stmt_iterator <seq>): Make it be pointer to\n\tgimple_seq.\n\t(gimple_seq_set_last, gimple_seq_set_first): Take pointer to\n\tsequence, lazily allocate it.\n\t(bb_seq_addr): New function.\n\t(gsi_start_1): Rename from gsi_start, but take pointer to sequence.\n\t(gsi_start): Macro to wrap gsi_start_1 taking pointer of argument.\n\t(gsi_none): New function.\n\t(gsi_start_bb): Adjust.\n\t(gsi_last_1): Rename from gsi_last, but take pointer to sequence.\n\t(gsi_last): Macro to wrap gsi_last_1 taking pointer of argument.\n\t(gsi_last_bb): Adjust.\n\t(gsi_seq): Adjust.\n\t* tree-flow-inline.h (phi_nodes_ptr): New function.\n\n\t* gimple-iterator.c (gsi_insert_seq_nodes_before): Adjust to \n\tdatastructure and interface change.\n\t(gsi_insert_seq_before_without_update): Ditto.\n\t(gsi_insert_seq_nodes_after): Ditto.\n\t(gsi_insert_seq_after_without_update): Ditto.\n\t(gsi_split_seq_after): Ditto, don't use gimple_seq_alloc.\n\t(gsi_split_seq_before): Ditto.\n\t(gsi_start_phis): Adjust.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Use\n\tgsi_none.\n\t(vect_transform_loop): Ditto.\n\t* gimple.c (gimple_seq_add_stmt, gimple_seq_add_seq,\n\tgimple_seq_copy): Don't use gimple_seq_alloc.\n\t* gimplify.c (gimple_seq_add_stmt_without_update): Ditto.\n\t(gimplify_seq_add_seq): Ditto.\n\t* lto-streamer-in.c (make_new_block): Ditto.\n\t* tree-cfg.c (create_bb): Ditto.\n\t* tree-sra.c (initialize_parameter_reductions): Ditto.\n\n\n\t* gimple.h (gimple_seq_first, gimple_seq_first_stmt, gimple_seq_last,\n\tgimple_seq_last_stmt, gimple_seq_set_last, gimple_seq_set_first,\n\tgimple_seq_empty_p, gimple_seq_alloc_with_stmt, bb_seq,\n\tset_bb_seq): Move down to after gimple_statement_d definition.\n\n\n\t* gimple-fold.c (gimplify_and_update_call_from_tree): Use\n\tgsi_replace_with_seq, instead of inserting itself.\n\t* gimple-iterator.c (gsi_replace_with_seq): New function.\n\t* tree-ssa-forwprop.c (forward_propagate_comparison): Take\n\titerator instead of statement, advance it.\n\t(ssa_forward_propagate_and_combine): Adjust call to above.\n\n\n\t* tree-phinodes.c (add_phi_node_to_bb): Tidy, don't use\n\tgimple_seq_alloc.\n\t* omp-low.c (finalize_task_copyfn): Don't use gimple_seq_alloc.\n\t* tree-nested.c (walk_gimple_omp_for): Ditto.\n\t* trans-mem.c (lower_transaction): Ditto.\n\t* tree-eh.c (do_return_redirection): Ditto.\n\t(do_goto_redirection): Ditto.\n\t(lower_try_finally_switch): Ditto.\n\t* gimplify.c (gimplify_stmt): Ditto.\n\t(gimplify_scan_omp_clauses): Ditto.\n\t(gimplify_omp_for): Ditto.\n\t(gimplify_function_tree): Ditto.\n\t* gimple-fold.c (gimplify_and_update_call_from_tree): Ditto.\n\t* tree-mudflap.c (mf_decl_cache_locals): Ditto.\n\t(mf_build_check_statement_for): Ditto.\n\t(mx_register_decls): Ditto.\n\t* graphite-sese-to-poly.c (remove_invariant_phi): Ditto,\n\tand don't use itertors to append.\n\t(insert_stmts): Ditto.\n\t(insert_out_of_ssa_copy): Ditto.\n\t(insert_out_of_ssa_copy_on_edge): Ditto.\n\n\n\t* gimple.h (gimple_bind_body_ptr): New function.\n\t(gimple_bind_body): Use it.\n\t(gimple_catch_handler): Use gimple_catch_handler_ptr.\n\t(gimple_eh_filter_failure_ptr): New function.\n\t(gimple_eh_filter_failure): Use it.\n\t(gimple_eh_else_n_body_ptr): New function.\n\t(gimple_eh_else_n_body): Use it.\n\t(gimple_eh_else_e_body_ptr): New function.\n\t(gimple_eh_else_e_body): Use it.\n\t(gimple_try_eval_ptr): New function.\n\t(gimple_try_eval): Use it.\n\t(gimple_try_cleanup_ptr): New function.\n\t(gimple_try_cleanup): Use it.\n\t(gimple_wce_cleanup_ptr): New function.\n\t(gimple_wce_cleanup): Use it.\n\t(gimple_omp_body_ptr): New function.\n\t(gimple_omp_body): Use it.\n\t(gimple_omp_for_pre_body_ptr): New function.\n\t(gimple_omp_for_pre_body): Use it.\n\t(gimple_transaction_body_ptr): New function.\n\t(gimple_transaction_body): Use it.\n\t(gsi_split_seq_before): Adjust to return nothing and take pointer\n\tto sequence.\n\t(gsi_set_stmt): Declare.\n\t(gsi_replace_with_seq): Declare.\n\t(walk_gimple_seq_mod): Declare.\n\t* function.h (struct function <gimple_body>): Use typedef gimple_seq.\n\n\t* gimple-iterator.c (gsi_set_stmt): New function.\n\t(gsi_split_seq_before): Return new sequence via pointer argument.\n\t(gsi_replace): Use gsi_set_stmt.\n\n\t* tree-ssa-loop-im.c (move_computations_stmt): First remove\n\tthen insert stmt.\n\t* tree-complex.c (update_complex_components_on_edge): Don't\n\tcopy gsi.\n\t* tree-phinodes.c (resize_phi_node): Don't resize stmt in-place,\n\treturn new stmt.\n\t(reserve_phi_args_for_new_edge): Change call to above,\n\tuse gsi_set_stmt.\n\n\t* omp-low.c (lower_omp): Change prototype to take pointer to\n\tsequence.\n\t(lower_rec_input_clauses): Use gimple_seq_add_seq instead of\n\titerators.  Adjust call to lower_omp.\n\t(lower_lastprivate_clauses): Adjust call to lower_omp.\n\t(lower_reduction_clauses): Ditto.\n\t(expand_omp_taskreg): Nullify non-cfg body of child_fn.\n\t(lower_omp_sections): Don't explicitely count sequence length,\n\tnullify lowered bodies earlier, ensure stmts are part of only\n\tone sequence, adjust call to lower_omp.\n\t(lower_omp_single): Ensure stmts are part of only one sequence,\n\tadjust call to lower_omp.\n\t(lower_omp_master): Ditto.\n\t(lower_omp_ordered): Ditto.\n\t(lower_omp_critical): Ditto.\n\t(lower_omp_for): Ditto.\n\t(lower_omp_taskreg): Ditto, tidy.\n\t(lower_omp_1): Adjust calls to lower_omp.\n\t(execute_lower_omp): Ditto.\n\t(lower_omp): Adjust to take pointer to sequence.\n\t(diagnose_sb_2): Use walk_gimple_seq_mod.\n\t(diagnose_omp_structured_block_errors): Ditto and set possibly\n\tchanged function body.\n\t* gimple-low.c (lower_function_body): Set function body after\n\tit stabilizes.\n\t(lower_sequence): Adjust to take pointer to sequence.\n\t(lower_omp_directive): Ensure stmt isn't put twice into the\n\tsequence, adjust call to lower_sequence.\n\t(lower_stmt): Adjust calls to lower_sequence.\n\t(lower_gimple_bind): Ditto.\n\t(gimple_try_catch_may_fallthru): Call gsi_start with lvalue.\n\t* tree-nested.c (walk_body): Take pointer to sequence, use\n\twalk_gimple_seq_mod.\n\t(walk_function): Adjust call to walk_body, set possibly changed\n\tbody.\n\t(walk_gimple_omp_for): Adjust calls to walk_body.\n\t(convert_nonlocal_omp_clauses): Ditto.\n\t(convert_nonlocal_reference_stmt): Ditto.\n\t(convert_local_omp_clauses): Ditto.\n\t(convert_local_reference_stmt): Ditto.\n\t(convert_tramp_reference_stmt): Ditto.\n\t(convert_gimple_call): Ditto.\n\t(convert_nl_goto_reference): Use local iterator copy.\n\t* gimple.c (walk_gimple_seq_mod): Renamed from walk_gimple_seq,\n\tbut taking pointer to sequence, ensure gsi_start is called with\n\tcallers lvalue.\n\t(walk_gimple_seq): New wrapper around walk_gimple_seq_mod,\n\tasserting that the sequence head didn't change.\n\t(walk_gimple_stmt): Replace all calls to walk_gimple_seq with\n\twalk_gimple_seq_mod.\n\t* trans-mem.c (lower_transaction): Use walk_gimple_seq_mod.\n\t(execute_lower_tm): Ditto, and set possibly changed body.\n\t* tree-eh.c (lower_eh_constructs_1): Take pointer to sequence,\n\tcall gsi_start with that lvalue.\n\t(replace_goto_queue_stmt_list): Ditto.\n\t(replace_goto_queue_1): Adjust calls to replace_goto_queue_stmt_list.\n\t(replace_goto_queue): Ditto.\n\t(lower_try_finally_nofallthru): Adjust calls to lower_eh_constructs_1.\n\t(lower_try_finally_onedest): Ditto.\n\t(lower_try_finally_copy): Ditto.\n\t(lower_try_finally_switch): Ditto.\n\t(lower_try_finally): Ditto.\n\t(lower_eh_filter): Ditto.\n\t(lower_eh_must_not_throw): Ditto.\n\t(lower_cleanup): Ditto.\n\t(lower_eh_constructs_2): Ditto.\n\t(lower_catch): Ditto, and ensure gsi_start is called with lvalue.\n\t(lower_eh_constructs): Adjust calls to lower_eh_constructs_1, and\n\tset possibly changed body.\n\t(optimize_double_finally): Call gsi_start with lvalue.\n\n\t* tree-cfg.c (make_blocks): Adjust call to gsi_split_seq_before.\n\t(gimple_split_block): Ditto.\n\t(gimple_merge_blocks): Use gsi_start_phis.\n\t(move_stmt_r): Use walk_gimple_seq_mod.\n\t* tree-ssa-dse.c (dse_enter_block): Use gsi_last_bb.\n\t* cgraphbuild.c (build_cgraph_edges): Use gsi_start_phis.\n\t(rebuild_cgraph_edges): Ditto.\n\t(cgraph_rebuild_references): Ditto.\n\t* ipa-prop.c (ipa_analyze_params_uses): Ditto.\n\t* tree-inline.c (copy_phis_for_bb): Ditto.\n\t* tree-ssa-dce.c: Ditto.\n\n\t* cgraphunit.c (cgraph_analyze_function): Use gimple_has_body_p.\n\nFrom-SVN: r187053", "tree": {"sha": "a909112c3b26051d56924ebe9435b84f207b2091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a909112c3b26051d56924ebe9435b84f207b2091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/355a76735231beec33c140af2d9e6adca486225c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355a76735231beec33c140af2d9e6adca486225c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355a76735231beec33c140af2d9e6adca486225c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355a76735231beec33c140af2d9e6adca486225c/comments", "author": null, "committer": null, "parents": [{"sha": "63dc7fbee074066f132d5092e53e6d62757bb922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63dc7fbee074066f132d5092e53e6d62757bb922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63dc7fbee074066f132d5092e53e6d62757bb922"}], "stats": {"total": 1812, "additions": 1074, "deletions": 738}, "files": [{"sha": "7611f01ad35cf8de8ff17f42618709365b315380", "filename": "gcc/ChangeLog", "status": "modified", "additions": 253, "deletions": 1, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -1,7 +1,259 @@\n+2012-05-02  Michael Matz  <matz@suse.de>\n+\n+\t* coretypes.h (gimple_seq, const_gimple_seq): Typedef as gimple.\n+\t* gimple.h (struct gimple_seq_node_d, struct gimple_seq_d): Remove.\n+\t(const_gimple_seq_node): Remove.\n+\t(gimple_seq_node): Typedef as gimple.\n+\t(struct gimple_statement_base): Add next and prev members,\n+\tadjust all WORD markers in using structs.\n+\t(union gimple_statement_d): Link via gsbase.next field for GC and PCH.\n+\t(gimple_seq_first, gimple_seq_first_stmt, gimple_seq_last,\n+\tgimple_seq_last_stmt): Adjust as gimple_seq, gimple_seq_node and\n+\tgimple are the same.\n+\t(gimple_seq_set_last, gimple_seq_set_first): Don't allocate\n+\tgimple_seq, adjust.\n+\t(gimple_init_singleton): New function.\n+\t(gsi_start_1, gsi_last_1, gsi_end_p, gsi_one_before_end_p): Adjust.\n+\t(gsi_next, gsi_prev): Adjust, handle prev cyclic list correctly.\n+\t(gsi_stmt): Adjust.\n+\t(gsi_stmt_ptr): Remove.\n+\t(enum gimple_alloc_kind): Remove gimple_alloc_kind_seq member.\n+\n+\t* gimple-iterator.c (update_bb_for_stmts): Take last parameter\n+\tagain, adjust for above changes.\n+\t(update_call_edge_frequencies): Adjust for above changes.\n+\t(gsi_insert_seq_nodes_before): Rewrite for new data structure.\n+\t(gsi_insert_seq_nodes_after): Ditto.\n+\t(gsi_split_seq_after): Ditto.\n+\t(gsi_set_stmt): Ditto.\n+\t(gsi_split_seq_before): Ditto.\n+\t(gsi_remove): Ditto.\n+\t(gsi_insert_seq_before_without_update): Don't free sequence.\n+\t(gsi_insert_seq_after_without_update): Ditto.\n+\t(gsi_replace): Assert some more invariants.\n+\t(gsi_insert_before_without_update, gsi_insert_after_without_update):\n+\tTidy.\n+\t(gsi_for_stmt): Don't search for stmt.\n+\t(gsi_insert_on_edge_immediate): Tidy.\n+\n+\t* gimple.c (gimple_alloc_k): Remove \"sequences\".\n+\t(gimple_seq_cache): Remove.\n+\t(gimple_alloc_stat): Make stmt a singleton sequence.\n+\t(gimple_seq_alloc, gimple_seq_free): Remove.\n+\t(gimple_assign_set_rhs_with_ops_1): Ensure new stmt is a singleton.\n+\t(gimple_copy): Ditto.\n+\t* gimplify.c (gimplify_cleanup_point_expr): Use gsi_set_stmt,\n+\tcreate iterator from correct sequence.\n+\t* tree-phinodes.c (make_phi_node): Make stmt a singleton.\n+\n+2012-05-02  Michael Matz  <matz@suse.de>\n+\n+\t* gimple.h (gimple_stmt_iterator <seq>): Make it be pointer to\n+\tgimple_seq.\n+\t(gimple_seq_set_last, gimple_seq_set_first): Take pointer to\n+\tsequence, lazily allocate it.\n+\t(bb_seq_addr): New function.\n+\t(gsi_start_1): Rename from gsi_start, but take pointer to sequence.\n+\t(gsi_start): Macro to wrap gsi_start_1 taking pointer of argument.\n+\t(gsi_none): New function.\n+\t(gsi_start_bb): Adjust.\n+\t(gsi_last_1): Rename from gsi_last, but take pointer to sequence.\n+\t(gsi_last): Macro to wrap gsi_last_1 taking pointer of argument.\n+\t(gsi_last_bb): Adjust.\n+\t(gsi_seq): Adjust.\n+\t* tree-flow-inline.h (phi_nodes_ptr): New function.\n+\n+\t* gimple-iterator.c (gsi_insert_seq_nodes_before): Adjust to \n+\tdatastructure and interface change.\n+\t(gsi_insert_seq_before_without_update): Ditto.\n+\t(gsi_insert_seq_nodes_after): Ditto.\n+\t(gsi_insert_seq_after_without_update): Ditto.\n+\t(gsi_split_seq_after): Ditto, don't use gimple_seq_alloc.\n+\t(gsi_split_seq_before): Ditto.\n+\t(gsi_start_phis): Adjust.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Use\n+\tgsi_none.\n+\t(vect_transform_loop): Ditto.\n+\t* gimple.c (gimple_seq_add_stmt, gimple_seq_add_seq,\n+\tgimple_seq_copy): Don't use gimple_seq_alloc.\n+\t* gimplify.c (gimple_seq_add_stmt_without_update): Ditto.\n+\t(gimplify_seq_add_seq): Ditto.\n+\t* lto-streamer-in.c (make_new_block): Ditto.\n+\t* tree-cfg.c (create_bb): Ditto.\n+\t* tree-sra.c (initialize_parameter_reductions): Ditto.\n+\n+2012-05-02  Michael Matz  <matz@suse.de>\n+\n+\t* gimple.h (gimple_seq_first, gimple_seq_first_stmt, gimple_seq_last,\n+\tgimple_seq_last_stmt, gimple_seq_set_last, gimple_seq_set_first,\n+\tgimple_seq_empty_p, gimple_seq_alloc_with_stmt, bb_seq,\n+\tset_bb_seq): Move down to after gimple_statement_d definition.\n+\n+2012-05-02  Michael Matz  <matz@suse.de>\n+\n+\t* gimple-fold.c (gimplify_and_update_call_from_tree): Use\n+\tgsi_replace_with_seq, instead of inserting itself.\n+\t* gimple-iterator.c (gsi_replace_with_seq): New function.\n+\t* tree-ssa-forwprop.c (forward_propagate_comparison): Take\n+\titerator instead of statement, advance it.\n+\t(ssa_forward_propagate_and_combine): Adjust call to above.\n+\n+2012-05-02  Michael Matz  <matz@suse.de>\n+\n+\t* tree-phinodes.c (add_phi_node_to_bb): Tidy, don't use\n+\tgimple_seq_alloc.\n+\t* omp-low.c (finalize_task_copyfn): Don't use gimple_seq_alloc.\n+\t* tree-nested.c (walk_gimple_omp_for): Ditto.\n+\t* trans-mem.c (lower_transaction): Ditto.\n+\t* tree-eh.c (do_return_redirection): Ditto.\n+\t(do_goto_redirection): Ditto.\n+\t(lower_try_finally_switch): Ditto.\n+\t* gimplify.c (gimplify_stmt): Ditto.\n+\t(gimplify_scan_omp_clauses): Ditto.\n+\t(gimplify_omp_for): Ditto.\n+\t(gimplify_function_tree): Ditto.\n+\t* gimple-fold.c (gimplify_and_update_call_from_tree): Ditto.\n+\t* tree-mudflap.c (mf_decl_cache_locals): Ditto.\n+\t(mf_build_check_statement_for): Ditto.\n+\t(mx_register_decls): Ditto.\n+\t* graphite-sese-to-poly.c (remove_invariant_phi): Ditto,\n+\tand don't use itertors to append.\n+\t(insert_stmts): Ditto.\n+\t(insert_out_of_ssa_copy): Ditto.\n+\t(insert_out_of_ssa_copy_on_edge): Ditto.\n+\n+2012-05-02  Michael Matz  <matz@suse.de>\n+\n+\t* gimple.h (gimple_bind_body_ptr): New function.\n+\t(gimple_bind_body): Use it.\n+\t(gimple_catch_handler): Use gimple_catch_handler_ptr.\n+\t(gimple_eh_filter_failure_ptr): New function.\n+\t(gimple_eh_filter_failure): Use it.\n+\t(gimple_eh_else_n_body_ptr): New function.\n+\t(gimple_eh_else_n_body): Use it.\n+\t(gimple_eh_else_e_body_ptr): New function.\n+\t(gimple_eh_else_e_body): Use it.\n+\t(gimple_try_eval_ptr): New function.\n+\t(gimple_try_eval): Use it.\n+\t(gimple_try_cleanup_ptr): New function.\n+\t(gimple_try_cleanup): Use it.\n+\t(gimple_wce_cleanup_ptr): New function.\n+\t(gimple_wce_cleanup): Use it.\n+\t(gimple_omp_body_ptr): New function.\n+\t(gimple_omp_body): Use it.\n+\t(gimple_omp_for_pre_body_ptr): New function.\n+\t(gimple_omp_for_pre_body): Use it.\n+\t(gimple_transaction_body_ptr): New function.\n+\t(gimple_transaction_body): Use it.\n+\t(gsi_split_seq_before): Adjust to return nothing and take pointer\n+\tto sequence.\n+\t(gsi_set_stmt): Declare.\n+\t(gsi_replace_with_seq): Declare.\n+\t(walk_gimple_seq_mod): Declare.\n+\t* function.h (struct function <gimple_body>): Use typedef gimple_seq.\n+\n+\t* gimple-iterator.c (gsi_set_stmt): New function.\n+\t(gsi_split_seq_before): Return new sequence via pointer argument.\n+\t(gsi_replace): Use gsi_set_stmt.\n+\n+\t* tree-ssa-loop-im.c (move_computations_stmt): First remove\n+\tthen insert stmt.\n+\t* tree-complex.c (update_complex_components_on_edge): Don't\n+\tcopy gsi.\n+\t* tree-phinodes.c (resize_phi_node): Don't resize stmt in-place,\n+\treturn new stmt.\n+\t(reserve_phi_args_for_new_edge): Change call to above,\n+\tuse gsi_set_stmt.\n+\n+\t* omp-low.c (lower_omp): Change prototype to take pointer to\n+\tsequence.\n+\t(lower_rec_input_clauses): Use gimple_seq_add_seq instead of\n+\titerators.  Adjust call to lower_omp.\n+\t(lower_lastprivate_clauses): Adjust call to lower_omp.\n+\t(lower_reduction_clauses): Ditto.\n+\t(expand_omp_taskreg): Nullify non-cfg body of child_fn.\n+\t(lower_omp_sections): Don't explicitely count sequence length,\n+\tnullify lowered bodies earlier, ensure stmts are part of only\n+\tone sequence, adjust call to lower_omp.\n+\t(lower_omp_single): Ensure stmts are part of only one sequence,\n+\tadjust call to lower_omp.\n+\t(lower_omp_master): Ditto.\n+\t(lower_omp_ordered): Ditto.\n+\t(lower_omp_critical): Ditto.\n+\t(lower_omp_for): Ditto.\n+\t(lower_omp_taskreg): Ditto, tidy.\n+\t(lower_omp_1): Adjust calls to lower_omp.\n+\t(execute_lower_omp): Ditto.\n+\t(lower_omp): Adjust to take pointer to sequence.\n+\t(diagnose_sb_2): Use walk_gimple_seq_mod.\n+\t(diagnose_omp_structured_block_errors): Ditto and set possibly\n+\tchanged function body.\n+\t* gimple-low.c (lower_function_body): Set function body after\n+\tit stabilizes.\n+\t(lower_sequence): Adjust to take pointer to sequence.\n+\t(lower_omp_directive): Ensure stmt isn't put twice into the\n+\tsequence, adjust call to lower_sequence.\n+\t(lower_stmt): Adjust calls to lower_sequence.\n+\t(lower_gimple_bind): Ditto.\n+\t(gimple_try_catch_may_fallthru): Call gsi_start with lvalue.\n+\t* tree-nested.c (walk_body): Take pointer to sequence, use\n+\twalk_gimple_seq_mod.\n+\t(walk_function): Adjust call to walk_body, set possibly changed\n+\tbody.\n+\t(walk_gimple_omp_for): Adjust calls to walk_body.\n+\t(convert_nonlocal_omp_clauses): Ditto.\n+\t(convert_nonlocal_reference_stmt): Ditto.\n+\t(convert_local_omp_clauses): Ditto.\n+\t(convert_local_reference_stmt): Ditto.\n+\t(convert_tramp_reference_stmt): Ditto.\n+\t(convert_gimple_call): Ditto.\n+\t(convert_nl_goto_reference): Use local iterator copy.\n+\t* gimple.c (walk_gimple_seq_mod): Renamed from walk_gimple_seq,\n+\tbut taking pointer to sequence, ensure gsi_start is called with\n+\tcallers lvalue.\n+\t(walk_gimple_seq): New wrapper around walk_gimple_seq_mod,\n+\tasserting that the sequence head didn't change.\n+\t(walk_gimple_stmt): Replace all calls to walk_gimple_seq with\n+\twalk_gimple_seq_mod.\n+\t* trans-mem.c (lower_transaction): Use walk_gimple_seq_mod.\n+\t(execute_lower_tm): Ditto, and set possibly changed body.\n+\t* tree-eh.c (lower_eh_constructs_1): Take pointer to sequence,\n+\tcall gsi_start with that lvalue.\n+\t(replace_goto_queue_stmt_list): Ditto.\n+\t(replace_goto_queue_1): Adjust calls to replace_goto_queue_stmt_list.\n+\t(replace_goto_queue): Ditto.\n+\t(lower_try_finally_nofallthru): Adjust calls to lower_eh_constructs_1.\n+\t(lower_try_finally_onedest): Ditto.\n+\t(lower_try_finally_copy): Ditto.\n+\t(lower_try_finally_switch): Ditto.\n+\t(lower_try_finally): Ditto.\n+\t(lower_eh_filter): Ditto.\n+\t(lower_eh_must_not_throw): Ditto.\n+\t(lower_cleanup): Ditto.\n+\t(lower_eh_constructs_2): Ditto.\n+\t(lower_catch): Ditto, and ensure gsi_start is called with lvalue.\n+\t(lower_eh_constructs): Adjust calls to lower_eh_constructs_1, and\n+\tset possibly changed body.\n+\t(optimize_double_finally): Call gsi_start with lvalue.\n+\n+\t* tree-cfg.c (make_blocks): Adjust call to gsi_split_seq_before.\n+\t(gimple_split_block): Ditto.\n+\t(gimple_merge_blocks): Use gsi_start_phis.\n+\t(move_stmt_r): Use walk_gimple_seq_mod.\n+\t* tree-ssa-dse.c (dse_enter_block): Use gsi_last_bb.\n+\t* cgraphbuild.c (build_cgraph_edges): Use gsi_start_phis.\n+\t(rebuild_cgraph_edges): Ditto.\n+\t(cgraph_rebuild_references): Ditto.\n+\t* ipa-prop.c (ipa_analyze_params_uses): Ditto.\n+\t* tree-inline.c (copy_phis_for_bb): Ditto.\n+\t* tree-ssa-dce.c: Ditto.\n+\n+\t* cgraphunit.c (cgraph_analyze_function): Use gimple_has_body_p.\n+\n 2012-05-02  Kirill Yukhin  <kirill.yukhin@intel.com>\n \t    Andi Kleen <ak@linux.intel.com>\n \n-\t* coretypes (MEMMODEL_MASK): New.\n+\t* coretypes.h (MEMMODEL_MASK): New.\n \t* builtins.c (get_memmodel): Add val. Call target.memmodel_check\n \tand return new variable.\n \t(expand_builtin_atomic_exchange):  Mask memmodel values."}, {"sha": "3abf869684eb9de18d81d3c1646814afb264f3f6", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -348,7 +348,7 @@ build_cgraph_edges (void)\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t}\n-      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), node,\n \t\t\t\t       mark_load, mark_store, mark_address);\n    }\n@@ -440,7 +440,7 @@ rebuild_cgraph_edges (void)\n \t\t\t\t\t mark_store, mark_address);\n \n \t}\n-      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), node,\n \t\t\t\t       mark_load, mark_store, mark_address);\n     }\n@@ -474,7 +474,7 @@ cgraph_rebuild_references (void)\n \t\t\t\t\t mark_store, mark_address);\n \n \t}\n-      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), node,\n \t\t\t\t       mark_load, mark_store, mark_address);\n     }"}, {"sha": "cfb94149ed4be6af284bbd3998355f5e14a0d528", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -646,7 +646,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t function we lower it, which will require gimplified nested\n \t functions, so we can end up here with an already gimplified\n \t body.  */\n-      if (!gimple_body (decl))\n+      if (!gimple_has_body_p (decl))\n \tgimplify_function_tree (decl);\n       dump_function (TDI_generic, decl);\n "}, {"sha": "813b0c349aa476a12c40e2d5fe9739762df3576e", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -72,9 +72,8 @@ struct cl_decoded_option;\n struct cl_option_handlers;\n struct diagnostic_context;\n typedef struct diagnostic_context diagnostic_context;\n-struct gimple_seq_d;\n-typedef struct gimple_seq_d *gimple_seq;\n-typedef const struct gimple_seq_d *const_gimple_seq;\n+typedef gimple gimple_seq;\n+typedef gimple const_gimple_seq;\n \n /* Address space number for named address space support.  */\n typedef unsigned char addr_space_t;"}, {"sha": "34efb3157abe1c349f462c6b6f2deef0a26a4b5b", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -507,7 +507,7 @@ struct GTY(()) function {\n   struct control_flow_graph *cfg;\n \n   /* GIMPLE body for this function.  */\n-  struct gimple_seq_d *gimple_body;\n+  gimple_seq gimple_body;\n \n   /* SSA and dataflow information.  */\n   struct gimple_df *gimple_df;"}, {"sha": "90405e67e0fdf57cdf3b0d7696e681b0d7b1ccad", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -549,9 +549,8 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n   tree lhs;\n   gimple stmt, new_stmt;\n   gimple_stmt_iterator i;\n-  gimple_seq stmts = gimple_seq_alloc();\n+  gimple_seq stmts = NULL;\n   struct gimplify_ctx gctx;\n-  gimple last;\n   gimple laststore;\n   tree reaching_vuse;\n \n@@ -620,17 +619,9 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \n   /* Second iterate over the statements forward, assigning virtual\n      operands to their uses.  */\n-  last = NULL;\n   reaching_vuse = gimple_vuse (stmt);\n   for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))\n     {\n-      /* Do not insert the last stmt in this loop but remember it\n-         for replacing the original statement.  */\n-      if (last)\n-\t{\n-\t  gsi_insert_before (si_p, last, GSI_NEW_STMT);\n-\t  gsi_next (si_p);\n-\t}\n       new_stmt = gsi_stmt (i);\n       /* The replacement can expose previously unreferenced variables.  */\n       if (gimple_in_ssa_p (cfun))\n@@ -642,7 +633,6 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n       gimple_set_modified (new_stmt, true);\n       if (gimple_vdef (new_stmt))\n \treaching_vuse = gimple_vdef (new_stmt);\n-      last = new_stmt;\n     }\n \n   /* If the new sequence does not do a store release the virtual\n@@ -659,8 +649,8 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \t}\n     }\n \n-  /* Finally replace rhe original statement with the last.  */\n-  gsi_replace (si_p, last, false);\n+  /* Finally replace the original statement with the sequence.  */\n+  gsi_replace_with_seq (si_p, stmts, false);\n }\n \n /* Return the string length, maximum string length or maximum value of"}, {"sha": "dd78faa323897782d122638d4203e0c2041a6560", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 137, "deletions": 91, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -57,12 +57,17 @@ update_modified_stmts (gimple_seq seq)\n    starting at FIRST and LAST.  */\n \n static void\n-update_bb_for_stmts (gimple_seq_node first, basic_block bb)\n+update_bb_for_stmts (gimple_seq_node first, gimple_seq_node last,\n+\t\t     basic_block bb)\n {\n   gimple_seq_node n;\n \n-  for (n = first; n; n = n->next)\n-    gimple_set_bb (n->stmt, bb);\n+  for (n = first; n; n = n->gsbase.next)\n+    {\n+      gimple_set_bb (n, bb);\n+      if (n == last)\n+\tbreak;\n+    }\n }\n \n /* Set the frequencies for the cgraph_edges for each of the calls\n@@ -75,8 +80,8 @@ update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n   int bb_freq = 0;\n   gimple_seq_node n;\n \n-  for (n = first; n ; n = n->next)\n-    if (is_gimple_call (n->stmt))\n+  for (n = first; n ; n = n->gsbase.next)\n+    if (is_gimple_call (n))\n       {\n \tstruct cgraph_edge *e;\n \n@@ -89,7 +94,7 @@ update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n \t\t       (current_function_decl, bb));\n \t  }\n \n-\te = cgraph_edge (cfun_node, n->stmt);\n+\te = cgraph_edge (cfun_node, n);\n \tif (e != NULL)\n \t  e->frequency = bb_freq;\n       }\n@@ -113,32 +118,37 @@ gsi_insert_seq_nodes_before (gimple_stmt_iterator *i,\n   basic_block bb;\n   gimple_seq_node cur = i->ptr;\n \n+  gcc_assert (!cur || cur->gsbase.prev);\n+\n   if ((bb = gsi_bb (*i)) != NULL)\n-    update_bb_for_stmts (first, bb);\n+    update_bb_for_stmts (first, last, bb);\n \n   /* Link SEQ before CUR in the sequence.  */\n   if (cur)\n     {\n-      first->prev = cur->prev;\n-      if (first->prev)\n-\tfirst->prev->next = first;\n+      first->gsbase.prev = cur->gsbase.prev;\n+      if (first->gsbase.prev->gsbase.next)\n+\tfirst->gsbase.prev->gsbase.next = first;\n       else\n \tgimple_seq_set_first (i->seq, first);\n-      last->next = cur;\n-      cur->prev = last;\n+      last->gsbase.next = cur;\n+      cur->gsbase.prev = last;\n     }\n   else\n     {\n-      gimple_seq_node itlast = gimple_seq_last (i->seq);\n+      gimple_seq_node itlast = gimple_seq_last (*i->seq);\n \n       /* If CUR is NULL, we link at the end of the sequence (this case happens\n \t when gsi_after_labels is called for a basic block that contains only\n \t labels, so it returns an iterator after the end of the block, and\n \t we need to insert before it; it might be cleaner to add a flag to the\n \t iterator saying whether we are at the start or end of the list).  */\n-      first->prev = itlast;\n+      last->gsbase.next = NULL;\n       if (itlast)\n-\titlast->next = first;\n+\t{\n+\t  first->gsbase.prev = itlast;\n+\t  itlast->gsbase.next = first;\n+\t}\n       else\n \tgimple_seq_set_first (i->seq, first);\n       gimple_seq_set_last (i->seq, last);\n@@ -178,15 +188,11 @@ gsi_insert_seq_before_without_update (gimple_stmt_iterator *i, gimple_seq seq,\n     return;\n \n   /* Don't allow inserting a sequence into itself.  */\n-  gcc_assert (seq != i->seq);\n+  gcc_assert (seq != *i->seq);\n \n   first = gimple_seq_first (seq);\n   last = gimple_seq_last (seq);\n \n-  gimple_seq_set_first (seq, NULL);\n-  gimple_seq_set_last (seq, NULL);\n-  gimple_seq_free (seq);\n-\n   /* Empty sequences need no work.  */\n   if (!first || !last)\n     {\n@@ -230,25 +236,30 @@ gsi_insert_seq_nodes_after (gimple_stmt_iterator *i,\n   basic_block bb;\n   gimple_seq_node cur = i->ptr;\n \n+  gcc_assert (!cur || cur->gsbase.prev);\n+\n   /* If the iterator is inside a basic block, we need to update the\n      basic block information for all the nodes between FIRST and LAST.  */\n   if ((bb = gsi_bb (*i)) != NULL)\n-    update_bb_for_stmts (first, bb);\n+    update_bb_for_stmts (first, last, bb);\n \n   /* Link SEQ after CUR.  */\n   if (cur)\n     {\n-      last->next = cur->next;\n-      if (last->next)\n-\tlast->next->prev = last;\n+      last->gsbase.next = cur->gsbase.next;\n+      if (last->gsbase.next)\n+\t{\n+\t  last->gsbase.next->gsbase.prev = last;\n+\t}\n       else\n \tgimple_seq_set_last (i->seq, last);\n-      first->prev = cur;\n-      cur->next = first;\n+      first->gsbase.prev = cur;\n+      cur->gsbase.next = first;\n     }\n   else\n     {\n-      gcc_assert (!gimple_seq_last (i->seq));\n+      gcc_assert (!gimple_seq_last (*i->seq));\n+      last->gsbase.next = NULL;\n       gimple_seq_set_first (i->seq, first);\n       gimple_seq_set_last (i->seq, last);\n     }\n@@ -289,15 +300,11 @@ gsi_insert_seq_after_without_update (gimple_stmt_iterator *i, gimple_seq seq,\n     return;\n \n   /* Don't allow inserting a sequence into itself.  */\n-  gcc_assert (seq != i->seq);\n+  gcc_assert (seq != *i->seq);\n \n   first = gimple_seq_first (seq);\n   last = gimple_seq_last (seq);\n \n-  gimple_seq_set_first (seq, NULL);\n-  gimple_seq_set_last (seq, NULL);\n-  gimple_seq_free (seq);\n-\n   /* Empty sequences need no work.  */\n   if (!first || !last)\n     {\n@@ -329,59 +336,81 @@ gimple_seq\n gsi_split_seq_after (gimple_stmt_iterator i)\n {\n   gimple_seq_node cur, next;\n-  gimple_seq old_seq, new_seq;\n+  gimple_seq *pold_seq, new_seq;\n \n   cur = i.ptr;\n \n   /* How can we possibly split after the end, or before the beginning?  */\n-  gcc_assert (cur && cur->next);\n-  next = cur->next;\n+  gcc_assert (cur && cur->gsbase.next);\n+  next = cur->gsbase.next;\n \n-  old_seq = i.seq;\n-  new_seq = gimple_seq_alloc ();\n+  pold_seq = i.seq;\n \n-  gimple_seq_set_first (new_seq, next);\n-  gimple_seq_set_last (new_seq, gimple_seq_last (old_seq));\n-  gimple_seq_set_last (old_seq, cur);\n-  cur->next = NULL;\n-  next->prev = NULL;\n+  gimple_seq_set_first (&new_seq, next);\n+  gimple_seq_set_last (&new_seq, gimple_seq_last (*pold_seq));\n+  gimple_seq_set_last (pold_seq, cur);\n+  cur->gsbase.next = NULL;\n \n   return new_seq;\n }\n \n \n+/* Set the statement to which GSI points to STMT.  This only updates\n+   the iterator and the gimple sequence, it doesn't do the bookkeeping\n+   of gsi_replace.  */\n+\n+void\n+gsi_set_stmt (gimple_stmt_iterator *gsi, gimple stmt)\n+{\n+  gimple orig_stmt = gsi_stmt (*gsi);\n+  gimple prev, next;\n+\n+  stmt->gsbase.next = next = orig_stmt->gsbase.next;\n+  stmt->gsbase.prev = prev = orig_stmt->gsbase.prev;\n+  /* Note how we don't clear next/prev of orig_stmt.  This is so that\n+     copies of *GSI our callers might still hold (to orig_stmt)\n+     can be advanced as if they too were replaced.  */\n+  if (prev->gsbase.next)\n+    prev->gsbase.next = stmt;\n+  else\n+    gimple_seq_set_first (gsi->seq, stmt);\n+  if (next)\n+    next->gsbase.prev = stmt;\n+  else\n+    gimple_seq_set_last (gsi->seq, stmt);\n+\n+  gsi->ptr = stmt;\n+}\n+\n+\n /* Move all statements in the sequence before I to a new sequence.\n    Return this new sequence.  I is set to the head of the new list.  */\n \n-gimple_seq\n-gsi_split_seq_before (gimple_stmt_iterator *i)\n+void\n+gsi_split_seq_before (gimple_stmt_iterator *i, gimple_seq *pnew_seq)\n {\n   gimple_seq_node cur, prev;\n-  gimple_seq old_seq, new_seq;\n+  gimple_seq old_seq;\n \n   cur = i->ptr;\n \n   /* How can we possibly split after the end?  */\n   gcc_assert (cur);\n-  prev = cur->prev;\n+  prev = cur->gsbase.prev;\n \n-  old_seq = i->seq;\n-  new_seq = gimple_seq_alloc ();\n-  i->seq = new_seq;\n+  old_seq = *i->seq;\n+  if (!prev->gsbase.next)\n+    *i->seq = NULL;\n+  i->seq = pnew_seq;\n \n   /* Set the limits on NEW_SEQ.  */\n-  gimple_seq_set_first (new_seq, cur);\n-  gimple_seq_set_last (new_seq, gimple_seq_last (old_seq));\n+  gimple_seq_set_first (pnew_seq, cur);\n+  gimple_seq_set_last (pnew_seq, gimple_seq_last (old_seq));\n \n   /* Cut OLD_SEQ before I.  */\n-  gimple_seq_set_last (old_seq, prev);\n-  cur->prev = NULL;\n-  if (prev)\n-    prev->next = NULL;\n-  else\n-    gimple_seq_set_first (old_seq, NULL);\n-\n-  return new_seq;\n+  gimple_seq_set_last (&old_seq, prev);\n+  if (prev->gsbase.next)\n+    prev->gsbase.next = NULL;\n }\n \n \n@@ -416,12 +445,38 @@ gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n   gimple_remove_stmt_histograms (cfun, orig_stmt);\n   delink_stmt_imm_use (orig_stmt);\n \n-  *gsi_stmt_ptr (gsi) = stmt;\n+  gsi_set_stmt (gsi, stmt);\n   gimple_set_modified (stmt, true);\n   update_modified_stmt (stmt);\n }\n \n \n+/* Replace the statement pointed-to by GSI with the sequence SEQ.\n+   If UPDATE_EH_INFO is true, the exception handling information of\n+   the original statement is moved to the last statement of the new\n+   sequence.  If the old statement is an assignment, then so must\n+   be the last statement of the new sequence, and they must have the\n+   same LHS.  */\n+\n+void\n+gsi_replace_with_seq (gimple_stmt_iterator *gsi, gimple_seq seq,\n+\t\t      bool update_eh_info)\n+{\n+  gimple_stmt_iterator seqi;\n+  gimple last;\n+  if (gimple_seq_empty_p (seq))\n+    {\n+      gsi_remove (gsi, true);\n+      return;\n+    }\n+  seqi = gsi_last (seq);\n+  last = gsi_stmt (seqi);\n+  gsi_remove (&seqi, false);\n+  gsi_insert_seq_before (gsi, seq, GSI_SAME_STMT);\n+  gsi_replace (gsi, last, update_eh_info);\n+}\n+\n+\n /* Insert statement STMT before the statement pointed-to by iterator I.\n    M specifies how to update iterator I after insertion (see enum\n    gsi_iterator_update).\n@@ -435,12 +490,7 @@ void\n gsi_insert_before_without_update (gimple_stmt_iterator *i, gimple stmt,\n                                   enum gsi_iterator_update m)\n {\n-  gimple_seq_node n;\n-\n-  n = ggc_alloc_gimple_seq_node_d ();\n-  n->prev = n->next = NULL;\n-  n->stmt = stmt;\n-  gsi_insert_seq_nodes_before (i, n, n, m);\n+  gsi_insert_seq_nodes_before (i, stmt, stmt, m);\n }\n \n /* Insert statement STMT before the statement pointed-to by iterator I.\n@@ -470,12 +520,7 @@ void\n gsi_insert_after_without_update (gimple_stmt_iterator *i, gimple stmt,\n                                  enum gsi_iterator_update m)\n {\n-  gimple_seq_node n;\n-\n-  n = ggc_alloc_gimple_seq_node_d ();\n-  n->prev = n->next = NULL;\n-  n->stmt = stmt;\n-  gsi_insert_seq_nodes_after (i, n, n, m);\n+  gsi_insert_seq_nodes_after (i, stmt, stmt, m);\n }\n \n \n@@ -525,19 +570,24 @@ gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n \n   /* Update the iterator and re-wire the links in I->SEQ.  */\n   cur = i->ptr;\n-  next = cur->next;\n-  prev = cur->prev;\n-\n-  if (prev)\n-    prev->next = next;\n-  else\n-    gimple_seq_set_first (i->seq, next);\n+  next = cur->gsbase.next;\n+  prev = cur->gsbase.prev;\n+  /* See gsi_set_stmt for why we don't reset prev/next of STMT.  */\n \n   if (next)\n-    next->prev = prev;\n-  else\n+    /* Cur is not last.  */\n+    next->gsbase.prev = prev;\n+  else if (prev->gsbase.next)\n+    /* Cur is last but not first.  */\n     gimple_seq_set_last (i->seq, prev);\n \n+  if (prev->gsbase.next)\n+    /* Cur is not first.  */\n+    prev->gsbase.next = next;\n+  else\n+    /* Cur is first.  */\n+    *i->seq = next;\n+\n   i->ptr = next;\n \n   return require_eh_edge_purge;\n@@ -557,11 +607,8 @@ gsi_for_stmt (gimple stmt)\n   else\n     i = gsi_start_bb (bb);\n \n-  for (; !gsi_end_p (i); gsi_next (&i))\n-    if (gsi_stmt (i) == stmt)\n-      return i;\n-\n-  gcc_unreachable ();\n+  i.ptr = stmt;\n+  return i;\n }\n \n \n@@ -727,17 +774,14 @@ basic_block\n gsi_insert_on_edge_immediate (edge e, gimple stmt)\n {\n   gimple_stmt_iterator gsi;\n-  struct gimple_seq_node_d node;\n   basic_block new_bb = NULL;\n   bool ins_after;\n \n   gcc_assert (!PENDING_STMT (e));\n \n   ins_after = gimple_find_edge_insert_loc (e, &gsi, &new_bb);\n \n-  node.stmt = stmt;\n-  node.prev = node.next = NULL;\n-  update_call_edge_frequencies (&node, gsi.bb);\n+  update_call_edge_frequencies (stmt, gsi.bb);\n \n   if (ins_after)\n     gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n@@ -820,5 +864,7 @@ gsi_commit_one_edge_insert (edge e, basic_block *new_bb)\n gimple_stmt_iterator\n gsi_start_phis (basic_block bb)\n {\n-  return gsi_start (phi_nodes (bb));\n+  gimple_seq *pseq = phi_nodes_ptr (bb);\n+  /* XXX check only necessary because ENTRY/EXIT blocks don't have il.gimple */\n+  return pseq ? gsi_start_1 (pseq) : gsi_none ();\n }"}, {"sha": "04d4275f75b7ec47676d1f85465c727541a10254", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -112,10 +112,6 @@ lower_function_body (void)\n   i = gsi_start (lowered_body);\n   lower_gimple_bind (&i, &data);\n \n-  /* Once the old body has been lowered, replace it with the new\n-     lowered sequence.  */\n-  gimple_set_body (current_function_decl, lowered_body);\n-\n   i = gsi_last (lowered_body);\n \n   /* If the function falls off the end, we need a null return statement.\n@@ -179,6 +175,10 @@ lower_function_body (void)\n       gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n     }\n \n+  /* Once the old body has been lowered, replace it with the new\n+     lowered sequence.  */\n+  gimple_set_body (current_function_decl, lowered_body);\n+\n   gcc_assert (data.block == DECL_INITIAL (current_function_decl));\n   BLOCK_SUBBLOCKS (data.block)\n     = blocks_nreverse (BLOCK_SUBBLOCKS (data.block));\n@@ -305,11 +305,11 @@ gimple_check_call_matching_types (gimple call_stmt, tree callee)\n    do it explicitly.  DATA is passed through the recursion.  */\n \n static void\n-lower_sequence (gimple_seq seq, struct lower_data *data)\n+lower_sequence (gimple_seq *seq, struct lower_data *data)\n {\n   gimple_stmt_iterator gsi;\n \n-  for (gsi = gsi_start (seq); !gsi_end_p (gsi); )\n+  for (gsi = gsi_start (*seq); !gsi_end_p (gsi); )\n     lower_stmt (&gsi, data);\n }\n \n@@ -324,11 +324,10 @@ lower_omp_directive (gimple_stmt_iterator *gsi, struct lower_data *data)\n \n   stmt = gsi_stmt (*gsi);\n \n-  lower_sequence (gimple_omp_body (stmt), data);\n-  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n-  gsi_insert_seq_before (gsi, gimple_omp_body (stmt), GSI_SAME_STMT);\n+  lower_sequence (gimple_omp_body_ptr (stmt), data);\n+  gsi_insert_seq_after (gsi, gimple_omp_body (stmt), GSI_CONTINUE_LINKING);\n   gimple_omp_set_body (stmt, NULL);\n-  gsi_remove (gsi, false);\n+  gsi_next (gsi);\n }\n \n \n@@ -376,10 +375,10 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n     case GIMPLE_TRY:\n       {\n \tbool try_cannot_fallthru;\n-\tlower_sequence (gimple_try_eval (stmt), data);\n+\tlower_sequence (gimple_try_eval_ptr (stmt), data);\n \ttry_cannot_fallthru = data->cannot_fallthru;\n \tdata->cannot_fallthru = false;\n-\tlower_sequence (gimple_try_cleanup (stmt), data);\n+\tlower_sequence (gimple_try_cleanup_ptr (stmt), data);\n \t/* See gimple_stmt_may_fallthru for the rationale.  */\n \tif (gimple_try_kind (stmt) == GIMPLE_TRY_FINALLY)\n \t  {\n@@ -392,17 +391,17 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n \n     case GIMPLE_CATCH:\n       data->cannot_fallthru = false;\n-      lower_sequence (gimple_catch_handler (stmt), data);\n+      lower_sequence (gimple_catch_handler_ptr (stmt), data);\n       break;\n \n     case GIMPLE_EH_FILTER:\n       data->cannot_fallthru = false;\n-      lower_sequence (gimple_eh_filter_failure (stmt), data);\n+      lower_sequence (gimple_eh_filter_failure_ptr (stmt), data);\n       break;\n \n     case GIMPLE_EH_ELSE:\n-      lower_sequence (gimple_eh_else_n_body (stmt), data);\n-      lower_sequence (gimple_eh_else_e_body (stmt), data);\n+      lower_sequence (gimple_eh_else_n_body_ptr (stmt), data);\n+      lower_sequence (gimple_eh_else_e_body_ptr (stmt), data);\n       break;\n \n     case GIMPLE_NOP:\n@@ -456,7 +455,7 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n       return;\n \n     case GIMPLE_TRANSACTION:\n-      lower_sequence (gimple_transaction_body (stmt), data);\n+      lower_sequence (gimple_transaction_body_ptr (stmt), data);\n       break;\n \n     default:\n@@ -505,7 +504,7 @@ lower_gimple_bind (gimple_stmt_iterator *gsi, struct lower_data *data)\n     }\n \n   record_vars (gimple_bind_vars (stmt));\n-  lower_sequence (gimple_bind_body (stmt), data);\n+  lower_sequence (gimple_bind_body_ptr (stmt), data);\n \n   if (new_block)\n     {\n@@ -585,7 +584,7 @@ gimple_try_catch_may_fallthru (gimple stmt)\n   if (gimple_seq_may_fallthru (gimple_try_eval (stmt)))\n     return true;\n \n-  i = gsi_start (gimple_try_cleanup (stmt));\n+  i = gsi_start (*gimple_try_cleanup_ptr (stmt));\n   switch (gimple_code (gsi_stmt (i)))\n     {\n     case GIMPLE_CATCH:"}, {"sha": "e8841ec65ae369d482b1b84dd5ea23bfd15d6a99", "filename": "gcc/gimple.c", "status": "modified", "additions": 37, "deletions": 79, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -90,16 +90,11 @@ static const char * const gimple_alloc_kind_names[] = {\n     \"assignments\",\n     \"phi nodes\",\n     \"conditionals\",\n-    \"sequences\",\n     \"everything else\"\n };\n \n #endif /* GATHER_STATISTICS */\n \n-/* A cache of gimple_seq objects.  Sequences are created and destroyed\n-   fairly often during gimplification.  */\n-static GTY ((deletable)) struct gimple_seq_d *gimple_seq_cache;\n-\n /* Private API manipulation functions shared only with some\n    other files.  */\n extern void gimple_set_stored_syms (gimple, bitmap, bitmap_obstack *);\n@@ -154,6 +149,7 @@ gimple_alloc_stat (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n   /* Do not call gimple_set_modified here as it has other side\n      effects and this tuple is still not completely built.  */\n   stmt->gsbase.modified = 1;\n+  gimple_init_singleton (stmt);\n \n   return stmt;\n }\n@@ -1201,67 +1197,16 @@ gimple_check_failed (const_gimple gs, const char *file, int line,\n #endif /* ENABLE_GIMPLE_CHECKING */\n \n \n-/* Allocate a new GIMPLE sequence in GC memory and return it.  If\n-   there are free sequences in GIMPLE_SEQ_CACHE return one of those\n-   instead.  */\n-\n-gimple_seq\n-gimple_seq_alloc (void)\n-{\n-  gimple_seq seq = gimple_seq_cache;\n-  if (seq)\n-    {\n-      gimple_seq_cache = gimple_seq_cache->next_free;\n-      gcc_assert (gimple_seq_cache != seq);\n-      memset (seq, 0, sizeof (*seq));\n-    }\n-  else\n-    {\n-      seq = ggc_alloc_cleared_gimple_seq_d ();\n-#ifdef GATHER_STATISTICS\n-      gimple_alloc_counts[(int) gimple_alloc_kind_seq]++;\n-      gimple_alloc_sizes[(int) gimple_alloc_kind_seq] += sizeof (*seq);\n-#endif\n-    }\n-\n-  return seq;\n-}\n-\n-/* Return SEQ to the free pool of GIMPLE sequences.  */\n-\n-void\n-gimple_seq_free (gimple_seq seq)\n-{\n-  if (seq == NULL)\n-    return;\n-\n-  gcc_assert (gimple_seq_first (seq) == NULL);\n-  gcc_assert (gimple_seq_last (seq) == NULL);\n-\n-  /* If this triggers, it's a sign that the same list is being freed\n-     twice.  */\n-  gcc_assert (seq != gimple_seq_cache || gimple_seq_cache == NULL);\n-\n-  /* Add SEQ to the pool of free sequences.  */\n-  seq->next_free = gimple_seq_cache;\n-  gimple_seq_cache = seq;\n-}\n-\n-\n /* Link gimple statement GS to the end of the sequence *SEQ_P.  If\n    *SEQ_P is NULL, a new sequence is allocated.  */\n \n void\n gimple_seq_add_stmt (gimple_seq *seq_p, gimple gs)\n {\n   gimple_stmt_iterator si;\n-\n   if (gs == NULL)\n     return;\n \n-  if (*seq_p == NULL)\n-    *seq_p = gimple_seq_alloc ();\n-\n   si = gsi_last (*seq_p);\n   gsi_insert_after (&si, gs, GSI_NEW_STMT);\n }\n@@ -1274,13 +1219,9 @@ void\n gimple_seq_add_seq (gimple_seq *dst_p, gimple_seq src)\n {\n   gimple_stmt_iterator si;\n-\n   if (src == NULL)\n     return;\n \n-  if (*dst_p == NULL)\n-    *dst_p = gimple_seq_alloc ();\n-\n   si = gsi_last (*dst_p);\n   gsi_insert_seq_after (&si, src, GSI_NEW_STMT);\n }\n@@ -1324,7 +1265,7 @@ gimple_seq\n gimple_seq_copy (gimple_seq src)\n {\n   gimple_stmt_iterator gsi;\n-  gimple_seq new_seq = gimple_seq_alloc ();\n+  gimple_seq new_seq = NULL;\n   gimple stmt;\n \n   for (gsi = gsi_start (src); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -1337,7 +1278,7 @@ gimple_seq_copy (gimple_seq src)\n }\n \n \n-/* Walk all the statements in the sequence SEQ calling walk_gimple_stmt\n+/* Walk all the statements in the sequence *PSEQ calling walk_gimple_stmt\n    on each one.  WI is as in walk_gimple_stmt.\n \n    If walk_gimple_stmt returns non-NULL, the walk is stopped, and the\n@@ -1349,12 +1290,12 @@ gimple_seq_copy (gimple_seq src)\n    Otherwise, all the statements are walked and NULL returned.  */\n \n gimple\n-walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt,\n-\t\t walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+walk_gimple_seq_mod (gimple_seq *pseq, walk_stmt_fn callback_stmt,\n+\t\t     walk_tree_fn callback_op, struct walk_stmt_info *wi)\n {\n   gimple_stmt_iterator gsi;\n \n-  for (gsi = gsi_start (seq); !gsi_end_p (gsi); )\n+  for (gsi = gsi_start (*pseq); !gsi_end_p (gsi); )\n     {\n       tree ret = walk_gimple_stmt (&gsi, callback_stmt, callback_op, wi);\n       if (ret)\n@@ -1378,6 +1319,20 @@ walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt,\n }\n \n \n+/* Like walk_gimple_seq_mod, but ensure that the head of SEQ isn't\n+   changed by the callbacks.  */\n+\n+gimple\n+walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt,\n+\t\t walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+{\n+  gimple_seq seq2 = seq;\n+  gimple ret = walk_gimple_seq_mod (&seq2, callback_stmt, callback_op, wi);\n+  gcc_assert (seq2 == seq);\n+  return ret;\n+}\n+\n+\n /* Helper function for walk_gimple_stmt.  Walk operands of a GIMPLE_ASM.  */\n \n static tree\n@@ -1808,51 +1763,51 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_BIND:\n-      ret = walk_gimple_seq (gimple_bind_body (stmt), callback_stmt,\n-\t                     callback_op, wi);\n+      ret = walk_gimple_seq_mod (gimple_bind_body_ptr (stmt), callback_stmt,\n+\t\t\t\t callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_CATCH:\n-      ret = walk_gimple_seq (gimple_catch_handler (stmt), callback_stmt,\n-\t                     callback_op, wi);\n+      ret = walk_gimple_seq_mod (gimple_catch_handler_ptr (stmt), callback_stmt,\n+\t\t\t\t callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_EH_FILTER:\n-      ret = walk_gimple_seq (gimple_eh_filter_failure (stmt), callback_stmt,\n+      ret = walk_gimple_seq_mod (gimple_eh_filter_failure_ptr (stmt), callback_stmt,\n \t\t             callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_EH_ELSE:\n-      ret = walk_gimple_seq (gimple_eh_else_n_body (stmt),\n+      ret = walk_gimple_seq_mod (gimple_eh_else_n_body_ptr (stmt),\n \t\t\t     callback_stmt, callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n-      ret = walk_gimple_seq (gimple_eh_else_e_body (stmt),\n+      ret = walk_gimple_seq_mod (gimple_eh_else_e_body_ptr (stmt),\n \t\t\t     callback_stmt, callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_TRY:\n-      ret = walk_gimple_seq (gimple_try_eval (stmt), callback_stmt, callback_op,\n+      ret = walk_gimple_seq_mod (gimple_try_eval_ptr (stmt), callback_stmt, callback_op,\n \t                     wi);\n       if (ret)\n \treturn wi->callback_result;\n \n-      ret = walk_gimple_seq (gimple_try_cleanup (stmt), callback_stmt,\n+      ret = walk_gimple_seq_mod (gimple_try_cleanup_ptr (stmt), callback_stmt,\n \t                     callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_OMP_FOR:\n-      ret = walk_gimple_seq (gimple_omp_for_pre_body (stmt), callback_stmt,\n+      ret = walk_gimple_seq_mod (gimple_omp_for_pre_body_ptr (stmt), callback_stmt,\n \t\t             callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n@@ -1866,21 +1821,21 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n     case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SINGLE:\n-      ret = walk_gimple_seq (gimple_omp_body (stmt), callback_stmt,\n+      ret = walk_gimple_seq_mod (gimple_omp_body_ptr (stmt), callback_stmt,\n \t\t\t     callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_WITH_CLEANUP_EXPR:\n-      ret = walk_gimple_seq (gimple_wce_cleanup (stmt), callback_stmt,\n+      ret = walk_gimple_seq_mod (gimple_wce_cleanup_ptr (stmt), callback_stmt,\n \t\t\t     callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n \n     case GIMPLE_TRANSACTION:\n-      ret = walk_gimple_seq (gimple_transaction_body (stmt),\n+      ret = walk_gimple_seq_mod (gimple_transaction_body_ptr (stmt),\n \t\t\t     callback_stmt, callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n@@ -2181,6 +2136,7 @@ gimple_assign_set_rhs_with_ops_1 (gimple_stmt_iterator *gsi, enum tree_code code\n       tree lhs = gimple_assign_lhs (stmt);\n       gimple new_stmt = gimple_alloc (gimple_code (stmt), new_rhs_ops + 1);\n       memcpy (new_stmt, stmt, gimple_size (gimple_code (stmt)));\n+      gimple_init_singleton (new_stmt);\n       gsi_replace (gsi, new_stmt, true);\n       stmt = new_stmt;\n \n@@ -2270,7 +2226,8 @@ gimple_replace_lhs (gimple stmt, tree nlhs)\n \n /* Return a deep copy of statement STMT.  All the operands from STMT\n    are reallocated and copied using unshare_expr.  The DEF, USE, VDEF\n-   and VUSE operand arrays are set to empty in the new copy.  */\n+   and VUSE operand arrays are set to empty in the new copy.  The new\n+   copy isn't part of any sequence.  */\n \n gimple\n gimple_copy (gimple stmt)\n@@ -2282,6 +2239,7 @@ gimple_copy (gimple stmt)\n \n   /* Shallow copy all the fields from STMT.  */\n   memcpy (copy, stmt, gimple_size (code));\n+  gimple_init_singleton (copy);\n \n   /* If STMT has sub-statements, deep-copy them as well.  */\n   if (gimple_has_substatements (stmt))"}, {"sha": "c40d7c3cc4ec7642321f4cbd01f3aa8b3d860158", "filename": "gcc/gimple.h", "status": "modified", "additions": 376, "deletions": 262, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -32,9 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n \n-struct gimple_seq_node_d;\n-typedef struct gimple_seq_node_d *gimple_seq_node;\n-typedef const struct gimple_seq_node_d *const_gimple_seq_node;\n+typedef gimple gimple_seq_node;\n \n /* For each block, the PHI nodes that need to be rewritten are stored into\n    these vectors.  */\n@@ -133,130 +131,6 @@ enum plf_mask {\n     GF_PLF_2\t= 1 << 1\n };\n \n-/* A node in a gimple_seq_d.  */\n-struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) gimple_seq_node_d {\n-  gimple stmt;\n-  struct gimple_seq_node_d *prev;\n-  struct gimple_seq_node_d *next;\n-};\n-\n-/* A double-linked sequence of gimple statements.  */\n-struct GTY ((chain_next (\"%h.next_free\"))) gimple_seq_d {\n-  /* First and last statements in the sequence.  */\n-  gimple_seq_node first;\n-  gimple_seq_node last;\n-\n-  /* Sequences are created/destroyed frequently.  To minimize\n-     allocation activity, deallocated sequences are kept in a pool of\n-     available sequences.  This is the pointer to the next free\n-     sequence in the pool.  */\n-  gimple_seq next_free;\n-};\n-\n-\n-/* Return the first node in GIMPLE sequence S.  */\n-\n-static inline gimple_seq_node\n-gimple_seq_first (const_gimple_seq s)\n-{\n-  return s ? s->first : NULL;\n-}\n-\n-\n-/* Return the first statement in GIMPLE sequence S.  */\n-\n-static inline gimple\n-gimple_seq_first_stmt (const_gimple_seq s)\n-{\n-  gimple_seq_node n = gimple_seq_first (s);\n-  return (n) ? n->stmt : NULL;\n-}\n-\n-\n-/* Return the last node in GIMPLE sequence S.  */\n-\n-static inline gimple_seq_node\n-gimple_seq_last (const_gimple_seq s)\n-{\n-  return s ? s->last : NULL;\n-}\n-\n-\n-/* Return the last statement in GIMPLE sequence S.  */\n-\n-static inline gimple\n-gimple_seq_last_stmt (const_gimple_seq s)\n-{\n-  gimple_seq_node n = gimple_seq_last (s);\n-  return (n) ? n->stmt : NULL;\n-}\n-\n-\n-/* Set the last node in GIMPLE sequence S to LAST.  */\n-\n-static inline void\n-gimple_seq_set_last (gimple_seq s, gimple_seq_node last)\n-{\n-  s->last = last;\n-}\n-\n-\n-/* Set the first node in GIMPLE sequence S to FIRST.  */\n-\n-static inline void\n-gimple_seq_set_first (gimple_seq s, gimple_seq_node first)\n-{\n-  s->first = first;\n-}\n-\n-\n-/* Return true if GIMPLE sequence S is empty.  */\n-\n-static inline bool\n-gimple_seq_empty_p (const_gimple_seq s)\n-{\n-  return s == NULL || s->first == NULL;\n-}\n-\n-\n-void gimple_seq_add_stmt (gimple_seq *, gimple);\n-\n-/* Link gimple statement GS to the end of the sequence *SEQ_P.  If\n-   *SEQ_P is NULL, a new sequence is allocated.  This function is\n-   similar to gimple_seq_add_stmt, but does not scan the operands.\n-   During gimplification, we need to manipulate statement sequences\n-   before the def/use vectors have been constructed.  */\n-void gimple_seq_add_stmt_without_update (gimple_seq *, gimple);\n-\n-/* Allocate a new sequence and initialize its first element with STMT.  */\n-\n-static inline gimple_seq\n-gimple_seq_alloc_with_stmt (gimple stmt)\n-{\n-  gimple_seq seq = NULL;\n-  gimple_seq_add_stmt (&seq, stmt);\n-  return seq;\n-}\n-\n-\n-/* Returns the sequence of statements in BB.  */\n-\n-static inline gimple_seq\n-bb_seq (const_basic_block bb)\n-{\n-  return (!(bb->flags & BB_RTL) && bb->il.gimple) ? bb->il.gimple->seq : NULL;\n-}\n-\n-\n-/* Sets the sequence of statements in BB to SEQ.  */\n-\n-static inline void\n-set_bb_seq (basic_block bb, gimple_seq seq)\n-{\n-  gcc_checking_assert (!(bb->flags & BB_RTL));\n-  bb->il.gimple->seq = seq;\n-}\n-\n /* Iterator object for GIMPLE statement sequences.  */\n \n typedef struct\n@@ -268,7 +142,7 @@ typedef struct\n      are necessary to handle edge cases such as when statement is\n      added to an empty basic block or when the last statement of a\n      block/sequence is removed.  */\n-  gimple_seq seq;\n+  gimple_seq *seq;\n   basic_block bb;\n } gimple_stmt_iterator;\n \n@@ -332,7 +206,16 @@ struct GTY(()) gimple_statement_base {\n      Basic block holding this statement.  */\n   struct basic_block_def *bb;\n \n-  /* [ WORD 4 ]\n+  /* [ WORD 4-5 ]\n+     Linked lists of gimple statements.  The next pointers form\n+     a NULL terminated list, the prev pointers are a cyclic list.\n+     A gimple statement is hence also a double-ended list of\n+     statements, with the pointer itself being the first element,\n+     and the prev pointer being the last.  */\n+  gimple next;\n+  gimple GTY((skip)) prev;\n+\n+  /* [ WORD 6 ]\n      Lexical block holding this statement.  */\n   tree block;\n };\n@@ -342,10 +225,10 @@ struct GTY(()) gimple_statement_base {\n \n struct GTY(()) gimple_statement_with_ops_base\n {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5-6 ]\n+  /* [ WORD 7-8 ]\n      SSA operand vectors.  NOTE: It should be possible to\n      amalgamate these vectors with the operand vector OP.  However,\n      the SSA operand vectors are organized differently and contain\n@@ -359,10 +242,10 @@ struct GTY(()) gimple_statement_with_ops_base\n \n struct GTY(()) gimple_statement_with_ops\n {\n-  /* [ WORD 1-6 ]  */\n+  /* [ WORD 1-8 ]  */\n   struct gimple_statement_with_ops_base opbase;\n \n-  /* [ WORD 7 ]\n+  /* [ WORD 9 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -374,10 +257,10 @@ struct GTY(()) gimple_statement_with_ops\n \n struct GTY(()) gimple_statement_with_memory_ops_base\n {\n-  /* [ WORD 1-6 ]  */\n+  /* [ WORD 1-8 ]  */\n   struct gimple_statement_with_ops_base opbase;\n \n-  /* [ WORD 7-8 ]\n+  /* [ WORD 9-10 ]\n      Virtual operands for this statement.  The GC will pick them\n      up via the ssa_names array.  */\n   tree GTY((skip (\"\"))) vdef;\n@@ -389,10 +272,10 @@ struct GTY(()) gimple_statement_with_memory_ops_base\n \n struct GTY(()) gimple_statement_with_memory_ops\n {\n-  /* [ WORD 1-8 ]  */\n+  /* [ WORD 1-10 ]  */\n   struct gimple_statement_with_memory_ops_base membase;\n \n-  /* [ WORD 9 ]\n+  /* [ WORD 11 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -404,20 +287,20 @@ struct GTY(()) gimple_statement_with_memory_ops\n \n struct GTY(()) gimple_statement_call\n {\n-  /* [ WORD 1-8 ]  */\n+  /* [ WORD 1-10 ]  */\n   struct gimple_statement_with_memory_ops_base membase;\n \n-  /* [ WORD 9-12 ]  */\n+  /* [ WORD 11-14 ]  */\n   struct pt_solution call_used;\n   struct pt_solution call_clobbered;\n \n-  /* [ WORD 13 ]  */\n+  /* [ WORD 15 ]  */\n   union GTY ((desc (\"%1.membase.opbase.gsbase.subcode & GF_CALL_INTERNAL\"))) {\n     tree GTY ((tag (\"0\"))) fntype;\n     enum internal_fn GTY ((tag (\"GF_CALL_INTERNAL\"))) internal_fn;\n   } u;\n \n-  /* [ WORD 14 ]\n+  /* [ WORD 16 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -428,100 +311,100 @@ struct GTY(()) gimple_statement_call\n /* OpenMP statements (#pragma omp).  */\n \n struct GTY(()) gimple_statement_omp {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]  */\n+  /* [ WORD 7 ]  */\n   gimple_seq body;\n };\n \n \n /* GIMPLE_BIND */\n \n struct GTY(()) gimple_statement_bind {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]\n+  /* [ WORD 7 ]\n      Variables declared in this scope.  */\n   tree vars;\n \n-  /* [ WORD 6 ]\n+  /* [ WORD 8 ]\n      This is different than the BLOCK field in gimple_statement_base,\n      which is analogous to TREE_BLOCK (i.e., the lexical block holding\n      this statement).  This field is the equivalent of BIND_EXPR_BLOCK\n      in tree land (i.e., the lexical scope defined by this bind).  See\n      gimple-low.c.  */\n   tree block;\n \n-  /* [ WORD 7 ]  */\n+  /* [ WORD 9 ]  */\n   gimple_seq body;\n };\n \n \n /* GIMPLE_CATCH */\n \n struct GTY(()) gimple_statement_catch {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]  */\n+  /* [ WORD 7 ]  */\n   tree types;\n \n-  /* [ WORD 6 ]  */\n+  /* [ WORD 8 ]  */\n   gimple_seq handler;\n };\n \n \n /* GIMPLE_EH_FILTER */\n \n struct GTY(()) gimple_statement_eh_filter {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]\n+  /* [ WORD 7 ]\n      Filter types.  */\n   tree types;\n \n-  /* [ WORD 6 ]\n+  /* [ WORD 8 ]\n      Failure actions.  */\n   gimple_seq failure;\n };\n \n /* GIMPLE_EH_ELSE */\n \n struct GTY(()) gimple_statement_eh_else {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5,6 ] */\n+  /* [ WORD 7,8 ] */\n   gimple_seq n_body, e_body;\n };\n \n /* GIMPLE_EH_MUST_NOT_THROW */\n \n struct GTY(()) gimple_statement_eh_mnt {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ] Abort function decl.  */\n+  /* [ WORD 7 ] Abort function decl.  */\n   tree fndecl;\n };\n \n /* GIMPLE_PHI */\n \n struct GTY(()) gimple_statement_phi {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]  */\n+  /* [ WORD 7 ]  */\n   unsigned capacity;\n   unsigned nargs;\n \n-  /* [ WORD 6 ]  */\n+  /* [ WORD 8 ]  */\n   tree result;\n \n-  /* [ WORD 7 ]  */\n+  /* [ WORD 9 ]  */\n   struct phi_arg_d GTY ((length (\"%h.nargs\"))) args[1];\n };\n \n@@ -530,10 +413,10 @@ struct GTY(()) gimple_statement_phi {\n \n struct GTY(()) gimple_statement_eh_ctrl\n {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]\n+  /* [ WORD 7 ]\n      Exception region number.  */\n   int region;\n };\n@@ -542,14 +425,14 @@ struct GTY(()) gimple_statement_eh_ctrl\n /* GIMPLE_TRY */\n \n struct GTY(()) gimple_statement_try {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]\n+  /* [ WORD 7 ]\n      Expression to evaluate.  */\n   gimple_seq eval;\n \n-  /* [ WORD 6 ]\n+  /* [ WORD 8 ]\n      Cleanup expression.  */\n   gimple_seq cleanup;\n };\n@@ -571,15 +454,15 @@ enum gimple_try_flags\n /* GIMPLE_WITH_CLEANUP_EXPR */\n \n struct GTY(()) gimple_statement_wce {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n   /* Subcode: CLEANUP_EH_ONLY.  True if the cleanup should only be\n \t      executed if an exception is thrown, not on normal exit of its\n \t      scope.  This flag is analogous to the CLEANUP_EH_ONLY flag\n \t      in TARGET_EXPRs.  */\n \n-  /* [ WORD 5 ]\n+  /* [ WORD 7 ]\n      Cleanup expression.  */\n   gimple_seq cleanup;\n };\n@@ -589,21 +472,21 @@ struct GTY(()) gimple_statement_wce {\n \n struct GTY(()) gimple_statement_asm\n {\n-  /* [ WORD 1-8 ]  */\n+  /* [ WORD 1-10 ]  */\n   struct gimple_statement_with_memory_ops_base membase;\n \n-  /* [ WORD 9 ]\n+  /* [ WORD 11 ]\n      __asm__ statement.  */\n   const char *string;\n \n-  /* [ WORD 10 ]\n+  /* [ WORD 12 ]\n        Number of inputs, outputs, clobbers, labels.  */\n   unsigned char ni;\n   unsigned char no;\n   unsigned char nc;\n   unsigned char nl;\n \n-  /* [ WORD 11 ]\n+  /* [ WORD 13 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -613,10 +496,10 @@ struct GTY(()) gimple_statement_asm\n /* GIMPLE_OMP_CRITICAL */\n \n struct GTY(()) gimple_statement_omp_critical {\n-  /* [ WORD 1-5 ]  */\n+  /* [ WORD 1-7 ]  */\n   struct gimple_statement_omp omp;\n \n-  /* [ WORD 6 ]\n+  /* [ WORD 8 ]\n      Critical section name.  */\n   tree name;\n };\n@@ -642,20 +525,20 @@ struct GTY(()) gimple_omp_for_iter {\n /* GIMPLE_OMP_FOR */\n \n struct GTY(()) gimple_statement_omp_for {\n-  /* [ WORD 1-5 ]  */\n+  /* [ WORD 1-7 ]  */\n   struct gimple_statement_omp omp;\n \n-  /* [ WORD 6 ]  */\n+  /* [ WORD 8 ]  */\n   tree clauses;\n \n-  /* [ WORD 7 ]\n+  /* [ WORD 9 ]\n      Number of elements in iter array.  */\n   size_t collapse;\n \n-  /* [ WORD 8 ]  */\n+  /* [ WORD 10 ]  */\n   struct gimple_omp_for_iter * GTY((length (\"%h.collapse\"))) iter;\n \n-  /* [ WORD 9 ]\n+  /* [ WORD 11 ]\n      Pre-body evaluated before the loop body begins.  */\n   gimple_seq pre_body;\n };\n@@ -664,18 +547,18 @@ struct GTY(()) gimple_statement_omp_for {\n /* GIMPLE_OMP_PARALLEL */\n \n struct GTY(()) gimple_statement_omp_parallel {\n-  /* [ WORD 1-5 ]  */\n+  /* [ WORD 1-7 ]  */\n   struct gimple_statement_omp omp;\n \n-  /* [ WORD 6 ]\n+  /* [ WORD 8 ]\n      Clauses.  */\n   tree clauses;\n \n-  /* [ WORD 7 ]\n+  /* [ WORD 9 ]\n      Child function holding the body of the parallel region.  */\n   tree child_fn;\n \n-  /* [ WORD 8 ]\n+  /* [ WORD 10 ]\n      Shared data argument.  */\n   tree data_arg;\n };\n@@ -684,14 +567,14 @@ struct GTY(()) gimple_statement_omp_parallel {\n /* GIMPLE_OMP_TASK */\n \n struct GTY(()) gimple_statement_omp_task {\n-  /* [ WORD 1-8 ]  */\n+  /* [ WORD 1-10 ]  */\n   struct gimple_statement_omp_parallel par;\n \n-  /* [ WORD 9 ]\n+  /* [ WORD 11 ]\n      Child function holding firstprivate initialization if needed.  */\n   tree copy_fn;\n \n-  /* [ WORD 10-11 ]\n+  /* [ WORD 12-13 ]\n      Size and alignment in bytes of the argument data block.  */\n   tree arg_size;\n   tree arg_align;\n@@ -705,13 +588,13 @@ struct GTY(()) gimple_statement_omp_task {\n /* GIMPLE_OMP_SECTIONS */\n \n struct GTY(()) gimple_statement_omp_sections {\n-  /* [ WORD 1-5 ]  */\n+  /* [ WORD 1-7 ]  */\n   struct gimple_statement_omp omp;\n \n-  /* [ WORD 6 ]  */\n+  /* [ WORD 8 ]  */\n   tree clauses;\n \n-  /* [ WORD 7 ]\n+  /* [ WORD 9 ]\n      The control variable used for deciding which of the sections to\n      execute.  */\n   tree control;\n@@ -723,23 +606,23 @@ struct GTY(()) gimple_statement_omp_sections {\n          do not need the body field.  */\n \n struct GTY(()) gimple_statement_omp_continue {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]  */\n+  /* [ WORD 7 ]  */\n   tree control_def;\n \n-  /* [ WORD 6 ]  */\n+  /* [ WORD 8 ]  */\n   tree control_use;\n };\n \n /* GIMPLE_OMP_SINGLE */\n \n struct GTY(()) gimple_statement_omp_single {\n-  /* [ WORD 1-5 ]  */\n+  /* [ WORD 1-7 ]  */\n   struct gimple_statement_omp omp;\n \n-  /* [ WORD 6 ]  */\n+  /* [ WORD 7 ]  */\n   tree clauses;\n };\n \n@@ -749,21 +632,21 @@ struct GTY(()) gimple_statement_omp_single {\n    contains a sequence, which we don't need here.  */\n \n struct GTY(()) gimple_statement_omp_atomic_load {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5-6 ]  */\n+  /* [ WORD 7-8 ]  */\n   tree rhs, lhs;\n };\n \n /* GIMPLE_OMP_ATOMIC_STORE.\n    See note on GIMPLE_OMP_ATOMIC_LOAD.  */\n \n struct GTY(()) gimple_statement_omp_atomic_store {\n-  /* [ WORD 1-4 ]  */\n+  /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 5 ]  */\n+  /* [ WORD 7 ]  */\n   tree val;\n };\n \n@@ -815,7 +698,8 @@ enum gimple_statement_structure_enum {\n /* Define the overall contents of a gimple tuple.  It may be any of the\n    structures declared above for various types of tuples.  */\n \n-union GTY ((desc (\"gimple_statement_structure (&%h)\"), variable_size)) gimple_statement_d {\n+union GTY ((desc (\"gimple_statement_structure (&%h)\"),\n+\t    chain_next (\"%h.gsbase.next\"), variable_size)) gimple_statement_d {\n   struct gimple_statement_base GTY ((tag (\"GSS_BASE\"))) gsbase;\n   struct gimple_statement_with_ops GTY ((tag (\"GSS_WITH_OPS\"))) gsops;\n   struct gimple_statement_with_memory_ops_base GTY ((tag (\"GSS_WITH_MEM_OPS_BASE\"))) gsmembase;\n@@ -1136,6 +1020,115 @@ extern tree tree_ssa_strip_useless_type_conversions (tree);\n extern bool useless_type_conversion_p (tree, tree);\n extern bool types_compatible_p (tree, tree);\n \n+/* Return the first node in GIMPLE sequence S.  */\n+\n+static inline gimple_seq_node\n+gimple_seq_first (const_gimple_seq s)\n+{\n+  return s;\n+}\n+\n+\n+/* Return the first statement in GIMPLE sequence S.  */\n+\n+static inline gimple\n+gimple_seq_first_stmt (const_gimple_seq s)\n+{\n+  gimple_seq_node n = gimple_seq_first (s);\n+  return n;\n+}\n+\n+\n+/* Return the last node in GIMPLE sequence S.  */\n+\n+static inline gimple_seq_node\n+gimple_seq_last (const_gimple_seq s)\n+{\n+  return s ? s->gsbase.prev : NULL;\n+}\n+\n+\n+/* Return the last statement in GIMPLE sequence S.  */\n+\n+static inline gimple\n+gimple_seq_last_stmt (const_gimple_seq s)\n+{\n+  gimple_seq_node n = gimple_seq_last (s);\n+  return n;\n+}\n+\n+\n+/* Set the last node in GIMPLE sequence *PS to LAST.  */\n+\n+static inline void\n+gimple_seq_set_last (gimple_seq *ps, gimple_seq_node last)\n+{\n+  (*ps)->gsbase.prev = last;\n+}\n+\n+\n+/* Set the first node in GIMPLE sequence *PS to FIRST.  */\n+\n+static inline void\n+gimple_seq_set_first (gimple_seq *ps, gimple_seq_node first)\n+{\n+  *ps = first;\n+}\n+\n+\n+/* Return true if GIMPLE sequence S is empty.  */\n+\n+static inline bool\n+gimple_seq_empty_p (const_gimple_seq s)\n+{\n+  return s == NULL;\n+}\n+\n+\n+void gimple_seq_add_stmt (gimple_seq *, gimple);\n+\n+/* Link gimple statement GS to the end of the sequence *SEQ_P.  If\n+   *SEQ_P is NULL, a new sequence is allocated.  This function is\n+   similar to gimple_seq_add_stmt, but does not scan the operands.\n+   During gimplification, we need to manipulate statement sequences\n+   before the def/use vectors have been constructed.  */\n+void gimple_seq_add_stmt_without_update (gimple_seq *, gimple);\n+\n+/* Allocate a new sequence and initialize its first element with STMT.  */\n+\n+static inline gimple_seq\n+gimple_seq_alloc_with_stmt (gimple stmt)\n+{\n+  gimple_seq seq = NULL;\n+  gimple_seq_add_stmt (&seq, stmt);\n+  return seq;\n+}\n+\n+\n+/* Returns the sequence of statements in BB.  */\n+\n+static inline gimple_seq\n+bb_seq (const_basic_block bb)\n+{\n+  return (!(bb->flags & BB_RTL) && bb->il.gimple) ? bb->il.gimple->seq : NULL;\n+}\n+\n+static inline gimple_seq *\n+bb_seq_addr (const_basic_block bb)\n+{\n+  return (!(bb->flags & BB_RTL) && bb->il.gimple) ? &bb->il.gimple->seq : NULL;\n+}\n+\n+/* Sets the sequence of statements in BB to SEQ.  */\n+\n+static inline void\n+set_bb_seq (basic_block bb, gimple_seq seq)\n+{\n+  gcc_checking_assert (!(bb->flags & BB_RTL));\n+  bb->il.gimple->seq = seq;\n+}\n+\n+\n /* Return the code for GIMPLE statement G.  */\n \n static inline enum gimple_code\n@@ -1358,6 +1351,16 @@ gimple_uid (const_gimple g)\n }\n \n \n+/* Make statement G a singleton sequence.  */\n+\n+static inline void\n+gimple_init_singleton (gimple g)\n+{\n+  g->gsbase.next = NULL;\n+  g->gsbase.prev = g;\n+}\n+\n+\n /* Return true if GIMPLE statement G has register or memory operands.  */\n \n static inline bool\n@@ -2819,13 +2822,19 @@ gimple_bind_append_vars (gimple gs, tree vars)\n }\n \n \n+static inline gimple_seq *\n+gimple_bind_body_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_BIND);\n+  return &gs->gimple_bind.body;\n+}\n+\n /* Return the GIMPLE sequence contained in the GIMPLE_BIND statement GS.  */\n \n static inline gimple_seq\n gimple_bind_body (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_BIND);\n-  return gs->gimple_bind.body;\n+  return *gimple_bind_body_ptr (gs);\n }\n \n \n@@ -3108,17 +3117,6 @@ gimple_catch_types_ptr (gimple gs)\n }\n \n \n-/* Return the GIMPLE sequence representing the body of the handler of\n-   GIMPLE_CATCH statement GS.  */\n-\n-static inline gimple_seq\n-gimple_catch_handler (gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CATCH);\n-  return gs->gimple_catch.handler;\n-}\n-\n-\n /* Return a pointer to the GIMPLE sequence representing the body of\n    the handler of GIMPLE_CATCH statement GS.  */\n \n@@ -3130,6 +3128,16 @@ gimple_catch_handler_ptr (gimple gs)\n }\n \n \n+/* Return the GIMPLE sequence representing the body of the handler of\n+   GIMPLE_CATCH statement GS.  */\n+\n+static inline gimple_seq\n+gimple_catch_handler (gimple gs)\n+{\n+  return *gimple_catch_handler_ptr (gs);\n+}\n+\n+\n /* Set T to be the set of types handled by GIMPLE_CATCH GS.  */\n \n static inline void\n@@ -3171,14 +3179,24 @@ gimple_eh_filter_types_ptr (gimple gs)\n }\n \n \n+/* Return a pointer to the sequence of statement to execute when\n+   GIMPLE_EH_FILTER statement fails.  */\n+\n+static inline gimple_seq *\n+gimple_eh_filter_failure_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_FILTER);\n+  return &gs->gimple_eh_filter.failure;\n+}\n+\n+\n /* Return the sequence of statement to execute when GIMPLE_EH_FILTER\n    statement fails.  */\n \n static inline gimple_seq\n gimple_eh_filter_failure (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_EH_FILTER);\n-  return gs->gimple_eh_filter.failure;\n+  return *gimple_eh_filter_failure_ptr (gs);\n }\n \n \n@@ -3222,18 +3240,30 @@ gimple_eh_must_not_throw_set_fndecl (gimple gs, tree decl)\n \n /* GIMPLE_EH_ELSE accessors.  */\n \n+static inline gimple_seq *\n+gimple_eh_else_n_body_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_ELSE);\n+  return &gs->gimple_eh_else.n_body;\n+}\n+\n static inline gimple_seq\n gimple_eh_else_n_body (gimple gs)\n+{\n+  return *gimple_eh_else_n_body_ptr (gs);\n+}\n+\n+static inline gimple_seq *\n+gimple_eh_else_e_body_ptr (gimple gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_EH_ELSE);\n-  return gs->gimple_eh_else.n_body;\n+  return &gs->gimple_eh_else.e_body;\n }\n \n static inline gimple_seq\n gimple_eh_else_e_body (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_EH_ELSE);\n-  return gs->gimple_eh_else.e_body;\n+  return *gimple_eh_else_e_body_ptr (gs);\n }\n \n static inline void\n@@ -3286,13 +3316,34 @@ gimple_try_catch_is_cleanup (const_gimple gs)\n }\n \n \n+/* Return a pointer to the sequence of statements used as the\n+   body for GIMPLE_TRY GS.  */\n+\n+static inline gimple_seq *\n+gimple_try_eval_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRY);\n+  return &gs->gimple_try.eval;\n+}\n+\n+\n /* Return the sequence of statements used as the body for GIMPLE_TRY GS.  */\n \n static inline gimple_seq\n gimple_try_eval (gimple gs)\n+{\n+  return *gimple_try_eval_ptr (gs);\n+}\n+\n+\n+/* Return a pointer to the sequence of statements used as the cleanup body for\n+   GIMPLE_TRY GS.  */\n+\n+static inline gimple_seq *\n+gimple_try_cleanup_ptr (gimple gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_TRY);\n-  return gs->gimple_try.eval;\n+  return &gs->gimple_try.cleanup;\n }\n \n \n@@ -3302,8 +3353,7 @@ gimple_try_eval (gimple gs)\n static inline gimple_seq\n gimple_try_cleanup (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_TRY);\n-  return gs->gimple_try.cleanup;\n+  return *gimple_try_cleanup_ptr (gs);\n }\n \n \n@@ -3342,13 +3392,22 @@ gimple_try_set_cleanup (gimple gs, gimple_seq cleanup)\n }\n \n \n+/* Return a pointer to the cleanup sequence for cleanup statement GS.  */\n+\n+static inline gimple_seq *\n+gimple_wce_cleanup_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_WITH_CLEANUP_EXPR);\n+  return &gs->gimple_wce.cleanup;\n+}\n+\n+\n /* Return the cleanup sequence for cleanup statement GS.  */\n \n static inline gimple_seq\n gimple_wce_cleanup (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_WITH_CLEANUP_EXPR);\n-  return gs->gimple_wce.cleanup;\n+  return *gimple_wce_cleanup_ptr (gs);\n }\n \n \n@@ -3747,12 +3806,20 @@ gimple_debug_source_bind_set_value (gimple dbg, tree value)\n   gimple_set_op (dbg, 1, value);\n }\n \n+/* Return a pointer to the body for the OMP statement GS.  */\n+\n+static inline gimple_seq *\n+gimple_omp_body_ptr (gimple gs)\n+{\n+  return &gs->omp.body;\n+}\n+\n /* Return the body for the OMP statement GS.  */\n \n static inline gimple_seq\n gimple_omp_body (gimple gs)\n {\n-  return gs->omp.body;\n+  return *gimple_omp_body_ptr (gs);\n }\n \n /* Set BODY to be the body for the OMP statement GS.  */\n@@ -3966,14 +4033,24 @@ gimple_omp_for_set_incr (gimple gs, size_t i, tree incr)\n }\n \n \n+/* Return a pointer to the sequence of statements to execute before the OMP_FOR\n+   statement GS starts.  */\n+\n+static inline gimple_seq *\n+gimple_omp_for_pre_body_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n+  return &gs->gimple_omp_for.pre_body;\n+}\n+\n+\n /* Return the sequence of statements to execute before the OMP_FOR\n    statement GS starts.  */\n \n static inline gimple_seq\n gimple_omp_for_pre_body (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  return gs->gimple_omp_for.pre_body;\n+  return *gimple_omp_for_pre_body_ptr (gs);\n }\n \n \n@@ -4627,13 +4704,21 @@ gimple_omp_continue_set_control_use (gimple g, tree use)\n   g->gimple_omp_continue.control_use = use;\n }\n \n+/* Return a pointer to the body for the GIMPLE_TRANSACTION statement GS.  */\n+\n+static inline gimple_seq *\n+gimple_transaction_body_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  return &gs->gimple_transaction.body;\n+}\n+\n /* Return the body for the GIMPLE_TRANSACTION statement GS.  */\n \n static inline gimple_seq\n gimple_transaction_body (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n-  return gs->gimple_transaction.body;\n+  return *gimple_transaction_body_ptr (gs);\n }\n \n /* Return the label associated with a GIMPLE_TRANSACTION.  */\n@@ -4858,30 +4943,52 @@ is_gimple_reg_type (tree type)\n /* Return a new iterator pointing to GIMPLE_SEQ's first statement.  */\n \n static inline gimple_stmt_iterator\n-gsi_start (gimple_seq seq)\n+gsi_start_1 (gimple_seq *seq)\n {\n   gimple_stmt_iterator i;\n \n-  i.ptr = gimple_seq_first (seq);\n+  i.ptr = gimple_seq_first (*seq);\n   i.seq = seq;\n-  i.bb = (i.ptr && i.ptr->stmt) ? gimple_bb (i.ptr->stmt) : NULL;\n+  i.bb = i.ptr ? gimple_bb (i.ptr) : NULL;\n \n   return i;\n }\n \n+#define gsi_start(x) gsi_start_1(&(x))\n+\n+static inline gimple_stmt_iterator\n+gsi_none (void)\n+{\n+  gimple_stmt_iterator i;\n+  i.ptr = NULL;\n+  i.seq = NULL;\n+  i.bb = NULL;\n+  return i;\n+}\n \n /* Return a new iterator pointing to the first statement in basic block BB.  */\n \n static inline gimple_stmt_iterator\n gsi_start_bb (basic_block bb)\n {\n   gimple_stmt_iterator i;\n-  gimple_seq seq;\n+  gimple_seq *seq;\n \n-  seq = bb_seq (bb);\n-  i.ptr = gimple_seq_first (seq);\n-  i.seq = seq;\n-  i.bb = bb;\n+  seq = bb_seq_addr (bb);\n+  if (!seq)\n+    /* XXX Only necessary because of ENTRY/EXIT block which don't have\n+       il.gimple */\n+    {\n+      i.ptr = NULL;\n+      i.seq = NULL;\n+      i.bb = NULL;\n+    }\n+  else\n+    {\n+      i.ptr = gimple_seq_first (*seq);\n+      i.seq = seq;\n+      i.bb = bb;\n+    }\n \n   return i;\n }\n@@ -4890,30 +4997,42 @@ gsi_start_bb (basic_block bb)\n /* Return a new iterator initially pointing to GIMPLE_SEQ's last statement.  */\n \n static inline gimple_stmt_iterator\n-gsi_last (gimple_seq seq)\n+gsi_last_1 (gimple_seq *seq)\n {\n   gimple_stmt_iterator i;\n \n-  i.ptr = gimple_seq_last (seq);\n+  i.ptr = gimple_seq_last (*seq);\n   i.seq = seq;\n-  i.bb = (i.ptr && i.ptr->stmt) ? gimple_bb (i.ptr->stmt) : NULL;\n+  i.bb = i.ptr ? gimple_bb (i.ptr) : NULL;\n \n   return i;\n }\n \n+#define gsi_last(x) gsi_last_1(&(x))\n \n /* Return a new iterator pointing to the last statement in basic block BB.  */\n \n static inline gimple_stmt_iterator\n gsi_last_bb (basic_block bb)\n {\n   gimple_stmt_iterator i;\n-  gimple_seq seq;\n+  gimple_seq *seq;\n \n-  seq = bb_seq (bb);\n-  i.ptr = gimple_seq_last (seq);\n-  i.seq = seq;\n-  i.bb = bb;\n+  seq = bb_seq_addr (bb);\n+  if (!seq)\n+    /* XXX Only necessary because of ENTRY/EXIT block which don't have\n+       il.gimple */\n+    {\n+      i.ptr = NULL;\n+      i.seq = NULL;\n+      i.bb = NULL;\n+    }\n+  else\n+    {\n+      i.ptr = gimple_seq_last (*seq);\n+      i.seq = seq;\n+      i.bb = bb;\n+    }\n \n   return i;\n }\n@@ -4933,7 +5052,7 @@ gsi_end_p (gimple_stmt_iterator i)\n static inline bool\n gsi_one_before_end_p (gimple_stmt_iterator i)\n {\n-  return i.ptr != NULL && i.ptr->next == NULL;\n+  return i.ptr != NULL && i.ptr->gsbase.next == NULL;\n }\n \n \n@@ -4942,23 +5061,27 @@ gsi_one_before_end_p (gimple_stmt_iterator i)\n static inline void\n gsi_next (gimple_stmt_iterator *i)\n {\n-  i->ptr = i->ptr->next;\n+  i->ptr = i->ptr->gsbase.next;\n }\n \n /* Advance the iterator to the previous gimple statement.  */\n \n static inline void\n gsi_prev (gimple_stmt_iterator *i)\n {\n-  i->ptr = i->ptr->prev;\n+  gimple prev = i->ptr->gsbase.prev;\n+  if (prev->gsbase.next)\n+    i->ptr = prev;\n+  else\n+    i->ptr = NULL;\n }\n \n /* Return the current stmt.  */\n \n static inline gimple\n gsi_stmt (gimple_stmt_iterator i)\n {\n-  return i.ptr->stmt;\n+  return i.ptr;\n }\n \n /* Return a block statement iterator that points to the first non-label\n@@ -5027,18 +5150,6 @@ gsi_last_nondebug_bb (basic_block bb)\n   return i;\n }\n \n-/* Return a pointer to the current stmt.\n-\n-  NOTE: You may want to use gsi_replace on the iterator itself,\n-  as this performs additional bookkeeping that will not be done\n-  if you simply assign through a pointer returned by gsi_stmt_ptr.  */\n-\n-static inline gimple *\n-gsi_stmt_ptr (gimple_stmt_iterator *i)\n-{\n-  return &i->ptr->stmt;\n-}\n-\n \n /* Return the basic block associated with this iterator.  */\n \n@@ -5054,7 +5165,7 @@ gsi_bb (gimple_stmt_iterator i)\n static inline gimple_seq\n gsi_seq (gimple_stmt_iterator i)\n {\n-  return i.seq;\n+  return *i.seq;\n }\n \n \n@@ -5071,8 +5182,10 @@ enum gsi_iterator_update\n /* In gimple-iterator.c  */\n gimple_stmt_iterator gsi_start_phis (basic_block);\n gimple_seq gsi_split_seq_after (gimple_stmt_iterator);\n-gimple_seq gsi_split_seq_before (gimple_stmt_iterator *);\n+void gsi_split_seq_before (gimple_stmt_iterator *, gimple_seq *);\n+void gsi_set_stmt (gimple_stmt_iterator *, gimple);\n void gsi_replace (gimple_stmt_iterator *, gimple, bool);\n+void gsi_replace_with_seq (gimple_stmt_iterator *, gimple_seq, bool);\n void gsi_insert_before (gimple_stmt_iterator *, gimple,\n \t\t\tenum gsi_iterator_update);\n void gsi_insert_before_without_update (gimple_stmt_iterator *, gimple,\n@@ -5167,6 +5280,8 @@ typedef tree (*walk_stmt_fn) (gimple_stmt_iterator *, bool *,\n \n gimple walk_gimple_seq (gimple_seq, walk_stmt_fn, walk_tree_fn,\n \t\t        struct walk_stmt_info *);\n+gimple walk_gimple_seq_mod (gimple_seq *, walk_stmt_fn, walk_tree_fn,\n+\t\t\t    struct walk_stmt_info *);\n tree walk_gimple_stmt (gimple_stmt_iterator *, walk_stmt_fn, walk_tree_fn,\n \t\t       struct walk_stmt_info *);\n tree walk_gimple_op (gimple, walk_tree_fn, struct walk_stmt_info *);\n@@ -5179,7 +5294,6 @@ enum gimple_alloc_kind\n   gimple_alloc_kind_assign,\t/* Assignments.  */\n   gimple_alloc_kind_phi,\t/* PHI nodes.  */\n   gimple_alloc_kind_cond,\t/* Conditionals.  */\n-  gimple_alloc_kind_seq,\t/* Sequences.  */\n   gimple_alloc_kind_rest,\t/* Everything else.  */\n   gimple_alloc_kind_all\n };"}, {"sha": "d7cbc2489a1b00139f415cdae873892e6101d8f0", "filename": "gcc/gimplify.c", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -169,11 +169,7 @@ gimple_seq_add_stmt_without_update (gimple_seq *seq_p, gimple gs)\n   if (gs == NULL)\n     return;\n \n-  if (*seq_p == NULL)\n-    *seq_p = gimple_seq_alloc ();\n-\n   si = gsi_last (*seq_p);\n-\n   gsi_insert_after_without_update (&si, gs, GSI_NEW_STMT);\n }\n \n@@ -200,9 +196,6 @@ gimplify_seq_add_seq (gimple_seq *dst_p, gimple_seq src)\n   if (src == NULL)\n     return;\n \n-  if (*dst_p == NULL)\n-    *dst_p = gimple_seq_alloc ();\n-\n   si = gsi_last (*dst_p);\n   gsi_insert_seq_after_without_update (&si, src, GSI_NEW_STMT);\n }\n@@ -5467,8 +5460,8 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n \t      gtry = gimple_build_try (seq, gimple_wce_cleanup (wce), kind);\n               /* Do not use gsi_replace here, as it may scan operands.\n                  We want to do a simple structural modification only.  */\n-              *gsi_stmt_ptr (&iter) = gtry;\n-\t      iter = gsi_start (seq);\n+\t      gsi_set_stmt (&iter, gtry);\n+\t      iter = gsi_start (gtry->gimple_try.eval);\n \t    }\n \t}\n       else\n@@ -5650,9 +5643,6 @@ gimplify_stmt (tree *stmt_p, gimple_seq *seq_p)\n {\n   gimple_seq_node last;\n \n-  if (!*seq_p)\n-    *seq_p = gimple_seq_alloc ();\n-\n   last = gimple_seq_last (*seq_p);\n   gimplify_expr (stmt_p, seq_p, NULL, is_gimple_stmt, fb_none);\n   return last != gimple_seq_last (*seq_p);\n@@ -6149,8 +6139,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      gimplify_omp_ctxp = ctx;\n \t      push_gimplify_context (&gctx);\n \n-\t      OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = gimple_seq_alloc ();\n-\t      OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = gimple_seq_alloc ();\n+\t      OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n+\t      OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n \n \t      gimplify_and_add (OMP_CLAUSE_REDUCTION_INIT (c),\n \t\t  \t\t&OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c));\n@@ -6486,7 +6476,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   gimplify_and_add (OMP_FOR_PRE_BODY (for_stmt), &for_pre_body);\n   OMP_FOR_PRE_BODY (for_stmt) = NULL_TREE;\n \n-  for_body = gimple_seq_alloc ();\n+  for_body = NULL;\n   gcc_assert (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n \t      == TREE_VEC_LENGTH (OMP_FOR_COND (for_stmt)));\n   gcc_assert (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n@@ -8322,7 +8312,7 @@ gimplify_function_tree (tree fndecl)\n \n   /* The tree body of the function is no longer needed, replace it\n      with the new GIMPLE body.  */\n-  seq = gimple_seq_alloc ();\n+  seq = NULL;\n   gimple_seq_add_stmt (&seq, bind);\n   gimple_set_body (fndecl, seq);\n \n@@ -8371,7 +8361,7 @@ gimplify_function_tree (tree fndecl)\n \n       /* Replace the current function body with the body\n          wrapped in the try/finally TF.  */\n-      seq = gimple_seq_alloc ();\n+      seq = NULL;\n       gimple_seq_add_stmt (&seq, new_bind);\n       gimple_set_body (fndecl, seq);\n     }"}, {"sha": "cdabd738dc65c7e088d2442bf86ec8828c0d854c", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -87,8 +87,7 @@ remove_invariant_phi (sese region, gimple_stmt_iterator *psi)\n   edge e = gimple_phi_arg_edge (phi, entry);\n   tree var;\n   gimple stmt;\n-  gimple_seq stmts;\n-  gimple_stmt_iterator gsi;\n+  gimple_seq stmts = NULL;\n \n   if (tree_contains_chrecs (scev, NULL))\n     scev = gimple_phi_arg_def (phi, entry);\n@@ -97,11 +96,7 @@ remove_invariant_phi (sese region, gimple_stmt_iterator *psi)\n   stmt = gimple_build_assign (res, var);\n   remove_phi_node (psi, false);\n \n-  if (!stmts)\n-    stmts = gimple_seq_alloc ();\n-\n-  gsi = gsi_last (stmts);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  gimple_seq_add_stmt (&stmts, stmt);\n   gsi_insert_seq_on_edge (e, stmts);\n   gsi_commit_edge_inserts ();\n   SSA_NAME_DEF_STMT (res) = stmt;\n@@ -2088,11 +2083,7 @@ insert_stmts (scop_p scop, gimple stmt, gimple_seq stmts,\n   gimple_stmt_iterator gsi;\n   VEC (gimple, heap) *x = VEC_alloc (gimple, heap, 3);\n \n-  if (!stmts)\n-    stmts = gimple_seq_alloc ();\n-\n-  gsi = gsi_last (stmts);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  gimple_seq_add_stmt (&stmts, stmt);\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n     VEC_safe_push (gimple, heap, x, gsi_stmt (gsi));\n \n@@ -2107,16 +2098,12 @@ static void\n insert_out_of_ssa_copy (scop_p scop, tree res, tree expr, gimple after_stmt)\n {\n   gimple_seq stmts;\n-  gimple_stmt_iterator si;\n   gimple_stmt_iterator gsi;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gimple stmt = gimple_build_assign (res, var);\n   VEC (gimple, heap) *x = VEC_alloc (gimple, heap, 3);\n \n-  if (!stmts)\n-    stmts = gimple_seq_alloc ();\n-  si = gsi_last (stmts);\n-  gsi_insert_after (&si, stmt, GSI_NEW_STMT);\n+  gimple_seq_add_stmt (&stmts, stmt);\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n     VEC_safe_push (gimple, heap, x, gsi_stmt (gsi));\n \n@@ -2167,17 +2154,13 @@ static void\n insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n {\n   gimple_stmt_iterator gsi;\n-  gimple_seq stmts;\n+  gimple_seq stmts = NULL;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gimple stmt = gimple_build_assign (res, var);\n   basic_block bb;\n   VEC (gimple, heap) *x = VEC_alloc (gimple, heap, 3);\n \n-  if (!stmts)\n-    stmts = gimple_seq_alloc ();\n-\n-  gsi = gsi_last (stmts);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  gimple_seq_add_stmt (&stmts, stmt);\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n     VEC_safe_push (gimple, heap, x, gsi_stmt (gsi));\n "}, {"sha": "17a431c05bd4c62e7c6c6a0a619f366af0de4f84", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -1626,7 +1626,7 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n \t\t\t\t\t visit_ref_for_mod_analysis,\n \t\t\t\t\t visit_ref_for_mod_analysis);\n \t}\n-      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), info,\n \t\t\t\t       visit_ref_for_mod_analysis,\n \t\t\t\t       visit_ref_for_mod_analysis,"}, {"sha": "394c3d7093936afa6490dcfeebf77896db1fbd9b", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -602,7 +602,7 @@ make_new_block (struct function *fn, unsigned int index)\n   bb->il.gimple = ggc_alloc_cleared_gimple_bb_info ();\n   n_basic_blocks_for_function (fn)++;\n   bb->flags = 0;\n-  set_bb_seq (bb, gimple_seq_alloc ());\n+  set_bb_seq (bb, NULL);\n   return bb;\n }\n "}, {"sha": "21a5188d214bca279d92f6cdd66f12059150f199", "filename": "gcc/omp-low.c", "status": "modified", "additions": 67, "deletions": 74, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -158,7 +158,7 @@ scan_omp_op (tree *tp, omp_context *ctx)\n   return walk_tree (tp, scan_omp_1_op, &wi, NULL);\n }\n \n-static void lower_omp (gimple_seq, omp_context *);\n+static void lower_omp (gimple_seq *, omp_context *);\n static tree lookup_decl_in_outer_ctx (tree, omp_context *);\n static tree maybe_lookup_decl_in_outer_ctx (tree, omp_context *);\n \n@@ -1233,7 +1233,7 @@ finalize_task_copyfn (gimple task_stmt)\n {\n   struct function *child_cfun;\n   tree child_fn, old_fn;\n-  gimple_seq seq, new_seq;\n+  gimple_seq seq = NULL, new_seq;\n   gimple bind;\n \n   child_fn = gimple_omp_task_copy_fn (task_stmt);\n@@ -1250,13 +1250,12 @@ finalize_task_copyfn (gimple task_stmt)\n   push_cfun (child_cfun);\n   current_function_decl = child_fn;\n   bind = gimplify_body (child_fn, false);\n-  seq = gimple_seq_alloc ();\n   gimple_seq_add_stmt (&seq, bind);\n   new_seq = maybe_catch_exception (seq);\n   if (new_seq != seq)\n     {\n       bind = gimple_build_bind (NULL, new_seq, NULL);\n-      seq = gimple_seq_alloc ();\n+      seq = NULL;\n       gimple_seq_add_stmt (&seq, bind);\n     }\n   gimple_set_body (child_fn, seq);\n@@ -2231,14 +2230,11 @@ static void\n lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t omp_context *ctx)\n {\n-  gimple_stmt_iterator diter;\n   tree c, dtor, copyin_seq, x, ptr;\n   bool copyin_by_ref = false;\n   bool lastprivate_firstprivate = false;\n   int pass;\n \n-  *dlist = gimple_seq_alloc ();\n-  diter = gsi_start (*dlist);\n   copyin_seq = NULL;\n \n   /* Do all the fixed sized types in the first pass, and the variable sized\n@@ -2427,7 +2423,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t  dtor = x;\n \t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t  gsi_insert_seq_before (&diter, tseq, GSI_SAME_STMT);\n+\t\t  gimple_seq_add_seq (dlist, tseq);\n \t\t}\n \t      break;\n \n@@ -2470,7 +2466,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t  SET_DECL_VALUE_EXPR (placeholder, x);\n \t\t  DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n-\t\t  lower_omp (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c), ctx);\n+\t\t  lower_omp (&OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c), ctx);\n \t\t  gimple_seq_add_seq (ilist,\n \t\t\t\t      OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c));\n \t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n@@ -2574,7 +2570,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \n \t  if (OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c))\n \t    {\n-\t      lower_omp (OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c), ctx);\n+\t      lower_omp (&OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c), ctx);\n \t      gimple_seq_add_seq (stmt_list,\n \t\t\t\t  OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c));\n \t    }\n@@ -2678,7 +2674,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t    ref = build_fold_addr_expr_loc (clause_loc, ref);\n \t  SET_DECL_VALUE_EXPR (placeholder, ref);\n \t  DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n-\t  lower_omp (OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c), ctx);\n+\t  lower_omp (&OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c), ctx);\n \t  gimple_seq_add_seq (&sub_seq, OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c));\n \t  OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n \t  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = NULL;\n@@ -3501,7 +3497,8 @@ expand_omp_taskreg (struct omp_region *region)\n \t    && !DECL_EXTERNAL (t))\n \t  varpool_finalize_decl (t);\n       DECL_SAVED_TREE (child_fn) = NULL;\n-      gimple_set_body (child_fn, bb_seq (single_succ (entry_bb)));\n+      /* We'll create a CFG for child_fn, so no gimple body is needed.  */\n+      gimple_set_body (child_fn, NULL);\n       TREE_USED (block) = 1;\n \n       /* Reset DECL_CONTEXT on function arguments.  */\n@@ -5789,9 +5786,8 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block, control;\n   gimple_stmt_iterator tgsi;\n-  unsigned i, len;\n   gimple stmt, new_stmt, bind, t;\n-  gimple_seq ilist, dlist, olist, new_body, body;\n+  gimple_seq ilist, dlist, olist, new_body;\n   struct gimplify_ctx gctx;\n \n   stmt = gsi_stmt (*gsi_p);\n@@ -5803,13 +5799,10 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   lower_rec_input_clauses (gimple_omp_sections_clauses (stmt),\n       \t\t\t   &ilist, &dlist, ctx);\n \n-  tgsi = gsi_start (gimple_omp_body (stmt));\n-  for (len = 0; !gsi_end_p (tgsi); len++, gsi_next (&tgsi))\n-    continue;\n-\n-  tgsi = gsi_start (gimple_omp_body (stmt));\n-  body = NULL;\n-  for (i = 0; i < len; i++, gsi_next (&tgsi))\n+  new_body = gimple_omp_body (stmt);\n+  gimple_omp_set_body (stmt, NULL);\n+  tgsi = gsi_start (new_body);\n+  for (; !gsi_end_p (tgsi); gsi_next (&tgsi))\n     {\n       omp_context *sctx;\n       gimple sec_start;\n@@ -5818,32 +5811,33 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       sctx = maybe_lookup_ctx (sec_start);\n       gcc_assert (sctx);\n \n-      gimple_seq_add_stmt (&body, sec_start);\n-\n-      lower_omp (gimple_omp_body (sec_start), sctx);\n-      gimple_seq_add_seq (&body, gimple_omp_body (sec_start));\n+      lower_omp (gimple_omp_body_ptr (sec_start), sctx);\n+      gsi_insert_seq_after (&tgsi, gimple_omp_body (sec_start),\n+\t\t\t    GSI_CONTINUE_LINKING);\n       gimple_omp_set_body (sec_start, NULL);\n \n-      if (i == len - 1)\n+      if (gsi_one_before_end_p (tgsi))\n \t{\n \t  gimple_seq l = NULL;\n \t  lower_lastprivate_clauses (gimple_omp_sections_clauses (stmt), NULL,\n \t\t\t\t     &l, ctx);\n-\t  gimple_seq_add_seq (&body, l);\n+\t  gsi_insert_seq_after (&tgsi, l, GSI_CONTINUE_LINKING);\n \t  gimple_omp_section_set_last (sec_start);\n \t}\n \n-      gimple_seq_add_stmt (&body, gimple_build_omp_return (false));\n+      gsi_insert_after (&tgsi, gimple_build_omp_return (false),\n+\t\t\tGSI_CONTINUE_LINKING);\n     }\n \n   block = make_node (BLOCK);\n-  bind = gimple_build_bind (NULL, body, block);\n+  bind = gimple_build_bind (NULL, new_body, block);\n \n   olist = NULL;\n   lower_reduction_clauses (gimple_omp_sections_clauses (stmt), &olist, ctx);\n \n   block = make_node (BLOCK);\n   new_stmt = gimple_build_bind (NULL, NULL, block);\n+  gsi_replace (gsi_p, new_stmt, true);\n \n   pop_gimplify_context (new_stmt);\n   gimple_bind_append_vars (new_stmt, ctx->block_vars);\n@@ -5873,9 +5867,6 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_seq_add_stmt (&new_body, t);\n \n   gimple_bind_set_body (new_stmt, new_body);\n-  gimple_omp_set_body (stmt, NULL);\n-\n-  gsi_replace (gsi_p, new_stmt, true);\n }\n \n \n@@ -6008,10 +5999,14 @@ lower_omp_single (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   push_gimplify_context (&gctx);\n \n+  block = make_node (BLOCK);\n+  bind = gimple_build_bind (NULL, NULL, block);\n+  gsi_replace (gsi_p, bind, true);\n   bind_body = NULL;\n+  dlist = NULL;\n   lower_rec_input_clauses (gimple_omp_single_clauses (single_stmt),\n \t\t\t   &bind_body, &dlist, ctx);\n-  lower_omp (gimple_omp_body (single_stmt), ctx);\n+  lower_omp (gimple_omp_body_ptr (single_stmt), ctx);\n \n   gimple_seq_add_stmt (&bind_body, single_stmt);\n \n@@ -6030,15 +6025,12 @@ lower_omp_single (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n         (!!find_omp_clause (gimple_omp_single_clauses (single_stmt),\n \t\t\t    OMP_CLAUSE_NOWAIT));\n   gimple_seq_add_stmt (&bind_body, t);\n-\n-  block = make_node (BLOCK);\n-  bind = gimple_build_bind (NULL, bind_body, block);\n+  gimple_bind_set_body (bind, bind_body);\n \n   pop_gimplify_context (bind);\n \n   gimple_bind_append_vars (bind, ctx->block_vars);\n   BLOCK_VARS (block) = ctx->block_vars;\n-  gsi_replace (gsi_p, bind, true);\n   if (BLOCK_VARS (block))\n     TREE_USED (block) = 1;\n }\n@@ -6058,8 +6050,9 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   push_gimplify_context (&gctx);\n \n   block = make_node (BLOCK);\n-  bind = gimple_build_bind (NULL, gimple_seq_alloc_with_stmt (stmt),\n-      \t\t\t\t block);\n+  bind = gimple_build_bind (NULL, NULL, block);\n+  gsi_replace (gsi_p, bind, true);\n+  gimple_bind_add_stmt (bind, stmt);\n \n   bfn_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n   x = build_call_expr_loc (loc, bfn_decl, 0);\n@@ -6069,7 +6062,7 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimplify_and_add (x, &tseq);\n   gimple_bind_add_seq (bind, tseq);\n \n-  lower_omp (gimple_omp_body (stmt), ctx);\n+  lower_omp (gimple_omp_body_ptr (stmt), ctx);\n   gimple_omp_set_body (stmt, maybe_catch_exception (gimple_omp_body (stmt)));\n   gimple_bind_add_seq (bind, gimple_omp_body (stmt));\n   gimple_omp_set_body (stmt, NULL);\n@@ -6082,7 +6075,6 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   gimple_bind_append_vars (bind, ctx->block_vars);\n   BLOCK_VARS (block) = ctx->block_vars;\n-  gsi_replace (gsi_p, bind, true);\n }\n \n \n@@ -6098,14 +6090,15 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   push_gimplify_context (&gctx);\n \n   block = make_node (BLOCK);\n-  bind = gimple_build_bind (NULL, gimple_seq_alloc_with_stmt (stmt),\n-      \t\t\t\t   block);\n+  bind = gimple_build_bind (NULL, NULL, block);\n+  gsi_replace (gsi_p, bind, true);\n+  gimple_bind_add_stmt (bind, stmt);\n \n   x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_START),\n \t\t\t 0);\n   gimple_bind_add_stmt (bind, x);\n \n-  lower_omp (gimple_omp_body (stmt), ctx);\n+  lower_omp (gimple_omp_body_ptr (stmt), ctx);\n   gimple_omp_set_body (stmt, maybe_catch_exception (gimple_omp_body (stmt)));\n   gimple_bind_add_seq (bind, gimple_omp_body (stmt));\n   gimple_omp_set_body (stmt, NULL);\n@@ -6119,7 +6112,6 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   gimple_bind_append_vars (bind, ctx->block_vars);\n   BLOCK_VARS (block) = gimple_bind_vars (bind);\n-  gsi_replace (gsi_p, bind, true);\n }\n \n \n@@ -6195,13 +6187,15 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   push_gimplify_context (&gctx);\n \n   block = make_node (BLOCK);\n-  bind = gimple_build_bind (NULL, gimple_seq_alloc_with_stmt (stmt), block);\n+  bind = gimple_build_bind (NULL, NULL, block);\n+  gsi_replace (gsi_p, bind, true);\n+  gimple_bind_add_stmt (bind, stmt);\n \n   tbody = gimple_bind_body (bind);\n   gimplify_and_add (lock, &tbody);\n   gimple_bind_set_body (bind, tbody);\n \n-  lower_omp (gimple_omp_body (stmt), ctx);\n+  lower_omp (gimple_omp_body_ptr (stmt), ctx);\n   gimple_omp_set_body (stmt, maybe_catch_exception (gimple_omp_body (stmt)));\n   gimple_bind_add_seq (bind, gimple_omp_body (stmt));\n   gimple_omp_set_body (stmt, NULL);\n@@ -6215,7 +6209,6 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   pop_gimplify_context (bind);\n   gimple_bind_append_vars (bind, ctx->block_vars);\n   BLOCK_VARS (block) = gimple_bind_vars (bind);\n-  gsi_replace (gsi_p, bind, true);\n }\n \n \n@@ -6283,11 +6276,15 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   push_gimplify_context (&gctx);\n \n-  lower_omp (gimple_omp_for_pre_body (stmt), ctx);\n-  lower_omp (gimple_omp_body (stmt), ctx);\n+  lower_omp (gimple_omp_for_pre_body_ptr (stmt), ctx);\n+  lower_omp (gimple_omp_body_ptr (stmt), ctx);\n \n   block = make_node (BLOCK);\n   new_stmt = gimple_build_bind (NULL, NULL, block);\n+  /* Replace at gsi right away, so that 'stmt' is no member\n+     of a sequence anymore as we're going to add to to a different\n+     one below.  */\n+  gsi_replace (gsi_p, new_stmt, true);\n \n   /* Move declaration of temporaries in the loop body before we make\n      it go away.  */\n@@ -6357,7 +6354,6 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_bind_set_body (new_stmt, body);\n   gimple_omp_set_body (stmt, NULL);\n   gimple_omp_for_set_pre_body (stmt, NULL);\n-  gsi_replace (gsi_p, new_stmt, true);\n }\n \n /* Callback for walk_stmts.  Check if the current statement only contains\n@@ -6710,7 +6706,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   par_olist = NULL;\n   par_ilist = NULL;\n   lower_rec_input_clauses (clauses, &par_ilist, &par_olist, ctx);\n-  lower_omp (par_body, ctx);\n+  lower_omp (&par_body, ctx);\n   if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL)\n     lower_reduction_clauses (clauses, &par_olist, ctx);\n \n@@ -6756,15 +6752,10 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_omp_set_body (stmt, new_body);\n \n   bind = gimple_build_bind (NULL, NULL, gimple_bind_block (par_bind));\n-  gimple_bind_add_stmt (bind, stmt);\n-  if (ilist || olist)\n-    {\n-      gimple_seq_add_stmt (&ilist, bind);\n-      gimple_seq_add_seq (&ilist, olist);\n-      bind = gimple_build_bind (NULL, ilist, NULL);\n-    }\n-\n   gsi_replace (gsi_p, bind, true);\n+  gimple_bind_add_seq (bind, ilist);\n+  gimple_bind_add_stmt (bind, stmt);\n+  gimple_bind_add_seq (bind, olist);\n \n   pop_gimplify_context (NULL);\n }\n@@ -6829,17 +6820,17 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \tgimple_regimplify_operands (stmt, gsi_p);\n       break;\n     case GIMPLE_CATCH:\n-      lower_omp (gimple_catch_handler (stmt), ctx);\n+      lower_omp (gimple_catch_handler_ptr (stmt), ctx);\n       break;\n     case GIMPLE_EH_FILTER:\n-      lower_omp (gimple_eh_filter_failure (stmt), ctx);\n+      lower_omp (gimple_eh_filter_failure_ptr (stmt), ctx);\n       break;\n     case GIMPLE_TRY:\n-      lower_omp (gimple_try_eval (stmt), ctx);\n-      lower_omp (gimple_try_cleanup (stmt), ctx);\n+      lower_omp (gimple_try_eval_ptr (stmt), ctx);\n+      lower_omp (gimple_try_cleanup_ptr (stmt), ctx);\n       break;\n     case GIMPLE_BIND:\n-      lower_omp (gimple_bind_body (stmt), ctx);\n+      lower_omp (gimple_bind_body_ptr (stmt), ctx);\n       break;\n     case GIMPLE_OMP_PARALLEL:\n     case GIMPLE_OMP_TASK:\n@@ -6892,11 +6883,11 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n }\n \n static void\n-lower_omp (gimple_seq body, omp_context *ctx)\n+lower_omp (gimple_seq *body, omp_context *ctx)\n {\n   location_t saved_location = input_location;\n-  gimple_stmt_iterator gsi = gsi_start (body);\n-  for (gsi = gsi_start (body); !gsi_end_p (gsi); gsi_next (&gsi))\n+  gimple_stmt_iterator gsi;\n+  for (gsi = gsi_start (*body); !gsi_end_p (gsi); gsi_next (&gsi))\n     lower_omp_1 (&gsi, ctx);\n   input_location = saved_location;\n }\n@@ -6926,7 +6917,7 @@ execute_lower_omp (void)\n \n       if (task_shared_vars)\n \tpush_gimplify_context (&gctx);\n-      lower_omp (body, NULL);\n+      lower_omp (&body, NULL);\n       if (task_shared_vars)\n \tpop_gimplify_context (NULL);\n     }\n@@ -7104,17 +7095,17 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_CRITICAL:\n       wi->info = stmt;\n-      walk_gimple_seq (gimple_omp_body (stmt), diagnose_sb_2, NULL, wi);\n+      walk_gimple_seq_mod (gimple_omp_body_ptr (stmt), diagnose_sb_2, NULL, wi);\n       wi->info = context;\n       break;\n \n     case GIMPLE_OMP_FOR:\n       wi->info = stmt;\n       /* gimple_omp_for_{index,initial,final} are all DECLs; no need to\n \t walk them.  */\n-      walk_gimple_seq (gimple_omp_for_pre_body (stmt),\n-\t  \t       diagnose_sb_2, NULL, wi);\n-      walk_gimple_seq (gimple_omp_body (stmt), diagnose_sb_2, NULL, wi);\n+      walk_gimple_seq_mod (gimple_omp_for_pre_body_ptr (stmt),\n+\t\t\t   diagnose_sb_2, NULL, wi);\n+      walk_gimple_seq_mod (gimple_omp_body_ptr (stmt), diagnose_sb_2, NULL, wi);\n       wi->info = context;\n       break;\n \n@@ -7187,7 +7178,9 @@ diagnose_omp_structured_block_errors (void)\n \n   memset (&wi, 0, sizeof (wi));\n   wi.want_locations = true;\n-  walk_gimple_seq (body, diagnose_sb_2, NULL, &wi);\n+  walk_gimple_seq_mod (&body, diagnose_sb_2, NULL, &wi);\n+\n+  gimple_set_body (current_function_decl, body);\n \n   splay_tree_delete (all_labels);\n   all_labels = NULL;"}, {"sha": "0a021b421e3748e78389a3931e09c156b758f452", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -1570,8 +1570,8 @@ lower_transaction (gimple_stmt_iterator *gsi, struct walk_stmt_info *wi)\n      us some idea of what we're dealing with.  */\n   memset (&this_wi, 0, sizeof (this_wi));\n   this_wi.info = (void *) &this_state;\n-  walk_gimple_seq (gimple_transaction_body (stmt),\n-\t\t   lower_sequence_tm, NULL, &this_wi);\n+  walk_gimple_seq_mod (gimple_transaction_body_ptr (stmt),\n+\t\t       lower_sequence_tm, NULL, &this_wi);\n \n   /* If there was absolutely nothing transaction related inside the\n      transaction, we may elide it.  Likewise if this is a nested\n@@ -1600,7 +1600,7 @@ lower_transaction (gimple_stmt_iterator *gsi, struct walk_stmt_info *wi)\n       gimple_seq n_seq, e_seq;\n \n       n_seq = gimple_seq_alloc_with_stmt (g);\n-      e_seq = gimple_seq_alloc ();\n+      e_seq = NULL;\n \n       g = gimple_build_call (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n \t\t\t     1, integer_zero_node);\n@@ -1704,13 +1704,15 @@ static unsigned int\n execute_lower_tm (void)\n {\n   struct walk_stmt_info wi;\n+  gimple_seq body;\n \n   /* Transactional clones aren't created until a later pass.  */\n   gcc_assert (!decl_is_tm_clone (current_function_decl));\n \n+  body = gimple_body (current_function_decl);\n   memset (&wi, 0, sizeof (wi));\n-  walk_gimple_seq (gimple_body (current_function_decl),\n-\t\t   lower_sequence_no_tm, NULL, &wi);\n+  walk_gimple_seq_mod (&body, lower_sequence_no_tm, NULL, &wi);\n+  gimple_set_body (current_function_decl, body);\n \n   return 0;\n }"}, {"sha": "7d884c9c926eb3f68927a4846947e85220757545", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -377,7 +377,7 @@ make_blocks (gimple_seq seq)\n       if (start_new_block || stmt_starts_bb_p (stmt, prev_stmt))\n \t{\n \t  if (!first_stmt_of_seq)\n-\t    seq = gsi_split_seq_before (&i);\n+\t    gsi_split_seq_before (&i, &seq);\n \t  bb = create_basic_block (seq, NULL, bb);\n \t  start_new_block = false;\n \t}\n@@ -439,7 +439,7 @@ create_bb (void *h, void *e, basic_block after)\n   bb->index = last_basic_block;\n   bb->flags = BB_NEW;\n   bb->il.gimple = ggc_alloc_cleared_gimple_bb_info ();\n-  set_bb_seq (bb, h ? (gimple_seq) h : gimple_seq_alloc ());\n+  set_bb_seq (bb, h ? (gimple_seq) h : NULL);\n \n   /* Add the new block to the linked list of blocks.  */\n   link_block (bb, after);\n@@ -1655,15 +1655,14 @@ static void\n gimple_merge_blocks (basic_block a, basic_block b)\n {\n   gimple_stmt_iterator last, gsi, psi;\n-  gimple_seq phis = phi_nodes (b);\n \n   if (dump_file)\n     fprintf (dump_file, \"Merging blocks %d and %d\\n\", a->index, b->index);\n \n   /* Remove all single-valued PHI nodes from block B of the form\n      V_i = PHI <V_j> by propagating V_j to all the uses of V_i.  */\n   gsi = gsi_last_bb (a);\n-  for (psi = gsi_start (phis); !gsi_end_p (psi); )\n+  for (psi = gsi_start_phis (b); !gsi_end_p (psi); )\n     {\n       gimple phi = gsi_stmt (psi);\n       tree def = gimple_phi_result (phi), use = gimple_phi_arg_def (phi, 0);\n@@ -5249,7 +5248,7 @@ gimple_split_block (basic_block bb, void *stmt)\n      brings ugly quadratic memory consumption in the inliner.\n      (We are still quadratic since we need to update stmt BB pointers,\n      sadly.)  */\n-  list = gsi_split_seq_before (&gsi);\n+  gsi_split_seq_before (&gsi, &list);\n   set_bb_seq (new_bb, list);\n   for (gsi_tgt = gsi_start (list);\n        !gsi_end_p (gsi_tgt); gsi_next (&gsi_tgt))\n@@ -6085,8 +6084,8 @@ move_stmt_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t  p->remap_decls_p = false;\n \t  *handled_ops_p = true;\n \n-\t  walk_gimple_seq (gimple_omp_body (stmt), move_stmt_r,\n-\t\t\t   move_stmt_op, wi);\n+\t  walk_gimple_seq_mod (gimple_omp_body_ptr (stmt), move_stmt_r,\n+\t\t\t       move_stmt_op, wi);\n \n \t  p->remap_decls_p = save_remap_decls_p;\n \t}"}, {"sha": "928a3f392744b21e496981b919c6dd5abae0e413", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -661,17 +661,16 @@ update_complex_components_on_edge (edge e, tree lhs, tree r, tree i)\n static void\n update_complex_assignment (gimple_stmt_iterator *gsi, tree r, tree i)\n {\n-  gimple_stmt_iterator orig_si = *gsi;\n   gimple stmt;\n \n-  if (gimple_in_ssa_p (cfun))\n-    update_complex_components (gsi, gsi_stmt (*gsi), r, i);\n-\n-  gimple_assign_set_rhs_with_ops (&orig_si, COMPLEX_EXPR, r, i);\n-  stmt = gsi_stmt (orig_si);\n+  gimple_assign_set_rhs_with_ops (gsi, COMPLEX_EXPR, r, i);\n+  stmt = gsi_stmt (*gsi);\n   update_stmt (stmt);\n   if (maybe_clean_eh_stmt (stmt))\n     gimple_purge_dead_eh_edges (gimple_bb (stmt));\n+\n+  if (gimple_in_ssa_p (cfun))\n+    update_complex_components (gsi, gsi_stmt (*gsi), r, i);\n }\n \n "}, {"sha": "ef2b58485695b253738749fa828a4e7645ce5c7b", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -406,7 +406,7 @@ static gimple_seq lower_eh_must_not_throw (struct leh_state *, gimple);\n \n #define LARGE_GOTO_QUEUE 20\n \n-static void lower_eh_constructs_1 (struct leh_state *state, gimple_seq seq);\n+static void lower_eh_constructs_1 (struct leh_state *state, gimple_seq *seq);\n \n static gimple_seq\n find_goto_replacement (struct leh_tf_state *tf, treemple stmt)\n@@ -481,7 +481,7 @@ replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,\n /* The real work of replace_goto_queue.  Returns with TSI updated to\n    point to the next statement.  */\n \n-static void replace_goto_queue_stmt_list (gimple_seq, struct leh_tf_state *);\n+static void replace_goto_queue_stmt_list (gimple_seq *, struct leh_tf_state *);\n \n static void\n replace_goto_queue_1 (gimple stmt, struct leh_tf_state *tf,\n@@ -511,18 +511,18 @@ replace_goto_queue_1 (gimple stmt, struct leh_tf_state *tf,\n       break;\n \n     case GIMPLE_TRY:\n-      replace_goto_queue_stmt_list (gimple_try_eval (stmt), tf);\n-      replace_goto_queue_stmt_list (gimple_try_cleanup (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_try_eval_ptr (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_try_cleanup_ptr (stmt), tf);\n       break;\n     case GIMPLE_CATCH:\n-      replace_goto_queue_stmt_list (gimple_catch_handler (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_catch_handler_ptr (stmt), tf);\n       break;\n     case GIMPLE_EH_FILTER:\n-      replace_goto_queue_stmt_list (gimple_eh_filter_failure (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_eh_filter_failure_ptr (stmt), tf);\n       break;\n     case GIMPLE_EH_ELSE:\n-      replace_goto_queue_stmt_list (gimple_eh_else_n_body (stmt), tf);\n-      replace_goto_queue_stmt_list (gimple_eh_else_e_body (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_eh_else_n_body_ptr (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_eh_else_e_body_ptr (stmt), tf);\n       break;\n \n     default:\n@@ -536,9 +536,9 @@ replace_goto_queue_1 (gimple stmt, struct leh_tf_state *tf,\n /* A subroutine of replace_goto_queue.  Handles GIMPLE_SEQ.  */\n \n static void\n-replace_goto_queue_stmt_list (gimple_seq seq, struct leh_tf_state *tf)\n+replace_goto_queue_stmt_list (gimple_seq *seq, struct leh_tf_state *tf)\n {\n-  gimple_stmt_iterator gsi = gsi_start (seq);\n+  gimple_stmt_iterator gsi = gsi_start (*seq);\n \n   while (!gsi_end_p (gsi))\n     replace_goto_queue_1 (gsi_stmt (gsi), tf, &gsi);\n@@ -551,8 +551,8 @@ replace_goto_queue (struct leh_tf_state *tf)\n {\n   if (tf->goto_queue_active == 0)\n     return;\n-  replace_goto_queue_stmt_list (tf->top_p_seq, tf);\n-  replace_goto_queue_stmt_list (eh_seq, tf);\n+  replace_goto_queue_stmt_list (&tf->top_p_seq, tf);\n+  replace_goto_queue_stmt_list (&eh_seq, tf);\n }\n \n /* Add a new record to the goto queue contained in TF. NEW_STMT is the\n@@ -731,9 +731,6 @@ do_return_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod)\n \n   q->cont_stmt = q->stmt.g;\n \n-  if (!q->repl_stmt)\n-    q->repl_stmt = gimple_seq_alloc ();\n-\n   if (mod)\n     gimple_seq_add_seq (&q->repl_stmt, mod);\n \n@@ -750,8 +747,6 @@ do_goto_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod,\n   gimple x;\n \n   gcc_assert (q->is_label);\n-  if (!q->repl_stmt)\n-    q->repl_stmt = gimple_seq_alloc ();\n \n   q->cont_stmt = gimple_build_goto (VEC_index (tree, tf->dest_array, q->index));\n \n@@ -1050,21 +1045,21 @@ lower_try_finally_nofallthru (struct leh_state *state,\n   if (eh_else)\n     {\n       finally = gimple_eh_else_n_body (eh_else);\n-      lower_eh_constructs_1 (state, finally);\n+      lower_eh_constructs_1 (state, &finally);\n       gimple_seq_add_seq (&tf->top_p_seq, finally);\n \n       if (tf->may_throw)\n \t{\n \t  finally = gimple_eh_else_e_body (eh_else);\n-\t  lower_eh_constructs_1 (state, finally);\n+\t  lower_eh_constructs_1 (state, &finally);\n \n \t  emit_post_landing_pad (&eh_seq, tf->region);\n \t  gimple_seq_add_seq (&eh_seq, finally);\n \t}\n     }\n   else\n     {\n-      lower_eh_constructs_1 (state, finally);\n+      lower_eh_constructs_1 (state, &finally);\n       gimple_seq_add_seq (&tf->top_p_seq, finally);\n \n       if (tf->may_throw)\n@@ -1105,7 +1100,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n \tfinally = gimple_eh_else_n_body (x);\n     }\n \n-  lower_eh_constructs_1 (state, finally);\n+  lower_eh_constructs_1 (state, &finally);\n \n   if (tf->may_throw)\n     {\n@@ -1193,7 +1188,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n   if (tf->may_fallthru)\n     {\n       seq = lower_try_finally_dup_block (finally, state);\n-      lower_eh_constructs_1 (state, seq);\n+      lower_eh_constructs_1 (state, &seq);\n       gimple_seq_add_seq (&new_stmt, seq);\n \n       tmp = lower_try_finally_fallthru_label (tf);\n@@ -1209,7 +1204,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \tseq = gimple_eh_else_e_body (eh_else);\n       else\n \tseq = lower_try_finally_dup_block (finally, state);\n-      lower_eh_constructs_1 (state, seq);\n+      lower_eh_constructs_1 (state, &seq);\n \n       emit_post_landing_pad (&eh_seq, tf->region);\n       gimple_seq_add_seq (&eh_seq, seq);\n@@ -1259,7 +1254,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n           gimple_seq_add_stmt (&new_stmt, x);\n \n \t  seq = lower_try_finally_dup_block (finally, state);\n-\t  lower_eh_constructs_1 (state, seq);\n+\t  lower_eh_constructs_1 (state, &seq);\n           gimple_seq_add_seq (&new_stmt, seq);\n \n           gimple_seq_add_stmt (&new_stmt, q->cont_stmt);\n@@ -1306,7 +1301,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   int nlabels, ndests, j, last_case_index;\n   tree last_case;\n   VEC (tree,heap) *case_label_vec;\n-  gimple_seq switch_body;\n+  gimple_seq switch_body = NULL;\n   gimple x, eh_else;\n   tree tmp;\n   gimple switch_stmt;\n@@ -1317,7 +1312,6 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   /* The location of the finally block.  */\n   location_t finally_loc;\n \n-  switch_body = gimple_seq_alloc ();\n   finally = gimple_try_cleanup (tf->top_p);\n   eh_else = get_eh_else (finally);\n \n@@ -1331,7 +1325,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n     : tf_loc;\n \n   /* Lower the finally block itself.  */\n-  lower_eh_constructs_1 (state, finally);\n+  lower_eh_constructs_1 (state, &finally);\n \n   /* Prepare for switch statement generation.  */\n   nlabels = VEC_length (tree, tf->dest_array);\n@@ -1382,7 +1376,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       if (tf->may_throw)\n \t{\n \t  finally = gimple_eh_else_e_body (eh_else);\n-\t  lower_eh_constructs_1 (state, finally);\n+\t  lower_eh_constructs_1 (state, &finally);\n \n \t  emit_post_landing_pad (&eh_seq, tf->region);\n \t  gimple_seq_add_seq (&eh_seq, finally);\n@@ -1426,12 +1420,10 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n      entrance through a particular edge. */\n   for (; q < qe; ++q)\n     {\n-      gimple_seq mod;\n+      gimple_seq mod = NULL;\n       int switch_id;\n       unsigned int case_index;\n \n-      mod = gimple_seq_alloc ();\n-\n       if (q->index < 0)\n \t{\n \t  x = gimple_build_assign (finally_tmp,\n@@ -1623,7 +1615,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n   old_eh_seq = eh_seq;\n   eh_seq = NULL;\n \n-  lower_eh_constructs_1 (&this_state, gimple_try_eval(tp));\n+  lower_eh_constructs_1 (&this_state, gimple_try_eval_ptr (tp));\n \n   /* Determine if the try block is escaped through the bottom.  */\n   this_tf.may_fallthru = gimple_seq_may_fallthru (gimple_try_eval (tp));\n@@ -1706,7 +1698,7 @@ lower_catch (struct leh_state *state, gimple tp)\n   struct leh_state this_state = *state;\n   gimple_stmt_iterator gsi;\n   tree out_label;\n-  gimple_seq new_seq;\n+  gimple_seq new_seq, cleanup;\n   gimple x;\n   location_t try_catch_loc = gimple_location (tp);\n \n@@ -1716,7 +1708,7 @@ lower_catch (struct leh_state *state, gimple tp)\n       this_state.cur_region = try_region;\n     }\n \n-  lower_eh_constructs_1 (&this_state, gimple_try_eval (tp));\n+  lower_eh_constructs_1 (&this_state, gimple_try_eval_ptr (tp));\n \n   if (!eh_region_may_contain_throw (try_region))\n     return gimple_try_eval (tp);\n@@ -1729,7 +1721,8 @@ lower_catch (struct leh_state *state, gimple tp)\n   this_state.ehp_region = try_region;\n \n   out_label = NULL;\n-  for (gsi = gsi_start (gimple_try_cleanup (tp));\n+  cleanup = gimple_try_cleanup (tp);\n+  for (gsi = gsi_start (cleanup);\n        !gsi_end_p (gsi);\n        gsi_next (&gsi))\n     {\n@@ -1741,7 +1734,7 @@ lower_catch (struct leh_state *state, gimple tp)\n       c = gen_eh_region_catch (try_region, gimple_catch_types (gcatch));\n \n       handler = gimple_catch_handler (gcatch);\n-      lower_eh_constructs_1 (&this_state, handler);\n+      lower_eh_constructs_1 (&this_state, &handler);\n \n       c->label = create_artificial_label (UNKNOWN_LOCATION);\n       x = gimple_build_label (c->label);\n@@ -1787,7 +1780,7 @@ lower_eh_filter (struct leh_state *state, gimple tp)\n       this_state.cur_region = this_region;\n     }\n \n-  lower_eh_constructs_1 (&this_state, gimple_try_eval (tp));\n+  lower_eh_constructs_1 (&this_state, gimple_try_eval_ptr (tp));\n \n   if (!eh_region_may_contain_throw (this_region))\n     return gimple_try_eval (tp);\n@@ -1803,7 +1796,7 @@ lower_eh_filter (struct leh_state *state, gimple tp)\n   x = gimple_build_label (this_region->u.allowed.label);\n   gimple_seq_add_stmt (&new_seq, x);\n \n-  lower_eh_constructs_1 (&this_state, gimple_eh_filter_failure (inner));\n+  lower_eh_constructs_1 (&this_state, gimple_eh_filter_failure_ptr (inner));\n   gimple_seq_add_seq (&new_seq, gimple_eh_filter_failure (inner));\n \n   gimple_try_set_cleanup (tp, new_seq);\n@@ -1838,7 +1831,7 @@ lower_eh_must_not_throw (struct leh_state *state, gimple tp)\n       this_state.cur_region = this_region;\n     }\n \n-  lower_eh_constructs_1 (&this_state, gimple_try_eval (tp));\n+  lower_eh_constructs_1 (&this_state, gimple_try_eval_ptr (tp));\n \n   return gimple_try_eval (tp);\n }\n@@ -1861,7 +1854,7 @@ lower_cleanup (struct leh_state *state, gimple tp)\n       this_state.cur_region = this_region;\n     }\n \n-  lower_eh_constructs_1 (&this_state, gimple_try_eval (tp));\n+  lower_eh_constructs_1 (&this_state, gimple_try_eval_ptr (tp));\n \n   if (cleanup_dead || !eh_region_may_contain_throw (this_region))\n     return gimple_try_eval (tp);\n@@ -1881,7 +1874,7 @@ lower_cleanup (struct leh_state *state, gimple tp)\n     {\n       /* In this case honor_protect_cleanup_actions had nothing to do,\n \t and we should process this normally.  */\n-      lower_eh_constructs_1 (state, gimple_try_cleanup (tp));\n+      lower_eh_constructs_1 (state, gimple_try_cleanup_ptr (tp));\n       result = frob_into_branch_around (tp, this_region,\n                                         fake_tf.fallthru_label);\n     }\n@@ -2010,7 +2003,7 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n \t  if (!x)\n \t    {\n \t      replace = gimple_try_eval (stmt);\n-\t      lower_eh_constructs_1 (state, replace);\n+\t      lower_eh_constructs_1 (state, &replace);\n \t    }\n \t  else\n \t    switch (gimple_code (x))\n@@ -2057,10 +2050,10 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n /* A helper to unwrap a gimple_seq and feed stmts to lower_eh_constructs_2. */\n \n static void\n-lower_eh_constructs_1 (struct leh_state *state, gimple_seq seq)\n+lower_eh_constructs_1 (struct leh_state *state, gimple_seq *pseq)\n {\n   gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start (seq); !gsi_end_p (gsi);)\n+  for (gsi = gsi_start (*pseq); !gsi_end_p (gsi);)\n     lower_eh_constructs_2 (state, &gsi);\n }\n \n@@ -2079,7 +2072,8 @@ lower_eh_constructs (void)\n   memset (&null_state, 0, sizeof (null_state));\n \n   collect_finally_tree_1 (bodyp, NULL);\n-  lower_eh_constructs_1 (&null_state, bodyp);\n+  lower_eh_constructs_1 (&null_state, &bodyp);\n+  gimple_set_body (current_function_decl, bodyp);\n \n   /* We assume there's a return statement, or something, at the end of\n      the function, and thus ploping the EH sequence afterward won't\n@@ -2874,8 +2868,10 @@ optimize_double_finally (gimple one, gimple two)\n {\n   gimple oneh;\n   gimple_stmt_iterator gsi;\n+  gimple_seq cleanup;\n \n-  gsi = gsi_start (gimple_try_cleanup (one));\n+  cleanup = gimple_try_cleanup (one);\n+  gsi = gsi_start (cleanup);\n   if (!gsi_one_before_end_p (gsi))\n     return;\n "}, {"sha": "066e9ad89cd454208cd4b1957493a34f5db41820", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -511,6 +511,15 @@ phi_nodes (const_basic_block bb)\n   return bb->il.gimple->phi_nodes;\n }\n \n+static inline gimple_seq *\n+phi_nodes_ptr (const_basic_block bb)\n+{\n+  gcc_checking_assert (!(bb->flags & BB_RTL));\n+  if (!bb->il.gimple)\n+    return NULL;\n+  return &bb->il.gimple->phi_nodes;\n+}\n+\n /* Set PHI nodes of a basic block BB to SEQ.  */\n \n static inline void"}, {"sha": "ef0346581abdd6dda369fc6bac1549e3f1a21076", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -1996,7 +1996,7 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n   edge new_edge;\n   bool inserted = false;\n \n-  for (si = gsi_start (phi_nodes (bb)); !gsi_end_p (si); gsi_next (&si))\n+  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       tree res, new_res;\n       gimple new_phi;"}, {"sha": "edd7755a701c28ed1d067ac88254e1c1052d5f06", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -472,7 +472,7 @@ static void\n mf_decl_cache_locals (void)\n {\n   gimple g;\n-  gimple_seq seq = gimple_seq_alloc ();\n+  gimple_seq seq = NULL;\n \n   /* Build the cache vars.  */\n   mf_cache_shift_decl_l\n@@ -572,7 +572,7 @@ mf_build_check_statement_for (tree base, tree limit,\n   mf_limit = make_rename_temp (mf_uintptr_type, \"__mf_limit\");\n \n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n-  seq = gimple_seq_alloc ();\n+  seq = NULL;\n   t = fold_convert_loc (location, mf_uintptr_type,\n \t\t\tunshare_expr (base));\n   t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n@@ -683,7 +683,7 @@ mf_build_check_statement_for (tree base, tree limit,\n \n      This is the body of the conditional.  */\n \n-  seq = gimple_seq_alloc ();\n+  seq = NULL;\n   /* u is a string, so it is already a gimple value.  */\n   u = mf_file_function_line_tree (location);\n   /* NB: we pass the overall [base..limit] range to mf_check.  */\n@@ -704,7 +704,7 @@ mf_build_check_statement_for (tree base, tree limit,\n \t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n \t  e = split_block (then_bb, g);\n \t  then_bb = e->dest;\n-\t  seq = gimple_seq_alloc ();\n+\t  seq = NULL;\n \t}\n \n       g = gimple_build_assign (mf_cache_shift_decl_l, mf_cache_shift_decl);\n@@ -1114,7 +1114,7 @@ mx_register_decls (tree decl, gimple_seq seq, location_t location)\n   if (finally_stmts != NULL)\n     {\n       gimple stmt = gimple_build_try (seq, finally_stmts, GIMPLE_TRY_FINALLY);\n-      gimple_seq new_seq = gimple_seq_alloc ();\n+      gimple_seq new_seq = NULL;\n \n       gimple_seq_add_stmt (&new_seq, stmt);\n       return new_seq;"}, {"sha": "b5d37e98e35366e1050cd39d579fc23d21d4c999", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -577,18 +577,18 @@ get_nl_goto_field (struct nesting_info *info)\n   return field;\n }\n \n-/* Invoke CALLBACK on all statements of GIMPLE sequence SEQ.  */\n+/* Invoke CALLBACK on all statements of GIMPLE sequence *PSEQ.  */\n \n static void\n walk_body (walk_stmt_fn callback_stmt, walk_tree_fn callback_op,\n-\t   struct nesting_info *info, gimple_seq seq)\n+\t   struct nesting_info *info, gimple_seq *pseq)\n {\n   struct walk_stmt_info wi;\n \n   memset (&wi, 0, sizeof (wi));\n   wi.info = info;\n   wi.val_only = true;\n-  walk_gimple_seq (seq, callback_stmt, callback_op, &wi);\n+  walk_gimple_seq_mod (pseq, callback_stmt, callback_op, &wi);\n }\n \n \n@@ -598,7 +598,9 @@ static inline void\n walk_function (walk_stmt_fn callback_stmt, walk_tree_fn callback_op,\n \t       struct nesting_info *info)\n {\n-  walk_body (callback_stmt, callback_op, info, gimple_body (info->context));\n+  gimple_seq body = gimple_body (info->context);\n+  walk_body (callback_stmt, callback_op, info, &body);\n+  gimple_set_body (info->context, body);\n }\n \n /* Invoke CALLBACK on a GIMPLE_OMP_FOR's init, cond, incr and pre-body.  */\n@@ -613,9 +615,9 @@ walk_gimple_omp_for (gimple for_stmt,\n   tree t;\n   size_t i;\n \n-  walk_body (callback_stmt, callback_op, info, gimple_omp_for_pre_body (for_stmt));\n+  walk_body (callback_stmt, callback_op, info, gimple_omp_for_pre_body_ptr (for_stmt));\n \n-  seq = gimple_seq_alloc ();\n+  seq = NULL;\n   memset (&wi, 0, sizeof (wi));\n   wi.info = info;\n   wi.gsi = gsi_last (seq);\n@@ -644,9 +646,8 @@ walk_gimple_omp_for (gimple for_stmt,\n       walk_tree (&TREE_OPERAND (t, 1), callback_op, &wi, NULL);\n     }\n \n-  if (gimple_seq_empty_p (seq))\n-    gimple_seq_free (seq);\n-  else\n+  seq = gsi_seq (wi.gsi);\n+  if (!gimple_seq_empty_p (seq))\n     {\n       gimple_seq pre_body = gimple_omp_for_pre_body (for_stmt);\n       annotate_all_with_location (seq, gimple_location (for_stmt));\n@@ -1136,10 +1137,10 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t\t= info->context;\n \t      walk_body (convert_nonlocal_reference_stmt,\n \t\t\t convert_nonlocal_reference_op, info,\n-\t\t\t OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause));\n+\t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause));\n \t      walk_body (convert_nonlocal_reference_stmt,\n \t\t\t convert_nonlocal_reference_op, info,\n-\t\t\t OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause));\n+\t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause));\n \t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n \t\t= old_context;\n \t    }\n@@ -1148,7 +1149,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  walk_body (convert_nonlocal_reference_stmt,\n \t\t     convert_nonlocal_reference_op, info,\n-\t\t     OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause));\n+\t\t     &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause));\n \t  break;\n \n \tdefault:\n@@ -1261,7 +1262,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       info->new_local_var_chain = NULL;\n \n       walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n-\t         info, gimple_omp_body (stmt));\n+\t         info, gimple_omp_body_ptr (stmt));\n \n       if (info->new_local_var_chain)\n \tdeclare_vars (info->new_local_var_chain,\n@@ -1277,31 +1278,31 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       walk_gimple_omp_for (stmt, convert_nonlocal_reference_stmt,\n \t  \t\t   convert_nonlocal_reference_op, info);\n       walk_body (convert_nonlocal_reference_stmt,\n-\t  \t convert_nonlocal_reference_op, info, gimple_omp_body (stmt));\n+\t  \t convert_nonlocal_reference_op, info, gimple_omp_body_ptr (stmt));\n       info->suppress_expansion = save_suppress;\n       break;\n \n     case GIMPLE_OMP_SECTIONS:\n       save_suppress = info->suppress_expansion;\n       convert_nonlocal_omp_clauses (gimple_omp_sections_clauses_ptr (stmt), wi);\n       walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n-\t         info, gimple_omp_body (stmt));\n+\t         info, gimple_omp_body_ptr (stmt));\n       info->suppress_expansion = save_suppress;\n       break;\n \n     case GIMPLE_OMP_SINGLE:\n       save_suppress = info->suppress_expansion;\n       convert_nonlocal_omp_clauses (gimple_omp_single_clauses_ptr (stmt), wi);\n       walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n-\t         info, gimple_omp_body (stmt));\n+\t         info, gimple_omp_body_ptr (stmt));\n       info->suppress_expansion = save_suppress;\n       break;\n \n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_ORDERED:\n       walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n-\t         info, gimple_omp_body (stmt));\n+\t         info, gimple_omp_body_ptr (stmt));\n       break;\n \n     case GIMPLE_BIND:\n@@ -1635,10 +1636,10 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t\t= info->context;\n \t      walk_body (convert_local_reference_stmt,\n \t\t\t convert_local_reference_op, info,\n-\t\t\t OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause));\n+\t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause));\n \t      walk_body (convert_local_reference_stmt,\n \t\t\t convert_local_reference_op, info,\n-\t\t\t OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause));\n+\t\t\t &OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause));\n \t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n \t\t= old_context;\n \t    }\n@@ -1647,7 +1648,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  walk_body (convert_local_reference_stmt,\n \t\t     convert_local_reference_op, info,\n-\t\t     OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause));\n+\t\t     &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause));\n \t  break;\n \n \tdefault:\n@@ -1692,7 +1693,7 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       info->new_local_var_chain = NULL;\n \n       walk_body (convert_local_reference_stmt, convert_local_reference_op, info,\n-\t         gimple_omp_body (stmt));\n+\t         gimple_omp_body_ptr (stmt));\n \n       if (info->new_local_var_chain)\n \tdeclare_vars (info->new_local_var_chain,\n@@ -1707,31 +1708,31 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       walk_gimple_omp_for (stmt, convert_local_reference_stmt,\n \t\t\t   convert_local_reference_op, info);\n       walk_body (convert_local_reference_stmt, convert_local_reference_op,\n-\t\t info, gimple_omp_body (stmt));\n+\t\t info, gimple_omp_body_ptr (stmt));\n       info->suppress_expansion = save_suppress;\n       break;\n \n     case GIMPLE_OMP_SECTIONS:\n       save_suppress = info->suppress_expansion;\n       convert_local_omp_clauses (gimple_omp_sections_clauses_ptr (stmt), wi);\n       walk_body (convert_local_reference_stmt, convert_local_reference_op,\n-\t\t info, gimple_omp_body (stmt));\n+\t\t info, gimple_omp_body_ptr (stmt));\n       info->suppress_expansion = save_suppress;\n       break;\n \n     case GIMPLE_OMP_SINGLE:\n       save_suppress = info->suppress_expansion;\n       convert_local_omp_clauses (gimple_omp_single_clauses_ptr (stmt), wi);\n       walk_body (convert_local_reference_stmt, convert_local_reference_op,\n-\t\t info, gimple_omp_body (stmt));\n+\t\t info, gimple_omp_body_ptr (stmt));\n       info->suppress_expansion = save_suppress;\n       break;\n \n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_ORDERED:\n       walk_body (convert_local_reference_stmt, convert_local_reference_op,\n-\t\t info, gimple_omp_body (stmt));\n+\t\t info, gimple_omp_body_ptr (stmt));\n       break;\n \n     case GIMPLE_COND:\n@@ -1809,12 +1810,12 @@ convert_nl_goto_reference (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n   /* Build: __builtin_nl_goto(new_label, &chain->nl_goto_field).  */\n   field = get_nl_goto_field (i);\n-  x = get_frame_field (info, target_context, field, &wi->gsi);\n+  x = get_frame_field (info, target_context, field, gsi);\n   x = build_addr (x, target_context);\n-  x = gsi_gimplify_val (info, x, &wi->gsi);\n+  x = gsi_gimplify_val (info, x, gsi);\n   call = gimple_build_call (builtin_decl_implicit (BUILT_IN_NONLOCAL_GOTO),\n \t\t\t    2, build_addr (new_label, target_context), x);\n-  gsi_replace (&wi->gsi, call, false);\n+  gsi_replace (gsi, call, false);\n \n   /* We have handled all of STMT's operands, no need to keep going.  */\n   *handled_ops_p = true;\n@@ -1979,7 +1980,7 @@ convert_tramp_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \tsave_local_var_chain = info->new_local_var_chain;\n \tinfo->new_local_var_chain = NULL;\n         walk_body (convert_tramp_reference_stmt, convert_tramp_reference_op,\n-\t\t   info, gimple_omp_body (stmt));\n+\t\t   info, gimple_omp_body_ptr (stmt));\n \tif (info->new_local_var_chain)\n \t  declare_vars (info->new_local_var_chain,\n \t\t\tgimple_seq_first_stmt (gimple_omp_body (stmt)),\n@@ -2035,7 +2036,7 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     case GIMPLE_OMP_TASK:\n       save_static_chain_added = info->static_chain_added;\n       info->static_chain_added = 0;\n-      walk_body (convert_gimple_call, NULL, info, gimple_omp_body (stmt));\n+      walk_body (convert_gimple_call, NULL, info, gimple_omp_body_ptr (stmt));\n       for (i = 0; i < 2; i++)\n \t{\n \t  tree c, decl;\n@@ -2065,15 +2066,15 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n     case GIMPLE_OMP_FOR:\n       walk_body (convert_gimple_call, NULL, info,\n-\t  \t gimple_omp_for_pre_body (stmt));\n+\t  \t gimple_omp_for_pre_body_ptr (stmt));\n       /* FALLTHRU */\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_CRITICAL:\n-      walk_body (convert_gimple_call, NULL, info, gimple_omp_body (stmt));\n+      walk_body (convert_gimple_call, NULL, info, gimple_omp_body_ptr (stmt));\n       break;\n \n     default:"}, {"sha": "bac9b52abcd2fd8997873beae07993d408257801", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -221,6 +221,7 @@ make_phi_node (tree var, int len)\n \t\t   - sizeof (struct phi_arg_d)\n \t\t   + sizeof (struct phi_arg_d) * len));\n   phi->gsbase.code = GIMPLE_PHI;\n+  gimple_init_singleton (phi);\n   phi->gimple_phi.nargs = len;\n   phi->gimple_phi.capacity = capacity;\n   if (TREE_CODE (var) == SSA_NAME)\n@@ -269,29 +270,29 @@ release_phi_node (gimple phi)\n /* Resize an existing PHI node.  The only way is up.  Return the\n    possibly relocated phi.  */\n \n-static void\n-resize_phi_node (gimple *phi, size_t len)\n+static gimple\n+resize_phi_node (gimple phi, size_t len)\n {\n   size_t old_size, i;\n   gimple new_phi;\n \n-  gcc_assert (len > gimple_phi_capacity (*phi));\n+  gcc_assert (len > gimple_phi_capacity (phi));\n \n   /* The garbage collector will not look at the PHI node beyond the\n      first PHI_NUM_ARGS elements.  Therefore, all we have to copy is a\n      portion of the PHI node currently in use.  */\n   old_size = sizeof (struct gimple_statement_phi)\n-\t     + (gimple_phi_num_args (*phi) - 1) * sizeof (struct phi_arg_d);\n+\t     + (gimple_phi_num_args (phi) - 1) * sizeof (struct phi_arg_d);\n \n   new_phi = allocate_phi_node (len);\n \n-  memcpy (new_phi, *phi, old_size);\n+  memcpy (new_phi, phi, old_size);\n \n   for (i = 0; i < gimple_phi_num_args (new_phi); i++)\n     {\n       use_operand_p imm, old_imm;\n       imm = gimple_phi_arg_imm_use_ptr (new_phi, i);\n-      old_imm = gimple_phi_arg_imm_use_ptr (*phi, i);\n+      old_imm = gimple_phi_arg_imm_use_ptr (phi, i);\n       imm->use = gimple_phi_arg_def_ptr (new_phi, i);\n       relink_imm_use_stmt (imm, old_imm, new_phi);\n     }\n@@ -310,7 +311,7 @@ resize_phi_node (gimple *phi, size_t len)\n       imm->loc.stmt = new_phi;\n     }\n \n-  *phi = new_phi;\n+  return new_phi;\n }\n \n /* Reserve PHI arguments for a new edge to basic block BB.  */\n@@ -324,18 +325,18 @@ reserve_phi_args_for_new_edge (basic_block bb)\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple *loc = gsi_stmt_ptr (&gsi);\n+      gimple stmt = gsi_stmt (gsi);\n \n-      if (len > gimple_phi_capacity (*loc))\n+      if (len > gimple_phi_capacity (stmt))\n \t{\n-\t  gimple old_phi = *loc;\n-\n-\t  resize_phi_node (loc, cap);\n+\t  gimple new_phi = resize_phi_node (stmt, cap);\n \n \t  /* The result of the PHI is defined by this PHI node.  */\n-\t  SSA_NAME_DEF_STMT (gimple_phi_result (*loc)) = *loc;\n+\t  SSA_NAME_DEF_STMT (gimple_phi_result (new_phi)) = new_phi;\n+\t  gsi_set_stmt (&gsi, new_phi);\n \n-\t  release_phi_node (old_phi);\n+\t  release_phi_node (stmt);\n+\t  stmt = new_phi;\n \t}\n \n       /* We represent a \"missing PHI argument\" by placing NULL_TREE in\n@@ -345,9 +346,9 @@ reserve_phi_args_for_new_edge (basic_block bb)\n \t example, the loop optimizer duplicates several basic blocks,\n \t redirects edges, and then fixes up PHI arguments later in\n \t batch.  */\n-      SET_PHI_ARG_DEF (*loc, len - 1, NULL_TREE);\n+      SET_PHI_ARG_DEF (stmt, len - 1, NULL_TREE);\n \n-      (*loc)->gimple_phi.nargs++;\n+      stmt->gimple_phi.nargs++;\n     }\n }\n \n@@ -356,13 +357,15 @@ reserve_phi_args_for_new_edge (basic_block bb)\n void\n add_phi_node_to_bb (gimple phi, basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n+  gimple_seq seq = phi_nodes (bb);\n   /* Add the new PHI node to the list of PHI nodes for block BB.  */\n-  if (phi_nodes (bb) == NULL)\n-    set_phi_nodes (bb, gimple_seq_alloc ());\n-\n-  gsi = gsi_last (phi_nodes (bb));\n-  gsi_insert_after (&gsi, phi, GSI_NEW_STMT);\n+  if (seq == NULL)\n+    set_phi_nodes (bb, gimple_seq_alloc_with_stmt (phi));\n+  else\n+    {\n+      gimple_seq_add_stmt (&seq, phi);\n+      gcc_assert (seq == phi_nodes (bb));\n+    }\n \n   /* Associate BB to the PHI node.  */\n   gimple_set_bb (phi, bb);"}, {"sha": "de99b305e3c74ea4613c631da40887bcb69d9b6b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -3192,6 +3192,7 @@ initialize_parameter_reductions (void)\n   gimple_seq seq = NULL;\n   tree parm;\n \n+  gsi = gsi_start (seq);\n   for (parm = DECL_ARGUMENTS (current_function_decl);\n        parm;\n        parm = DECL_CHAIN (parm))\n@@ -3205,19 +3206,14 @@ initialize_parameter_reductions (void)\n       if (!access_vec)\n \tcontinue;\n \n-      if (!seq)\n-\t{\n-\t  seq = gimple_seq_alloc ();\n-\t  gsi = gsi_start (seq);\n-\t}\n-\n       for (access = VEC_index (access_p, access_vec, 0);\n \t   access;\n \t   access = access->next_grp)\n \tgenerate_subtree_copies (access, parm, 0, 0, 0, &gsi, true, true,\n \t\t\t\t EXPR_LOCATION (parm));\n     }\n \n+  seq = gsi_seq (gsi);\n   if (seq)\n     gsi_insert_seq_on_edge_immediate (single_succ_edge (ENTRY_BLOCK_PTR), seq);\n }"}, {"sha": "1d72e06fe7697652848857707f74786b70cc7394", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -1042,12 +1042,10 @@ static bool\n remove_dead_phis (basic_block bb)\n {\n   bool something_changed = false;\n-  gimple_seq phis;\n   gimple phi;\n   gimple_stmt_iterator gsi;\n-  phis = phi_nodes (bb);\n \n-  for (gsi = gsi_start (phis); !gsi_end_p (gsi);)\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);)\n     {\n       stats.total_phis++;\n       phi = gsi_stmt (gsi);"}, {"sha": "bf4458065e99cadeff2890953c55c809d0ba9098", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -277,7 +277,7 @@ dse_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n {\n   gimple_stmt_iterator gsi;\n \n-  for (gsi = gsi_last (bb_seq (bb)); !gsi_end_p (gsi); gsi_prev (&gsi))\n+  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n     dse_optimize_stmt (gsi);\n }\n "}, {"sha": "e14627d9f3a1ed2f27f9ef5d8000dcd62a2ad666", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -1202,16 +1202,18 @@ forward_propagate_addr_expr (tree name, tree rhs)\n }\n \n \n-/* Forward propagate the comparison defined in STMT like\n+/* Forward propagate the comparison defined in *DEFGSI like\n    cond_1 = x CMP y to uses of the form\n      a_1 = (T')cond_1\n      a_1 = !cond_1\n      a_1 = cond_1 != 0\n-   Returns true if stmt is now unused.  */\n+   Returns true if stmt is now unused.  Advance DEFGSI to the next\n+   statement.  */\n \n static bool\n-forward_propagate_comparison (gimple stmt)\n+forward_propagate_comparison (gimple_stmt_iterator *defgsi)\n {\n+  gimple stmt = gsi_stmt (*defgsi);\n   tree name = gimple_assign_lhs (stmt);\n   gimple use_stmt;\n   tree tmp = NULL_TREE;\n@@ -1224,18 +1226,18 @@ forward_propagate_comparison (gimple stmt)\n        && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (stmt)))\n       || (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME\n         && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs2 (stmt))))\n-    return false;\n+    goto bailout;\n \n   /* Do not un-cse comparisons.  But propagate through copies.  */\n   use_stmt = get_prop_dest_stmt (name, &name);\n   if (!use_stmt\n       || !is_gimple_assign (use_stmt))\n-    return false;\n+    goto bailout;\n \n   code = gimple_assign_rhs_code (use_stmt);\n   lhs = gimple_assign_lhs (use_stmt);\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-    return false;\n+    goto bailout;\n \n   /* We can propagate the condition into a statement that\n      computes the logical negation of the comparison result.  */\n@@ -1249,13 +1251,13 @@ forward_propagate_comparison (gimple stmt)\n       enum tree_code inv_code;\n       inv_code = invert_tree_comparison (gimple_assign_rhs_code (stmt), nans);\n       if (inv_code == ERROR_MARK)\n-\treturn false;\n+\tgoto bailout;\n \n       tmp = build2 (inv_code, TREE_TYPE (lhs), gimple_assign_rhs1 (stmt),\n \t\t    gimple_assign_rhs2 (stmt));\n     }\n   else\n-    return false;\n+    goto bailout;\n \n   gsi = gsi_for_stmt (use_stmt);\n   gimple_assign_set_rhs_from_tree (&gsi, unshare_expr (tmp));\n@@ -1271,8 +1273,16 @@ forward_propagate_comparison (gimple stmt)\n       fprintf (dump_file, \"'\\n\");\n     }\n \n+  /* When we remove stmt now the iterator defgsi goes off it's current\n+     sequence, hence advance it now.  */\n+  gsi_next (defgsi);\n+\n   /* Remove defining statements.  */\n   return remove_prop_source_from_use (name);\n+\n+bailout:\n+  gsi_next (defgsi);\n+  return false;\n }\n \n \n@@ -2752,9 +2762,8 @@ ssa_forward_propagate_and_combine (void)\n \t    }\n \t  else if (TREE_CODE_CLASS (code) == tcc_comparison)\n \t    {\n-\t      if (forward_propagate_comparison (stmt))\n+\t      if (forward_propagate_comparison (&gsi))\n \t        cfg_changed = true;\n-\t      gsi_next (&gsi);\n \t    }\n \t  else\n \t    gsi_next (&gsi);"}, {"sha": "5a01e618da556717661d183ac81ba24f327a119f", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -1328,8 +1328,8 @@ move_computations_stmt (struct dom_walk_data *dw_data,\n \t}\n \n       mark_virtual_ops_for_renaming (stmt);\n-      gsi_insert_on_edge (loop_preheader_edge (level), stmt);\n       gsi_remove (&bsi, false);\n+      gsi_insert_on_edge (loop_preheader_edge (level), stmt);\n     }\n }\n "}, {"sha": "82866033f618924c9f48e916d802e133e0d83acf", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355a76735231beec33c140af2d9e6adca486225c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=355a76735231beec33c140af2d9e6adca486225c", "patch": "@@ -183,7 +183,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   HOST_WIDE_INT dummy;\n   gimple stmt, pattern_stmt = NULL;\n   gimple_seq pattern_def_seq = NULL;\n-  gimple_stmt_iterator pattern_def_si = gsi_start (NULL);\n+  gimple_stmt_iterator pattern_def_si = gsi_none ();\n   bool analyze_pattern_stmt = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -336,7 +336,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      pattern_def_si = gsi_start (NULL);\n+\t\t      pattern_def_si = gsi_none ();\n \t\t      analyze_pattern_stmt = false;\n \t\t    }\n \t\t}\n@@ -5231,7 +5231,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   gimple_seq cond_expr_stmt_list = NULL;\n   gimple stmt, pattern_stmt;\n   gimple_seq pattern_def_seq = NULL;\n-  gimple_stmt_iterator pattern_def_si = gsi_start (NULL);\n+  gimple_stmt_iterator pattern_def_si = gsi_none ();\n   bool transform_pattern_stmt = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -5409,7 +5409,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      pattern_def_si = gsi_start (NULL);\n+\t\t      pattern_def_si = gsi_none ();\n \t\t      transform_pattern_stmt = false;\n \t\t    }\n \t\t}"}]}