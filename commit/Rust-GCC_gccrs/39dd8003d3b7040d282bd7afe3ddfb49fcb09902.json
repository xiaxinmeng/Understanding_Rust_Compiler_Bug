{"sha": "39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkZDgwMDNkM2I3MDQwZDI4MmJkN2FmZTNkZGZiNDlmY2IwOTkwMg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-09-20T13:48:12Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-09-20T13:48:12Z"}, "message": "Pass all command line options to both language dependent and language independent\ndecoders.\n\nFrom-SVN: r29520", "tree": {"sha": "6b01bf7b4820bd91d23d643f9b831da8c9426ccd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b01bf7b4820bd91d23d643f9b831da8c9426ccd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dd8003d3b7040d282bd7afe3ddfb49fcb09902/comments", "author": null, "committer": null, "parents": [{"sha": "558389e375659800e35b5e92a2808b92fdcdbc23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558389e375659800e35b5e92a2808b92fdcdbc23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/558389e375659800e35b5e92a2808b92fdcdbc23"}], "stats": {"total": 1169, "additions": 605, "deletions": 564}, "files": [{"sha": "5767aa543b2b7b8871f9072f023abb07eca684f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dd8003d3b7040d282bd7afe3ddfb49fcb09902/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dd8003d3b7040d282bd7afe3ddfb49fcb09902/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "patch": "@@ -1,3 +1,23 @@\n+Mon Sep 20 14:43:37 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* toplev.c (progname): Make 'const char *'\n+\t(flag_print_mem): Move out of main.\n+\t(version_flag): Move out of main.\n+\t(filename): Move out of main.\n+\t(debug_args): Remove g prefix from options.\n+\t(documented_lang_options): Remove cpplib specific options.\n+\t(display_help): Add g prefix to debug options.\n+\t(check_lang_option): Delete this function.\n+\t(decode_d_option): New function: Decode -d... option.\n+\t(decode_f_option): New function: Decode -f... option.\n+\t(decode_W_option): New function: Decode -W... option.\n+\t(decode_g_option): New function: Decode -g... option.\n+\t(independent_decode_option): New function: Decode a language\n+\tindependent command line option.\n+\t(main): Invoke lang_decode_option and then\n+\tindependent_decode_option on each command line option in\n+\tturn. \n+\n Mon Sep 20 05:41:36 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* flow.c (merge_blocks_move_predecessor_nojumps): New function."}, {"sha": "49db51baf3c5ec3160ce8291d9e428ff689a9266", "filename": "gcc/toplev.c", "status": "modified", "additions": 585, "deletions": 564, "changes": 1149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dd8003d3b7040d282bd7afe3ddfb49fcb09902/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dd8003d3b7040d282bd7afe3ddfb49fcb09902/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "patch": "@@ -192,6 +192,12 @@ static void report_file_and_line PROTO ((const char *, int, int));\n static void vnotice PROTO ((FILE *, const char *, va_list));\n static void mark_file_stack PROTO ((void *));\n \n+static void decode_d_option PROTO ((const char *));\n+static int  decode_f_option PROTO ((const char *));\n+static int  decode_W_option PROTO ((const char *));\n+static int  decode_g_option PROTO ((const char *));\n+static unsigned independent_decode_option PROTO ((int, char **, unsigned));\n+\n static void print_version PROTO((FILE *, const char *));\n static int print_single_switch PROTO((FILE *, int, int, const char *,\n \t\t\t\t      const char *, const char *,\n@@ -279,6 +285,9 @@ int stack_reg_dump = 0;\n #ifdef MACHINE_DEPENDENT_REORG\n int mach_dep_reorg_dump = 0;\n #endif\n+static int flag_print_mem = 0;\n+static int version_flag = 0;\n+static char * filename = 0;\n enum graph_dump_types graph_dump_format;\n \n /* Name for output file of assembly code, specified with -o.  */\n@@ -767,27 +776,27 @@ static struct\n } *da,\n debug_args[] =\n {\n-  { \"g\",    NO_DEBUG, DEFAULT_GDB_EXTENSIONS,\n+  { \"\",       NO_DEBUG, DEFAULT_GDB_EXTENSIONS,\n     \"Generate default debug format output\" },\n-  { \"ggdb\", NO_DEBUG, 1, \"Generate default extended debug format output\" },\n+  { \"gdb\",    NO_DEBUG, 1, \"Generate default extended debug format output\" },\n #ifdef DBX_DEBUGGING_INFO\n-  { \"gstabs\",  DBX_DEBUG, 0, \"Generate STABS format debug output\" },\n-  { \"gstabs+\", DBX_DEBUG, 1, \"Generate extended STABS format debug output\" },\n+  { \"stabs\",  DBX_DEBUG, 0, \"Generate STABS format debug output\" },\n+  { \"stabs+\", DBX_DEBUG, 1, \"Generate extended STABS format debug output\" },\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n-  { \"gdwarf\",  DWARF_DEBUG, 0, \"Generate DWARF-1 format debug output\"},\n-  { \"gdwarf+\", DWARF_DEBUG, 1,\n+  { \"dwarf\",  DWARF_DEBUG, 0, \"Generate DWARF-1 format debug output\"},\n+  { \"dwarf+\", DWARF_DEBUG, 1,\n     \"Generated extended DWARF-1 format debug output\" },\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n-  { \"gdwarf-2\", DWARF2_DEBUG, 0, \"Enable DWARF-2 debug output\" },\n+  { \"dwarf-2\", DWARF2_DEBUG, 0, \"Enable DWARF-2 debug output\" },\n #endif\n #ifdef XCOFF_DEBUGGING_INFO\n-  { \"gxcoff\",  XCOFF_DEBUG, 0, \"Generate XCOFF format debug output\" },\n-  { \"gxcoff+\", XCOFF_DEBUG, 1, \"Generate extended XCOFF format debug output\" },\n+  { \"xcoff\",  XCOFF_DEBUG, 0, \"Generate XCOFF format debug output\" },\n+  { \"xcoff+\", XCOFF_DEBUG, 1, \"Generate extended XCOFF format debug output\" },\n #endif\n #ifdef SDB_DEBUGGING_INFO\n-  { \"gcoff\", SDB_DEBUG, 0, \"Generate COFF format debug output\" },\n+  { \"coff\", SDB_DEBUG, 0, \"Generate COFF format debug output\" },\n #endif\n   { 0, 0, 0, 0 }\n };\n@@ -1095,40 +1104,10 @@ documented_lang_options[] =\n   { \"-Wno-undef\", \"\" },\n   { \"-Wwrite-strings\", \"Mark strings as 'const char *'\"},\n   { \"-Wno-write-strings\", \"\" },\n-\n-  /* These are for languages with USE_CPPLIB.  */\n-  /* These options are already documented in cpplib.c */\n-  { \"--help\", \"\" },\n-  { \"-A\", \"\" },\n-  { \"-D\", \"\" },\n-  { \"-I\", \"\" },\n-#if USE_CPPLIB\n-  { \"-MD\", \"Print dependencies to FILE.d\" },\n-  { \"-MMD\", \"Print dependencies to FILE.d\" },\n-  { \"-M\", \"Print dependencies to stdout\" },\n-  { \"-MM\", \"Print dependencies to stdout\" },\n-#endif /* USE_CPPLIB */\n-  { \"-U\", \"\" },\n-  { \"-H\", \"\" },\n-  { \"-idirafter\", \"\" },\n-  { \"-imacros\", \"\" },\n-  { \"-include\", \"\" },\n-  { \"-iprefix\", \"\" },\n-  { \"-isystem\", \"\" },\n-  { \"-iwithprefix\", \"\" },\n-  { \"-iwithprefixbefore\", \"\" },\n-  { \"-lang-c\", \"\" },\n-  { \"-lang-c89\", \"\" },\n-  { \"-lang-c++\", \"\" },\n-  { \"-remap\", \"\" },\n-  { \"-nostdinc\", \"\" },\n-  { \"-nostdinc++\", \"\" },\n-  { \"-trigraphs\", \"\" },\n-  { \"-undef\", \"\" },\n   \n #define DEFINE_LANG_NAME(NAME) { NULL, NAME },\n   \n-  /* These are for obj c.  */\n+  /* These are for Objective C.  */\n   DEFINE_LANG_NAME (\"Objective C\")\n   \n   { \"-lang-objc\", \"\" },\n@@ -1911,16 +1890,16 @@ error VPROTO((const char *msgid, ...))\n   va_end (ap);\n }\n \n-/* Report a fatal error at the current line number.   Allow a front end to\n+/* Report a fatal error at the current line number.  Allow a front end to\n    intercept the message.  */\n \n-static void (*fatal_function) PROTO((const char *, va_list));\n+static void (*fatal_function) PROTO ((const char *, va_list));\n \n /* Set the function to call when a fatal error occurs.  */\n \n void\n set_fatal_function (f)\n-     void (*f) PROTO((const char *, va_list));\n+     void (*f) PROTO ((const char *, va_list));\n {\n   fatal_function = f;\n }\n@@ -4516,7 +4495,7 @@ display_help ()\n   for (i = NUM_ELEM (debug_args); i--;)\n     {\n       if (debug_args[i].description != NULL)\n-\tprintf (\"  -%-22s %s\\n\", debug_args[i].arg, debug_args[i].description);\n+\tprintf (\"  -g%-21s %s\\n\", debug_args[i].arg, debug_args[i].description);\n     }\n   \n   printf (\"  -aux-info <file>        Emit declaration info into <file>.X\\n\");\n@@ -4636,74 +4615,569 @@ display_help ()\n \t}\n     }\n }\n+\f\n+/* Parse a -d... comand line switch.  */\n \n-/* Compare the user specified 'option' with the language\n-   specific 'lang_option'.  Return true if they match, or\n-   if 'option' is a viable prefix of 'lang_option'.  */\n+static void\n+decode_d_option (arg)\n+     const char * arg;\n+{\n+  while (* arg)\n+    switch (* arg ++)\n+      {\n+      case 'a':\n+\tbranch_prob_dump = 1;\n+\tcombine_dump = 1;\n+#ifdef DELAY_SLOTS\n+\tdbr_sched_dump = 1;\n+#endif\n+\tflow_dump = 1;\n+\tflow2_dump = 1;\n+\tglobal_reg_dump = 1;\n+\tjump_opt_dump = 1;\n+\taddressof_dump = 1;\n+\tjump2_opt_dump = 1;\n+\tlocal_reg_dump = 1;\n+\tloop_dump = 1;\n+\tregmove_dump = 1;\n+\trtl_dump = 1;\n+\tcse_dump = 1;\n+\tcse2_dump = 1;\n+\tgcse_dump = 1;\n+\tsched_dump = 1;\n+\tsched2_dump = 1;\n+#ifdef STACK_REGS\n+\tstack_reg_dump = 1;\n+#endif\n+#ifdef MACHINE_DEPENDENT_REORG\n+\tmach_dep_reorg_dump = 1;\n+#endif\n+\tpeephole2_dump = 1;\n+\tbreak;\n+      case 'A':\n+\tflag_debug_asm = 1;\n+\tbreak;\n+      case 'b':\n+\tbranch_prob_dump = 1;\n+\tbreak;\n+      case 'c':\n+\tcombine_dump = 1;\n+\tbreak;\n+#ifdef DELAY_SLOTS\n+      case 'd':\n+\tdbr_sched_dump = 1;\n+\tbreak;\n+#endif\n+      case 'f':\n+\tflow_dump = 1;\n+\tbreak;\n+      case 'F':\n+\taddressof_dump = 1;\n+\tbreak;\n+      case 'g':\n+\tglobal_reg_dump = 1;\n+\tbreak;\n+      case 'G':\n+\tgcse_dump = 1;\n+\tbreak;\n+      case 'j':\n+\tjump_opt_dump = 1;\n+\tbreak;\n+      case 'J':\n+\tjump2_opt_dump = 1;\n+\tbreak;\n+#ifdef STACK_REGS\t\t    \n+      case 'k':\n+\tstack_reg_dump = 1;\n+\tbreak;\n+#endif\n+      case 'l':\n+\tlocal_reg_dump = 1;\n+\tbreak;\n+      case 'L':\n+\tloop_dump = 1;\n+\tbreak;\n+      case 'm':\n+\tflag_print_mem = 1;\n+\tbreak;\n+#ifdef MACHINE_DEPENDENT_REORG\n+      case 'M':\n+\tmach_dep_reorg_dump = 1;\n+\tbreak;\n+#endif\n+      case 'p':\n+\tflag_print_asm_name = 1;\n+\tbreak;\n+      case 'r':\n+\trtl_dump = 1;\n+\tbreak;\n+      case 'R':\n+\tsched2_dump = 1;\n+\tbreak;\n+      case 's':\n+\tcse_dump = 1;\n+\tbreak;\n+      case 'S':\n+\tsched_dump = 1;\n+\tbreak;\n+      case 't':\n+\tcse2_dump = 1;\n+\tbreak;\n+      case 'N':\n+\tregmove_dump = 1;\n+\tbreak;\n+      case 'v':\n+\tgraph_dump_format = vcg;\n+\tbreak;\n+      case 'w':\n+\tflow2_dump = 1;\n+\tbreak;\n+      case 'x':\n+\trtl_dump_and_exit = 1;\n+\tbreak;\n+      case 'y':\n+\tset_yydebug (1);\n+\tbreak;\n+      case 'z':\n+\tpeephole2_dump = 1;\n+\tbreak;\n+      case 'D':\t/* These are handled by the preprocessor.  */\n+      case 'I':\n+\tbreak;\n+      default:\n+\twarning (\"unrecognised gcc debugging option: %c\", arg[-1]);\n+\tbreak;\n+      }\n+}\n+\n+/* Parse a -f... comand line switch.  ARG is the value after the -f.\n+   It is safe to access 'ARG - 2' to generate the full switch name.\n+   Return the number of strings consumed.  */\n \n static int\n-check_lang_option (option, lang_option)\n-     const char * option;\n-     const char * lang_option;\n+decode_f_option (arg)\n+     const char * arg;\n {\n-  lang_independent_options * indep_options;\n-  int    len;\n-  long    k;\n-  const char * space;\n-  \n-  /* Ignore NULL entries.  */\n-  if (option == NULL || lang_option == NULL)\n-    return 0;\n+  int j;\n \n-  if ((space = strchr (lang_option, ' ')) != NULL)\n-    len = space - lang_option;\n+  /* Search for the option in the table of binary f options.  */\n+  for (j = sizeof (f_options) / sizeof (f_options[0]); j--;)\n+    {\n+      if (!strcmp (arg, f_options[j].string))\n+\t{\n+\t  *f_options[j].variable = f_options[j].on_value;\n+\t  return 1;\n+\t}\n+    \n+      if (arg[0] == 'n' && arg[1] == 'o' && arg[2] == '-'\n+\t  && ! strcmp (arg + 3, f_options[j].string))\n+\t{\n+\t  *f_options[j].variable = ! f_options[j].on_value;\n+\t  return 1;\n+\t}\n+    }\n+\n+  if (!strncmp (arg, \"inline-limit-\", 13)\n+      || !strncmp (arg, \"inline-limit=\", 13))\n+    inline_max_insns =\n+      read_integral_parameter (arg + 13, arg - 2, inline_max_insns);\n+#ifdef INSN_SCHEDULING\n+  else if (!strncmp (arg, \"sched-verbose=\", 14))\n+    fix_sched_param (\"verbose\", (char *)(arg + 14));\n+#endif\n+  else if (!strncmp (arg, \"fixed-\", 6))\n+    fix_register ((char *)(arg + 6), 1, 1);\n+  else if (!strncmp (arg, \"call-used-\", 10))\n+    fix_register ((char *)(arg + 10), 0, 1);\n+  else if (!strncmp (arg, \"call-saved-\", 11))\n+    fix_register ((char *)(arg + 11), 0, 0);\n+  else if (!strncmp (arg, \"align-loops=\", 12))\n+    align_loops = read_integral_parameter (arg + 12, arg - 2, align_loops);\n+  else if (!strncmp (arg, \"align-functions=\", 16))\n+    align_functions =\n+      read_integral_parameter (arg + 16, arg - 2, align_functions);\n+  else if (!strncmp (arg, \"align-jumps=\", 12))\n+    align_jumps = read_integral_parameter (arg + 12, arg - 2, align_jumps);\n+  else if (!strncmp (arg, \"align-labels=\", 13))\n+    align_labels = read_integral_parameter (arg + 13, arg - 2, align_labels);\n+  else if (!strcmp (arg, \"preprocessed\"))\n+    /* Recognise this switch but do nothing.  This prevents warnings\n+       about an unrecognised switch if cpplib has not been linked in.  */\n+    ;\n   else\n-    len = strlen (lang_option);\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Parse a -W... comand line switch.  ARG is the value after the -W.\n+   It is safe to access 'ARG - 2' to generate the full switch name.\n+   Return the number of strings consumed.  */\n+static int\n+decode_W_option (arg)\n+     const char * arg;\n+{\n+  int j;\n   \n-  /* If they do not match to the first n characters then fail.  */\n-  if (strncmp (option, lang_option, len) != 0)\n+  /* Search for the option in the table of binary W options.  */\n+\n+  for (j = sizeof (W_options) / sizeof (W_options[0]); j--;)\n+    {\n+      if (!strcmp (arg, W_options[j].string))\n+\t{\n+\t  *W_options[j].variable = W_options[j].on_value;\n+\t  return 1;\n+\t}\n+\n+      if (arg[0] == 'n' && arg[1] == 'o' && arg[2] == '-'\n+\t  && ! strcmp (arg + 3, W_options[j].string))\n+\t{\n+\t  *W_options[j].variable = ! W_options[j].on_value;\n+\t  return 1;\n+\t}\n+    }\n+\n+  if (!strncmp (arg, \"id-clash-\", 9))\n+    {\n+      const int id_clash_val = read_integral_parameter (arg + 9, arg - 2, -1);\n+      \n+      if (id_clash_val != -1)\n+\t{\n+\t  id_clash_len = id_clash_val;\n+\t  warn_id_clash = 1;\n+\t}\n+    }\n+  else if (!strncmp (arg, \"larger-than-\", 12))\n+    {\n+      const int larger_than_val =\n+\tread_integral_parameter (arg + 12, arg - 2, -1);\n+      if (larger_than_val != -1)\n+\t{\n+\t  larger_than_size = larger_than_val;\n+\t  warn_larger_than = 1;\n+\t}\n+    }\n+  else\n     return 0;\n+\n+  return 1;\n+}\n+\n+/* Parse a -g... comand line switch.  ARG is the value after the -g.\n+   It is safe to access 'ARG - 2' to generate the full switch name.\n+   Return the number of strings consumed.  */\n+static int\n+decode_g_option (arg)\n+     const char * arg;\n+{\n+  unsigned level;\n+  /* A lot of code assumes write_symbols == NO_DEBUG if the\n+     debugging level is 0 (thus -gstabs1 -gstabs0 would lose track\n+     of what debugging type has been selected).  This records the\n+     selected type.  It is an error to specify more than one\n+     debugging type.  */\n+  static enum debug_info_type selected_debug_type = NO_DEBUG;\n+  /* Non-zero if debugging format has been explicitly set.\n+     -g and -ggdb don't explicitly set the debugging format so\n+     -gdwarf -g3 is equivalent to -gdwarf3.  */\n+  static int type_explicitly_set_p = 0;\n+  /* Indexed by enum debug_info_type.  */\n+  static const char * debug_type_names[] =\n+  {\n+    \"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\"\n+  };\n   \n-  /* Do not accept a lang option, if it matches a normal -f or -W\n-     option.  Chill defines a -fpack, but we want to support\n-     -fpack-struct.  */\n+  /* The maximum admissible debug level value.  */\n+  static const unsigned max_debug_level = 3;\n   \n-  /* An exact match is OK  */\n-  if ((int) strlen (option) == len)\n-    return 1;\n+  /* Look up ARG in the table.  */\n+  for (da = debug_args; da->arg; da++)\n+    {\n+      const int da_len = strlen (da->arg);\n+\n+      if (da_len == 0 || ! strncmp (arg, da->arg, da_len))\n+\t{\n+\t  enum debug_info_type type = da->debug_type;\n+\t  const char * p = arg + da_len;\n+\t  \n+\t  if (*p && (*p < '0' || *p > '9'))\n+\t    continue;\n+\t  \n+\t  /* A debug flag without a level defaults to level 2.\n+\t     Note we do not want to call read_integral_parameter\n+\t     for that case since it will call atoi which \n+\t     will return zero.\n+\t     \n+\t     ??? We may want to generalize the interface to \n+\t     read_integral_parameter to better handle this case\n+\t     if this case shows up often.  */\n+\t  if (*p)\n+\t    level = read_integral_parameter (p, 0, max_debug_level + 1);\n+\t  else\n+\t    level = 2;\n+\t  \n+\t  if (da_len > 1 && *p && !strncmp (arg, \"dwarf\", da_len))\n+\t    {\n+\t      error (\"use -gdwarf -g%d for DWARF v1, level %d\",\n+\t\t     level, level);\n+\t      if (level == 2)\n+\t\terror (\"use -gdwarf-2   for DWARF v2\");\n+\t    }\n+\t  \n+\t  if (level > max_debug_level)\n+\t    {\n+\t      warning (\"\\\n+ignoring option `%s' due to invalid debug level specification\",\n+\t\t       arg - 2);\n+\t      level = debug_info_level;\n+\t    }\n+\n+\t  if (type == NO_DEBUG)\n+\t    {\n+\t      type = PREFERRED_DEBUGGING_TYPE;\n+\t      \n+\t      if (da_len > 1 && strncmp (arg, \"gdb\", da_len) == 0)\n+\t\t{\n+#if defined (DWARF2_DEBUGGING_INFO) && !defined (LINKER_DOES_NOT_WORK_WITH_DWARF2)\n+\t\t  type = DWARF2_DEBUG;\n+#else\n+#ifdef DBX_DEBUGGING_INFO\n+\t\t  type = DBX_DEBUG;\n+#endif\n+#endif\n+\t\t}\n+\t    }\n+\t  \n+\t  if (type == NO_DEBUG)\n+\t    warning (\"`%s' not supported by this configuration of GCC\",\n+\t\t     arg - 2);\n+\n+\t  /* Does it conflict with an already selected type?  */\n+\t  if (type_explicitly_set_p\n+\t      /* -g/-ggdb don't conflict with anything */\n+\t      && da->debug_type != NO_DEBUG\n+\t      && type != selected_debug_type)\n+\t    warning (\"`%s' ignored, conflicts with `-g%s'\",\n+\t\t     arg - 2, debug_type_names[(int) selected_debug_type]);\n+\t  else\n+\t    {\n+\t      /* If the format has already been set, -g/-ggdb\n+\t\t only change the debug level.  */\n+\t      if (type_explicitly_set_p && da->debug_type == NO_DEBUG)\n+\t\t; /* don't change debugging type */\n+\t      else\n+\t\t{\n+\t\t  selected_debug_type = type;\n+\t\t  type_explicitly_set_p = da->debug_type != NO_DEBUG;\n+\t\t}\n+\t      \n+\t      write_symbols = (level == 0\n+\t\t\t       ? NO_DEBUG\n+\t\t\t       : selected_debug_type);\n+\t      use_gnu_debug_info_extensions = da->use_extensions_p;\n+\t      debug_info_level = (enum debug_info_level) level;\n+\t    }\n+\t  \n+\t  break;\n+\t}\n+    }\n   \n-  /* If it is not an -f or -W option allow the match */\n-  if (option[0] != '-')\n-    return 1;\n+  if (! da->arg)\n+    warning (\"`%s' not supported by this configuration of GCC\", arg - 2);\n+\n+  return 1;\n+}\n+\n+/* Decode the first argument in the argv as a language-independent option.\n+   Return the number of strings consumed.  'strings_processed' is the\n+   number of strings that have already been decoded in a language\n+   specific fashion before this function was invoked.  */\n+   \n+static unsigned\n+independent_decode_option (argc, argv, strings_processed)\n+     int argc;\n+     char ** argv;\n+     unsigned strings_processed ATTRIBUTE_UNUSED;\n+{\n+  char * arg = argv[0];\n   \n-  switch (option[1])\n+  if (arg[0] != '-' || arg[1] == 0)\n     {\n-    case 'f': indep_options = f_options; break;\n-    case 'W': indep_options = W_options; break;\n-    default:  return 1;\n+      if (arg[0] == '+')\n+\treturn 0;\n+      \n+      filename = arg;\n+\n+      return 1;\n     }\n+\n+  arg ++;\n   \n-  /* The option is a -f or -W option.\n-     Skip past the prefix and search for the remainder in the\n-     appropriate table of options.  */\n-  option += 2;\n-  \n-  if (option[0] == 'n' && option[1] == 'o' && option[2] == '-')\n-    option += 3;\n+  if (!strcmp (arg, \"-help\"))\n+    {\n+      display_help ();\n+      exit (0);\n+    }\n+\n+  if (* arg == 'Y')\n+    arg ++;\n   \n-  for (k = NUM_ELEM (indep_options); k--;)\n+  switch (* arg)\n     {\n-      if (!strcmp (option, indep_options[k].string))\n+    default:\n+      return 0;\n+      \n+    case 'O':\n+      /* Already been treated in main (). Do nothing.  */\n+      break;\n+\t  \n+    case 'm':\n+      set_target_switch (arg + 1);\n+      break;\n+\n+    case 'f':\n+      return decode_f_option (arg + 1);\n+\t    \n+    case 'g':\n+      return decode_g_option (arg + 1);\n+\n+    case 'd':\n+      if (!strcmp (arg, \"dumpbase\"))\n+\t{\n+\t  if (argc == 1)\n+\t    return 0;\n+\t  \n+\t  dump_base_name = argv[1];\n+\t  return 2;\n+\t}\n+      else\n+\tdecode_d_option (arg + 1);\n+      break;\n+\n+    case 'p':\n+      if (!strcmp (arg, \"pedantic\"))\n+\tpedantic = 1;\n+      else if (!strcmp (arg, \"pedantic-errors\"))\n+\tflag_pedantic_errors = pedantic = 1;\n+      else if (arg[1] == 0)\n+\tprofile_flag = 1;\n+      else\n+\treturn 0;\n+      break;\n+\n+    case 'q':\n+      if (!strcmp (arg, \"quiet\"))\n+\tquiet_flag = 1;\n+      else\n+\treturn 0;\n+      break;\n+\n+    case 'v':\n+      if (!strcmp (arg, \"version\"))\n+\tversion_flag = 1;\n+      else\n+\treturn 0;\n+      break;\n+\n+    case 'w':\n+      if (arg[1] == 0)\n+\tinhibit_warnings = 1;\n+      else\n+\treturn 0;\n+      break;\n+\n+    case 'W':\n+      if (arg[1] == 0)\n+\t{\n+\t  extra_warnings = 1;\n+\t  /* We save the value of warn_uninitialized, since if they put\n+\t     -Wuninitialized on the command line, we need to generate a\n+\t     warning about not using it without also specifying -O.  */\n+\t  if (warn_uninitialized != 1)\n+\t    warn_uninitialized = 2;\n+\t}\n+      else\n+\treturn decode_W_option (arg + 1);\n+      break;\n+\t  \n+    case 'a':\n+      if (arg[1] == 0)\n+\t{\n+#if !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n+\t  warning (\"`-a' option (basic block profile) not supported\");\n+#else\n+\t  profile_block_flag = (profile_block_flag < 2) ? 1 : 3;\n+#endif\n+\t}\n+      else if (!strcmp (arg, \"ax\"))\n+\t{\n+#if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n+\t  warning (\"`-ax' option (jump profiling) not supported\");\n+#else\n+\t  profile_block_flag = (!profile_block_flag \n+\t\t\t\t|| profile_block_flag == 2) ? 2 : 3;\n+#endif\n+\t}\n+      else if (!strncmp (arg, \"aux-info\", 8))\n+\t{\n+\t  flag_gen_aux_info = 1;\n+\t  if (arg[8] == '\\0')\n+\t    {\n+\t      if (argc == 1)\n+\t\treturn 0;\n+\t      \n+\t      aux_info_file_name = argv[1];\n+\t      return 2;\n+\t    }\n+\t  else\n+\t    aux_info_file_name = arg + 8;\n+\t}\n+      else\n+\treturn 0;\n+      break;\n+\n+    case 'o':\n+      if (arg[1] == 0)\n \t{\n-\t  /* The option matched a language independent option,\n-\t     do not allow the language specific match.  */\n+\t  if (argc == 1)\n+\t    return 0;\n \t  \n-\t  return 0;\n+\t  asm_file_name = argv[1];\n+\t  return 2;\n \t}\n+      return 0;\n+\n+    case 'G':\n+      {\n+\tint g_switch_val;\n+\tint return_val;\n+\t    \n+\tif (arg[1] == 0)\n+\t  {\n+\t    if (argc == 1)\n+\t      return 0;\n+\t    \n+\t    g_switch_val = read_integral_parameter (argv[1], 0, -1);\n+\t    return_val = 2;\n+\t  }\n+\telse\n+\t  {\n+\t    g_switch_val = read_integral_parameter (arg + 1, 0, -1);\n+\t    return_val = 1;\n+\t  }\n+\t    \n+\tif (g_switch_val == -1)\n+\t  return_val = 0;\n+\telse\n+\t  {\n+\t    g_switch_set = TRUE;\n+\t    g_switch_value = g_switch_val;\n+\t  }\n+\t    \n+\treturn return_val;\n+      }\n     }\n   \n-  /* The option matches the start of the langauge specific option\n-     and it is not an exact match for a language independent option.  */\n   return 1;\n }\n \f\n@@ -4719,9 +5193,6 @@ main (argc, argv)\n      char **argv;\n {\n   register int i;\n-  char *filename = 0;\n-  int flag_print_mem = 0;\n-  int version_flag = 0;\n   char *p;\n \n   /* save in case md file wants to emit args as a comment.  */\n@@ -4872,480 +5343,30 @@ main (argc, argv)\n   /* Initialize register usage now so switches may override.  */\n   init_reg_sets ();\n \n-  for (i = 1; i < argc; i++)\n+  /* Perform normal command line switch decoding.  */\n+  for (i = 1; i < argc;)\n     {\n-      size_t j;\n+      unsigned lang_processed;\n+      unsigned indep_processed;\n       \n-      /* If this is a language-specific option,\n-\t decode it in a language-specific way.  */\n-      for (j = NUM_ELEM (documented_lang_options); j--;)\n-\tif (check_lang_option (argv[i], documented_lang_options[j].option))\n-\t  break;\n-      \n-      if (j != (size_t)-1)\n-\t{\n-\t  /* If the option is valid for *some* language,\n-\t     treat it as valid even if this language doesn't understand it.  */\n-\t  int strings_processed = lang_decode_option (argc - i, argv + i);\n-\t  \n-\t  if (!strcmp (argv[i], \"--help\"))\n-\t    {\n-\t      display_help ();\n-\t      return (0);\n-\t    }\n-\t  \n-\t  if (strings_processed != 0)\n-\t    i += strings_processed - 1;\n-\t}\n-      else if (argv[i][0] == '-' && argv[i][1] != 0)\n+      /* Give the language a chance to decode the option for itself.  */\n+      lang_processed = lang_decode_option (argc - i, argv + i);\n+ \n+      /* Now see if the option also has a language independent meaning.\n+\t Some options are both language specific and language independent,\n+\t eg --help.  It is possible that there might be options that should\n+\t only be decoded in a language independent way if the were not\n+\t decoded in a langauge specific way, which is why 'lang_processed'\n+\t is passed in.  */\n+      indep_processed = independent_decode_option (argc - i, argv + i, lang_processed);\n+\n+      if (lang_processed || indep_processed)\n+\ti += lang_processed > indep_processed ? lang_processed : indep_processed;\n+      else\n \t{\n-\t  register char *str = argv[i] + 1;\n-\t  if (str[0] == 'Y')\n-\t    str++;\n-\n-\t  if (str[0] == 'm')\n-\t    set_target_switch (&str[1]);\n-\t  else if (!strcmp (str, \"dumpbase\"))\n-\t    {\n-\t      dump_base_name = argv[++i];\n-\t    }\n-\t  else if (str[0] == 'd')\n-\t    {\n-\t      register char *p = &str[1];\n-\t      while (*p)\n-\t\tswitch (*p++)\n-\t\t  {\n- \t\t  case 'a':\n-\t\t    branch_prob_dump = 1;\n- \t\t    combine_dump = 1;\n-#ifdef DELAY_SLOTS\n- \t\t    dbr_sched_dump = 1;\n-#endif\n- \t\t    flow_dump = 1;\n- \t\t    flow2_dump = 1;\n- \t\t    global_reg_dump = 1;\n- \t\t    jump_opt_dump = 1;\n- \t\t    addressof_dump = 1;\n- \t\t    jump2_opt_dump = 1;\n- \t\t    local_reg_dump = 1;\n- \t\t    loop_dump = 1;\n-\t\t    regmove_dump = 1;\n- \t\t    rtl_dump = 1;\n- \t\t    cse_dump = 1, cse2_dump = 1;\n-\t\t    gcse_dump = 1;\n- \t\t    sched_dump = 1;\n- \t\t    sched2_dump = 1;\n-#ifdef STACK_REGS\n-\t\t    stack_reg_dump = 1;\n-#endif\n-#ifdef MACHINE_DEPENDENT_REORG\n-\t\t    mach_dep_reorg_dump = 1;\n-#endif\n-\t\t    peephole2_dump = 1;\n-\t\t    break;\n-\t\t  case 'A':\n-\t\t    flag_debug_asm = 1;\n-\t\t    break;\n-\t\t  case 'b':\n-\t\t    branch_prob_dump = 1;\n-\t\t    break;\n-\t\t  case 'c':\n-\t\t    combine_dump = 1;\n-\t\t    break;\n-#ifdef DELAY_SLOTS\n-\t\t  case 'd':\n-\t\t    dbr_sched_dump = 1;\n-\t\t    break;\n-#endif\n-\t\t  case 'f':\n-\t\t    flow_dump = 1;\n-\t\t    break;\n-\t\t  case 'F':\n-\t\t    addressof_dump = 1;\n-\t\t    break;\n-\t\t  case 'g':\n-\t\t    global_reg_dump = 1;\n-\t\t    break;\n-\t\t  case 'G':\n-\t\t    gcse_dump = 1;\n-\t\t    break;\n-\t\t  case 'j':\n-\t\t    jump_opt_dump = 1;\n-\t\t    break;\n-\t\t  case 'J':\n-\t\t    jump2_opt_dump = 1;\n-\t\t    break;\n-#ifdef STACK_REGS\t\t    \n-\t\t  case 'k':\n-\t\t    stack_reg_dump = 1;\n-\t\t    break;\n-#endif\n-\t\t  case 'l':\n-\t\t    local_reg_dump = 1;\n-\t\t    break;\n-\t\t  case 'L':\n-\t\t    loop_dump = 1;\n-\t\t    break;\n-\t\t  case 'm':\n-\t\t    flag_print_mem = 1;\n-\t\t    break;\n-#ifdef MACHINE_DEPENDENT_REORG\n-\t\t  case 'M':\n-\t\t    mach_dep_reorg_dump = 1;\n-\t\t    break;\n-#endif\n-\t\t  case 'p':\n-\t\t    flag_print_asm_name = 1;\n-\t\t    break;\n-\t\t  case 'r':\n-\t\t    rtl_dump = 1;\n-\t\t    break;\n-\t\t  case 'R':\n-\t\t    sched2_dump = 1;\n-\t\t    break;\n-\t\t  case 's':\n-\t\t    cse_dump = 1;\n-\t\t    break;\n-\t\t  case 'S':\n-\t\t    sched_dump = 1;\n-\t\t    break;\n-\t\t  case 't':\n-\t\t    cse2_dump = 1;\n-\t\t    break;\n-\t\t  case 'N':\n-\t\t    regmove_dump = 1;\n-\t\t    break;\n-\t\t  case 'v':\n-\t\t    graph_dump_format = vcg;\n-\t\t    break;\n-\t\t  case 'w':\n-\t\t    flow2_dump = 1;\n-\t\t    break;\n-\t\t  case 'x':\n-\t\t    rtl_dump_and_exit = 1;\n-\t\t    break;\n-\t\t  case 'y':\n-\t\t    set_yydebug (1);\n-\t\t    break;\n-\t\t  case 'z':\n-\t\t    peephole2_dump = 1;\n-\t\t    break;\n-\t\t  case 'D':\t/* these are handled by the preprocessor */\n-\t\t  case 'I':\n-\t\t    break;\n-\t\t  default:\n-\t\t    warning (\"unrecognised gcc debugging option: %c\", p[-1]);\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t  else if (str[0] == 'f')\n-\t    {\n-\t      register char *p = &str[1];\n-\t      int found = 0;\n-\n-\t      /* Some kind of -f option.\n-\t\t P's value is the option sans `-f'.\n-\t\t Search for it in the table of options.  */\n-\n-\t      for (j = 0;\n-\t\t   !found && j < sizeof (f_options) / sizeof (f_options[0]);\n-\t\t   j++)\n-\t\t{\n-\t\t  if (!strcmp (p, f_options[j].string))\n-\t\t    {\n-\t\t      *f_options[j].variable = f_options[j].on_value;\n-\t\t      /* A goto here would be cleaner,\n-\t\t\t but breaks the vax pcc.  */\n-\t\t      found = 1;\n-\t\t    }\n-\t\t  if (p[0] == 'n' && p[1] == 'o' && p[2] == '-'\n-\t\t      && ! strcmp (p+3, f_options[j].string))\n-\t\t    {\n-\t\t      *f_options[j].variable = ! f_options[j].on_value;\n-\t\t      found = 1;\n-\t\t    }\n-\t\t}\n-\n-\t      if (found)\n-\t\t;\n-\t      else if (!strncmp (p, \"inline-limit-\", 13)\n-\t\t       || !strncmp (p, \"inline-limit=\", 13))\n-\t        inline_max_insns =\n-\t\t  read_integral_parameter (p + 13, p - 2, inline_max_insns);\n-#ifdef INSN_SCHEDULING\n-\t      else if (!strncmp (p, \"sched-verbose=\",14))\n-\t\tfix_sched_param(\"verbose\",&p[14]);\n-#endif\n-\t      else if (!strncmp (p, \"fixed-\", 6))\n-\t\tfix_register (&p[6], 1, 1);\n-\t      else if (!strncmp (p, \"call-used-\", 10))\n-\t\tfix_register (&p[10], 0, 1);\n-\t      else if (!strncmp (p, \"call-saved-\", 11))\n-\t\tfix_register (&p[11], 0, 0);\n-\t      else if (!strncmp (p, \"align-loops=\", 12))\n-\t\talign_loops = read_integral_parameter (p + 12, p - 2,\n-\t\t\t\t\t\t       align_loops);\n-\t      else if (!strncmp (p, \"align-functions=\", 16))\n-\t\talign_functions = read_integral_parameter (p + 16, p - 2,\n-\t\t\t\t\t\t       align_functions);\n-\t      else if (!strncmp (p, \"align-jumps=\", 12))\n-\t\talign_jumps = read_integral_parameter (p + 12, p - 2,\n-\t\t\t\t\t\t       align_jumps);\n-\t      else if (!strncmp (p, \"align-labels=\", 13))\n-\t\talign_labels = read_integral_parameter (p + 13, p - 2,\n-\t\t\t\t\t\t\talign_labels);\n-\t      else\n-\t\terror (\"Invalid option `%s'\", argv[i]);\n-\t    }\n-\t  else if (str[0] == 'O')\n-\t    {\n-\t      /* Already been treated above. Do nothing.  */\n-\t    }\n-\t  else if (!strcmp (str, \"pedantic\"))\n-\t    pedantic = 1;\n-\t  else if (!strcmp (str, \"pedantic-errors\"))\n-\t    flag_pedantic_errors = pedantic = 1;\n-\t  else if (!strcmp (str, \"quiet\"))\n-\t    quiet_flag = 1;\n-\t  else if (!strcmp (str, \"version\"))\n-\t    version_flag = 1;\n-\t  else if (!strcmp (str, \"w\"))\n-\t    inhibit_warnings = 1;\n-\t  else if (!strcmp (str, \"W\"))\n-\t    {\n-\t      extra_warnings = 1;\n-\t      /* We save the value of warn_uninitialized, since if they put\n-\t\t -Wuninitialized on the command line, we need to generate a\n-\t\t warning about not using it without also specifying -O.  */\n-\t      if (warn_uninitialized != 1)\n-\t\twarn_uninitialized = 2;\n-\t    }\n-\t  else if (str[0] == 'W')\n-\t    {\n-\t      register char *p = &str[1];\n-\t      int found = 0;\n-\n-\t      /* Some kind of -W option.\n-\t\t P's value is the option sans `-W'.\n-\t\t Search for it in the table of options.  */\n-\n-\t      for (j = 0;\n-\t\t   !found && j < sizeof (W_options) / sizeof (W_options[0]);\n-\t\t   j++)\n-\t\t{\n-\t\t  if (!strcmp (p, W_options[j].string))\n-\t\t    {\n-\t\t      *W_options[j].variable = W_options[j].on_value;\n-\t\t      /* A goto here would be cleaner,\n-\t\t\t but breaks the vax pcc.  */\n-\t\t      found = 1;\n-\t\t    }\n-\t\t  if (p[0] == 'n' && p[1] == 'o' && p[2] == '-'\n-\t\t      && ! strcmp (p+3, W_options[j].string))\n-\t\t    {\n-\t\t      *W_options[j].variable = ! W_options[j].on_value;\n-\t\t      found = 1;\n-\t\t    }\n-\t\t}\n-\n-\t      if (found)\n-\t\t;\n-\t      else if (!strncmp (p, \"id-clash-\", 9))\n-\t\t{\n-\t\t  const int id_clash_val\n-\t\t    = read_integral_parameter (p + 9, p - 2, -1);\n-\t\t  if (id_clash_val != -1)\n-\t\t    {\n-\t\t      id_clash_len = id_clash_val;\n-\t\t      warn_id_clash = 1;\n-\t\t    }\n-\t\t}\n-\t      else if (!strncmp (p, \"larger-than-\", 12))\n-\t\t{\n-\t\t  const int larger_than_val\n-\t\t    = read_integral_parameter (p + 12, p - 2, -1);\n-\t\t  if (larger_than_val != -1)\n-\t\t    {\n-\t\t      larger_than_size = larger_than_val;\n-\t\t      warn_larger_than = 1;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\terror (\"Invalid option `%s'\", argv[i]);\n-\t    }\n-\t  else if (!strcmp (str, \"p\"))\n-\t    {\n-\t      profile_flag = 1;\n-\t    }\n-\t  else if (!strcmp (str, \"a\"))\n-\t    {\n-#if !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n-\t      warning (\"`-a' option (basic block profile) not supported\");\n-#else\n-              profile_block_flag = (profile_block_flag < 2) ? 1 : 3;\n-#endif\n-\t    }\n-\t  else if (!strcmp (str, \"ax\"))\n-\t    {\n-#if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n-\t      warning (\"`-ax' option (jump profiling) not supported\");\n-#else\n-\t      profile_block_flag = (!profile_block_flag \n-\t                               || profile_block_flag == 2) ? 2 : 3;\n-#endif\n-\t    }\n-\t  else if (str[0] == 'g')\n-\t    {\n-\t      unsigned level;\n-\t      /* A lot of code assumes write_symbols == NO_DEBUG if the\n-\t\t debugging level is 0 (thus -gstabs1 -gstabs0 would lose track\n-\t\t of what debugging type has been selected).  This records the\n-\t\t selected type.  It is an error to specify more than one\n-\t\t debugging type.  */\n-\t      static enum debug_info_type selected_debug_type = NO_DEBUG;\n-\t      /* Non-zero if debugging format has been explicitly set.\n-\t\t -g and -ggdb don't explicitly set the debugging format so\n-\t\t -gdwarf -g3 is equivalent to -gdwarf3.  */\n-\t      static int type_explicitly_set_p = 0;\n-\t      /* Indexed by enum debug_info_type.  */\n-\t      static const char *debug_type_names[] =\n-\t      {\n-\t\t\"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\"\n-\t      };\n-\n-\t      /* The maximum admissible debug level value.  */\n-\t      static const unsigned max_debug_level = 3;\n-\n-\t      /* Look up STR in the table.  */\n-\t      for (da = debug_args; da->arg; da++)\n-\t\t{\n-\t\t  const int da_len = strlen (da->arg);\n-\n-\t\t  if (! strncmp (str, da->arg, da_len))\n-\t\t    {\n-\t\t      enum debug_info_type type = da->debug_type;\n-\t\t      const char *p = str + da_len;\n-\n-\t\t      if (*p && (*p < '0' || *p > '9'))\n-\t\t\tcontinue;\n-\t\t      \n-\t\t      /* A debug flag without a level defaults to level 2.\n-\t\t\t Note we do not want to call read_integral_parameter\n-\t\t\t for that case since it will call atoi which \n-\t\t\t will return zero.\n-\n-\t\t\t ??? We may want to generalize the interface to \n-\t\t\t read_integral_parameter to better handle this case\n-\t\t\t if this case shows up often.  */\n-\t\t      if (*p)\n-\t\t\tlevel = read_integral_parameter (p, 0,\n-\t\t\t\t\t\t\t max_debug_level + 1);\n-\t\t      else\n-\t\t\tlevel = 2;\n-\n-\t\t      if (da_len > 1 && *p && !strncmp (str, \"gdwarf\", da_len))\n-\t\t\t{\n-\t\t\t  error (\"use -gdwarf -g%d for DWARF v1, level %d\",\n-\t\t\t\t level, level);\n-\t\t\t  if (level == 2)\n-\t\t\t    error (\"use -gdwarf-2   for DWARF v2\");\n-\t\t\t}\n-\n-\t\t      if (level > max_debug_level)\n-\t\t\t{\n-\t\t\t  warning (\"ignoring option `%s' due to invalid debug level specification\",\n-\t\t\t\t   str - 1);\n-\t\t\t  level = debug_info_level;\n-\t\t\t}\n-\n-\t\t      if (type == NO_DEBUG)\n-\t\t\t{\n-\t\t\t  type = PREFERRED_DEBUGGING_TYPE;\n-\t\t\t  if (da_len > 1 && strncmp (str, \"ggdb\", da_len) == 0)\n-\t\t\t    {\n-#if defined (DWARF2_DEBUGGING_INFO) && !defined (LINKER_DOES_NOT_WORK_WITH_DWARF2)\n-\t\t\t      type = DWARF2_DEBUG;\n-#else\n-#ifdef DBX_DEBUGGING_INFO\n-\t\t\t      type = DBX_DEBUG;\n-#endif\n-#endif\n-\t\t\t    }\n-\t\t\t}\n-\n-\t\t      if (type == NO_DEBUG)\n-\t\t\twarning (\"`-%s' not supported by this configuration of GCC\",\n-\t\t\t\t str);\n-\n-\t\t      /* Does it conflict with an already selected type?  */\n-\t\t      if (type_explicitly_set_p\n-\t\t\t  /* -g/-ggdb don't conflict with anything */\n-\t\t\t  && da->debug_type != NO_DEBUG\n-\t\t\t  && type != selected_debug_type)\n-\t\t\twarning (\"`-%s' ignored, conflicts with `-g%s'\",\n-\t\t\t\t str, debug_type_names[(int) selected_debug_type]);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* If the format has already been set, -g/-ggdb\n-\t\t\t     only change the debug level.  */\n-\t\t\t  if (type_explicitly_set_p\n-\t\t\t      && da->debug_type == NO_DEBUG)\n-\t\t\t    ; /* don't change debugging type */\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      selected_debug_type = type;\n-\t\t\t      type_explicitly_set_p = da->debug_type != NO_DEBUG;\n-\t\t\t    }\n-\t\t\t  write_symbols = (level == 0\n-\t\t\t\t\t   ? NO_DEBUG\n-\t\t\t\t\t   : selected_debug_type);\n-\t\t\t  use_gnu_debug_info_extensions = da->use_extensions_p;\n-\t\t\t  debug_info_level = (enum debug_info_level) level;\n-\t\t\t}\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (! da->arg)\n-\t\twarning (\"`-%s' not supported by this configuration of GCC\",\n-\t\t\t str);\n-\t    }\n-\t  else if (!strcmp (str, \"o\"))\n-\t    {\n-\t      asm_file_name = argv[++i];\n-\t    }\n-\t  else if (str[0] == 'G')\n-\t    {\n-\t      const int g_switch_val = (str[1] != '\\0') ?\n-\t                               read_integral_parameter(str + 1, 0, -1) :\n-\t\t\t               read_integral_parameter(argv[++i], 0, -1);\n-\t      \n-\t      if (g_switch_val != -1)\n-\t        {\n-\t\t  g_switch_set = TRUE;\n-\t\t  g_switch_value = g_switch_val;\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  error(\"Invalid option `-%s'\",str);\n-\t\t}\n-\t    }\n-\t  else if (!strncmp (str, \"aux-info\", 8))\n-\t    {\n-\t      flag_gen_aux_info = 1;\n-\t      aux_info_file_name = (str[8] != '\\0' ? str+8 : argv[++i]);\n-\t    }\n-\t  else if (!strcmp (str, \"-help\"))\n-\t    {\n-\t      display_help ();\n-\t      return (0);\n-\t    }\n-\t  else\n-\t    error (\"Invalid option `%s'\", argv[i]);\n+\t  error (\"Invalid option `%s'\", argv[i]);\n+\t  i++;\n \t}\n-      else if (argv[i][0] == '+')\n-\terror (\"Invalid option `%s'\", argv[i]);\n-      else\n-\tfilename = argv[i];\n     }\n \n   /* Checker uses the frame pointer.  */"}]}