{"sha": "0214010c60e8777e7f40e3b63c158134af301525", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxNDAxMGM2MGU4Nzc3ZTdmNDBlM2I2M2MxNTgxMzRhZjMwMTUyNQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-01-30T09:18:51Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-01-30T09:18:51Z"}, "message": "Preliminary named locales.\n\n\n2001-01-29  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPreliminary named locales.\n\t* acinclude.m4 (GLIBCPP_ENABLE_CLOCALE): New macro.\n\t* aclocal.m4: Regenerate.\n\t* configure.in: Use it.\n\t* configure: Regerate.\n\t* src/Makefile.am (sources): Add c++locale.cc.\n\t(build_headers): Add c++locale.h.\n\t* src/Makefile.in: Regenerate.\n\t* config/c_locale_gnu.h: New file.\n\t* config/c_locale_gnu.cc: New file. Non-inline member functions\n\tfor named locales, gnu-specific.\n\t* config/c_locale_generic.h: New file.\n\t* config/c_locale_generic.cc: New file. Non-inline member\n\tfunctions for named locales, generic version.\n\t* docs/html/configopts.html: Add documentation on new options.\n\n\t* include/bits/locale_facets.h (class _Messages): Remove.\n\t(class _Moneypunct): Remove.\n\t* src/locale-inst.cc: Remove.\n\n\t* include/bits/locale_facets.h (class _Collate): Remove.\n\t* src/locale-inst.cc (std): Remove.\n\t* src/locale.cc: And here.\n\n\t* include/bits/localefwd.h (locale::_M_coalesce): New\n\tfunction. Correctly put together multi-name locales.\n\t(_Impl(const _Impl&, category, size_t)): Remove.\n\n\t* include/bits/localefwd.h (locale::_Impl): Remove _M_construct_*\n\tmember functions.\n\t(_M_normalize_category_names): Remove.\n\t(_M_replace_categories): Fix.\n\n\t* src/localename.cc (locale::_Impl::_M_construct_collate): Remove.\n\t(locale::_Impl::_M_construct_ctype): Remove.\n\t(locale::_Impl::_M_construct_monetary): Remove.\n\t(locale::_Impl::_M_construct_numeric): Remove.\n\t(locale::_Impl::_M_construct_time): Remove.\n\t(locale::_Impl::_M_construct_messages): Remove.\n\n\t* include/bits/locale_facets.h (_Bad_use_facet): Remove.\n\t(_Use_facet_failure_handle): Remove.\n\t* src/locale.cc: Remove definitions.\n\t* src/locale-inst.cc: And here.\n\n\t* testsuite/22_locale/ctor_copy_dtor.cc (test01): Fixup. Add tests.\n\n\t* src/localename.cc (locale::facet::_S_create_c_locale): Properly\n\tcreate and error-check underlying locale object.\n\t(locale::facet::_S_destroy_c_locale): Add, take care of properly\n\ttearing down underlying locale object.\n\t* include/bits/localefwd.h (locale::facet): Declare.\n\t* testsuite/22_locale/members.cc: Don't test \"fr_FR\" locale for\n\tcorrectness, as glibc apparently has incorrect info in it. Test\n\twith it when it works again.....\n\n\t* include/bits/localefwd.h (locale::_Impl::__vec_string):\n\tRemove. Number of categories is fixed at six, so just simplify and\n\tmake this an array of strings.\n\t(locale::_Impl::_M_has_name): Remove.\n\t(locale::_Impl::_M_name): Remove.\n\t(locale::_Impl::_M_category_names): Turns into...\n\t(locale::_Impl::_M_names): ...this.\n\t(locale::_Impl::_M_has_same_name()): New function.\n\t* src/localename.cc (locale::_Impl::~_Impl()): Remove here.\n\t(locale::_Impl::_Impl(size_t __refs, string __str)): Simplify\n\tsignature.\n\t* src/locale.cc (locale::name()): Construct mangled name\n\taccurately reflecting combined locale categories.\n\n\t* src/locale.cc (locale::classic()): Don't initialize here.\n\t* src/localename.cc (locale::_Impl::_Impl(size_t __num, size_t\n\t__refs, bool __has_name, string __str): Do it here.\n\n\t* include/bits/localefwd.h: _S_categories_num to\n\t_S_num_categories. _S_facets_num to _S_num_facets.\n\t(locale::id::id()): Explicitly set _M_index to zero.\n\t* src/locale.cc: Same.\n\n\t* src/locale.cc: (locale::locale(const char*)): Construct named\n\tlocales uniquely.\n\n\t* src/locale.cc: Remove numpunct_byname ctors.\n\t* testsuite/22_locale/numpunct_byname.cc: New file.\n\t* testsuite/22_locale/numpunct.cc: New file.\n\n\t* include/bits/localefwd.h (class locale): Change data members to\n\tprotected, from private.\n\t(_Impl::_M_get_c_locale): Add member function.\n\t(locale::facet::_M_get_global_impl()): Add member function.\n\t* include/bits/locale_facets.h (numpunct::_M_init): Change to take\n\ta __c_locale pointer.\n\t(numpunct::numpunct( __c_locale*, size_t)): Add additonal ctor for\n\tnamed locales.\n\t* testsuite/22_locale/members.cc: New file, test name and combine.\n\n\t* include/bits/locale_facets.h (class numpunct): Remove class\n\t_Punct and _Numpunct. Rewrite class numpunct to be correct for\n\tnamed locales.\n\t* include/bits/localefwd.h (locale::_Imp::_M_c_locale): Add.\n\t* src/localename.cc (_Impl::~_Impl()): Call __frelocale.\n\t(_Imp::_Impl(size_t, size_t, bool, string)) Initialize _M_c_locale.\n\t* src/locale-inst.cc: Remove _Numpunct, _Punct instantiations.\n\t* testsuite/22_locale/numpunct_char_members.cc: New file.\n\nFrom-SVN: r39347", "tree": {"sha": "f4cd5b7db4af6680ea3aecdacddb39448df7480b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4cd5b7db4af6680ea3aecdacddb39448df7480b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0214010c60e8777e7f40e3b63c158134af301525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0214010c60e8777e7f40e3b63c158134af301525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0214010c60e8777e7f40e3b63c158134af301525", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0214010c60e8777e7f40e3b63c158134af301525/comments", "author": null, "committer": null, "parents": [{"sha": "f25561bb8c3f9381d6b03af546a8a2a599274aed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25561bb8c3f9381d6b03af546a8a2a599274aed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f25561bb8c3f9381d6b03af546a8a2a599274aed"}], "stats": {"total": 4590, "additions": 2813, "deletions": 1777}, "files": [{"sha": "a39058d1706d9cfb744a21c0bc27d73a65803977", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,3 +1,110 @@\n+2001-01-29  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPreliminary named locales.\n+\t* acinclude.m4 (GLIBCPP_ENABLE_CLOCALE): New macro.\n+\t* aclocal.m4: Regenerate.\n+\t* configure.in: Use it.\n+\t* configure: Regerate.\n+\t* src/Makefile.am (sources): Add c++locale.cc.\n+\t(build_headers): Add c++locale.h.\n+\t* src/Makefile.in: Regenerate.\n+\t* config/c_locale_gnu.h: New file. \t\n+\t* config/c_locale_gnu.cc: New file. Non-inline member functions\n+\tfor named locales, gnu-specific.\n+\t* config/c_locale_generic.h: New file. \t\t\n+\t* config/c_locale_generic.cc: New file. Non-inline member\n+\tfunctions for named locales, generic version.\n+\t* docs/html/configopts.html: Add documentation on new options.\n+\n+\t* include/bits/locale_facets.h (class _Messages): Remove.\n+\t(class _Moneypunct): Remove.\n+\t* src/locale-inst.cc: Remove.\n+\t\n+\t* include/bits/locale_facets.h (class _Collate): Remove.\n+\t* src/locale-inst.cc (std): Remove.\n+\t* src/locale.cc: And here.\n+\t\n+\t* include/bits/localefwd.h (locale::_M_coalesce): New\n+\tfunction. Correctly put together multi-name locales.\n+\t(_Impl(const _Impl&, category, size_t)): Remove.\n+\n+\t* include/bits/localefwd.h (locale::_Impl): Remove _M_construct_*\n+\tmember functions.\n+\t(_M_normalize_category_names): Remove.\n+\t(_M_replace_categories): Fix.\n+\n+\t* src/localename.cc (locale::_Impl::_M_construct_collate): Remove.\n+\t(locale::_Impl::_M_construct_ctype): Remove.\n+\t(locale::_Impl::_M_construct_monetary): Remove.\t\n+\t(locale::_Impl::_M_construct_numeric): Remove.\t\n+\t(locale::_Impl::_M_construct_time): Remove.\t\t\n+\t(locale::_Impl::_M_construct_messages): Remove.\t\t\n+\n+\t* include/bits/locale_facets.h (_Bad_use_facet): Remove.\n+\t(_Use_facet_failure_handle): Remove.\n+\t* src/locale.cc: Remove definitions.\n+\t* src/locale-inst.cc: And here.\n+\t\n+\t* testsuite/22_locale/ctor_copy_dtor.cc (test01): Fixup. Add tests.\n+\n+\t* src/localename.cc (locale::facet::_S_create_c_locale): Properly\n+\tcreate and error-check underlying locale object.\n+\t(locale::facet::_S_destroy_c_locale): Add, take care of properly\n+\ttearing down underlying locale object.\n+\t* include/bits/localefwd.h (locale::facet): Declare.\n+\t* testsuite/22_locale/members.cc: Don't test \"fr_FR\" locale for\n+\tcorrectness, as glibc apparently has incorrect info in it. Test\n+\twith it when it works again.....\t\n+\n+\t* include/bits/localefwd.h (locale::_Impl::__vec_string):\n+\tRemove. Number of categories is fixed at six, so just simplify and\n+\tmake this an array of strings.\n+\t(locale::_Impl::_M_has_name): Remove.\n+\t(locale::_Impl::_M_name): Remove.\t\n+\t(locale::_Impl::_M_category_names): Turns into...\t\n+\t(locale::_Impl::_M_names): ...this.\n+\t(locale::_Impl::_M_has_same_name()): New function.\n+\t* src/localename.cc (locale::_Impl::~_Impl()): Remove here.\n+\t(locale::_Impl::_Impl(size_t __refs, string __str)): Simplify\n+\tsignature.\n+\t* src/locale.cc (locale::name()): Construct mangled name\n+\taccurately reflecting combined locale categories.\n+\n+\t* src/locale.cc (locale::classic()): Don't initialize here.\n+\t* src/localename.cc (locale::_Impl::_Impl(size_t __num, size_t\n+\t__refs, bool __has_name, string __str): Do it here.\n+\n+\t* include/bits/localefwd.h: _S_categories_num to\n+\t_S_num_categories. _S_facets_num to _S_num_facets.\n+\t(locale::id::id()): Explicitly set _M_index to zero.\n+\t* src/locale.cc: Same.\n+\n+\t* src/locale.cc: (locale::locale(const char*)): Construct named\n+\tlocales uniquely.\n+\n+\t* src/locale.cc: Remove numpunct_byname ctors.\n+\t* testsuite/22_locale/numpunct_byname.cc: New file.\n+\t* testsuite/22_locale/numpunct.cc: New file.\t\n+\t\n+\t* include/bits/localefwd.h (class locale): Change data members to\n+\tprotected, from private.\n+\t(_Impl::_M_get_c_locale): Add member function.\n+\t(locale::facet::_M_get_global_impl()): Add member function.\n+\t* include/bits/locale_facets.h (numpunct::_M_init): Change to take\n+\ta __c_locale pointer.\n+\t(numpunct::numpunct( __c_locale*, size_t)): Add additonal ctor for\n+\tnamed locales.\n+\t* testsuite/22_locale/members.cc: New file, test name and combine.\n+\t\n+\t* include/bits/locale_facets.h (class numpunct): Remove class\n+\t_Punct and _Numpunct. Rewrite class numpunct to be correct for\n+\tnamed locales.\n+\t* include/bits/localefwd.h (locale::_Imp::_M_c_locale): Add.\n+\t* src/localename.cc (_Impl::~_Impl()): Call __frelocale.\n+\t(_Imp::_Impl(size_t, size_t, bool, string)) Initialize _M_c_locale.\n+\t* src/locale-inst.cc: Remove _Numpunct, _Punct instantiations.\n+\t* testsuite/22_locale/numpunct_char_members.cc: New file.\n+\t\n 2001-01-28  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* testsuite/README: Add more comment."}, {"sha": "cb8a64a7a2ea073c26039cbd42afe5aaf36ba280", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1054,6 +1054,51 @@ AC_SUBST(EXTRA_CXX_FLAGS)\n ])\n \n \n+dnl\n+dnl Check for which locale library to use:  gnu or generic.\n+dnl\n+dnl GLIBCPP_ENABLE_CLOCALE\n+dnl --enable-clocale=gnu sets config/c_locale_gnu.cc and friends\n+dnl --enable-clocale=generic sets config/c_locale_generic.cc and friends\n+dnl \n+dnl default is generic\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_CLOCALE, [\n+  AC_MSG_CHECKING([for clocale to use])\n+  AC_ARG_ENABLE(clocale,\n+  [  --enable-clocale       enable model for target locale package. \n+     --enable-clocale=MODEL use MODEL target-speific locale package. [default=generic]\n+  ], \n+  if test x$enable_clocale = xno; then\n+     enable_clocale=generic\n+  fi,\n+     enable_clocale=generic)\n+\n+  enable_clocale_flag=$enable_clocale\n+\n+  dnl Check if a valid locale package\n+  case x${enable_clocale_flag} in\n+    xgnu)\n+      CLOCALE_H=config/c_locale_gnu.h\n+      CLOCALE_CC=config/c_locale_gnu.cc\n+      AC_MSG_RESULT(gnu)\n+      ;;\n+    xgeneric)\n+      CLOCALE_H=config/c_locale_generic.h\n+      CLOCALE_CC=config/c_locale_generic.cc\n+      AC_MSG_RESULT(generic)\n+      ;;\n+    *)\n+      echo \"$enable_clocale is an unknown locale package\" 1>&2\n+      exit 1\n+      ;;\n+  esac\n+\n+  AC_LINK_FILES($CLOCALE_H, include/bits/c++locale.h)\n+  AC_LINK_FILES($CLOCALE_CC, src/c++locale.cc)\n+])\n+\n+\n dnl\n dnl Check for which I/O library to use:  libio, or something specific.\n dnl"}, {"sha": "025637166862190eedd83160f8694fc3f220fff5", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1066,6 +1066,51 @@ AC_SUBST(EXTRA_CXX_FLAGS)\n ])\n \n \n+dnl\n+dnl Check for which locale library to use:  gnu or generic.\n+dnl\n+dnl GLIBCPP_ENABLE_CLOCALE\n+dnl --enable-clocale=gnu sets config/c_locale_gnu.cc and friends\n+dnl --enable-clocale=generic sets config/c_locale_generic.cc and friends\n+dnl \n+dnl default is generic\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_CLOCALE, [\n+  AC_MSG_CHECKING([for clocale to use])\n+  AC_ARG_ENABLE(clocale,\n+  [  --enable-clocale       enable model for target locale package. \n+     --enable-clocale=MODEL use MODEL target-speific locale package. [default=generic]\n+  ], \n+  if test x$enable_clocale = xno; then\n+     enable_clocale=generic\n+  fi,\n+     enable_clocale=generic)\n+\n+  enable_clocale_flag=$enable_clocale\n+\n+  dnl Check if a valid locale package\n+  case x${enable_clocale_flag} in\n+    xgnu)\n+      CLOCALE_H=config/c_locale_gnu.h\n+      CLOCALE_CC=config/c_locale_gnu.cc\n+      AC_MSG_RESULT(gnu)\n+      ;;\n+    xgeneric)\n+      CLOCALE_H=config/c_locale_generic.h\n+      CLOCALE_CC=config/c_locale_generic.cc\n+      AC_MSG_RESULT(generic)\n+      ;;\n+    *)\n+      echo \"$enable_clocale is an unknown locale package\" 1>&2\n+      exit 1\n+      ;;\n+  esac\n+\n+  AC_LINK_FILES($CLOCALE_H, include/bits/c++locale.h)\n+  AC_LINK_FILES($CLOCALE_CC, src/c++locale.cc)\n+])\n+\n+\n dnl\n dnl Check for which I/O library to use:  libio, or something specific.\n dnl"}, {"sha": "3cfeb3c8b84f3824a75a7d0c5dcdb20d64ba329d", "filename": "libstdc++-v3/config/c_locale_generic.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_generic.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,108 @@\n+// Wrapper for underlying C-language localization -*- C++ -*-\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.8  Standard locale categories.\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+\n+#include <locale>\n+#include <langinfo.h>\n+\n+namespace std \n+{\n+  void\n+  locale::facet::_S_create_c_locale(__c_locale& /*__cloc*/, const char*)\n+  { }\n+\n+  void\n+  locale::facet::_S_destroy_c_locale(__c_locale& /*__cloc*/)\n+  { }\n+\n+  template<> \n+    void\n+    numpunct<char>::_M_initialize_numpunct(__c_locale /*__cloc*/)\n+    {\n+      // \"C\" locale\n+      _M_decimal_point = '.';\n+      _M_thousands_sep = ',';\n+      _M_grouping = \"\";\n+      _M_truename = \"true\";\n+      _M_falsename = \"false\";\n+    }\n+      \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    void\n+    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale /*__cloc*/)\n+    {\n+      // \"C\" locale\n+      _M_decimal_point = L'.';\n+      _M_thousands_sep = L',';\n+      _M_grouping = \"\";\n+      _M_truename = L\"true\";\n+      _M_falsename = L\"false\";\n+    }\n+#endif\n+\n+  template<> \n+    void\n+    moneypunct<char>::_M_initialize_moneypunct(__c_locale /*__cloc*/)\n+    {\n+      // \"C\" locale\n+      _M_decimal_point = '.';\n+      _M_thousands_sep = ',';\n+      _M_grouping = \"\";\n+      _M_curr_symbol = string_type();\n+      _M_positive_sign = string_type();\n+      _M_negative_sign = string_type();\n+      _M_frac_digits = 0;\n+      _M_pos_format = money_base::_S_default_pattern;\n+      _M_neg_format = money_base::_S_default_pattern;\n+    }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    void\n+    moneypunct<wchar_t>::_M_initialize_moneypunct(__c_locale /*__cloc*/)\n+    {\n+      // \"C\" locale\n+      _M_decimal_point = L'.';\n+      _M_thousands_sep = L',';\n+      _M_grouping = \"\";\n+      _M_curr_symbol = string_type();\n+      _M_positive_sign = string_type();\n+      _M_negative_sign = string_type();\n+      _M_frac_digits = 0;\n+      _M_pos_format = money_base::_S_default_pattern;\n+      _M_neg_format = money_base::_S_default_pattern;\n+    }\n+#endif\n+}  // namespace std"}, {"sha": "4c205297f563b999bdd037f7b0c0873db96ae53c", "filename": "libstdc++-v3/config/c_locale_generic.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_generic.h?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,39 @@\n+// Wrapper for underlying C-language localization -*- C++ -*-\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.8  Standard locale categories.\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+\n+namespace std\n+{\n+  typedef int*\t\t\t__c_locale;\n+}"}, {"sha": "4013941cfb8244adb7241e5387851cd4014ceb52", "filename": "libstdc++-v3/config/c_locale_gnu.cc", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_gnu.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_gnu.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_gnu.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,204 @@\n+// Wrapper for underlying C-language localization -*- C++ -*-\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.8  Standard locale categories.\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+\n+#include <locale>\n+#include <stdexcept>\n+#include <langinfo.h>\n+\n+namespace std \n+{\n+  void\n+  locale::facet::_S_create_c_locale(__c_locale& __cloc, const char* __s)\n+  {\n+    // XXX\n+    // perhaps locale::categories could be made equivalent to LC_*_MASK\n+    //    _M_c_locale = __newlocale(1 << LC_ALL, __str.c_str(), NULL);\n+    //    _M_c_locale = __newlocale(locale::all, __str.c_str(), NULL);\n+    __cloc = __newlocale(LC_ALL, __s, NULL);\n+    if (!__cloc)\n+      {\n+\t// This named locale is not supported by the underlying OS.\n+\tthrow runtime_error(\"attempt to create locale from unknown name\");\n+      }\n+  }\n+  \n+  void\n+  locale::facet::_S_destroy_c_locale(__c_locale& __cloc)\n+  {\n+    if (__cloc)\n+      __freelocale(__cloc); \n+  }\n+\n+  template<> \n+    void\n+    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc)\n+    {\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_decimal_point = '.';\n+\t  _M_thousands_sep = ',';\n+\t  _M_grouping = \"\";\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  _M_decimal_point = *(__nl_langinfo_l(RADIXCHAR, __cloc));\n+\t  _M_thousands_sep = *(__nl_langinfo_l(THOUSEP, __cloc));\n+\t  _M_grouping = __nl_langinfo_l(GROUPING, __cloc);\n+\t}\n+      // NB: There is no way to extact this info from posix locales.\n+      // _M_truename = __nl_langinfo_l(YESSTR, __cloc);\n+      _M_truename = \"true\";\n+      // _M_falsename = __nl_langinfo_l(NOSTR, __cloc);\n+      _M_falsename = \"false\";\n+    }\n+      \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    void\n+    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc)\n+    {\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_decimal_point = L'.';\n+\t  _M_thousands_sep = L',';\n+\t  _M_grouping = \"\";\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  _M_decimal_point = reinterpret_cast<wchar_t>(__nl_langinfo_l(_NL_NUMERIC_DECIMAL_POINT_WC, __cloc));\n+\t  _M_thousands_sep = reinterpret_cast<wchar_t>(__nl_langinfo_l(_NL_NUMERIC_THOUSANDS_SEP_WC,__cloc));\n+\t  _M_grouping = __nl_langinfo_l(GROUPING, __cloc);\n+\t}\n+      // NB: There is no way to extact this info from posix locales.\n+      // _M_truename = __nl_langinfo_l(YESSTR, __cloc);\n+      _M_truename = L\"true\";\n+      // _M_falsename = __nl_langinfo_l(NOSTR, __cloc);\n+      _M_falsename = L\"false\";\n+    }\n+#endif\n+\n+  template<> \n+    void\n+    moneypunct<char>::_M_initialize_moneypunct(__c_locale __cloc)\n+    {\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_decimal_point = '.';\n+\t  _M_thousands_sep = ',';\n+\t  _M_grouping = \"\";\n+\t  _M_curr_symbol = string_type();\n+\t  _M_positive_sign = string_type();\n+\t  _M_negative_sign = string_type();\n+\t  _M_frac_digits = 0;\n+\t  _M_pos_format = money_base::_S_default_pattern;\n+\t  _M_neg_format = money_base::_S_default_pattern;\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  _M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT, __cloc));\n+\t  _M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP, __cloc));\n+\t  _M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);\n+\t  _M_positive_sign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n+\t  _M_negative_sign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);\n+\t  if (intl)\n+\t    {\n+\t      _M_curr_symbol = __nl_langinfo_l(__INT_CURR_SYMBOL, __cloc);\n+\t      _M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS, __cloc));\n+\t      char __ppreceeds = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, \n+\t\t\t\t\t\t   __cloc));\n+\t      char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));\n+\t      char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));\n+\t      _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, \n+\t\t\t\t\t\t   __pposn);\n+\t      char __npreceeds = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, \n+\t\t\t\t\t\t   __cloc));\n+\t      char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));\n+\t      char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));\n+\t      _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, \n+\t\t\t\t\t\t   __nposn);\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_curr_symbol = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);\n+\t      _M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));\n+\t      char __ppreceeds = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n+\t      char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n+\t      char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n+\t      _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, \n+\t\t\t\t\t\t   __pposn);\n+\t      char __npreceeds = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n+\t      char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n+\t      char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n+\t      _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, \n+\t\t\t\t\t\t   __nposn);\n+\t    }\n+\t}\n+    }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    void\n+    moneypunct<wchar_t>::_M_initialize_moneypunct(__c_locale /*__cloc*/)\n+    {\n+      // XXX implement\n+      // \"C\" locale\n+      _M_decimal_point = L'.';\n+      _M_thousands_sep = L',';\n+      _M_grouping = \"\";\n+      _M_curr_symbol = string_type();\n+      _M_positive_sign = string_type();\n+      _M_negative_sign = string_type();\n+      _M_frac_digits = 0;\n+      _M_pos_format = money_base::_S_default_pattern;\n+      _M_neg_format = money_base::_S_default_pattern;\n+    }\n+#endif\n+}  // namespace std\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "eac640a5007ce2805a0a5df76c070a8e6ecce828", "filename": "libstdc++-v3/config/c_locale_gnu.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_gnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_gnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_locale_gnu.h?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,39 @@\n+// Wrapper for underlying C-language localization -*- C++ -*-\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.8  Standard locale categories.\n+//\n+\n+// Written by Benjamin Kosnik <bkoz@redhat.com>\n+\n+namespace std\n+{\n+  typedef __locale_t\t\t__c_locale;\n+}"}, {"sha": "1a221db5bc6b7f8b97608de3d418ab01e6c3ee5a", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 836, "deletions": 796, "changes": 1632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=0214010c60e8777e7f40e3b63c158134af301525"}, {"sha": "eea3b6e27ac04587e9434797200bc7606fd28cd3", "filename": "libstdc++-v3/configure.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.in?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -35,6 +35,7 @@ GLIBCPP_CHECK_COMPILER_VERSION\n # Enable all the crazy c++ stuff.  C_MBCHAR must come early.\n GLIBCPP_ENABLE_DEBUG($USE_MAINTAINER_MODE)\n GLIBCPP_ENABLE_CSTDIO\n+GLIBCPP_ENABLE_CLOCALE\n GLIBCPP_ENABLE_C_MBCHAR([yes])\n GLIBCPP_ENABLE_LONG_LONG([no])\n GLIBCPP_ENABLE_CHEADERS([c_std])"}, {"sha": "2bbb4bd5e9f3ee1b708341f07f55f046589c9399", "filename": "libstdc++-v3/docs/html/22_locale/locale.html", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F22_locale%2Flocale.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F22_locale%2Flocale.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F22_locale%2Flocale.html?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -5,19 +5,22 @@ <H1>\n   </H1>\n </HEAD>\n <I>\n-prepared by Benjamin Kosnik (bkoz@redhat.com) on September 15, 2000\n+prepared by Benjamin Kosnik (bkoz@redhat.com) on January 24, 2001\n </I>\n \n <P>\n <H2>\n-1. Abstract\n+1. Abstract Describes the basic locale object, including nested\n+classes id, facet, and the reference-counted implementation object,\n+class _Impl.\n </H2>\n <P>\n </P>\n \n <P>\n <H2>\n 2. What the standard says\n+See Chapter 22 of the standard.\n </H2>\n \n \n@@ -27,25 +30,52 @@ <H2>\n </H2>\n \n <P>\n-For the required specialization codecvt&lt;wchar_t, char, mbstate_t&gt; ,\n-conversions are made between the internal character set (always UCS4\n-on GNU/Linux) and whatever the currently selected locale for the\n-LC_CTYPE category implements.\n+The major problem is fitting an object-orientated and non-global locale\n+design ontop of POSIX and other relevant stanards, which include the\n+Single Unix (nee X/Open.)\n \n+Because POSIX falls down so completely, portibility is an issue.\n <P>\n+\n <H2>\n 4. Design\n </H2>\n-The two required specializations are implemented as follows:\n+Class locale in non-templatized and has three distinct types nested\n+inside of it:\n+\n+class facet\n+22.1.1.1.2 Class locale::facet\n+\n+Facets actually implement locale functionality. For instance, a facet\n+called numpunct is the data objects that can be used to query for the\n+thousands seperator is in the German locale.\n+\n+Literally, a facet is strictly defined:\n+ - containing \n+public:\n+  static locale::id id;\n+\n+- or derived from another facet\n+\n+The only other thing of interest in this class is the memory\n+management of facets. Each constructor of a facet class takes a\n+std::size_t __refs argument: if __refs == 0, the facet is deleted when\n+no longer used. if __refs == 1, the facet is not destroyed, even when\n+it is no longer reference.\n+\n+\n+class id\n+Provides an index for looking up specific facets.\n \n+class _Impl\n \n <P>\n <H2>\n 5.  Examples\n </H2>\n \n <pre>\n-  typedef ctype<char> cctype;\n+  typedef __locale_t locale;\n </pre>\n \n More information can be found in the following testcases:"}, {"sha": "cf9ded1e690a5b866caaf0af037b7667bf4097ff", "filename": "libstdc++-v3/docs/html/configopts.html", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fconfigopts.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fconfigopts.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fconfigopts.html?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -7,7 +7,7 @@\n    <META NAME=\"GENERATOR\" CONTENT=\"vi and eight fingers\">\n    <TITLE>libstdc++-v3 configure options</TITLE>\n <LINK REL=StyleSheet HREF=\"lib3styles.css\">\n-<!-- $Id: configopts.html,v 1.3 2001/01/03 15:53:27 bkoz Exp $ -->\n+<!-- $Id: configopts.html,v 1.4 2001/01/21 09:36:09 pme Exp $ -->\n </HEAD>\n <BODY>\n \n@@ -69,6 +69,21 @@ <H1 CLASS=\"centered\"><A NAME=\"top\">Interesting <TT>configure</TT>\n \tabstraction.  The default is 'stdio'.\n      </P>\n \n+ <DT><TT>--enable-clocale  </TT>\n+ <DD><P>This is an abbreviated form of <TT>'--enable-clocale=generic'</TT>\n+        (described next).\n+     </P>\n+\n+ <DT><TT>--enable-clocale=MODEL  </TT>\n+ <DD><P>Select a target-specific underlying locale package. The\n+        choices are 'gnu' to specify an X/Open (IEEE Std. 1003.1-200x)\n+        model based on langinfo/iconv (from <A\n+        HREF=\"http://sources.redhat.com/glibc/\">glibc</A>, the GNU C\n+        library), or 'generic' to use a generic &quot;C&quot;\n+        abstraction which consists of \"C\" locale info.  The default is\n+        'generic'.\n+     </P>\n+\n  <DT><TT>--enable-long-long  </TT>\n  <DD><P>The &quot;long long&quot; type was introduced in C99.  It is\n         provided as a GNU extension to C++98 in g++.  This flag builds\n@@ -178,7 +193,7 @@ <H1 CLASS=\"centered\"><A NAME=\"top\">Interesting <TT>configure</TT>\n \n <HR>\n <P CLASS=\"fineprint\"><EM>\n-$Id: configopts.html,v 1.3 2001/01/03 15:53:27 bkoz Exp $\n+$Id: configopts.html,v 1.4 2001/01/21 09:36:09 pme Exp $\n </EM></P>\n \n "}, {"sha": "f96924119b9ef1134629f2877251f8a6a54637aa", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 199, "deletions": 285, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,6 +1,6 @@\n // Locale support -*- C++ -*-\n \n-// Copyright (C) 1997-2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -37,49 +37,15 @@\n #define _CPP_BITS_LOCFACETS_H\t1\n \n #include <bits/std_ctime.h>\t// For struct tm\n-#include <typeinfo> \t\t// For bad_cast, which shouldn't be here.\n #include <bits/std_ios.h>\t// For ios_base\n #ifdef _GLIBCPP_USE_WCHAR_T\n+# include <langinfo.h>\t\t// For codecvt\n # include <bits/std_cwctype.h>\t// For wctype_t\n # include <iconv.h>\t\t// For codecvt using iconv, iconv_t\n-# include <langinfo.h>\t\t// For codecvt using nl_langinfo\n #endif \n \n namespace std\n {\n-  // XXX This function is to be specialized for the \"required\" facets to \n-  // be constructed lazily.   The specializations must be declared after \n-  // the definitions of the facets themselves; but they shouldn't be \n-  // inline.  Corresponding new's in locale::classic() should then be \n-  // eliminated.  Note that ctype<> should not get this treatment; \n-  // see the use_facet<> specializations below.\n-  //\n-  struct _Bad_use_facet : public bad_cast \n-  {\n-    _Bad_use_facet() throw() {}\n-\n-    _Bad_use_facet(_Bad_use_facet const&  __b) throw() \n-    : bad_cast(__b) { }\n-\n-    _Bad_use_facet& \n-    operator=(_Bad_use_facet const& __b) throw() \n-    { \n-      static_cast<bad_cast*>(this)->operator=(__b); \n-      return *this; \n-    }\n-\n-    virtual char const* \n-    what() const throw();\n-\n-    virtual \n-    ~_Bad_use_facet() throw();\n-  };\n-\n-  template<typename _Facet>\n-    const _Facet& \n-    _Use_facet_failure_handler(const locale&)\n-    { throw _Bad_use_facet(); }\n-\n   // 22.2.1.1  Template class ctype\n   // Include host-specific ctype enums for ctype_base.\n   #include <bits/ctype_base.h>\n@@ -809,12 +775,30 @@ namespace std\n     locale::id num_put<_CharT, _OutIter>::id;\n \n   template<typename _CharT>\n-    class _Punct : public locale::facet\n+    class numpunct : public locale::facet\n     {\n     public:\n       // Types:\n-      typedef _CharT               char_type;\n-      typedef basic_string<_CharT> string_type;\n+      typedef _CharT          \t\tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n+\n+      static locale::id id;\n+\n+    private:\n+      char_type \t_M_decimal_point;\n+      char_type \t_M_thousands_sep;\n+      string \t\t_M_grouping;\n+      string_type \t_M_truename;\n+      string_type \t_M_falsename;\n+\n+    public:\n+      explicit \n+      numpunct(size_t __refs = 0) : locale::facet(__refs) \n+      { _M_initialize_numpunct(); }\n+\n+      explicit \n+      numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs) \n+      { _M_initialize_numpunct(__cloc); }\n \n       char_type    \n       decimal_point() const\n@@ -827,13 +811,18 @@ namespace std\n       string       \n       grouping() const\n       { return do_grouping(); }\n-    protected:\n \n-      explicit \n-      _Punct(size_t __refs = 0) : locale::facet(__refs) { }\n+      string_type  \n+      truename() const\n+      { return do_truename(); }\n+\n+      string_type  \n+      falsename() const\n+      { return do_falsename(); }\n \n+    protected:\n       virtual \n-      ~_Punct() { }\n+      ~numpunct() { }\n \n       virtual char_type    \n       do_decimal_point() const\n@@ -843,49 +832,10 @@ namespace std\n       do_thousands_sep() const\n       { return _M_thousands_sep; }\n \n-      virtual string       \n+      virtual string\n       do_grouping() const\n       { return _M_grouping; }\n \n-    private:\n-      char_type _M_decimal_point;\n-      char_type _M_thousands_sep;\n-      string    _M_grouping;\n-      \n-    protected:\n-      // for use at construction time only:\n-      void \n-      _M_init(char_type __d, char_type __t, const string& __g)\n-      {\n-\t_M_decimal_point = __d;\n-\t_M_thousands_sep = __t;\n-\t_M_grouping = __g;\n-      }\n-    };\n-\n-  template<typename _CharT>\n-    class _Numpunct : public _Punct<_CharT>\n-    {\n-    public:\n-      // Types:\n-      typedef _CharT               char_type;\n-      typedef basic_string<_CharT> string_type;\n-\n-      string_type  \n-      truename() const\n-      { return do_truename(); }\n-\n-      string_type  \n-      falsename() const\n-      { return do_falsename(); }\n-\n-    protected:\n-      explicit \n-      _Numpunct(size_t __refs = 0) : _Punct<_CharT> (__refs) { }\n-\n-      virtual \n-      ~_Numpunct() { }\n-\n       virtual string_type  \n       do_truename() const\n       { return _M_truename; }\n@@ -894,86 +844,67 @@ namespace std\n       do_falsename() const\n       { return _M_falsename; }\n \n-    private:\n-      string_type _M_truename;\n-      string_type _M_falsename;\n-      \n-    protected:\n-      // For use only during construction\n+      // For use at construction time only.\n       void \n-      _M_boolnames_init(const string_type& __t, const string_type& __f)\n-      {\n-\t_M_truename = __t;\n-\t_M_falsename = __f;\n-      }\n-    };\n-\n-  template<typename _CharT>\n-    class numpunct : public _Numpunct<_CharT>\n-    {\n-    public:\n-      typedef _CharT               char_type;\n-      typedef basic_string<_CharT> string_type;\n-\n-      static locale::id id;\n-\n-      explicit \n-      numpunct(size_t __refs = 0) : _Numpunct<_CharT>(__refs) { }\n-\n-    protected:\n-      virtual \n-      ~numpunct() { }\n+      _M_initialize_numpunct(__c_locale __cloc = NULL);\n     };\n \n   template<typename _CharT>\n     locale::id numpunct<_CharT>::id;\n \n-  template<> \n-    numpunct<char>::numpunct(size_t __refs): _Numpunct<char>(__refs)\n-    {\n-      _M_init('.', ',', \"\");\n-      _M_boolnames_init(\"true\", \"false\");\n+  template<typename _CharT>\n+    void\n+    numpunct<_CharT>::_M_initialize_numpunct(__c_locale /*__cloc*/)\n+    { \n+      // NB: Cannot be made generic. \n     }\n \n+  template<> \n+    void\n+    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<> \n-    numpunct<wchar_t>::numpunct(size_t __refs): _Numpunct<wchar_t>(__refs)\n-    {\n-      _M_init(L'.', L',', \"\");\n-      _M_boolnames_init(L\"true\", L\"false\");\n-    }\n+    void\n+    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);\n #endif\n \n+\n   template<typename _CharT>\n     class numpunct_byname : public numpunct<_CharT>\n     {\n+      __c_locale\t\t\t_M_c_locale_numpunct;\n     public:\n-      typedef _CharT               char_type;\n-      typedef basic_string<_CharT> string_type;\n+      typedef _CharT               \tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n \n       explicit \n-      numpunct_byname(const char*, size_t __refs = 0);\n-      \n+      numpunct_byname(const char* __s, size_t __refs = 0)\n+      : numpunct<_CharT>(__refs)\n+      {\n+\t_S_create_c_locale(_M_c_locale_numpunct, __s);\n+\t_M_initialize_numpunct(_M_c_locale_numpunct);\t\n+      }\n+\n     protected:\n       virtual \n-      ~numpunct_byname() { }\n+      ~numpunct_byname() \n+      { _S_destroy_c_locale(_M_c_locale_numpunct); }\n     };\n \n-  template<>\n-    numpunct_byname<char>::numpunct_byname(const char*, size_t __refs);\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    numpunct_byname<wchar_t>::numpunct_byname(const char*, size_t __refs);\n-#endif\n \n   template<typename _CharT>\n-    class _Collate : public locale::facet\n+    class collate : public locale::facet\n     {\n     public:\n       // Types:\n       typedef _CharT               char_type;\n       typedef basic_string<_CharT> string_type;\n \n+      static locale::id id;\n+\n+      explicit \n+      collate(size_t __refs = 0) : locale::facet(__refs) { }\n+\n       int \n       compare(const _CharT* __lo1, const _CharT* __hi1,\n \t      const _CharT* __lo2, const _CharT* __hi2) const\n@@ -988,99 +919,50 @@ namespace std\n       { return do_hash(__lo, __hi); }\n       \n   protected:\n-      explicit \n-      _Collate(size_t __refs = 0) : locale::facet(__refs) { }\n-\n-      ~_Collate() { } // virtual\n+      ~collate() { } // virtual\n \n       virtual int  \n       do_compare(const _CharT* __lo1, const _CharT* __hi1,\n-\t\t const _CharT* __lo2, const _CharT* __hi2) const = 0;\n+\t\t const _CharT* __lo2, const _CharT* __hi2) const;\n \n       virtual string_type \n-      do_transform(const _CharT* __lo, const _CharT* __hi) const = 0;\n+      do_transform(const _CharT* __lo, const _CharT* __hi) const;\n \n       virtual long   \n-      do_hash(const _CharT* __lo, const _CharT* __hi) const = 0;\n-    };\n-\n-  template<typename _CharT>\n-    class collate : public _Collate<_CharT>\n-    {\n-    public:      \n-      // Types:\n-      typedef _CharT               char_type;\n-      typedef basic_string<_CharT> string_type;\n-\n-      explicit \n-      collate(size_t __refs = 0) : _Collate<_CharT> (__refs) { }\n-\n-      static locale::id id;\n-      \n-    protected:\n-      virtual \n-      ~collate() { }\n+      do_hash(const _CharT* __lo, const _CharT* __hi) const;\n     };\n \n   template<typename _CharT>\n     locale::id collate<_CharT>::id;\n \n+  // Required specializations.\n   template<>\n-    class collate<char> : public _Collate<char>\n-    {\n-    public:      \n-      // Types:\n-      typedef char               char_type;\n-      typedef basic_string<char> string_type;\n-\n-      explicit \n-      collate(size_t __refs = 0);\n+    int \n+    collate<char>::do_compare(const char* __lo1, const char* __hi1, \n+\t\t\t      const char* __lo2, const char* __hi2) const;\n \n-      static locale::id id;\n-      \n-    protected:\n-      virtual \n-      ~collate();\n-\n-      virtual int  \n-      do_compare(const char* __lo1, const char* __hi1,\n-\t\t const char* __lo2, const char* __hi2) const;\n-\n-      virtual string_type \n-      do_transform(const char* __lo, const char* __hi) const;\n-\n-      virtual long   \n-      do_hash(const char* __lo, const char* __hi) const;\n-    };\n+  template<>\n+    string\n+    collate<char>::do_transform(const char* __lo, const char* __hi) const;\n \n+  template<>\n+    long\n+    collate<char>::do_hash(const char* __lo, const char* __hi) const;\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<>\n-    class collate<wchar_t> : public _Collate<wchar_t>\n-    {\n-    public:\n-      // Types:\n-      typedef wchar_t               char_type;\n-      typedef basic_string<wchar_t> string_type;\n-      \n-      explicit \n-      collate(size_t __refs = 0);\n+    int \n+    collate<wchar_t>::do_compare(const wchar_t* __lo1, const wchar_t* __hi1, \n+\t\t\t\t const wchar_t* __lo2, \n+\t\t\t\t const wchar_t* __hi2) const;\n \n-      static locale::id id;\n-      \n-    protected:\n-      virtual \n-      ~collate();\n-\n-      virtual int   \n-      do_compare(const wchar_t* __lo1, const wchar_t* __hi1,\n-\t\t const wchar_t* __lo2, const wchar_t* __hi2) const;\n-\n-      virtual string_type \n-      do_transform(const wchar_t* __lo, const wchar_t* __hi) const;\n+  template<>\n+    wstring\n+    collate<wchar_t>::do_transform(const wchar_t* __lo, \n+\t\t\t\t   const wchar_t* __hi) const;\n \n-      virtual long   \n-      do_hash(const wchar_t* __lo, const wchar_t* __hi) const;\n-    };\n+  template<>\n+    long\n+    collate<wchar_t>::do_hash(const wchar_t* __lo, const wchar_t* __hi) const;\n #endif\n \n   template<typename _CharT>\n@@ -1356,17 +1238,58 @@ namespace std\n     struct pattern { char field[4]; };\n \n     static const pattern _S_default_pattern;\n+\n+    // Construct and return valid pattern consisting of some combination of:\n+    // space none symbol sign value\n+    static pattern \n+    _S_construct_pattern(char __preceeds, char __space, char __posn);\n   };\n \n-  template<typename _CharT>\n-    class _Moneypunct : public _Punct<_CharT>, public money_base\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct : public locale::facet, public money_base\n     {\n     public:\n-      typedef _CharT char_type;\n-      typedef basic_string<_CharT> string_type;\n+      // Types:\n+      typedef _CharT \t\t\tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n+\n+      static const bool intl = _Intl;\n+      static locale::id id;\n+\n+    private:\n+      char_type \t_M_decimal_point;\n+      char_type \t_M_thousands_sep;\n+      string \t\t_M_grouping;\n+      string_type \t_M_curr_symbol;\n+      string_type \t_M_positive_sign;\n+      string_type \t_M_negative_sign;\n+      int \t\t_M_frac_digits;\n+      pattern \t\t_M_pos_format;\n+      pattern \t\t_M_neg_format;\n+\n+    public:\n+      explicit \n+      moneypunct(size_t __refs = 0) : locale::facet(__refs)\n+      { _M_initialize_moneypunct(); }\n+\n+      explicit \n+      moneypunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs)\n+      { _M_initialize_moneypunct(__cloc); }\n+\n+      char_type\n+      decimal_point() const\n+      { return decimal_point(); }\n+      \n+      char_type\n+      thousands_sep() const\n+      { return thousands_sep(); }\n+      \n+      string \n+      grouping() const\n+      { return grouping(); }\n \n       string_type  \n-      curr_symbol()   const\n+      curr_symbol() const\n       { return do_curr_symbol(); }\n \n       string_type  \n@@ -1378,66 +1301,60 @@ namespace std\n       { return do_negative_sign(); }\n \n       int          \n-      frac_digits()   const\n+      frac_digits() const\n       { return do_frac_digits(); }\n \n       pattern      \n-      pos_format()    const\n+      pos_format() const\n       { return do_pos_format(); }\n \n       pattern      \n-      neg_format()    const\n+      neg_format() const\n       { return do_neg_format(); }\n \n     protected:\n-      explicit \n-      _Moneypunct(size_t __refs = 0) : _Punct<_CharT> (__refs) { }\n-\n       virtual \n-      ~_Moneypunct() { }\n+      ~moneypunct() { }\n+\n+      virtual char_type\n+      do_decimal_point() const\n+      { return _M_decimal_point; }\n+      \n+      virtual char_type\n+      do_thousands_sep() const\n+      { return _M_thousands_sep; }\n+      \n+      virtual string \n+      do_grouping() const\n+      { return _M_grouping; }\n \n       virtual string_type  \n       do_curr_symbol()   const\n-      { return basic_string<_CharT>(); }\n+      { return _M_curr_symbol; }\n \n       virtual string_type  \n       do_positive_sign() const\n-      { return basic_string<_CharT>(); }\n+      { return _M_positive_sign; }\n \n       virtual string_type  \n       do_negative_sign() const\n-      { return basic_string<_CharT>(); }\n+      { return _M_negative_sign; }\n \n       virtual int          \n       do_frac_digits() const\n-      { return 0; }\n+      { return _M_frac_digits; }\n \n       virtual pattern      \n       do_pos_format() const\n-      { return money_base::_S_default_pattern; }\n+      { return _M_pos_format; }\n \n       virtual pattern      \n       do_neg_format() const\n-      { return money_base::_S_default_pattern; }\n-    };\n+      { return _M_neg_format; }\n \n-  template<typename _CharT, bool _Intl>\n-    class moneypunct : public _Moneypunct<_CharT>\n-    {\n-    public:\n-      // Types:\n-      typedef _CharT \t\t\tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n-\n-      static const bool intl = _Intl;\n-      static locale::id id;\n-\n-      explicit \n-      moneypunct(size_t __refs = 0) : _Moneypunct<_CharT> (__refs) { }\n-\n-    protected:\n-      virtual \n-      ~moneypunct() { }\n+      // For use at construction time only.\n+      void \n+      _M_initialize_moneypunct(__c_locale __cloc = NULL);\n     };\n \n   template<typename _CharT, bool _Intl>\n@@ -1447,50 +1364,65 @@ namespace std\n     const bool moneypunct<_CharT, _Intl>::intl;\n \n   template<typename _CharT, bool _Intl>\n-    class moneypunct_byname : public moneypunct<_CharT,_Intl>\n+    void\n+    moneypunct<_CharT, _Intl>::_M_initialize_moneypunct(__c_locale /*__cloc*/)\n+    { \n+      // NB: Cannot be made generic. \n+    }\n+\n+  template<> \n+    void\n+    moneypunct<char>::_M_initialize_moneypunct(__c_locale __cloc);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    void\n+    moneypunct<wchar_t>::_M_initialize_moneypunct(__c_locale __cloc);\n+#endif\n+\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct_byname : public moneypunct<_CharT, _Intl>\n     {\n+      __c_locale\t\t\t_M_c_locale_moneypunct;\n     public:\n-      typedef _CharT char_type;\n-      typedef basic_string<_CharT> string_type;\n+      typedef _CharT \t\t\tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n+\n       static const bool intl = _Intl;\n \n       explicit \n-      moneypunct_byname(const char*, size_t __refs = 0);\n+      moneypunct_byname(const char* __s, size_t __refs = 0)\n+      : moneypunct<_CharT, _Intl>(__refs)\n+      {\n+\t_S_create_c_locale(_M_c_locale_moneypunct, __s);\n+\t_M_initialize_moneypunct(_M_c_locale_moneypunct);\t\n+      }\n \n     protected:\n       virtual \n-      ~moneypunct_byname() { }\n+      ~moneypunct_byname() \n+      { _S_destroy_c_locale(_M_c_locale_moneypunct); }\n     };\n \n   template<typename _CharT, bool _Intl>\n     const bool moneypunct_byname<_CharT, _Intl>::intl;\n \n-  template<>\n-    moneypunct_byname<char, false>::\n-    moneypunct_byname(const char*, size_t __refs);\n-  template<>\n-    moneypunct_byname<char, true>::\n-    moneypunct_byname(const char*, size_t __refs);\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    moneypunct_byname<wchar_t,false>::\n-    moneypunct_byname(const char*, size_t __refs);\n-  template<>\n-    moneypunct_byname<wchar_t,true>::\n-    moneypunct_byname (const char*, size_t __refs);\n-#endif\n \n   struct messages_base\n   {\n     typedef int catalog;\n   };\n \n   template<typename _CharT>\n-    class _Messages : public locale::facet, public messages_base\n+    class messages : public locale::facet, public messages_base\n     {\n     public:\n-      typedef _CharT char_type;\n-      typedef basic_string<_CharT> string_type;\n+      typedef _CharT \t\t\tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      messages(size_t __refs = 0) : locale::facet(__refs) { }\n \n       catalog \n       open(const basic_string<char>& __s, const locale& __loc) const\n@@ -1505,11 +1437,8 @@ namespace std\n       { return do_close(__c); }\n \n     protected:\n-      explicit \n-      _Messages(size_t __refs = 0) : locale::facet(__refs) { }\n-\n       virtual \n-      ~_Messages() { }\n+      ~messages() { }\n \n       // NB: Probably these should be pure, and implemented only in\n       //  specializations of messages<>.  But for now...\n@@ -1522,22 +1451,7 @@ namespace std\n       { return __dfault; }\n \n       virtual void    \n-      do_close (catalog) const { }\n-    };\n-\n-  template<typename _CharT>\n-    class messages : public _Messages<_CharT>\n-    {\n-    public:\n-      typedef _CharT char_type;\n-      typedef basic_string<_CharT> string_type;\n-      static locale::id id;\n-\n-      explicit \n-      messages(size_t __refs = 0) : _Messages<_CharT> (__refs) { }\n-    protected:\n-      virtual \n-      ~messages() { }\n+      do_close(catalog) const { }\n     };\n \n   template<typename _CharT>"}, {"sha": "87ba473514b1014cf05cc1af390ac2f145f7c6bf", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,6 +1,6 @@\n // Locale support -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,8 +39,10 @@\n #include <bits/std_memory.h>    // For auto_ptr\n #include <bits/sbuf_iter.h>     // For streambuf_iterators\n #include <bits/std_cctype.h>    // For isspace\n+#include <typeinfo> \t\t// For bad_cast\n #include <bits/std_vector.h>\t\n \n+\n namespace std\n {\n   template<typename _Facet>\n@@ -49,7 +51,6 @@ namespace std\n     {\n       locale __copy(*this);\n       __copy._M_impl->_M_replace_facet(__other._M_impl, &_Facet::id);\n-      __copy._M_impl->_M_has_name = false;\n       return __copy;\n     }\n \n@@ -58,8 +59,6 @@ namespace std\n     locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,\n                        const basic_string<_CharT, _Traits, _Alloc>& __s2) const\n     {\n-      // XXX should not need to qualify here.\n-      // typedef collate<_CharT> __collate_type;\n       typedef std::collate<_CharT> __collate_type;\n       const __collate_type* __fcoll = &use_facet<__collate_type>(*this);\n       return (__fcoll->compare(__s1.data(), __s1.data() + __s1.length(),\n@@ -71,12 +70,12 @@ namespace std\n     use_facet(const locale& __loc)\n     {\n       typedef locale::_Impl::__vec_facet        __vec_facet;\n-      locale::id& __id = _Facet::id;         // check member id\n+      locale::id& __id = _Facet::id;         \n       size_t __i = __id._M_index;\n       __vec_facet* __facet = __loc._M_impl->_M_facets;\n-      const locale::facet* __fp = (*__facet)[__i]; // check derivation\n-      if (__i >= __facet->size() || __fp == 0)\n-        return _Use_facet_failure_handler<_Facet>(__loc);\n+      const locale::facet* __fp = (*__facet)[__i]; \n+      if (__fp == 0 || __i >= __facet->size())\n+        throw bad_cast();\n       return static_cast<const _Facet&>(*__fp);\n     }\n \n@@ -85,7 +84,7 @@ namespace std\n     has_facet(const locale& __loc) throw()\n     {\n       typedef locale::_Impl::__vec_facet        __vec_facet;\n-      locale::id& __id = _Facet::id;         // check member id\n+      locale::id& __id = _Facet::id;         \n       size_t __i = __id._M_index;\n       __vec_facet* __facet = __loc._M_impl->_M_facets;\n       return (__i < __facet->size() && (*__facet)[__i] != 0);"}, {"sha": "cafa045b4105646697f8d536f45c1c511a7ffbd1", "filename": "libstdc++-v3/include/bits/localefwd.h", "status": "modified", "additions": 53, "deletions": 70, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,6 +1,6 @@\n // Locale support -*- C++ -*-\n \n-// Copyright (C) 1997-2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -38,9 +38,16 @@\n #include <bits/std_climits.h>\t// For CHAR_BIT\n #include <bits/std_string.h> \t// For string\n #include <bits/std_cctype.h>\t// For isspace, etc.\n+#include <bits/c++locale.h>     // Defines __c_locale.\n \n namespace std\n {\n+  // NB: Don't instantiate required wchar_t facets if no wchar_t support.\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+# define  _GLIBCPP_NUM_FACETS 26\n+#else\n+# define  _GLIBCPP_NUM_FACETS 13\n+#endif\n \n   // _Count_ones: compile-time computation of number of 1-bits in a value N\n   // This takes only 5 (or 6) instantiations, doing recursive descent\n@@ -163,10 +170,6 @@ namespace std\n   // 22.2.4 collation\n   template<typename _CharT> \n     class collate;\n-  template<> class collate<char>;\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<> class collate<wchar_t>;\n-#endif\n   template<typename _CharT> class \n     collate_byname;\n \n@@ -199,19 +202,19 @@ namespace std\n   template<typename _CharT> \n     class messages_byname;\n \n-\n   // 22.1.1 Class locale\n   class locale\n   {\n   public:\n     // Types:\n-    typedef unsigned int category;\n+    typedef unsigned int \tcategory;\n \n     // Forward decls and friends:\n     class facet;\n     class id;\n     class _Impl;\n \n+    friend class facet;\n     friend class _Impl;\n \n     template<typename _Facet>\n@@ -223,7 +226,7 @@ namespace std\n       has_facet(const locale&) throw();\n  \n     // Category values:\n-    // NB much depends on the order in which these appear:\n+    // NB: Order must match _S_facet_categories definition in locale.cc\n     static const category none\t\t= 0;\n     static const category ctype \t= 1 << 0;\n     static const category numeric \t= 1 << 1;\n@@ -235,23 +238,20 @@ namespace std\n \t\t\t\t \t   numeric | time  | messages);\n \n     // Construct/copy/destroy:\n-    inline  \n     locale() throw();\n \n-    inline  \n     locale(const locale& __other) throw();\n \n     explicit  \n     locale(const char* __std_name);\n \n-    locale(const locale& __other, const char* __std_name, category __cat);\n+    locale(const locale& __base, const char* __s, category __cat);\n \n-    locale(const locale& __other, const locale& __one, category __cat);\n+    locale(const locale& __base, const locale& __add, category __cat);\n \n     template<typename _Facet>\n       locale(const locale& __other, _Facet* __f);\n \n-    inline  \n     ~locale() throw();\n \n     const locale&  \n@@ -294,8 +294,8 @@ namespace std\n     // Current global reference locale\n     static _Impl* \t_S_global;  \n \n-    static const int \t_S_categories_num = _Count_ones<all>::_M_count;\n-    static const int \t_S_facets_num = 26;\n+    static const size_t\t_S_num_categories = _Count_ones<all>::_M_count;\n+    static const size_t _S_num_facets = _GLIBCPP_NUM_FACETS;\n \n     explicit \n     locale(_Impl*) throw();\n@@ -304,8 +304,11 @@ namespace std\n     _S_initialize()\n     { if (!_S_classic) classic();  }\n \n-    static int  \n-    _S_normalize_category(int);\n+    static category  \n+    _S_normalize_category(category);\n+\n+    void\n+    _M_coalesce(const locale& __base, const locale& __add, category __cat);\n   };\n \n \n@@ -314,8 +317,7 @@ namespace std\n   {\n   public:\n     // Types.\n-    typedef vector<facet*, allocator<facet*> > __vec_facet;\n-    typedef vector<string, allocator<string> > __vec_string;\n+    typedef vector<facet*, allocator<facet*> > \t__vec_facet;\n \n     // Friends.\n     friend class locale;\n@@ -333,9 +335,8 @@ namespace std\n     // Data Members.\n     size_t \t\t\t\t_M_references;\n     __vec_facet* \t\t\t_M_facets;\n-    __vec_string* \t\t\t_M_category_names;\n-    bool \t\t\t\t_M_has_name;\n-    string \t\t\t\t_M_name;\n+    string \t\t\t\t_M_names[_S_num_categories];\n+    __c_locale\t\t\t\t_M_c_locale;\n     static const locale::id* const \t_S_id_ctype[];\n     static const locale::id* const \t_S_id_numeric[];\n     static const locale::id* const \t_S_id_collate[];\n@@ -353,19 +354,25 @@ namespace std\n     {\n       if (_M_references-- == 0)  // XXX MT\n \t{\n-\t  try { \n-\t    delete this; \n-\t  } \n-\t  catch(...) { \n-\t  }\n+\t  try \n+\t    { delete this; } \n+\t  catch(...) \n+\t    { }\n \t}\n     }\n \n     _Impl(const _Impl&, size_t);\n-    _Impl(const _Impl&, const string&, category, size_t);\n-    _Impl(size_t, size_t, bool __has_name = false, string __name = \"*\");\n+    _Impl(string __name, size_t);\n    ~_Impl() throw();\n \n+    bool\n+    _M_check_same_name()\n+    {\n+      bool __ret = true;\n+      for (size_t i = 0; i < _S_num_categories - 1; ++i)\n+\t__ret &= _M_names[i] == _M_names[i + 1];\n+      return __ret;\n+    }\n     void \n     _M_replace_categories(const _Impl*, category);\n \n@@ -380,53 +387,19 @@ namespace std\n \n     template<typename _Facet>\n       inline void \n-      _M_facet_init(_Facet* __facet)\n+      _M_init_facet(_Facet* __facet)\n       { _M_install_facet(&_Facet::id, __facet);  }\n-\n-    void \n-    _M_construct_collate(const char*);\n-\n-    void \n-    _M_construct_ctype(const char*);\n-\n-    void \n-    _M_construct_monetary(const char*);\n-\n-    void \n-    _M_construct_numeric(const char*);\n-\n-    void \n-    _M_construct_time(const char*);\n-\n-    void \n-    _M_construct_messages(const char*);\n-\n-    category \n-    _M_normalize_category_names(const string&, category __cat);\n   };\n \n-  // class locale inlines, that need declaration of locale::_Imp\n-  locale::locale() throw()\n-  { \n-    _S_initialize(); \n-    (_M_impl = _S_global)->_M_add_reference(); \n-  } // XXX MT\n-\n-  locale::locale(const locale& __other) throw()\n-  { (_M_impl = __other._M_impl)->_M_add_reference(); }\n-\n   template<typename _Facet>\n     locale::locale(const locale& __other, _Facet* __f)\n     {\n       _M_impl = new _Impl(*__other._M_impl, 1);\n       _M_impl->_M_install_facet(&_Facet::id, __f);\n-      _M_impl->_M_has_name = false;\n-      _M_impl->_M_name = \"*\";\n+      for (int __i = 0; __i < _S_num_categories; ++__i)\n+\t_M_impl->_M_names[__i] = \"*\";\n     }\n \n-  locale::~locale() throw()\n-  { _M_impl->_M_remove_reference(); }\n-\n   // 22.1.1.1.2  Class locale::facet\n   class locale::facet\n   {\n@@ -440,6 +413,12 @@ namespace std\n     virtual \n     ~facet() { };\n \n+    static void\n+    _S_create_c_locale(__c_locale& __cloc, const char* __s);\n+\n+    static void\n+    _S_destroy_c_locale(__c_locale& __cloc);\n+\n   private:\n     size_t _M_references;\n \n@@ -459,6 +438,7 @@ namespace std\n   // 22.1.1.1.3 Class locale::id\n   class locale::id\n   {\n+  private:\n     friend class locale;\n     friend class locale::_Impl;\n     template<typename _Facet>\n@@ -467,9 +447,7 @@ namespace std\n     template<typename _Facet>\n       friend bool           \n       has_facet(const locale&) throw ();\n-  public:\n-    id() { };\n-  private:\n+\n     // NB: There is no accessor for _M_index because it may be used\n     // before the constructor is run; the effect of calling a member\n     // function (even an inline) would be undefined.\n@@ -482,6 +460,12 @@ namespace std\n     operator=(const id&);  // not defined\n \n     id(const id&);  // not defined\n+\n+  public:\n+    // NB: This class is always a static data member, and thus can be\n+    // counted on to be zero-initialized.\n+    // XXX id() : _M_index(0) { }\n+    id() { }\n   };\n \n   template<typename _Facet>\n@@ -491,7 +475,6 @@ namespace std\n   template<typename _Facet>\n     bool\n     has_facet(const locale& __loc) throw();\n-\n } // namespace std\n \n #endif\t/* _CPP_BITS_LOCCORE_H */"}, {"sha": "e74397f40fe56008497ccd1a59b1a845019520ca", "filename": "libstdc++-v3/include/c_std/bits/std_clocale.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_clocale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_clocale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_clocale.h?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -36,6 +36,8 @@\n #ifndef _CPP_CLOCALE\n #define _CPP_CLOCALE 1\n \n+#include <bits/c++config.h>\n+\n #pragma GCC system_header\n #include <locale.h>\n "}, {"sha": "44c83267e1bf5840b2724246d0fcee7fb35fe599", "filename": "libstdc++-v3/libio/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FChangeLog?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,3 +1,7 @@\n+2001-01-28  benjamin kosnik  <bkoz@fillmore.constant.com>\n+\n+\t* Makefile.am (LIBIO_SRCS): Remove stdio.c.\n+\n 2000-10-29  Benjamin Kosnik  <bkoz@gnu.org>\n \n \t* Makefile.am (INCLUDES): Change to $(top_builddir)/include."}, {"sha": "c54ae683cb1a00bf7837b2fbef3ac4fc4ad3f12d", "filename": "libstdc++-v3/libio/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.am?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -48,8 +48,8 @@ libio_headers = \\\n \n if GLIBCPP_NEED_LIBIO\n LIBIO_SRCS = \\\n-\tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c iofclose.c \\\n-    iofopen.c stdio.c\n+\tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c \\\n+\tiofclose.c iofopen.c \n else\n LIBIO_SRCS =\n endif"}, {"sha": "2edc59f6270b08a972a7aeeb77d70716e8da25dd", "filename": "libstdc++-v3/libio/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.in?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -129,7 +129,7 @@ INCLUDES =  \t-nostdinc++ \t-I$(top_builddir)/include -I$(GLIBCPP_INCLUDE_DIR) \t$(\n \n libio_headers =          libio.h libioP.h iolibio.h\n \n-@GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = \tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c iofclose.c     iofopen.c stdio.c\n+@GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = \tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c \tiofclose.c iofopen.c \n @GLIBCPP_NEED_LIBIO_FALSE@LIBIO_SRCS = \n @GLIBCPP_NEED_WLIBIO_TRUE@LIBIO_WSRCS = \twfiledoalloc.c wfileops.c wgenops.c iofwide.c\n @GLIBCPP_NEED_WLIBIO_FALSE@LIBIO_WSRCS = \n@@ -157,7 +157,7 @@ libio_la_LIBADD =\n @GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n @GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@c_codecvt.lo \\\n @GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo stdio.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo \\\n @GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfiledoalloc.lo \\\n @GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfileops.lo \\\n @GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wgenops.lo \\\n@@ -174,7 +174,7 @@ libio_la_LIBADD =\n @GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n @GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@c_codecvt.lo \\\n @GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo stdio.lo\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo\n @GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS = \n CFLAGS = @CFLAGS@\n COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)"}, {"sha": "ed3326d733830707da3c22a72abe37e730fa799f", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -21,7 +21,7 @@\n ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n ## USA.\n \n-## $Id: Makefile.am,v 1.64 2001/01/11 07:27:49 bkoz Exp $\n+## $Id: Makefile.am,v 1.65 2001/01/25 22:39:28 mmitchel Exp $\n \n AUTOMAKE_OPTIONS = 1.3 gnits\n MAINT_CHARSET = latin1\n@@ -168,7 +168,8 @@ libio_headers =\n endif\n \n build_headers = \\\n-\tbits/std_limits.h bits/c++config.h bits/c++io.h bits/c++threads.h \\\n+\tbits/std_limits.h \\\n+\tbits/c++config.h bits/c++io.h bits/c++locale.h bits/c++threads.h \\\n \tbits/atomicity.h bits/os_defines.h \\\n \tbits/ctype_base.h bits/ctype_noninline.h bits/ctype_inline.h \n \n@@ -178,7 +179,7 @@ sources = \\\n \tstdexcept.cc bitset.cc \\\n         globals.cc \\\n \tc++io.cc ios.cc strstream.cc \\\n-\tlocale.cc localename.cc codecvt.cc \\\n+\tc++locale.cc locale.cc localename.cc codecvt.cc \\\n \tlocale-inst.cc stl-inst.cc misc-inst.cc valarray-inst.cc string-inst.cc\n \n wstring_sources = \\"}, {"sha": "3f37c7e8c6fe4cca463a970ffd40a4f2eed9ab3e", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -167,10 +167,10 @@ std_headers =  \talgorithm bitset complex deque fstream functional \tiomanip ios i\n @GLIBCPP_NEED_LIBIO_TRUE@libio_headers = \t$(top_srcdir)/libio/_G_config.h $(top_srcdir)/libio/libio.h\n @GLIBCPP_NEED_LIBIO_FALSE@libio_headers = \n \n-build_headers =  \tbits/std_limits.h bits/c++config.h bits/c++io.h bits/c++threads.h \tbits/atomicity.h bits/os_defines.h \tbits/ctype_base.h bits/ctype_noninline.h bits/ctype_inline.h \n+build_headers =  \tbits/std_limits.h \tbits/c++config.h bits/c++io.h bits/c++locale.h bits/c++threads.h \tbits/atomicity.h bits/os_defines.h \tbits/ctype_base.h bits/ctype_noninline.h bits/ctype_inline.h \n \n \n-sources =  \tlimitsMEMBERS.cc \tcomplex_io.cc \tstdexcept.cc bitset.cc         globals.cc \tc++io.cc ios.cc strstream.cc \tlocale.cc localename.cc codecvt.cc \tlocale-inst.cc stl-inst.cc misc-inst.cc valarray-inst.cc string-inst.cc\n+sources =  \tlimitsMEMBERS.cc \tcomplex_io.cc \tstdexcept.cc bitset.cc         globals.cc \tc++io.cc ios.cc strstream.cc \tc++locale.cc locale.cc localename.cc codecvt.cc \tlocale-inst.cc stl-inst.cc misc-inst.cc valarray-inst.cc string-inst.cc\n \n \n wstring_sources =  \twstring-inst.cc\n@@ -259,9 +259,9 @@ libinst_wstring_la_LDFLAGS =\n libinst_wstring_la_LIBADD = \n libinst_wstring_la_OBJECTS =  wstring-inst.lo\n libstdc___la_OBJECTS =  limitsMEMBERS.lo complex_io.lo stdexcept.lo \\\n-bitset.lo globals.lo c++io.lo ios.lo strstream.lo locale.lo \\\n-localename.lo codecvt.lo locale-inst.lo stl-inst.lo misc-inst.lo \\\n-valarray-inst.lo string-inst.lo\n+bitset.lo globals.lo c++io.lo ios.lo strstream.lo c++locale.lo \\\n+locale.lo localename.lo codecvt.lo locale-inst.lo stl-inst.lo \\\n+misc-inst.lo valarray-inst.lo string-inst.lo\n CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)"}, {"sha": "c67dd040b15d426e4271993e9c239daa41bc6929", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,6 +1,6 @@\n // Locale support -*- C++ -*-\n \n-// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -54,7 +54,6 @@ namespace std {\n   template class moneypunct<char, true>;\n   template class moneypunct_byname<char, false>;\n   template class moneypunct_byname<char, true>;\n-  template class _Moneypunct<char>;\n   template class money_get<char, obuf_iterator>;\n   template class money_put<char, obuf_iterator>;\n   template class money_get<char, ibuf_iterator>;\n@@ -66,7 +65,6 @@ namespace std {\n   template class moneypunct<wchar_t, true>;\n   template class moneypunct_byname<wchar_t, false>;\n   template class moneypunct_byname<wchar_t, true>;\n-  template class _Moneypunct<wchar_t>;\n   template class money_get<wchar_t, wobuf_iterator>;\n   template class money_put<wchar_t, wobuf_iterator>;\n   template class money_get<wchar_t, wibuf_iterator>;\n@@ -77,23 +75,15 @@ namespace std {\n   // numpunct, numpunct_byname, num_get, and num_put\n   template class numpunct<char>;\n   template class numpunct_byname<char>;\n-  template class _Numpunct<char>;\n   template class num_get<char, ibuf_iterator>;\n   template class num_put<char, obuf_iterator>;\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class numpunct<wchar_t>;\n   template class numpunct_byname<wchar_t>;\n-  template class _Numpunct<wchar_t>;\n   template class num_get<wchar_t, wibuf_iterator>;\n   template class num_put<wchar_t, wobuf_iterator>;\n #endif\n \n-  // _Punct\n-  template class _Punct<char>;\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template class _Punct<wchar_t>;\n-#endif\n-  \n   // time_get and time_put\n   template class time_put<char, obuf_iterator>;\n   template class time_put_byname<char, obuf_iterator>;\n@@ -108,11 +98,9 @@ namespace std {\n #endif\n \n   // messages\n-  template class _Messages<char>;\n   template class messages<char>;\n   template class messages_byname<char>;\n #ifdef _GLIBCPP_USE_WCHAR_T\n-  template class _Messages<wchar_t>;\n   template class messages<wchar_t>;\n   template class messages_byname<wchar_t>;\n #endif\n@@ -134,12 +122,12 @@ namespace std {\n #endif\n \n   // collate\n-  template class _Collate<char>;\n+  template class collate<char>;\n   template class collate_byname<char>;\n   template class _Weekdaynames<char, int>;\n   template class _Monthnames<char, int>;\n #ifdef _GLIBCPP_USE_WCHAR_T\n-  template class _Collate<wchar_t>;\n+  template class collate<wchar_t>;\n   template class collate_byname<wchar_t>;\n   template class _Weekdaynames<wchar_t, int>;\n   template class _Monthnames<wchar_t, int>;\n@@ -155,10 +143,6 @@ namespace std {\n   template\n     const codecvt<char, char, mbstate_t>& \n     use_facet<codecvt<char, char, mbstate_t> >(const locale&);\n-   template \n-    const num_put<char, obuf_iterator>& \n-    _Use_facet_failure_handler<num_put<char, obuf_iterator> >\n-    (const locale &);\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template \n     const num_put<wchar_t, wobuf_iterator>& \n@@ -169,10 +153,6 @@ namespace std {\n   template\n     const codecvt<wchar_t, char, mbstate_t>& \n     use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const &);\n-  template \n-    const num_put<wchar_t, wobuf_iterator>& \n-    _Use_facet_failure_handler<num_put<wchar_t, wobuf_iterator> >\n-    (const locale &);\n #endif\n \n   // has_facet\n@@ -296,12 +276,11 @@ namespace std {\n   template \n     locale::facet** \n     fill_n<locale::facet**, unsigned int, locale::facet*>\n-    (locale::facet**, unsigned int, locale::facet* const &);\n+    (locale::facet**, unsigned int, locale::facet* const&);\n \n   template \n     locale::facet** \n     fill_n<locale::facet**, unsigned long, locale::facet*>\n-    (locale::facet**, unsigned long, locale::facet* const &);\n-\n+    (locale::facet**, unsigned long, locale::facet* const&);\n } //std\n "}, {"sha": "5ad0539f24e9eb70e803ff1214b3e247a9fd4429", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 454, "deletions": 315, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -55,8 +55,8 @@ namespace std\n \n   locale::_Impl* \t\tlocale::_S_classic;\n   locale::_Impl* \t\tlocale::_S_global; \n-  const int \t\t\tlocale::_S_categories_num;\n-  const int \t\t\tlocale::_S_facets_num;\n+  const size_t \t\t\tlocale::_S_num_categories;\n+  const size_t \t\t\tlocale::_S_num_facets;\n \n   // Definitions for locale::id of standard facets. \n   locale::id ctype<char>::id;\n@@ -180,9 +180,457 @@ namespace std\n     0\n   };\n \n+  // Construct and return valid pattern consisting of some combination of:\n+  // space none symbol sign value\n+  money_base::pattern\n+  money_base::_S_construct_pattern(char __preceeds, char __space, char __posn)\n+  { \n+    pattern __ret;\n+\n+    // This insanely complicated routine attempts to construct a valid\n+    // pattern for use with monyepunct. A couple of invariants:\n+\n+    // if (__preceeds) symbol -> value\n+    // else value -> symbol\n+    \n+    // if (__space) space\n+    // else none\n+\n+    // none == never first\n+    // space never first or last\n+\n+    // Any elegant implementations of this are welcome.\n+    switch (__posn)\n+      {\n+      case 1:\n+\t// 1 The sign precedes the value and symbol.\n+\tif (__space)\n+\t  {\n+\t    // Pattern starts with sign.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = value;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = symbol;\n+\t      }\n+\t    __ret.field[0] = sign;\n+\t  }\n+\telse\n+\t  {\n+\t    // Pattern starts with sign and ends with none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = value;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[0] = sign;\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 2:\n+\t// 2 The sign follows the value and symbol.\n+\tif (__space)\n+\t  {\n+\t    // Pattern either ends with sign.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[3] = sign;\n+\t  }\n+\telse\n+\t  {\n+\t    // Pattern ends with sign then none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = symbol;\n+\t      }\n+\t    __ret.field[2] = sign;\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 3:\n+\t// 3 The sign immediately precedes the symbol.\n+\tif (__space)\n+\t  {\n+\t    // Have space.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = sign;\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = sign;\n+\t\t__ret.field[3] = symbol;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // Have none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = sign;\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = sign;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 4:\n+\t// 4 The sign immediately follows the symbol. \n+\tif (__space)\n+\t  {\n+\t    // Have space.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = sign;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = symbol;\n+\t\t__ret.field[3] = sign;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // Have none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = sign;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = sign;\n+\t      }\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      default:\n+\t;\n+      }\n+    return __ret;\n+  }\n+\n+  locale::~locale() throw()\n+  { _M_impl->_M_remove_reference(); }\n+\n+  void\n+  locale::_M_coalesce(const locale& __base, const locale& __add, \n+\t\t      category __cat)\n+  {\n+    __cat = _S_normalize_category(__cat);  \n+    _M_impl = new _Impl(*__base._M_impl, 1);  \n+\n+    try \n+      { _M_impl->_M_replace_categories(__add._M_impl, __cat); }\n+    catch (...) \n+      { \n+\t_M_impl->_M_remove_reference(); \n+\tthrow; \n+      }\n+  }\n+\n+  locale::locale() throw()\n+  { \n+    _S_initialize(); \n+    (_M_impl = _S_global)->_M_add_reference(); \n+  } // XXX MT\n+\n+  locale::locale(const locale& __other) throw()\n+  { (_M_impl = __other._M_impl)->_M_add_reference(); }\n+\n+  locale::locale(_Impl* __ip) throw()\n+  : _M_impl(__ip)\n+  { __ip->_M_add_reference(); }\n+\n+  locale::locale(const char* __s)\n+  {\n+    if (__s)\n+      {\n+\tif (strcmp(__s, \"C\") == 0 || strcmp(__s, \"POSIX\") == 0)\n+\t  (_M_impl = _S_classic)->_M_add_reference();\n+\telse\n+\t  _M_impl = new _Impl(__s, 1);\n+      }\n+    else\n+      throw runtime_error(\"attempt to create locale from NULL name\");\n+  }\n+\n+  locale::locale(const locale& __base, const char* __s, category __cat)\n+  { \n+    // NB: There are complicated, yet more efficient ways to do\n+    // this. Building up locales on a per-category way is tedious, so\n+    // let's do it this way until people complain.\n+    locale __add(__s);\n+    _M_coalesce(__base, __add, __cat);\n+  }\n+\n+  locale::locale(const locale& __base, const locale& __add, category __cat)\n+  { _M_coalesce(__base, __add, __cat); }\n+\n+  bool\n+  locale::operator==(const locale& __rhs) const throw()\n+  {\n+    string __name = this->name();\n+    return (_M_impl == __rhs._M_impl \n+\t    || (__name != \"*\" && __name == __rhs.name()));\n+  }\n+\n+  const locale&\n+  locale::operator=(const locale& __other) throw()\n+  {\n+    __other._M_impl->_M_add_reference();\n+    _M_impl->_M_remove_reference();\n+    _M_impl = __other._M_impl;\n+    return *this;\n+  }\n+\n+  locale\n+  locale::global(const locale& __other)\n+  {\n+    // XXX MT\n+    _S_initialize();\n+    locale __old(_S_global);\n+    __other._M_impl->_M_add_reference();\n+    _S_global->_M_remove_reference();\n+    _S_global = __other._M_impl; \n+    if (_S_global->_M_check_same_name() && _S_global->_M_names[0] != \"*\")\n+      setlocale(LC_ALL, __other.name().c_str());\n+    return __old;\n+  }\n+\n+  string\n+  locale::name() const\n+  {\n+    string __ret;\n+    // Need some kind of separator character. This one was pretty much\n+    // arbitrarily chosen as to not conflict with glibc locales: the\n+    // exact formatting is not set in stone.\n+    const char __separator = '|';\n+\n+    if (_M_impl->_M_check_same_name())\n+      __ret = _M_impl->_M_names[0];\n+    else\n+      {\n+\tfor (size_t i = 0; i < _S_num_categories; ++i)\n+\t  __ret += __separator + _M_impl->_M_names[i];\n+      }\n+    return __ret;\n+  }\n+\n+  locale const&\n+  locale::classic()\n+  {\n+    static locale* __classic_locale;\n+    // XXX MT\n+    if (!_S_classic)\n+      {\n+\ttry \n+\t  {\n+\t    // 26 Standard facets, 2 references.\n+\t    // One reference for _M_classic, one for _M_global\n+\t    _S_classic = new _Impl(\"C\", 2);\n+\t    _S_global = _S_classic; \t    \n+\n+\t    // Finesse static init order hassles\n+\t    __classic_locale = new locale(_S_classic);\n+\t  }\n+\tcatch(...) \n+\t  {\n+\t    delete __classic_locale;\n+\t    if (_S_classic)\n+\t      {\n+\t\t_S_classic->_M_remove_reference();\n+\t\t_S_global->_M_remove_reference();\n+\t      }\n+\t    _S_classic = _S_global = 0;\n+\t    // XXX MT\n+\t    throw;\n+\t  }\n+      }\n+    return *__classic_locale;\n+  }\n+\n+  locale::category\n+  locale::_S_normalize_category(category __cat) \n+  {\n+    int __ret;\n+    if (__cat == none || (__cat & all) && !(__cat & ~all))\n+      __ret = __cat;\n+    else\n+      {\n+\t// NB: May be a C-style \"LC_ALL\" category; convert.\n+\tswitch (__cat)\n+\t  {\n+\t  case LC_COLLATE:  \n+\t    __ret = collate; \n+\t    break;\n+\t  case LC_CTYPE:    \n+\t    __ret = ctype;\n+\t    break;\n+\t  case LC_MONETARY: \n+\t    __ret = monetary;\n+\t    break;\n+\t  case LC_NUMERIC:  \n+\t    __ret = numeric;\n+\t    break;\n+\t  case LC_TIME:     \n+\t    __ret = time; \n+\t    break;\n+#ifdef _GLIBCPP_HAVE_LC_MESSAGES\n+\t  case LC_MESSAGES: \n+\t    __ret = messages;\n+\t    break;\n+#endif\t\n+\t  case LC_ALL:      \n+\t    __ret = all;\n+\t    break;\n+\t  default:\n+\t    throw runtime_error(\"bad locale category\");\n+\t  }\n+      }\n+    return __ret;\n+  }\n+\n+  locale::facet::\n+  facet(size_t __refs) throw()\n+  : _M_references(__refs) \n+  { }\n+\n+  void  \n+  locale::facet::\n+  _M_add_reference() throw()\n+  { ++_M_references; }                     // XXX MT\n+\n+  void  \n+  locale::facet::\n+  _M_remove_reference() throw()\n+  {\n+    if (_M_references)\n+      --_M_references;\n+    else\n+      {\n+        try \n+\t  { delete this; }  // XXX MT\n+\tcatch (...) \n+\t  { }\n+      }\n+  }\n+  \n+  // Definitions for static const data members of ctype_base.\n+  const ctype_base::mask ctype_base::space;\n+  const ctype_base::mask ctype_base::print;\n+  const ctype_base::mask ctype_base::cntrl;\n+  const ctype_base::mask ctype_base::upper;\n+  const ctype_base::mask ctype_base::lower;\n+  const ctype_base::mask ctype_base::alpha;\n+  const ctype_base::mask ctype_base::digit;\n+  const ctype_base::mask ctype_base::punct;\n+  const ctype_base::mask ctype_base::xdigit;\n+  const ctype_base::mask ctype_base::alnum;\n+  const ctype_base::mask ctype_base::graph;\n+\n+  // Platform-specific initialization code for ctype tables.\n+  #include <bits/ctype_noninline.h>\n+\n+  const size_t ctype<char>::table_size;\n+\n+  ctype<char>::~ctype()\n+  { if (_M_del) delete[] this->table(); }\n+\n+  // These are dummy placeholders as these virtual functions are never called.\n+  bool \n+  ctype<char>::do_is(mask, char_type) const \n+  { return false; }\n+  \n+  const char*\n+  ctype<char>::do_is(const char_type* __c, const char_type*, mask*) const \n+  { return __c; }\n+  \n+  const char*\n+  ctype<char>::do_scan_is(mask, const char_type* __c, const char_type*) const \n+  { return __c; }\n+\n+  const char* \n+  ctype<char>::do_scan_not(mask, const char_type* __c, const char_type*) const\n+  { return __c; }\n+\n+  char\n+  ctype<char>::do_widen(char __c) const\n+  { return __c; }\n+  \n+  const char* \n+  ctype<char>::do_widen(const char* __low, const char* __high, \n+\t\t\tchar* __dest) const\n+  {\n+    memcpy(__dest, __low, __high - __low);\n+    return __high;\n+  }\n+  \n+  char\n+  ctype<char>::do_narrow(char __c, char /*__dfault*/) const\n+  { return __c; }\n+  \n+  const char* \n+  ctype<char>::do_narrow(const char* __low, const char* __high, \n+\t\t\t char /*__dfault*/, char* __dest) const\n+  {\n+    memcpy(__dest, __low, __high - __low);\n+    return __high;\n+  }\n+\n+  ctype_byname<char>::ctype_byname(const char* /*__s*/, size_t __refs)\n+  : ctype<char>(new mask[table_size], true, __refs)\n+  { }\n+\n   // Definitions for static const data members of money_base\n   const money_base::pattern \n-  money_base::_S_default_pattern =  {{symbol, sign, none, value}};;\n+  money_base::_S_default_pattern =  {{symbol, sign, none, value}};\n \n   template<>\n     _Format_cache<char>::_Format_cache()\n@@ -565,300 +1013,8 @@ namespace std\n     return __incl_prec;\n   }\n \n-\n-  locale::locale(_Impl* __ip) throw()\n-  : _M_impl(__ip)\n-  { __ip->_M_add_reference(); }\n-\n-\n-  locale::locale(const char* __name)\n-  {\n-    if (__name)\n-      {\n-\tif (strcmp(__name, \"C\") == 0 || strcmp(__name, \"POSIX\") == 0)\n-\t  (_M_impl = _S_classic)->_M_add_reference();\n-\t// Might throw:\n-\telse\n-\t  // XXX Named locale support not finished.\n-\t  // _M_impl = new _Impl(_S_facets_num, 1, true, __name);\n-\t  _M_impl = new _Impl(*_S_classic, __name, all, 1);\n-      }\n-    else\n-      throw runtime_error(\"attempt to create named locale from NULL name\");\n-  }\n-\n-  locale::locale(const locale& __other, const char* __name, category __cat)\n-  { \n-    if (__name)\n-      {\n-\tif (__other.name() == __name)\n-\t  (_M_impl = __other._M_impl)->_M_add_reference();\n-\t// Might throw:\n-\telse\n-\t  _M_impl = new _Impl(*__other._M_impl, __name, __cat, 1);\n-      }\n-    else\n-      throw runtime_error(\"attempt to create locale from NULL named locale\");\n-  }\n-\n-  locale::locale(const locale& __other, const locale& __one, category __cat)\n-  {\n-    __cat = _S_normalize_category(__cat);    // might throw\n-    _M_impl = new _Impl(*__other._M_impl, 1);  // might throw\n-\n-    try { \n-      _M_impl->_M_replace_categories(__one._M_impl, __cat); \n-    }\n-    catch (...) { \n-      _M_impl->_M_remove_reference(); \n-      throw; \n-    }\n-\n-    // XXX\n-    //    _M_impl->_M_cached_name_ok = false;\n-    if (!__other._M_impl->_M_has_name)\n-      _M_impl->_M_has_name = false;\n-  }\n-\n-  bool\n-  locale::operator==(const locale& __rhs) const throw()\n-  {\n-    return (_M_impl == __rhs._M_impl\n-\t    || (this->name() != \"*\" && this->name() == __rhs.name()));\n-  }\n-\n-  const locale&\n-  locale::operator=(const locale& __other) throw()\n-  {\n-    __other._M_impl->_M_add_reference();\n-    _M_impl->_M_remove_reference();\n-    _M_impl = __other._M_impl;\n-    return *this;\n-  }\n-\n-  locale\n-  locale::global(const locale& __other)\n-  {\n-    // XXX MT\n-    _S_initialize();\n-    locale __keep(_S_global);\n-    __other._M_impl->_M_add_reference();\n-    _S_global->_M_remove_reference();\n-    _S_global = __other._M_impl; \n-    if (_S_global->_M_has_name)\n-      setlocale(LC_ALL, __other.name().c_str());\n-    return __keep;\n-  }\n-\n-  string\n-  locale::name() const\n-  { return _M_impl->_M_name; }\n-\n-  locale const&\n-  locale::classic()\n-  {\n-    static locale* __classic_locale;\n-    // XXX MT\n-    if (!_S_classic)\n-      {\n-\ttry {\n-\t  // 26 Standard facets, 2 references.\n-\t  // One reference for _M_classic, one for _M_global\n-\t  _S_classic = new _Impl(_S_facets_num, 2, true, \"C\");\n-\t  _S_global = _S_classic; \n-\n-\t  _S_classic->_M_facet_init(new std::collate<char>);\n-\t  _S_classic->_M_facet_init(new std::ctype<char>);\n-\t  _S_classic->_M_facet_init(new codecvt<char, char, mbstate_t>);\n-\t  _S_classic->_M_facet_init(new moneypunct<char, false>);\n-\t  _S_classic->_M_facet_init(new moneypunct<char,true >);\n-\t  _S_classic->_M_facet_init(new money_get<char>);\n-\t  _S_classic->_M_facet_init(new money_put<char>);\n-\t  _S_classic->_M_facet_init(new numpunct<char>);\n-\t  _S_classic->_M_facet_init(new num_get<char>);\n-\t  _S_classic->_M_facet_init(new num_put<char>);\n-\t  _S_classic->_M_facet_init(new time_get<char>);\n-\t  _S_classic->_M_facet_init(new time_put<char>);\n-\t  _S_classic->_M_facet_init(new std::messages<char>);\n-\n-#ifdef  _GLIBCPP_USE_WCHAR_T\n-\t  _S_classic->_M_facet_init(new std::collate<wchar_t>);\n-\t  _S_classic->_M_facet_init(new std::ctype<wchar_t>);\n-\t  _S_classic->_M_facet_init(new codecvt<wchar_t, char, mbstate_t>);\n-\t  _S_classic->_M_facet_init(new moneypunct<wchar_t, false>);\n-\t  _S_classic->_M_facet_init(new moneypunct<wchar_t,true >);\n-\t  _S_classic->_M_facet_init(new money_get<wchar_t>);\n-\t  _S_classic->_M_facet_init(new money_put<wchar_t>);\n-\t  _S_classic->_M_facet_init(new numpunct<wchar_t>);\n-\t  _S_classic->_M_facet_init(new num_get<wchar_t>);\n-\t  _S_classic->_M_facet_init(new num_put<wchar_t>);\n-\t  _S_classic->_M_facet_init(new time_get<wchar_t>);\n-\t  _S_classic->_M_facet_init(new time_put<wchar_t>);\n-\t  _S_classic->_M_facet_init(new std::messages<wchar_t>);\n-#endif\t  \n-\n-\t  // Finesse static init order hassles\n-\t  __classic_locale = new locale(_S_classic);\n-\t}\n-\tcatch(...) {\n-\t  delete __classic_locale;\n-\t  if (_S_classic)\n-\t    {\n-\t      _S_classic->_M_remove_reference();\n-\t      _S_global->_M_remove_reference();\n-\t    }\n-\t  _S_classic = _S_global = 0;\n-\t  // XXX MT\n-\t  throw;\n-\t}\n-      }\n-    return *__classic_locale;\n-  }\n-\n-  int\n-  locale::_S_normalize_category(int __cat) \n-  {\n-    int __ret;\n-    if ((__cat & all) && !(__cat & ~all))\n-      __ret = __cat;\n-    else\n-      {\n-\t// NB: May be a C-style \"LC_ALL\" category; convert.\n-\tswitch (__cat)\n-\t  {\n-\t  case LC_COLLATE:  \n-\t    __ret = collate; \n-\t    break;\n-\t  case LC_CTYPE:    \n-\t    __ret = ctype;\n-\t    break;\n-\t  case LC_MONETARY: \n-\t    __ret = monetary;\n-\t    break;\n-\t  case LC_NUMERIC:  \n-\t    __ret = numeric;\n-\t    break;\n-\t  case LC_TIME:     \n-\t    __ret = time; \n-\t    break;\n-#ifdef _GLIBCPP_HAVE_LC_MESSAGES\n-\t  case LC_MESSAGES: \n-\t    __ret = messages;\n-\t    break;\n-#endif\t\n-\t  case LC_ALL:      \n-\t    __ret = all;\n-\t    break;\n-\t  default:\n-\t    throw runtime_error(\"bad locale category\");\n-\t  }\n-      }\n-    return __ret;\n-  }\n-\n-  locale::facet::\n-  facet(size_t __refs) throw()\n-  : _M_references(__refs - 1) \n-  { }\n-\n-  void  \n-  locale::facet::\n-  _M_add_reference() throw()\n-  { \n-    if (this) \n-      ++_M_references; \n-  }                     // XXX MT\n-\n-  void  \n-  locale::facet::\n-  _M_remove_reference() throw()\n-  {\n-    if (this && _M_references-- == 0)\n-      {\n-        try { \n-\t  delete this; \n-\t}  // XXX MT\n-\tcatch (...) { \n-\t}\n-      }\n-  }\n-\n-  char const* \n-  _Bad_use_facet::\n-  what() const throw()\n-  { return \"_Bad_use_facet thrown from use_facet\"; }\n-\n-  _Bad_use_facet::\n-  ~_Bad_use_facet() throw() { }\n-  \n-  // Definitions for static const data members of ctype_base.\n-  const ctype_base::mask ctype_base::space;\n-  const ctype_base::mask ctype_base::print;\n-  const ctype_base::mask ctype_base::cntrl;\n-  const ctype_base::mask ctype_base::upper;\n-  const ctype_base::mask ctype_base::lower;\n-  const ctype_base::mask ctype_base::alpha;\n-  const ctype_base::mask ctype_base::digit;\n-  const ctype_base::mask ctype_base::punct;\n-  const ctype_base::mask ctype_base::xdigit;\n-  const ctype_base::mask ctype_base::alnum;\n-  const ctype_base::mask ctype_base::graph;\n-\n-  // Platform-specific initialization code for ctype tables.\n-  #include <bits/ctype_noninline.h>\n-\n-  const size_t ctype<char>::table_size;\n-\n-  ctype<char>::~ctype()\n-  { if (_M_del) delete[] this->table(); }\n-\n-  // These are dummy placeholders as these virtual functions are never called.\n-  bool \n-  ctype<char>::do_is(mask, char_type) const \n-  { return false; }\n-  \n-  const char*\n-  ctype<char>::do_is(const char_type* __c, const char_type*, mask*) const \n-  { return __c; }\n-  \n-  const char*\n-  ctype<char>::do_scan_is(mask, const char_type* __c, const char_type*) const \n-  { return __c; }\n-\n-  const char* \n-  ctype<char>::do_scan_not(mask, const char_type* __c, const char_type*) const\n-  { return __c; }\n-\n-  char\n-  ctype<char>::do_widen(char __c) const\n-  { return __c; }\n-  \n-  const char* \n-  ctype<char>::do_widen(const char* __low, const char* __high, \n-\t\t\tchar* __dest) const\n-  {\n-    memcpy(__dest, __low, __high - __low);\n-    return __high;\n-  }\n-  \n-  char\n-  ctype<char>::do_narrow(char __c, char /*__dfault*/) const\n-  { return __c; }\n-  \n-  const char* \n-  ctype<char>::do_narrow(const char* __low, const char* __high, \n-\t\t\t char /*__dfault*/, char* __dest) const\n-  {\n-    memcpy(__dest, __low, __high - __low);\n-    return __high;\n-  }\n-\n-  ctype_byname<char>::ctype_byname(const char* /*__s*/, size_t __refs)\n-  : ctype<char>(new mask[table_size], true, __refs)\n-  { }\n-\n   collate<char>::collate(size_t __refs)\n-  : _Collate<char>(__refs) { }\n+  : locale::facet(__refs) { }\n   \n   collate<char>::~collate() { }\n   \n@@ -896,9 +1052,6 @@ namespace std\n   collate_byname<char>::collate_byname(const char* /*__s*/, size_t __refs)\n   : collate<char>(__refs) { }\n \n-  numpunct_byname<char>::numpunct_byname(const char* /*__s*/, size_t __refs)\n-  : numpunct<char>(__refs) { }\n-\n   moneypunct_byname<char, false>::moneypunct_byname(const char* /*__s*/, \n \t\t\t\t\t\t    size_t __refs)\n   : moneypunct<char, false>(__refs) { }\n@@ -1068,8 +1221,7 @@ namespace std\n   : ctype<wchar_t>(__refs) { }\n \n   collate<wchar_t>::\n-  collate(size_t __refs)\n-  : _Collate<wchar_t> (__refs) { }\n+  collate(size_t __refs): locale::facet(__refs) { }\n   \n   collate<wchar_t>::\n   ~collate() { }\n@@ -1094,27 +1246,14 @@ namespace std\n     return 0; // XXX not done\n   }\n \n-  numpunct_byname<wchar_t>::\n-  numpunct_byname(const char* /*__s*/, size_t __refs)\n-  : numpunct<wchar_t> (__refs) { }\n-\n   collate_byname<wchar_t>::\n   collate_byname(const char* /*__s*/, size_t __refs)\n   : collate<wchar_t> (__refs) { }\n   \n-  moneypunct_byname<wchar_t, false>::\n-  moneypunct_byname(const char* /*__s*/, size_t __refs)\n-  : moneypunct<wchar_t, false> (__refs) { }\n-  \n-  moneypunct_byname<wchar_t, true>::\n-  moneypunct_byname(const char* /*__s*/, size_t __refs)\n-  : moneypunct<wchar_t, true> (__refs) { }\n-    \n   messages_byname<wchar_t>::\n   messages_byname(const char* /*__s*/, size_t __refs)\n   : messages<wchar_t> (__refs) { }\n #endif //  _GLIBCPP_USE_WCHAR_T\n-\n } // namespace std\n \n "}, {"sha": "867b063fbfbd694999d21c6d5a1068d875671235", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 92, "deletions": 180, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -25,29 +25,28 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-\n #include <bits/std_clocale.h>\n #include <bits/std_locale.h>\n #include <bits/std_cstring.h>\n #include <bits/std_vector.h>\n #include <bits/std_stdexcept.h>\n \n namespace std {\n-\n   locale::_Impl::\n   ~_Impl() throw()\n   {\n-    std::vector<facet*>::iterator it = _M_facets->begin();\n+    __vec_facet::iterator it = _M_facets->begin();\n     for (; it != _M_facets->end(); ++it)\n-      (*it)->_M_remove_reference();\n+      if (*it)\n+\t(*it)->_M_remove_reference();\n     delete _M_facets;\n-    delete _M_category_names;\n+    locale::facet::_S_destroy_c_locale(_M_c_locale);\n   }\n \n+  // Clone existing _Impl object.\n   locale::_Impl::\n   _Impl(const _Impl& __imp, size_t __refs)\n-  : _M_references(__refs - 1), _M_facets(0), _M_category_names(0), \n-    _M_has_name(__imp._M_has_name), _M_name(__imp._M_name)\n+  : _M_references(__refs - 1), _M_facets(0), _M_c_locale(0) // XXX\n   {\n     try\n       {  _M_facets = new __vec_facet(*(__imp._M_facets)); }\n@@ -57,121 +56,89 @@ namespace std {\n \tthrow;\n       }\n \n-    try \n-      {\t_M_category_names = new __vec_string(*(__imp._M_category_names)); }\n-    catch(...) \n-      {\n-\tdelete _M_category_names;\n-\tthrow;\n-      }\n+    for (size_t i = 0; i < _S_num_categories; ++i)\n+      _M_names[i] = __imp._M_names[i];\n \n-    std::vector<facet*>::iterator __it = _M_facets->begin();\n+    __vec_facet::iterator __it = _M_facets->begin();\n     for (; __it != _M_facets->end(); ++__it)\n-      (*__it)->_M_add_reference();\n+      if (*__it)\n+\t(*__it)->_M_add_reference();\n   }\n \n-  // This constructor is used to correctly initialize named locales,\n-  // including the standard \"C\" locale.\n+  // Construct named _Impl, including the standard \"C\" locale.\n   locale::_Impl::\n-  _Impl(size_t __num, size_t __refs, bool __has_name, string __str)\n-  : _M_references(__refs - 1), _M_facets(0), _M_category_names(0), \n-    _M_has_name(__has_name), _M_name(__str)\n+  _Impl(string __str, size_t __refs)\n+  : _M_references(__refs - 1), _M_facets(0)\n   {\n+    // Initialize the underlying locale model, which also checks to\n+    // see if the given name is valid.\n+    if (__str != \"C\" && __str != \"POSIX\")\n+      locale::facet::_S_create_c_locale(_M_c_locale, __str.c_str());\n+    else\n+      _M_c_locale = NULL;\n+\n+    // Allocate facet container.\n     try\n-      {  _M_facets = new __vec_facet(__num, NULL); }\n+      {  _M_facets = new __vec_facet(_S_num_facets, NULL); }\n     catch(...) \n       {\n \tdelete _M_facets;\n \tthrow;\n       }\n \n-    try \n-      {\t_M_category_names = new __vec_string(_S_categories_num, _M_name); }\n-    catch(...) \n-      {\n-\tdelete _M_category_names;\n-\tthrow;\n-      }\n-  }\n-  \n-  // Construct specific categories, leaving unselected ones alone\n-  locale::_Impl::\n-  _Impl(const _Impl& __imp, const string& __str, category __cat, size_t __refs)\n-  : _M_references(__refs - 1)\n-  {\n-    __cat = _S_normalize_category(__cat);  // might throw\n-\n-    try \n-      { _M_facets = new __vec_facet(*(__imp._M_facets)); }\n-    catch(...) \n-      {\n-\tdelete _M_facets;\n-\tthrow;\n-      }\n-\n-    try \n-      {\t_M_category_names = new __vec_string(*(__imp._M_category_names)); }\n-    catch(...) \n-      {\n-\tdelete _M_category_names;\n-\tthrow;\n-      }\n-\n-    static void(_Impl::* ctors[]) (const char*) = \n-    {\n-      //  NB: Order must match the decl order in class locale.\n-      &locale::_Impl::_M_construct_ctype,\n-      &locale::_Impl::_M_construct_numeric,\n-      &locale::_Impl::_M_construct_collate,\n-      &locale::_Impl::_M_construct_time,\n-      &locale::_Impl::_M_construct_monetary,\n-      &locale::_Impl::_M_construct_messages,\n-      0\n-    };\n+    // Name all the categories.\n+    for (size_t i = 0; i < _S_num_categories; ++i)\n+      _M_names[i] = __str;\n+\n+    // Construct all standard facets and add them to _M_facets.\n+    // XXX Eventually, all should use __c_locale ctor like numpunct\n+    _M_init_facet(new std::collate<char>);\n+    _M_init_facet(new std::ctype<char>);\n+    _M_init_facet(new codecvt<char, char, mbstate_t>);\n+    _M_init_facet(new moneypunct<char, false>(_M_c_locale));\n+    _M_init_facet(new moneypunct<char,true >);\n+    _M_init_facet(new money_get<char>);\n+    _M_init_facet(new money_put<char>);\n+    _M_init_facet(new numpunct<char>(_M_c_locale));\n+    _M_init_facet(new num_get<char>);\n+    _M_init_facet(new num_put<char>);\n+    _M_init_facet(new time_get<char>);\n+    _M_init_facet(new time_put<char>);\n+    _M_init_facet(new std::messages<char>);\n     \n-    __vec_facet::iterator __it = _M_facets->begin();\n-    for (; __it != _M_facets->end(); ++__it)\n-      (*__it)->_M_add_reference();\n-\n-    try \n-      {\n-\tunsigned mask = (locale::all & -(unsigned)locale::all);\n-\tfor (unsigned ix = 0; (-mask & __cat) != 0; ++ix, (mask <<= 1))\n-\t  {\n-\t    if (!(mask & __cat))\n-\t      continue;\n-\t    \n-\t    if (mask & __cat)\n-\t      _M_replace_category(_S_classic, _S_facet_categories[ix]);\n-\t    else\n-\t      (this->*ctors[ix])(__str.c_str());\n-\t  }\n-      }\n-    catch(...) \n-      {\n-\t__it = _M_facets->begin();\n-\tfor (; __it != _M_facets->end(); ++__it)\n-\t  (*__it)->_M_remove_reference();\n-\tthrow;\n-      }\n-\n-    // XXX May need to be adjusted\n-    if (__cat == all)\n-      _M_name = __str;\n-    _M_has_name = __str != \"*\";\n+#ifdef  _GLIBCPP_USE_WCHAR_T\n+    _M_init_facet(new std::collate<wchar_t>);\n+    _M_init_facet(new std::ctype<wchar_t>);\n+    _M_init_facet(new codecvt<wchar_t, char, mbstate_t>);\n+    _M_init_facet(new moneypunct<wchar_t, false>(_M_c_locale));\n+    _M_init_facet(new moneypunct<wchar_t,true >);\n+    _M_init_facet(new money_get<wchar_t>);\n+    _M_init_facet(new money_put<wchar_t>);\n+    _M_init_facet(new numpunct<wchar_t>(_M_c_locale));\n+    _M_init_facet(new num_get<wchar_t>);\n+    _M_init_facet(new num_put<wchar_t>);\n+    _M_init_facet(new time_get<wchar_t>);\n+    _M_init_facet(new time_put<wchar_t>);\n+    _M_init_facet(new std::messages<wchar_t>);\n+#endif\t  \n   }\n   \n   void\n   locale::_Impl::\n   _M_replace_categories(const _Impl* __imp, category __cat)\n   {\n-    category  __mask = locale::all & -static_cast<unsigned int>(locale::all);\n-    for (unsigned int __ix = 0; (-__mask & __cat) != 0; ++__ix, (__mask <<= 1))\n+    const string __none(\"*\");\n+    category __mask;\n+    for (unsigned int __ix = 0; __ix < _S_num_categories; ++__ix)\n       {\n+\t__mask = 1 << __ix;\n \tif (__mask & __cat)\n \t  {\n+\t    // Need to replace entry in _M_facets with other locale's info.\n \t    _M_replace_category(__imp, _S_facet_categories[__ix]);\n-\t    (*_M_category_names)[__ix] = (*(__imp->_M_category_names))[__ix];\n+\t    // If both have names, go ahead and mangle.\n+\t    if (_M_names[__ix] != __none && __imp->_M_names[__ix] != __none)\n+\t      _M_names[__ix] = __imp->_M_names[__ix];\n \t  }\n       }\n   }\n@@ -201,91 +168,36 @@ namespace std {\n   locale::_Impl::\n   _M_install_facet(const locale::id* __idp, facet* __fp)\n   {\n-    if (__fp == 0)\n-      return;\n-\n-    size_t& __index = __idp->_M_index;\n-    if (!__index)\n-      __index = ++locale::id::_S_highwater;  // XXX MT\n-\n-    if (__index >= _M_facets->size())\n-      _M_facets->resize(__index + 1, 0);  // might throw\n-    facet*& __fpr = (*_M_facets)[__index];\n-    // Order matters, here:\n-    __fp->_M_add_reference();\n-    if (__fpr) \n-      __fpr->_M_remove_reference();\n-    __fpr = __fp;\n-  }\n- \n-  void \n-  locale::_Impl::_M_construct_collate(const char* __s)\n-  {\n-    _M_facet_init(new collate_byname<char>(__s, 0));\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _M_facet_init(new collate_byname<wchar_t>(__s, 0));\n-#endif \n-  }\n+    if (__fp)\n+      {\n+\tsize_t& __index = __idp->_M_index;\n+\tif (!__index)\n+\t  __index = ++locale::id::_S_highwater;  // XXX MT\n+\t\n+\tif (__index >= _M_facets->size())\n+\t  _M_facets->resize(__index + 1, 0);  // might throw\n \n-  void \n-  locale::_Impl::_M_construct_ctype(const char* __s)\n-  {\n-    _M_facet_init(new ctype_byname<char>(__s, 0));\n-    _M_facet_init(new codecvt_byname<char, char, mbstate_t>(__s));\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _M_facet_init(new ctype_byname<wchar_t>(__s, 0));\n-    _M_facet_init(new codecvt_byname<wchar_t, char, mbstate_t>(__s));\n-#endif \n-  }\n-    \n-  void \n-  locale::_Impl::_M_construct_monetary(const char* __s)\n-  {\n-    _M_replace_facet(locale::_S_classic, &money_get<char>::id);\n-    _M_replace_facet(locale::_S_classic, &money_put<char>::id);\n-    _M_facet_init(new moneypunct_byname<char, false>(__s, 0));\n-    _M_facet_init(new moneypunct_byname<char, true >(__s, 0));\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _M_replace_facet(locale::_S_classic, &money_get<wchar_t>::id);\n-    _M_replace_facet(locale::_S_classic, &money_put<wchar_t>::id);\n-    _M_facet_init(new moneypunct_byname<wchar_t, false>(__s, 0));\n-    _M_facet_init(new moneypunct_byname<wchar_t, true >(__s, 0));\n-#endif\n-  }\n-    \n-  void \n-  locale::_Impl::_M_construct_numeric(const char* __s)\n-  {\n-    _M_replace_facet(locale::_S_classic, &num_get<char>::id);\n-    _M_replace_facet(locale::_S_classic, &num_put<char>::id);\n-    _M_facet_init(new numpunct_byname<char>(__s, 0));\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _M_replace_facet(locale::_S_classic, &num_get<wchar_t>::id);\n-    _M_replace_facet(locale::_S_classic, &num_put<wchar_t>::id);\n-    _M_facet_init(new numpunct_byname<wchar_t>(__s, 0));\n-#endif \n-  }\n-    \n-  void \n-  locale::_Impl::_M_construct_time(const char* __s)\n-  {\n-    _M_facet_init(new time_get_byname<char>(__s, 0));\n-    _M_facet_init(new time_put_byname<char>(__s, 0));\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _M_facet_init(new time_get_byname<wchar_t>(__s, 0));\n-    _M_facet_init(new time_put_byname<wchar_t>(__s, 0));\n-#endif \n-  }\n-    \n-  void \n-  locale::_Impl::_M_construct_messages(const char* __s)\n-  {\n-    _M_facet_init(new messages_byname<char>(__s, 0));\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _M_facet_init(new messages_byname<wchar_t>(__s, 0));\n-#endif \n+\tfacet*& __fpr = (*_M_facets)[__index];\n+\tif (__fpr)\n+\t  {\n+\t    // Replacing an existing facet.\n+\t    // Order matters, here:\n+\t    __fp->_M_add_reference();\n+\t    if (__fpr) \n+\t      __fpr->_M_remove_reference();\n+\t    __fpr = __fp;\n+\t  }\n+\telse\n+\t  {\n+\t    // Installing a newly created facet into an empty\n+\t    // _M_facets container, say a newly-constructed,\n+\t    // swanky-fresh _Impl.\n+\t    (*_M_facets)[__index] = __fp;\n+\t  }\n+      }\n   }\n }\n \n \n \n+"}, {"sha": "cbac8843187885813a25c7b81a654dcb048b6798", "filename": "libstdc++-v3/testsuite/22_locale/ctor_copy_dtor.cc", "status": "modified", "additions": 104, "deletions": 43, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -1,6 +1,6 @@\n // 2000-09-13 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 2000 Free Software Foundation\n+// Copyright (C) 2000, 2001 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -33,6 +33,14 @@ typedef std::codecvt_byname<wchar_t, char, std::mbstate_t>    w_codecvt_byname;\n \n class gnu_codecvt: public c_codecvt { }; \n \n+class gnu_facet: public std::locale::facet\n+{\n+public:\n+  static std::locale::id id;\n+};\n+\n+std::locale::id gnu_facet::id;\n+\n void test01()\n {\n   using namespace std;\n@@ -65,14 +73,7 @@ void test01()\n     { VERIFY( false ); }\n \n   try \n-    {  VERIFY (has_facet<c_codecvt_byname>(loc02)); }\n-  catch(bad_cast& obj)\n-    { VERIFY( true ); }\n-  catch(...)\n-    { VERIFY( false ); }\n-\n-  try \n-    {  VERIFY (has_facet<w_codecvt_byname>(loc02)); }\n+    { use_facet<gnu_facet>(loc02); }\n   catch(bad_cast& obj)\n     { VERIFY( true ); }\n   catch(...)\n@@ -92,14 +93,7 @@ void test01()\n     { VERIFY( false ); }\n \n   try \n-    {  VERIFY (has_facet<c_codecvt_byname>(loc13)); }\n-  catch(bad_cast& obj)\n-    { VERIFY( true ); }\n-  catch(...)\n-    { VERIFY( false ); }\n-\n-  try \n-    {  VERIFY (has_facet<w_codecvt_byname>(loc13)); }\n+    { use_facet<gnu_facet>(loc13); }\n   catch(bad_cast& obj)\n     { VERIFY( true ); }\n   catch(...)\n@@ -134,32 +128,99 @@ void test01()\n \n   // 4\n   // locale(const locale& other, const char* std_name, category)\n-  locale loc09(loc06, \"C\", locale::ctype);\n-  VERIFY (loc09.name() != \"fr_FR\");\n-  VERIFY (loc09.name() != \"C\");\n-  VERIFY (loc09 != loc01);  \n-  VERIFY (loc09 != loc06);  \n-  // XXX somehow check that the ctype, codecvt facets have \"C\" locale bits...\n-\n-  locale loc10(loc02, \"C\", locale::ctype);\n-  VERIFY (loc10.name() == \"*\");\n-  VERIFY (loc10 != loc01);   // As not named, even tho facets same...\n-  VERIFY (loc10 != loc02);  \n-  // XXX somehow check that the ctype, codecvt facets have \"C\" locale bits...\n-\n-  locale loc11(loc01, \"C\", locale::ctype);\n-  VERIFY (loc11.name() == \"C\");\n-  VERIFY (loc11 == loc01);  \n-  // XXX somehow check that the ctype, codecvt facets have \"C\" locale bits...\n-\n-  try\n-    { locale loc12(loc01, static_cast<const char*>(NULL), locale::ctype); }\n-  catch(runtime_error& obj)\n-    { VERIFY (true); }\n-  catch(...)\n-    { VERIFY (false); }\n-  \n-\n+  {\n+    // This is the same as 5 only use \"C\" for loc(\"C\")\n+    locale loc09(loc06, \"C\", locale::ctype);\n+    VERIFY (loc09.name() != \"fr_FR\");\n+    VERIFY (loc09.name() != \"C\");\n+    VERIFY (loc09.name() != \"*\");\n+    VERIFY (loc09 != loc01);  \n+    VERIFY (loc09 != loc06);  \n+\n+    locale loc10(loc02, \"C\", locale::ctype);\n+    VERIFY (loc10.name() == \"*\");\n+    VERIFY (loc10 != loc01);   // As not named, even tho facets same...\n+    VERIFY (loc10 != loc02);  \n+\n+    locale loc11(loc01, \"C\", locale::ctype);\n+    VERIFY (loc11.name() == \"C\");\n+    VERIFY (loc11 == loc01);  \n+\n+    try\n+      { locale loc12(loc01, static_cast<const char*>(NULL), locale::ctype); }\n+    catch(runtime_error& obj)\n+      { VERIFY (true); }\n+    catch(...)\n+      { VERIFY (false); }\n+\n+    try\n+      { locale loc13(loc01, \"localized by the wu-tang clan\", locale::ctype); }\n+    catch(runtime_error& obj)\n+      { VERIFY (true); }\n+    catch(...)\n+      { VERIFY (false); }\n+\n+    locale loc14(loc06, \"C\", locale::none);\n+    VERIFY (loc14.name() == \"fr_FR\");\n+    VERIFY (loc14 == loc06);  \n+\n+    locale loc15(loc06, \"C\", locale::collate);\n+    VERIFY (loc15.name() != \"fr_FR\");\n+    VERIFY (loc15.name() != \"C\");\n+    VERIFY (loc15.name() != \"*\");\n+    VERIFY (loc15.name() != loc09.name());\n+    VERIFY (loc15 != loc01);  \n+    VERIFY (loc15 != loc06);  \n+    VERIFY (loc15 != loc09);  \n+  }\n+\n+  // 5\n+  // locale(const locale& other, const locale& one, category)\n+  {\n+    // This is the exact same as 4, with locale(\"C\") for \"C\"\n+    locale loc09(loc06, loc01, locale::ctype);\n+    VERIFY (loc09.name() != \"fr_FR\");\n+    VERIFY (loc09.name() != \"C\");\n+    VERIFY (loc09.name() != \"*\");\n+    VERIFY (loc09 != loc01);  \n+    VERIFY (loc09 != loc06);  \n+\n+    locale loc10(loc02, loc01, locale::ctype);\n+    VERIFY (loc10.name() == \"*\");\n+    VERIFY (loc10 != loc01);   // As not named, even tho facets same...\n+    VERIFY (loc10 != loc02);  \n+\n+    locale loc11(loc01, loc01, locale::ctype);\n+    VERIFY (loc11.name() == \"C\");\n+    VERIFY (loc11 == loc01);  \n+\n+    try\n+      { locale loc12(loc01, static_cast<const char*>(NULL), locale::ctype); }\n+    catch(runtime_error& obj)\n+      { VERIFY (true); }\n+    catch(...)\n+      { VERIFY (false); }\n+\n+    try\n+      { locale loc13(loc01, locale(\"wu-tang clan\"), locale::ctype); }\n+    catch(runtime_error& obj)\n+      { VERIFY (true); }\n+    catch(...)\n+      { VERIFY (false); }\n+\n+    locale loc14(loc06, loc01, locale::none);\n+    VERIFY (loc14.name() == \"fr_FR\");\n+    VERIFY (loc14 == loc06);  \n+\n+    locale loc15(loc06, loc01, locale::collate);\n+    VERIFY (loc15.name() != \"fr_FR\");\n+    VERIFY (loc15.name() != \"C\");\n+    VERIFY (loc15.name() != \"*\");\n+    VERIFY (loc15.name() != loc09.name());\n+    VERIFY (loc15 != loc01);  \n+    VERIFY (loc15 != loc06);  \n+    VERIFY (loc15 != loc09);  \n+  }\n }\n #endif /* !defined(_GLIBCPP_USE_WCHAR_T) */\n "}, {"sha": "1f1a42fa914206ec4d36440e99114473ea2b8171", "filename": "libstdc++-v3/testsuite/22_locale/facet.cc", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ffacet.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ffacet.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ffacet.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -22,6 +22,8 @@\n \n #include <cwchar> // for mbstate_t\n #include <locale>\n+#include <stdexcept>\n+#include <string>\n #include <iterator>\n #include <debug_assert.h>\n \n@@ -169,37 +171,66 @@ std::locale::id gnu_facet::id;\n \n void test01()\n {\n-  // 1\n-  gnu_collate \t\t\tobj01;\n-  gnu_ctype \t\t\tobj02;\n-  gnu_codecvt \t\t\tobj03;\n-  gnu_moneypunct\t\tobj04;\n-  gnu_moneypunct_true\t\tobj05;\n-  gnu_money_get\t\t\tobj06;\n-  gnu_money_put\t\t\tobj07;\n-  gnu_numpunct\t\t\tobj08;\n-  gnu_num_get\t\t\tobj09;\n-  gnu_num_put\t\t\tobj10;\n-  gnu_time_get\t\t\tobj11;\n-  gnu_time_put\t\t\tobj12;\n-  gnu_messages\t\t\tobj13;\n-  gnu_time_put_out\t\tobj14(0);\n-  gnu_time_put_byname\t\tobj15(\"gnu_message_byname\", 0);\n-  gnu_time_get_in\t\tobj16(0);\n-  gnu_time_get_byname\t\tobj17(\"gnu_message_byname\", 0);\n-  gnu_num_put_out\t\tobj18(0);\n-  gnu_num_get_in\t\tobj19(0);\n-  gnu_numpunct_byname\t\tobj20(\"gnu_message_byname\", 0);\n-  gnu_money_put_out\t\tobj21(0);\n-  gnu_money_get_in\t\tobj22(0);\n-  gnu_moneypunct_byname_false\tobj23(\"gnu_message_byname\", 0);\n-  gnu_moneypunct_byname_true\tobj24(\"gnu_message_byname\", 0);\n-  gnu_ctype_byname\t\tobj25(\"gnu_message_byname\", 0);\n-  gnu_collate_byname\t\tobj26(\"gnu_message_byname\", 0);\n-  gnu_messages_byname\t\tobj27(\"gnu_message_byname\", 0);\n+  bool test = true;\n+  const std::string name_no(\"*\");\n+  const std::string name_c(\"C\");\n+\n+  try \n+    {\n+      gnu_collate \t\t\tobj01;\n+      gnu_ctype \t\t\tobj02;\n+      gnu_codecvt \t\t\tobj03;\n+      gnu_moneypunct\t\t\tobj04;\n+      gnu_moneypunct_true\t\tobj05;\n+      gnu_money_get\t\t\tobj06;\n+      gnu_money_put\t\t\tobj07;\n+      gnu_numpunct\t\t\tobj08;\n+      gnu_num_get\t\t\tobj09;\n+      gnu_num_put\t\t\tobj10;\n+      gnu_time_get\t\t\tobj11;\n+      gnu_time_put\t\t\tobj12;\n+      gnu_messages\t\t\tobj13;\n+      gnu_time_put_out\t\t\tobj14(0);\n+      gnu_time_put_byname\t\tobj15(\"C\", 0);\n+      gnu_time_get_in\t\t\tobj16(0);\n+      gnu_time_get_byname\t\tobj17(\"C\", 0);\n+      gnu_num_put_out\t\t\tobj18(0);\n+      gnu_num_get_in\t\t\tobj19(0);\n+      gnu_numpunct_byname\t\tobj20(\"C\", 0);\n+      gnu_money_put_out\t\t\tobj21(0);\n+      gnu_money_get_in\t\t\tobj22(0);\n+      gnu_moneypunct_byname_false\tobj23(\"C\", 0);\n+      gnu_moneypunct_byname_true\tobj24(\"C\", 0);\n+      gnu_ctype_byname\t\t\tobj25(\"C\", 0);\n+      gnu_collate_byname\t\tobj26(\"C\", 0);\n+      gnu_messages_byname\t\tobj27(\"C\", 0);\n+    }\n+  catch (std::runtime_error& obj)\n+    { \n+      // named locale not valid\n+      VERIFY( false );\n+    }\n+  catch (std::exception& obj)\n+    {\n+      // some other error\n+      VERIFY( false );\n+    }\n \n   // 2\n-  gnu_facet \t\t\tobj28;\n+  try\n+    { \n+      gnu_facet \t\t\tobj28; \n+    }\n+  catch (std::runtime_error& obj)\n+    { \n+      // named locale not valid\n+      VERIFY( false );\n+    }\n+  catch (std::exception& obj)\n+    {\n+      // some other error\n+      VERIFY( false );\n+    }\n }\n \n int main ()"}, {"sha": "c474a17ee8744c3d22816191648eb27417a1c762", "filename": "libstdc++-v3/testsuite/22_locale/members.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmembers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmembers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmembers.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,140 @@\n+// 2001-01-19 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.3.1.1  numpunct members\n+\n+#include <locale>\n+#include <string>\n+#include <debug_assert.h>\n+\n+// creating unnamed locales 1 using new + combine\n+void\n+test01()\n+{\n+  using namespace std;\n+  bool test = true;\n+  const string name_c(\"C\");\n+  const string str_unnamed(\"*\");\n+  string str;\n+\n+  // construct a locale object with the specialized facet.\n+  locale\t\tloc_c = locale::classic();\n+  locale \t\tloc_1(locale::classic(), new numpunct<char>);\n+\n+  // check names\n+  VERIFY( loc_c.name() == name_c );\n+  VERIFY( loc_1.name() == str_unnamed );\n+\n+  // sanity check the constructed locale has the specialized facet.\n+  VERIFY( has_facet<numpunct<char> >(loc_1) );\n+  VERIFY( has_facet<numpunct<char> >(loc_c) );\n+  \n+  // extract facet\n+  const numpunct<char>&\tf_nump_1 = use_facet<numpunct<char> >(loc_1); \n+  const numpunct<char>&\tf_nump_c = use_facet<numpunct<char> >(loc_c); \n+\n+  // attempt to re-synthesize classic locale\n+  locale\t\tloc_2 = loc_1.combine<numpunct<char> >(loc_c);\n+  VERIFY( loc_2.name() == str_unnamed );\n+  VERIFY( loc_2 != loc_c );\n+}\n+\n+\n+void\n+test02()\n+{\n+  using namespace std;\n+  bool test = true;\n+  const string name_c(\"C\");\n+  const string name_no(\"*\");\n+  string str;\n+\n+  // construct a locale object with the specialized facet.\n+  locale\t\tloc_c = locale::classic();\n+  locale \t\tloc_1(locale::classic(), \n+\t\t\t      new numpunct_byname<char>(\"fr_FR\"));\n+  locale\t\tloc_fr(\"fr_FR\");\n+\n+  // check names\n+  VERIFY( loc_c.name() == name_c );\n+  VERIFY( loc_1.name() == name_no );\n+\n+  // sanity check the constructed locale has the specialized facet.\n+  VERIFY( has_facet<numpunct<char> >(loc_1) );\n+  VERIFY( has_facet<numpunct<char> >(loc_c) );\n+  \n+  // attempt to re-synthesize classic locale\n+  locale\t\tloc_2 = loc_1.combine<numpunct<char> >(loc_c);\n+  VERIFY( loc_2.name() == name_no );\n+  VERIFY( loc_2 != loc_c );\n+\n+  // extract facet\n+  const numpunct<char>&\tf_nump_1 = use_facet<numpunct<char> >(loc_1); \n+  const numpunct<char>&\tf_nump_2 = use_facet<numpunct<char> >(loc_2); \n+  const numpunct<char>&\tf_nump_c = use_facet<numpunct<char> >(loc_c); \n+  const numpunct<char>&\tf_nump_fr = use_facet<numpunct<char> >(loc_fr); \n+\n+  // sanity check the data is correct.\n+  char dp1 = f_nump_c.decimal_point();\n+  char th1 = f_nump_c.thousands_sep();\n+  string g1 = f_nump_c.grouping();\n+  string t1 = f_nump_c.truename();\n+  string f1 = f_nump_c.falsename();\n+\n+  char dp2 = f_nump_1.decimal_point();\n+  char th2 = f_nump_1.thousands_sep();\n+  string g2 = f_nump_1.grouping();\n+  string t2 = f_nump_1.truename();\n+  string f2 = f_nump_1.falsename();\n+\n+  char dp3 = f_nump_2.decimal_point();\n+  char th3 = f_nump_2.thousands_sep();\n+  string g3 = f_nump_2.grouping();\n+  string t3 = f_nump_2.truename();\n+  string f3 = f_nump_2.falsename();\n+\n+  char dp4 = f_nump_fr.decimal_point();\n+  char th4 = f_nump_fr.thousands_sep();\n+  string g4 = f_nump_fr.grouping();\n+  string t4 = f_nump_fr.truename();\n+  string f4 = f_nump_fr.falsename();\n+\n+#if 0\n+  // XXX these should not be the same if named locales are working correctly.\n+  VERIFY( dp1 != dp2 );\n+  VERIFY( th1 != th2 );\n+#endif\n+\n+  VERIFY( dp1 == dp3 );\n+  VERIFY( th1 == th3 );\n+  VERIFY( t1 == t3 );\n+  VERIFY( f1 == f3 );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+\n+\n+"}, {"sha": "f50e99bffc9d5ae00dd0cc0b17e7f18f83c1d2e4", "filename": "libstdc++-v3/testsuite/22_locale/numpunct.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,34 @@\n+// 2001-01-23  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.3 the numeric punctuation facet\n+\n+#include <locale>\n+\n+// Should be able to instantiate this for other types besides char, wchar_t\n+class gnu_numpunct: public std::numpunct<unsigned char> \n+{ };\n+\n+\n+int main() \n+{ \n+  gnu_numpunct facet01;\n+  return 0;\n+}"}, {"sha": "444f364a2e5f4f48cfc9463114169ca15f04483a", "filename": "libstdc++-v3/testsuite/22_locale/numpunct_byname.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_byname.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_byname.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_byname.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,73 @@\n+// 2001-01-24 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.3.2 Template class numpunct_byname\n+\n+#include <locale>\n+#include <debug_assert.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  \n+  bool test = true;\n+  string str;\n+\n+  locale loc_byname(locale::classic(), new numpunct_byname<char>(\"de_DE\"));\n+  str = loc_byname.name();\n+\n+  locale loc_de(\"de_DE\");\n+  str = loc_de.name();\n+\n+  VERIFY( loc_de != loc_byname );\n+\n+  // cache the numpunct facets\n+  const numpunct<char>& nump_byname = use_facet<numpunct<char> >(loc_byname); \n+  const numpunct<char>& nump_de = use_facet<numpunct<char> >(loc_de); \n+\n+  // sanity check that the data match\n+  char dp1 = nump_byname.decimal_point();\n+  char th1 = nump_byname.thousands_sep();\n+  string g1 = nump_byname.grouping();\n+  string t1 = nump_byname.truename();\n+  string f1 = nump_byname.falsename();\n+\n+  char dp2 = nump_de.decimal_point();\n+  char th2 = nump_de.thousands_sep();\n+  string g2 = nump_de.grouping();\n+  string t2 = nump_de.truename();\n+  string f2 = nump_de.falsename();\n+\n+  VERIFY( dp1 == dp2 );\n+  VERIFY( th1 == th2 );\n+  VERIFY( g1 == g2 );\n+  VERIFY( t1 == t2 );\n+  VERIFY( f1 == f2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}\n+\n+\n+"}, {"sha": "64c329fee199974f08215cb0c999d50dafe26b01", "filename": "libstdc++-v3/testsuite/22_locale/numpunct_char_members.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_char_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0214010c60e8777e7f40e3b63c158134af301525/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_char_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_char_members.cc?ref=0214010c60e8777e7f40e3b63c158134af301525", "patch": "@@ -0,0 +1,91 @@\n+// 2001-01-17 bkoz\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.3.1.1 nunpunct members\n+\n+#include <locale>\n+#include <debug_assert.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  \n+  bool test = true;\n+  string str;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  str = loc_c.name();\n+\n+  locale loc_us(\"en_US\");\n+  str = loc_us.name();\n+  VERIFY( loc_c != loc_us );\n+\n+  locale loc_fr(\"fr_FR\");\n+  str = loc_fr.name();\n+  VERIFY( loc_c != loc_fr );\n+\n+  VERIFY( loc_us != loc_fr );\n+\n+  locale loc_combo(loc_us, loc_fr, locale::numeric);\n+  str = loc_combo.name();\n+  VERIFY( loc_combo != loc_fr );\n+  VERIFY( loc_combo != loc_us );\n+  VERIFY( loc_combo != loc_c );\n+\n+  // cache the numpunct facets\n+  const numpunct<char>& nump_c = use_facet<numpunct<char> >(loc_c); \n+  const numpunct<char>& nump_us = use_facet<numpunct<char> >(loc_us); \n+  const numpunct<char>& nump_fr = use_facet<numpunct<char> >(loc_fr); \n+  const numpunct<char>& nump_combo = use_facet<numpunct<char> >(loc_combo); \n+\n+  // sanity check the data is correct.\n+  char dp1 = nump_c.decimal_point();\n+  char th1 = nump_c.thousands_sep();\n+  string g1 = nump_c.grouping();\n+  string t1 = nump_c.truename();\n+  string f1 = nump_c.falsename();\n+\n+  char dp2 = nump_us.decimal_point();\n+  char th2 = nump_us.thousands_sep();\n+  string g2 = nump_us.grouping();\n+  string t2 = nump_us.truename();\n+  string f2 = nump_us.falsename();\n+\n+  char dp3 = nump_fr.decimal_point();\n+  char th3 = nump_fr.thousands_sep();\n+  string g3 = nump_fr.grouping();\n+  string t3 = nump_fr.truename();\n+  string f3 = nump_fr.falsename();\n+\n+  char dp4 = nump_combo.decimal_point();\n+  char th4 = nump_combo.thousands_sep();\n+  string g4 = nump_combo.grouping();\n+  string t4 = nump_combo.truename();\n+  string f4 = nump_combo.falsename();\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}\n+"}]}