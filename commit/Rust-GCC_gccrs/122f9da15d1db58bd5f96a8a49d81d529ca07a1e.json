{"sha": "122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIyZjlkYTE1ZDFkYjU4YmQ1Zjk2YThhNDlkODFkNTI5Y2EwN2ExZQ==", "commit": {"author": {"name": "Daniel Santos", "email": "daniel.santos@pobox.com", "date": "2017-08-23T21:46:14Z"}, "committer": {"name": "Daniel Santos", "email": "dansan@gcc.gnu.org", "date": "2017-08-23T21:46:14Z"}, "message": "PR target/80969 - Fix ICE with -mabi=ms -mavx512f, reduce wasted space when realigning stack.\n\n2017-08-23  Daniel Santos  <daniel.santos@pobox.com>\n\n\t* config/i386/i386.h (ix86_frame::stack_realign_allocate_offset):\n\tRemove field.\n\t(ix86_frame::stack_realign_allocate): New field.\n\t(struct machine_frame_state): Modify comments.\n\t(machine_frame_state::sp_realigned_fp_end): New field.\n\t* config/i386/i386.c (ix86_compute_frame_layout): Rework stack frame\n\tlayout calculation.\n\t(sp_valid_at): Add assertion to assure no attempt to access invalid\n\toffset of a realigned stack.\n\t(fp_valid_at): Likewise.\n\t(choose_baseaddr): Modify comments.\n\t(ix86_emit_outlined_ms2sysv_save): Adjust to changes in\n\tix86_expand_prologue.\n\t(ix86_expand_prologue): Modify stack realignment and allocation.\n\t(ix86_expand_epilogue): Modify comments.\n\t* doc/sourcebuild.texi: Add documentation for target selectors avx2,\n\tavx2_runtime, avx512f, and avx512f_runtime.\n\n2017-08-23  Daniel Santos  <daniel.santos@pobox.com>\n\n\t* gcc.target/i386/pr80969-1.c: New testcase.\n\t* gcc.target/i386/pr80969-2a.c: Likewise.\n\t* gcc.target/i386/pr80969-2.c: Likewise.\n\t* gcc.target/i386/pr80969-3.c: Likewise.\n\t* gcc.target/i386/pr80969-4a.c: Likewise.\n\t* gcc.target/i386/pr80969-4b.c: Likewise.\n\t* gcc.target/i386/pr80969-4.c: Likewise.\n\t* gcc.target/i386/pr80969-4.h: New header common to pr80969-4*.c\n\t* lib/target-supports.exp (check_avx512_os_support_available,\n\tcheck_avx512f_hw_available, check_effective_target_avx512f_runtime):\n\tNew proceedures for target avx512f and avx512f_runtime selectors.\n\t(check_avx2_hw_available): Fix breakage due NULL being undefined.\n\nFrom-SVN: r251321", "tree": {"sha": "3e22ff025c943b2613b1046be2eb62d27a8237a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e22ff025c943b2613b1046be2eb62d27a8237a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/comments", "author": {"login": "daniel-santos", "id": 980562, "node_id": "MDQ6VXNlcjk4MDU2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/980562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daniel-santos", "html_url": "https://github.com/daniel-santos", "followers_url": "https://api.github.com/users/daniel-santos/followers", "following_url": "https://api.github.com/users/daniel-santos/following{/other_user}", "gists_url": "https://api.github.com/users/daniel-santos/gists{/gist_id}", "starred_url": "https://api.github.com/users/daniel-santos/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daniel-santos/subscriptions", "organizations_url": "https://api.github.com/users/daniel-santos/orgs", "repos_url": "https://api.github.com/users/daniel-santos/repos", "events_url": "https://api.github.com/users/daniel-santos/events{/privacy}", "received_events_url": "https://api.github.com/users/daniel-santos/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e931c2a2819523ce7847b622eaf8ae5f740744e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e931c2a2819523ce7847b622eaf8ae5f740744e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e931c2a2819523ce7847b622eaf8ae5f740744e"}], "stats": {"total": 579, "additions": 496, "deletions": 83}, "files": [{"sha": "96aa15157822b0d469824e807795ebfb65b0ec10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -1,3 +1,23 @@\n+2017-08-23  Daniel Santos  <daniel.santos@pobox.com>\n+\n+\t* config/i386/i386.h (ix86_frame::stack_realign_allocate_offset):\n+\tRemove field.\n+\t(ix86_frame::stack_realign_allocate): New field.\n+\t(struct machine_frame_state): Modify comments.\n+\t(machine_frame_state::sp_realigned_fp_end): New field.\n+\t* config/i386/i386.c (ix86_compute_frame_layout): Rework stack frame\n+\tlayout calculation.\n+\t(sp_valid_at): Add assertion to assure no attempt to access invalid\n+\toffset of a realigned stack.\n+\t(fp_valid_at): Likewise.\n+\t(choose_baseaddr): Modify comments.\n+\t(ix86_emit_outlined_ms2sysv_save): Adjust to changes in\n+\tix86_expand_prologue.\n+\t(ix86_expand_prologue): Modify stack realignment and allocation.\n+\t(ix86_expand_epilogue): Modify comments.\n+\t* doc/sourcebuild.texi: Add documentation for target selectors avx2,\n+\tavx2_runtime, avx512f, and avx512f_runtime.\n+\n 2017-08-23  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.opt: Remove unneeded Init(0) initializations."}, {"sha": "9f1f8e797e79ace0a879d17452d7bcd49b3e3c3b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 140, "deletions": 77, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -12961,6 +12961,14 @@ ix86_compute_frame_layout (void)\n   gcc_assert (preferred_alignment >= STACK_BOUNDARY / BITS_PER_UNIT);\n   gcc_assert (preferred_alignment <= stack_alignment_needed);\n \n+  /* The only ABI saving SSE regs should be 64-bit ms_abi.  */\n+  gcc_assert (TARGET_64BIT || !frame->nsseregs);\n+  if (TARGET_64BIT && m->call_ms2sysv)\n+    {\n+      gcc_assert (stack_alignment_needed >= 16);\n+      gcc_assert (!frame->nsseregs);\n+    }\n+\n   /* For SEH we have to limit the amount of code movement into the prologue.\n      At present we do this via a BLOCKAGE, at which point there's very little\n      scheduling that can be done, which means that there's very little point\n@@ -13023,54 +13031,88 @@ ix86_compute_frame_layout (void)\n   if (TARGET_SEH)\n     frame->hard_frame_pointer_offset = offset;\n \n-  /* When re-aligning the stack frame, but not saving SSE registers, this\n-     is the offset we want adjust the stack pointer to.  */\n-  frame->stack_realign_allocate_offset = offset;\n+  /* Calculate the size of the va-arg area (not including padding, if any).  */\n+  frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n \n-  /* The re-aligned stack starts here.  Values before this point are not\n-     directly comparable with values below this point.  Use sp_valid_at\n-     to determine if the stack pointer is valid for a given offset and\n-     fp_valid_at for the frame pointer.  */\n   if (stack_realign_fp)\n-    offset = ROUND_UP (offset, stack_alignment_needed);\n-  frame->stack_realign_offset = offset;\n-\n-  if (TARGET_64BIT && m->call_ms2sysv)\n     {\n-      gcc_assert (stack_alignment_needed >= 16);\n-      gcc_assert (!frame->nsseregs);\n+      /* We may need a 16-byte aligned stack for the remainder of the\n+\t register save area, but the stack frame for the local function\n+\t may require a greater alignment if using AVX/2/512.  In order\n+\t to avoid wasting space, we first calculate the space needed for\n+\t the rest of the register saves, add that to the stack pointer,\n+\t and then realign the stack to the boundary of the start of the\n+\t frame for the local function.  */\n+      HOST_WIDE_INT space_needed = 0;\n+      HOST_WIDE_INT sse_reg_space_needed = 0;\n \n-      m->call_ms2sysv_pad_in = !!(offset & UNITS_PER_WORD);\n-      offset += xlogue_layout::get_instance ().get_stack_space_used ();\n-    }\n+      if (TARGET_64BIT)\n+\t{\n+\t  if (m->call_ms2sysv)\n+\t    {\n+\t      m->call_ms2sysv_pad_in = 0;\n+\t      space_needed = xlogue_layout::get_instance ().get_stack_space_used ();\n+\t    }\n \n-  /* Align and set SSE register save area.  */\n-  else if (frame->nsseregs)\n-    {\n-      /* The only ABI that has saved SSE registers (Win64) also has a\n-\t 16-byte aligned default stack.  However, many programs violate\n-\t the ABI, and Wine64 forces stack realignment to compensate.\n+\t  else if (frame->nsseregs)\n+\t    /* The only ABI that has saved SSE registers (Win64) also has a\n+\t       16-byte aligned default stack.  However, many programs violate\n+\t       the ABI, and Wine64 forces stack realignment to compensate.  */\n+\t    space_needed = frame->nsseregs * 16;\n \n-\t If the incoming stack boundary is at least 16 bytes, or DRAP is\n-\t required and the DRAP re-alignment boundary is at least 16 bytes,\n-\t then we want the SSE register save area properly aligned.  */\n-      if (ix86_incoming_stack_boundary >= 128\n-\t       || (stack_realign_drap && stack_alignment_needed >= 16))\n-\toffset = ROUND_UP (offset, 16);\n-      offset += frame->nsseregs * 16;\n-      frame->stack_realign_allocate_offset = offset;\n+\t  sse_reg_space_needed = space_needed = ROUND_UP (space_needed, 16);\n+\n+\t  /* 64-bit frame->va_arg_size should always be a multiple of 16, but\n+\t     rounding to be pedantic.  */\n+\t  space_needed = ROUND_UP (space_needed + frame->va_arg_size, 16);\n+\t}\n+      else\n+\tspace_needed = frame->va_arg_size;\n+\n+      /* Record the allocation size required prior to the realignment AND.  */\n+      frame->stack_realign_allocate = space_needed;\n+\n+      /* The re-aligned stack starts at frame->stack_realign_offset.  Values\n+\t before this point are not directly comparable with values below\n+\t this point.  Use sp_valid_at to determine if the stack pointer is\n+\t valid for a given offset, fp_valid_at for the frame pointer, or\n+\t choose_baseaddr to have a base register chosen for you.\n+\n+\t Note that the result of (frame->stack_realign_offset\n+\t & (stack_alignment_needed - 1)) may not equal zero.  */\n+      offset = ROUND_UP (offset + space_needed, stack_alignment_needed);\n+      frame->stack_realign_offset = offset - space_needed;\n+      frame->sse_reg_save_offset = frame->stack_realign_offset\n+\t\t\t\t\t\t\t+ sse_reg_space_needed;\n     }\n+  else\n+    {\n+      frame->stack_realign_offset = offset;\n \n-  frame->sse_reg_save_offset = offset;\n+      if (TARGET_64BIT && m->call_ms2sysv)\n+\t{\n+\t  m->call_ms2sysv_pad_in = !!(offset & UNITS_PER_WORD);\n+\t  offset += xlogue_layout::get_instance ().get_stack_space_used ();\n+\t}\n \n-  /* Va-arg area */\n-  frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n-  offset += frame->va_arg_size;\n+      /* Align and set SSE register save area.  */\n+      else if (frame->nsseregs)\n+\t{\n+\t  /* If the incoming stack boundary is at least 16 bytes, or DRAP is\n+\t     required and the DRAP re-alignment boundary is at least 16 bytes,\n+\t     then we want the SSE register save area properly aligned.  */\n+\t  if (ix86_incoming_stack_boundary >= 128\n+\t\t  || (stack_realign_drap && stack_alignment_needed >= 16))\n+\t    offset = ROUND_UP (offset, 16);\n+\t  offset += frame->nsseregs * 16;\n+\t}\n+      frame->sse_reg_save_offset = offset;\n+      offset += frame->va_arg_size;\n+    }\n \n   /* Align start of frame for local function.  */\n-  if (stack_realign_fp\n-      || m->call_ms2sysv\n-      || offset != frame->sse_reg_save_offset\n+  if (m->call_ms2sysv\n+      || frame->va_arg_size != 0\n       || size != 0\n       || !crtl->is_leaf\n       || cfun->calls_alloca\n@@ -13178,26 +13220,36 @@ choose_baseaddr_len (unsigned int regno, HOST_WIDE_INT offset)\n   return len;\n }\n \n-/* Determine if the stack pointer is valid for accessing the cfa_offset.\n-   The register is saved at CFA - CFA_OFFSET.  */\n+/* Determine if the stack pointer is valid for accessing the CFA_OFFSET in\n+   the frame save area.  The register is saved at CFA - CFA_OFFSET.  */\n \n-static inline bool\n+static bool\n sp_valid_at (HOST_WIDE_INT cfa_offset)\n {\n   const struct machine_frame_state &fs = cfun->machine->fs;\n-  return fs.sp_valid && !(fs.sp_realigned\n-\t\t\t  && cfa_offset <= fs.sp_realigned_offset);\n+  if (fs.sp_realigned && cfa_offset <= fs.sp_realigned_offset)\n+    {\n+      /* Validate that the cfa_offset isn't in a \"no-man's land\".  */\n+      gcc_assert (cfa_offset <= fs.sp_realigned_fp_last);\n+      return false;\n+    }\n+  return fs.sp_valid;\n }\n \n-/* Determine if the frame pointer is valid for accessing the cfa_offset.\n-   The register is saved at CFA - CFA_OFFSET.  */\n+/* Determine if the frame pointer is valid for accessing the CFA_OFFSET in\n+   the frame save area.  The register is saved at CFA - CFA_OFFSET.  */\n \n static inline bool\n fp_valid_at (HOST_WIDE_INT cfa_offset)\n {\n   const struct machine_frame_state &fs = cfun->machine->fs;\n-  return fs.fp_valid && !(fs.sp_valid && fs.sp_realigned\n-\t\t\t  && cfa_offset > fs.sp_realigned_offset);\n+  if (fs.sp_realigned && cfa_offset > fs.sp_realigned_fp_last)\n+    {\n+      /* Validate that the cfa_offset isn't in a \"no-man's land\".  */\n+      gcc_assert (cfa_offset >= fs.sp_realigned_offset);\n+      return false;\n+    }\n+  return fs.fp_valid;\n }\n \n /* Choose a base register based upon alignment requested, speed and/or\n@@ -13308,10 +13360,13 @@ choose_basereg (HOST_WIDE_INT cfa_offset, rtx &base_reg,\n }\n \n /* Return an RTX that points to CFA_OFFSET within the stack frame and\n-   the alignment of address.  If align is non-null, it should point to\n+   the alignment of address.  If ALIGN is non-null, it should point to\n    an alignment value (in bits) that is preferred or zero and will\n-   recieve the alignment of the base register that was selected.  The\n-   valid base registers are taken from CFUN->MACHINE->FS.  */\n+   recieve the alignment of the base register that was selected,\n+   irrespective of rather or not CFA_OFFSET is a multiple of that\n+   alignment value.\n+\n+   The valid base registers are taken from CFUN->MACHINE->FS.  */\n \n static rtx\n choose_baseaddr (HOST_WIDE_INT cfa_offset, unsigned int *align)\n@@ -14394,35 +14449,35 @@ ix86_emit_outlined_ms2sysv_save (const struct ix86_frame &frame)\n   rtx sym, addr;\n   rtx rax = gen_rtx_REG (word_mode, AX_REG);\n   const struct xlogue_layout &xlogue = xlogue_layout::get_instance ();\n-  HOST_WIDE_INT rax_offset = xlogue.get_stub_ptr_offset () + m->fs.sp_offset;\n-  HOST_WIDE_INT stack_alloc_size = frame.stack_pointer_offset - m->fs.sp_offset;\n-  HOST_WIDE_INT stack_align_off_in = xlogue.get_stack_align_off_in ();\n+  HOST_WIDE_INT allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n+\n+  /* AL should only be live with sysv_abi.  */\n+  gcc_assert (!ix86_eax_live_at_start_p ());\n \n-  /* Verify that the incoming stack 16-byte alignment offset matches the\n-     layout we're using.  */\n-  gcc_assert (stack_align_off_in == (m->fs.sp_offset & UNITS_PER_WORD));\n+  /* Setup RAX as the stub's base pointer.  We use stack_realign_offset rather\n+     we've actually realigned the stack or not.  */\n+  align = GET_MODE_ALIGNMENT (V4SFmode);\n+  addr = choose_baseaddr (frame.stack_realign_offset\n+\t\t\t  + xlogue.get_stub_ptr_offset (), &align);\n+  gcc_assert (align >= GET_MODE_ALIGNMENT (V4SFmode));\n+  emit_insn (gen_rtx_SET (rax, addr));\n+\n+  /* Allocate stack if not already done.  */\n+  if (allocate > 0)\n+      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\tGEN_INT (-allocate), -1, false);\n \n   /* Get the stub symbol.  */\n   sym = xlogue.get_stub_rtx (frame_pointer_needed ? XLOGUE_STUB_SAVE_HFP\n \t\t\t\t\t\t  : XLOGUE_STUB_SAVE);\n   RTVEC_ELT (v, vi++) = gen_rtx_USE (VOIDmode, sym);\n \n-  /* Setup RAX as the stub's base pointer.  */\n-  align = GET_MODE_ALIGNMENT (V4SFmode);\n-  addr = choose_baseaddr (rax_offset, &align);\n-  gcc_assert (align >= GET_MODE_ALIGNMENT (V4SFmode));\n-  insn = emit_insn (gen_rtx_SET (rax, addr));\n-\n-  gcc_assert (stack_alloc_size >= xlogue.get_stack_space_used ());\n-  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t     GEN_INT (-stack_alloc_size), -1,\n-\t\t\t     m->fs.cfa_reg == stack_pointer_rtx);\n   for (i = 0; i < ncregs; ++i)\n     {\n       const xlogue_layout::reginfo &r = xlogue.get_reginfo (i);\n       rtx reg = gen_rtx_REG ((SSE_REGNO_P (r.regno) ? V4SFmode : word_mode),\n \t\t\t     r.regno);\n-      RTVEC_ELT (v, vi++) = gen_frame_store (reg, rax, -r.offset);;\n+      RTVEC_ELT (v, vi++) = gen_frame_store (reg, rax, -r.offset);\n     }\n \n   gcc_assert (vi == (unsigned)GET_NUM_ELEM (v));\n@@ -14676,27 +14731,35 @@ ix86_expand_prologue (void)\n       int align_bytes = crtl->stack_alignment_needed / BITS_PER_UNIT;\n       gcc_assert (align_bytes > MIN_STACK_BOUNDARY / BITS_PER_UNIT);\n \n+      /* Record last valid frame pointer offset.  */\n+      m->fs.sp_realigned_fp_last = frame.reg_save_offset;\n+\n       /* The computation of the size of the re-aligned stack frame means\n \t that we must allocate the size of the register save area before\n \t performing the actual alignment.  Otherwise we cannot guarantee\n \t that there's enough storage above the realignment point.  */\n-      allocate = frame.stack_realign_allocate_offset - m->fs.sp_offset;\n-      if (allocate && !m->call_ms2sysv)\n+      allocate = frame.reg_save_offset - m->fs.sp_offset\n+\t\t + frame.stack_realign_allocate;\n+      if (allocate)\n         pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t   GEN_INT (-allocate), -1, false);\n \n       /* Align the stack.  */\n       insn = emit_insn (ix86_gen_andsp (stack_pointer_rtx,\n \t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\tGEN_INT (-align_bytes)));\n-      /* For the purposes of register save area addressing, the stack\n-\t pointer can no longer be used to access anything in the frame\n-\t below m->fs.sp_realigned_offset and the frame pointer cannot be\n-\t used for anything at or above.  */\n       m->fs.sp_offset = ROUND_UP (m->fs.sp_offset, align_bytes);\n-      m->fs.sp_realigned = true;\n-      m->fs.sp_realigned_offset = m->fs.sp_offset - frame.nsseregs * 16;\n+      m->fs.sp_realigned_offset = m->fs.sp_offset\n+\t\t\t\t\t      - frame.stack_realign_allocate;\n+      /* The stack pointer may no longer be equal to CFA - m->fs.sp_offset.\n+\t Beyond this point, stack access should be done via choose_baseaddr or\n+\t by using sp_valid_at and fp_valid_at to determine the correct base\n+\t register.  Henceforth, any CFA offset should be thought of as logical\n+\t and not physical.  */\n+      gcc_assert (m->fs.sp_realigned_offset >= m->fs.sp_realigned_fp_last);\n       gcc_assert (m->fs.sp_realigned_offset == frame.stack_realign_offset);\n+      m->fs.sp_realigned = true;\n+\n       /* SEH unwind emit doesn't currently support REG_CFA_EXPRESSION, which\n \t is needed to describe where a register is saved using a realigned\n \t stack pointer, so we need to invalidate the stack pointer for that\n@@ -14758,7 +14821,7 @@ ix86_expand_prologue (void)\n      so probe if the size is non-negative to preserve the protection area.  */\n   if (allocate >= 0 && flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n     {\n-      /* We expect the registers to be saved when probes are used.  */\n+      /* We expect the GP registers to be saved when probes are used.  */\n       gcc_assert (int_registers_saved);\n \n       if (STACK_CHECK_MOVING_SP)\n@@ -15393,10 +15456,10 @@ ix86_expand_epilogue (int style)\n   if (restore_regs_via_mov || frame.nsseregs)\n     {\n       /* Ensure that the entire register save area is addressable via\n-\t the stack pointer, if we will restore via sp.  */\n+\t the stack pointer, if we will restore SSE regs via sp.  */\n       if (TARGET_64BIT\n \t  && m->fs.sp_offset > 0x7fffffff\n-\t  && !(fp_valid_at (frame.stack_realign_offset) || m->fs.drap_valid)\n+\t  && sp_valid_at (frame.stack_realign_offset)\n \t  && (frame.nsseregs + frame.nregs) != 0)\n \t{\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,"}, {"sha": "dad6499ca1d1442c91548fea712507eecb16a755", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -2503,7 +2503,7 @@ struct GTY(()) ix86_frame\n   HOST_WIDE_INT stack_pointer_offset;\n   HOST_WIDE_INT hfp_save_offset;\n   HOST_WIDE_INT reg_save_offset;\n-  HOST_WIDE_INT stack_realign_allocate_offset;\n+  HOST_WIDE_INT stack_realign_allocate;\n   HOST_WIDE_INT stack_realign_offset;\n   HOST_WIDE_INT sse_reg_save_offset;\n \n@@ -2512,7 +2512,9 @@ struct GTY(()) ix86_frame\n   bool save_regs_using_mov;\n };\n \n-/* Machine specific frame tracking during prologue/epilogue generation.  */\n+/* Machine specific frame tracking during prologue/epilogue generation.  All\n+   values are positive, but since the x86 stack grows downward, are subtratced\n+   from the CFA to produce a valid address.  */\n \n struct GTY(()) machine_frame_state\n {\n@@ -2550,13 +2552,19 @@ struct GTY(()) machine_frame_state\n \n   /* Indicates whether the stack pointer has been re-aligned.  When set,\n      SP/FP continue to be relative to the CFA, but the stack pointer\n-     should only be used for offsets >= sp_realigned_offset, while\n-     the frame pointer should be used for offsets < sp_realigned_offset.\n+     should only be used for offsets > sp_realigned_offset, while\n+     the frame pointer should be used for offsets <= sp_realigned_fp_last.\n      The flags realigned and sp_realigned are mutually exclusive.  */\n   BOOL_BITFIELD sp_realigned : 1;\n \n-  /* If sp_realigned is set, this is the offset from the CFA that the\n-     stack pointer was realigned to.  */\n+  /* If sp_realigned is set, this is the last valid offset from the CFA\n+     that can be used for access with the frame pointer.  */\n+  HOST_WIDE_INT sp_realigned_fp_last;\n+\n+  /* If sp_realigned is set, this is the offset from the CFA that the stack\n+     pointer was realigned, and may or may not be equal to sp_realigned_fp_last.\n+     Access via the stack pointer is only valid for offsets that are greater than\n+     this value.  */\n   HOST_WIDE_INT sp_realigned_offset;\n };\n "}, {"sha": "9901c940e79767041230daab11ec61ead8e14936", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -1855,6 +1855,18 @@ Target supports compiling @code{avx} instructions.\n @item avx_runtime\n Target supports the execution of @code{avx} instructions.\n \n+@item avx2\n+Target supports compiling @code{avx2} instructions.\n+\n+@item avx2_runtime\n+Target supports the execution of @code{avx2} instructions.\n+\n+@item avx512f\n+Target supports compiling @code{avx512f} instructions.\n+\n+@item avx512f_runtime\n+Target supports the execution of @code{avx512f} instructions.\n+\n @item cell_hw\n Test system can execute AltiVec and Cell PPU instructions.\n "}, {"sha": "158f523fe17c3b0bac600220c9648f361888f634", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -1,3 +1,18 @@\n+2017-08-23  Daniel Santos  <daniel.santos@pobox.com>\n+\n+\t* gcc.target/i386/pr80969-1.c: New testcase.\n+\t* gcc.target/i386/pr80969-2a.c: Likewise.\n+\t* gcc.target/i386/pr80969-2.c: Likewise.\n+\t* gcc.target/i386/pr80969-3.c: Likewise.\n+\t* gcc.target/i386/pr80969-4a.c: Likewise.\n+\t* gcc.target/i386/pr80969-4b.c: Likewise.\n+\t* gcc.target/i386/pr80969-4.c: Likewise.\n+\t* gcc.target/i386/pr80969-4.h: New header common to pr80969-4*.c\n+\t* lib/target-supports.exp (check_avx512_os_support_available,\n+\tcheck_avx512f_hw_available, check_effective_target_avx512f_runtime):\n+\tNew proceedures for target avx512f and avx512f_runtime selectors.\n+\t(check_avx2_hw_available): Fix breakage due NULL being undefined.\n+\n 2017-08-23  David Malcolm  <dmalcolm@redhat.com>\n \n \t* g++.dg/diagnostic/param-type-mismatch.C: New test acse."}, {"sha": "e0520b45c407e1f1b9dfeb41608d0cfc0d8438b2", "filename": "gcc/testsuite/gcc.target/i386/pr80969-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-1.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target { ! x32 } } } */\n+/* { dg-options \"-Ofast -mabi=ms -mavx512f\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+int a[56];\n+int b;\n+int main (int argc, char *argv[]) {\n+  int c;\n+  for (; b; b++) {\n+    c = b;\n+    if (b & 1)\n+      c = 2;\n+    a[b] = c;\n+  }\n+  return 0;\n+}"}, {"sha": "f885dee65124e286df693006daefbf3049f66b78", "filename": "gcc/testsuite/gcc.target/i386/pr80969-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-2.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run { target { { ! x32 } && avx512f_runtime } } } */\n+/* { dg-do compile { target { { ! x32 } && { ! avx512f_runtime } } } } */\n+/* { dg-options \"-Ofast -mabi=ms -mavx512f\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+/* Test when calling a sysv func.  */\n+\n+int a[56];\n+int b;\n+\n+static void __attribute__((sysv_abi)) sysv ()\n+{\n+}\n+\n+void __attribute__((sysv_abi)) (*volatile const sysv_noinfo)() = sysv;\n+\n+int main (int argc, char *argv[]) {\n+  int c;\n+  sysv_noinfo ();\n+  for (; b; b++) {\n+    c = b;\n+    if (b & 1)\n+      c = 2;\n+    a[b] = c;\n+  }\n+  return 0;\n+}"}, {"sha": "baea0796d244c7eb39c02928e4a9641a5078fa8c", "filename": "gcc/testsuite/gcc.target/i386/pr80969-2a.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-2a.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do run { target { lp64 && avx512f_runtime } } } */\n+/* { dg-do compile { target { lp64 && { ! avx512f_runtime } } } } */\n+/* { dg-options \"-Ofast -mabi=ms -mavx512f -mcall-ms2sysv-xlogues\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+/* Test when calling a sysv func using save/restore stubs.  */\n+\n+#include \"pr80969-2.c\""}, {"sha": "d902a771cc8f015815ec19b87c447c021a9f46cf", "filename": "gcc/testsuite/gcc.target/i386/pr80969-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-3.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run { target { { ! x32 } && avx512f_runtime } } } */\n+/* { dg-do compile { target { { ! x32 } && { ! avx512f_runtime } } } } */\n+/* { dg-options \"-Ofast -mabi=ms -mavx512f\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+/* Test with alloca (and DRAP).  */\n+\n+#include <alloca.h>\n+\n+int a[56];\n+volatile int b = -12345;\n+volatile const int d = 42;\n+\n+void foo (int *x, int y, int z)\n+{\n+}\n+\n+void (*volatile const foo_noinfo)(int *, int, int) = foo;\n+\n+int main (int argc, char *argv[]) {\n+  int c;\n+  int *e = alloca (d);\n+  foo_noinfo (e, d, 0);\n+  for (; b; b++) {\n+    c = b;\n+    if (b & 1)\n+      c = 2;\n+    foo_noinfo (e, d, c);\n+    a[-(b % 56)] = c;\n+  }\n+  return 0;\n+}"}, {"sha": "d5026657cd467c3580679cb59f7755db34a10829", "filename": "gcc/testsuite/gcc.target/i386/pr80969-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { { ! x32 } && avx512f_runtime } } } */\n+/* { dg-do compile { target { { ! x32 } && { ! avx512f_runtime } } } } */\n+/* { dg-options \"-Ofast -mabi=ms -mavx512f\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+/* Test with avx512 and va_args.  */\n+\n+#define CALLEE_ABI ms_abi\n+#include \"pr80969-4.h\""}, {"sha": "a7ff6456242027e6771ab45fd6751ec772d229fe", "filename": "gcc/testsuite/gcc.target/i386/pr80969-4.h", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4.h?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,119 @@\n+\n+#include <stdarg.h>\n+#include <assert.h>\n+\n+#include \"avx-check.h\"\n+\n+int a[56];\n+int b;\n+\n+__m128 n1 = { -283.3, -23.3, 213.4, 1119.03 };\n+__m512d n2 = { -93.83, 893.318, 3994.3, -39484.0, 830.32, -328.32, 3.14159, 2.99792 };\n+__m128i n3 = { 893, -3180 } ;\n+int n4 = 324;\n+double n5 = 103.3;\n+__m128i n6 = { -123, 2 };\n+__m128d n7 = { -91.387, -8193.518 };\n+__m256d n8 = { -123.3, 2.3, 3.4, -10.03 };\n+__m128 n9 = { -123.3, 2.3, 3.4, -10.03 };\n+__m128i n10 = { 1233, -100 };\n+int n11 = 407;\n+double n12 = 304.9;\n+__m128i n13 = { 233, -110 };\n+__m256i n14 = { -1233, 23, 34, -1003 };\n+__m512i n15 = { -393, -180, 213.4, 1119.03, -8193.518, -100, 304.9, 2.99792 };\n+__m128d n16 = { 73.0, 63.18 };\n+__m256 n17 = { -183.3, -22.3, 13.9, -119.3, 483.1, 122.3, -33.4, -9.37 };\n+__m128 n18 = { -183.3, 22.3, 13.4, -19.03 };\n+\n+__m128 e1;\n+__m512d e2;\n+__m128i e3;\n+int e4;\n+double e5;\n+__m128i e6;\n+__m128d e7;\n+__m256d e8;\n+__m128 e9;\n+__m128i e10;\n+int e11;\n+double e12;\n+__m128i e13;\n+__m256i e14;\n+__m512i e15;\n+__m128d e16;\n+__m256 e17;\n+__m128 e18;\n+\n+static void\n+__attribute__((noinline, CALLEE_ABI))\n+bar (__m128 a1, __m512d a2, __m128i a3, va_list va_arglist)\n+{\n+  e1 = a1;\n+  e2 = a2;\n+  e3 = a3;\n+  e4 = va_arg (va_arglist, int);\n+  e5 = va_arg (va_arglist, double);\n+  e6 = va_arg (va_arglist, __m128i);\n+  e7 = va_arg (va_arglist, __m128d);\n+  e8 = va_arg (va_arglist, __m256d);\n+  e9 = va_arg (va_arglist, __m128);\n+  e10 = va_arg (va_arglist, __m128i);\n+  e11 = va_arg (va_arglist, int);\n+  e12 = va_arg (va_arglist, double);\n+  e13 = va_arg (va_arglist, __m128i);\n+  e14 = va_arg (va_arglist, __m256i);\n+  e15 = va_arg (va_arglist, __m512i);\n+  e16 = va_arg (va_arglist, __m128d);\n+  e17 = va_arg (va_arglist, __m256);\n+  e18 = va_arg (va_arglist, __m128);\n+}\n+\n+void __attribute__((CALLEE_ABI))\n+(*volatile const bar_noinfo) (__m128, __m512d, __m128i, va_list) = bar;\n+\n+static void\n+__attribute__((noinline))\n+foo (__m128 a1, __m512d a2, __m128i a3, ...)\n+{\n+  va_list va_arglist;\n+  int c;\n+\n+  va_start (va_arglist, a3);\n+  bar_noinfo (a1, a2, a3, va_arglist);\n+  va_end (va_arglist);\n+\n+  for (; b; b++) {\n+    c = b;\n+    if (b & 1)\n+      c = 2;\n+    a[b] = c;\n+  }\n+}\n+void (*volatile const foo_noinfo) (__m128, __m512d, __m128i, ...) = foo;\n+\n+static void\n+avx_test (void)\n+{\n+  foo (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12,\n+       n13, n14, n15, n16, n17, n18);\n+  assert (__builtin_memcmp (&e1, &n1, sizeof (e1)) == 0);\n+  assert (__builtin_memcmp (&e2, &n2, sizeof (e2)) == 0);\n+  assert (__builtin_memcmp (&e3, &n3, sizeof (e3)) == 0);\n+  assert (n4 == e4);\n+  assert (n5 == e5);\n+  assert (__builtin_memcmp (&e6, &n6, sizeof (e6)) == 0);\n+  assert (__builtin_memcmp (&e7, &n7, sizeof (e7)) == 0);\n+  assert (__builtin_memcmp (&e8, &n8, sizeof (e8)) == 0);\n+  assert (__builtin_memcmp (&e9, &n9, sizeof (e9)) == 0);\n+  assert (__builtin_memcmp (&e10, &n10, sizeof (e10)) == 0);\n+  assert (n11 == e11);\n+  assert (n12 == e12);\n+  assert (__builtin_memcmp (&e13, &n13, sizeof (e13)) == 0);\n+  assert (__builtin_memcmp (&e14, &n14, sizeof (e14)) == 0);\n+  assert (__builtin_memcmp (&e15, &n15, sizeof (e15)) == 0);\n+  assert (__builtin_memcmp (&e16, &n16, sizeof (e16)) == 0);\n+  assert (__builtin_memcmp (&e17, &n17, sizeof (e17)) == 0);\n+  assert (__builtin_memcmp (&e18, &n18, sizeof (e18)) == 0);\n+}\n+"}, {"sha": "e5d4cadb04597525869319376e1fac774d3f0c3c", "filename": "gcc/testsuite/gcc.target/i386/pr80969-4a.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4a.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { { ! x32 } && avx512f_runtime } } } */\n+/* { dg-do compile { target { { ! x32 } && { ! avx512f_runtime } } } } */\n+/* { dg-options \"-Ofast -mabi=ms -mavx512f\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+/* Test with avx512, va_args, and ms to sysv call.  */\n+\n+#define CALLEE_ABI sysv_abi\n+#include \"pr80969-4.h\""}, {"sha": "ae8759249eba445e01c7a0fc6a368e9e60515f2b", "filename": "gcc/testsuite/gcc.target/i386/pr80969-4b.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80969-4b.c?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { lp64 && avx512f_runtime } } } */\n+/* { dg-do compile { target { lp64 && { ! avx512f_runtime } } } } */\n+/* { dg-options \"-Ofast -mabi=ms -mavx512f -mcall-ms2sysv-xlogues\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+/* Test with avx512, va_args, and ms to sysv call using save/restore stubs.  */\n+\n+#define CALLEE_ABI sysv_abi\n+#include \"pr80969-4.h\""}, {"sha": "547fe7a2ff2335dc6e9ab3e4d0063344d20aa87c", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122f9da15d1db58bd5f96a8a49d81d529ca07a1e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=122f9da15d1db58bd5f96a8a49d81d529ca07a1e", "patch": "@@ -1642,6 +1642,29 @@ proc check_avx_os_support_available { } {\n     }]\n }\n \n+# Return 1 if the target OS supports running AVX executables, 0\n+# otherwise.  Cache the result.\n+\n+proc check_avx512_os_support_available { } {\n+    return [check_cached_effective_target avx512_os_support_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n+\t    expr 0\n+\t} else {\n+\t    # Check that OS has AVX512, AVX and SSE saving enabled.\n+\t    check_runtime_nocache avx512_os_support_available {\n+\t\tint main ()\n+\t\t{\n+\t\t  unsigned int eax, edx;\n+\n+\t\t  asm (\"xgetbv\" : \"=a\" (eax), \"=d\" (edx) : \"c\" (0));\n+\t\t  return (eax & 0xe6) != 0xe6;\n+\t\t}\n+\t    } \"\"\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports executing SSE instructions, 0\n # otherwise.  Cache the result.\n \n@@ -1822,6 +1845,7 @@ proc check_avx2_hw_available { } {\n \t    expr 0\n \t} else {\n \t    check_runtime_nocache avx2_hw_available {\n+\t\t#include <stddef.h>\n \t\t#include \"cpuid.h\"\n \t\tint main ()\n \t\t{\n@@ -1842,6 +1866,37 @@ proc check_avx2_hw_available { } {\n     }]\n }\n \n+# Return 1 if the target supports executing AVX512 foundation instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_avx512f_hw_available { } {\n+    return [check_cached_effective_target avx512f_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache avx512f_hw_available {\n+\t\t#include <stddef.h>\n+\t\t#include \"cpuid.h\"\n+\t\tint main ()\n+\t\t{\n+\t\t  unsigned int eax, ebx, ecx, edx;\n+\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx)\n+\t\t      || !(ecx & bit_OSXSAVE))\n+\t\t    return 1;\n+\n+\t\t  if (__get_cpuid_max (0, NULL) < 7)\n+\t\t    return 1;\n+\n+\t\t  __cpuid_count (7, 0, eax, ebx, ecx, edx);\n+\n+\t\t  return !(ebx & bit_AVX512F);\n+\t\t}\n+\t    } \"\"\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports running SSE executables, 0 otherwise.\n \n proc check_effective_target_sse_runtime { } {\n@@ -1928,6 +1983,17 @@ proc check_effective_target_avx2_runtime { } {\n     return 0\n }\n \n+# Return 1 if the target supports running AVX512f executables, 0 otherwise.\n+\n+proc check_effective_target_avx512f_runtime { } {\n+    if { [check_effective_target_avx512f]\n+\t && [check_avx512f_hw_available]\n+\t && [check_avx512_os_support_available] } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n # Return 1 if we are compiling for 64-bit PowerPC but we do not use direct\n # move instructions for moves from GPR to FPR.\n "}]}