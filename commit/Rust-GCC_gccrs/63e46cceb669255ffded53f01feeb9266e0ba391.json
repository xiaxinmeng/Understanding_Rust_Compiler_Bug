{"sha": "63e46cceb669255ffded53f01feeb9266e0ba391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNlNDZjY2ViNjY5MjU1ZmZkZWQ1M2YwMWZlZWI5MjY2ZTBiYTM5MQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2008-05-19T18:54:44Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2008-05-19T18:54:44Z"}, "message": "i386.c (ix86_expand_vector_init_concat): New.\n\n2008-05-19  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386.c (ix86_expand_vector_init_concat): New.\n\t(ix86_expand_vector_init_interleave): Likewise.\n\t(ix86_expand_vector_init_general): Use them.  Assert word_mode\n\t== SImode when n_words == 4.\n\nFrom-SVN: r135578", "tree": {"sha": "85dce9f9ee2d3b4041598e308cef8b0a55667c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85dce9f9ee2d3b4041598e308cef8b0a55667c9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63e46cceb669255ffded53f01feeb9266e0ba391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e46cceb669255ffded53f01feeb9266e0ba391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e46cceb669255ffded53f01feeb9266e0ba391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e46cceb669255ffded53f01feeb9266e0ba391/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16a55411b4b374fbd2274ca4f8a4d9a2127b120c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a55411b4b374fbd2274ca4f8a4d9a2127b120c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a55411b4b374fbd2274ca4f8a4d9a2127b120c"}], "stats": {"total": 419, "additions": 246, "deletions": 173}, "files": [{"sha": "a0b2cbe38a2e88b4cf9710d061e0295d0ffb57ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e46cceb669255ffded53f01feeb9266e0ba391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e46cceb669255ffded53f01feeb9266e0ba391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63e46cceb669255ffded53f01feeb9266e0ba391", "patch": "@@ -1,3 +1,10 @@\n+2008-05-19  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386.c (ix86_expand_vector_init_concat): New.\n+\t(ix86_expand_vector_init_interleave): Likewise.\n+\t(ix86_expand_vector_init_general): Use them.  Assert word_mode\n+\t== SImode when n_words == 4.\n+\n 2008-05-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_secondary_reload): New static function."}, {"sha": "a116bc6091ced013d468c2cdf1efb74d3eeb76c3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 239, "deletions": 173, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e46cceb669255ffded53f01feeb9266e0ba391/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e46cceb669255ffded53f01feeb9266e0ba391/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=63e46cceb669255ffded53f01feeb9266e0ba391", "patch": "@@ -23869,194 +23869,270 @@ ix86_expand_vector_init_one_var (bool mmx_ok, enum machine_mode mode,\n   return true;\n }\n \n-/* A subroutine of ix86_expand_vector_init.  Handle the most general case:\n-   all values variable, and none identical.  */\n+/* A subroutine of ix86_expand_vector_init_general.  Use vector\n+   concatenate to handle the most general case: all values variable,\n+   and none identical.  */\n \n static void\n-ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n-\t\t\t\t rtx target, rtx vals)\n+ix86_expand_vector_init_concat (enum machine_mode mode,\n+\t\t\t\trtx target, rtx *ops, int n)\n {\n-  enum machine_mode half_mode = GET_MODE_INNER (mode);\n-  rtx op0 = NULL, op1 = NULL;\n-  bool use_vec_concat = false;\n+  enum machine_mode cmode, hmode = VOIDmode;\n+  rtx first[8], second[4];\n+  rtvec v;\n+  int i, j;\n \n-  switch (mode)\n+  switch (n)\n     {\n-    case V2SFmode:\n-    case V2SImode:\n-      if (!mmx_ok && !TARGET_SSE)\n-\tbreak;\n-      /* FALLTHRU */\n+    case 2:\n+      switch (mode)\n+\t{\n+\tcase V4SImode:\n+\t  cmode = V2SImode;\n+\t  break;\n+\tcase V4SFmode:\n+\t  cmode = V2SFmode;\n+\t  break;\n+\tcase V2DImode:\n+\t  cmode = DImode;\n+\t  break;\n+\tcase V2SImode:\n+\t  cmode = SImode;\n+\t  break;\n+\tcase V2DFmode:\n+\t  cmode = DFmode;\n+\t  break;\n+\tcase V2SFmode:\n+\t  cmode = SFmode;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n-    case V2DFmode:\n-    case V2DImode:\n-      /* For the two element vectors, we always implement VEC_CONCAT.  */\n-      op0 = XVECEXP (vals, 0, 0);\n-      op1 = XVECEXP (vals, 0, 1);\n-      use_vec_concat = true;\n+      if (!register_operand (ops[1], cmode))\n+\tops[1] = force_reg (cmode, ops[1]);\n+      if (!register_operand (ops[0], cmode))\n+\tops[0] = force_reg (cmode, ops[0]);\n+      emit_insn (gen_rtx_SET (VOIDmode, target,\n+\t\t\t      gen_rtx_VEC_CONCAT (mode, ops[0],\n+\t\t\t\t\t\t  ops[1])));\n       break;\n \n-    case V4SFmode:\n-      half_mode = V2SFmode;\n-      goto half;\n-    case V4SImode:\n-      half_mode = V2SImode;\n+    case 4:\n+      switch (mode)\n+\t{\n+\tcase V4SImode:\n+\t  cmode = V2SImode;\n+\t  break;\n+\tcase V4SFmode:\n+\t  cmode = V2SFmode;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       goto half;\n-    half:\n-      {\n-\trtvec v;\n \n-\t/* For V4SF and V4SI, we implement a concat of two V2 vectors.\n-\t   Recurse to load the two halves.  */\n+half:\n+      /* FIXME: We process inputs backward to help RA.  PR 36222.  */\n+      i = n - 1;\n+      j = (n >> 1) - 1;\n+      for (; i > 0; i -= 2, j--)\n+\t{\n+\t  first[j] = gen_reg_rtx (cmode);\n+\t  v = gen_rtvec (2, ops[i - 1], ops[i]);\n+\t  ix86_expand_vector_init (false, first[j],\n+\t\t\t\t   gen_rtx_PARALLEL (cmode, v));\n+\t}\n \n-\top1 = gen_reg_rtx (half_mode);\n-\tv = gen_rtvec (2, XVECEXP (vals, 0, 2), XVECEXP (vals, 0, 3));\n-\tix86_expand_vector_init (false, op1, gen_rtx_PARALLEL (half_mode, v));\n+      n >>= 1;\n+      if (n > 2)\n+\t{\n+\t  gcc_assert (hmode != VOIDmode);\n+\t  for (i = j = 0; i < n; i += 2, j++)\n+\t    {\n+\t      second[j] = gen_reg_rtx (hmode);\n+\t      ix86_expand_vector_init_concat (hmode, second [j],\n+\t\t\t\t\t      &first [i], 2);\n+\t    }\n+\t  n >>= 1;\n+\t  ix86_expand_vector_init_concat (mode, target, second, n);\n+\t}\n+      else\n+\tix86_expand_vector_init_concat (mode, target, first, n);\n+      break;\n \n-\top0 = gen_reg_rtx (half_mode);\n-\tv = gen_rtvec (2, XVECEXP (vals, 0, 0), XVECEXP (vals, 0, 1));\n-\tix86_expand_vector_init (false, op0, gen_rtx_PARALLEL (half_mode, v));\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n-\tuse_vec_concat = true;\n-      }\n-      break;\n+/* A subroutine of ix86_expand_vector_init_general.  Use vector\n+   interleave to handle the most general case: all values variable,\n+   and none identical.  */\n \n+static void\n+ix86_expand_vector_init_interleave (enum machine_mode mode,\n+\t\t\t\t    rtx target, rtx *ops, int n)\n+{\n+  enum machine_mode first_imode, second_imode, third_imode;\n+  int i, j;\n+  rtx op0, op1;\n+  rtx (*gen_load_even) (rtx, rtx, rtx);\n+  rtx (*gen_interleave_first_low) (rtx, rtx, rtx);\n+  rtx (*gen_interleave_second_low) (rtx, rtx, rtx);\n+  \n+  switch (mode)\n+    {\n     case V8HImode:\n-      if (TARGET_SSE2)\n-\t{\n-\t  rtx ops[4];\n-\t  unsigned int i, j;\n+      gen_load_even = gen_vec_setv8hi;\n+      gen_interleave_first_low = gen_vec_interleave_lowv4si;\n+      gen_interleave_second_low = gen_vec_interleave_lowv2di;\n+      first_imode = V4SImode;\n+      second_imode = V2DImode;\n+      third_imode = VOIDmode;\n+      break;\n+    case V16QImode:\n+      gen_load_even = gen_vec_setv16qi;\n+      gen_interleave_first_low = gen_vec_interleave_lowv8hi;\n+      gen_interleave_second_low = gen_vec_interleave_lowv4si;\n+      first_imode = V8HImode;\n+      second_imode = V4SImode;\n+      third_imode = V2DImode;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+     \n+  for (i = 0; i < n; i++)\n+    {\n+      /* Extend the odd elment to SImode using a paradoxical SUBREG.  */\n+      op0 = gen_reg_rtx (SImode);\n+      emit_move_insn (op0, gen_lowpart (SImode, ops [i + i]));\n \n-\t  for (i = 0; i < ARRAY_SIZE (ops); i++)\n-\t    {\n-\t      /* Extend the odd elment from HImode to SImode using\n-\t\t a paradoxical SUBREG.  */\n-\t      op0 = gen_reg_rtx (SImode);\n-\t      emit_move_insn (op0, gen_lowpart (SImode,\n-\t\t\t\t\t\tXVECEXP (vals, 0,\n-\t\t\t\t\t\t\t i + i)));\n-\n-\t      /* Insert the SImode value as low element of V4SImode\n-\t\t vector. */\n-\t      op1 = gen_reg_rtx (V4SImode);\n-\t      op0 = gen_rtx_VEC_MERGE (V4SImode,\n-\t\t\t\t       gen_rtx_VEC_DUPLICATE (V4SImode,\n-\t\t\t\t\t\t\t      op0),\n-\t\t\t\t       CONST0_RTX (V4SImode),\n-\t\t\t\t       const1_rtx);\n-\t      emit_insn (gen_rtx_SET (VOIDmode, op1, op0));\n-\n-\t      /* Cast the V4SImode vector back to a V8HImode vector.  */\n-\t      op0 = gen_reg_rtx (mode);\n-\t      emit_move_insn (op0, gen_lowpart (mode, op1));\n-\n-\t      /* Load even HI elements into the second positon.  */\n-\t      emit_insn (gen_vec_setv8hi (op0, XVECEXP (vals, 0,\n-\t\t\t\t\t\t\ti + i + 1),\n-\t\t\t\t\t  const1_rtx));\n-\n-\t      /* Cast V8HImode vector to V4SImode vector.  */\n-\t      ops[i] = gen_reg_rtx (V4SImode);\n-\t      emit_move_insn (ops[i], gen_lowpart (V4SImode, op0));\n-\t    }\n+      /* Insert the SImode value as low element of V4SImode vector. */\n+      op1 = gen_reg_rtx (V4SImode);\n+      op0 = gen_rtx_VEC_MERGE (V4SImode,\n+\t\t\t       gen_rtx_VEC_DUPLICATE (V4SImode,\n+\t\t\t\t\t\t      op0),\n+\t\t\t       CONST0_RTX (V4SImode),\n+\t\t\t       const1_rtx);\n+      emit_insn (gen_rtx_SET (VOIDmode, op1, op0));\n \n-\t  /* Interleave low V4SIs.  */\n-\t  for (i = j = 0; i < ARRAY_SIZE (ops); i += 2, j++)\n-\t    {\n-\t      op0 = gen_reg_rtx (V4SImode);\n-\t      emit_insn (gen_vec_interleave_lowv4si (op0, ops[i],\n-\t\t\t\t\t\t     ops[i + 1]));\n-\n-\t      /* Cast V4SImode vectors to V2DImode vectors.  */\n-\t      op1 = gen_reg_rtx (V2DImode);\n-\t      emit_move_insn (op1, gen_lowpart (V2DImode, op0));\n-\t      ops[j] = op1;\n-\t    }\n+      /* Cast the V4SImode vector back to a vector in orignal mode.  */\n+      op0 = gen_reg_rtx (mode);\n+      emit_move_insn (op0, gen_lowpart (mode, op1));\n+      \n+      /* Load even elements into the second positon.  */\n+      emit_insn ((*gen_load_even) (op0, ops [i + i + 1],\n+\t\t\t\t   const1_rtx));\n \n-\t  /* Interleave low V2DIs.  */\n-\t  op0 = gen_reg_rtx (V2DImode);\n-\t  emit_insn (gen_vec_interleave_lowv2di (op0, ops[0], ops[1]));\n+      /* Cast vector to FIRST_IMODE vector.  */\n+      ops[i] = gen_reg_rtx (first_imode);\n+      emit_move_insn (ops[i], gen_lowpart (first_imode, op0));\n+    }\n \n-\t  /* Cast the V2DImode vector back to a V8HImode vector.  */\n-\t  emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t  gen_lowpart (mode, op0)));\n-\t  return;\n-\t}\n+  /* Interleave low FIRST_IMODE vectors.  */\n+  for (i = j = 0; i < n; i += 2, j++)\n+    {\n+      op0 = gen_reg_rtx (first_imode);\n+      emit_insn ((*gen_interleave_first_low) (op0, ops[i], ops[i + 1]));\n \n-    case V16QImode:\n-      if (TARGET_SSE4_1)\n+      /* Cast FIRST_IMODE vector to SECOND_IMODE vector.  */\n+      ops[j] = gen_reg_rtx (second_imode);\n+      emit_move_insn (ops[j], gen_lowpart (second_imode, op0));\n+    }\n+\n+  /* Interleave low SECOND_IMODE vectors.  */\n+  switch (second_imode)\n+    {\n+    case V4SImode:\n+      for (i = j = 0; i < n / 2; i += 2, j++)\n \t{\n-\t  rtx ops[8];\n-\t  unsigned int i, j;\n+\t  op0 = gen_reg_rtx (second_imode);\n+\t  emit_insn ((*gen_interleave_second_low) (op0, ops[i],\n+\t\t\t\t\t\t   ops[i + 1]));\n \n-\t  for (i = 0; i < ARRAY_SIZE (ops); i++)\n-\t    {\n-\t      /* Extend the odd elment from QImode to SImode using\n-\t\t a paradoxical SUBREG.  */\n-\t      op0 = gen_reg_rtx (SImode);\n-\t      emit_move_insn (op0, gen_lowpart (SImode,\n-\t\t\t\t\t\tXVECEXP (vals, 0,\n-\t\t\t\t\t\t\t i + i)));\n-\n-\t      /* Insert the SImode value as low element of V4SImode\n-\t\t vector. */\n-\t      op1 = gen_reg_rtx (V4SImode);\n-\t      op0 = gen_rtx_VEC_MERGE (V4SImode,\n-\t\t\t\t       gen_rtx_VEC_DUPLICATE (V4SImode,\n-\t\t\t\t\t\t\t      op0),\n-\t\t\t\t       CONST0_RTX (V4SImode),\n-\t\t\t\t       const1_rtx);\n-\t      emit_insn (gen_rtx_SET (VOIDmode, op1, op0));\n-\n-\t      /* Cast the V4SImode vector back to a V16QImode vector.  */\n-\t      op0 = gen_reg_rtx (mode);\n-\t      emit_move_insn (op0, gen_lowpart (mode, op1));\n-\n-\t      /* Load even QI elements into the second positon.  */\n-\t      emit_insn (gen_vec_setv16qi (op0, XVECEXP (vals, 0,\n-\t\t\t\t\t\t\t i + i + 1),\n-\t\t\t\t\t   const1_rtx));\n-\n-\t      /* Cast V16QImode vector to V8HImode vector.  */\n-\t      ops[i] = gen_reg_rtx (V8HImode);\n-\t      emit_move_insn (ops[i], gen_lowpart (V8HImode, op0));\n-\t    }\n+\t  /* Cast the SECOND_IMODE vector to the THIRD_IMODE\n+\t     vector.  */\n+\t  ops[j] = gen_reg_rtx (third_imode);\n+\t  emit_move_insn (ops[j], gen_lowpart (third_imode, op0));\n+\t}\n+      second_imode = V2DImode;\n+      gen_interleave_second_low = gen_vec_interleave_lowv2di;\n+      /* FALLTHRU */\n \n-\t  /* Interleave low V8HIs.  */\n-\t  for (i = j = 0; i < ARRAY_SIZE (ops); i += 2, j++)\n-\t    {\n-\t      op0 = gen_reg_rtx (V8HImode);\n-\t      emit_insn (gen_vec_interleave_lowv8hi (op0, ops[i],\n-\t\t\t\t\t\t     ops[i + 1]));\n-\n-\t      /* Cast V8HImode vector to V4SImode vector.  */\n-\t      op1 = gen_reg_rtx (V4SImode);\n-\t      emit_move_insn (op1, gen_lowpart (V4SImode, op0));\n-\t      ops[j] = op1;\n-\t    }\n+    case V2DImode:\n+      op0 = gen_reg_rtx (second_imode);\n+      emit_insn ((*gen_interleave_second_low) (op0, ops[0],\n+\t\t\t\t\t       ops[1]));\n \n-\t  /* Interleave low V4SIs.  */\n-\t  for (i = j = 0; i < ARRAY_SIZE (ops) / 2; i += 2, j++)\n-\t    {\n-\t      op0 = gen_reg_rtx (V4SImode);\n-\t      emit_insn (gen_vec_interleave_lowv4si (op0, ops[i],\n-\t\t\t\t\t\t     ops[i + 1]));\n-\n-\t      /* Cast V4SImode vectors to V2DImode vectors.  */\n-\t      op1 = gen_reg_rtx (V2DImode);\n-\t      emit_move_insn (op1, gen_lowpart (V2DImode, op0));\n-\t      ops[j] = op1;\n-\t    }\n+      /* Cast the SECOND_IMODE vector back to a vector on original\n+\t mode.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, target,\n+\t\t\t      gen_lowpart (mode, op0)));\n+      break;\n \n-\t  /* Interleave low V2DIs.  */\n-\t  op0 = gen_reg_rtx (V2DImode);\n-\t  emit_insn (gen_vec_interleave_lowv2di (op0, ops[0], ops[1]));\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n-\t  /* Cast the V2DImode vector back to a V8HImode vector.  */\n-\t  emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t  gen_lowpart (mode, op0)));\n-\t  return;\n-\t}\n+/* A subroutine of ix86_expand_vector_init.  Handle the most general case:\n+   all values variable, and none identical.  */\n+\n+static void\n+ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n+\t\t\t\t rtx target, rtx vals)\n+{\n+  rtx ops[32], op0, op1;\n+  enum machine_mode half_mode = VOIDmode;\n+  int n, i;\n+\n+  switch (mode)\n+    {\n+    case V2SFmode:\n+    case V2SImode:\n+      if (!mmx_ok && !TARGET_SSE)\n+\tbreak;\n+\n+      n = 2;\n+      goto vec_concat;\n+\n+    case V4SFmode:\n+    case V4SImode:\n+      n = 4;\n+      goto vec_concat;\n+\n+    case V2DFmode:\n+    case V2DImode:\n+      n = 2;\n+      goto vec_concat;\n+\n+vec_concat:\n+      for (i = 0; i < n; i++)\n+\tops[i] = XVECEXP (vals, 0, i);\n+      ix86_expand_vector_init_concat (mode, target, ops, n);\n+      return;\n+\n+    case V16QImode:\n+      if (!TARGET_SSE4_1)\n+\tbreak;\n+\n+      n = 16;\n+      goto vec_interleave;\n+\n+    case V8HImode:\n+      if (!TARGET_SSE2)\n+\tbreak;\n+\n+      n = 8;\n+      goto vec_interleave;\n+\n+vec_interleave:\n+      for (i = 0; i < n; i++)\n+\tops[i] = XVECEXP (vals, 0, i);\n+      ix86_expand_vector_init_interleave (mode, target, ops, n >> 1);\n+      return;\n \n     case V4HImode:\n     case V8QImode:\n@@ -24066,17 +24142,6 @@ ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n       gcc_unreachable ();\n     }\n \n-  if (use_vec_concat)\n-    {\n-      if (!register_operand (op1, half_mode))\n-\top1 = force_reg (half_mode, op1);\n-      if (!register_operand (op0, half_mode))\n-\top0 = force_reg (half_mode, op0);\n-\n-      emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t      gen_rtx_VEC_CONCAT (mode, op0, op1)));\n-    }\n-  else\n     {\n       int i, j, n_elts, n_words, n_elt_per_word;\n       enum machine_mode inner_mode;\n@@ -24124,6 +24189,7 @@ ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n       else if (n_words == 4)\n \t{\n \t  rtx tmp = gen_reg_rtx (V4SImode);\n+\t  gcc_assert (word_mode == SImode);\n \t  vals = gen_rtx_PARALLEL (V4SImode, gen_rtvec_v (4, words));\n \t  ix86_expand_vector_init_general (false, V4SImode, tmp, vals);\n \t  emit_move_insn (target, gen_lowpart (mode, tmp));"}]}