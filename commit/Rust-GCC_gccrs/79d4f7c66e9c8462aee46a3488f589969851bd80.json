{"sha": "79d4f7c66e9c8462aee46a3488f589969851bd80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlkNGY3YzY2ZTljODQ2MmFlZTQ2YTM0ODhmNTg5OTY5ODUxYmQ4MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-16T08:28:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-16T08:28:51Z"}, "message": "fold-const.c (fold_widened_comparison): Remove.\n\n2015-07-16  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (fold_widened_comparison): Remove.\n\t(fold_sign_changed_comparison): Likewise.\n\t(fold_comparison): Move widened and sign-changed comparison\n\tsimplification ...\n\t* match.pd: ... to patterns here.\n\t* generic-match-head.c: Include target.h.\n\t* gimple-match-head.c: Likewise.\n\n\t* gcc.dg/tree-ssa/pr21031.c: Adjust.\n\nFrom-SVN: r225861", "tree": {"sha": "808b6ca01568ad4ba625da0b59f16015a8fded59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/808b6ca01568ad4ba625da0b59f16015a8fded59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79d4f7c66e9c8462aee46a3488f589969851bd80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d4f7c66e9c8462aee46a3488f589969851bd80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79d4f7c66e9c8462aee46a3488f589969851bd80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d4f7c66e9c8462aee46a3488f589969851bd80/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "612b9d1364bbefb708245c6cd5b5bfa2718926e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/612b9d1364bbefb708245c6cd5b5bfa2718926e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/612b9d1364bbefb708245c6cd5b5bfa2718926e6"}], "stats": {"total": 234, "additions": 74, "deletions": 160}, "files": [{"sha": "0287697ecb4f44cfcf1b6ec29016e6b943768c6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79d4f7c66e9c8462aee46a3488f589969851bd80", "patch": "@@ -1,3 +1,13 @@\n+2015-07-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (fold_widened_comparison): Remove.\n+\t(fold_sign_changed_comparison): Likewise.\n+\t(fold_comparison): Move widened and sign-changed comparison\n+\tsimplification ...\n+\t* match.pd: ... to patterns here.\n+\t* generic-match-head.c: Include target.h.\n+\t* gimple-match-head.c: Likewise.\n+\n 2015-07-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-dom.c (dom_valueize): New function."}, {"sha": "93dd29d6729b2d445ea12ca87dd62980913d55a9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=79d4f7c66e9c8462aee46a3488f589969851bd80", "patch": "@@ -6685,148 +6685,6 @@ tree_swap_operands_p (const_tree arg0, const_tree arg1, bool reorder)\n   return 0;\n }\n \n-/* Fold comparison ARG0 CODE ARG1 (with result in TYPE), where\n-   ARG0 is extended to a wider type.  */\n-\n-static tree\n-fold_widened_comparison (location_t loc, enum tree_code code,\n-\t\t\t tree type, tree arg0, tree arg1)\n-{\n-  tree arg0_unw = get_unwidened (arg0, NULL_TREE);\n-  tree arg1_unw;\n-  tree shorter_type, outer_type;\n-  tree min, max;\n-  bool above, below;\n-\n-  if (arg0_unw == arg0)\n-    return NULL_TREE;\n-  shorter_type = TREE_TYPE (arg0_unw);\n-\n-  /* Disable this optimization if we're casting a function pointer\n-     type on targets that require function pointer canonicalization.  */\n-  if (targetm.have_canonicalize_funcptr_for_compare ()\n-      && TREE_CODE (shorter_type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (shorter_type)) == FUNCTION_TYPE)\n-    return NULL_TREE;\n-\n-  if (TYPE_PRECISION (TREE_TYPE (arg0)) <= TYPE_PRECISION (shorter_type))\n-    return NULL_TREE;\n-\n-  arg1_unw = get_unwidened (arg1, NULL_TREE);\n-\n-  /* If possible, express the comparison in the shorter mode.  */\n-  if ((code == EQ_EXPR || code == NE_EXPR\n-       || TYPE_UNSIGNED (TREE_TYPE (arg0)) == TYPE_UNSIGNED (shorter_type))\n-      && (TREE_TYPE (arg1_unw) == shorter_type\n-\t  || ((TYPE_PRECISION (shorter_type)\n-\t       >= TYPE_PRECISION (TREE_TYPE (arg1_unw)))\n-\t      && (TYPE_UNSIGNED (shorter_type)\n-\t\t  == TYPE_UNSIGNED (TREE_TYPE (arg1_unw))))\n-\t  || (TREE_CODE (arg1_unw) == INTEGER_CST\n-\t      && (TREE_CODE (shorter_type) == INTEGER_TYPE\n-\t\t  || TREE_CODE (shorter_type) == BOOLEAN_TYPE)\n-\t      && int_fits_type_p (arg1_unw, shorter_type))))\n-    return fold_build2_loc (loc, code, type, arg0_unw,\n-\t\t\tfold_convert_loc (loc, shorter_type, arg1_unw));\n-\n-  if (TREE_CODE (arg1_unw) != INTEGER_CST\n-      || TREE_CODE (shorter_type) != INTEGER_TYPE\n-      || int_fits_type_p (arg1_unw, shorter_type))\n-    return NULL_TREE;\n-\n-  /* If we are comparing with the integer that does not fit into the range\n-     of the shorter type, the result is known.  */\n-  outer_type = TREE_TYPE (arg1_unw);\n-  min = lower_bound_in_type (outer_type, shorter_type);\n-  max = upper_bound_in_type (outer_type, shorter_type);\n-\n-  above = integer_nonzerop (fold_relational_const (LT_EXPR, type,\n-\t\t\t\t\t\t   max, arg1_unw));\n-  below = integer_nonzerop (fold_relational_const (LT_EXPR, type,\n-\t\t\t\t\t\t   arg1_unw, min));\n-\n-  switch (code)\n-    {\n-    case EQ_EXPR:\n-      if (above || below)\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n-      break;\n-\n-    case NE_EXPR:\n-      if (above || below)\n-\treturn omit_one_operand_loc (loc, type, integer_one_node, arg0);\n-      break;\n-\n-    case LT_EXPR:\n-    case LE_EXPR:\n-      if (above)\n-\treturn omit_one_operand_loc (loc, type, integer_one_node, arg0);\n-      else if (below)\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n-\n-    case GT_EXPR:\n-    case GE_EXPR:\n-      if (above)\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n-      else if (below)\n-\treturn omit_one_operand_loc (loc, type, integer_one_node, arg0);\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Fold comparison ARG0 CODE ARG1 (with result in TYPE), where for\n-   ARG0 just the signedness is changed.  */\n-\n-static tree\n-fold_sign_changed_comparison (location_t loc, enum tree_code code, tree type,\n-\t\t\t      tree arg0, tree arg1)\n-{\n-  tree arg0_inner;\n-  tree inner_type, outer_type;\n-\n-  if (!CONVERT_EXPR_P (arg0))\n-    return NULL_TREE;\n-\n-  outer_type = TREE_TYPE (arg0);\n-  arg0_inner = TREE_OPERAND (arg0, 0);\n-  inner_type = TREE_TYPE (arg0_inner);\n-\n-  /* Disable this optimization if we're casting a function pointer\n-     type on targets that require function pointer canonicalization.  */\n-  if (targetm.have_canonicalize_funcptr_for_compare ()\n-      && TREE_CODE (inner_type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (inner_type)) == FUNCTION_TYPE)\n-    return NULL_TREE;\n-\n-  if (TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (arg1) != INTEGER_CST\n-      && !(CONVERT_EXPR_P (arg1)\n-\t   && TREE_TYPE (TREE_OPERAND (arg1, 0)) == inner_type))\n-    return NULL_TREE;\n-\n-  if (TYPE_UNSIGNED (inner_type) != TYPE_UNSIGNED (outer_type)\n-      && code != NE_EXPR\n-      && code != EQ_EXPR)\n-    return NULL_TREE;\n-\n-  if (POINTER_TYPE_P (inner_type) != POINTER_TYPE_P (outer_type))\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (arg1) == INTEGER_CST)\n-    arg1 = force_fit_type (inner_type, wi::to_widest (arg1), 0,\n-\t\t\t   TREE_OVERFLOW (arg1));\n-  else\n-    arg1 = fold_convert_loc (loc, inner_type, arg1);\n-\n-  return fold_build2_loc (loc, code, type, arg0_inner, arg1);\n-}\n-\n \n /* Fold A < X && A + 1 > Y to A < X && A >= Y.  Normally A + 1 > Y\n    means A >= Y && A != MAX, but in this case we know that\n@@ -8813,22 +8671,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n   if (tem)\n     return tem;\n \n-  if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n-      && CONVERT_EXPR_P (arg0))\n-    {\n-      /* If we are widening one operand of an integer comparison,\n-\t see if the other operand is similarly being widened.  Perhaps we\n-\t can do the comparison in the narrower type.  */\n-      tem = fold_widened_comparison (loc, code, type, arg0, arg1);\n-      if (tem)\n-\treturn tem;\n-\n-      /* Or if we are changing signedness.  */\n-      tem = fold_sign_changed_comparison (loc, code, type, arg0, arg1);\n-      if (tem)\n-\treturn tem;\n-    }\n-\n   /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n      constant, we can simplify it.  */\n   if (TREE_CODE (arg1) == INTEGER_CST"}, {"sha": "da7abc669647df562e3a3cbf59942223aa36db2e", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=79d4f7c66e9c8462aee46a3488f589969851bd80", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"builtins.h\"\n #include \"dumpfile.h\"\n+#include \"target.h\"\n #include \"generic-match.h\"\n \n /* Routine to determine if the types T1 and T2 are effectively"}, {"sha": "2b1423806bca237910a1f75912182f372e5b346d", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=79d4f7c66e9c8462aee46a3488f589969851bd80", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"builtins.h\"\n #include \"dumpfile.h\"\n+#include \"target.h\"\n #include \"gimple-match.h\"\n \n "}, {"sha": "c335ada567ed82b164aa390cfdf0ddd2b075d0b2", "filename": "gcc/match.pd", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=79d4f7c66e9c8462aee46a3488f589969851bd80", "patch": "@@ -1664,6 +1664,62 @@ along with GCC; see the file COPYING3.  If not see\n     (if (tem && !TREE_OVERFLOW (tem))\n      (scmp @0 { tem; }))))))\n \n+/* From fold_sign_changed_comparison and fold_widened_comparison.  */\n+(for cmp (simple_comparison)\n+ (simplify\n+  (cmp (convert@0 @00) (convert?@1 @10))\n+  (if (TREE_CODE (TREE_TYPE (@0)) == INTEGER_TYPE\n+       /* Disable this optimization if we're casting a function pointer\n+\t  type on targets that require function pointer canonicalization.  */\n+       && !(targetm.have_canonicalize_funcptr_for_compare ()\n+\t    && TREE_CODE (TREE_TYPE (@00)) == POINTER_TYPE\n+\t    && TREE_CODE (TREE_TYPE (TREE_TYPE (@00))) == FUNCTION_TYPE))\n+   (if (TYPE_PRECISION (TREE_TYPE (@00)) == TYPE_PRECISION (TREE_TYPE (@0))\n+\t&& (TREE_CODE (@10) == INTEGER_CST\n+\t    || (@1 != @10 && types_match (TREE_TYPE (@10), TREE_TYPE (@00))))\n+\t&& (TYPE_UNSIGNED (TREE_TYPE (@00)) == TYPE_UNSIGNED (TREE_TYPE (@0))\n+\t    || cmp == NE_EXPR\n+\t    || cmp == EQ_EXPR)\n+\t&& (POINTER_TYPE_P (TREE_TYPE (@00)) == POINTER_TYPE_P (TREE_TYPE (@0))))\n+    /* ???  The special-casing of INTEGER_CST conversion was in the original\n+       code and here to avoid a spurious overflow flag on the resulting\n+       constant which fold_convert produces.  */\n+    (if (TREE_CODE (@1) == INTEGER_CST)\n+     (cmp @00 { force_fit_type (TREE_TYPE (@00), wi::to_widest (@1), 0,\n+\t\t\t\tTREE_OVERFLOW (@1)); })\n+     (cmp @00 (convert @1)))\n+\n+    (if (TYPE_PRECISION (TREE_TYPE (@0)) > TYPE_PRECISION (TREE_TYPE (@00)))\n+     /* If possible, express the comparison in the shorter mode.  */\n+     (if ((cmp == EQ_EXPR || cmp == NE_EXPR\n+\t   || TYPE_UNSIGNED (TREE_TYPE (@0)) == TYPE_UNSIGNED (TREE_TYPE (@00)))\n+\t  && (types_match (TREE_TYPE (@10), TREE_TYPE (@00))\n+\t      || ((TYPE_PRECISION (TREE_TYPE (@00))\n+\t\t   >= TYPE_PRECISION (TREE_TYPE (@10)))\n+\t\t  && (TYPE_UNSIGNED (TREE_TYPE (@00))\n+\t\t      == TYPE_UNSIGNED (TREE_TYPE (@10))))\n+\t      || (TREE_CODE (@10) == INTEGER_CST\n+\t\t  && (TREE_CODE (TREE_TYPE (@00)) == INTEGER_TYPE\n+\t\t      || TREE_CODE (TREE_TYPE (@00)) == BOOLEAN_TYPE)\n+\t\t  && int_fits_type_p (@10, TREE_TYPE (@00)))))\n+      (cmp @00 (convert @10))\n+      (if (TREE_CODE (@10) == INTEGER_CST\n+\t   && TREE_CODE (TREE_TYPE (@00)) == INTEGER_TYPE\n+\t   && !int_fits_type_p (@10, TREE_TYPE (@00)))\n+       (with\n+\t{\n+\t  tree min = lower_bound_in_type (TREE_TYPE (@10), TREE_TYPE (@00));\n+\t  tree max = upper_bound_in_type (TREE_TYPE (@10), TREE_TYPE (@00));\n+\t  bool above = integer_nonzerop (const_binop (LT_EXPR, type, max, @10));\n+\t  bool below = integer_nonzerop (const_binop (LT_EXPR, type, @10, min));\n+\t}\n+\t(if (above || below)\n+\t (if (cmp == EQ_EXPR || cmp == NE_EXPR)\n+\t  { constant_boolean_node (cmp == EQ_EXPR ? false : true, type); }\n+\t  (if (cmp == LT_EXPR || cmp == LE_EXPR)\n+\t   { constant_boolean_node (above ? true : false, type); }\n+\t   (if (cmp == GT_EXPR || cmp == GE_EXPR)\n+\t    { constant_boolean_node (above ? false : true, type); }))))))))))))\n \n /* Equality compare simplifications from fold_binary  */\n (for cmp (eq ne)"}, {"sha": "8bc934129987b18a0076fdb0b8615b852484d33a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79d4f7c66e9c8462aee46a3488f589969851bd80", "patch": "@@ -1,3 +1,7 @@\n+2015-07-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/pr21031.c: Adjust.\n+\n 2015-07-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/66866"}, {"sha": "a6f5b6e88481335cb48f6d11143434301dfaf311", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21031.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21031.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d4f7c66e9c8462aee46a3488f589969851bd80/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21031.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21031.c?ref=79d4f7c66e9c8462aee46a3488f589969851bd80", "patch": "@@ -3,7 +3,7 @@\n    Make sure that a != 0 is propagated into the \"if\" statement.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-forwprop1-details\" } */\n+/* { dg-options \"-O1 -fdump-tree-forwprop1\" } */\n \n int\n foo (int a)\n@@ -16,4 +16,4 @@ foo (int a)\n     return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Replaced\" 2 \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"if \\\\(a_\\[0-9\\]+\\\\(D\\\\) != 0\\\\)\" \"forwprop1\" } } */"}]}