{"sha": "44c8402d35160515b3c09fd2bc239587e0c32a2b", "node_id": "C_kwDOANBUbNoAKDQ0Yzg0MDJkMzUxNjA1MTViM2MwOWZkMmJjMjM5NTg3ZTBjMzJhMmI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-12-02T13:52:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-12-05T09:22:53Z"}, "message": "tree-optimization/107833 - invariant motion of uninit uses\n\nThe following fixes a wrong-code bug caused by loop invariant motion\nhoisting an expression using an uninitialized value outside of its\ncontrolling condition causing IVOPTs to use that to rewrite a defined\nvalue.  PR107839 is a similar case involving a bogus uninit diagnostic.\n\n\tPR tree-optimization/107833\n\tPR tree-optimization/107839\n\t* cfghooks.cc: Include tree.h.\n\t* tree-ssa-loop-im.cc (movement_possibility): Wrap and\n\tmake stmts using any ssa_name_maybe_undef_p operand\n\tto preserve execution.\n\t(loop_invariant_motion_in_fun): Call mark_ssa_maybe_undefs\n\tto init maybe-undefined status.\n\t* tree-ssa-loop-ivopts.cc (ssa_name_maybe_undef_p,\n\tssa_name_set_maybe_undef, ssa_name_any_use_dominates_bb_p,\n\tmark_ssa_maybe_undefs): Move ...\n\t* tree-ssa.cc: ... here.\n\t* tree-ssa.h (ssa_name_any_use_dominates_bb_p,\n\tmark_ssa_maybe_undefs): Declare.\n\t(ssa_name_maybe_undef_p, ssa_name_set_maybe_undef): Define.\n\n\t* gcc.dg/torture/pr107833.c: New testcase.\n\t* gcc.dg/uninit-pr107839.c: Likewise.", "tree": {"sha": "f592f253098750358187f2ee53bce15c1b97b175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f592f253098750358187f2ee53bce15c1b97b175"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44c8402d35160515b3c09fd2bc239587e0c32a2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c8402d35160515b3c09fd2bc239587e0c32a2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c8402d35160515b3c09fd2bc239587e0c32a2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c8402d35160515b3c09fd2bc239587e0c32a2b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "824542bec24c09319fa55922a0162209a5f64963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824542bec24c09319fa55922a0162209a5f64963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/824542bec24c09319fa55922a0162209a5f64963"}], "stats": {"total": 300, "additions": 187, "deletions": 113}, "files": [{"sha": "f8fa13c1d69fe37554572383242b5a9469522adb", "filename": "gcc/cfghooks.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Fcfghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Fcfghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.cc?ref=44c8402d35160515b3c09fd2bc239587e0c32a2b", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"dumpfile.h\"\n #include \"cfganal.h\"\n+#include \"tree.h\"\n #include \"tree-ssa.h\"\n #include \"cfgloop.h\"\n #include \"sreal.h\""}, {"sha": "0edf7c328ba17ae2d98b282243c60c1308d73a9e", "filename": "gcc/testsuite/gcc.dg/torture/pr107833.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107833.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107833.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107833.c?ref=44c8402d35160515b3c09fd2bc239587e0c32a2b", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+\n+int a, b[1] = { 0 }, c, *d = b, e, *f, g;\n+\n+__attribute__((noipa)) int\n+foo (const char *x)\n+{\n+  (void) x;\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  for (int h = 0; a < 2; a++)\n+    {\n+      int i;\n+      for (g = 0; g < 2; g++)\n+\tif (a < h)\n+\t  {\n+\t    e = i % 2;\n+\t    c = *f;\n+\t  }\n+      for (h = 0; h < 3; h++)\n+\t{\n+\t  if (d)\n+\t    break;\n+\t  i--;\n+\t  foo (\"0\");\n+\t}\n+    }\n+  return 0;\n+}"}, {"sha": "c2edcfaee22f104c3ff160723bbb769318823a11", "filename": "gcc/testsuite/gcc.dg/uninit-pr107839.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr107839.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr107839.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr107839.c?ref=44c8402d35160515b3c09fd2bc239587e0c32a2b", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wuninitialized\" } */\n+\n+int f (int);\n+void g (int c)\n+{\n+  int v;\n+  if (c)\n+    v = f(0);\n+  while (1)\n+    if (c)\n+      f(v + v); /* { dg-bogus \"uninitialized\" } */ \n+}"}, {"sha": "20a9ca7e8227df45cabaf4a2a501d8b2386b7f04", "filename": "gcc/tree-ssa-loop-im.cc", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa-loop-im.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa-loop-im.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.cc?ref=44c8402d35160515b3c09fd2bc239587e0c32a2b", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alias.h\"\n #include \"builtins.h\"\n #include \"tree-dfa.h\"\n+#include \"tree-ssa.h\"\n #include \"dbgcnt.h\"\n \n /* TODO:  Support for predicated code motion.  I.e.\n@@ -331,8 +332,8 @@ enum move_pos\n    because it may trap), return MOVE_PRESERVE_EXECUTION.\n    Otherwise return MOVE_IMPOSSIBLE.  */\n \n-enum move_pos\n-movement_possibility (gimple *stmt)\n+static enum move_pos\n+movement_possibility_1 (gimple *stmt)\n {\n   tree lhs;\n   enum move_pos ret = MOVE_POSSIBLE;\n@@ -422,6 +423,23 @@ movement_possibility (gimple *stmt)\n   return ret;\n }\n \n+static enum move_pos\n+movement_possibility (gimple *stmt)\n+{\n+  enum move_pos pos = movement_possibility_1 (stmt);\n+  if (pos == MOVE_POSSIBLE)\n+    {\n+      use_operand_p use_p;\n+      ssa_op_iter ssa_iter;\n+      FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, ssa_iter, SSA_OP_USE)\n+\tif (TREE_CODE (USE_FROM_PTR (use_p)) == SSA_NAME\n+\t    && ssa_name_maybe_undef_p (USE_FROM_PTR (use_p)))\n+\t  return MOVE_PRESERVE_EXECUTION;\n+    }\n+  return pos;\n+}\n+\n+\n /* Compare the profile count inequality of bb and loop's preheader, it is\n    three-state as stated in profile-count.h, FALSE is returned if inequality\n    cannot be decided.  */\n@@ -3532,6 +3550,8 @@ loop_invariant_motion_in_fun (function *fun, bool store_motion)\n \n   tree_ssa_lim_initialize (store_motion);\n \n+  mark_ssa_maybe_undefs ();\n+\n   /* Gathers information about memory accesses in the loops.  */\n   analyze_memory_references (store_motion);\n "}, {"sha": "5b9044fc3f3fdee956ba994f2e72e6f60a4f7eb9", "filename": "gcc/tree-ssa-loop-ivopts.cc", "status": "modified", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa-loop-ivopts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa-loop-ivopts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.cc?ref=44c8402d35160515b3c09fd2bc239587e0c32a2b", "patch": "@@ -3071,117 +3071,6 @@ get_loop_invariant_expr (struct ivopts_data *data, tree inv_expr)\n   return *slot;\n }\n \n-/* Return TRUE iff VAR is marked as maybe-undefined.  See\n-   mark_ssa_maybe_undefs.  */\n-\n-static inline bool\n-ssa_name_maybe_undef_p (tree var)\n-{\n-  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n-  return TREE_VISITED (var);\n-}\n-\n-/* Set (or clear, depending on VALUE) VAR's maybe-undefined mark.  */\n-\n-static inline void\n-ssa_name_set_maybe_undef (tree var, bool value = true)\n-{\n-  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n-  TREE_VISITED (var) = value;\n-}\n-\n-/* Return TRUE iff there are any non-PHI uses of VAR that dominate the\n-   end of BB.  If we return TRUE and BB is a loop header, then VAR we\n-   be assumed to be defined within the loop, even if it is marked as\n-   maybe-undefined.  */\n-\n-static inline bool\n-ssa_name_any_use_dominates_bb_p (tree var, basic_block bb)\n-{\n-  imm_use_iterator iter;\n-  use_operand_p use_p;\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n-    {\n-      if (is_a <gphi *> (USE_STMT (use_p))\n-\t  || is_gimple_debug (USE_STMT (use_p)))\n-\tcontinue;\n-      basic_block dombb = gimple_bb (USE_STMT (use_p));\n-      if (dominated_by_p (CDI_DOMINATORS, bb, dombb))\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Mark as maybe_undef any SSA_NAMEs that are unsuitable as ivopts\n-   candidates for potentially involving undefined behavior.  */\n-\n-static void\n-mark_ssa_maybe_undefs (void)\n-{\n-  auto_vec<tree> queue;\n-\n-  /* Scan all SSA_NAMEs, marking the definitely-undefined ones as\n-     maybe-undefined and queuing them for propagation, while clearing\n-     the mark on others.  */\n-  unsigned int i;\n-  tree var;\n-  FOR_EACH_SSA_NAME (i, var, cfun)\n-    {\n-      if (SSA_NAME_IS_VIRTUAL_OPERAND (var)\n-\t  || !ssa_undefined_value_p (var, false))\n-\tssa_name_set_maybe_undef (var, false);\n-      else\n-\t{\n-\t  ssa_name_set_maybe_undef (var);\n-\t  queue.safe_push (var);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"marking _%i as maybe-undef\\n\",\n-\t\t     SSA_NAME_VERSION (var));\n-\t}\n-    }\n-\n-  /* Now propagate maybe-undefined from a DEF to any other PHI that\n-     uses it, as long as there isn't any intervening use of DEF.  */\n-  while (!queue.is_empty ())\n-    {\n-      var = queue.pop ();\n-      imm_use_iterator iter;\n-      use_operand_p use_p;\n-      FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n-\t{\n-\t  /* Any uses of VAR that aren't PHI args imply VAR must be\n-\t     defined, otherwise undefined behavior would have been\n-\t     definitely invoked.  Only PHI args may hold\n-\t     maybe-undefined values without invoking undefined\n-\t     behavior for that reason alone.  */\n-\t  if (!is_a <gphi *> (USE_STMT (use_p)))\n-\t    continue;\n-\t  gphi *phi = as_a <gphi *> (USE_STMT (use_p));\n-\n-\t  tree def = gimple_phi_result (phi);\n-\t  if (ssa_name_maybe_undef_p (def))\n-\t    continue;\n-\n-\t  /* Look for any uses of the maybe-unused SSA_NAME that\n-\t     dominates the block that reaches the incoming block\n-\t     corresponding to the PHI arg in which it is mentioned.\n-\t     That means we can assume the SSA_NAME is defined in that\n-\t     path, so we only mark a PHI result as maybe-undef if we\n-\t     find an unused reaching SSA_NAME.  */\n-\t  int idx = phi_arg_index_from_use (use_p);\n-\t  basic_block bb = gimple_phi_arg_edge (phi, idx)->src;\n-\t  if (ssa_name_any_use_dominates_bb_p (var, bb))\n-\t    continue;\n-\n-\t  ssa_name_set_maybe_undef (def);\n-\t  queue.safe_push (def);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"marking _%i as maybe-undef because of _%i\\n\",\n-\t\t     SSA_NAME_VERSION (def), SSA_NAME_VERSION (var));\n-\t}\n-    }\n-}\n \n /* Return *TP if it is an SSA_NAME marked with TREE_VISITED, i.e., as\n    unsuitable as ivopts candidates for potentially involving undefined"}, {"sha": "5dedc0947e20babbbea00f0cc46c9803b47c0822", "filename": "gcc/tree-ssa.cc", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.cc?ref=44c8402d35160515b3c09fd2bc239587e0c32a2b", "patch": "@@ -1400,6 +1400,99 @@ gimple_uses_undefined_value_p (gimple *stmt)\n }\n \n \n+/* Return TRUE iff there are any non-PHI uses of VAR that dominate the\n+   end of BB.  If we return TRUE and BB is a loop header, then VAR we\n+   be assumed to be defined within the loop, even if it is marked as\n+   maybe-undefined.  */\n+\n+bool\n+ssa_name_any_use_dominates_bb_p (tree var, basic_block bb)\n+{\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+    {\n+      if (is_a <gphi *> (USE_STMT (use_p))\n+\t  || is_gimple_debug (USE_STMT (use_p)))\n+\tcontinue;\n+      basic_block dombb = gimple_bb (USE_STMT (use_p));\n+      if (dominated_by_p (CDI_DOMINATORS, bb, dombb))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Mark as maybe_undef any SSA_NAMEs that are unsuitable as ivopts\n+   candidates for potentially involving undefined behavior.  */\n+\n+void\n+mark_ssa_maybe_undefs (void)\n+{\n+  auto_vec<tree> queue;\n+\n+  /* Scan all SSA_NAMEs, marking the definitely-undefined ones as\n+     maybe-undefined and queuing them for propagation, while clearing\n+     the mark on others.  */\n+  unsigned int i;\n+  tree var;\n+  FOR_EACH_SSA_NAME (i, var, cfun)\n+    {\n+      if (SSA_NAME_IS_VIRTUAL_OPERAND (var)\n+\t  || !ssa_undefined_value_p (var, false))\n+\tssa_name_set_maybe_undef (var, false);\n+      else\n+\t{\n+\t  ssa_name_set_maybe_undef (var);\n+\t  queue.safe_push (var);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"marking _%i as maybe-undef\\n\",\n+\t\t     SSA_NAME_VERSION (var));\n+\t}\n+    }\n+\n+  /* Now propagate maybe-undefined from a DEF to any other PHI that\n+     uses it, as long as there isn't any intervening use of DEF.  */\n+  while (!queue.is_empty ())\n+    {\n+      var = queue.pop ();\n+      imm_use_iterator iter;\n+      use_operand_p use_p;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+\t{\n+\t  /* Any uses of VAR that aren't PHI args imply VAR must be\n+\t     defined, otherwise undefined behavior would have been\n+\t     definitely invoked.  Only PHI args may hold\n+\t     maybe-undefined values without invoking undefined\n+\t     behavior for that reason alone.  */\n+\t  if (!is_a <gphi *> (USE_STMT (use_p)))\n+\t    continue;\n+\t  gphi *phi = as_a <gphi *> (USE_STMT (use_p));\n+\n+\t  tree def = gimple_phi_result (phi);\n+\t  if (ssa_name_maybe_undef_p (def))\n+\t    continue;\n+\n+\t  /* Look for any uses of the maybe-unused SSA_NAME that\n+\t     dominates the block that reaches the incoming block\n+\t     corresponding to the PHI arg in which it is mentioned.\n+\t     That means we can assume the SSA_NAME is defined in that\n+\t     path, so we only mark a PHI result as maybe-undef if we\n+\t     find an unused reaching SSA_NAME.  */\n+\t  int idx = phi_arg_index_from_use (use_p);\n+\t  basic_block bb = gimple_phi_arg_edge (phi, idx)->src;\n+\t  if (ssa_name_any_use_dominates_bb_p (var, bb))\n+\t    continue;\n+\n+\t  ssa_name_set_maybe_undef (def);\n+\t  queue.safe_push (def);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"marking _%i as maybe-undef because of _%i\\n\",\n+\t\t     SSA_NAME_VERSION (def), SSA_NAME_VERSION (var));\n+\t}\n+    }\n+}\n+\n \n /* If necessary, rewrite the base of the reference tree *TP from\n    a MEM_REF to a plain or converted symbol.  */"}, {"sha": "19c1eedc9f96ab77a7aef9b8cdf6db7145300fb2", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c8402d35160515b3c09fd2bc239587e0c32a2b/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=44c8402d35160515b3c09fd2bc239587e0c32a2b", "patch": "@@ -55,6 +55,31 @@ extern tree find_released_ssa_name (tree *, int *, void *);\n extern bool ssa_defined_default_def_p (tree t);\n extern bool ssa_undefined_value_p (tree, bool = true);\n extern bool gimple_uses_undefined_value_p (gimple *);\n+\n+\n+bool ssa_name_any_use_dominates_bb_p (tree var, basic_block bb);\n+extern void mark_ssa_maybe_undefs (void);\n+\n+/* Return TRUE iff VAR is marked as maybe-undefined.  See\n+   mark_ssa_maybe_undefs.  */\n+\n+static inline bool\n+ssa_name_maybe_undef_p (tree var)\n+{\n+  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n+  return TREE_VISITED (var);\n+}\n+\n+/* Set (or clear, depending on VALUE) VAR's maybe-undefined mark.  */\n+\n+static inline void\n+ssa_name_set_maybe_undef (tree var, bool value = true)\n+{\n+  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n+  TREE_VISITED (var) = value;\n+}\n+\n+\n extern void execute_update_addresses_taken (void);\n \n /* Given an edge_var_map V, return the PHI arg definition.  */"}]}