{"sha": "014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0YTExMzhkNmZmNzllZmY5YWVhNzA0ZDVlOGFlM2Y1OGZlZjVkMQ==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2004-02-06T20:03:45Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2004-02-06T20:03:45Z"}, "message": "Josef Zlomek <zlomekj@suse.cz>\n\n\tJosef Zlomek  <zlomekj@suse.cz>\n\t* Makefile.in (var-tracking.o): New.\n\t* common.opt (fvar-tracking): New.\n\t* flags.h (flag_var_tracking): New.\n\t* gengtype.c (adjust_field_rtx_def): NOTE_INSN_VAR_LOCATION was added.\n\t* opts.c (common_handle_option): Add OPT_fvar_tracking.\n\t* print-rtl.c (print_rtx): NOTE_INSN_VAR_LOCATION was added.\n        * rtl.c (note_insn_name): Likewise.\n        * rtl.def (VAR_LOCATION): New.\n        * rtl.h (NOTE_VAR_LOCATION): New.\n        (NOTE_VAR_LOCATION_DECL): New.\n        (NOTE_VAR_LOCATION_LOC): New.\n        (enum insn_note): NOTE_INSN_VAR_LOCATION was added.\n        (variable_tracking_main): New exported function.\n        * timevar.def (TV_VAR_TRACKING): New.\n        * toplev.c (enum dump_file_index): Added DFI_vartrack.\n        (dump_file): \"vartrack\" was added (-dV).\n        (flag_var_tracking): New.\n        (f_options): \"var-tracking\" was added.\n\t(rest_of_handle_variable_tracking): New function.\n        (rest_of_compilation): Run variable tracking.\n\t(process_options): If user has not specified flag_var_tracking set it\n\taccording to optimize, debug_info_level and debug_hooks.\n\t* tree.h (frame_base_decl): New.\n        * var-tracking.c: New file.\n\t* config/ia64/ia64.c (ia64_flag_var_tracking): New variable.\n\t(ia64_override_options): Set flags to run variable tracking in machine\n\tdependent reorg instead of toplev.c.\n\t(ia64_reorg): Run variable tracking if wanted.\n        * doc/invoke.texi: Mention variable tracking in -dV,\n\tadd and -fvar-tracking.\n        * doc/passes.texi: Added variable tracking pass.\n\n\tDaniel Berlin <dberlin@dberlin.org>\n\t* debug.h (struct gcc_debug_hooks): Added var_location debug hook.\n\t* dbxout.c (dbx_debug_hooks): Likewise.\n\t(xcoff_debug): Likewise.\n\t* debug.c (do_nothing_debug_hooks): Likewise.\n\t* dwarf2out.c (dwarf2_debug_hooks): Likewise.\n\t* dwarfout.c (dwarf_debug_hooks): Likewise.\n\t* sdbout.c (sdb_debug_hooks): Likewise.\n\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n\t* final.c (final_scan_insn): Call var_location debug hook for each\n\tNOTE_INSN_VAR_LOCATION.\n\nCo-Authored-By: Daniel Berlin <dberlin@dberlin.org>\n\nFrom-SVN: r77418", "tree": {"sha": "f57616e19dba86e71b7eabf273b9af5e97701906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f57616e19dba86e71b7eabf273b9af5e97701906"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/comments", "author": null, "committer": null, "parents": [{"sha": "298c28a8f4e43c22d3ad390699192f2dfa8fca70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298c28a8f4e43c22d3ad390699192f2dfa8fca70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/298c28a8f4e43c22d3ad390699192f2dfa8fca70"}], "stats": {"total": 2830, "additions": 2820, "deletions": 10}, "files": [{"sha": "35aab6c99f59837f82ba8f8f6b4ba3b4b0856f0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -1,3 +1,51 @@\n+2004-02-06  Josef Zlomek  <zlomekj@suse.cz>\n+            Daniel Berlin <dberlin@dberlin.org>\n+\n+\tJosef Zlomek  <zlomekj@suse.cz>\n+\t* Makefile.in (var-tracking.o): New.\n+\t* common.opt (fvar-tracking): New.\n+\t* flags.h (flag_var_tracking): New.\n+\t* gengtype.c (adjust_field_rtx_def): NOTE_INSN_VAR_LOCATION was added.\n+\t* opts.c (common_handle_option): Add OPT_fvar_tracking.\n+\t* print-rtl.c (print_rtx): NOTE_INSN_VAR_LOCATION was added.\n+        * rtl.c (note_insn_name): Likewise.\n+        * rtl.def (VAR_LOCATION): New.\n+        * rtl.h (NOTE_VAR_LOCATION): New.\n+        (NOTE_VAR_LOCATION_DECL): New.\n+        (NOTE_VAR_LOCATION_LOC): New.\n+        (enum insn_note): NOTE_INSN_VAR_LOCATION was added.\n+        (variable_tracking_main): New exported function.\n+        * timevar.def (TV_VAR_TRACKING): New.\n+        * toplev.c (enum dump_file_index): Added DFI_vartrack.\n+        (dump_file): \"vartrack\" was added (-dV).\n+        (flag_var_tracking): New.\n+        (f_options): \"var-tracking\" was added.\n+\t(rest_of_handle_variable_tracking): New function.\n+        (rest_of_compilation): Run variable tracking.\n+\t(process_options): If user has not specified flag_var_tracking set it\n+\taccording to optimize, debug_info_level and debug_hooks.\n+\t* tree.h (frame_base_decl): New.\n+        * var-tracking.c: New file.\n+\t* config/ia64/ia64.c (ia64_flag_var_tracking): New variable.\n+\t(ia64_override_options): Set flags to run variable tracking in machine\n+\tdependent reorg instead of toplev.c.\n+\t(ia64_reorg): Run variable tracking if wanted.\n+        * doc/invoke.texi: Mention variable tracking in -dV,\n+\tadd and -fvar-tracking.\n+        * doc/passes.texi: Added variable tracking pass.\n+\n+\tDaniel Berlin <dberlin@dberlin.org>\n+\t* debug.h (struct gcc_debug_hooks): Added var_location debug hook.\n+\t* dbxout.c (dbx_debug_hooks): Likewise.\n+\t(xcoff_debug): Likewise.\n+\t* debug.c (do_nothing_debug_hooks): Likewise.\n+\t* dwarf2out.c (dwarf2_debug_hooks): Likewise.\n+\t* dwarfout.c (dwarf_debug_hooks): Likewise.\n+\t* sdbout.c (sdb_debug_hooks): Likewise.\n+\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n+\t* final.c (final_scan_insn): Call var_location debug hook for each \n+\tNOTE_INSN_VAR_LOCATION. \n+\n 2004-02-06  Jan Hubicka  <jh@suse.cz>\n \n \t* flow.c (update_life_info): Allocate reg_deaths when called from"}, {"sha": "1b4edcf4766620c46233cb0575da3da467d99357", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -852,7 +852,7 @@ OBJS-common = \\\n  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t   \\\n  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  \t   \\\n  loop.o optabs.o options.o opts.o params.o postreload.o predict.o\t   \\\n- print-rtl.o print-tree.o value-prof.o\t\t\t\t\t   \\\n+ print-rtl.o print-tree.o value-prof.o var-tracking.o\t\t\t   \\\n  profile.o ra.o ra-build.o ra-colorize.o ra-debug.o ra-rewrite.o\t   \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n@@ -1669,6 +1669,9 @@ lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) df.h $(FIBHEAP_H)\n+var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h flags.h \\\n+   $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H)\n conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "4c08b9705877d35ca51c1b145fa5e0812d11ce3c", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -715,6 +715,10 @@ funwind-tables\n Common\n Just generate unwind tables for exception handling\n \n+fvar-tracking\n+Common\n+Perform variable tracking\n+\n fverbose-asm\n Common\n Add extra commentary to assembler output"}, {"sha": "4764a1a316b98b5407e0fb66a4a3d8d5d1be595a", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -117,6 +117,10 @@ const char *ia64_tune_string;\n    avoid the normal second scheduling pass.  */\n static int ia64_flag_schedule_insns2;\n \n+/* Determines whether we run variable tracking in machine dependent\n+   reorganization.  */\n+static int ia64_flag_var_tracking;\n+\n /* Variables which are this size or smaller are put in the sdata/sbss\n    sections.  */\n \n@@ -4785,6 +4789,11 @@ ia64_override_options (void)\n   ia64_flag_schedule_insns2 = flag_schedule_insns_after_reload;\n   flag_schedule_insns_after_reload = 0;\n \n+  /* Variable tracking should be run after all optimizations which change order\n+     of insns.  It also needs a valid CFG.  */\n+  ia64_flag_var_tracking = flag_var_tracking;\n+  flag_var_tracking = 0;\n+\n   ia64_section_threshold = g_switch_set ? g_switch_value : IA64_DEFAULT_GVALUE;\n \n   init_machine_status = ia64_init_machine_status;\n@@ -7630,6 +7639,13 @@ ia64_reorg (void)\n \n   fixup_errata ();\n   emit_predicate_relation_info ();\n+\n+  if (ia64_flag_var_tracking)\n+    {\n+      timevar_push (TV_VAR_TRACKING);\n+      variable_tracking_main ();\n+      timevar_pop (TV_VAR_TRACKING);\n+    }\n }\n \f\n /* Return true if REGNO is used by the epilogue.  */"}, {"sha": "e020d03f47a6887fd757544528a67a1071f08b99", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -400,7 +400,8 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx,\t\t         /* label */\n-  dbxout_handle_pch\t\t         /* handle_pch */\n+  dbxout_handle_pch,\t\t         /* handle_pch */\n+  debug_nothing_rtx\t\t         /* var_location */\n };\n #endif /* DBX_DEBUGGING_INFO  */\n \n@@ -428,7 +429,8 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx,\t\t         /* label */\n-  dbxout_handle_pch\t\t         /* handle_pch */\n+  dbxout_handle_pch,\t\t         /* handle_pch */\n+  debug_nothing_rtx\t\t         /* var_location */\n };\n #endif /* XCOFF_DEBUGGING_INFO  */\n \f"}, {"sha": "18d5bc8cae23c5ca315684cd53c8ac4bf416d0ab", "filename": "gcc/debug.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -45,7 +45,8 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx,\t\t         /* label */\n-  debug_nothing_int\t\t         /* handle_pch */\n+  debug_nothing_int,\t\t         /* handle_pch */\n+  debug_nothing_rtx\t\t         /* var_location */\n };\n \n /* This file contains implementations of each debug hook that do"}, {"sha": "448b028ea798014c828f3a438d979083417c41e3", "filename": "gcc/debug.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -108,6 +108,9 @@ struct gcc_debug_hooks\n   /* Called after the start and before the end of writing a PCH file.\n      The parameter is 0 if after the start, 1 if before the end.  */\n   void (* handle_pch) (unsigned int);\n+\n+  /* Called from final_scan_insn for any NOTE_INSN_VAR_LOCATION note.  */\n+  void (* var_location) (rtx);\n };\n \n extern const struct gcc_debug_hooks *debug_hooks;"}, {"sha": "2a8d919833eb7931ff14b40add8af9e2997ea5ba", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -251,7 +251,7 @@ in the following sections.\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n--ftest-coverage  -ftime-report @gol\n+-ftest-coverage  -ftime-report -fvar-tracking @gol\n -g  -g@var{level}  -gcoff -gdwarf-2 @gol\n -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol\n -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol\n@@ -3313,6 +3313,7 @@ Dump callgraph and unit-at-a-time optimization @file{@var{file}.00.unit}.\n @item V\n @opindex dV\n Dump after the value profile transformations, to @file{@var{file}.13.vpt}.\n+Also dump after variable tracking, to @file{@var{file}.35.vartrack}.\n @item w\n @opindex dw\n Dump after the second flow pass, to @file{@var{file}.27.flow2}.\n@@ -3467,6 +3468,16 @@ executing the program itself.  The second number is ``system time,''\n time spent executing operating system routines on behalf of the program.\n Both numbers are in seconds.\n \n+@item -fvar-tracking\n+@opindex fvar-tracking\n+Run variable tracking pass. It computes where variables are stored at each\n+position in code. Better debugging information is then generated\n+(if the debugging information format supports this information).\n+\n+It is enabled by default when compiling with optimization (@option{-Os},\n+@option{-O}, @option{-O2}, ...), debugging information (@option{-g}) and\n+the debug info format supports it.\n+\n @item -print-file-name=@var{library}\n @opindex print-file-name\n Print the full absolute name of the library file @var{library} that"}, {"sha": "a71c7c6c4442be216d45b0976a4b1f685b35fc0f", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -507,6 +507,19 @@ The option @option{-dB} causes a debugging dump of the RTL code after\n this pass.  This dump file's name is made by appending @samp{.bbro} to\n the input file name.\n \n+@cindex variable tracking\n+@item\n+Variable tracking.  This pass computes where the variables are stored at each\n+position in code and generates notes describing the variable locations\n+to RTL code.  The location lists are then generated according to these\n+notes to debug information if the debugging information format supports\n+location lists.\n+\n+@opindex dV\n+The option @option{-dV} causes a debugging dump of the RTL code after\n+this pass.  This dump file's name is made by appending @samp{.vartrack}\n+to the input file name.\n+\n @cindex delayed branch scheduling\n @cindex scheduling, delayed branch\n @item"}, {"sha": "e407a0b4d0cbaa231f66362389c10ad4d02d60be", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -3280,7 +3280,8 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n      something tries to reference them.  */\n   dwarf2out_abstract_function,\t/* outlining_inline_function */\n   debug_nothing_rtx,\t\t/* label */\n-  debug_nothing_int\t\t/* handle_pch */\n+  debug_nothing_int,\t\t/* handle_pch */\n+  debug_nothing_rtx\t\t/* var_location */\n };\n #endif\n \f"}, {"sha": "b12d8b63f0ba6c3cc67c5937ea324465dca10289", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -1782,6 +1782,10 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  ASM_OUTPUT_DEBUG_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n \t  break;\n \n+\tcase NOTE_INSN_VAR_LOCATION:\n+\t  (*debug_hooks->var_location) (insn);\n+\t  break;\n+\n \tcase 0:\n \t  break;\n "}, {"sha": "1ca9d98365d874ca4874e1230e05b283745ef157", "filename": "gcc/flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -723,6 +723,9 @@ extern int flag_web;\n    used.  */\n extern int flag_remove_unreachable_functions;\n \n+/* Nonzero if we should track variables.  */\n+extern int flag_var_tracking;\n+\n /* A string that's used when a random name is required.  NULL means\n    to make it really random.  */\n "}, {"sha": "86286c7cb22dfd650ad4ce9af1e970a41f1e16c9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -450,6 +450,7 @@ adjust_field_rtx_def (type_p t, options_p opt ATTRIBUTE_UNUSED)\n \t    break;\n \n \t  case NOTE_INSN_EXPECTED_VALUE:\n+\t  case NOTE_INSN_VAR_LOCATION:\n \t    note_flds->name = \"rtx\";\n \t    note_flds->type = rtx_tp;\n \t    break;"}, {"sha": "d54d1b44552fac6dc538bb211c8057b052354a3a", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -1436,6 +1436,10 @@ common_handle_option (size_t scode, const char *arg,\n       flag_unwind_tables = value;\n       break;\n \n+    case OPT_fvar_tracking:\n+      flag_var_tracking = value;\n+      break;\n+\n     case OPT_fverbose_asm:\n       flag_verbose_asm = value;\n       break;"}, {"sha": "cafdb475c58913938824b8e778342559e84b1674", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -291,6 +291,14 @@ print_rtx (rtx in_rtx)\n \t\t  fprintf (outfile, \" [ ERROR ]\");\n \t\tbreak;\n \n+\t      case NOTE_INSN_VAR_LOCATION:\n+\t\tfprintf (outfile, \" (\");\n+\t\tprint_mem_expr (outfile, NOTE_VAR_LOCATION_DECL (in_rtx));\n+\t\tfprintf (outfile, \" \");\n+\t\tprint_rtx (NOTE_VAR_LOCATION_LOC (in_rtx));\n+\t\tfprintf (outfile, \")\");\n+\t\tbreak;\n+\n \t      default:\n \t\t{\n \t\t  const char * const str = X0STR (in_rtx, i);"}, {"sha": "d0081587198d67e13d710df22fc0d86adfd1847b", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -122,7 +122,7 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n   \"NOTE_INSN_REPEATED_LINE_NUMBER\",\n   \"NOTE_INSN_BASIC_BLOCK\", \"NOTE_INSN_EXPECTED_VALUE\",\n-  \"NOTE_INSN_PREDICTION\"\n+  \"NOTE_INSN_PREDICTION\", \"NOTE_INSN_VAR_LOCATION\"\n };\n \n const char * const reg_note_name[] ="}, {"sha": "9dd4af53e4ee5ccbf67fa81222a7ac83d649a9ac", "filename": "gcc/rtl.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -1215,6 +1215,8 @@ DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", '1')\n /* Unsigned saturating truncate.  */\n DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", '1')\n \n+/* Information about the variable and its location.  */\n+DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"te\", 'x')\n \n /*\n Local variables:"}, {"sha": "05ad03d2f277134f7a43cf34d2618820b9fb7961", "filename": "gcc/rtl.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -819,6 +819,7 @@ extern const char * const reg_note_name[];\n #define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 4, NOTE)\n #define NOTE_PREDICTION(INSN)   XCINT (INSN, 4, NOTE)\n #define NOTE_PRECONDITIONED(INSN)   XCINT (INSN, 4, NOTE)\n+#define NOTE_VAR_LOCATION(INSN)\tXCEXP (INSN, 4, NOTE)\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n@@ -834,6 +835,12 @@ extern const char * const reg_note_name[];\n #define NOTE_PREDICTION_FLAGS(INSN) (XCINT(INSN, 4, NOTE)&0xff)\n #define NOTE_PREDICT(ALG,FLAGS)     ((ALG<<8)+(FLAGS))\n \n+/* Variable declaration and the location of a variable.  */\n+#define NOTE_VAR_LOCATION_DECL(INSN)\t(XCTREE (XCEXP (INSN, 4, NOTE), \\\n+\t\t\t\t\t\t 0, VAR_LOCATION))\n+#define NOTE_VAR_LOCATION_LOC(INSN)\t(XCEXP (XCEXP (INSN, 4, NOTE),  \\\n+\t\t\t\t\t\t1, VAR_LOCATION))\n+  \n /* Codes that appear in the NOTE_LINE_NUMBER field\n    for kinds of notes that are not line numbers.\n \n@@ -917,6 +924,9 @@ enum insn_note\n   /* Record a prediction.  Uses NOTE_PREDICTION.  */\n   NOTE_INSN_PREDICTION,\n \n+  /* The location of a variable.  */\n+  NOTE_INSN_VAR_LOCATION,\n+\n   NOTE_INSN_MAX\n };\n \n@@ -2343,4 +2353,7 @@ extern bool expensive_function_p (int);\n /* In tracer.c */\n extern void tracer (void);\n \n+/* In var-tracking.c */\n+extern void variable_tracking_main (void);\n+\n #endif /* ! GCC_RTL_H */"}, {"sha": "648b4c9ccde0e87d1da1aead0e8ebdad279b01a8", "filename": "gcc/sdbout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -335,7 +335,8 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   sdbout_label,\t\t\t         /* label */\n-  debug_nothing_int\t\t         /* handle_pch */\n+  debug_nothing_int,\t\t         /* handle_pch */\n+  debug_nothing_rtx\t\t         /* var_location */\n };\n \n /* Return a unique string to name an anonymous type.  */"}, {"sha": "cd776fb5f4a09bd70f274b6cb12fdf95e94943e0", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -95,6 +95,7 @@ DEFTIMEVAR (TV_SHORTEN_BRANCH        , \"shorten branches\")\n DEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\n DEFTIMEVAR (TV_FINAL                 , \"final\")\n DEFTIMEVAR (TV_SYMOUT                , \"symout\")\n+DEFTIMEVAR (TV_VAR_TRACKING          , \"variable tracking\")\n \n /* Everything else in rest_of_compilation not included above.  */\n DEFTIMEVAR (TV_REST_OF_COMPILATION   , \"rest of compilation\")"}, {"sha": "8330c89bc444b503731bafe31a9b0bd2a66ba238", "filename": "gcc/toplev.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -158,6 +158,7 @@ static void rest_of_handle_reorder_blocks (tree, rtx);\n #ifdef STACK_REGS\n static void rest_of_handle_stack_regs (tree, rtx);\n #endif\n+static void rest_of_handle_variable_tracking (tree, rtx);\n static void rest_of_handle_machine_reorg (tree, rtx);\n #ifdef DELAY_SLOTS\n static void rest_of_handle_delay_slots (tree, rtx);\n@@ -289,6 +290,7 @@ enum dump_file_index\n   DFI_branch_target_load,\n   DFI_sched2,\n   DFI_stack,\n+  DFI_vartrack,\n   DFI_mach,\n   DFI_dbr,\n   DFI_MAX\n@@ -340,6 +342,7 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"btl\",\t'd', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"stack\",\t'k', 1, 0, 0 },\n+  { \"vartrack\",\t'V', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n   { \"mach\",\t'M', 1, 0, 0 },\n   { \"dbr\",\t'd', 0, 0, 0 },\n };\n@@ -965,6 +968,13 @@ int flag_tracer = 0;\n \n int flag_unit_at_a_time = 0;\n \n+/* Nonzero if we should track variables.  When\n+   flag_var_tracking == AUTODETECT_FLAG_VAR_TRACKING it will be set according\n+   to optimize, debug_info_level and debug_hooks in process_options ().  */\n+ \n+#define AUTODETECT_FLAG_VAR_TRACKING 2\n+int flag_var_tracking = AUTODETECT_FLAG_VAR_TRACKING;\n+\n /* Values of the -falign-* flags: how much to align labels in code.\n    0 means `use default', 1 means `don't align'.\n    For each variable, there is an _log variant which is the power\n@@ -1145,7 +1155,8 @@ static const lang_independent_options f_options[] =\n   {\"mem-report\", &mem_report, 1 },\n   { \"trapv\", &flag_trapv, 1 },\n   { \"wrapv\", &flag_wrapv, 1 },\n-  { \"new-ra\", &flag_new_regalloc, 1 }\n+  { \"new-ra\", &flag_new_regalloc, 1 },\n+  { \"var-tracking\", &flag_var_tracking, 1}\n };\n \n /* Here is a table, controlled by the tm.h file, listing each -m switch\n@@ -2148,6 +2159,18 @@ rest_of_handle_stack_regs (tree decl, rtx insns)\n }\n #endif\n \n+/* Track the variables, ie. compute where the variable is stored at each position in function.  */\n+static void\n+rest_of_handle_variable_tracking (tree decl, rtx insns)\n+{\n+  timevar_push (TV_VAR_TRACKING);\n+  open_dump_file (DFI_vartrack, decl);\n+\n+  variable_tracking_main ();\n+\n+  close_dump_file (DFI_vartrack, print_rtl_with_bb, insns);\n+  timevar_pop (TV_VAR_TRACKING);\n+}\n \n /* Machine independent reorg pass.  */\n static void\n@@ -3562,6 +3585,9 @@ rest_of_compilation (tree decl)\n \n   compute_alignments ();\n \n+  if (flag_var_tracking)\n+    rest_of_handle_variable_tracking (decl, insns);\n+\n   /* CFG is no longer maintained up-to-date.  */\n   free_bb_for_insn ();\n \n@@ -4414,6 +4440,16 @@ process_options (void)\n     error (\"target system does not support the \\\"%s\\\" debug format\",\n \t   debug_type_names[write_symbols]);\n \n+  /* Now we know which debug output will be used so we can set\n+     flag_var_tracking if user has not specified it.  */\n+  if (flag_var_tracking == AUTODETECT_FLAG_VAR_TRACKING)\n+    {\n+      /* User has not specified -f(no-)var-tracking so autodetect it.  */\n+      flag_var_tracking\n+\t= (optimize >= 1 && debug_info_level >= DINFO_LEVEL_NORMAL\n+\t   && debug_hooks->var_location != do_nothing_debug_hooks.var_location);\n+    }\n+\n   /* If auxiliary info generation is desired, open the output file.\n      This goes in the same directory as the source file--unlike\n      all the other output files.  */"}, {"sha": "f6d3baf5c81a08a525a280757ecbb886ae3935b0", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -2060,6 +2060,7 @@ enum ptrmemfunc_vbit_where_t\n \f\n #define NULL_TREE (tree) NULL\n \n+extern tree frame_base_decl;\n extern tree decl_assembler_name (tree);\n \n /* Compute the number of bytes occupied by 'node'.  This routine only"}, {"sha": "7a1653d3ca436ff1ad3812079fad9763d50d3b22", "filename": "gcc/var-tracking.c", "status": "added", "additions": 2633, "deletions": 0, "changes": 2633, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -0,0 +1,2633 @@\n+/* Variable tracking routines for the GNU compiler.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* This file contains the variable tracking pass.  It computes where\n+   variables are located (which registers or where in memory) at each position\n+   in instruction stream and emits notes describing the locations.\n+   Debug information (DWARF2 location lists) is finally generated from\n+   these notes.\n+   With this debug information, it is possible to show variables\n+   even when debugging optimized code.\n+\n+   How does the variable tracking pass work?\n+\n+   First, it scans RTL code for uses, stores and clobbers (register/memory\n+   references in instructions), for call insns and for stack adjustments\n+   separately for each basic block and saves them to an array of micro\n+   operations.\n+   The micro operations of one instruction are ordered so that\n+   pre-modifying stack adjustment < use < use with no var < call insn <\n+     < set < clobber < post-modifying stack adjustment\n+\n+   Then, a forward dataflow analysis is performed to find out how locations\n+   of variables change through code and to propagate the variable locations\n+   along control flow graph.\n+   The IN set for basic block BB is computed as a union of OUT sets of BB's\n+   predecessors, the OUT set for BB is copied from the IN set for BB and\n+   is changed according to micro operations in BB.\n+\n+   The IN and OUT sets for basic blocks consist of a current stack adjustment\n+   (used for adjusting offset of variables addressed using stack pointer),\n+   the table of structures describing the locations of parts of a variable\n+   and for each physical register a linked list for each physical register.\n+   The linked list is a list of variable parts stored in the register,\n+   i.e. it is a list of triplets (reg, decl, offset) where decl is\n+   REG_EXPR (reg) and offset is REG_OFFSET (reg).  The linked list is used for\n+   effective deleting appropriate variable parts when we set or clobber the\n+   register.\n+\n+   There may be more than one variable part in a register.  The linked lists\n+   should be pretty short so it is a good data structure here.\n+   For example in the following code, register allocator may assign same\n+   register to variables A and B, and both of them are stored in the same\n+   register in CODE:\n+\n+     if (cond)\n+       set A;\n+     else\n+       set B;\n+     CODE;\n+     if (cond)\n+       use A;\n+     else\n+       use B;\n+\n+   Finally, the NOTE_INSN_VAR_LOCATION notes describing the variable locations\n+   are emitted to appropriate positions in RTL code.  Each such a note describes\n+   the location of one variable at the point in instruction stream where the\n+   note is.  There is no need to emit a note for each variable before each\n+   instruction, we only emit these notes where the location of variable changes\n+   (this means that we also emit notes for changes between the OUT set of the\n+   previous block and the IN set of the current block).\n+\n+   The notes consist of two parts:\n+   1. the declaration (from REG_EXPR or MEM_EXPR)\n+   2. the location of a variable - it is either a simple register/memory\n+      reference (for simple variables, for example int),\n+      or a parallel of register/memory references (for a large variables\n+      which consist of several parts, for example long long).\n+\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"insn-config.h\"\n+#include \"reload.h\"\n+#include \"sbitmap.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibheap.h\"\n+#include \"hashtab.h\"\n+\n+/* Type of micro operation.  */\n+enum micro_operation_type\n+{\n+  MO_USE,\t/* Use location (REG or MEM).  */\n+  MO_USE_NO_VAR,/* Use location which is not associated with a variable\n+\t\t   or the variable is not trackable.  */\n+  MO_SET,\t/* Set location.  */\n+  MO_CLOBBER,\t/* Clobber location.  */\n+  MO_CALL,\t/* Call insn.  */\n+  MO_ADJUST\t/* Adjust stack pointer. */\n+};\n+\n+/* Where shall the note be emitted?  BEFORE or AFTER the instruction.  */\n+enum emit_note_where\n+{\n+  EMIT_NOTE_BEFORE_INSN,\n+  EMIT_NOTE_AFTER_INSN\n+};\n+\n+/* Structure holding information about micro operation.  */\n+typedef struct micro_operation_def\n+{\n+  /* Type of micro operation.  */\n+  enum micro_operation_type type;\n+\n+  union {\n+    /* Location.  */\n+    rtx loc;\n+\n+    /* Stack adjustment.  */\n+    HOST_WIDE_INT adjust;\n+  } u;\n+\n+  /* The instruction which the micro operation is in.  */\n+  rtx insn;\n+} micro_operation;\n+\n+/* Structure for passing some other parameters to function\n+   emit_note_insn_var_location.  */\n+typedef struct emit_note_data_def\n+{\n+  /* The instruction which the note will be emitted before/after.  */\n+  rtx insn;\n+\n+  /* Where the note will be emitted (before/after insn)?  */\n+  enum emit_note_where where;\n+} emit_note_data;\n+\n+/* Description of location of a part of a variable.  The content of a physical\n+   register is described by a chain of these structures.\n+   The chains are pretty short (usually 1 or 2 elements) and thus\n+   chain is the best data structure.  */\n+typedef struct attrs_def\n+{\n+  /* Pointer to next member of the list.  */\n+  struct attrs_def *next;\n+\n+  /* The rtx of register.  */\n+  rtx loc;\n+\n+  /* The declaration corresponding to LOC.  */\n+  tree decl;\n+\n+  /* Offset from start of DECL.  */\n+  HOST_WIDE_INT offset;\n+} *attrs;\n+\n+/* Structure holding the IN or OUT set for a basic block.  */\n+typedef struct dataflow_set_def\n+{\n+  /* Adjustment of stack offset.  */\n+  HOST_WIDE_INT stack_adjust;\n+\n+  /* Attributes for registers (lists of attrs).  */\n+  attrs regs[FIRST_PSEUDO_REGISTER];\n+\n+  /* Variable locations.  */\n+  htab_t vars;\n+} dataflow_set;\n+\n+/* The structure (one for each basic block) containing the information\n+   needed for variable tracking.  */\n+typedef struct variable_tracking_info_def\n+{\n+  /* Number of micro operations stored in the MOS array.  */\n+  int n_mos;\n+\n+  /* The array of micro operations.  */\n+  micro_operation *mos;\n+\n+  /* The IN and OUT set for dataflow analysis.  */\n+  dataflow_set in;\n+  dataflow_set out;\n+\n+  /* Has the block been visited in DFS?  */\n+  bool visited;\n+} *variable_tracking_info;\n+\n+/* Structure for chaining the locations.  */\n+typedef struct location_chain_def\n+{\n+  /* Next element in the chain.  */\n+  struct location_chain_def *next;\n+\n+  /* The location (REG or MEM).  */\n+  rtx loc;\n+} *location_chain;\n+\n+/* Structure describing one part of variable.  */\n+typedef struct variable_part_def\n+{\n+  /* Chain of locations of the part.  */\n+  location_chain loc_chain;\n+\n+  /* Location which was last emitted to location list.  */\n+  rtx cur_loc;\n+\n+  /* The offset in the variable.  */\n+  HOST_WIDE_INT offset;\n+} variable_part;\n+\n+/* Maximum number of location parts.  */\n+#define MAX_VAR_PARTS 16\n+\n+/* Structure describing where the variable is located.  */\n+typedef struct variable_def\n+{\n+  /* The declaration of the variable.  */\n+  tree decl;\n+\n+  /* Number of variable parts.  */\n+  int n_var_parts;\n+\n+  /* The variable parts.  */\n+  variable_part var_part[MAX_VAR_PARTS];\n+} *variable;\n+\n+/* Hash function for DECL for VARIABLE_HTAB.  */\n+#define VARIABLE_HASH_VAL(decl) ((size_t) (decl))\n+\n+/* Pointer to the BB's information specific to variable tracking pass.  */\n+#define VTI(BB) ((variable_tracking_info) (BB)->aux)\n+\n+/* Alloc pool for struct attrs_def.  */\n+static alloc_pool attrs_pool;\n+\n+/* Alloc pool for struct variable_def.  */\n+static alloc_pool var_pool;\n+\n+/* Alloc pool for struct location_chain_def.  */\n+static alloc_pool loc_chain_pool;\n+\n+/* Changed variables, notes will be emitted for them.  */\n+static htab_t changed_variables;\n+\n+/* Shall notes be emitted?  */\n+static bool emit_notes;\n+\n+/* Fake variable for stack pointer.  */\n+tree frame_base_decl;\n+\n+/* Local function prototypes.  */\n+static void stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n+\t\t\t\t\t  HOST_WIDE_INT *);\n+static void insn_stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n+\t\t\t\t\t       HOST_WIDE_INT *);\n+static void bb_stack_adjust_offset (basic_block);\n+static HOST_WIDE_INT prologue_stack_adjust (void);\n+static bool vt_stack_adjustments (void);\n+static rtx adjust_stack_reference (rtx, HOST_WIDE_INT);\n+static hashval_t variable_htab_hash (const void *);\n+static int variable_htab_eq (const void *, const void *);\n+static void variable_htab_free (void *);\n+\n+static void init_attrs_list_set (attrs *);\n+static void attrs_list_clear (attrs *);\n+static attrs attrs_list_member (attrs, tree, HOST_WIDE_INT);\n+static void attrs_list_insert (attrs *, tree, HOST_WIDE_INT, rtx);\n+static void attrs_list_copy (attrs *, attrs);\n+static void attrs_list_union (attrs *, attrs);\n+\n+static void vars_clear (htab_t);\n+static int vars_copy_1 (void **, void *);\n+static void vars_copy (htab_t, htab_t);\n+static void var_reg_delete_and_set (dataflow_set *, rtx);\n+static void var_reg_delete (dataflow_set *, rtx);\n+static void var_regno_delete (dataflow_set *, int);\n+static void var_mem_delete_and_set (dataflow_set *, rtx);\n+static void var_mem_delete (dataflow_set *, rtx);\n+\n+static void dataflow_set_init (dataflow_set *, int);\n+static void dataflow_set_clear (dataflow_set *);\n+static void dataflow_set_copy (dataflow_set *, dataflow_set *);\n+static int variable_union_info_cmp_pos (const void *, const void *);\n+static int variable_union (void **, void *);\n+static void dataflow_set_union (dataflow_set *, dataflow_set *);\n+static bool variable_part_different_p (variable_part *, variable_part *);\n+static bool variable_different_p (variable, variable);\n+static int dataflow_set_different_1 (void **, void *);\n+static int dataflow_set_different_2 (void **, void *);\n+static bool dataflow_set_different (dataflow_set *, dataflow_set *);\n+static void dataflow_set_destroy (dataflow_set *);\n+\n+static bool contains_symbol_ref (rtx);\n+static bool track_expr_p (tree);\n+static int count_uses (rtx *, void *);\n+static void count_uses_1 (rtx *, void *);\n+static void count_stores (rtx, rtx, void *);\n+static int add_uses (rtx *, void *);\n+static void add_uses_1 (rtx *, void *);\n+static void add_stores (rtx, rtx, void *);\n+static bool compute_bb_dataflow (basic_block);\n+static void vt_find_locations (void);\n+\n+static void dump_attrs_list (attrs);\n+static int dump_variable (void **, void *);\n+static void dump_vars (htab_t);\n+static void dump_dataflow_set (dataflow_set *);\n+static void dump_dataflow_sets (void);\n+\n+static void variable_was_changed (variable, htab_t);\n+static void set_frame_base_location (dataflow_set *, rtx);\n+static void set_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n+static void delete_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n+static int emit_note_insn_var_location (void **, void *);\n+static void emit_notes_for_changes (rtx, enum emit_note_where);\n+static int emit_notes_for_differences_1 (void **, void *);\n+static int emit_notes_for_differences_2 (void **, void *);\n+static void emit_notes_for_differences (rtx, dataflow_set *, dataflow_set *);\n+static void emit_notes_in_bb (basic_block);\n+static void vt_emit_notes (void);\n+\n+static bool vt_get_decl_and_offset (rtx, tree *, HOST_WIDE_INT *);\n+static void vt_add_function_parameters (void);\n+static void vt_initialize (void);\n+static void vt_finalize (void);\n+\n+/* Given a SET, calculate the amount of stack adjustment it contains\n+   PRE- and POST-modifying stack pointer.\n+   This function is similar to stack_adjust_offset.  */\n+\n+static void\n+stack_adjust_offset_pre_post (rtx pattern, HOST_WIDE_INT *pre,\n+\t\t\t      HOST_WIDE_INT *post)\n+{\n+  rtx src = SET_SRC (pattern);\n+  rtx dest = SET_DEST (pattern);\n+  enum rtx_code code;\n+\n+  if (dest == stack_pointer_rtx)\n+    {\n+      /* (set (reg sp) (plus (reg sp) (const_int))) */\n+      code = GET_CODE (src);\n+      if (! (code == PLUS || code == MINUS)\n+\t  || XEXP (src, 0) != stack_pointer_rtx\n+\t  || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\treturn;\n+\n+      if (code == MINUS)\n+\t*post += INTVAL (XEXP (src, 1));\n+      else\n+\t*post -= INTVAL (XEXP (src, 1));\n+    }\n+  else if (GET_CODE (dest) == MEM)\n+    {\n+      /* (set (mem (pre_dec (reg sp))) (foo)) */\n+      src = XEXP (dest, 0);\n+      code = GET_CODE (src);\n+\n+      switch (code)\n+\t{\n+\tcase PRE_MODIFY:\n+\tcase POST_MODIFY:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      rtx val = XEXP (XEXP (src, 1), 1);\n+\t      /* We handle only adjustments by constant amount.  */\n+\t      if (GET_CODE (XEXP (src, 1)) != PLUS ||\n+\t\t  GET_CODE (val) != CONST_INT)\n+\t\tabort ();\n+\t      if (code == PRE_MODIFY)\n+\t\t*pre -= INTVAL (val);\n+\t      else\n+\t\t*post -= INTVAL (val);\n+\t      break;\n+\t    }\n+\t  return;\n+\n+\tcase PRE_DEC:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      *pre += GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    }\n+\t  return;\n+\n+\tcase POST_DEC:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      *post += GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    }\n+\t  return;\n+\n+\tcase PRE_INC:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      *pre -= GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    }\n+\t  return;\n+\n+\tcase POST_INC:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      *post -= GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    }\n+\t  return;\n+\n+\tdefault:\n+\t  return;\n+\t}\n+    }\n+}\n+\n+/* Given an INSN, calculate the amount of stack adjustment it contains\n+   PRE- and POST-modifying stack pointer.  */\n+\n+static void\n+insn_stack_adjust_offset_pre_post (rtx insn, HOST_WIDE_INT *pre,\n+\t\t\t\t   HOST_WIDE_INT *post)\n+{\n+  *pre = 0;\n+  *post = 0;\n+\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    stack_adjust_offset_pre_post (PATTERN (insn), pre, post);\n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t   || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    {\n+      int i;\n+\n+      /* There may be stack adjustments inside compound insns.  Search\n+\t for them.  */\n+      for ( i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n+\t  stack_adjust_offset_pre_post (XVECEXP (PATTERN (insn), 0, i),\n+\t\t\t\t\tpre, post);\n+    }\n+}\n+\n+/* Compute stack adjustnment in basic block BB.  */\n+\n+static void\n+bb_stack_adjust_offset (basic_block bb)\n+{\n+  HOST_WIDE_INT offset;\n+  int i;\n+\n+  offset = VTI (bb)->in.stack_adjust;\n+  for (i = 0; i < VTI (bb)->n_mos; i++)\n+    {\n+      if (VTI (bb)->mos[i].type == MO_ADJUST)\n+\toffset += VTI (bb)->mos[i].u.adjust;\n+      else if (VTI (bb)->mos[i].type != MO_CALL)\n+\t{\n+\t  if (GET_CODE (VTI (bb)->mos[i].u.loc) == MEM)\n+\t    {\n+\t      VTI (bb)->mos[i].u.loc\n+\t\t= adjust_stack_reference (VTI (bb)->mos[i].u.loc, -offset);\n+\t    }\n+\t}\n+    }\n+  VTI (bb)->out.stack_adjust = offset;\n+}\n+\n+/* Compute stack adjustment caused by function prolog.  */\n+\n+static HOST_WIDE_INT\n+prologue_stack_adjust (void)\n+{\n+  HOST_WIDE_INT offset = 0;\n+  basic_block bb = ENTRY_BLOCK_PTR->next_bb;\n+  rtx insn;\n+  rtx end;\n+\n+  if (!BB_END (bb))\n+    return 0;\n+\n+  end = NEXT_INSN (BB_END (bb));\n+  for (insn = BB_HEAD (bb); insn != end; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n+\tbreak;\n+\n+      if (INSN_P (insn))\n+\t{\n+\t  HOST_WIDE_INT tmp;\n+\n+\t  insn_stack_adjust_offset_pre_post (insn, &tmp, &tmp);\n+\t  offset += tmp;\n+\t}\n+    }\n+\n+  return offset;\n+}\n+\n+/* Compute stack adjustments for all blocks by traversing DFS tree.\n+   Return true when the adjustments on all incoming edges are consistent.\n+   Heavily borrowed from flow_depth_first_order_compute.  */\n+\n+static bool\n+vt_stack_adjustments (void)\n+{\n+  edge *stack;\n+  int sp;\n+\n+  /* Initialize enttry block.  */\n+  VTI (ENTRY_BLOCK_PTR)->visited = true;\n+  VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = 0;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  sp = 0;\n+\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+\n+  while (sp)\n+    {\n+      edge e;\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      e = stack[sp - 1];\n+      src = e->src;\n+      dest = e->dest;\n+\n+      /* Check if the edge destination has been visited yet.  */\n+      if (!VTI (dest)->visited)\n+\t{\n+\t  VTI (dest)->visited = true;\n+\t  VTI (dest)->in.stack_adjust = VTI (src)->out.stack_adjust;\n+\t  bb_stack_adjust_offset (dest);\n+\n+\t  if (dest->succ)\n+\t    /* Since the DEST node has been visited for the first\n+\t       time, check its successors.  */\n+\t    stack[sp++] = dest->succ;\n+\t}\n+      else\n+\t{\n+\t  /* Check whether the adjustments on the edges are the same.  */\n+\t  if (VTI (dest)->in.stack_adjust != VTI (src)->out.stack_adjust)\n+\t    {\n+\t      free (stack);\n+\t      return false;\n+\t    }\n+\n+\t  if (e->succ_next)\n+\t    /* Go to the next edge.  */\n+\t    stack[sp - 1] = e->succ_next;\n+\t  else\n+\t    /* Return to previous level if there are no more edges.  */\n+\t    sp--;\n+\t}\n+    }\n+\n+  free (stack);\n+  return true;\n+}\n+\n+/* Adjust stack reference MEM by ADJUSTMENT bytes and return the new rtx.  */\n+\n+static rtx\n+adjust_stack_reference (rtx mem, HOST_WIDE_INT adjustment)\n+{\n+  rtx adjusted_mem;\n+  rtx tmp;\n+\n+  adjusted_mem = copy_rtx (mem);\n+  XEXP (adjusted_mem, 0) = replace_rtx (XEXP (adjusted_mem, 0),\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tgen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t      GEN_INT (adjustment)));\n+  tmp = simplify_rtx (XEXP (adjusted_mem, 0));\n+  if (tmp)\n+    XEXP (adjusted_mem, 0) = tmp;\n+\n+  return adjusted_mem;\n+}\n+\n+/* The hash function for variable_htab, computes the hash value\n+   from the declaration of variable X.  */\n+\n+static hashval_t\n+variable_htab_hash (const void *x)\n+{\n+  const variable v = (const variable) x;\n+\n+  return (VARIABLE_HASH_VAL (v->decl));\n+}\n+\n+/* Compare the declaration of variable X with declaration Y.  */\n+\n+static int\n+variable_htab_eq (const void *x, const void *y)\n+{\n+  const variable v = (const variable) x;\n+  const tree decl = (const tree) y;\n+\n+  return (VARIABLE_HASH_VAL (v->decl) == VARIABLE_HASH_VAL (decl));\n+}\n+\n+/* Free the element of VARIABLE_HTAB (its type is struct variable_def).  */\n+\n+static void\n+variable_htab_free (void *elem)\n+{\n+  int i;\n+  variable var = (variable) elem;\n+  location_chain node, next;\n+\n+  for (i = 0; i < var->n_var_parts; i++)\n+    {\n+      for (node = var->var_part[i].loc_chain; node; node = next)\n+\t{\n+\t  next = node->next;\n+\t  pool_free (loc_chain_pool, node);\n+\t}\n+      var->var_part[i].loc_chain = NULL;\n+    }\n+  pool_free (var_pool, var);\n+}\n+\n+/* Initialize the set (array) SET of attrs to empty lists.  */\n+\n+static void\n+init_attrs_list_set (attrs *set)\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    set[i] = NULL;\n+}\n+\n+/* Make the list *LISTP empty.  */\n+\n+static void\n+attrs_list_clear (attrs *listp)\n+{\n+  attrs list, next;\n+\n+  for (list = *listp; list; list = next)\n+    {\n+      next = list->next;\n+      pool_free (attrs_pool, list);\n+    }\n+  *listp = NULL;\n+}\n+\n+/* Return true if the pair of DECL and OFFSET is the member of the LIST.  */\n+\n+static attrs\n+attrs_list_member (attrs list, tree decl, HOST_WIDE_INT offset)\n+{\n+  for (; list; list = list->next)\n+    if (list->decl == decl && list->offset == offset)\n+      return list;\n+  return NULL;\n+}\n+\n+/* Insert the triplet DECL, OFFSET, LOC to the list *LISTP.  */\n+\n+static void\n+attrs_list_insert (attrs *listp, tree decl, HOST_WIDE_INT offset, rtx loc)\n+{\n+  attrs list;\n+\n+  list = pool_alloc (attrs_pool);\n+  list->loc = loc;\n+  list->decl = decl;\n+  list->offset = offset;\n+  list->next = *listp;\n+  *listp = list;\n+}\n+\n+/* Copy all nodes from SRC and create a list *DSTP of the copies.  */\n+\n+static void\n+attrs_list_copy (attrs *dstp, attrs src)\n+{\n+  attrs n;\n+\n+  attrs_list_clear (dstp);\n+  for (; src; src = src->next)\n+    {\n+      n = pool_alloc (attrs_pool);\n+      n->loc = src->loc;\n+      n->decl = src->decl;\n+      n->offset = src->offset;\n+      n->next = *dstp;\n+      *dstp = n;\n+    }\n+}\n+\n+/* Add all nodes from SRC which are not in *DSTP to *DSTP.  */\n+\n+static void\n+attrs_list_union (attrs *dstp, attrs src)\n+{\n+  for (; src; src = src->next)\n+    {\n+      if (!attrs_list_member (*dstp, src->decl, src->offset))\n+\tattrs_list_insert (dstp, src->decl, src->offset, src->loc);\n+    }\n+}\n+\n+/* Delete all variables from hash table VARS.  */\n+\n+static void\n+vars_clear (htab_t vars)\n+{\n+  htab_empty (vars);\n+}\n+\n+/* Copy one variable from *SLOT to hash table DATA.  */\n+\n+static int\n+vars_copy_1 (void **slot, void *data)\n+{\n+  htab_t dst = (htab_t) data;\n+  variable src, *dstp, var;\n+  int i;\n+\n+  src = *(variable *) slot;\n+  dstp = (variable *) htab_find_slot_with_hash (dst, src->decl,\n+\t\t\t\t\t\tVARIABLE_HASH_VAL (src->decl),\n+\t\t\t\t\t\tINSERT);\n+  var = pool_alloc (var_pool);\n+  var->decl = src->decl;\n+  var->n_var_parts = src->n_var_parts;\n+  *dstp = (void *) var;\n+\n+  for (i = 0; i < var->n_var_parts; i++)\n+    {\n+      location_chain last, node;\n+\n+      var->var_part[i].offset = src->var_part[i].offset;\n+      last = NULL;\n+      for (node = src->var_part[i].loc_chain; node; node = node->next)\n+\t{\n+\t  location_chain new_lc;\n+\n+\t  new_lc = pool_alloc (loc_chain_pool);\n+\t  new_lc->next = NULL;\n+\t  new_lc->loc = node->loc;\n+\n+\t  if (last)\n+\t    last->next = new_lc;\n+\t  else\n+\t    var->var_part[i].loc_chain = new_lc;\n+\t  last = new_lc;\n+\t}\n+\n+      /* We are at the basic block boundary when copying variable description\n+\t so set the CUR_LOC to be the first element of the chain.  */\n+      if (var->var_part[i].loc_chain)\n+\tvar->var_part[i].cur_loc = var->var_part[i].loc_chain->loc;\n+      else\n+\tvar->var_part[i].cur_loc = NULL;\n+    }\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Copy all variables from hash table SRC to hash table DST.  */\n+\n+static void\n+vars_copy (htab_t dst, htab_t src)\n+{\n+  vars_clear (dst);\n+  htab_traverse (src, vars_copy_1, dst);\n+}\n+\n+/* Delete current content of register LOC in dataflow set SET\n+   and set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */\n+\n+static void\n+var_reg_delete_and_set (dataflow_set *set, rtx loc)\n+{\n+  attrs *reg = &set->regs[REGNO (loc)];\n+  tree decl = REG_EXPR (loc);\n+  HOST_WIDE_INT offset = REG_OFFSET (loc);\n+  attrs node, prev, next;\n+\n+  prev = NULL;\n+  for (node = *reg; node; node = next)\n+    {\n+      next = node->next;\n+      if (node->decl != decl || node->offset != offset)\n+\t{\n+\t  delete_variable_part (set, node->loc, node->decl, node->offset);\n+\n+\t  if (prev)\n+\t    prev->next = next;\n+\t  else\n+\t    *reg = next;\n+\t  pool_free (attrs_pool, node);\n+\t}\n+      else\n+\t{\n+\t  node->loc = loc;\n+\t  prev = node;\n+\t}\n+    }\n+  if (*reg == NULL)\n+    attrs_list_insert (reg, decl, offset, loc);\n+  set_variable_part (set, loc, decl, offset);\n+}\n+\n+/* Delete current content of register LOC in dataflow set SET.  */\n+\n+static void\n+var_reg_delete (dataflow_set *set, rtx loc)\n+{\n+  attrs *reg = &set->regs[REGNO (loc)];\n+  attrs node, next;\n+\n+  for (node = *reg; node; node = next)\n+    {\n+      next = node->next;\n+      delete_variable_part (set, node->loc, node->decl, node->offset);\n+      pool_free (attrs_pool, node);\n+    }\n+  *reg = NULL;\n+}\n+\n+/* Delete content of register with number REGNO in dataflow set SET.  */\n+\n+static void\n+var_regno_delete (dataflow_set *set, int regno)\n+{\n+  attrs *reg = &set->regs[regno];\n+  attrs node, next;\n+\n+  for (node = *reg; node; node = next)\n+    {\n+      next = node->next;\n+      delete_variable_part (set, node->loc, node->decl, node->offset);\n+      pool_free (attrs_pool, node);\n+    }\n+  *reg = NULL;\n+}\n+\n+/* Delete and set the location part of variable MEM_EXPR (LOC)\n+   in dataflow set SET to LOC.\n+   Adjust the address first if it is stack pointer based.  */\n+\n+static void\n+var_mem_delete_and_set (dataflow_set *set, rtx loc)\n+{\n+  tree decl = MEM_EXPR (loc);\n+  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+\n+  set_variable_part (set, loc, decl, offset);\n+}\n+\n+/* Delete the location part LOC from dataflow set SET.\n+   Adjust the address first if it is stack pointer based.  */\n+\n+static void\n+var_mem_delete (dataflow_set *set, rtx loc)\n+{\n+  tree decl = MEM_EXPR (loc);\n+  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+\n+  delete_variable_part (set, loc, decl, offset);\n+}\n+\n+/* Initialize dataflow set SET to be empty. \n+   VARS_SIZE is the initial size of hash table VARS.  */\n+\n+static void\n+dataflow_set_init (dataflow_set *set, int vars_size)\n+{\n+  init_attrs_list_set (set->regs);\n+  set->vars = htab_create (vars_size, variable_htab_hash, variable_htab_eq,\n+\t\t\t   variable_htab_free);\n+  set->stack_adjust = 0;\n+}\n+\n+/* Delete the contents of dataflow set SET.  */\n+\n+static void\n+dataflow_set_clear (dataflow_set *set)\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    attrs_list_clear (&set->regs[i]);\n+\n+  vars_clear (set->vars);\n+}\n+\n+/* Copy the contents of dataflow set SRC to DST.  */\n+\n+static void\n+dataflow_set_copy (dataflow_set *dst, dataflow_set *src)\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    attrs_list_copy (&dst->regs[i], src->regs[i]);\n+\n+  vars_copy (dst->vars, src->vars);\n+  dst->stack_adjust = src->stack_adjust;\n+}\n+\n+/* Information for merging lists of locations for a given offset of variable.\n+ */\n+struct variable_union_info\n+{\n+  /* Node of the location chain.  */\n+  location_chain lc;\n+\n+  /* The sum of positions in the input chains.  */\n+  int pos;\n+\n+  /* The position in the chains of SRC and DST dataflow sets.  */\n+  int pos_src;\n+  int pos_dst;\n+};\n+\n+/* Compare function for qsort, order the structures by POS element.  */\n+\n+static int\n+variable_union_info_cmp_pos (const void *n1, const void *n2)\n+{\n+  const struct variable_union_info *i1 = n1;\n+  const struct variable_union_info *i2 = n2;\n+\n+  if (i1->pos != i2->pos)\n+    return i1->pos - i2->pos;\n+  \n+  return (i1->pos_dst - i2->pos_dst);\n+}\n+\n+/* Compute union of location parts of variable *SLOT and the same variable\n+   from hash table DATA.  Compute \"sorted\" union of the location chains\n+   for common offsets, i.e. the locations of a variable part are sorted by\n+   a priority where the priority is the sum of the positions in the 2 chains\n+   (if a location is only in one list the position in the second list is\n+   defined to be larger than the length of the chains).\n+   When we are updating the location parts the newest location is in the\n+   beginning of the chain, so when we do the described \"sorted\" union\n+   we keep the newest locations in the beginning.  */\n+\n+static int\n+variable_union (void **slot, void *data)\n+{\n+  variable src, dst, *dstp;\n+  dataflow_set *set = (dataflow_set *) data;\n+  int i, j, k;\n+\n+  src = *(variable *) slot;\n+  dstp = (variable *) htab_find_slot_with_hash (set->vars, src->decl,\n+\t\t\t\t\t\tVARIABLE_HASH_VAL (src->decl),\n+\t\t\t\t\t\tINSERT);\n+  if (!*dstp)\n+    {\n+      *dstp = dst = pool_alloc (var_pool);\n+      dst->decl = src->decl;\n+      dst->n_var_parts = 0;\n+    }\n+  else\n+    dst = *dstp;\n+\n+#ifdef ENABLE_CHECKING\n+  if (src->n_var_parts == 0)\n+    abort ();\n+#endif\n+\n+  /* Count the number of location parts, result is K.  */\n+  for (i = 0, j = 0, k = 0;\n+       i < src->n_var_parts && j < dst->n_var_parts; k++)\n+    {\n+      if (src->var_part[i].offset == dst->var_part[j].offset)\n+\t{\n+\t  i++;\n+\t  j++;\n+\t}\n+      else if (src->var_part[i].offset < dst->var_part[j].offset)\n+\ti++;\n+      else\n+\tj++;\n+    }\n+  if (i < src->n_var_parts)\n+    k += src->n_var_parts - i;\n+  if (j < dst->n_var_parts)\n+    k += dst->n_var_parts - j;\n+#ifdef ENABLE_CHECKING\n+  /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n+     thus there are at most MAX_VAR_PARTS different offsets.  */\n+  if (k > MAX_VAR_PARTS)\n+    abort ();\n+#endif\n+\n+  i = src->n_var_parts - 1;\n+  j = dst->n_var_parts - 1;\n+  dst->n_var_parts = k;\n+\n+  for (k--; k >= 0; k--)\n+    {\n+      location_chain node;\n+\n+      if (i >= 0 && j >= 0\n+\t  && src->var_part[i].offset == dst->var_part[j].offset)\n+\t{\n+\t  /* Compute the \"sorted\" union of the chains, i.e. the locations which\n+\t     are in both chains go first, they are sorted by the sum of\n+\t     positions in the chains.  */\n+\t  int dst_l, src_l;\n+\t  int ii, jj, n;\n+\t  struct variable_union_info *vui;\n+\t  \n+\t  src_l = 0;\n+\t  for (node = src->var_part[i].loc_chain; node; node = node->next)\n+\t    src_l++;\n+\t  dst_l = 0;\n+\t  for (node = dst->var_part[j].loc_chain; node; node = node->next)\n+\t    dst_l++;\n+\t  vui = xcalloc (src_l + dst_l, sizeof (struct variable_union_info));\n+\n+\t  /* Fill in the locations from DST.  */\n+\t  for (node = dst->var_part[j].loc_chain, jj = 0; node;\n+\t       node = node->next, jj++)\n+\t    {\n+\t      vui[jj].lc = node;\n+\t      vui[jj].pos_dst = jj;\n+\n+\t      /* Value larger than a sum of 2 valid positions.  */\n+\t      vui[jj].pos_src = src_l + dst_l;\n+\t    }\n+\n+\t  /* Fill in the locations from SRC.  */\n+\t  n = dst_l;\n+\t  for (node = src->var_part[i].loc_chain, ii = 0; node;\n+\t       node = node->next, ii++)\n+\t    {\n+\t      /* Find location from NODE.  */\n+\t      for (jj = 0; jj < dst_l; jj++)\n+\t\t{\n+\t\t  if ((GET_CODE (vui[jj].lc->loc) == REG\n+\t\t       && GET_CODE (node->loc) == REG\n+\t\t       && REGNO (vui[jj].lc->loc) == REGNO (node->loc))\n+\t\t      || rtx_equal_p (vui[jj].lc->loc, node->loc))\n+\t\t    {\n+\t\t      vui[jj].pos_src = ii;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (jj >= dst_l)\t/* The location has not been found.  */\n+\t\t{\n+\t\t  location_chain new_node;\n+\n+\t\t  /* Copy the location from SRC.  */\n+\t\t  new_node = pool_alloc (loc_chain_pool);\n+\t\t  new_node->loc = node->loc;\n+\t\t  vui[n].lc = new_node;\n+\t\t  vui[n].pos_src = ii;\n+\t\t  vui[n].pos_dst = src_l + dst_l;\n+\t\t  n++;\n+\t\t}\n+\t    }\n+\n+\t  for (ii = 0; ii < src_l + dst_l; ii++)\n+\t    vui[ii].pos = vui[ii].pos_src + vui[ii].pos_dst;\n+\n+\t  qsort (vui, n, sizeof (struct variable_union_info),\n+\t\t variable_union_info_cmp_pos);\n+\n+\t  /* Reconnect the nodes in sorted order.  */\n+\t  for (ii = 1; ii < n; ii++)\n+\t    vui[ii - 1].lc->next = vui[ii].lc;\n+\t  vui[n - 1].lc->next = NULL;\n+\n+\t  dst->var_part[k].loc_chain = vui[0].lc;\n+\t  dst->var_part[k].offset = dst->var_part[j].offset;\n+\n+\t  free (vui);\n+\t  i--;\n+\t  j--;\n+\t}\n+      else if ((i >= 0 && j >= 0\n+\t\t&& src->var_part[i].offset < dst->var_part[j].offset)\n+\t       || i < 0)\n+\t{\n+\t  dst->var_part[k] = dst->var_part[j];\n+\t  j--;\n+\t}\n+      else if ((i >= 0 && j >= 0\n+\t\t&& src->var_part[i].offset > dst->var_part[j].offset)\n+\t       || j < 0)\n+\t{\n+\t  location_chain last = NULL;\n+\n+\t  /* Copy the chain from SRC.  */\n+\t  for (node = src->var_part[i].loc_chain; node; node = node->next)\n+\t    {\n+\t      location_chain new_lc;\n+\n+\t      new_lc = pool_alloc (loc_chain_pool);\n+\t      new_lc->next = NULL;\n+\t      new_lc->loc = node->loc;\n+\n+\t      if (last)\n+\t\tlast->next = new_lc;\n+\t      else\n+\t\tdst->var_part[k].loc_chain = new_lc;\n+\t      last = new_lc;\n+\t    }\n+\n+\t  dst->var_part[k].offset = src->var_part[i].offset;\n+\t  i--;\n+\t}\n+\n+      /* We are at the basic block boundary when computing union\n+\t so set the CUR_LOC to be the first element of the chain.  */\n+      if (dst->var_part[k].loc_chain)\n+\tdst->var_part[k].cur_loc = dst->var_part[k].loc_chain->loc;\n+      else\n+\tdst->var_part[k].cur_loc = NULL;\n+    }\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Compute union of dataflow sets SRC and DST and store it to DST.  */\n+\n+static void\n+dataflow_set_union (dataflow_set *dst, dataflow_set *src)\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    attrs_list_union (&dst->regs[i], src->regs[i]);\n+\n+  htab_traverse (src->vars, variable_union, dst);\n+}\n+\n+/* Flag whether two dataflow sets being compared contain different data.  */\n+static bool\n+dataflow_set_different_value;\n+\n+static bool\n+variable_part_different_p (variable_part *vp1, variable_part *vp2)\n+{\n+  location_chain lc1, lc2;\n+\n+  for (lc1 = vp1->loc_chain; lc1; lc1 = lc1->next)\n+    {\n+      for (lc2 = vp2->loc_chain; lc2; lc2 = lc2->next)\n+\t{\n+\t  if (GET_CODE (lc1->loc) == REG && GET_CODE (lc2->loc) == REG)\n+\t    {\n+\t      if (REGNO (lc1->loc) == REGNO (lc2->loc))\n+\t\tbreak;\n+\t    }\n+\t  if (rtx_equal_p (lc1->loc, lc2->loc))\n+\t    break;\n+\t}\n+      if (!lc2)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if variables VAR1 and VAR2 are different (only the first\n+   location in the list of locations is checked for each offset,\n+   i.e. when true is returned a note should be emitted).  */\n+\n+static bool\n+variable_different_p (variable var1, variable var2)\n+{\n+  int i;\n+\n+  if (var1->n_var_parts != var2->n_var_parts)\n+    return true;\n+\n+  for (i = 0; i < var1->n_var_parts; i++)\n+    {\n+      if (var1->var_part[i].offset != var2->var_part[i].offset)\n+\treturn true;\n+      if (variable_part_different_p (&var1->var_part[i], &var2->var_part[i]))\n+\treturn true;\n+      if (variable_part_different_p (&var2->var_part[i], &var1->var_part[i]))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Compare variable *SLOT with the same variable in hash table DATA\n+   and set DATAFLOW_SET_DIFFERENT_VALUE if they are different.  */\n+\n+static int\n+dataflow_set_different_1 (void **slot, void *data)\n+{\n+  htab_t htab = (htab_t) data;\n+  variable var1, var2;\n+\n+  var1 = *(variable *) slot;\n+  var2 = (variable) htab_find_with_hash (htab, var1->decl,\n+\t\t\t\t\t VARIABLE_HASH_VAL (var1->decl));\n+  if (!var2)\n+    {\n+      dataflow_set_different_value = true;\n+\n+      /* Stop traversing the hash table.   */\n+      return 0;\n+    }\n+\n+  if (variable_different_p (var1, var2))\n+    {\n+      dataflow_set_different_value = true;\n+\n+      /* Stop traversing the hash table.   */\n+      return 0;\n+    }\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Compare variable *SLOT with the same variable in hash table DATA\n+   and set DATAFLOW_SET_DIFFERENT_VALUE if they are different.  */\n+\n+static int\n+dataflow_set_different_2 (void **slot, void *data)\n+{\n+  htab_t htab = (htab_t) data;\n+  variable var1, var2;\n+\n+  var1 = *(variable *) slot;\n+  var2 = (variable) htab_find_with_hash (htab, var1->decl,\n+\t\t\t\t\t VARIABLE_HASH_VAL (var1->decl));\n+  if (!var2)\n+    {\n+      dataflow_set_different_value = true;\n+\n+      /* Stop traversing the hash table.   */\n+      return 0;\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  /* If both variables are defined they have been already checked for\n+     equivalence.  */\n+  if (variable_different_p (var1, var2))\n+    abort ();\n+#endif\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Return true if dataflow sets OLD_SET and NEW_SET differ.  */\n+\n+static bool\n+dataflow_set_different (dataflow_set *old_set, dataflow_set *new_set)\n+{\n+  dataflow_set_different_value = false;\n+\n+  htab_traverse (old_set->vars, dataflow_set_different_1, new_set->vars);\n+  if (!dataflow_set_different_value)\n+    {\n+      /* We have compared the variables which are in both hash tables\n+\t so now only check whether there are some variables in NEW_SET->VARS\n+\t which are not in OLD_SET->VARS.  */\n+      htab_traverse (new_set->vars, dataflow_set_different_2, old_set->vars);\n+    }\n+  return dataflow_set_different_value;\n+}\n+\n+/* Free the contents of dataflow set SET.  */\n+\n+static void\n+dataflow_set_destroy (dataflow_set *set)\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    attrs_list_clear (&set->regs[i]);\n+\n+  htab_delete (set->vars);\n+  set->vars = NULL;\n+}\n+\n+/* Return true if RTL X contains a SYMBOL_REF.  */\n+\n+static bool\n+contains_symbol_ref (rtx x)\n+{\n+  const char *fmt;\n+  RTX_CODE code;\n+  int i;\n+\n+  if (!x)\n+    return false;\n+\n+  code = GET_CODE (x);\n+  if (code == SYMBOL_REF)\n+    return true;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (contains_symbol_ref (XEXP (x, i)))\n+\t    return true;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (contains_symbol_ref (XVECEXP (x, i, j)))\n+\t      return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Shall EXPR be tracked?  */\n+\n+static bool\n+track_expr_p (tree expr)\n+{\n+  rtx decl_rtl;\n+\n+  /* If EXPR is not a parameter or a variable do not track it.  */\n+  if (TREE_CODE (expr) != VAR_DECL && TREE_CODE (expr) != PARM_DECL)\n+    return 0;\n+\n+  /* It also must have a name...  */\n+  if (!DECL_NAME (expr))\n+    return 0;\n+\n+  /* ... and a RTL assigned to it.  */\n+  decl_rtl = DECL_RTL_IF_SET (expr);\n+  if (!decl_rtl)\n+    return 0;\n+\n+  /* Do not track global variables until we are able to emit correct location\n+     list for them.  */\n+  if (TREE_STATIC (expr))\n+    return 0;\n+\n+  /* When the EXPR is a DECL for alias of some variable (see example)\n+     the TREE_STATIC flag is not used.  Disable tracking all DECLs whose\n+     DECL_RTL contains SYMBOL_REF.\n+\n+     Example:\n+     extern char **_dl_argv_internal __attribute__ ((alias (\"_dl_argv\")));\n+     char **_dl_argv;\n+  */\n+  if (GET_CODE (decl_rtl) == MEM\n+      && contains_symbol_ref (XEXP (decl_rtl, 0)))\n+    return 0;\n+\n+  /* If RTX is a memory it should not be very large (because it would be\n+     an array or struct).  */\n+  if (GET_CODE (decl_rtl) == MEM)\n+    {\n+      /* Do not track structures and arrays.  */\n+      if (GET_MODE (decl_rtl) == BLKmode)\n+\treturn 0;\n+      if (MEM_SIZE (decl_rtl)\n+\t  && INTVAL (MEM_SIZE (decl_rtl)) > MAX_VAR_PARTS)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Count uses (register and memory references) LOC which will be tracked.\n+   INSN is instruction which the LOC is part of.  */\n+\n+static int\n+count_uses (rtx *loc, void *insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n+\n+  if (GET_CODE (*loc) == REG)\n+    {\n+#ifdef ENABLE_CHECKING\n+\tif (REGNO (*loc) >= FIRST_PSEUDO_REGISTER)\n+\t  abort ();\n+#endif\n+\tVTI (bb)->n_mos++;\n+    }\n+  else if (GET_CODE (*loc) == MEM\n+\t   && MEM_EXPR (*loc)\n+\t   && track_expr_p (MEM_EXPR (*loc)))\n+    {\n+\t  VTI (bb)->n_mos++;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Helper function for finding all uses of REG/MEM in X in insn INSN.  */\n+\n+static void\n+count_uses_1 (rtx *x, void *insn)\n+{\n+  for_each_rtx (x, count_uses, insn);\n+}\n+\n+/* Count stores (register and memory references) LOC which will be tracked.\n+   INSN is instruction which the LOC is part of.  */\n+\n+static void\n+count_stores (rtx loc, rtx expr ATTRIBUTE_UNUSED, void *insn)\n+{\n+  count_uses (&loc, insn);\n+}\n+\n+/* Add uses (register and memory references) LOC which will be tracked\n+   to VTI (bb)->mos.  INSN is instruction which the LOC is part of.  */\n+\n+static int\n+add_uses (rtx *loc, void *insn)\n+{\n+  if (GET_CODE (*loc) == REG)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n+      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\n+      mo->type = ((REG_EXPR (*loc) && track_expr_p (REG_EXPR (*loc)))\n+\t\t  ? MO_USE : MO_USE_NO_VAR);\n+      mo->u.loc = *loc;\n+      mo->insn = (rtx) insn;\n+    }\n+  else if (GET_CODE (*loc) == MEM\n+\t   && MEM_EXPR (*loc)\n+\t   && track_expr_p (MEM_EXPR (*loc)))\n+    {\n+      basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n+      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\n+      mo->type = MO_USE;\n+      mo->u.loc = *loc;\n+      mo->insn = (rtx) insn;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Helper function for finding all uses of REG/MEM in X in insn INSN.  */\n+\n+static void\n+add_uses_1 (rtx *x, void *insn)\n+{\n+  for_each_rtx (x, add_uses, insn);\n+}\n+\n+/* Add stores (register and memory references) LOC which will be tracked\n+   to VTI (bb)->mos. EXPR is the RTL expression containing the store.\n+   INSN is instruction which the LOC is part of.  */\n+\n+static void\n+add_stores (rtx loc, rtx expr, void *insn)\n+{\n+  if (GET_CODE (loc) == REG)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n+      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\n+      mo->type = ((GET_CODE (expr) != CLOBBER && REG_EXPR (loc)\n+\t\t   && track_expr_p (REG_EXPR (loc)))\n+\t\t  ? MO_SET : MO_CLOBBER);\n+      mo->u.loc = loc;\n+      mo->insn = (rtx) insn;\n+    }\n+  else if (GET_CODE (loc) == MEM\n+\t   && MEM_EXPR (loc)\n+\t   && track_expr_p (MEM_EXPR (loc)))\n+    {\n+      basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n+      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\n+      mo->type = GET_CODE (expr) == CLOBBER ? MO_CLOBBER : MO_SET;\n+      mo->u.loc = loc;\n+      mo->insn = (rtx) insn;\n+    }\n+}\n+\n+/* Compute the changes of variable locations in the basic block BB.  */\n+\n+static bool\n+compute_bb_dataflow (basic_block bb)\n+{\n+  int i, n, r;\n+  bool changed;\n+  dataflow_set old_out;\n+  dataflow_set *in = &VTI (bb)->in;\n+  dataflow_set *out = &VTI (bb)->out;\n+\n+  dataflow_set_init (&old_out, htab_elements (VTI (bb)->out.vars) + 3);\n+  dataflow_set_copy (&old_out, out);\n+  dataflow_set_copy (out, in);\n+\n+  n = VTI (bb)->n_mos;\n+  for (i = 0; i < n; i++)\n+    {\n+      switch (VTI (bb)->mos[i].type)\n+\t{\n+\t  case MO_CALL:\n+\t    for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t      if (TEST_HARD_REG_BIT (call_used_reg_set, r))\n+\t\tvar_regno_delete (out, r);\n+\t    break;\n+\n+\t  case MO_USE:\n+\t  case MO_SET:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (GET_CODE (loc) == REG)\n+\t\tvar_reg_delete_and_set (out, loc);\n+\t      else if (GET_CODE (loc) == MEM)\n+\t\tvar_mem_delete_and_set (out, loc);\n+\t    }\n+\t    break;\n+\n+\t  case MO_USE_NO_VAR:\n+\t  case MO_CLOBBER:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (GET_CODE (loc) == REG)\n+\t\tvar_reg_delete (out, loc);\n+\t      else if (GET_CODE (loc) == MEM)\n+\t\tvar_mem_delete (out, loc);\n+\t    }\n+\t    break;\n+\n+\t  case MO_ADJUST:\n+\t    {\n+\t      rtx base;\n+\n+\t      out->stack_adjust += VTI (bb)->mos[i].u.adjust;\n+\t      base = gen_rtx_MEM (Pmode,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\tGEN_INT (out->stack_adjust)));\n+\t      set_frame_base_location (out, base);\n+\t    }\n+\t    break;\n+\t}\n+    }\n+\n+  changed = dataflow_set_different (&old_out, out);\n+  dataflow_set_destroy (&old_out);\n+  return changed;\n+}\n+\n+/* Find the locations of variables in the whole function.  */\n+\n+static void\n+vt_find_locations (void)\n+{\n+  fibheap_t worklist, pending, fibheap_swap;\n+  sbitmap visited, in_worklist, in_pending, sbitmap_swap;\n+  basic_block bb;\n+  edge e;\n+  int *bb_order;\n+  int *rc_order;\n+  int i;\n+\n+  /* Compute reverse completion order of depth first search of the CFG\n+     so that the data-flow runs faster.  */\n+  rc_order = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+  bb_order = (int *) xmalloc (last_basic_block * sizeof (int));\n+  flow_depth_first_order_compute (NULL, rc_order);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    bb_order[rc_order[i]] = i;\n+  free (rc_order);\n+\n+  worklist = fibheap_new ();\n+  pending = fibheap_new ();\n+  visited = sbitmap_alloc (last_basic_block);\n+  in_worklist = sbitmap_alloc (last_basic_block);\n+  in_pending = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (in_worklist);\n+  sbitmap_zero (in_pending);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      fibheap_insert (pending, bb_order[bb->index], bb);\n+      SET_BIT (in_pending, bb->index);\n+    }\n+\n+  while (!fibheap_empty (pending))\n+    {\n+      fibheap_swap = pending;\n+      pending = worklist;\n+      worklist = fibheap_swap;\n+      sbitmap_swap = in_pending;\n+      in_pending = in_worklist;\n+      in_worklist = sbitmap_swap;\n+\n+      sbitmap_zero (visited);\n+\n+      while (!fibheap_empty (worklist))\n+\t{\n+\t  bb = fibheap_extract_min (worklist);\n+\t  RESET_BIT (in_worklist, bb->index);\n+\t  if (!TEST_BIT (visited, bb->index))\n+\t    {\n+\t      bool changed;\n+\n+\t      SET_BIT (visited, bb->index);\n+\n+\t      /* Calculate the IN set as union of predecessor OUT sets.  */\n+\t      dataflow_set_clear (&VTI (bb)->in);\n+\t      for (e = bb->pred; e; e = e->pred_next)\n+\t\t{\n+\t\t  dataflow_set_union (&VTI (bb)->in, &VTI (e->src)->out);\n+\t\t}\n+\n+\t      changed = compute_bb_dataflow (bb);\n+\t      if (changed)\n+\t\t{\n+\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t    {\n+\t\t      if (e->dest == EXIT_BLOCK_PTR)\n+\t\t\tcontinue;\n+\n+\t\t      if (e->dest == bb)\n+\t\t\tcontinue;\n+\n+\t\t      if (TEST_BIT (visited, e->dest->index))\n+\t\t\t{\n+\t\t\t  if (!TEST_BIT (in_pending, e->dest->index))\n+\t\t\t    {\n+\t\t\t      /* Send E->DEST to next round.  */\n+\t\t\t      SET_BIT (in_pending, e->dest->index);\n+\t\t\t      fibheap_insert (pending,\n+\t\t\t\t\t      bb_order[e->dest->index],\n+\t\t\t\t\t      e->dest);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else if (!TEST_BIT (in_worklist, e->dest->index))\n+\t\t\t{\n+\t\t\t  /* Add E->DEST to current round.  */\n+\t\t\t  SET_BIT (in_worklist, e->dest->index);\n+\t\t\t  fibheap_insert (worklist, bb_order[e->dest->index],\n+\t\t\t\t\t  e->dest);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  free (bb_order);\n+  fibheap_delete (worklist);\n+  fibheap_delete (pending);\n+  sbitmap_free (visited);\n+  sbitmap_free (in_worklist);\n+  sbitmap_free (in_pending);\n+}\n+\n+/* Print the content of the LIST to dump file.  */\n+\n+static void\n+dump_attrs_list (attrs list)\n+{\n+  for (; list; list = list->next)\n+    {\n+      print_mem_expr (rtl_dump_file, list->decl);\n+      fprintf (rtl_dump_file, \"+\");\n+      fprintf (rtl_dump_file, HOST_WIDE_INT_PRINT_DEC, list->offset);\n+    }\n+  fprintf (rtl_dump_file, \"\\n\");\n+}\n+\n+/* Print the information about variable *SLOT to dump file.  */\n+\n+static int\n+dump_variable (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  variable var = *(variable *) slot;\n+  int i;\n+  location_chain node;\n+\n+  fprintf (rtl_dump_file, \"  name: %s\\n\",\n+\t   IDENTIFIER_POINTER (DECL_NAME (var->decl)));\n+  for (i = 0; i < var->n_var_parts; i++)\n+    {\n+      fprintf (rtl_dump_file, \"    offset %ld\\n\",\n+\t       (long) var->var_part[i].offset);\n+      for (node = var->var_part[i].loc_chain; node; node = node->next)\n+\t{\n+\t  fprintf (rtl_dump_file, \"      \");\n+\t  print_rtl_single (rtl_dump_file, node->loc);\n+\t}\n+    }\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Print the information about variables from hash table VARS to dump file.  */\n+\n+static void\n+dump_vars (htab_t vars)\n+{\n+  if (htab_elements (vars) > 0)\n+    {\n+      fprintf (rtl_dump_file, \"Variables:\\n\");\n+      htab_traverse (vars, dump_variable, NULL);\n+    }\n+}\n+\n+/* Print the dataflow set SET to dump file.  */\n+\n+static void\n+dump_dataflow_set (dataflow_set *set)\n+{\n+  int i;\n+\n+  fprintf (rtl_dump_file, \"Stack adjustment: \");\n+  fprintf (rtl_dump_file, HOST_WIDE_INT_PRINT_DEC, set->stack_adjust);\n+  fprintf (rtl_dump_file, \"\\n\");\n+  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (set->regs[i])\n+\t{\n+\t  fprintf (rtl_dump_file, \"Reg %d:\", i);\n+\t  dump_attrs_list (set->regs[i]);\n+\t}\n+    }\n+  dump_vars (set->vars);\n+  fprintf (rtl_dump_file, \"\\n\");\n+}\n+\n+/* Print the IN and OUT sets for each basic block to dump file.  */\n+\n+static void\n+dump_dataflow_sets (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      fprintf (rtl_dump_file, \"\\nBasic block %d:\\n\", bb->index);\n+      fprintf (rtl_dump_file, \"IN:\\n\");\n+      dump_dataflow_set (&VTI (bb)->in);\n+      fprintf (rtl_dump_file, \"OUT:\\n\");\n+      dump_dataflow_set (&VTI (bb)->out);\n+    }\n+}\n+\n+/* Add variable VAR to the hash table of changed variables and\n+   if it has no locations delete it from hash table HTAB.  */\n+\n+static void\n+variable_was_changed (variable var, htab_t htab)\n+{\n+  hashval_t hash = VARIABLE_HASH_VAL (var->decl);\n+\n+  if (emit_notes)\n+    {\n+      variable *slot;\n+\n+      slot = (variable *) htab_find_slot_with_hash (changed_variables,\n+\t\t\t\t\t\t    var->decl, hash, INSERT);\n+\n+      if (htab && var->n_var_parts == 0)\n+\t{\n+\t  variable empty_var;\n+\t  void **old;\n+\n+\t  empty_var = pool_alloc (var_pool);\n+\t  empty_var->decl = var->decl;\n+\t  empty_var->n_var_parts = 0;\n+\t  *slot = empty_var;\n+\n+\t  old = htab_find_slot_with_hash (htab, var->decl, hash,\n+\t\t\t\t\t  NO_INSERT);\n+\t  if (old)\n+\t    htab_clear_slot (htab, old);\n+\t}\n+      else\n+\t{\n+\t  *slot = var;\n+\t}\n+    }\n+  else\n+    {\n+#ifdef ENABLE_CHECKING\n+      if (!htab)\n+\tabort ();\n+#endif\n+      if (var->n_var_parts == 0)\n+\t{\n+\t  void **slot = htab_find_slot_with_hash (htab, var->decl, hash,\n+\t\t\t\t\t\t  NO_INSERT);\n+\t  if (slot)\n+\t    htab_clear_slot (htab, slot);\n+\t}\n+    }\n+}\n+\n+/* Set the location of frame_base_decl to LOC in dataflow set SET.  This\n+   function expects that\n+   frame_base_decl has already one location for offset 0 in the variable table.\n+ */\n+\n+static void\n+set_frame_base_location (dataflow_set *set, rtx loc)\n+{\n+  variable var;\n+  \n+  var = htab_find_with_hash (set->vars, frame_base_decl,\n+\t\t\t     VARIABLE_HASH_VAL (frame_base_decl));\n+#ifdef ENABLE_CHECKING\n+  if (!var)\n+    abort ();\n+  if (var->n_var_parts != 1)\n+    abort ();\n+  if (var->var_part[0].offset != 0)\n+    abort ();\n+  if (!var->var_part[0].loc_chain)\n+    abort ();\n+#endif\n+\n+  var->var_part[0].loc_chain->loc = loc;\n+  variable_was_changed (var, set->vars);\n+}\n+\n+/* Set the part of variable's location in the dataflow set SET.  The variable\n+   part is specified by variable's declaration DECL and offset OFFSET and the\n+   part's location by LOC.  */\n+\n+static void\n+set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n+{\n+  int pos, low, high;\n+  location_chain node, prev, next;\n+  variable var;\n+  void **slot;\n+  \n+  slot = htab_find_slot_with_hash (set->vars, decl,\n+\t\t\t\t   VARIABLE_HASH_VAL (decl), INSERT);\n+  if (!*slot)\n+    {\n+      /* Create new variable information.  */\n+      var = pool_alloc (var_pool);\n+      var->decl = decl;\n+      var->n_var_parts = 1;\n+      var->var_part[0].offset = offset;\n+      var->var_part[0].loc_chain = NULL;\n+      var->var_part[0].cur_loc = NULL;\n+      *slot = var;\n+      pos = 0;\n+    }\n+  else\n+    {\n+      var = (variable) *slot;\n+\n+      /* Find the location part.  */\n+      low = 0;\n+      high = var->n_var_parts;\n+      while (low != high)\n+\t{\n+\t  pos = (low + high) / 2;\n+\t  if (var->var_part[pos].offset < offset)\n+\t    low = pos + 1;\n+\t  else\n+\t    high = pos;\n+\t}\n+      pos = low;\n+\n+      if (pos == var->n_var_parts || var->var_part[pos].offset != offset)\n+\t{\n+\t  /* We have not find the location part, new one will be created.  */\n+\n+#ifdef ENABLE_CHECKING\n+\t  /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n+\t     thus there are at most MAX_VAR_PARTS different offsets.  */\n+\t  if (var->n_var_parts >= MAX_VAR_PARTS)\n+\t    abort ();\n+#endif\n+\n+\t  /* We have to move the elements of array starting at index low to the\n+\t     next position.  */\n+\t  for (high = var->n_var_parts; high > low; high--)\n+\t    var->var_part[high] = var->var_part[high - 1];\n+\n+\t  var->n_var_parts++;\n+\t  var->var_part[pos].offset = offset;\n+\t  var->var_part[pos].loc_chain = NULL;\n+\t  var->var_part[pos].cur_loc = NULL;\n+\t}\n+    }\n+\n+  /* Delete the location from list.  */\n+  prev = NULL;\n+  for (node = var->var_part[pos].loc_chain; node; node = next)\n+    {\n+      next = node->next;\n+      if ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+\t   && REGNO (node->loc) == REGNO (loc))\n+\t  || rtx_equal_p (node->loc, loc))\n+\t{\n+\t  if (prev)\n+\t    prev->next = next;\n+\t  else\n+\t    var->var_part[pos].loc_chain = next;\n+\t  pool_free (loc_chain_pool, node);\n+\t  break;\n+\t}\n+      else\n+\tprev = node;\n+    }\n+\n+  /* Add the location to the beginning.  */\n+  node = pool_alloc (loc_chain_pool);\n+  node->loc = loc;\n+  node->next = var->var_part[pos].loc_chain;\n+  var->var_part[pos].loc_chain = node;\n+\n+  /* If no location was emitted do so.  */\n+  if (var->var_part[pos].cur_loc == NULL)\n+    {\n+      var->var_part[pos].cur_loc = loc;\n+      variable_was_changed (var, set->vars);\n+    }\n+}\n+\n+/* Delete the part of variable's location from dataflow set SET.  The variable\n+   part is specified by variable's declaration DECL and offset OFFSET and the\n+   part's location by LOC.  */\n+\n+static void\n+delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n+\t\t      HOST_WIDE_INT offset)\n+{\n+  int pos, low, high;\n+  void **slot;\n+    \n+  slot = htab_find_slot_with_hash (set->vars, decl, VARIABLE_HASH_VAL (decl),\n+\t\t\t\t   NO_INSERT);\n+  if (slot)\n+    {\n+      variable var = (variable) *slot;\n+\n+      /* Find the location part.  */\n+      low = 0;\n+      high = var->n_var_parts;\n+      while (low != high)\n+\t{\n+\t  pos = (low + high) / 2;\n+\t  if (var->var_part[pos].offset < offset)\n+\t    low = pos + 1;\n+\t  else\n+\t    high = pos;\n+\t}\n+      pos = low;\n+\n+      if (pos < var->n_var_parts && var->var_part[pos].offset == offset)\n+\t{\n+\t  location_chain node, prev, next;\n+\t  bool changed;\n+\n+\t  /* Delete the location part.  */\n+\t  prev = NULL;\n+\t  for (node = var->var_part[pos].loc_chain; node; node = next)\n+\t    {\n+\t      next = node->next;\n+\t      if ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+\t\t   && REGNO (node->loc) == REGNO (loc))\n+\t\t  || rtx_equal_p (node->loc, loc))\n+\t\t{\n+\t\t  if (prev)\n+\t\t    prev->next = next;\n+\t\t  else\n+\t\t    var->var_part[pos].loc_chain = next;\n+\t\t  pool_free (loc_chain_pool, node);\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\tprev = node;\n+\t    }\n+\n+\t  /* If we have deleted the location which was last emitted\n+\t     we have to emit new location so add the variable to set\n+\t     of changed variables.  */\n+\t  if (var->var_part[pos].cur_loc\n+\t      && ((GET_CODE (loc) == REG\n+\t\t   && GET_CODE (var->var_part[pos].cur_loc) == REG\n+\t\t   && REGNO (loc) == REGNO (var->var_part[pos].cur_loc))\n+\t\t  || rtx_equal_p (loc, var->var_part[pos].cur_loc)))\n+\t    {\n+\t      changed = true;\n+\t      if (var->var_part[pos].loc_chain)\n+\t\tvar->var_part[pos].cur_loc = var->var_part[pos].loc_chain->loc;\n+\t    }\n+\t  else\n+\t    changed = false;\n+\n+\t  if (var->var_part[pos].loc_chain == NULL)\n+\t    {\n+\t      var->n_var_parts--;\n+\t      while (pos < var->n_var_parts)\n+\t\t{\n+\t\t  var->var_part[pos] = var->var_part[pos + 1];\n+\t\t  pos++;\n+\t\t}\n+\t    }\n+\t  if (changed)\n+\t      variable_was_changed (var, set->vars);\n+\t}\n+    }\n+}\n+\n+/* Emit the NOTE_INSN_VAR_LOCATION for variable *VARP.  DATA contains\n+   additional parameters: WHERE specifies whether the note shall be emitted\n+   before of after instruction INSN.  */\n+\n+static int\n+emit_note_insn_var_location (void **varp, void *data)\n+{\n+  variable var = *(variable *) varp;\n+  rtx insn = ((emit_note_data *)data)->insn;\n+  enum emit_note_where where = ((emit_note_data *)data)->where;\n+  rtx note;\n+  int i;\n+  bool complete;\n+  HOST_WIDE_INT last_limit;\n+  tree type_size_unit;\n+\n+#ifdef ENABLE_CHECKING\n+  if (!var->decl)\n+    abort ();\n+#endif\n+\n+  complete = true;\n+  last_limit = 0;\n+  for (i = 0; i < var->n_var_parts; i++)\n+    {\n+      if (last_limit < var->var_part[i].offset)\n+\t{\n+\t  complete = false;\n+\t  break;\n+\t}\n+      last_limit\n+\t= (var->var_part[i].offset\n+\t   + GET_MODE_SIZE (GET_MODE (var->var_part[i].loc_chain->loc)));\n+    }\n+  type_size_unit = TYPE_SIZE_UNIT (TREE_TYPE (var->decl));\n+  if ((unsigned HOST_WIDE_INT) last_limit < TREE_INT_CST_LOW (type_size_unit))\n+    complete = false;\n+\n+  if (where == EMIT_NOTE_AFTER_INSN)\n+    note = emit_note_after (NOTE_INSN_VAR_LOCATION, insn);\n+  else\n+    note = emit_note_before (NOTE_INSN_VAR_LOCATION, insn);\n+\n+  if (!complete)\n+    {\n+      NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n+\t\t\t\t\t\t       NULL_RTX);\n+    }\n+  else if (var->n_var_parts == 1)\n+    {\n+      rtx expr_list\n+\t= gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t     var->var_part[0].loc_chain->loc,\n+\t\t\t     GEN_INT (var->var_part[0].offset));\n+\n+      NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n+\t\t\t\t\t\t       expr_list);\n+    }\n+  else if (var->n_var_parts)\n+    {\n+      rtx argp[MAX_VAR_PARTS];\n+      rtx parallel;\n+\n+      for (i = 0; i < var->n_var_parts; i++)\n+\targp[i] = gen_rtx_EXPR_LIST (VOIDmode, var->var_part[i].loc_chain->loc,\n+\t\t\t\t     GEN_INT (var->var_part[i].offset));\n+      parallel = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t   gen_rtvec_v (var->n_var_parts, argp));\n+      NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n+\t\t\t\t\t\t       parallel);\n+    }\n+\n+  htab_clear_slot (changed_variables, varp);\n+\n+  /* When there are no location parts the variable has been already\n+     removed from hash table and a new empty variable was created.\n+     Free the empty variable.  */\n+  if (var->n_var_parts == 0)\n+    {\n+      pool_free (var_pool, var);\n+    }\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Emit NOTE_INSN_VAR_LOCATION note for each variable from a chain\n+   CHANGED_VARIABLES and delete this chain.  WHERE specifies whether the notes\n+   shall be emitted before of after instruction INSN.  */\n+\n+static void\n+emit_notes_for_changes (rtx insn, enum emit_note_where where)\n+{\n+  emit_note_data data;\n+\n+  data.insn = insn;\n+  data.where = where;\n+  htab_traverse (changed_variables, emit_note_insn_var_location, &data);\n+}\n+\n+/* Add variable *SLOT to the chain CHANGED_VARIABLES if it differs from the\n+   same variable in hash table DATA or is not there at all.  */\n+\n+static int\n+emit_notes_for_differences_1 (void **slot, void *data)\n+{\n+  htab_t new_vars = (htab_t) data;\n+  variable old_var, new_var;\n+\n+  old_var = *(variable *) slot;\n+  new_var = (variable) htab_find_with_hash (new_vars, old_var->decl,\n+\t\t\t\t\t    VARIABLE_HASH_VAL (old_var->decl));\n+\n+  if (!new_var)\n+    {\n+      /* Variable has disappeared.  */\n+      variable empty_var;\n+\n+      empty_var = pool_alloc (var_pool);\n+      empty_var->decl = old_var->decl;\n+      empty_var->n_var_parts = 0;\n+      variable_was_changed (empty_var, NULL);\n+    }\n+  else if (variable_different_p (old_var, new_var))\n+    {\n+      variable_was_changed (new_var, NULL);\n+    }\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Add variable *SLOT to the chain CHANGED_VARIABLES if it is not in hash\n+   table DATA.  */\n+\n+static int\n+emit_notes_for_differences_2 (void **slot, void *data)\n+{\n+  htab_t old_vars = (htab_t) data;\n+  variable old_var, new_var;\n+\n+  new_var = *(variable *) slot;\n+  old_var = (variable) htab_find_with_hash (old_vars, new_var->decl,\n+\t\t\t\t\t    VARIABLE_HASH_VAL (new_var->decl));\n+  if (!old_var)\n+    {\n+      /* Variable has appeared.  */\n+      variable_was_changed (new_var, NULL);\n+    }\n+\n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Emit notes before INSN for differences between dataflow sets OLD_SET and\n+   NEW_SET.  */\n+\n+static void\n+emit_notes_for_differences (rtx insn, dataflow_set *old_set,\n+\t\t\t    dataflow_set *new_set)\n+{\n+  htab_traverse (old_set->vars, emit_notes_for_differences_1, new_set->vars);\n+  htab_traverse (new_set->vars, emit_notes_for_differences_2, old_set->vars);\n+  emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+}\n+\n+/* Emit the notes for changes of location parts in the basic block BB.  */\n+\n+static void\n+emit_notes_in_bb (basic_block bb)\n+{\n+  int i;\n+  dataflow_set set;\n+\n+  dataflow_set_init (&set, htab_elements (VTI (bb)->in.vars) + 3);\n+  dataflow_set_copy (&set, &VTI (bb)->in);\n+\n+  for (i = 0; i < VTI (bb)->n_mos; i++)\n+    {\n+      rtx insn = VTI (bb)->mos[i].insn;\n+\n+      switch (VTI (bb)->mos[i].type)\n+\t{\n+\t  case MO_CALL:\n+\t    {\n+\t      int r;\n+\n+\t      for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t\tif (TEST_HARD_REG_BIT (call_used_reg_set, r))\n+\t\t  {\n+\t\t    var_regno_delete (&set, r);\n+\t\t  }\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t    }\n+\t    break;\n+\n+\t  case MO_USE:\n+\t  case MO_SET:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (GET_CODE (loc) == REG)\n+\t\tvar_reg_delete_and_set (&set, loc);\n+\t      else\n+\t\tvar_mem_delete_and_set (&set, loc);\n+\n+\t      if (VTI (bb)->mos[i].type == MO_USE)\n+\t\temit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+\t      else\n+\t\temit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t    }\n+\t    break;\n+\n+\t  case MO_USE_NO_VAR:\n+\t  case MO_CLOBBER:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (GET_CODE (loc) == REG)\n+\t\tvar_reg_delete (&set, loc);\n+\t      else\n+\t\tvar_mem_delete (&set, loc);\n+\n+\t      if (VTI (bb)->mos[i].type == MO_USE_NO_VAR)\n+\t\temit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+\t      else\n+\t\temit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t    }\n+\t    break;\n+\n+\t  case MO_ADJUST:\n+\t    {\n+\t      rtx base;\n+\n+\t      set.stack_adjust += VTI (bb)->mos[i].u.adjust;\n+\t      base = gen_rtx_MEM (Pmode,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\tGEN_INT (set.stack_adjust)));\n+\t      set_frame_base_location (&set, base);\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t    }\n+\t    break;\n+\t}\n+    }\n+  dataflow_set_destroy (&set);\n+}\n+\n+/* Emit notes for the whole function.  */\n+\n+static void\n+vt_emit_notes (void)\n+{\n+  basic_block bb;\n+  dataflow_set *last_out;\n+  dataflow_set empty;\n+\n+#ifdef ENABLE_CHECKING\n+  if (htab_elements (changed_variables))\n+    abort ();\n+#endif\n+\n+  /* Enable emitting notes by functions (mainly by set_variable_part and\n+     delete_variable_part).  */\n+  emit_notes = true;\n+\n+  dataflow_set_init (&empty, 7);\n+  last_out = &empty;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      /* Emit the notes for changes of variable locations between two\n+\t subsequent basic blocks.  */\n+      emit_notes_for_differences (BB_HEAD (bb), last_out, &VTI (bb)->in);\n+\n+      /* Emit the notes for the changes in the basic block itself.  */\n+      emit_notes_in_bb (bb);\n+\n+      last_out = &VTI (bb)->out;\n+    }\n+  dataflow_set_destroy (&empty);\n+  emit_notes = false;\n+}\n+\n+/* If there is a declaration and offset associated with register/memory RTL\n+   assign declaration to *DECLP and offset to *OFFSETP, and return true.  */\n+\n+static bool\n+vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n+{\n+  if (GET_CODE (rtl) == REG)\n+    {\n+      if (REG_ATTRS (rtl))\n+\t{\n+\t  *declp = REG_EXPR (rtl);\n+\t  *offsetp = REG_OFFSET (rtl);\n+\t  return true;\n+\t}\n+    }\n+  else if (GET_CODE (rtl) == MEM)\n+    {\n+      if (MEM_ATTRS (rtl))\n+\t{\n+\t  *declp = MEM_EXPR (rtl);\n+\t  *offsetp = MEM_OFFSET (rtl) ? INTVAL (MEM_OFFSET (rtl)) : 0;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Insert function parameters to IN and OUT sets of ENTRY_BLOCK.  */\n+\n+static void\n+vt_add_function_parameters (void)\n+{\n+  tree parm;\n+  HOST_WIDE_INT stack_adjust = 0;\n+  \n+  if (!frame_pointer_needed)\n+    stack_adjust = prologue_stack_adjust ();\n+\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm; parm = TREE_CHAIN (parm))\n+    {\n+      rtx decl_rtl = DECL_RTL_IF_SET (parm);\n+      rtx incoming = DECL_INCOMING_RTL (parm);\n+      tree decl;\n+      HOST_WIDE_INT offset;\n+      dataflow_set *in, *out;\n+\n+      if (TREE_CODE (parm) != PARM_DECL)\n+\tcontinue;\n+\n+      if (!DECL_NAME (parm))\n+\tcontinue;\n+\n+      if (!decl_rtl || !incoming)\n+\tcontinue;\n+\n+      if (GET_MODE (decl_rtl) == BLKmode || GET_MODE (incoming) == BLKmode)\n+\tcontinue;\n+\n+      if (!vt_get_decl_and_offset (incoming, &decl, &offset))\n+\tif (!vt_get_decl_and_offset (decl_rtl, &decl, &offset))\n+\t  continue;\n+\n+      if (!decl)\n+\tcontinue;\n+\n+      if (parm != decl)\n+\tabort ();\n+\n+      incoming = eliminate_regs (incoming, 0, NULL_RTX);\n+      if (!frame_pointer_needed && GET_CODE (incoming) == MEM)\n+\tincoming = adjust_stack_reference (incoming, -stack_adjust);\n+      in = &VTI (ENTRY_BLOCK_PTR)->in;\n+      out = &VTI (ENTRY_BLOCK_PTR)->out;\n+\n+      if (GET_CODE (incoming) == REG)\n+\t{\n+\t  if (REGNO (incoming) >= FIRST_PSEUDO_REGISTER)\n+\t    abort ();\n+\t  attrs_list_insert (&in->regs[REGNO (incoming)],\n+\t\t\t     parm, offset, incoming);\n+\t  attrs_list_insert (&out->regs[REGNO (incoming)],\n+\t\t\t     parm, offset, incoming);\n+\t  set_variable_part (in, incoming, parm, offset);\n+\t  set_variable_part (out, incoming, parm, offset);\n+\t}\n+      else if (GET_CODE (incoming) == MEM)\n+\t{\n+\t  set_variable_part (in, incoming, parm, offset);\n+\t  set_variable_part (out, incoming, parm, offset);\n+\t}\n+    }\n+}\n+\n+/* Allocate and initialize the data structures for variable tracking\n+   and parse the RTL to get the micro operations.  */\n+\n+static void\n+vt_initialize (void)\n+{\n+  basic_block bb;\n+\n+  alloc_aux_for_blocks (sizeof (struct variable_tracking_info_def));\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn;\n+      HOST_WIDE_INT pre, post;\n+\n+      /* Count the number of micro operations.  */\n+      VTI (bb)->n_mos = 0;\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      if (!frame_pointer_needed)\n+\t\t{\n+\t\t  insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n+\t\t  if (pre)\n+\t\t    VTI (bb)->n_mos++;\n+\t\t  if (post)\n+\t\t    VTI (bb)->n_mos++;\n+\t\t}\n+\t      note_uses (&PATTERN (insn), count_uses_1, insn);\n+\t      note_stores (PATTERN (insn), count_stores, insn);\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\tVTI (bb)->n_mos++;\n+\t    }\n+\t}\n+\n+      /* Add the nicro-operations to the array.  */\n+      VTI (bb)->mos = xmalloc (VTI (bb)->n_mos\n+\t\t\t       * sizeof (struct micro_operation_def));\n+      VTI (bb)->n_mos = 0;\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      int n1, n2;\n+\n+\t      if (!frame_pointer_needed)\n+\t\t{\n+\t\t  insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n+\t\t  if (pre)\n+\t\t    {\n+\t\t      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\n+\t\t      mo->type = MO_ADJUST;\n+\t\t      mo->u.adjust = pre;\n+\t\t      mo->insn = insn;\n+\t\t    }\n+\t\t}\n+\n+\t      n1 = VTI (bb)->n_mos;\n+\t      note_uses (&PATTERN (insn), add_uses_1, insn);\n+\t      n2 = VTI (bb)->n_mos - 1;\n+\n+\t      /* Order the MO_USEs to be before MO_USE_NO_VARs.  */\n+\t      while (n1 < n2)\n+\t\t{\n+\t\t  while (n1 < n2 && VTI (bb)->mos[n1].type == MO_USE)\n+\t\t    n1++;\n+\t\t  while (n1 < n2 && VTI (bb)->mos[n2].type == MO_USE_NO_VAR)\n+\t\t    n2--;\n+\t\t  if (n1 < n2)\n+\t\t    {\n+\t\t      micro_operation sw;\n+\n+\t\t      sw = VTI (bb)->mos[n1];\n+\t\t      VTI (bb)->mos[n1] = VTI (bb)->mos[n2];\n+\t\t      VTI (bb)->mos[n2] = sw;\n+\t\t    }\n+\t\t}\n+\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\t{\n+\t\t  micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\n+\t\t  mo->type = MO_CALL;\n+\t\t  mo->insn = insn;\n+\t\t}\n+\n+\t      n1 = VTI (bb)->n_mos;\n+\t      note_stores (PATTERN (insn), add_stores, insn);\n+\t      n2 = VTI (bb)->n_mos - 1;\n+\n+\t      /* Order the MO_SETs to be before MO_CLOBBERs.  */\n+\t      while (n1 < n2)\n+\t\t{\n+\t\t  while (n1 < n2 && VTI (bb)->mos[n1].type == MO_SET)\n+\t\t    n1++;\n+\t\t  while (n1 < n2 && VTI (bb)->mos[n2].type == MO_CLOBBER)\n+\t\t    n2--;\n+\t\t  if (n1 < n2)\n+\t\t    {\n+\t\t      micro_operation sw;\n+\n+\t\t      sw = VTI (bb)->mos[n1];\n+\t\t      VTI (bb)->mos[n1] = VTI (bb)->mos[n2];\n+\t\t      VTI (bb)->mos[n2] = sw;\n+\t\t    }\n+\t\t}\n+\n+\t      if (!frame_pointer_needed && post)\n+\t\t{\n+\t\t  micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\n+\t\t  mo->type = MO_ADJUST;\n+\t\t  mo->u.adjust = post;\n+\t\t  mo->insn = insn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Init the IN and OUT sets.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      VTI (bb)->visited = false;\n+      dataflow_set_init (&VTI (bb)->in, 7);\n+      dataflow_set_init (&VTI (bb)->out, 7);\n+    }\n+\n+  attrs_pool = create_alloc_pool (\"attrs_def pool\",\n+\t\t\t\t  sizeof (struct attrs_def), 1024);\n+  var_pool = create_alloc_pool (\"variable_def pool\",\n+\t\t\t\tsizeof (struct variable_def), 64);\n+  loc_chain_pool = create_alloc_pool (\"location_chain_def pool\",\n+\t\t\t\t      sizeof (struct location_chain_def),\n+\t\t\t\t      1024);\n+  changed_variables = htab_create (10, variable_htab_hash, variable_htab_eq,\n+\t\t\t\t   NULL);\n+  vt_add_function_parameters ();\n+\n+  if (!frame_pointer_needed)\n+    {\n+      rtx base;\n+\n+      /* Create fake variable for tracking stack pointer changes.  */\n+      frame_base_decl = make_node (VAR_DECL);\n+      DECL_NAME (frame_base_decl) = get_identifier (\"___frame_base_decl\");\n+      TREE_TYPE (frame_base_decl) = char_type_node;\n+      DECL_ARTIFICIAL (frame_base_decl) = 1;\n+\n+      /* Set its initial \"location\".  */\n+      base = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n+      set_variable_part (&VTI (ENTRY_BLOCK_PTR)->in, base, frame_base_decl, 0);\n+      set_variable_part (&VTI (ENTRY_BLOCK_PTR)->out, base, frame_base_decl, 0);\n+    }\n+  else\n+    {\n+      frame_base_decl = NULL;\n+    }\n+}\n+\n+/* Free the data structures needed for variable tracking.  */\n+\n+static void\n+vt_finalize (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      free (VTI (bb)->mos);\n+    }\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      dataflow_set_destroy (&VTI (bb)->in);\n+      dataflow_set_destroy (&VTI (bb)->out);\n+    }\n+  free_aux_for_blocks ();\n+  free_alloc_pool (attrs_pool);\n+  free_alloc_pool (var_pool);\n+  free_alloc_pool (loc_chain_pool);\n+  htab_delete (changed_variables);\n+}\n+\n+/* The entry point to variable tracking pass.  */\n+\n+void\n+variable_tracking_main (void)\n+{\n+  if (n_basic_blocks > 500 && n_edges / n_basic_blocks >= 20)\n+    return;\n+\n+  mark_dfs_back_edges ();\n+  vt_initialize ();\n+  if (!frame_pointer_needed)\n+    {\n+      if (!vt_stack_adjustments ())\n+\t{\n+\t  vt_finalize ();\n+\t  return;\n+\t}\n+    }\n+\n+  vt_find_locations ();\n+  vt_emit_notes ();\n+\n+  if (rtl_dump_file)\n+    {\n+      dump_dataflow_sets ();\n+      dump_flow_info (rtl_dump_file);\n+    }\n+\n+  vt_finalize ();\n+}"}, {"sha": "5c5634de3444c95ac13fba0776df553023672867", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014a1138d6ff79eff9aea704d5e8ae3f58fef5d1/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=014a1138d6ff79eff9aea704d5e8ae3f58fef5d1", "patch": "@@ -190,7 +190,8 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    debug_nothing_tree,\t\t  /* deferred_inline_function */\n    vmsdbgout_abstract_function,\n    debug_nothing_rtx,\t\t  /* label */\n-   debug_nothing_int\t\t  /* handle_pch */\n+   debug_nothing_int,\t\t  /* handle_pch */\n+   debug_nothing_rtx\t\t  /* var_location */\n };\n \n /* Definitions of defaults for assembler-dependent names of various"}]}