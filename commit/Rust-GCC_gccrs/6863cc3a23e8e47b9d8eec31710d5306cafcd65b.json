{"sha": "6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "node_id": "C_kwDOANBUbNoAKDY4NjNjYzNhMjNlOGU0N2I5ZDhlZWMzMTcxMGQ1MzA2Y2FmY2Q2NWI", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:29:21Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:29:21Z"}, "message": "Merge commit '02c031088ac0bbf716aec52e027d615b7a5a572b^' into HEAD", "tree": {"sha": "44547a7079b1186fef211faf538467e923212ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44547a7079b1186fef211faf538467e923212ba4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d39b61800112febb6de6ec8a44f116e48a63baa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d39b61800112febb6de6ec8a44f116e48a63baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d39b61800112febb6de6ec8a44f116e48a63baa"}, {"sha": "1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1060cd2ad00b5174f4f8ef8ca3d8c283e321ffca"}], "stats": {"total": 19704, "additions": 19143, "deletions": 561}, "files": [{"sha": "f70333f344452fd0ab5a74721bc8bc3dabc51b47", "filename": "contrib/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,34 @@\n+2022-12-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/git_commit.py: Support digits in PR's\n+\tcomponent in subject.\n+\n+2022-12-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/test_email.py: Add new test.\n+\t* gcc-changelog/test_patches.txt: Add new patch.\n+\n+2022-12-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/git_commit.py: Allow digit in component name.\n+\n+2022-12-19  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* gcc-changelog/git_check_commit.py (__main__): With -v print a\n+\twarning for the auto-added files.\n+\t* gcc-changelog/git_commit.py (GitCommit.__init__): Add self.warnings.\n+\t(GitCommit.check_mentioned_files): Add warning for auto-added files.\n+\t(GitCommit.print_warnings): New function.\n+\t* gcc-changelog/git_email.py (__main__): Remove bogus argument to\n+\tGitEmail constructor; print auto-added-files warning.\n+\t* gcc-changelog/test_email.py (test_auto_add_file_1,\n+\ttest_auto_add_file_2): New tests.\n+\t* gcc-changelog/test_patches.txt: Add two test cases.\n+\n+2022-12-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/setup.cfg: Do not use flake8 pytest plug-in.\n+\n 2022-12-16  Martin Liska  <mliska@suse.cz>\n \n \t* filter-clang-warnings.py: Print each warning only one time."}, {"sha": "2b9f2381f2097d26e488b94bf6004cf66fae8872", "filename": "contrib/gcc-changelog/git_check_commit.py", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fgit_check_commit.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fgit_check_commit.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_check_commit.py?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -42,7 +42,13 @@\n     if git_commit.success:\n         if args.print_changelog:\n             git_commit.print_output()\n+        if args.verbose and git_commit.warnings:\n+            for warning in git_commit.warnings:\n+                print('WARN: %s' % warning)\n     else:\n+        if args.verbose and git_commit.warnings:\n+            for warning in git_commit.warnings:\n+                print('WARN: %s' % warning)\n         for error in git_commit.errors:\n             print('ERR: %s' % error)\n             if args.verbose and error.details:"}, {"sha": "b73e587eb98017fdb70eb9c3438e00839efcec0a", "filename": "contrib/gcc-changelog/git_commit.py", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fgit_commit.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fgit_commit.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_commit.py?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -22,6 +22,7 @@\n import os\n import re\n import sys\n+from collections import defaultdict\n \n default_changelog_locations = {\n     'c++tools',\n@@ -162,9 +163,9 @@\n         re.compile(r'^(?P<datetime>\\d{4}-\\d{2}-\\d{2})\\ {2}(?P<name>.*  <.*>)')\n additional_author_regex = re.compile(r'^\\t(?P<spaces>\\ *)?(?P<name>.*  <.*>)')\n changelog_regex = re.compile(r'^(?:[fF]or +)?([a-z0-9+-/]*)ChangeLog:?')\n-subject_pr_regex = re.compile(r'(^|\\W)PR\\s+(?P<component>[a-zA-Z+-]+)/(?P<pr>\\d{4,7})')\n+subject_pr_regex = re.compile(r'(^|\\W)PR\\s+(?P<component>[a-zA-Z0-9+-]+)/(?P<pr>\\d{4,7})')\n subject_pr2_regex = re.compile(r'[(\\[]PR\\s*(?P<pr>\\d{4,7})[)\\]]')\n-pr_regex = re.compile(r'\\tPR (?P<component>[a-z+-]+\\/)?(?P<pr>[0-9]+)$')\n+pr_regex = re.compile(r'\\tPR (?P<component>[a-z0-9+-]+\\/)?(?P<pr>[0-9]+)$')\n dr_regex = re.compile(r'\\tDR ([0-9]+)$')\n star_prefix_regex = re.compile(r'\\t\\*(?P<spaces>\\ *)(?P<content>.*)')\n end_of_location_regex = re.compile(r'[\\[<(:]')\n@@ -304,6 +305,7 @@ def __init__(self, info, commit_to_info_hook=None, ref_name=None):\n         self.changes = None\n         self.changelog_entries = []\n         self.errors = []\n+        self.warnings = []\n         self.top_level_authors = []\n         self.co_authors = []\n         self.top_level_prs = []\n@@ -706,6 +708,7 @@ def check_mentioned_files(self):\n                 msg += f' (did you mean \"{candidates[0]}\"?)'\n                 details = '\\n'.join(difflib.Differ().compare([file], [candidates[0]])).rstrip()\n             self.errors.append(Error(msg, file, details))\n+        auto_add_warnings = defaultdict(list)\n         for file in sorted(changed_files - mentioned_files):\n             if not self.in_ignored_location(file):\n                 if file in self.new_files:\n@@ -738,6 +741,7 @@ def check_mentioned_files(self):\n                         file = file[len(entry.folder):].lstrip('/')\n                         entry.lines.append('\\t* %s: New file.' % file)\n                         entry.files.append(file)\n+                        auto_add_warnings[entry.folder].append(file)\n                     else:\n                         msg = 'new file in the top-level folder not mentioned in a ChangeLog'\n                         self.errors.append(Error(msg, file))\n@@ -755,6 +759,11 @@ def check_mentioned_files(self):\n             if pattern not in used_patterns:\n                 error = \"pattern doesn't match any changed files\"\n                 self.errors.append(Error(error, pattern))\n+        for entry, val in auto_add_warnings.items():\n+            if len(val) == 1:\n+                self.warnings.append(f\"Auto-added new file '{entry}/{val[0]}'\")\n+            else:\n+                self.warnings.append(f\"Auto-added {len(val)} new files in '{entry}'\")\n \n     def check_for_correct_changelog(self):\n         for entry in self.changelog_entries:\n@@ -830,6 +839,12 @@ def print_errors(self):\n         for error in self.errors:\n             print(error)\n \n+    def print_warnings(self):\n+        if self.warnings:\n+            print('Warnings:')\n+            for warning in self.warnings:\n+                print(warning)\n+\n     def check_commit_email(self):\n         # Parse 'Martin Liska  <mliska@suse.cz>'\n         email = self.info.author.split(' ')[-1].strip('<>')"}, {"sha": "5468efcd0d59a534ee4a4e21481309d711a18534", "filename": "contrib/gcc-changelog/git_email.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fgit_email.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fgit_email.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_email.py?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -119,11 +119,13 @@ def show_help():\n \n         success = 0\n         for full in sorted(allfiles):\n-            email = GitEmail(full, False)\n+            email = GitEmail(full)\n             print(email.filename)\n             if email.success:\n                 success += 1\n                 print('  OK')\n+                for warning in email.warnings:\n+                    print('  WARN: %s' % warning)\n             else:\n                 for error in email.errors:\n                     print('  ERR: %s' % error)\n@@ -135,6 +137,7 @@ def show_help():\n         if email.success:\n             print('OK')\n             email.print_output()\n+            email.print_warnings()\n         else:\n             if not email.info.lines:\n                 print('Error: patch contains no parsed lines', file=sys.stderr)"}, {"sha": "a606029e25fdd8ee55bd437e0b8a4245ddfb4aa6", "filename": "contrib/gcc-changelog/setup.cfg", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fsetup.cfg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Fsetup.cfg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fsetup.cfg?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,4 +2,4 @@\n max-line-length = 120\n \n [tool:pytest]\n-addopts = -vv --flake8\n+addopts = -vv"}, {"sha": "3e311d8d0f19ac50c037f6bbc8abc82e04fbddfa", "filename": "contrib/gcc-changelog/test_email.py", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Ftest_email.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Ftest_email.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Ftest_email.py?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -461,3 +461,21 @@ def test_space_after_tab(self):\n     def test_CR_in_patch(self):\n         email = self.from_patch_glob('0001-Add-M-character.patch')\n         assert (email.errors[0].message == 'cannot find a ChangeLog location in message')\n+\n+    def test_auto_add_file_1(self):\n+        email = self.from_patch_glob('0001-Auto-Add-File.patch')\n+        assert not email.errors\n+        assert (len(email.warnings) == 1)\n+        assert (email.warnings[0]\n+                == \"Auto-added new file 'libgomp/testsuite/libgomp.fortran/allocate-4.f90'\")\n+\n+    def test_auto_add_file_2(self):\n+        email = self.from_patch_glob('0002-Auto-Add-File.patch')\n+        assert not email.errors\n+        assert (len(email.warnings) == 2)\n+        assert (email.warnings[0] == \"Auto-added new file 'gcc/doc/gm2.texi'\")\n+        assert (email.warnings[1] == \"Auto-added 2 new files in 'gcc/m2'\")\n+\n+    def test_digit_in_PR_component(self):\n+        email = self.from_patch_glob('modula-PR-component.patch')\n+        assert not email.errors"}, {"sha": "8bbd341c399074989fcd55a74d7ee4b0eac09cab", "filename": "contrib/gcc-changelog/test_patches.txt", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Ftest_patches.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/contrib%2Fgcc-changelog%2Ftest_patches.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Ftest_patches.txt?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -3636,3 +3636,124 @@ index 0000000..d75da75\n -- \n 2.38.1\n \n+=== 0001-Auto-Add-File.patch ====\n+From e205ec03f0794aeac3e8a89e947c12624d5a274e Mon Sep 17 00:00:00 2001\n+From: Tobias Burnus <tobias@codesourcery.com>\n+Date: Thu, 15 Dec 2022 12:25:07 +0100\n+Subject: [PATCH] libgfortran's ISO_Fortran_binding.c: Use GCC11 version for\n+ backward-only code [PR108056]\n+\n+libgfortran/ChangeLog:\n+\n+\tPR libfortran/108056\n+\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc,\n+\tgfc_desc_to_cfi_desc): Mostly revert to GCC 11 version for\n+\tthose backward-compatiblity-only functions.\n+---\n+ libgfortran/runtime/ISO_Fortran_binding.c     | 151 +++---------------\n+ .../testsuite/libgomp.fortran/allocate-4.f90  |  42 +++++\n+ 2 files changed, 64 insertions(+), 129 deletions(-)\n+ create mode 100644 libgomp/testsuite/libgomp.fortran/allocate-4.f90\n+\n+diff --git a/libgfortran/runtime/ISO_Fortran_binding.c b/libgfortran/runtime/ISO_Fortran_binding.c\n+index 342df4275b9..e63a717a69b 100644\n+--- a/libgfortran/runtime/ISO_Fortran_binding.c\n++++ b/libgfortran/runtime/ISO_Fortran_binding.c\n+@@ -41,1 +41,1 @@ export_proto(cfi_desc_to_gfc_desc);\n+-  signed char type;\n++  size_t type;\n+diff --git a/libgomp/testsuite/libgomp.fortran/allocate-4.f90 b/libgomp/testsuite/libgomp.fortran/allocate-4.f90\n+new file mode 100644\n+index 00000000000..ddb507ba8e4\n+--- /dev/null\n++++ b/libgomp/testsuite/libgomp.fortran/allocate-4.f90\n+@@ -0,0 +1,1 @@\n++end\n+-- \n+2.25.1\n+\n+=== 0002-Auto-Add-File.patch ====\n+From 1eee94d351774cdc2efc8ee508b82d065184c6ee Mon Sep 17 00:00:00 2001\n+From: Gaius Mulley <gaiusmod2@gmail.com>\n+Date: Wed, 14 Dec 2022 17:43:08 +0000\n+Subject: [PATCH 363/400] Merge modula-2 front end onto gcc.\n+\n+This commit merges the devel/modula2 into master.\n+The libraries reside in libgm2, the compiler in gcc/m2\n+and the testsuite in gcc/testsuite/gm2.\n+\n+gcc/ChangeLog:\n+\n+\t* configure.ac (HAVE_PYTHON): Test for Python3 added.\n+\t* doc/install.texi: Add m2 as a language.  (--disable-libgm2)\n+\n+Signed-off-by: Gaius Mulley <gaiusmod2@gmail.com>\n+---\n+ gcc/configure.ac                              |    15 +-\n+ gcc/doc/gm2.texi                              |  2838 ++\n+ gcc/doc/install.texi                          |    53 +-\n+ gcc/m2/COPYING.FDL                            |   397 +\n+ gcc/m2/COPYING.RUNTIME                        |    73 +\n+diff --git a/gcc/configure.ac b/gcc/configure.ac\n+index 7ca08726efa..5efbf11793c 100644\n+--- a/gcc/configure.ac\n++++ b/gcc/configure.ac\n+@@ -7651,3 +7665,2 @@ done\n+ [subdirs='$subdirs'])\n+ AC_OUTPUT\n+-\n+diff --git a/gcc/doc/gm2.texi b/gcc/doc/gm2.texi\n+new file mode 100644\n+index 00000000000..513fdd3ec7f\n+--- /dev/null\n++++ b/gcc/doc/gm2.texi\n+@@ -0,0 +1,1 @@\n++\\input texinfo\n+diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi\n+index 89ff6a6734b..6884a74936b 100644\n+--- a/gcc/doc/install.texi\n++++ b/gcc/doc/install.texi\n+@@ -308,1 +308,2 @@ On some targets, @samp{libphobos} isn't enabled by default, but compiles\n+ \n++@item @anchor{GM2-prerequisite}GM2\n+diff --git a/gcc/m2/COPYING.FDL b/gcc/m2/COPYING.FDL\n+new file mode 100644\n+index 00000000000..9854856fa81\n+--- /dev/null\n++++ b/gcc/m2/COPYING.FDL\n+@@ -0,0 +1,1 @@\n++\t\tGNU Free Documentation License\n+diff --git a/gcc/m2/COPYING.RUNTIME b/gcc/m2/COPYING.RUNTIME\n+new file mode 100644\n+index 00000000000..649af5e573a\n+--- /dev/null\n++++ b/gcc/m2/COPYING.RUNTIME\n+@@ -0,0 +1,1 @@\n++GCC RUNTIME LIBRARY EXCEPTION\n+-- \n+2.25.1\n+\n+=== modula-PR-component.patch ===\n+From 1052d89a0b9769453561e18da32b1558d059b320 Mon Sep 17 00:00:00 2001\n+From: Martin Liska <mliska@suse.cz>\n+Date: Mon, 19 Dec 2022 14:34:18 +0100\n+Subject: [PATCH] gcc-changelog: allow digit in component name\n+\n+\tPR modula2/123456\n+\n+contrib/ChangeLog:\n+\n+\t* gcc-changelog/git_commit.py: Allow digit in component name.\n+---\n+ contrib/gcc-changelog/git_commit.py | 2 +-\n+ 1 file changed, 1 insertion(+), 1 deletion(-)\n+\n+diff --git a/contrib/gcc-changelog/git_commit.py b/contrib/gcc-changelog/git_commit.py\n+index e82fbcacd3e..7fde02cba85 100755\n+--- a/contrib/gcc-changelog/git_commit.py\n++++ b/contrib/gcc-changelog/git_commit.py\n+@@ -0,0 +1,1 @@\n++\t\tGNU Free Documentation License\n+-- \n+2.39.0\n+"}, {"sha": "bc11164bcc856c89c4822e7c21bf8b3f25c57678", "filename": "gcc/ChangeLog", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,107 @@\n+2022-12-19  Jason Merrill  <jason@redhat.com>\n+\n+\t* sort.cc: Disable -Wconditionally-supported in\n+\tCHECKING_P code.\n+\n+2022-12-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/64867\n+\t* configure.ac (strict_warn): Add -Wconditionally-supported.\n+\t* configure: Regenerate.\n+\n+2022-12-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108164\n+\t* tree-vect-loop-manip.cc (vect_update_ivs_after_vectorizer):\n+\tPerform vect_step_op_add update in the appropriate type.\n+\n+2022-12-19  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm-c.cc (__ARM_FEATURE_CLZ): Fix definition of\n+\tpreprocessor macro when target has CLZ in another ISA.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector.md: Remove vste.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config.gcc: Add riscv-vsetvl.o.\n+\t* config/riscv/riscv-passes.def (INSERT_PASS_BEFORE): Add VSETVL PASS\n+\tlocation.\n+\t* config/riscv/riscv-protos.h (make_pass_vsetvl): New function.\n+\t(enum avl_type): New enum.\n+\t(get_ta): New function.\n+\t(get_ma): Ditto.\n+\t(get_avl_type): Ditto.\n+\t(calculate_ratio): Ditto.\n+\t(enum tail_policy): New enum.\n+\t(enum mask_policy): Ditto.\n+\t* config/riscv/riscv-v.cc (calculate_ratio): New function.\n+\t(emit_pred_op): change the VLMAX mov codgen.\n+\t(get_ta): New function.\n+\t(get_ma): Ditto.\n+\t(enum tail_policy): Change enum.\n+\t(get_prefer_tail_policy): New function.\n+\t(enum mask_policy): Change enum.\n+\t(get_prefer_mask_policy): New function.\n+\t* config/riscv/t-riscv: Add riscv-vsetvl.o\n+\t* config/riscv/vector.md: Adjust attribute and pattern for VSETVL\n+\tPASS.\n+\t(@vlmax_avl<mode>): Ditto.\n+\t(@vsetvl<mode>_no_side_effects): Delete.\n+\t(vsetvl_vtype_change_only): New MD pattern.\n+\t(@vsetvl_discard_result<mode>): Ditto.\n+\t* config/riscv/riscv-vsetvl.cc: New file.\n+\t* config/riscv/riscv-vsetvl.h: New file.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-switch.def (ENTRY): Correct attributes.\n+\n+2022-12-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR target/108140\n+\t* config/aarch64/aarch64-builtins.cc\n+\t(aarch64_expand_builtin_data_intrinsic): Handle NULL target.\n+\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/gnu-user.h (LIBHWASAN_EARLY_SPEC): Add libhwasan_preinit.o\n+\tto link spec if not -shared.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-v.cc (emit_vlmax_vsetvl): Pass through VLMUL enum\n+\tinstead of machine mode.\n+\t* config/riscv/riscv-vector-builtins-bases.cc: Ditto.\n+\t* config/riscv/riscv.cc (riscv_print_operand): Print LMUL by enum vlmul\n+\tinstead of machine mode.\n+\n+2022-12-19  Jiufu Guo  <guojiufu@linux.ibm.com>\n+\n+\tPR target/106708\n+\t* config/rs6000/rs6000.cc (rs6000_emit_set_long_const): Add using\n+\t\"li; x?oris\" to build constant.\n+\n+2022-12-19  liuhongt  <hongtao.liu@intel.com>\n+\n+\tPR target/55522\n+\t* config/i386/gnu-user-common.h (GNU_USER_TARGET_MATHFILE_SPEC):\n+\tDon't add crtfastmath.o for -shared.\n+\t* doc/invoke.texi (-shared): Add related documentation.\n+\n+2022-12-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* config.gcc: Determine Solaris minor version.\n+\tObsolete *-*-solaris2.11.[0-3]*.\n+\t* doc/install.texi (Specific, *-*-solaris2*): Document it.\n+\n+2022-12-17  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000-logue.cc (rs6000_output_function_epilogue):\n+\tHandle GNU Rust for the tbtab lang field.\n+\n 2022-12-16  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/pa.cc (pa_option_override): Disable -fstack-protector."}, {"sha": "142f05d435412b82322863ab7f1b5fbc25203433", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1 +1 @@\n-20221217\n+20221220"}, {"sha": "da43a2542ed59b62845a75367c1f0224ab636911", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,8 @@\n+2022-12-19  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/98487\n+\t* c-format.cc (check_function_format): Use get_attribute_name.\n+\n 2022-12-16  Qing Zhao  <qing.zhao@oracle.com>\n \n \t* c.opt (Wstrict-flex-arrays): New option."}, {"sha": "08643c5da7aa77d276f5c640cda9a60a88793ce0", "filename": "gcc/c-family/c-format.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc-family%2Fc-format.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc-family%2Fc-format.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1215,7 +1215,7 @@ check_function_format (const_tree fn, tree attrs, int nargs,\n \t      for (c = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n \t\t   c;\n \t\t   c = TREE_CHAIN (c))\n-\t\tif (is_attribute_p (\"format\", TREE_PURPOSE (c))\n+\t\tif (is_attribute_p (\"format\", get_attribute_name (c))\n \t\t    && (decode_format_type (IDENTIFIER_POINTER\n \t\t\t\t\t    (TREE_VALUE (TREE_VALUE (c))))\n \t\t\t== info.format_type))"}, {"sha": "62e484f45b49c6dda945f6c22108dd3e33315fb0", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,9 @@\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/108043\n+\t* c-parser.cc (c_parser_postfix_expression_after_paren_type): Diagnose\n+\tcompound literals with function type.\n+\n 2022-12-07  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-decl.cc (declspecs_add_type, declspecs_add_scspec): Check for"}, {"sha": "7d6960fffbb6775b5620f44c4c7002c41454ab4f", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -10924,6 +10924,11 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n       error_at (type_loc, \"compound literal has variable size\");\n       type = error_mark_node;\n     }\n+  else if (TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      error_at (type_loc, \"compound literal has function type\");\n+      type = error_mark_node;\n+    }\n   if (constexpr_p && type != error_mark_node)\n     {\n       tree type_no_array = strip_array_types (type);"}, {"sha": "dba19e188e474dd9af259457005351345b0b0caf", "filename": "gcc/config.gcc", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -257,14 +257,25 @@ target_type_format_char='@'\n xm_file=\n md_file=\n \n+# Determine Solaris minor version\n+case ${target}:`uname -v` in\n+  # Only do this on Solaris.  Illumos uses illumos-* instead.\n+  *-*-solaris2.11*:11.*)\n+    # Restrict to native configurations.\n+    if test x$host = x$target; then\n+      uname_version=\"`uname -v`\"\n+      # Prepend dot as needed below.\n+      target_min=\".`expr \"$uname_version\" : '11\\.\\([0-9]*\\)'`\"\n+    fi\n+    ;;\n+esac\n+\n # Obsolete configurations.\n-case ${target} in\n-  *)\n-  ;;\n-  obsoleted-target \\\n+case ${target}${target_min} in\n+    *-*-solaris2.11.[0-3]*\t\t\\\n  )\n     if test \"x$enable_obsolete\" != xyes; then\n-      echo \"*** Configuration ${target} is obsolete.\" >&2\n+      echo \"*** Configuration ${target}${target_min} is obsolete.\" >&2\n       echo \"*** Specify --enable-obsolete to build it anyway.\" >&2\n       echo \"*** Support will be REMOVED in the next major release of GCC,\" >&2\n       echo \"*** unless a maintainer comes forward.\" >&2\n@@ -529,7 +540,7 @@ pru-*-*)\n \t;;\n riscv*)\n \tcpu_type=riscv\n-\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o riscv-v.o\"\n+\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o riscv-v.o riscv-vsetvl.o\"\n \textra_objs=\"${extra_objs} riscv-vector-builtins.o riscv-vector-builtins-shapes.o riscv-vector-builtins-bases.o\"\n \td_target_objs=\"riscv-d.o\"\n \textra_headers=\"riscv_vector.h\""}, {"sha": "5c9f727b255baa35e5876ed46819432e75cbc99c", "filename": "gcc/config/aarch64/aarch64-builtins.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2648,7 +2648,7 @@ static rtx\n aarch64_expand_builtin_data_intrinsic (unsigned int fcode, tree exp, rtx target)\n {\n   expand_operand ops[2];\n-  machine_mode mode = GET_MODE (target);\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n   create_output_operand (&ops[0], target, mode);\n   create_input_operand (&ops[1], expand_normal (CALL_EXPR_ARG (exp, 0)), mode);\n   enum insn_code icode;"}, {"sha": "202898fa04185e839a2f530a9222a9ae41468976", "filename": "gcc/config/arm/arm-c.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Farm%2Farm-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Farm%2Farm-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -238,8 +238,12 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n     builtin_define_with_int_value (\"__ARM_FEATURE_LDREX\",\n \t\t\t\t   TARGET_ARM_FEATURE_LDREX);\n \n+  /* ACLE says that __ARM_FEATURE_CLZ is defined if the hardware\n+     supports it; it's also clear that this doesn't mean the current\n+     ISA, so we define this even when compiling for Thumb1 if the\n+     target supports CLZ in A32.  */\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_CLZ\",\n-\t\t      ((TARGET_ARM_ARCH >= 5 && !TARGET_THUMB)\n+\t\t      ((TARGET_ARM_ARCH >= 5 && arm_arch_notm)\n \t\t       || TARGET_ARM_ARCH_ISA_THUMB >=2));\n \n   def_or_undef_macro (pfile, \"__ARM_FEATURE_NUMERIC_MAXMIN\","}, {"sha": "edb3aa6e451b3a5b4e8b9ff1052d0af1ba7efc03", "filename": "gcc/config/gnu-user.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Fgnu-user.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Fgnu-user.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu-user.h?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -138,7 +138,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   LD_STATIC_OPTION \" --whole-archive -lasan --no-whole-archive \" \\\n   LD_DYNAMIC_OPTION \"}}%{!static-libasan:-lasan}\"\n #undef LIBHWASAN_EARLY_SPEC\n-#define LIBHWASAN_EARLY_SPEC \"%{static-libhwasan:%{!shared:\" \\\n+#define LIBHWASAN_EARLY_SPEC \"%{!shared:libhwasan_preinit%O%s} \" \\\n+  \"%{static-libhwasan:%{!shared:\" \\\n   LD_STATIC_OPTION \" --whole-archive -lhwasan --no-whole-archive \" \\\n   LD_DYNAMIC_OPTION \"}}%{!static-libhwasan:-lhwasan}\"\n #undef LIBTSAN_EARLY_SPEC"}, {"sha": "9910cd64363dea617d6b3d5826c8693191a7f987", "filename": "gcc/config/i386/gnu-user-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Fi386%2Fgnu-user-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Fi386%2Fgnu-user-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgnu-user-common.h?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Similar to standard GNU userspace, but adding -ffast-math support.  */\n #define GNU_USER_TARGET_MATHFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}} \\\n    %{mpc32:crtprec32.o%s} \\\n    %{mpc64:crtprec64.o%s} \\\n    %{mpc80:crtprec80.o%s}\""}, {"sha": "d2d48f231aa8f40c232f0ec262a4d793c6b06eb1", "filename": "gcc/config/riscv/riscv-passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-passes.def?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -18,3 +18,4 @@\n    <http://www.gnu.org/licenses/>.  */\n \n INSERT_PASS_AFTER (pass_rtl_store_motion, 1, pass_shorten_memrefs);\n+INSERT_PASS_BEFORE (pass_sched2, 1, pass_vsetvl);"}, {"sha": "cfd0f284f9163aad5285a46eb5b79a8d137e56e7", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -96,6 +96,7 @@ extern void riscv_parse_arch_string (const char *, struct gcc_options *, locatio\n extern bool riscv_hard_regno_rename_ok (unsigned, unsigned);\n \n rtl_opt_pass * make_pass_shorten_memrefs (gcc::context *ctxt);\n+rtl_opt_pass * make_pass_vsetvl (gcc::context *ctxt);\n \n /* Information about one CPU we know about.  */\n struct riscv_cpu_info {\n@@ -131,6 +132,12 @@ enum vlmul_type\n   LMUL_F4 = 6,\n   LMUL_F2 = 7,\n };\n+\n+enum avl_type\n+{\n+  NONVLMAX,\n+  VLMAX,\n+};\n /* Routines implemented in riscv-vector-builtins.cc.  */\n extern void init_builtins (void);\n extern const char *mangle_builtin_type (const_tree);\n@@ -145,17 +152,25 @@ extern bool legitimize_move (rtx, rtx, machine_mode);\n extern void emit_pred_op (unsigned, rtx, rtx, machine_mode);\n extern enum vlmul_type get_vlmul (machine_mode);\n extern unsigned int get_ratio (machine_mode);\n+extern int get_ta (rtx);\n+extern int get_ma (rtx);\n+extern int get_avl_type (rtx);\n+extern unsigned int calculate_ratio (unsigned int, enum vlmul_type);\n enum tail_policy\n {\n   TAIL_UNDISTURBED = 0,\n   TAIL_AGNOSTIC = 1,\n+  TAIL_ANY = 2,\n };\n \n enum mask_policy\n {\n   MASK_UNDISTURBED = 0,\n   MASK_AGNOSTIC = 1,\n+  MASK_ANY = 2,\n };\n+enum tail_policy get_prefer_tail_policy ();\n+enum mask_policy get_prefer_mask_policy ();\n }\n \n /* We classify builtin types into two classes:"}, {"sha": "bae5e921dd0c33fe2a360ab15fde9a6264373ea3", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -72,11 +72,16 @@ template <int MAX_OPERANDS> class insn_expander\n   }\n   void add_policy_operand (enum tail_policy vta, enum mask_policy vma)\n   {\n-    rtx tail_policy_rtx = vta == TAIL_UNDISTURBED ? const0_rtx : const1_rtx;\n-    rtx mask_policy_rtx = vma == MASK_UNDISTURBED ? const0_rtx : const1_rtx;\n+    rtx tail_policy_rtx = gen_int_mode (vta, Pmode);\n+    rtx mask_policy_rtx = gen_int_mode (vma, Pmode);\n     add_input_operand (tail_policy_rtx, Pmode);\n     add_input_operand (mask_policy_rtx, Pmode);\n   }\n+  void add_avl_type_operand ()\n+  {\n+    rtx vlmax_rtx = gen_int_mode (avl_type::VLMAX, Pmode);\n+    add_input_operand (vlmax_rtx, Pmode);\n+  }\n \n   void expand (enum insn_code icode, bool temporary_volatile_p = false)\n   {\n@@ -112,19 +117,58 @@ emit_vlmax_vsetvl (machine_mode vmode)\n   unsigned int sew = GET_MODE_CLASS (vmode) == MODE_VECTOR_BOOL\n \t\t       ? 8\n \t\t       : GET_MODE_BITSIZE (GET_MODE_INNER (vmode));\n+  enum vlmul_type vlmul = get_vlmul (vmode);\n+  unsigned int ratio = calculate_ratio (sew, vlmul);\n+\n+  if (!optimize)\n+    emit_insn (gen_vsetvl (Pmode, vl, RVV_VLMAX, gen_int_mode (sew, Pmode),\n+\t\t\t   gen_int_mode (get_vlmul (vmode), Pmode), const0_rtx,\n+\t\t\t   const0_rtx));\n+  else\n+    emit_insn (gen_vlmax_avl (Pmode, vl, gen_int_mode (ratio, Pmode)));\n \n-  emit_insn (\n-    gen_vsetvl_no_side_effects (Pmode, vl, RVV_VLMAX, gen_int_mode (sew, Pmode),\n-\t\t\t\tgen_int_mode ((unsigned int) vmode, Pmode),\n-\t\t\t\tconst1_rtx, const1_rtx));\n   return vl;\n }\n \n+/* Calculate SEW/LMUL ratio.  */\n+unsigned int\n+calculate_ratio (unsigned int sew, enum vlmul_type vlmul)\n+{\n+  unsigned int ratio;\n+  switch (vlmul)\n+    {\n+    case LMUL_1:\n+      ratio = sew;\n+      break;\n+    case LMUL_2:\n+      ratio = sew / 2;\n+      break;\n+    case LMUL_4:\n+      ratio = sew / 4;\n+      break;\n+    case LMUL_8:\n+      ratio = sew / 8;\n+      break;\n+    case LMUL_F8:\n+      ratio = sew * 8;\n+      break;\n+    case LMUL_F4:\n+      ratio = sew * 4;\n+      break;\n+    case LMUL_F2:\n+      ratio = sew * 2;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return ratio;\n+}\n+\n /* Emit an RVV unmask && vl mov from SRC to DEST.  */\n void\n emit_pred_op (unsigned icode, rtx dest, rtx src, machine_mode mask_mode)\n {\n-  insn_expander<7> e;\n+  insn_expander<8> e;\n   machine_mode mode = GET_MODE (dest);\n \n   e.add_output_operand (dest, mode);\n@@ -137,7 +181,9 @@ emit_pred_op (unsigned icode, rtx dest, rtx src, machine_mode mask_mode)\n   e.add_input_operand (vlmax, Pmode);\n \n   if (GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL)\n-    e.add_policy_operand (TAIL_AGNOSTIC, MASK_AGNOSTIC);\n+    e.add_policy_operand (get_prefer_tail_policy (), get_prefer_mask_policy ());\n+\n+  e.add_avl_type_operand ();\n \n   e.expand ((enum insn_code) icode, MEM_P (dest) || MEM_P (src));\n }\n@@ -256,4 +302,44 @@ get_ratio (machine_mode mode)\n     return mode_vtype_infos.ratio_for_min_vlen64[mode];\n }\n \n+/* Get ta according to operand[tail_op_idx].  */\n+int\n+get_ta (rtx ta)\n+{\n+  if (INTVAL (ta) == TAIL_ANY)\n+    return INVALID_ATTRIBUTE;\n+  return INTVAL (ta);\n+}\n+\n+/* Get ma according to operand[mask_op_idx].  */\n+int\n+get_ma (rtx ma)\n+{\n+  if (INTVAL (ma) == MASK_ANY)\n+    return INVALID_ATTRIBUTE;\n+  return INTVAL (ma);\n+}\n+\n+/* Get prefer tail policy.  */\n+enum tail_policy\n+get_prefer_tail_policy ()\n+{\n+  /* TODO: By default, we choose to use TAIL_ANY which allows\n+     compiler pick up either agnostic or undisturbed. Maybe we\n+     will have a compile option like -mprefer=agnostic to set\n+     this value???.  */\n+  return TAIL_ANY;\n+}\n+\n+/* Get prefer mask policy.  */\n+enum mask_policy\n+get_prefer_mask_policy ()\n+{\n+  /* TODO: By default, we choose to use MASK_ANY which allows\n+     compiler pick up either agnostic or undisturbed. Maybe we\n+     will have a compile option like -mprefer=agnostic to set\n+     this value???.  */\n+  return MASK_ANY;\n+}\n+\n } // namespace riscv_vector"}, {"sha": "ffeb1b25fbcf4f84fcfc7a55cbc6a86dd39674d3", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -73,7 +73,7 @@ class vsetvl : public function_base\n \t\t\t gen_int_mode (GET_MODE_BITSIZE (inner_mode), Pmode));\n \n     /* LMUL.  */\n-    e.add_input_operand (Pmode, gen_int_mode ((unsigned int) mode, Pmode));\n+    e.add_input_operand (Pmode, gen_int_mode (get_vlmul (mode), Pmode));\n \n     /* TA.  */\n     e.add_input_operand (Pmode, gen_int_mode (1, Pmode));"}, {"sha": "ec12be84661edc6ac06d419245fc33512116badb", "filename": "gcc/config/riscv/riscv-vector-switch.def", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -95,16 +95,16 @@ TODO: FP16 vector needs support of 'zvfh', we don't support it yet.  */\n #endif\n \n /* Mask modes. Disable VNx64BImode when TARGET_MIN_VLEN == 32.  */\n-ENTRY (VNx64BI, TARGET_MIN_VLEN > 32, LMUL_F8, 64, LMUL_RESERVED, 0)\n-ENTRY (VNx32BI, true, LMUL_F4, 32, LMUL_RESERVED, 0)\n-ENTRY (VNx16BI, true, LMUL_F2, 16, LMUL_RESERVED, 0)\n-ENTRY (VNx8BI, true, LMUL_1, 8, LMUL_RESERVED, 0)\n-ENTRY (VNx4BI, true, LMUL_2, 4, LMUL_RESERVED, 0)\n-ENTRY (VNx2BI, true, LMUL_4, 2, LMUL_RESERVED, 0)\n-ENTRY (VNx1BI, true, LMUL_8, 1, LMUL_RESERVED, 0)\n+ENTRY (VNx64BI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_8, 1)\n+ENTRY (VNx32BI, true, LMUL_8, 1, LMUL_4, 2)\n+ENTRY (VNx16BI, true, LMUL_4, 2, LMUL_2, 4)\n+ENTRY (VNx8BI, true, LMUL_2, 4, LMUL_1, 8)\n+ENTRY (VNx4BI, true, LMUL_1, 8, LMUL_F2, 16)\n+ENTRY (VNx2BI, true, LMUL_F2, 16, LMUL_F4, 32)\n+ENTRY (VNx1BI, true, LMUL_F4, 32, LMUL_F8, 64)\n \n /* SEW = 8. Disable VNx64QImode when TARGET_MIN_VLEN == 32.  */\n-ENTRY (VNx64QI, TARGET_MIN_VLEN > 32, LMUL_8, 1, LMUL_RESERVED, 0)\n+ENTRY (VNx64QI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_8, 1)\n ENTRY (VNx32QI, true, LMUL_8, 1, LMUL_4, 2)\n ENTRY (VNx16QI, true, LMUL_4, 2, LMUL_2, 4)\n ENTRY (VNx8QI, true, LMUL_2, 4, LMUL_1, 8)\n@@ -113,15 +113,15 @@ ENTRY (VNx2QI, true, LMUL_F2, 16, LMUL_F4, 32)\n ENTRY (VNx1QI, true, LMUL_F4, 32, LMUL_F8, 64)\n \n /* SEW = 16. Disable VNx32HImode when TARGET_MIN_VLEN == 32.  */\n-ENTRY (VNx32HI, TARGET_MIN_VLEN > 32, LMUL_8, 2, LMUL_RESERVED, 0)\n+ENTRY (VNx32HI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_8, 2)\n ENTRY (VNx16HI, true, LMUL_8, 2, LMUL_4, 4)\n ENTRY (VNx8HI, true, LMUL_4, 4, LMUL_2, 8)\n ENTRY (VNx4HI, true, LMUL_2, 8, LMUL_1, 16)\n ENTRY (VNx2HI, true, LMUL_1, 16, LMUL_F2, 32)\n ENTRY (VNx1HI, true, LMUL_F2, 32, LMUL_F4, 64)\n \n /* TODO:Disable all FP16 vector, enable them when 'zvfh' is supported.  */\n-ENTRY (VNx32HF, false, LMUL_8, 2, LMUL_RESERVED, 0)\n+ENTRY (VNx32HF, false, LMUL_RESERVED, 0, LMUL_8, 2)\n ENTRY (VNx16HF, false, LMUL_8, 2, LMUL_4, 4)\n ENTRY (VNx8HF, false, LMUL_4, 4, LMUL_2, 8)\n ENTRY (VNx4HF, false, LMUL_2, 8, LMUL_1, 16)\n@@ -131,18 +131,18 @@ ENTRY (VNx1HF, false, LMUL_F2, 32, LMUL_F4, 64)\n /* SEW = 32. Disable VNx16SImode when TARGET_MIN_VLEN == 32.\n    For single-precision floating-point, we need TARGET_VECTOR_FP32 ==\n    RVV_ENABLE.  */\n-ENTRY (VNx16SI, TARGET_MIN_VLEN > 32, LMUL_8, 4, LMUL_RESERVED, 0)\n+ENTRY (VNx16SI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_8, 4)\n ENTRY (VNx8SI, true, LMUL_8, 4, LMUL_4, 8)\n-ENTRY (VNx4SI, true, LMUL_4, 8, LMUL_2, 4)\n-ENTRY (VNx2SI, true, LMUL_2, 16, LMUL_1, 2)\n-ENTRY (VNx1SI, true, LMUL_1, 32, LMUL_F2, 1)\n+ENTRY (VNx4SI, true, LMUL_4, 8, LMUL_2, 16)\n+ENTRY (VNx2SI, true, LMUL_2, 16, LMUL_1, 32)\n+ENTRY (VNx1SI, true, LMUL_1, 32, LMUL_F2, 64)\n \n-ENTRY (VNx16SF, TARGET_VECTOR_FP32 && (TARGET_MIN_VLEN > 32), LMUL_8, 4,\n-       LMUL_RESERVED, 0)\n+ENTRY (VNx16SF, TARGET_VECTOR_FP32 && (TARGET_MIN_VLEN > 32), LMUL_RESERVED, 0,\n+       LMUL_8, 4)\n ENTRY (VNx8SF, TARGET_VECTOR_FP32, LMUL_8, 4, LMUL_4, 8)\n-ENTRY (VNx4SF, TARGET_VECTOR_FP32, LMUL_4, 8, LMUL_2, 4)\n-ENTRY (VNx2SF, TARGET_VECTOR_FP32, LMUL_2, 16, LMUL_1, 2)\n-ENTRY (VNx1SF, TARGET_VECTOR_FP32, LMUL_1, 32, LMUL_F2, 1)\n+ENTRY (VNx4SF, TARGET_VECTOR_FP32, LMUL_4, 8, LMUL_2, 16)\n+ENTRY (VNx2SF, TARGET_VECTOR_FP32, LMUL_2, 16, LMUL_1, 32)\n+ENTRY (VNx1SF, TARGET_VECTOR_FP32, LMUL_1, 32, LMUL_F2, 64)\n \n /* SEW = 64. Enable when TARGET_MIN_VLEN > 32.\n    For double-precision floating-point, we need TARGET_VECTOR_FP64 =="}, {"sha": "3ca3fc15e5a9567f1cbf3b42894a70e176e4bcd4", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "added", "additions": 2509, "deletions": 0, "changes": 2509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,2509 @@\n+/* VSETVL pass for RISC-V 'V' Extension for GNU compiler.\n+   Copyright(C) 2022-2022 Free Software Foundation, Inc.\n+   Contributed by Juzhe Zhong (juzhe.zhong@rivai.ai), RiVAI Technologies Ltd.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or(at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/*  This pass is to Set VL/VTYPE global status for RVV instructions\n+    that depend on VL and VTYPE registers by Lazy code motion (LCM).\n+\n+    Strategy:\n+\n+    -  Backward demanded info fusion within block.\n+\n+    -  Lazy code motion (LCM) based demanded info backward propagation.\n+\n+    -  RTL_SSA framework for def-use, PHI analysis.\n+\n+    -  Lazy code motion (LCM) for global VL/VTYPE optimization.\n+\n+    Assumption:\n+\n+    -  Each avl operand is either an immediate (must be in range 0 ~ 31) or reg.\n+\n+    This pass consists of 5 phases:\n+\n+    -  Phase 1 - compute VL/VTYPE demanded information within each block\n+       by backward data-flow analysis.\n+\n+    -  Phase 2 - Emit vsetvl instructions within each basic block according to\n+       demand, compute and save ANTLOC && AVLOC of each block.\n+\n+    -  Phase 3 - Backward demanded info propagation and fusion across blocks.\n+\n+    -  Phase 4 - Lazy code motion including: compute local properties,\n+       pre_edge_lcm and vsetvl insertion && delete edges for LCM results.\n+\n+    -  Phase 5 - Cleanup AVL operand of RVV instruction since it will not be\n+       used any more and VL operand of VSETVL instruction if it is not used by\n+       any non-debug instructions.\n+\n+    Implementation:\n+\n+    -  The subroutine of optimize == 0 is simple_vsetvl.\n+       This function simplily vsetvl insertion for each RVV\n+       instruction. No optimization.\n+\n+    -  The subroutine of optimize > 0 is lazy_vsetvl.\n+       This function optimize vsetvl insertion process by\n+       lazy code motion (LCM) layering on RTL_SSA.  */\n+\n+#define IN_TARGET_CODE 1\n+#define INCLUDE_ALGORITHM\n+#define INCLUDE_FUNCTIONAL\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"target.h\"\n+#include \"tree-pass.h\"\n+#include \"df.h\"\n+#include \"rtl-ssa.h\"\n+#include \"cfgcleanup.h\"\n+#include \"insn-config.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-opinit.h\"\n+#include \"tm-constrs.h\"\n+#include \"cfgrtl.h\"\n+#include \"cfganal.h\"\n+#include \"lcm.h\"\n+#include \"predict.h\"\n+#include \"profile-count.h\"\n+#include \"riscv-vsetvl.h\"\n+\n+using namespace rtl_ssa;\n+using namespace riscv_vector;\n+\n+DEBUG_FUNCTION void\n+debug (const vector_insn_info *info)\n+{\n+  info->dump (stderr);\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const vector_infos_manager *info)\n+{\n+  info->dump (stderr);\n+}\n+\n+static bool\n+vlmax_avl_p (rtx x)\n+{\n+  return x && rtx_equal_p (x, RVV_VLMAX);\n+}\n+\n+static bool\n+vlmax_avl_insn_p (rtx_insn *rinsn)\n+{\n+  return INSN_CODE (rinsn) == CODE_FOR_vlmax_avlsi\n+\t || INSN_CODE (rinsn) == CODE_FOR_vlmax_avldi;\n+}\n+\n+static bool\n+loop_basic_block_p (const basic_block cfg_bb)\n+{\n+  return JUMP_P (BB_END (cfg_bb)) && any_condjump_p (BB_END (cfg_bb));\n+}\n+\n+/* Return true if it is an RVV instruction depends on VTYPE global\n+   status register.  */\n+static bool\n+has_vtype_op (rtx_insn *rinsn)\n+{\n+  return recog_memoized (rinsn) >= 0 && get_attr_has_vtype_op (rinsn);\n+}\n+\n+/* Return true if it is an RVV instruction depends on VL global\n+   status register.  */\n+static bool\n+has_vl_op (rtx_insn *rinsn)\n+{\n+  return recog_memoized (rinsn) >= 0 && get_attr_has_vl_op (rinsn);\n+}\n+\n+/* Is this a SEW value that can be encoded into the VTYPE format.  */\n+static bool\n+valid_sew_p (size_t sew)\n+{\n+  return exact_log2 (sew) && sew >= 8 && sew <= 64;\n+}\n+\n+/* Return true if it is a vsetvl instruction.  */\n+static bool\n+vector_config_insn_p (rtx_insn *rinsn)\n+{\n+  return recog_memoized (rinsn) >= 0 && get_attr_type (rinsn) == TYPE_VSETVL;\n+}\n+\n+/* Return true if it is vsetvldi or vsetvlsi.  */\n+static bool\n+vsetvl_insn_p (rtx_insn *rinsn)\n+{\n+  return INSN_CODE (rinsn) == CODE_FOR_vsetvldi\n+\t || INSN_CODE (rinsn) == CODE_FOR_vsetvlsi;\n+}\n+\n+/* Return true if INSN1 comes befeore INSN2 in the same block.  */\n+static bool\n+same_bb_and_before_p (const insn_info *insn1, const insn_info *insn2)\n+{\n+  return (insn1->bb ()->index () == insn2->bb ()->index ())\n+\t && (*insn1 < *insn2);\n+}\n+\n+/* Return true if INSN1 comes after or equal INSN2 in the same block.  */\n+static bool\n+same_bb_and_after_or_equal_p (const insn_info *insn1, const insn_info *insn2)\n+{\n+  return (insn1->bb ()->index () == insn2->bb ()->index ())\n+\t && (*insn1 >= *insn2);\n+}\n+\n+/* An \"anticipatable occurrence\" is one that is the first occurrence in the\n+   basic block, the operands are not modified in the basic block prior\n+   to the occurrence and the output is not used between the start of\n+   the block and the occurrence.  */\n+static bool\n+anticipatable_occurrence_p (const insn_info *insn, const vector_insn_info dem)\n+{\n+  /* The only possible operand we care of VSETVL is AVL.  */\n+  if (dem.has_avl_reg ())\n+    {\n+      /* The operands shoule not be modified in the basic block prior\n+\t to the occurrence.  */\n+      if (!vlmax_avl_p (dem.get_avl ()))\n+\t{\n+\t  set_info *set\n+\t    = find_access (insn->uses (), REGNO (dem.get_avl ()))->def ();\n+\t  /* If it's undefined, it's not anticipatable conservatively.  */\n+\t  if (!set)\n+\t    return false;\n+\t  if (same_bb_and_before_p (set->insn (), insn))\n+\t    return false;\n+\t}\n+    }\n+\n+  /* The output should not be used between the start of the block\n+     and the occurrence.  */\n+  if (vsetvl_insn_p (insn->rtl ()))\n+    {\n+      rtx dest = SET_DEST (XVECEXP (PATTERN (insn->rtl ()), 0, 0));\n+      for (insn_info *i = insn->prev_nondebug_insn (); i != nullptr;\n+\t   i = i->prev_nondebug_insn ())\n+\tif (find_access (i->uses (), REGNO (dest)))\n+\t  return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* An \"available occurrence\" is one that is the last occurrence in the\n+   basic block and the operands are not modified by following statements in\n+   the basic block [including this insn].  */\n+static bool\n+available_occurrence_p (const insn_info *insn, const vector_insn_info dem)\n+{\n+  /* The only possible operand we care of VSETVL is AVL.  */\n+  if (dem.has_avl_reg ())\n+    {\n+      /* The operands shoule not be modified in the basic block prior\n+\t to the occurrence.\n+\t e.g.\n+\t    bb:\n+\t      vsetvl hr3, hr2, ...\n+\t      ...\n+\t      vadd ... (vl=hr3)\n+      */\n+      if (!vlmax_avl_p (dem.get_avl ()))\n+\t{\n+\t  set_info *set\n+\t    = find_access (insn->uses (), REGNO (dem.get_avl ()))->def ();\n+\t  /* If it's undefined, it's not available conservatively.  */\n+\t  if (!set)\n+\t    return false;\n+\t  if (same_bb_and_after_or_equal_p (set->insn (), insn))\n+\t    return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Return true if the branch probability is dominate.  */\n+static bool\n+dominate_probability_p (edge e)\n+{\n+  /* TODO: We simpily pick dominate probability >= 50%.\n+     However, it isn't always optimal. Consider cases\n+     like this:\n+       bb 0: 80% succs: bb 2, bb 3, bb 4, bb 5.\n+       bb 1: 20%\n+\n+     Assume bb 1, bb 2, bb 3, bb 4, bb 5 are different\n+     one another, and bb 2, bb 3, bb 4, bb 5 are incompatible.\n+\n+     ??? Maybe backward propagate bb 1 is better ???\n+     May need to support an accurate and reliable COST model\n+     in the future.  */\n+  return e->probability >= profile_probability::even ();\n+}\n+\n+/* Return true if the block is worthwhile backward propagation.  */\n+static bool\n+backward_propagate_worthwhile_p (const basic_block cfg_bb,\n+\t\t\t\t const vector_block_info block_info)\n+{\n+  if (loop_basic_block_p (cfg_bb))\n+    {\n+      if (block_info.local_dem.compatible_p (block_info.reaching_out))\n+\treturn true;\n+\n+      /* There is a obvious case that is not worthwhile and meaningless\n+\t to propagate the demand information:\n+\t\t\t  local_dem\n+\t\t\t     __________\n+\t\t\t ____|____     |\n+\t\t\t|        |     |\n+\t\t\t|________|     |\n+\t\t\t     |_________|\n+\t\t\t  reaching_out\n+\t  Header is incompatible with reaching_out and the block is loop itself,\n+\t  we don't backward propagete the local_dem since we can't avoid emit\n+\t  vsetvl for the local_dem.  */\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n+\tif (e->dest->index == cfg_bb->index)\n+\t  return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Helper function to get VL operand.  */\n+static rtx\n+get_vl (rtx_insn *rinsn)\n+{\n+  if (has_vl_op (rinsn))\n+    {\n+      /* We only call get_vl for VLMAX use VTYPE instruction.\n+\t It's used to get the VL operand to emit VLMAX VSETVL instruction:\n+\t vsetvl a5,zero,e32,m1,ta,ma.  */\n+      gcc_assert (get_attr_avl_type (rinsn) == VLMAX);\n+      extract_insn_cached (rinsn);\n+      return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+    }\n+  return SET_DEST (XVECEXP (PATTERN (rinsn), 0, 0));\n+}\n+\n+/* Helper function to get AVL operand.  */\n+static rtx\n+get_avl (rtx_insn *rinsn)\n+{\n+  if (vsetvl_insn_p (rinsn))\n+    return XVECEXP (SET_SRC (XVECEXP (PATTERN (rinsn), 0, 0)), 0, 0);\n+\n+  if (!has_vl_op (rinsn))\n+    return NULL_RTX;\n+  if (get_attr_avl_type (rinsn) == VLMAX)\n+    return RVV_VLMAX;\n+  extract_insn_cached (rinsn);\n+  return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+}\n+\n+static bool\n+can_backward_propagate_p (const function_info *ssa, const basic_block cfg_bb,\n+\t\t\t  const vector_insn_info prop)\n+{\n+  insn_info *insn = prop.get_insn ();\n+\n+  /* TODO: We don't backward propagate the explict VSETVL here\n+     since we will change vsetvl and vsetvlmax intrinsiscs into\n+     no side effects which can be optimized into optimzal location\n+     by GCC internal PASSes. We only need to support these backward\n+     propagation if vsetvl instrinsics have side effects.  */\n+  if (vsetvl_insn_p (insn->rtl ()))\n+    return false;\n+\n+  gcc_assert (has_vtype_op (insn->rtl ()));\n+  rtx reg = NULL_RTX;\n+\n+  /* Case 1: Don't need VL. Just let it backward propagate.  */\n+  if (!has_vl_op (insn->rtl ()))\n+    return true;\n+  else\n+    {\n+      /* Case 2: CONST_INT AVL, we don't need to check def.  */\n+      if (prop.has_avl_imm ())\n+\treturn true;\n+      else\n+\t{\n+\t  /* Case 3: REG AVL, we need to check the distance of def to make\n+\t     sure we won't backward propagate over the def.  */\n+\t  gcc_assert (prop.has_avl_reg ());\n+\t  if (vlmax_avl_p (prop.get_avl ()))\n+\t    /* Check VL operand for vsetvl vl,zero.  */\n+\t    reg = get_vl (insn->rtl ());\n+\t  else\n+\t    /* Check AVL operand for vsetvl zero,avl.  */\n+\t    reg = get_avl (insn->rtl ());\n+\t}\n+    }\n+\n+  def_info *def = find_access (insn->uses (), REGNO (reg))->def ();\n+\n+  /* If the definition is in the current block, we can't propagate it\n+     acrocss blocks.  */\n+  if (def->bb ()->cfg_bb ()->index == insn->bb ()->cfg_bb ()->index)\n+    {\n+      set_info *set = safe_dyn_cast<set_info *> (def);\n+\n+      /* True if it is a degenerate PHI that can be backward propagated.  */\n+      auto valid_degenerate_phi_p = [&] () {\n+\tif (!set)\n+\t  return false;\n+\n+\tphi_info *phi = safe_dyn_cast<phi_info *> (set);\n+\tif (!phi)\n+\t  return false;\n+\n+\tbasic_block iter_bb;\n+\tset_info *ultimate_def = look_through_degenerate_phi (set);\n+\tconst basic_block ultimate_bb = ultimate_def->bb ()->cfg_bb ();\n+\tFOR_BB_BETWEEN (iter_bb, ultimate_bb, def->bb ()->cfg_bb (), next_bb)\n+\t  if (iter_bb->index == cfg_bb->index)\n+\t    return true;\n+\n+\treturn false;\n+      };\n+\n+      if (valid_degenerate_phi_p ())\n+\treturn true;\n+\n+      /* TODO: Support non-degenerate PHI backward propagation later.  */\n+      return false;\n+    }\n+\n+  /* If the definition block is the current block that we iterate, we\n+     can backward propagate it since we will insert or change VL/VTYPE\n+     info at the end of the current block we iterate.  */\n+  if (def->bb ()->cfg_bb ()->index == cfg_bb->index)\n+    return true;\n+\n+  /* Make sure we don't backward propagete the VL/VTYPE info over the\n+     definition blocks.  */\n+  bool visited_p = false;\n+  for (const bb_info *bb : ssa->reverse_bbs ())\n+    {\n+      if (bb->cfg_bb ()->index == cfg_bb->index && visited_p)\n+\treturn false;\n+      if (bb->cfg_bb ()->index == def->bb ()->cfg_bb ()->index)\n+\tvisited_p = true;\n+    }\n+\n+  return true;\n+}\n+\n+/* Helper function to get SEW operand. We always have SEW value for\n+   all RVV instructions that have VTYPE OP.  */\n+static uint8_t\n+get_sew (rtx_insn *rinsn)\n+{\n+  return get_attr_sew (rinsn);\n+}\n+\n+/* Helper function to get VLMUL operand. We always have VLMUL value for\n+   all RVV instructions that have VTYPE OP. */\n+static enum vlmul_type\n+get_vlmul (rtx_insn *rinsn)\n+{\n+  return (enum vlmul_type) get_attr_vlmul (rinsn);\n+}\n+\n+/* Get default tail policy.  */\n+static bool\n+get_default_ta ()\n+{\n+  /* For the instruction that doesn't require TA, we still need a default value\n+     to emit vsetvl. We pick up the default value according to prefer policy. */\n+  return (bool) (get_prefer_tail_policy () & 0x1\n+\t\t || (get_prefer_tail_policy () >> 1 & 0x1));\n+}\n+\n+/* Get default mask policy.  */\n+static bool\n+get_default_ma ()\n+{\n+  /* For the instruction that doesn't require MA, we still need a default value\n+     to emit vsetvl. We pick up the default value according to prefer policy. */\n+  return (bool) (get_prefer_mask_policy () & 0x1\n+\t\t || (get_prefer_mask_policy () >> 1 & 0x1));\n+}\n+\n+/* Helper function to get TA operand.  */\n+static bool\n+tail_agnostic_p (rtx_insn *rinsn)\n+{\n+  /* If it doesn't have TA, we return agnostic by default.  */\n+  extract_insn_cached (rinsn);\n+  int ta = get_attr_ta (rinsn);\n+  return ta == INVALID_ATTRIBUTE ? get_default_ta () : IS_AGNOSTIC (ta);\n+}\n+\n+/* Helper function to get MA operand.  */\n+static bool\n+mask_agnostic_p (rtx_insn *rinsn)\n+{\n+  /* If it doesn't have MA, we return agnostic by default.  */\n+  extract_insn_cached (rinsn);\n+  int ma = get_attr_ma (rinsn);\n+  return ma == INVALID_ATTRIBUTE ? get_default_ma () : IS_AGNOSTIC (ma);\n+}\n+\n+/* Return true if FN has a vector instruction that use VL/VTYPE.  */\n+static bool\n+has_vector_insn (function *fn)\n+{\n+  basic_block cfg_bb;\n+  rtx_insn *rinsn;\n+  FOR_ALL_BB_FN (cfg_bb, fn)\n+    FOR_BB_INSNS (cfg_bb, rinsn)\n+      if (NONDEBUG_INSN_P (rinsn) && has_vtype_op (rinsn))\n+\treturn true;\n+  return false;\n+}\n+\n+/* Emit vsetvl instruction.  */\n+static rtx\n+gen_vsetvl_pat (enum vsetvl_type insn_type, vl_vtype_info info, rtx vl)\n+{\n+  rtx avl = info.get_avl ();\n+  rtx sew = gen_int_mode (info.get_sew (), Pmode);\n+  rtx vlmul = gen_int_mode (info.get_vlmul (), Pmode);\n+  rtx ta = gen_int_mode (info.get_ta (), Pmode);\n+  rtx ma = gen_int_mode (info.get_ma (), Pmode);\n+\n+  if (insn_type == VSETVL_NORMAL)\n+    {\n+      gcc_assert (vl != NULL_RTX);\n+      return gen_vsetvl (Pmode, vl, avl, sew, vlmul, ta, ma);\n+    }\n+  else if (insn_type == VSETVL_VTYPE_CHANGE_ONLY)\n+    return gen_vsetvl_vtype_change_only (sew, vlmul, ta, ma);\n+  else\n+    return gen_vsetvl_discard_result (Pmode, avl, sew, vlmul, ta, ma);\n+}\n+\n+static rtx\n+gen_vsetvl_pat (rtx_insn *rinsn, const vector_insn_info info)\n+{\n+  rtx new_pat;\n+  if (vsetvl_insn_p (rinsn) || vlmax_avl_p (info.get_avl ()))\n+    {\n+      rtx dest = get_vl (rinsn);\n+      new_pat = gen_vsetvl_pat (VSETVL_NORMAL, info, dest);\n+    }\n+  else if (INSN_CODE (rinsn) == CODE_FOR_vsetvl_vtype_change_only)\n+    new_pat = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, info, NULL_RTX);\n+  else\n+    new_pat = gen_vsetvl_pat (VSETVL_DISCARD_RESULT, info, NULL_RTX);\n+  return new_pat;\n+}\n+\n+static void\n+emit_vsetvl_insn (enum vsetvl_type insn_type, enum emit_type emit_type,\n+\t\t  vl_vtype_info info, rtx vl, rtx_insn *rinsn)\n+{\n+  rtx pat = gen_vsetvl_pat (insn_type, info, vl);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nInsert vsetvl insn PATTERN:\\n\");\n+      print_rtl_single (dump_file, pat);\n+    }\n+\n+  if (emit_type == EMIT_DIRECT)\n+    emit_insn (pat);\n+  else if (emit_type == EMIT_BEFORE)\n+    emit_insn_before (pat, rinsn);\n+  else\n+    emit_insn_after (pat, rinsn);\n+}\n+\n+static void\n+eliminate_insn (rtx_insn *rinsn)\n+{\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nEliminate insn %d:\\n\", INSN_UID (rinsn));\n+      print_rtl_single (dump_file, rinsn);\n+    }\n+  if (in_sequence_p ())\n+    remove_insn (rinsn);\n+  else\n+    delete_insn (rinsn);\n+}\n+\n+static void\n+insert_vsetvl (enum emit_type emit_type, rtx_insn *rinsn,\n+\t       const vector_insn_info &info, const vector_insn_info &prev_info)\n+{\n+  /* Use X0, X0 form if the AVL is the same and the SEW+LMUL gives the same\n+     VLMAX.  */\n+  if (prev_info.valid_or_dirty_p () && !prev_info.unknown_p ()\n+      && info.same_avl_p (prev_info) && info.same_vlmax_p (prev_info))\n+    {\n+      emit_vsetvl_insn (VSETVL_VTYPE_CHANGE_ONLY, emit_type, info, NULL_RTX,\n+\t\t\trinsn);\n+      return;\n+    }\n+\n+  if (info.has_avl_imm ())\n+    {\n+      emit_vsetvl_insn (VSETVL_DISCARD_RESULT, emit_type, info, NULL_RTX,\n+\t\t\trinsn);\n+      return;\n+    }\n+\n+  if (info.has_avl_no_reg ())\n+    {\n+      /* We can only use x0, x0 if there's no chance of the vtype change causing\n+\t the previous vl to become invalid.  */\n+      if (prev_info.valid_or_dirty_p () && !prev_info.unknown_p ()\n+\t  && info.same_vlmax_p (prev_info))\n+\t{\n+\t  emit_vsetvl_insn (VSETVL_VTYPE_CHANGE_ONLY, emit_type, info, NULL_RTX,\n+\t\t\t    rinsn);\n+\t  return;\n+\t}\n+      /* Otherwise use an AVL of 0 to avoid depending on previous vl.  */\n+      vl_vtype_info new_info = info;\n+      new_info.set_avl_info (avl_info (const0_rtx, nullptr));\n+      emit_vsetvl_insn (VSETVL_DISCARD_RESULT, emit_type, new_info, NULL_RTX,\n+\t\t\trinsn);\n+      return;\n+    }\n+\n+  /* Use X0 as the DestReg unless AVLReg is X0. We also need to change the\n+     opcode if the AVLReg is X0 as they have different register classes for\n+     the AVL operand.  */\n+  if (vlmax_avl_p (info.get_avl ()))\n+    {\n+      gcc_assert (has_vtype_op (rinsn) || vsetvl_insn_p (rinsn));\n+      rtx vl_op = get_vl (rinsn);\n+      gcc_assert (!vlmax_avl_p (vl_op));\n+      emit_vsetvl_insn (VSETVL_NORMAL, emit_type, info, vl_op, rinsn);\n+      return;\n+    }\n+\n+  emit_vsetvl_insn (VSETVL_DISCARD_RESULT, emit_type, info, NULL_RTX, rinsn);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Update VL/VTYPE info, previous info=\");\n+      prev_info.dump (dump_file);\n+    }\n+}\n+\n+/* If X contains any LABEL_REF's, add REG_LABEL_OPERAND notes for them\n+   to INSN.  If such notes are added to an insn which references a\n+   CODE_LABEL, the LABEL_NUSES count is incremented.  We have to add\n+   that note, because the following loop optimization pass requires\n+   them.  */\n+\n+/* ??? If there was a jump optimization pass after gcse and before loop,\n+   then we would not need to do this here, because jump would add the\n+   necessary REG_LABEL_OPERAND and REG_LABEL_TARGET notes.  */\n+\n+static void\n+add_label_notes (rtx x, rtx_insn *insn)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+  const char *fmt;\n+\n+  if (code == LABEL_REF && !LABEL_REF_NONLOCAL_P (x))\n+    {\n+      /* This code used to ignore labels that referred to dispatch tables to\n+\t avoid flow generating (slightly) worse code.\n+\n+\t We no longer ignore such label references (see LABEL_REF handling in\n+\t mark_jump_label for additional information).  */\n+\n+      /* There's no reason for current users to emit jump-insns with\n+\t such a LABEL_REF, so we don't have to handle REG_LABEL_TARGET\n+\t notes.  */\n+      gcc_assert (!JUMP_P (insn));\n+      add_reg_note (insn, REG_LABEL_OPERAND, label_ref_label (x));\n+\n+      if (LABEL_P (label_ref_label (x)))\n+\tLABEL_NUSES (label_ref_label (x))++;\n+\n+      return;\n+    }\n+\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tadd_label_notes (XEXP (x, i), insn);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  add_label_notes (XVECEXP (x, i, j), insn);\n+    }\n+}\n+\n+/* Add EXPR to the end of basic block BB.\n+\n+   This is used by both the PRE and code hoisting.  */\n+\n+static void\n+insert_insn_end_basic_block (rtx_insn *rinsn, basic_block cfg_bb)\n+{\n+  rtx_insn *end_rinsn = BB_END (cfg_bb);\n+  rtx_insn *new_insn;\n+  rtx_insn *pat, *pat_end;\n+\n+  pat = rinsn;\n+  gcc_assert (pat && INSN_P (pat));\n+\n+  pat_end = pat;\n+  while (NEXT_INSN (pat_end) != NULL_RTX)\n+    pat_end = NEXT_INSN (pat_end);\n+\n+  /* If the last end_rinsn is a jump, insert EXPR in front.  Similarly we need\n+     to take care of trapping instructions in presence of non-call exceptions.\n+   */\n+\n+  if (JUMP_P (end_rinsn)\n+      || (NONJUMP_INSN_P (end_rinsn)\n+\t  && (!single_succ_p (cfg_bb)\n+\t      || single_succ_edge (cfg_bb)->flags & EDGE_ABNORMAL)))\n+    {\n+      /* FIXME: What if something in jump uses value set in new end_rinsn?  */\n+      new_insn = emit_insn_before_noloc (pat, end_rinsn, cfg_bb);\n+    }\n+\n+  /* Likewise if the last end_rinsn is a call, as will happen in the presence\n+     of exception handling.  */\n+  else if (CALL_P (end_rinsn)\n+\t   && (!single_succ_p (cfg_bb)\n+\t       || single_succ_edge (cfg_bb)->flags & EDGE_ABNORMAL))\n+    {\n+      /* Keeping in mind targets with small register classes and parameters\n+\t in registers, we search backward and place the instructions before\n+\t the first parameter is loaded.  Do this for everyone for consistency\n+\t and a presumption that we'll get better code elsewhere as well.  */\n+\n+      /* Since different machines initialize their parameter registers\n+\t in different orders, assume nothing.  Collect the set of all\n+\t parameter registers.  */\n+      end_rinsn = find_first_parameter_load (end_rinsn, BB_HEAD (cfg_bb));\n+\n+      /* If we found all the parameter loads, then we want to insert\n+\t before the first parameter load.\n+\n+\t If we did not find all the parameter loads, then we might have\n+\t stopped on the head of the block, which could be a CODE_LABEL.\n+\t If we inserted before the CODE_LABEL, then we would be putting\n+\t the end_rinsn in the wrong basic block.  In that case, put the\n+\t end_rinsn after the CODE_LABEL.  Also, respect NOTE_INSN_BASIC_BLOCK.\n+       */\n+      while (LABEL_P (end_rinsn) || NOTE_INSN_BASIC_BLOCK_P (end_rinsn))\n+\tend_rinsn = NEXT_INSN (end_rinsn);\n+\n+      new_insn = emit_insn_before_noloc (pat, end_rinsn, cfg_bb);\n+    }\n+  else\n+    new_insn = emit_insn_after_noloc (pat, end_rinsn, cfg_bb);\n+\n+  while (1)\n+    {\n+      if (INSN_P (pat))\n+\tadd_label_notes (PATTERN (pat), new_insn);\n+      if (pat == pat_end)\n+\tbreak;\n+      pat = NEXT_INSN (pat);\n+    }\n+}\n+\n+/* Get VL/VTYPE information for INSN.  */\n+static vl_vtype_info\n+get_vl_vtype_info (const insn_info *insn)\n+{\n+  if (vector_config_insn_p (insn->rtl ()))\n+    gcc_assert (vsetvl_insn_p (insn->rtl ())\n+\t\t&& \"Can't handle X0, rs1 vsetvli yet\");\n+\n+  set_info *set = nullptr;\n+  rtx avl = ::get_avl (insn->rtl ());\n+  if (avl && REG_P (avl) && !vlmax_avl_p (avl))\n+    set = find_access (insn->uses (), REGNO (avl))->def ();\n+\n+  uint8_t sew = get_sew (insn->rtl ());\n+  enum vlmul_type vlmul = get_vlmul (insn->rtl ());\n+  uint8_t ratio = get_attr_ratio (insn->rtl ());\n+  /* when get_attr_ratio is invalid, this kind of instructions\n+     doesn't care about ratio. However, we still need this value\n+     in demand info backward analysis.  */\n+  if (ratio == INVALID_ATTRIBUTE)\n+    ratio = calculate_ratio (sew, vlmul);\n+  bool ta = tail_agnostic_p (insn->rtl ());\n+  bool ma = mask_agnostic_p (insn->rtl ());\n+\n+  /* If merge operand is undef value, we prefer agnostic.  */\n+  int merge_op_idx = get_attr_merge_op_idx (insn->rtl ());\n+  if (merge_op_idx != INVALID_ATTRIBUTE\n+      && satisfies_constraint_vu (recog_data.operand[merge_op_idx]))\n+    {\n+      ta = true;\n+      ma = true;\n+    }\n+\n+  vl_vtype_info info (avl_info (avl, set), sew, vlmul, ratio, ta, ma);\n+  return info;\n+}\n+\n+static void\n+change_insn (rtx_insn *rinsn, rtx new_pat)\n+{\n+  /* We don't apply change on RTL_SSA here since it's possible a\n+     new INSN we add in the PASS before which doesn't have RTL_SSA\n+     info yet.*/\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nChange PATTERN of insn %d from:\\n\",\n+\t       INSN_UID (rinsn));\n+      print_rtl_single (dump_file, PATTERN (rinsn));\n+    }\n+\n+  validate_change (rinsn, &PATTERN (rinsn), new_pat, true);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nto:\\n\");\n+      print_rtl_single (dump_file, PATTERN (rinsn));\n+    }\n+}\n+\n+static bool\n+change_insn (function_info *ssa, insn_change change, insn_info *insn,\n+\t     rtx new_pat)\n+{\n+  rtx_insn *rinsn = insn->rtl ();\n+  auto attempt = ssa->new_change_attempt ();\n+  if (!restrict_movement (change))\n+    return false;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nChange PATTERN of insn %d from:\\n\",\n+\t       INSN_UID (rinsn));\n+      print_rtl_single (dump_file, PATTERN (rinsn));\n+      if (dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"RTL_SSA info:\\n\");\n+\t  pretty_printer pp;\n+\t  pp.buffer->stream = dump_file;\n+\t  insn->print_full (&pp);\n+\t  pp_printf (&pp, \"\\n\");\n+\t  pp_flush (&pp);\n+\t}\n+    }\n+\n+  insn_change_watermark watermark;\n+  validate_change (rinsn, &PATTERN (rinsn), new_pat, true);\n+\n+  /* These routines report failures themselves.  */\n+  if (!recog (attempt, change) || !change_is_worthwhile (change, false))\n+    return false;\n+  confirm_change_group ();\n+  ssa->change_insn (change);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nto:\\n\");\n+      print_rtl_single (dump_file, PATTERN (rinsn));\n+      if (dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"RTL_SSA info:\\n\");\n+\t  pretty_printer pp;\n+\t  pp.buffer->stream = dump_file;\n+\t  insn->print_full (&pp);\n+\t  pp_printf (&pp, \"\\n\");\n+\t  pp_flush (&pp);\n+\t}\n+    }\n+  return true;\n+}\n+\n+avl_info::avl_info (rtx value_in, set_info *source_in)\n+  : m_value (value_in), m_source (source_in)\n+{}\n+\n+avl_info &\n+avl_info::operator= (const avl_info &other)\n+{\n+  m_value = other.get_value ();\n+  m_source = other.get_source ();\n+  return *this;\n+}\n+\n+bool\n+avl_info::operator== (const avl_info &other) const\n+{\n+  if (!m_value)\n+    return !other.get_value ();\n+  if (!other.get_value ())\n+    return false;\n+\n+  /* It's safe to consider they are equal if their RTX value are\n+     strictly the same.  */\n+  if (m_value == other.get_value ())\n+    return true;\n+\n+  if (GET_CODE (m_value) != GET_CODE (other.get_value ()))\n+    return false;\n+\n+  /* Handle CONST_INT AVL.  */\n+  if (CONST_INT_P (m_value))\n+    return INTVAL (m_value) == INTVAL (other.get_value ());\n+\n+  /* Handle VLMAX AVL.  */\n+  if (vlmax_avl_p (m_value))\n+    return vlmax_avl_p (other.get_value ());\n+\n+  /* TODO: So far we only support VLMAX (AVL=zero) comparison,\n+     we will support non-VLMAX AVL in the future.  */\n+  return false;\n+}\n+\n+bool\n+avl_info::operator!= (const avl_info &other) const\n+{\n+  return !(*this == other);\n+}\n+\n+/* Initialize VL/VTYPE information.  */\n+vl_vtype_info::vl_vtype_info (avl_info avl_in, uint8_t sew_in,\n+\t\t\t      enum vlmul_type vlmul_in, uint8_t ratio_in,\n+\t\t\t      bool ta_in, bool ma_in)\n+  : m_avl (avl_in), m_sew (sew_in), m_vlmul (vlmul_in), m_ratio (ratio_in),\n+    m_ta (ta_in), m_ma (ma_in)\n+{\n+  gcc_assert (valid_sew_p (m_sew) && \"Unexpected SEW\");\n+}\n+\n+bool\n+vl_vtype_info::operator== (const vl_vtype_info &other) const\n+{\n+  return m_avl == other.get_avl_info () && m_sew == other.get_sew ()\n+\t && m_vlmul == other.get_vlmul () && m_ta == other.get_ta ()\n+\t && m_ma == other.get_ma () && m_ratio == other.get_ratio ();\n+}\n+\n+bool\n+vl_vtype_info::operator!= (const vl_vtype_info &other) const\n+{\n+  return !(*this == other);\n+}\n+\n+bool\n+vl_vtype_info::has_non_zero_avl () const\n+{\n+  if (has_avl_imm ())\n+    return INTVAL (get_avl ()) > 0;\n+  if (has_avl_reg ())\n+    return vlmax_avl_p (get_avl ());\n+  return false;\n+}\n+\n+bool\n+vl_vtype_info::same_avl_p (const vl_vtype_info &other) const\n+{\n+  return get_avl_info () == other.get_avl_info ();\n+}\n+\n+bool\n+vl_vtype_info::same_vtype_p (const vl_vtype_info &other) const\n+{\n+  return get_sew () == other.get_sew () && get_vlmul () == other.get_vlmul ()\n+\t && get_ta () == other.get_ta () && get_ma () == other.get_ma ();\n+}\n+\n+bool\n+vl_vtype_info::same_vlmax_p (const vl_vtype_info &other) const\n+{\n+  return get_ratio () == other.get_ratio ();\n+}\n+\n+/* Compare the compatibility between Dem1 and Dem2.\n+   If Dem1 > Dem2, Dem1 has bigger compatibility then Dem2\n+   meaning Dem1 is easier be compatible with others than Dem2\n+   or Dem2 is stricter than Dem1.\n+   For example, Dem1 (demand SEW + LMUL) > Dem2 (demand RATIO).  */\n+bool\n+vector_insn_info::operator> (const vector_insn_info &other) const\n+{\n+  if (other.compatible_p (static_cast<const vl_vtype_info &> (*this))\n+      && !this->compatible_p (static_cast<const vl_vtype_info &> (other)))\n+    return true;\n+  return false;\n+}\n+\n+bool\n+vector_insn_info::operator>= (const vector_insn_info &other) const\n+{\n+  if (*this > other)\n+    return true;\n+\n+  if (*this == other)\n+    return true;\n+\n+  if (!compatible_p (other))\n+    return false;\n+\n+  if (!demand_p (DEMAND_AVL) && other.demand_p (DEMAND_AVL))\n+    return false;\n+\n+  if (same_vlmax_p (other))\n+    {\n+      if (demand_p (DEMAND_RATIO) && !other.demand_p (DEMAND_RATIO)\n+\t  && (get_sew () != other.get_sew ()\n+\t      || get_vlmul () != other.get_vlmul ()))\n+\treturn false;\n+\n+      if (get_sew () == other.get_sew () && get_vlmul () == other.get_vlmul ())\n+\t{\n+\t  if (demand_p (DEMAND_RATIO) && !other.demand_p (DEMAND_RATIO))\n+\t    return false;\n+\t}\n+    }\n+\n+  if (demand_p (DEMAND_TAIL_POLICY) && !other.demand_p (DEMAND_TAIL_POLICY)\n+      && get_ta () != other.get_ta ())\n+    return false;\n+\n+  if (demand_p (DEMAND_MASK_POLICY) && !other.demand_p (DEMAND_MASK_POLICY)\n+      && get_ma () != other.get_ma ())\n+    return false;\n+\n+  return true;\n+}\n+\n+bool\n+vector_insn_info::operator== (const vector_insn_info &other) const\n+{\n+  gcc_assert (!uninit_p () && !other.uninit_p ()\n+\t      && \"Uninitialization should not happen\");\n+\n+  /* Empty is only equal to another Empty.  */\n+  if (empty_p ())\n+    return other.empty_p ();\n+  if (other.empty_p ())\n+    return empty_p ();\n+\n+  /* Unknown is only equal to another Unknown.  */\n+  if (unknown_p ())\n+    return other.unknown_p ();\n+  if (other.unknown_p ())\n+    return unknown_p ();\n+\n+  for (size_t i = 0; i < NUM_DEMAND; i++)\n+    if (m_demands[i] != other.demand_p ((enum demand_type) i))\n+      return false;\n+\n+  if (m_insn != other.get_insn ())\n+    return false;\n+  if (m_dirty_pat != other.get_dirty_pat ())\n+    return false;\n+\n+  if (!same_avl_p (other))\n+    return false;\n+\n+  /* If the full VTYPE is valid, check that it is the same.  */\n+  return same_vtype_p (other);\n+}\n+\n+void\n+vector_insn_info::parse_insn (rtx_insn *rinsn)\n+{\n+  *this = vector_insn_info ();\n+  if (!NONDEBUG_INSN_P (rinsn))\n+    return;\n+  if (!has_vtype_op (rinsn))\n+    return;\n+  m_state = VALID;\n+  extract_insn_cached (rinsn);\n+  const rtx avl = recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+  m_avl = avl_info (avl, nullptr);\n+  m_sew = ::get_sew (rinsn);\n+  m_vlmul = ::get_vlmul (rinsn);\n+  m_ta = tail_agnostic_p (rinsn);\n+  m_ma = mask_agnostic_p (rinsn);\n+}\n+\n+void\n+vector_insn_info::parse_insn (insn_info *insn)\n+{\n+  *this = vector_insn_info ();\n+\n+  /* Return if it is debug insn for the consistency with optimize == 0.  */\n+  if (insn->is_debug_insn ())\n+    return;\n+\n+  /* We set it as unknown since we don't what will happen in CALL or ASM.  */\n+  if (insn->is_call () || insn->is_asm ())\n+    {\n+      set_unknown ();\n+      return;\n+    }\n+\n+  /* If this is something that updates VL/VTYPE that we don't know about, set\n+     the state to unknown.  */\n+  if (!vector_config_insn_p (insn->rtl ())\n+      && (find_access (insn->defs (), VL_REGNUM)\n+\t  || find_access (insn->defs (), VTYPE_REGNUM)))\n+    {\n+      set_unknown ();\n+      return;\n+    }\n+\n+  if (!vector_config_insn_p (insn->rtl ()) && !has_vtype_op (insn->rtl ()))\n+    return;\n+\n+  /* Warning: This function has to work on both the lowered (i.e. post\n+     emit_local_forward_vsetvls) and pre-lowering forms.  The main implication\n+     of this is that it can't use the value of a SEW, VL, or Policy operand as\n+     they might be stale after lowering.  */\n+  vl_vtype_info::operator= (get_vl_vtype_info (insn));\n+  m_insn = insn;\n+  m_state = VALID;\n+  if (vector_config_insn_p (insn->rtl ()))\n+    {\n+      m_demands[DEMAND_AVL] = true;\n+      m_demands[DEMAND_RATIO] = true;\n+      return;\n+    }\n+\n+  if (has_vl_op (insn->rtl ()))\n+    m_demands[DEMAND_AVL] = true;\n+\n+  if (get_attr_ratio (insn->rtl ()) != INVALID_ATTRIBUTE)\n+    m_demands[DEMAND_RATIO] = true;\n+  else\n+    {\n+      /* TODO: By default, if it doesn't demand RATIO, we set it\n+\t demand SEW && LMUL both. Some instructions may demand SEW\n+\t only and ignore LMUL, will fix it later.  */\n+      m_demands[DEMAND_SEW] = true;\n+      m_demands[DEMAND_LMUL] = true;\n+    }\n+\n+  if (get_attr_ta (insn->rtl ()) != INVALID_ATTRIBUTE)\n+    m_demands[DEMAND_TAIL_POLICY] = true;\n+  if (get_attr_ma (insn->rtl ()) != INVALID_ATTRIBUTE)\n+    m_demands[DEMAND_MASK_POLICY] = true;\n+}\n+\n+void\n+vector_insn_info::demand_vl_vtype ()\n+{\n+  m_state = VALID;\n+  m_demands[DEMAND_AVL] = true;\n+  m_demands[DEMAND_SEW] = true;\n+  m_demands[DEMAND_LMUL] = true;\n+  m_demands[DEMAND_TAIL_POLICY] = true;\n+  m_demands[DEMAND_MASK_POLICY] = true;\n+}\n+\n+bool\n+vector_insn_info::compatible_p (const vector_insn_info &other) const\n+{\n+  gcc_assert (valid_or_dirty_p () && other.valid_or_dirty_p ()\n+\t      && \"Can't compare invalid demanded infos\");\n+\n+  /* Check SEW.  */\n+  if (demand_p (DEMAND_SEW) && other.demand_p (DEMAND_SEW)\n+      && get_sew () != other.get_sew ())\n+    return false;\n+\n+  /* Check LMUL.  */\n+  if (demand_p (DEMAND_LMUL) && other.demand_p (DEMAND_LMUL)\n+      && get_vlmul () != other.get_vlmul ())\n+    return false;\n+\n+  /* Check RATIO.  */\n+  if (demand_p (DEMAND_RATIO) && other.demand_p (DEMAND_RATIO)\n+      && get_ratio () != other.get_ratio ())\n+    return false;\n+  if (demand_p (DEMAND_RATIO) && (other.get_sew () || other.get_vlmul ())\n+      && get_ratio () != other.get_ratio ())\n+    return false;\n+  if (other.demand_p (DEMAND_RATIO) && (get_sew () || get_vlmul ())\n+      && get_ratio () != other.get_ratio ())\n+    return false;\n+\n+  if (demand_p (DEMAND_TAIL_POLICY) && other.demand_p (DEMAND_TAIL_POLICY)\n+      && get_ta () != other.get_ta ())\n+    return false;\n+  if (demand_p (DEMAND_MASK_POLICY) && other.demand_p (DEMAND_MASK_POLICY)\n+      && get_ma () != other.get_ma ())\n+    return false;\n+\n+  if (demand_p (DEMAND_AVL) && other.demand_p (DEMAND_AVL))\n+    return m_avl == other.get_avl_info ();\n+\n+  return true;\n+}\n+\n+bool\n+vector_insn_info::compatible_avl_p (const vl_vtype_info &other) const\n+{\n+  gcc_assert (valid_or_dirty_p () && \"Can't compare invalid vl_vtype_info\");\n+  gcc_assert (!unknown_p () && \"Can't compare AVL in unknown state\");\n+  if (!demand_p (DEMAND_AVL))\n+    return true;\n+  return get_avl_info () == other.get_avl_info ();\n+}\n+\n+bool\n+vector_insn_info::compatible_vtype_p (const vl_vtype_info &other) const\n+{\n+  gcc_assert (valid_or_dirty_p () && \"Can't compare invalid vl_vtype_info\");\n+  gcc_assert (!unknown_p () && \"Can't compare VTYPE in unknown state\");\n+  if (demand_p (DEMAND_SEW) && m_sew != other.get_sew ())\n+    return false;\n+  if (demand_p (DEMAND_LMUL) && m_vlmul != other.get_vlmul ())\n+    return false;\n+  if (demand_p (DEMAND_RATIO) && m_ratio != other.get_ratio ())\n+    return false;\n+  if (demand_p (DEMAND_TAIL_POLICY) && m_ta != other.get_ta ())\n+    return false;\n+  if (demand_p (DEMAND_MASK_POLICY) && m_ma != other.get_ma ())\n+    return false;\n+  return true;\n+}\n+\n+/* Determine whether the vector instructions requirements represented by\n+   Require are compatible with the previous vsetvli instruction represented\n+   by this.  INSN is the instruction whose requirements we're considering.  */\n+bool\n+vector_insn_info::compatible_p (const vl_vtype_info &curr_info) const\n+{\n+  gcc_assert (!uninit_p () && \"Can't handle uninitialized info\");\n+  if (empty_p ())\n+    return false;\n+\n+  /* Nothing is compatible with Unknown.  */\n+  if (unknown_p ())\n+    return false;\n+\n+  /* If the instruction doesn't need an AVLReg and the SEW matches, consider\n+     it compatible.  */\n+  if (!demand_p (DEMAND_AVL))\n+    if (m_sew == curr_info.get_sew ())\n+      return true;\n+\n+  return compatible_avl_p (curr_info) && compatible_vtype_p (curr_info);\n+}\n+\n+vector_insn_info\n+vector_insn_info::merge (const vector_insn_info &merge_info,\n+\t\t\t bool across_bb_p = false) const\n+{\n+  gcc_assert (this->compatible_p (merge_info)\n+\t      && \"Can't merge incompatible demanded infos\");\n+\n+  vector_insn_info new_info;\n+  new_info.demand_vl_vtype ();\n+\n+  if (dirty_p ())\n+    {\n+      gcc_assert (across_bb_p);\n+      if (demand_p (DEMAND_AVL))\n+\tnew_info.set_insn (get_insn ());\n+      else\n+\tnew_info.set_insn (merge_info.get_insn ());\n+    }\n+  else\n+    {\n+      if (across_bb_p)\n+\tnew_info.set_insn (get_insn ());\n+      else\n+\tnew_info.set_insn (merge_info.get_insn ());\n+    }\n+\n+  new_info.set_dirty_pat (merge_info.get_dirty_pat ());\n+\n+  if (!demand_p (DEMAND_AVL) && !merge_info.demand_p (DEMAND_AVL))\n+    new_info.undemand (DEMAND_AVL);\n+  if (!demand_p (DEMAND_SEW) && !merge_info.demand_p (DEMAND_SEW))\n+    new_info.undemand (DEMAND_SEW);\n+  if (!demand_p (DEMAND_LMUL) && !merge_info.demand_p (DEMAND_LMUL))\n+    new_info.undemand (DEMAND_LMUL);\n+\n+  if (!demand_p (DEMAND_TAIL_POLICY)\n+      && !merge_info.demand_p (DEMAND_TAIL_POLICY))\n+    new_info.undemand (DEMAND_TAIL_POLICY);\n+  if (!demand_p (DEMAND_MASK_POLICY)\n+      && !merge_info.demand_p (DEMAND_MASK_POLICY))\n+    new_info.undemand (DEMAND_MASK_POLICY);\n+\n+  if (merge_info.demand_p (DEMAND_AVL))\n+    new_info.set_avl_info (merge_info.get_avl_info ());\n+  else if (demand_p (DEMAND_AVL))\n+    new_info.set_avl_info (get_avl_info ());\n+\n+  if (merge_info.demand_p (DEMAND_SEW))\n+    new_info.set_sew (merge_info.get_sew ());\n+  else if (demand_p (DEMAND_SEW))\n+    new_info.set_sew (get_sew ());\n+\n+  if (merge_info.demand_p (DEMAND_LMUL))\n+    new_info.set_vlmul (merge_info.get_vlmul ());\n+  else if (demand_p (DEMAND_LMUL))\n+    new_info.set_vlmul (get_vlmul ());\n+\n+  if (!new_info.demand_p (DEMAND_SEW) && !new_info.demand_p (DEMAND_LMUL))\n+    {\n+      if (demand_p (DEMAND_RATIO) || merge_info.demand_p (DEMAND_RATIO))\n+\tnew_info.demand (DEMAND_RATIO);\n+      /* Even though we don't demand_p SEW && VLMUL in this case, we still\n+       * need them.  */\n+      if (merge_info.demand_p (DEMAND_RATIO))\n+\t{\n+\t  new_info.set_sew (merge_info.get_sew ());\n+\t  new_info.set_vlmul (merge_info.get_vlmul ());\n+\t  new_info.set_ratio (merge_info.get_ratio ());\n+\t}\n+      else if (demand_p (DEMAND_RATIO))\n+\t{\n+\t  new_info.set_sew (get_sew ());\n+\t  new_info.set_vlmul (get_vlmul ());\n+\t  new_info.set_ratio (get_ratio ());\n+\t}\n+    }\n+  else\n+    {\n+      /* when get_attr_ratio is invalid, this kind of instructions\n+\t doesn't care about ratio. However, we still need this value\n+\t in demand_p info backward analysis.  */\n+      new_info.set_ratio (\n+\tcalculate_ratio (new_info.get_sew (), new_info.get_vlmul ()));\n+    }\n+\n+  if (merge_info.demand_p (DEMAND_TAIL_POLICY))\n+    new_info.set_ta (merge_info.get_ta ());\n+  else if (demand_p (DEMAND_TAIL_POLICY))\n+    new_info.set_ta (get_ta ());\n+  else\n+    new_info.set_ta (get_default_ta ());\n+\n+  if (merge_info.demand_p (DEMAND_MASK_POLICY))\n+    new_info.set_ma (merge_info.get_ma ());\n+  else if (demand_p (DEMAND_MASK_POLICY))\n+    new_info.set_ma (get_ma ());\n+  else\n+    new_info.set_ma (get_default_ma ());\n+\n+  return new_info;\n+}\n+\n+void\n+vector_insn_info::dump (FILE *file) const\n+{\n+  fprintf (file, \"[\");\n+  if (uninit_p ())\n+    fprintf (file, \"UNINITIALIZED,\");\n+  else if (valid_p ())\n+    fprintf (file, \"VALID,\");\n+  else if (unknown_p ())\n+    fprintf (file, \"UNKNOWN,\");\n+  else if (empty_p ())\n+    fprintf (file, \"EMPTY,\");\n+  else\n+    fprintf (file, \"DIRTY,\");\n+\n+  fprintf (file, \"Demand field={%d(VL),\", demand_p (DEMAND_AVL));\n+  fprintf (file, \"%d(SEW),\", demand_p (DEMAND_SEW));\n+  fprintf (file, \"%d(LMUL),\", demand_p (DEMAND_LMUL));\n+  fprintf (file, \"%d(RATIO),\", demand_p (DEMAND_RATIO));\n+  fprintf (file, \"%d(TAIL_POLICY),\", demand_p (DEMAND_TAIL_POLICY));\n+  fprintf (file, \"%d(MASK_POLICY)}\\n\", demand_p (DEMAND_MASK_POLICY));\n+\n+  fprintf (file, \"AVL=\");\n+  print_rtl_single (file, get_avl ());\n+  fprintf (file, \"SEW=%d,\", get_sew ());\n+  fprintf (file, \"VLMUL=%d,\", get_vlmul ());\n+  fprintf (file, \"RATIO=%d,\", get_ratio ());\n+  fprintf (file, \"TAIL_POLICY=%d,\", get_ta ());\n+  fprintf (file, \"MASK_POLICY=%d\", get_ma ());\n+  fprintf (file, \"]\\n\");\n+\n+  if (valid_p ())\n+    {\n+      if (get_insn ())\n+\t{\n+\t  fprintf (file, \"RTL_SSA insn_info=\");\n+\t  pretty_printer pp;\n+\t  pp.buffer->stream = file;\n+\t  get_insn ()->print_full (&pp);\n+\t  pp_printf (&pp, \"\\n\");\n+\t  pp_flush (&pp);\n+\t}\n+      if (get_dirty_pat ())\n+\t{\n+\t  fprintf (file, \"Dirty RTL Pattern=\");\n+\t  print_rtl_single (file, get_dirty_pat ());\n+\t}\n+    }\n+}\n+\n+vector_infos_manager::vector_infos_manager ()\n+{\n+  vector_edge_list = nullptr;\n+  vector_kill = nullptr;\n+  vector_del = nullptr;\n+  vector_insert = nullptr;\n+  vector_antic = nullptr;\n+  vector_transp = nullptr;\n+  vector_comp = nullptr;\n+  vector_avin = nullptr;\n+  vector_avout = nullptr;\n+  vector_insn_infos.safe_grow (get_max_uid ());\n+  vector_block_infos.safe_grow (last_basic_block_for_fn (cfun));\n+  if (!optimize)\n+    {\n+      basic_block cfg_bb;\n+      rtx_insn *rinsn;\n+      FOR_ALL_BB_FN (cfg_bb, cfun)\n+\t{\n+\t  vector_block_infos[cfg_bb->index].local_dem = vector_insn_info ();\n+\t  vector_block_infos[cfg_bb->index].reaching_out = vector_insn_info ();\n+\t  FOR_BB_INSNS (cfg_bb, rinsn)\n+\t    vector_insn_infos[INSN_UID (rinsn)].parse_insn (rinsn);\n+\t}\n+    }\n+  else\n+    {\n+      for (const bb_info *bb : crtl->ssa->bbs ())\n+\t{\n+\t  vector_block_infos[bb->index ()].local_dem = vector_insn_info ();\n+\t  vector_block_infos[bb->index ()].reaching_out = vector_insn_info ();\n+\t  for (insn_info *insn : bb->real_insns ())\n+\t    vector_insn_infos[insn->uid ()].parse_insn (insn);\n+\t}\n+    }\n+}\n+\n+void\n+vector_infos_manager::create_expr (vector_insn_info &info)\n+{\n+  for (size_t i = 0; i < vector_exprs.length (); i++)\n+    if (*vector_exprs[i] == info)\n+      return;\n+  vector_exprs.safe_push (&info);\n+}\n+\n+size_t\n+vector_infos_manager::get_expr_id (const vector_insn_info &info) const\n+{\n+  for (size_t i = 0; i < vector_exprs.length (); i++)\n+    if (*vector_exprs[i] == info)\n+      return i;\n+  gcc_unreachable ();\n+}\n+\n+auto_vec<size_t>\n+vector_infos_manager::get_all_available_exprs (\n+  const vector_insn_info &info) const\n+{\n+  auto_vec<size_t> available_list;\n+  for (size_t i = 0; i < vector_exprs.length (); i++)\n+    if (info >= *vector_exprs[i])\n+      available_list.safe_push (i);\n+  return available_list;\n+}\n+\n+bool\n+vector_infos_manager::all_same_ratio_p (sbitmap bitdata) const\n+{\n+  if (bitmap_empty_p (bitdata))\n+    return false;\n+\n+  int ratio = -1;\n+  unsigned int bb_index;\n+  sbitmap_iterator sbi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (bitdata, 0, bb_index, sbi)\n+  {\n+    if (ratio == -1)\n+      ratio = vector_exprs[bb_index]->get_ratio ();\n+    else if (vector_exprs[bb_index]->get_ratio () != ratio)\n+      return false;\n+  }\n+  return true;\n+}\n+\n+size_t\n+vector_infos_manager::expr_set_num (sbitmap bitdata) const\n+{\n+  size_t count = 0;\n+  for (size_t i = 0; i < vector_exprs.length (); i++)\n+    if (bitmap_bit_p (bitdata, i))\n+      count++;\n+  return count;\n+}\n+\n+void\n+vector_infos_manager::release (void)\n+{\n+  if (!vector_insn_infos.is_empty ())\n+    vector_insn_infos.release ();\n+  if (!vector_block_infos.is_empty ())\n+    vector_block_infos.release ();\n+  if (!vector_exprs.is_empty ())\n+    vector_exprs.release ();\n+\n+  if (optimize > 0)\n+    {\n+      /* Finished. Free up all the things we've allocated.  */\n+      free_edge_list (vector_edge_list);\n+      sbitmap_vector_free (vector_del);\n+      sbitmap_vector_free (vector_insert);\n+      sbitmap_vector_free (vector_kill);\n+      sbitmap_vector_free (vector_antic);\n+      sbitmap_vector_free (vector_transp);\n+      sbitmap_vector_free (vector_comp);\n+      sbitmap_vector_free (vector_avin);\n+      sbitmap_vector_free (vector_avout);\n+    }\n+}\n+\n+void\n+vector_infos_manager::dump (FILE *file) const\n+{\n+  basic_block cfg_bb;\n+  rtx_insn *rinsn;\n+\n+  fprintf (file, \"\\n\");\n+  FOR_ALL_BB_FN (cfg_bb, cfun)\n+    {\n+      fprintf (file, \"Local vector info of <bb %d>:\\n\", cfg_bb->index);\n+      fprintf (file, \"<HEADER>=\");\n+      vector_block_infos[cfg_bb->index].local_dem.dump (file);\n+      FOR_BB_INSNS (cfg_bb, rinsn)\n+\t{\n+\t  if (!NONDEBUG_INSN_P (rinsn) || !has_vtype_op (rinsn))\n+\t    continue;\n+\t  fprintf (file, \"<insn %d>=\", INSN_UID (rinsn));\n+\t  const auto &info = vector_insn_infos[INSN_UID (rinsn)];\n+\t  info.dump (file);\n+\t}\n+      fprintf (file, \"<FOOTER>=\");\n+      vector_block_infos[cfg_bb->index].reaching_out.dump (file);\n+      fprintf (file, \"\\n\\n\");\n+    }\n+\n+  fprintf (file, \"\\n\");\n+  FOR_ALL_BB_FN (cfg_bb, cfun)\n+    {\n+      fprintf (file, \"Local properties of <bb %d>:\\n\", cfg_bb->index);\n+\n+      fprintf (file, \"<ANTLOC>=\");\n+      if (vector_antic == nullptr)\n+\tfprintf (file, \"(nil)\\n\");\n+      else\n+\tdump_bitmap_file (file, vector_antic[cfg_bb->index]);\n+\n+      fprintf (file, \"<AVLOC>=\");\n+      if (vector_comp == nullptr)\n+\tfprintf (file, \"(nil)\\n\");\n+      else\n+\tdump_bitmap_file (file, vector_comp[cfg_bb->index]);\n+\n+      fprintf (file, \"<TRANSP>=\");\n+      if (vector_transp == nullptr)\n+\tfprintf (file, \"(nil)\\n\");\n+      else\n+\tdump_bitmap_file (file, vector_transp[cfg_bb->index]);\n+\n+      fprintf (file, \"<KILL>=\");\n+      if (vector_kill == nullptr)\n+\tfprintf (file, \"(nil)\\n\");\n+      else\n+\tdump_bitmap_file (file, vector_kill[cfg_bb->index]);\n+    }\n+\n+  fprintf (file, \"\\n\");\n+  FOR_ALL_BB_FN (cfg_bb, cfun)\n+    {\n+      fprintf (file, \"Global LCM (Lazy code motion) result of <bb %d>:\\n\",\n+\t       cfg_bb->index);\n+\n+      fprintf (file, \"<AVIN>=\");\n+      if (vector_avin == nullptr)\n+\tfprintf (file, \"(nil)\\n\");\n+      else\n+\tdump_bitmap_file (file, vector_avin[cfg_bb->index]);\n+\n+      fprintf (file, \"<AVOUT>=\");\n+      if (vector_avout == nullptr)\n+\tfprintf (file, \"(nil)\\n\");\n+      else\n+\tdump_bitmap_file (file, vector_avout[cfg_bb->index]);\n+\n+      fprintf (file, \"<DELETE>=\");\n+      if (vector_del == nullptr)\n+\tfprintf (file, \"(nil)\\n\");\n+      else\n+\tdump_bitmap_file (file, vector_del[cfg_bb->index]);\n+    }\n+\n+  fprintf (file, \"\\nGlobal LCM (Lazy code motion) INSERT info:\\n\");\n+  for (size_t i = 0; i < vector_exprs.length (); i++)\n+    {\n+      for (int ed = 0; ed < NUM_EDGES (vector_edge_list); ed++)\n+\t{\n+\t  edge eg = INDEX_EDGE (vector_edge_list, ed);\n+\t  if (bitmap_bit_p (vector_insert[ed], i))\n+\t    fprintf (dump_file,\n+\t\t     \"INSERT edge %d from bb %d to bb %d for VSETVL \"\n+\t\t     \"expr[%ld]\\n\",\n+\t\t     ed, eg->src->index, eg->dest->index, i);\n+\t}\n+    }\n+}\n+\n+const pass_data pass_data_vsetvl = {\n+  RTL_PASS,\t /* type */\n+  \"vsetvl\",\t /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE,\t /* tv_id */\n+  0,\t\t /* properties_required */\n+  0,\t\t /* properties_provided */\n+  0,\t\t /* properties_destroyed */\n+  0,\t\t /* todo_flags_start */\n+  0,\t\t /* todo_flags_finish */\n+};\n+\n+class pass_vsetvl : public rtl_opt_pass\n+{\n+private:\n+  class vector_infos_manager *m_vector_manager;\n+\n+  void simple_vsetvl (void) const;\n+  void lazy_vsetvl (void);\n+\n+  /* Phase 1.  */\n+  void compute_local_backward_infos (const bb_info *);\n+\n+  /* Phase 2.  */\n+  bool need_vsetvl (const vector_insn_info &, const vector_insn_info &) const;\n+  void transfer_before (vector_insn_info &, insn_info *) const;\n+  void transfer_after (vector_insn_info &, insn_info *) const;\n+  void emit_local_forward_vsetvls (const bb_info *);\n+\n+  /* Phase 3.  */\n+  void merge_successors (const basic_block, const basic_block);\n+  void compute_global_backward_infos (void);\n+\n+  /* Phase 4.  */\n+  void prune_expressions (void);\n+  void compute_local_properties (void);\n+  bool can_refine_vsetvl_p (const basic_block, uint8_t) const;\n+  void refine_vsetvls (void) const;\n+  void cleanup_vsetvls (void);\n+  bool commit_vsetvls (void);\n+  void pre_vsetvl (void);\n+\n+  /* Phase 5.  */\n+  void cleanup_insns (void) const;\n+\n+  void init (void);\n+  void done (void);\n+\n+public:\n+  pass_vsetvl (gcc::context *ctxt) : rtl_opt_pass (pass_data_vsetvl, ctxt) {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) final override { return TARGET_VECTOR; }\n+  virtual unsigned int execute (function *) final override;\n+}; // class pass_vsetvl\n+\n+/* Simple m_vsetvl_insert vsetvl for optimize == 0.  */\n+void\n+pass_vsetvl::simple_vsetvl (void) const\n+{\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nEntering Simple VSETVL PASS and Handling %d basic blocks for \"\n+\t     \"function:%s\\n\",\n+\t     n_basic_blocks_for_fn (cfun), function_name (cfun));\n+\n+  basic_block cfg_bb;\n+  rtx_insn *rinsn;\n+  FOR_ALL_BB_FN (cfg_bb, cfun)\n+    {\n+      FOR_BB_INSNS (cfg_bb, rinsn)\n+\t{\n+\t  if (!NONDEBUG_INSN_P (rinsn))\n+\t    continue;\n+\t  if (has_vtype_op (rinsn))\n+\t    {\n+\t      const auto info\n+\t\t= m_vector_manager->vector_insn_infos[INSN_UID (rinsn)];\n+\t      emit_vsetvl_insn (VSETVL_DISCARD_RESULT, EMIT_BEFORE, info,\n+\t\t\t\tNULL_RTX, rinsn);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Compute demanded information by backward data-flow analysis.  */\n+void\n+pass_vsetvl::compute_local_backward_infos (const bb_info *bb)\n+{\n+  vector_insn_info change;\n+  change.set_empty ();\n+\n+  auto &block_info = m_vector_manager->vector_block_infos[bb->index ()];\n+  block_info.reaching_out = change;\n+\n+  for (insn_info *insn : bb->reverse_real_nondebug_insns ())\n+    {\n+      auto &info = m_vector_manager->vector_insn_infos[insn->uid ()];\n+\n+      if (info.uninit_p ())\n+\t/* If it is uninitialized, propagate it directly.  */\n+\tinfo = change;\n+      else if (info.unknown_p ())\n+\tchange = info;\n+      else\n+\t{\n+\t  gcc_assert (info.valid_p () && \"Unexpected Invalid demanded info\");\n+\t  if (change.valid_p () && change.compatible_p (info))\n+\t    info = change.merge (info);\n+\t  change = info;\n+\t}\n+    }\n+\n+  block_info.local_dem = change;\n+  if (block_info.local_dem.empty_p ())\n+    block_info.reaching_out = block_info.local_dem;\n+}\n+\n+/* Return true if a dem_info is required to transition from curr_info to\n+   require before INSN.  */\n+bool\n+pass_vsetvl::need_vsetvl (const vector_insn_info &require,\n+\t\t\t  const vector_insn_info &curr_info) const\n+{\n+  if (!curr_info.valid_p () || curr_info.unknown_p () || curr_info.uninit_p ())\n+    return true;\n+\n+  if (require.compatible_p (curr_info))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Given an incoming state reaching INSN, modifies that state so that it is\n+   minimally compatible with INSN.  The resulting state is guaranteed to be\n+   semantically legal for INSN, but may not be the state requested by INSN.  */\n+void\n+pass_vsetvl::transfer_before (vector_insn_info &info, insn_info *insn) const\n+{\n+  if (!has_vtype_op (insn->rtl ()))\n+    return;\n+\n+  const vector_insn_info require\n+    = m_vector_manager->vector_insn_infos[insn->uid ()];\n+  if (info.valid_p () && !need_vsetvl (require, info))\n+    return;\n+  info = require;\n+}\n+\n+/* Given a state with which we evaluated insn (see transfer_before above for why\n+   this might be different that the state insn requested), modify the state to\n+   reflect the changes insn might make.  */\n+void\n+pass_vsetvl::transfer_after (vector_insn_info &info, insn_info *insn) const\n+{\n+  if (vector_config_insn_p (insn->rtl ()))\n+    {\n+      info = m_vector_manager->vector_insn_infos[insn->uid ()];\n+      return;\n+    }\n+\n+  /* TODO: Support fault first load info update VL in the future.  */\n+\n+  /* If this is something that updates VL/VTYPE that we don't know about, set\n+     the state to unknown.  */\n+  if (insn->is_call () || insn->is_asm ()\n+      || find_access (insn->defs (), VL_REGNUM)\n+      || find_access (insn->defs (), VTYPE_REGNUM))\n+    info = vector_insn_info::get_unknown ();\n+}\n+\n+/* Emit vsetvl within each block by forward data-flow analysis.  */\n+void\n+pass_vsetvl::emit_local_forward_vsetvls (const bb_info *bb)\n+{\n+  auto &block_info = m_vector_manager->vector_block_infos[bb->index ()];\n+  if (block_info.local_dem.empty_p ())\n+    return;\n+\n+  vector_insn_info curr_info;\n+  for (insn_info *insn : bb->real_nondebug_insns ())\n+    {\n+      const vector_insn_info prev_info = curr_info;\n+      transfer_before (curr_info, insn);\n+\n+      if (has_vtype_op (insn->rtl ()))\n+\t{\n+\t  if (static_cast<const vl_vtype_info &> (prev_info)\n+\t      != static_cast<const vl_vtype_info &> (curr_info))\n+\t    {\n+\t      const auto require\n+\t\t= m_vector_manager->vector_insn_infos[insn->uid ()];\n+\t      if (!require.compatible_p (\n+\t\t    static_cast<const vl_vtype_info &> (prev_info)))\n+\t\tinsert_vsetvl (EMIT_BEFORE, insn->rtl (), require, prev_info);\n+\t    }\n+\t}\n+\n+      transfer_after (curr_info, insn);\n+    }\n+\n+  block_info.reaching_out = curr_info;\n+}\n+\n+/* Merge all successors of Father except child node.  */\n+void\n+pass_vsetvl::merge_successors (const basic_block father,\n+\t\t\t       const basic_block child)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  auto &father_info = m_vector_manager->vector_block_infos[father->index];\n+  gcc_assert (father_info.local_dem.dirty_p ()\n+\t      || father_info.local_dem.empty_p ());\n+  gcc_assert (father_info.reaching_out.dirty_p ()\n+\t      || father_info.reaching_out.empty_p ());\n+\n+  FOR_EACH_EDGE (e, ei, father->succs)\n+    {\n+      const basic_block succ = e->dest;\n+      if (succ->index == child->index)\n+\tcontinue;\n+\n+      const auto succ_info\n+\t= m_vector_manager->vector_block_infos[succ->index].local_dem;\n+\n+      if (!succ_info.valid_p ())\n+\tcontinue;\n+\n+      vector_insn_info new_info;\n+      if (father_info.reaching_out.dirty_p ())\n+\t{\n+\t  if (!father_info.reaching_out.compatible_p (succ_info))\n+\t    continue;\n+\n+\t  new_info = succ_info.merge (father_info.reaching_out, true);\n+\t}\n+      else\n+\tnew_info = succ_info;\n+\n+      new_info.set_dirty ();\n+      rtx new_pat = gen_vsetvl_pat (new_info.get_insn ()->rtl (), new_info);\n+      new_info.set_dirty_pat (new_pat);\n+\n+      father_info.local_dem = new_info;\n+      father_info.reaching_out = new_info;\n+    }\n+}\n+\n+/* Compute global backward demanded info.  */\n+void\n+pass_vsetvl::compute_global_backward_infos (void)\n+{\n+  /* We compute global infos by backward propagation.\n+     We want to have better performance in these following cases:\n+\n+\t1. for (size_t i = 0; i < n; i++) {\n+\t     if (i != cond) {\n+\t       vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+\t       *(vint8mf8_t*)(out + i + 100) = v;\n+\t     } else {\n+\t       vbool1_t v = *(vbool1_t*)(in + i + 400);\n+\t       *(vbool1_t*)(out + i + 400) = v;\n+\t     }\n+\t   }\n+\n+\t   Since we don't have any RVV instruction in the BEFORE blocks,\n+\t   LCM fails to optimize such case. We want to backward propagate\n+\t   them into empty blocks so that we could have better performance\n+\t   in LCM.\n+\n+\t2. bb 0:\n+\t     vsetvl e8,mf8 (demand RATIO)\n+\t   bb 1:\n+\t     vsetvl e32,mf2 (demand SEW and LMUL)\n+\t   We backward propagate the first VSETVL into e32,mf2 so that we\n+\t   could be able to eliminate the second VSETVL in LCM.  */\n+\n+  for (const bb_info *bb : crtl->ssa->reverse_bbs ())\n+    {\n+      basic_block cfg_bb = bb->cfg_bb ();\n+      const auto &prop\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index].local_dem;\n+\n+      /* If there is nothing to propagate, just skip it.  */\n+      if (!prop.valid_or_dirty_p ())\n+\tcontinue;\n+\n+      if (!backward_propagate_worthwhile_p (\n+\t    cfg_bb, m_vector_manager->vector_block_infos[cfg_bb->index]))\n+\tcontinue;\n+\n+      edge e;\n+      edge_iterator ei;\n+      /* Backward propagate to each predecessor.  */\n+      FOR_EACH_EDGE (e, ei, cfg_bb->preds)\n+\t{\n+\t  rtx new_pat;\n+\t  auto &block_info\n+\t    = m_vector_manager->vector_block_infos[e->src->index];\n+\n+\t  /* We don't propagate through critical edges.  */\n+\t  if (e->flags & EDGE_COMPLEX)\n+\t    continue;\n+\t  if (e->src->index == ENTRY_BLOCK_PTR_FOR_FN (cfun)->index)\n+\t    continue;\n+\n+\t  if (block_info.reaching_out.unknown_p ())\n+\t    continue;\n+\t  else if (block_info.reaching_out.empty_p ())\n+\t    {\n+\t      if (!can_backward_propagate_p (crtl->ssa, e->src, prop))\n+\t\tcontinue;\n+\n+\t      if (dominate_probability_p (e))\n+\t\t{\n+\t\t  rtx new_pat = gen_vsetvl_pat (prop.get_insn ()->rtl (), prop);\n+\n+\t\t  block_info.reaching_out = prop;\n+\t\t  block_info.reaching_out.set_dirty ();\n+\t\t  block_info.reaching_out.set_dirty_pat (new_pat);\n+\t\t  block_info.local_dem = block_info.reaching_out;\n+\t\t}\n+\n+\t      merge_successors (e->src, cfg_bb);\n+\t    }\n+\t  else if (block_info.reaching_out.dirty_p ())\n+\t    {\n+\t      /* DIRTY -> DIRTY or VALID -> DIRTY.  */\n+\t      vector_insn_info new_info;\n+\n+\t      if (block_info.reaching_out.compatible_p (prop))\n+\t\t{\n+\t\t  if (block_info.reaching_out >= prop)\n+\t\t    continue;\n+\t\t  new_info = block_info.reaching_out.merge (prop, true);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (dominate_probability_p (e))\n+\t\t    new_info = prop;\n+\t\t  else\n+\t\t    continue;\n+\t\t}\n+\n+\t      rtx new_pat\n+\t\t= gen_vsetvl_pat (new_info.get_insn ()->rtl (), new_info);\n+\t      new_info.set_dirty ();\n+\t      new_info.set_dirty_pat (new_pat);\n+\t      block_info.local_dem = new_info;\n+\t      block_info.reaching_out = new_info;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We not only change the info during backward propagation,\n+\t\t but also change the VSETVL instruction.  */\n+\t      gcc_assert (block_info.reaching_out.valid_p ());\n+\t      if (!block_info.reaching_out.compatible_p (prop))\n+\t\tcontinue;\n+\t      if (block_info.reaching_out >= prop)\n+\t\tcontinue;\n+\n+\t      vector_insn_info be_merged = block_info.reaching_out;\n+\t      if (block_info.local_dem == block_info.reaching_out)\n+\t\tbe_merged = block_info.local_dem;\n+\t      vector_insn_info new_info = be_merged.merge (prop, true);\n+\n+\t      rtx_insn *rinsn;\n+\t      if (vector_config_insn_p (new_info.get_insn ()->rtl ()))\n+\t\t{\n+\t\t  rinsn = new_info.get_insn ()->rtl ();\n+\t\t  gcc_assert (vsetvl_insn_p (rinsn)\n+\t\t\t      && \"Can't handle X0, rs1 vsetvli yet\");\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (has_vtype_op (new_info.get_insn ()->rtl ()));\n+\t\t  rinsn = PREV_INSN (new_info.get_insn ()->rtl ());\n+\t\t  gcc_assert (vector_config_insn_p (rinsn));\n+\t\t}\n+\t      new_pat = gen_vsetvl_pat (rinsn, new_info);\n+\t      change_insn (rinsn, new_pat);\n+\t      if (block_info.local_dem == block_info.reaching_out)\n+\t\tblock_info.local_dem = new_info;\n+\t      block_info.reaching_out = new_info;\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n\\nDirty blocks list: \");\n+      for (size_t i = 0; i < m_vector_manager->vector_block_infos.length ();\n+\t   i++)\n+\t{\n+\t  if (m_vector_manager->vector_block_infos[i].reaching_out.dirty_p ())\n+\t    fprintf (dump_file, \"%ld \", i);\n+\t}\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+}\n+\n+/* Assemble the candidates expressions for LCM.  */\n+void\n+pass_vsetvl::prune_expressions (void)\n+{\n+  for (size_t i = 0; i < m_vector_manager->vector_block_infos.length (); i++)\n+    {\n+      if (m_vector_manager->vector_block_infos[i].local_dem.valid_or_dirty_p ())\n+\tm_vector_manager->create_expr (\n+\t  m_vector_manager->vector_block_infos[i].local_dem);\n+      if (m_vector_manager->vector_block_infos[i]\n+\t    .reaching_out.valid_or_dirty_p ())\n+\tm_vector_manager->create_expr (\n+\t  m_vector_manager->vector_block_infos[i].reaching_out);\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nThe total VSETVL expression num = %d\\n\",\n+\t       m_vector_manager->vector_exprs.length ());\n+      fprintf (dump_file, \"Expression List:\\n\");\n+      for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n+\t{\n+\t  fprintf (dump_file, \"Expr[%ld]:\\n\", i);\n+\t  m_vector_manager->vector_exprs[i]->dump (dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+}\n+\n+void\n+pass_vsetvl::compute_local_properties (void)\n+{\n+  /* -  If T is locally available at the end of a block, then T' must be\n+\tavailable at the end of the same block. Since some optimization has\n+\toccurred earlier, T' might not be locally available, however, it must\n+\thave been previously computed on all paths. As a formula, T at AVLOC(B)\n+\timplies that T' at AVOUT(B).\n+\tAn \"available occurrence\" is one that is the last occurrence in the\n+\tbasic block and the operands are not modified by following statements in\n+\tthe basic block [including this insn].\n+\n+     -  If T is locally anticipated at the beginning of a block, then either\n+\tT', is locally anticipated or it is already available from previous\n+\tblocks. As a formula, this means that T at ANTLOC(B) implies that T' at\n+\tANTLOC(B) at AVIN(B).\n+\tAn \"anticipatable occurrence\" is one that is the first occurrence in the\n+\tbasic block, the operands are not modified in the basic block prior\n+\tto the occurrence and the output is not used between the start of\n+\tthe block and the occurrence.  */\n+\n+  basic_block cfg_bb;\n+  FOR_EACH_BB_FN (cfg_bb, cfun)\n+    {\n+      int curr_bb_idx = cfg_bb->index;\n+      const auto local_dem\n+\t= m_vector_manager->vector_block_infos[curr_bb_idx].local_dem;\n+      const auto reaching_out\n+\t= m_vector_manager->vector_block_infos[curr_bb_idx].reaching_out;\n+\n+      if (!local_dem.empty_p ())\n+\t{\n+\t  for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n+\t    bitmap_clear_bit (m_vector_manager->vector_transp[curr_bb_idx], i);\n+\t}\n+\n+      if (local_dem.valid_or_dirty_p ())\n+\t{\n+\t  const insn_info *header_insn = local_dem.get_insn ();\n+\t  size_t header_index = m_vector_manager->get_expr_id (local_dem);\n+\t  if (anticipatable_occurrence_p (header_insn, local_dem))\n+\t    bitmap_set_bit (m_vector_manager->vector_antic[curr_bb_idx],\n+\t\t\t    header_index);\n+\t}\n+\n+      if (reaching_out.valid_or_dirty_p ())\n+\t{\n+\t  const insn_info *footer_insn = reaching_out.get_insn ();\n+\t  size_t footer_index = m_vector_manager->get_expr_id (reaching_out);\n+\t  if (available_occurrence_p (footer_insn, reaching_out))\n+\t    bitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n+\t\t\t    footer_index);\n+\t  auto_vec<size_t> available_list\n+\t    = m_vector_manager->get_all_available_exprs (reaching_out);\n+\t  for (size_t i = 0; i < available_list.length (); i++)\n+\t    bitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n+\t\t\t    available_list[i]);\n+\t}\n+    }\n+\n+  /* Compute kill for each basic block using:\n+\n+     ~(TRANSP | COMP)\n+  */\n+\n+  FOR_EACH_BB_FN (cfg_bb, cfun)\n+    {\n+      bitmap_ior (m_vector_manager->vector_kill[cfg_bb->index],\n+\t\t  m_vector_manager->vector_transp[cfg_bb->index],\n+\t\t  m_vector_manager->vector_comp[cfg_bb->index]);\n+      bitmap_not (m_vector_manager->vector_kill[cfg_bb->index],\n+\t\t  m_vector_manager->vector_kill[cfg_bb->index]);\n+    }\n+\n+  FOR_EACH_BB_FN (cfg_bb, cfun)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      /* If the current block is the destination of an abnormal edge, we\n+\t kill all trapping (for PRE) and memory (for hoist) expressions\n+\t because we won't be able to properly place the instruction on\n+\t the edge.  So make them neither anticipatable nor transparent.\n+\t This is fairly conservative.\n+\n+\t ??? For hoisting it may be necessary to check for set-and-jump\n+\t instructions here, not just for abnormal edges.  The general problem\n+\t is that when an expression cannot not be placed right at the end of\n+\t a basic block we should account for any side-effects of a subsequent\n+\t jump instructions that could clobber the expression.  It would\n+\t be best to implement this check along the lines of\n+\t should_hoist_expr_to_dom where the target block is already known\n+\t and, hence, there's no need to conservatively prune expressions on\n+\t \"intermediate\" set-and-jump instructions.  */\n+      FOR_EACH_EDGE (e, ei, cfg_bb->preds)\n+\tif (e->flags & EDGE_COMPLEX)\n+\t  {\n+\t    bitmap_clear (m_vector_manager->vector_antic[cfg_bb->index]);\n+\t    bitmap_clear (m_vector_manager->vector_transp[cfg_bb->index]);\n+\t  }\n+    }\n+}\n+\n+/* Return true if VSETVL in the block can be refined as vsetvl zero,zero.  */\n+bool\n+pass_vsetvl::can_refine_vsetvl_p (const basic_block cfg_bb, uint8_t ratio) const\n+{\n+  if (!m_vector_manager->all_same_ratio_p (\n+\tm_vector_manager->vector_avin[cfg_bb->index]))\n+    return false;\n+\n+  size_t expr_id\n+    = bitmap_first_set_bit (m_vector_manager->vector_avin[cfg_bb->index]);\n+  if (m_vector_manager->vector_exprs[expr_id]->get_ratio () != ratio)\n+    return false;\n+\n+  edge e;\n+  edge_iterator ei;\n+  bool all_valid_p = true;\n+  FOR_EACH_EDGE (e, ei, cfg_bb->preds)\n+    {\n+      if (bitmap_empty_p (m_vector_manager->vector_avout[e->src->index]))\n+\t{\n+\t  all_valid_p = false;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!all_valid_p)\n+    return false;\n+  return true;\n+}\n+\n+/* Optimize athe case like this:\n+\n+      bb 0:\n+\tvsetvl 0 a5,zero,e8,mf8\n+\tinsn 0 (demand SEW + LMUL)\n+      bb 1:\n+\tvsetvl 1 a5,zero,e16,mf4\n+\tinsn 1 (demand SEW + LMUL)\n+\n+   In this case, we should be able to refine\n+   vsetvl 1 into vsetvl zero, zero according AVIN.  */\n+void\n+pass_vsetvl::refine_vsetvls (void) const\n+{\n+  basic_block cfg_bb;\n+  FOR_EACH_BB_FN (cfg_bb, cfun)\n+    {\n+      auto info = m_vector_manager->vector_block_infos[cfg_bb->index].local_dem;\n+      insn_info *insn = info.get_insn ();\n+      if (!info.valid_p ())\n+\tcontinue;\n+\n+      rtx_insn *rinsn = insn->rtl ();\n+      if (!can_refine_vsetvl_p (cfg_bb, info.get_ratio ()))\n+\tcontinue;\n+\n+      if (!vector_config_insn_p (rinsn))\n+\trinsn = PREV_INSN (rinsn);\n+      rtx new_pat = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, info, NULL_RTX);\n+      change_insn (rinsn, new_pat);\n+    }\n+}\n+\n+void\n+pass_vsetvl::cleanup_vsetvls ()\n+{\n+  basic_block cfg_bb;\n+  FOR_EACH_BB_FN (cfg_bb, cfun)\n+    {\n+      auto &info\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out;\n+      gcc_assert (m_vector_manager->expr_set_num (\n+\t\t    m_vector_manager->vector_del[cfg_bb->index])\n+\t\t  <= 1);\n+      for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n+\t{\n+\t  if (bitmap_bit_p (m_vector_manager->vector_del[cfg_bb->index], i))\n+\t    {\n+\t      if (info.dirty_p ())\n+\t\tinfo.set_unknown ();\n+\t      else\n+\t\t{\n+\t\t  insn_info *insn\n+\t\t    = m_vector_manager->vector_exprs[i]->get_insn ();\n+\t\t  gcc_assert (insn && insn->rtl ());\n+\t\t  rtx_insn *rinsn;\n+\t\t  if (vector_config_insn_p (insn->rtl ()))\n+\t\t    rinsn = insn->rtl ();\n+\t\t  else\n+\t\t    {\n+\t\t      gcc_assert (has_vtype_op (insn->rtl ()));\n+\t\t      rinsn = PREV_INSN (insn->rtl ());\n+\t\t      gcc_assert (\n+\t\t\tvector_config_insn_p (PREV_INSN (insn->rtl ())));\n+\t\t    }\n+\t\t  eliminate_insn (rinsn);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+bool\n+pass_vsetvl::commit_vsetvls (void)\n+{\n+  bool need_commit = false;\n+\n+  for (int ed = 0; ed < NUM_EDGES (m_vector_manager->vector_edge_list); ed++)\n+    {\n+      for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n+\t{\n+\t  edge eg = INDEX_EDGE (m_vector_manager->vector_edge_list, ed);\n+\t  if (bitmap_bit_p (m_vector_manager->vector_insert[ed], i))\n+\t    {\n+\t      const vector_insn_info *require\n+\t\t= m_vector_manager->vector_exprs[i];\n+\t      gcc_assert (require->valid_or_dirty_p ());\n+\t      rtl_profile_for_edge (eg);\n+\t      start_sequence ();\n+\n+\t      insn_info *insn = require->get_insn ();\n+\t      vector_insn_info prev_info = vector_insn_info ();\n+\t      if (m_vector_manager->all_same_ratio_p (\n+\t\t    m_vector_manager->vector_avout[eg->src->index]))\n+\t\t{\n+\t\t  size_t first = bitmap_first_set_bit (\n+\t\t    m_vector_manager->vector_avout[eg->src->index]);\n+\t\t  prev_info = *m_vector_manager->vector_exprs[first];\n+\t\t}\n+\n+\t      insert_vsetvl (EMIT_DIRECT, insn->rtl (), *require, prev_info);\n+\t      rtx_insn *rinsn = get_insns ();\n+\t      end_sequence ();\n+\t      default_rtl_profile ();\n+\n+\t      /* We should not get an abnormal edge here.  */\n+\t      gcc_assert (!(eg->flags & EDGE_ABNORMAL));\n+\t      need_commit = true;\n+\t      insert_insn_on_edge (rinsn, eg);\n+\t    }\n+\t}\n+    }\n+\n+  basic_block cfg_bb;\n+  FOR_EACH_BB_FN (cfg_bb, cfun)\n+    {\n+      const auto reaching_out\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out;\n+      if (!reaching_out.dirty_p ())\n+\tcontinue;\n+\n+      rtx new_pat = reaching_out.get_dirty_pat ();\n+      if (can_refine_vsetvl_p (cfg_bb, reaching_out.get_ratio ()))\n+\tnew_pat\n+\t  = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, reaching_out, NULL_RTX);\n+\n+      start_sequence ();\n+      emit_insn (new_pat);\n+      rtx_insn *rinsn = get_insns ();\n+      end_sequence ();\n+      insert_insn_end_basic_block (rinsn, cfg_bb);\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"\\nInsert vsetvl insn %d at the end of <bb %d>:\\n\",\n+\t\t   INSN_UID (rinsn), cfg_bb->index);\n+\t  print_rtl_single (dump_file, rinsn);\n+\t}\n+    }\n+\n+  return need_commit;\n+}\n+\n+void\n+pass_vsetvl::pre_vsetvl (void)\n+{\n+  /* Compute entity list.  */\n+  prune_expressions ();\n+\n+  /* Create the bitmap vectors.  */\n+  m_vector_manager->vector_antic\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    m_vector_manager->vector_exprs.length ());\n+  m_vector_manager->vector_transp\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    m_vector_manager->vector_exprs.length ());\n+  m_vector_manager->vector_comp\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    m_vector_manager->vector_exprs.length ());\n+  m_vector_manager->vector_avin\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    m_vector_manager->vector_exprs.length ());\n+  m_vector_manager->vector_avout\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    m_vector_manager->vector_exprs.length ());\n+  m_vector_manager->vector_kill\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    m_vector_manager->vector_exprs.length ());\n+\n+  bitmap_vector_ones (m_vector_manager->vector_transp,\n+\t\t      last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (m_vector_manager->vector_antic,\n+\t\t       last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (m_vector_manager->vector_comp,\n+\t\t       last_basic_block_for_fn (cfun));\n+  compute_local_properties ();\n+  m_vector_manager->vector_edge_list = pre_edge_lcm_avs (\n+    m_vector_manager->vector_exprs.length (), m_vector_manager->vector_transp,\n+    m_vector_manager->vector_comp, m_vector_manager->vector_antic,\n+    m_vector_manager->vector_kill, m_vector_manager->vector_avin,\n+    m_vector_manager->vector_avout, &m_vector_manager->vector_insert,\n+    &m_vector_manager->vector_del);\n+\n+  /* We should dump the information before CFG is changed. Otherwise it will\n+     produce ICE (internal compiler error).  */\n+  if (dump_file)\n+    m_vector_manager->dump (dump_file);\n+\n+  refine_vsetvls ();\n+  cleanup_vsetvls ();\n+  bool need_commit = commit_vsetvls ();\n+  if (need_commit)\n+    commit_edge_insertions ();\n+}\n+\n+void\n+pass_vsetvl::cleanup_insns (void) const\n+{\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    {\n+      for (insn_info *insn : bb->real_nondebug_insns ())\n+\t{\n+\t  rtx_insn *rinsn = insn->rtl ();\n+\n+\t  if (vlmax_avl_insn_p (rinsn))\n+\t    {\n+\t      eliminate_insn (rinsn);\n+\t      continue;\n+\t    }\n+\n+\t  /* Erase the AVL operand from the instruction.  */\n+\t  if (!has_vl_op (rinsn) || !REG_P (get_vl (rinsn)))\n+\t    continue;\n+\t  rtx avl = get_vl (rinsn);\n+\t  if (count_occurrences (PATTERN (rinsn), avl, true) == 1)\n+\t    {\n+\t      /* Get the list of uses for the new instruction.  */\n+\t      auto attempt = crtl->ssa->new_change_attempt ();\n+\t      insn_change change (insn);\n+\t      /* Remove the use of the substituted value.  */\n+\t      access_array_builder uses_builder (attempt);\n+\t      uses_builder.reserve (insn->num_uses () - 1);\n+\t      for (use_info *use : insn->uses ())\n+\t\tif (use != find_access (insn->uses (), REGNO (avl)))\n+\t\t  uses_builder.quick_push (use);\n+\t      use_array new_uses = use_array (uses_builder.finish ());\n+\t      change.new_uses = new_uses;\n+\t      change.move_range = insn->ebb ()->insn_range ();\n+\t      rtx pat = simplify_replace_rtx (PATTERN (rinsn), avl, const0_rtx);\n+\t      gcc_assert (change_insn (crtl->ssa, change, insn, pat));\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+pass_vsetvl::init (void)\n+{\n+  if (optimize > 0)\n+    {\n+      /* Initialization of RTL_SSA.  */\n+      calculate_dominance_info (CDI_DOMINATORS);\n+      df_analyze ();\n+      crtl->ssa = new function_info (cfun);\n+    }\n+\n+  m_vector_manager = new vector_infos_manager ();\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nPrologue: Initialize vector infos\\n\");\n+      m_vector_manager->dump (dump_file);\n+    }\n+}\n+\n+void\n+pass_vsetvl::done (void)\n+{\n+  if (optimize > 0)\n+    {\n+      /* Finalization of RTL_SSA.  */\n+      free_dominance_info (CDI_DOMINATORS);\n+      if (crtl->ssa->perform_pending_updates ())\n+\tcleanup_cfg (0);\n+      delete crtl->ssa;\n+      crtl->ssa = nullptr;\n+    }\n+  m_vector_manager->release ();\n+  delete m_vector_manager;\n+  m_vector_manager = nullptr;\n+}\n+\n+/* Lazy vsetvl insertion for optimize > 0. */\n+void\n+pass_vsetvl::lazy_vsetvl (void)\n+{\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nEntering Lazy VSETVL PASS and Handling %d basic blocks for \"\n+\t     \"function:%s\\n\",\n+\t     n_basic_blocks_for_fn (cfun), function_name (cfun));\n+\n+  /* Phase 1 - Compute the local dems within each block.\n+     The data-flow analysis within each block is backward analysis.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nPhase 1: Compute local backward vector infos\\n\");\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    compute_local_backward_infos (bb);\n+  if (dump_file)\n+    m_vector_manager->dump (dump_file);\n+\n+  /* Phase 2 - Emit vsetvl instructions within each basic block according to\n+     demand, compute and save ANTLOC && AVLOC of each block.  */\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nPhase 2: Emit vsetvl instruction within each block\\n\");\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    emit_local_forward_vsetvls (bb);\n+  if (dump_file)\n+    m_vector_manager->dump (dump_file);\n+\n+  /* Phase 3 - Propagate demanded info across blocks.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nPhase 3: Demands propagation across blocks\\n\");\n+  compute_global_backward_infos ();\n+  if (dump_file)\n+    m_vector_manager->dump (dump_file);\n+\n+  /* Phase 4 - Lazy code motion.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nPhase 4: PRE vsetvl by Lazy code motion (LCM)\\n\");\n+  pre_vsetvl ();\n+\n+  /* Phase 5 - Cleanup AVL && VL operand of RVV instruction.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nPhase 5: Cleanup AVL and VL operands\\n\");\n+  cleanup_insns ();\n+}\n+\n+/* Main entry point for this pass.  */\n+unsigned int\n+pass_vsetvl::execute (function *)\n+{\n+  if (n_basic_blocks_for_fn (cfun) <= 0)\n+    return 0;\n+\n+  /* The reason we have this since we didn't finish splitting yet\n+     when optimize == 0. In this case, we should conservatively\n+     split all instructions here to make sure we don't miss any\n+     RVV instruction.  */\n+  if (!optimize)\n+    split_all_insns ();\n+\n+  /* Early return for there is no vector instructions.  */\n+  if (!has_vector_insn (cfun))\n+    return 0;\n+\n+  init ();\n+\n+  if (!optimize)\n+    simple_vsetvl ();\n+  else\n+    lazy_vsetvl ();\n+\n+  done ();\n+  return 0;\n+}\n+\n+rtl_opt_pass *\n+make_pass_vsetvl (gcc::context *ctxt)\n+{\n+  return new pass_vsetvl (ctxt);\n+}"}, {"sha": "ad9bb27cebf71fee8d84d32dc01433a36d7131e1", "filename": "gcc/config/riscv/riscv-vsetvl.h", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,344 @@\n+/* VSETVL pass header for RISC-V 'V' Extension for GNU compiler.\n+   Copyright(C) 2022-2022 Free Software Foundation, Inc.\n+   Contributed by Juzhe Zhong (juzhe.zhong@rivai.ai), RiVAI Technologies Ltd.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or(at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RISCV_VSETVL_H\n+#define GCC_RISCV_VSETVL_H\n+\n+#define IS_AGNOSTIC(VALUE) (bool) (VALUE & 0x1 || (VALUE >> 1 & 0x1))\n+\n+namespace riscv_vector {\n+\n+/* Classification of vsetvl instruction.  */\n+enum vsetvl_type\n+{\n+  VSETVL_NORMAL,\n+  VSETVL_VTYPE_CHANGE_ONLY,\n+  VSETVL_DISCARD_RESULT,\n+};\n+\n+enum emit_type\n+{\n+  /* emit_insn directly.  */\n+  EMIT_DIRECT,\n+  EMIT_BEFORE,\n+  EMIT_AFTER,\n+};\n+\n+enum demand_type\n+{\n+  DEMAND_AVL,\n+  DEMAND_SEW,\n+  DEMAND_LMUL,\n+  DEMAND_RATIO,\n+  DEMAND_TAIL_POLICY,\n+  DEMAND_MASK_POLICY,\n+  NUM_DEMAND\n+};\n+\n+/* AVL info for RVV instruction. Most RVV instructions have AVL operand in\n+   implicit dependency. The AVL comparison between 2 RVV instructions is\n+   very important since it affects our decision whether we should insert\n+   a vsetvl instruction in this situation. AVL operand of all RVV instructions\n+   can only be either a const_int value with < 32 or a reg value which can be\n+   define by either a real RTL instruction or a PHI instruction. So we need a\n+   standalone method to define AVL comparison and we can not simpily use\n+   operator \"==\" to compare 2 RTX value since it's to strict which will make\n+   use miss a lot of optimization opportunities. This method handle these\n+   following cases:\n+\n+     -  Background:\n+\t  Insert-vsetvl PASS is working after RA.\n+\n+     -  Terminology:\n+\t  - pr: Pseudo-register.\n+\t  - hr: Hardware-register.\n+\n+     -  Case 1:\n+\n+\tBefore RA:\n+\t  li pr138,13\n+\t  insn1 (implicit depend on pr138).\n+\t  li pr138,14\n+\t  insn2 (implicit depend on pr139).\n+\n+\tAfter RA:\n+\t  li hr5,13\n+\t  insn1 (implicit depend on hr5).\n+\t  li hr5,14\n+\t  insn2 (implicit depend on hr5).\n+\n+\tCorrect IR after vsetvl PASS:\n+\t  li hr5,13\n+\t  vsetvl1 zero,hr5....\n+\t  insn1 (implicit depend on hr5).\n+\t  li hr5,14\n+\t  vsetvl2 zero,hr5....\n+\t  insn2 (implicit depend on hr5).\n+\n+     In this case, both insn1 and insn2 are using hr5 as the same AVL.\n+     If we use \"rtx_equal_p\" or \"REGNO (AVL1) == REGNO (AVL)\", we will end\n+     up with missing the vsetvl2 instruction which creates wrong result.\n+\n+     Note: Using \"==\" operator to compare 2 AVL RTX strictly can fix this\n+     issue. However, it is a too strict comparison method since not all member\n+     variables in RTX data structure are not neccessary to be the same. It will\n+     make us miss a lot of optimization opportunities.\n+\n+     -  Case 2:\n+\n+\tAfter RA:\n+\tbb 0:\n+\t  li hr5,13\n+\tbb 1:\n+\t  li hr5,14\n+\tbb2:\n+\t  insn1 (implicit depend on hr5).\n+\t  insn2 (implicit depend on hr5).\n+\n+     In this case, we may end up with different AVL RTX and produce redundant\n+     vsetvl instruction.\n+\n+     VALUE is the implicit dependency in each RVV instruction.\n+     SOURCE is the source definition information of AVL operand.  */\n+class avl_info\n+{\n+private:\n+  rtx m_value;\n+  rtl_ssa::set_info *m_source;\n+\n+public:\n+  avl_info () : m_value (NULL_RTX), m_source (nullptr) {}\n+  avl_info (rtx, rtl_ssa::set_info *);\n+  rtx get_value () const { return m_value; }\n+  rtl_ssa::set_info *get_source () const { return m_source; }\n+  avl_info &operator= (const avl_info &);\n+  bool operator== (const avl_info &) const;\n+  bool operator!= (const avl_info &) const;\n+};\n+\n+/* Basic structure to save VL/VTYPE information.  */\n+struct vl_vtype_info\n+{\n+protected:\n+  /* AVL can be either register or const_int.  */\n+  avl_info m_avl;\n+  /* Fields from VTYPE. The VTYPE checking depend on the flag\n+     dem_* before.  */\n+  uint8_t m_sew;\n+  riscv_vector::vlmul_type m_vlmul;\n+  uint8_t m_ratio;\n+  bool m_ta;\n+  bool m_ma;\n+\n+public:\n+  void set_sew (uint8_t sew) { m_sew = sew; }\n+  void set_vlmul (riscv_vector::vlmul_type vlmul) { m_vlmul = vlmul; }\n+  void set_ratio (uint8_t ratio) { m_ratio = ratio; }\n+  void set_ta (bool ta) { m_ta = ta; }\n+  void set_ma (bool ma) { m_ma = ma; }\n+\n+  vl_vtype_info ()\n+    : m_avl (avl_info ()), m_sew (0), m_vlmul (riscv_vector::LMUL_RESERVED),\n+      m_ratio (0), m_ta (0), m_ma (0)\n+  {}\n+  vl_vtype_info (const vl_vtype_info &) = default;\n+  vl_vtype_info &operator= (const vl_vtype_info &) = default;\n+  vl_vtype_info (avl_info, uint8_t, riscv_vector::vlmul_type, uint8_t, bool,\n+\t\t bool);\n+\n+  bool operator== (const vl_vtype_info &) const;\n+  bool operator!= (const vl_vtype_info &) const;\n+\n+  bool has_avl_imm () const { return get_avl () && CONST_INT_P (get_avl ()); }\n+  bool has_avl_reg () const { return get_avl () && REG_P (get_avl ()); }\n+  bool has_avl_no_reg () const { return !get_avl (); }\n+  bool has_non_zero_avl () const;\n+\n+  rtx get_avl () const { return m_avl.get_value (); }\n+  avl_info get_avl_info () const { return m_avl; }\n+  void set_avl_info (const avl_info &avl) { m_avl = avl; }\n+  uint8_t get_sew () const { return m_sew; }\n+  riscv_vector::vlmul_type get_vlmul () const { return m_vlmul; }\n+  uint8_t get_ratio () const { return m_ratio; }\n+  bool get_ta () const { return m_ta; }\n+  bool get_ma () const { return m_ma; }\n+\n+  bool same_avl_p (const vl_vtype_info &) const;\n+  bool same_vtype_p (const vl_vtype_info &) const;\n+  bool same_vlmax_p (const vl_vtype_info &) const;\n+};\n+\n+class vector_insn_info : public vl_vtype_info\n+{\n+private:\n+  enum state_type\n+  {\n+    UNINITIALIZED,\n+    VALID,\n+    UNKNOWN,\n+    EMPTY,\n+\n+    /* The block is polluted as containing VSETVL instruction during dem\n+       backward propagation to gain better LCM optimization even though\n+       such VSETVL instruction is not really emit yet during this time.  */\n+    DIRTY\n+  };\n+\n+  enum state_type m_state;\n+\n+  bool m_demands[NUM_DEMAND];\n+\n+  /* TODO: Assume INSN1 = INSN holding of definition of AVL.\n+\t\t  INSN2 = INSN that is inserted a vsetvl insn before.\n+     We may need to add a new member to save INSN of holding AVL.\n+     m_insn is holding the INSN that is inserted a vsetvl insn before in\n+     Phase 2. Ideally, most of the time INSN1 == INSN2. However, considering\n+     such case:\n+\n+\tvmv.x.s (INSN2)\n+\tvle8.v (INSN1)\n+\n+     If these 2 instructions are compatible, we should only issue a vsetvl INSN\n+     (with AVL included) before vmv.x.s, but vmv.x.s is not the INSN holding the\n+     definition of AVL.  */\n+  rtl_ssa::insn_info *m_insn;\n+  /* Save instruction pattern for Dirty block.\n+     Since empty block may be polluted as a dirty block during dem backward\n+     propagation (phase 3) which is intending to cheat LCM there is a VSETVL\n+     instruction here to gain better LCM optimization. Such instruction is not\n+     emit yet, we save this here and then emit it in the 4th phase if it is\n+     necessary.  */\n+  rtx m_dirty_pat;\n+\n+  /* Parse the instruction to get VL/VTYPE information and demanding\n+   * information.  */\n+  /* This is only called by simple_vsetvl subroutine when optimize == 0.\n+     Since RTL_SSA can not be enabled when optimize == 0, we don't initialize\n+     the m_insn.  */\n+  void parse_insn (rtx_insn *);\n+  /* This is only called by lazy_vsetvl subroutine when optimize > 0.\n+     We use RTL_SSA framework to initialize the insn_info.  */\n+  void parse_insn (rtl_ssa::insn_info *);\n+\n+  friend class vector_infos_manager;\n+\n+public:\n+  vector_insn_info ()\n+    : vl_vtype_info (), m_state (UNINITIALIZED), m_demands{false},\n+      m_insn (nullptr), m_dirty_pat (NULL_RTX)\n+  {}\n+\n+  bool operator> (const vector_insn_info &) const;\n+  bool operator>= (const vector_insn_info &) const;\n+  bool operator== (const vector_insn_info &) const;\n+\n+  bool uninit_p () const { return m_state == UNINITIALIZED; }\n+  bool valid_p () const { return m_state == VALID; }\n+  bool unknown_p () const { return m_state == UNKNOWN; }\n+  bool empty_p () const { return m_state == EMPTY; }\n+  bool dirty_p () const { return m_state == DIRTY; }\n+  bool valid_or_dirty_p () const\n+  {\n+    return m_state == VALID || m_state == DIRTY;\n+  }\n+\n+  static vector_insn_info get_unknown ()\n+  {\n+    vector_insn_info info;\n+    info.set_unknown ();\n+    return info;\n+  }\n+\n+  void set_valid () { m_state = VALID; }\n+  void set_unknown () { m_state = UNKNOWN; }\n+  void set_empty () { m_state = EMPTY; }\n+  void set_dirty () { m_state = DIRTY; }\n+  void set_dirty_pat (rtx pat) { m_dirty_pat = pat; }\n+  void set_insn (rtl_ssa::insn_info *insn) { m_insn = insn; }\n+\n+  bool demand_p (enum demand_type type) const { return m_demands[type]; }\n+  void demand (enum demand_type type) { m_demands[type] = true; }\n+  void demand_vl_vtype ();\n+  void undemand (enum demand_type type) { m_demands[type] = false; }\n+\n+  bool compatible_p (const vector_insn_info &) const;\n+  bool compatible_avl_p (const vl_vtype_info &) const;\n+  bool compatible_vtype_p (const vl_vtype_info &) const;\n+  bool compatible_p (const vl_vtype_info &) const;\n+  vector_insn_info merge (const vector_insn_info &, bool) const;\n+\n+  rtl_ssa::insn_info *get_insn () const { return m_insn; }\n+  rtx get_dirty_pat () const { return m_dirty_pat; }\n+\n+  void dump (FILE *) const;\n+};\n+\n+struct vector_block_info\n+{\n+  /* The local_dem vector insn_info of the block.  */\n+  vector_insn_info local_dem;\n+\n+  /* The reaching_out vector insn_info of the block.  */\n+  vector_insn_info reaching_out;\n+\n+  vector_block_info () = default;\n+};\n+\n+class vector_infos_manager\n+{\n+public:\n+  auto_vec<vector_insn_info> vector_insn_infos;\n+  auto_vec<vector_block_info> vector_block_infos;\n+  auto_vec<vector_insn_info *> vector_exprs;\n+\n+  struct edge_list *vector_edge_list;\n+  sbitmap *vector_kill;\n+  sbitmap *vector_del;\n+  sbitmap *vector_insert;\n+  sbitmap *vector_antic;\n+  sbitmap *vector_transp;\n+  sbitmap *vector_comp;\n+  sbitmap *vector_avin;\n+  sbitmap *vector_avout;\n+\n+  vector_infos_manager ();\n+\n+  /* Create a new expr in expr list if it is not exist.  */\n+  void create_expr (vector_insn_info &);\n+\n+  /* Get the expr id of the pair of expr.  */\n+  size_t get_expr_id (const vector_insn_info &) const;\n+\n+  /* Return the number of expr that is set in the bitmap.  */\n+  size_t expr_set_num (sbitmap) const;\n+\n+  /* Get all relaxer expression id for corresponding vector info.  */\n+  auto_vec<size_t> get_all_available_exprs (const vector_insn_info &) const;\n+\n+  /* Return true if all expression set in bitmap are same ratio.  */\n+  bool all_same_ratio_p (sbitmap) const;\n+\n+  void release (void);\n+\n+  void dump (FILE *) const;\n+};\n+\n+} // namespace riscv_vector\n+#endif"}, {"sha": "83e0187c21919b9e0fdd4996ccbdd7a986ad1ac6", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -4256,30 +4256,34 @@ riscv_print_operand (FILE *file, rtx op, int letter)\n \t  }\n \telse if (code == CONST_INT)\n \t  {\n-\t    /* The value in the operand is the unsigned int value\n-\t       converted from (enum machine_mode).\n-\t       This RTX is generated as follows:\n-\n-\t       machine_mode mode = XXXmode;\n-\t       operand = gen_int_mode ((unsigned int)mode, Pmode);\n-\n-\t       So we convert it back into machine_mode and then calculate\n-\t       the LMUL according to GET_MODE_SIZE.  */\n-\n-\t    machine_mode rvv_mode = (machine_mode) UINTVAL (op);\n-\t    /* For rvv mask modes, we can not calculate LMUL simpily according\n-\t       to BYTES_PER_RISCV_VECTOR. When rvv_mode = VNx4BImode.\n-\t       Set SEW = 8, LMUL = 1 by default if TARGET_MIN_VLEN == 32.\n-\t       Set SEW = 8, LMUL = 1 / 2 by default if TARGET_MIN_VLEN > 32.  */\n-\t    bool bool_p = GET_MODE_CLASS (rvv_mode) == MODE_VECTOR_BOOL;\n-\t    poly_int64 m1_size = BYTES_PER_RISCV_VECTOR;\n-\t    poly_int64 rvv_size\n-\t      = bool_p ? GET_MODE_NUNITS (rvv_mode) : GET_MODE_SIZE (rvv_mode);\n-\t    bool fractional_p = known_lt (rvv_size, BYTES_PER_RISCV_VECTOR);\n-\t    unsigned int factor\n-\t      = fractional_p ? exact_div (m1_size, rvv_size).to_constant ()\n-\t\t\t     : exact_div (rvv_size, m1_size).to_constant ();\n-\t    asm_fprintf (file, \"%s%d\", fractional_p ? \"mf\" : \"m\", factor);\n+\t    /* If it is a const_int value, it denotes the VLMUL field enum.  */\n+\t    unsigned int vlmul = UINTVAL (op);\n+\t    switch (vlmul)\n+\t      {\n+\t      case riscv_vector::LMUL_1:\n+\t\tasm_fprintf (file, \"%s\", \"m1\");\n+\t\tbreak;\n+\t      case riscv_vector::LMUL_2:\n+\t\tasm_fprintf (file, \"%s\", \"m2\");\n+\t\tbreak;\n+\t      case riscv_vector::LMUL_4:\n+\t\tasm_fprintf (file, \"%s\", \"m4\");\n+\t\tbreak;\n+\t      case riscv_vector::LMUL_8:\n+\t\tasm_fprintf (file, \"%s\", \"m8\");\n+\t\tbreak;\n+\t      case riscv_vector::LMUL_F8:\n+\t\tasm_fprintf (file, \"%s\", \"mf8\");\n+\t\tbreak;\n+\t      case riscv_vector::LMUL_F4:\n+\t\tasm_fprintf (file, \"%s\", \"mf4\");\n+\t\tbreak;\n+\t      case riscv_vector::LMUL_F2:\n+\t\tasm_fprintf (file, \"%s\", \"mf2\");\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n \t  }\n \telse\n \t  output_operand_lossage (\"invalid vector constant\");"}, {"sha": "7af9f5402ec713a4d505d89a25f0111bd4810e9d", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -51,6 +51,14 @@ riscv-c.o: $(srcdir)/config/riscv/riscv-c.cc $(CONFIG_H) $(SYSTEM_H) \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/riscv/riscv-c.cc\n \n+riscv-vsetvl.o: $(srcdir)/config/riscv/riscv-vsetvl.cc \\\n+  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n+  $(TARGET_H) tree-pass.h df.h rtl-ssa.h cfgcleanup.h insn-config.h \\\n+  insn-attr.h insn-opinit.h tm-constrs.h cfgrtl.h cfganal.h lcm.h \\\n+  predict.h profile-count.h $(srcdir)/config/riscv/riscv-vsetvl.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/riscv/riscv-vsetvl.cc\n+\n riscv-d.o: $(srcdir)/config/riscv/riscv-d.cc\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)"}, {"sha": "52ca6b3d25cd79d8ccf7f7c564bd7cf48777284d", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 104, "deletions": 27, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -32,6 +32,7 @@\n   UNSPEC_VSETVL\n   UNSPEC_VUNDEF\n   UNSPEC_VPREDICATE\n+  UNSPEC_VLMAX\n ])\n \n (define_constants [\n@@ -94,7 +95,13 @@\n \t (const_int 32)\n \t (eq_attr \"mode\" \"VNx1DI,VNx2DI,VNx4DI,VNx8DI,\\\n \t\t\t  VNx1DF,VNx2DF,VNx4DF,VNx8DF\")\n-\t (const_int 64)]\n+\t (const_int 64)\n+\n+\t (eq_attr \"type\" \"vsetvl\")\n+\t (if_then_else (eq_attr \"INSN_CODE (curr_insn) == CODE_FOR_vsetvldi\n+\t\t\t\t || INSN_CODE (curr_insn) == CODE_FOR_vsetvlsi\")\n+\t\t       (symbol_ref \"INTVAL (operands[2])\")\n+\t\t       (const_int INVALID_ATTRIBUTE))]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; Ditto to LMUL.\n@@ -142,7 +149,12 @@\n \t (eq_attr \"mode\" \"VNx4DI,VNx4DF\")\n \t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx4DImode)\")\n \t (eq_attr \"mode\" \"VNx8DI,VNx8DF\")\n-\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8DImode)\")]\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8DImode)\")\n+\t (eq_attr \"type\" \"vsetvl\")\n+\t (if_then_else (eq_attr \"INSN_CODE (curr_insn) == CODE_FOR_vsetvldi\n+\t\t\t\t || INSN_CODE (curr_insn) == CODE_FOR_vsetvlsi\")\n+\t\t       (symbol_ref \"INTVAL (operands[3])\")\n+\t\t       (const_int INVALID_ATTRIBUTE))]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; It is valid for instruction that require sew/lmul ratio.\n@@ -219,6 +231,34 @@\n \t (const_int 6)]\n \t(const_int INVALID_ATTRIBUTE)))\n \n+;; The index of operand[] to get the mask policy op.\n+(define_attr \"avl_type_op_idx\" \"\"\n+  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vlds,vlds\")\n+\t (const_int 7)\n+\t (eq_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n+\t (const_int 5)]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; The tail policy op value.\n+(define_attr \"ta\" \"\"\n+  (cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vlds\")\n+\t   (symbol_ref \"riscv_vector::get_ta(operands[5])\")]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; The mask policy op value.\n+(define_attr \"ma\" \"\"\n+  (cond [(eq_attr \"type\" \"vlde,vlds\")\n+\t   (symbol_ref \"riscv_vector::get_ma(operands[6])\")]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; The avl type value.\n+(define_attr \"avl_type\" \"\"\n+  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vlds,vlds\")\n+\t   (symbol_ref \"INTVAL (operands[7])\")\n+\t (eq_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n+\t   (symbol_ref \"INTVAL (operands[5])\")]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n ;; -----------------------------------------------------------------\n ;; ---- Miscellaneous Operations\n ;; -----------------------------------------------------------------\n@@ -229,6 +269,37 @@\n   \"TARGET_VECTOR\"\n   \"\")\n \n+;; This pattern is used to hold the AVL operand for\n+;; RVV instructions that implicity use VLMAX AVL.\n+;; RVV instruction implicitly use GPR that is ultimately\n+;; defined by this pattern is safe for VSETVL pass emit\n+;; a vsetvl instruction modify this register after RA.\n+;; Case 1:\n+;;   vlmax_avl a5\n+;;   ... (across many blocks)\n+;;   vadd (implicit use a5)  ====> emit: vsetvl a5,zero\n+;; Case 2:\n+;;   vlmax_avl a5\n+;;   ... (across many blocks)\n+;;   mv a6,a5\n+;;   ... (across many blocks)\n+;;   vadd (implicit use a6)  ====> emit: vsetvl a6,zero\n+;; Case 3:\n+;;   vlmax_avl a5\n+;;   ... (across many blocks)\n+;;   store mem,a5 (spill)\n+;;   ... (across many blocks)\n+;;   load a7,mem (spill)\n+;;   ... (across many blocks)\n+;;   vadd (implicit use a7)  ====> emit: vsetvl a7,zero\n+;; Such cases are all safe for VSETVL PASS to emit a vsetvl\n+;; instruction that modifies the AVL operand.\n+(define_insn \"@vlmax_avl<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"const_int_operand\" \"i\")] UNSPEC_VLMAX))]\n+  \"TARGET_VECTOR\"\n+  \"\")\n+\n ;; -----------------------------------------------------------------\n ;; ---- Moves Operations\n ;; -----------------------------------------------------------------\n@@ -482,32 +553,35 @@\n   [(set_attr \"type\" \"vsetvl\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-;; We keep it as no side effects before reload_completed.\n-;; In this case, we can gain benefits from different GCC\n-;; internal PASS such as cprop, fwprop, combine,...etc.\n-\n-;; Then recover it for \"insert-vsetvl\" and \"sched2\" PASS\n-;; in order to get correct codegen.\n-(define_insn_and_split \"@vsetvl<mode>_no_side_effects\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-\t(unspec:P [(match_operand:P 1 \"csr_operand\" \"rK\")\n-\t\t   (match_operand 2 \"const_int_operand\" \"i\")\n-\t\t   (match_operand 3 \"const_int_operand\" \"i\")\n-\t\t   (match_operand 4 \"const_int_operand\" \"i\")\n-\t\t   (match_operand 5 \"const_int_operand\" \"i\")] UNSPEC_VSETVL))]\n+;; vsetvl zero,zero,vtype instruction.\n+;; This pattern has no side effects and does not set X0 register.\n+(define_insn \"vsetvl_vtype_change_only\"\n+  [(set (reg:SI VTYPE_REGNUM)\n+\t(unspec:SI\n+\t  [(match_operand 0 \"const_int_operand\" \"i\")\n+\t   (match_operand 1 \"const_int_operand\" \"i\")\n+\t   (match_operand 2 \"const_int_operand\" \"i\")\n+\t   (match_operand 3 \"const_int_operand\" \"i\")] UNSPEC_VSETVL))]\n   \"TARGET_VECTOR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel\n-    [(set (match_dup 0)\n-\t  (unspec:P [(match_dup 1) (match_dup 2) (match_dup 3)\n-\t\t     (match_dup 4) (match_dup 5)] UNSPEC_VSETVL))\n-     (set (reg:SI VL_REGNUM)\n-\t  (unspec:SI [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPEC_VSETVL))\n-     (set (reg:SI VTYPE_REGNUM)\n-\t  (unspec:SI [(match_dup 2) (match_dup 3) (match_dup 4)\n-\t\t      (match_dup 5)] UNSPEC_VSETVL))])]\n-  \"\"\n+  \"vsetvli\\tzero,zero,e%0,%m1,t%p2,m%p3\"\n+  [(set_attr \"type\" \"vsetvl\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;; vsetvl zero,rs1,vtype instruction.\n+;; The reason we need this pattern since we should avoid setting X0 register\n+;; in vsetvl instruction pattern.\n+(define_insn \"@vsetvl_discard_result<mode>\"\n+  [(set (reg:SI VL_REGNUM)\n+\t(unspec:SI [(match_operand:P 0 \"csr_operand\" \"rK\")\n+\t\t    (match_operand 1 \"const_int_operand\" \"i\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"i\")] UNSPEC_VSETVL))\n+   (set (reg:SI VTYPE_REGNUM)\n+\t(unspec:SI [(match_dup 1)\n+\t\t    (match_dup 2)\n+\t\t    (match_operand 3 \"const_int_operand\" \"i\")\n+\t\t    (match_operand 4 \"const_int_operand\" \"i\")] UNSPEC_VSETVL))]\n+  \"TARGET_VECTOR\"\n+  \"vsetvli\\tzero,%0,e%1,%m2,t%p3,m%p4\"\n   [(set_attr \"type\" \"vsetvl\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -563,6 +637,7 @@\n \t     (match_operand 4 \"vector_length_operand\"    \" rK,  rK,    rK,    rK,    rK\")\n \t     (match_operand 5 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n \t     (match_operand 6 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n \t  (match_operand:V 3 \"vector_move_operand\"       \"  m,   m,    vr,    vr, viWc0\")\n@@ -593,6 +668,7 @@\n \t  (unspec:VB\n \t    [(match_operand:VB 1 \"vector_mask_operand\"   \"Wc1, Wc1, Wc1, Wc1, Wc1\")\n \t     (match_operand 4 \"vector_length_operand\"    \" rK,  rK,  rK,  rK,  rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"  i,   i,   i,   i,   i\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n \t  (match_operand:VB 3 \"vector_move_operand\"      \"  m,  vr,  vr, Wc0, Wc1\")\n@@ -628,6 +704,7 @@\n \t     (match_operand 4 \"vector_length_operand\"         \" rK,  rK,  rK,  rK\")\n \t     (match_operand 5 \"const_int_operand\"             \"  i,   i,   i,   i\")\n \t     (match_operand 6 \"const_int_operand\"             \"  i,   i,   i,   i\")\n+\t     (match_operand 7 \"const_int_operand\"             \"  i,   i,   i,   i\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n \t  (vec_duplicate:V"}, {"sha": "8355621d4edc435d8d8c88cef81ebad78f66445c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -35,6 +35,9 @@ extern bool xxspltib_constant_p (rtx, machine_mode, int *, int *);\n extern int vspltis_shifted (rtx);\n extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);\n extern bool macho_lo_sum_memory_operand (rtx, machine_mode);\n+extern bool can_be_rotated_to_lowbits (unsigned HOST_WIDE_INT, int, int *);\n+extern bool can_be_rotated_to_positive_16bits (HOST_WIDE_INT);\n+extern bool can_be_rotated_to_negative_15bits (HOST_WIDE_INT);\n extern int num_insns_constant (rtx, machine_mode);\n extern int small_data_operand (rtx, machine_mode);\n extern bool mem_operand_gpr (rtx, machine_mode);"}, {"sha": "e074e8f7bdf36b06aa704a6c7a964c82b1ee7187", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -10251,17 +10251,42 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c)\n       if (ud1 != 0)\n \temit_move_insn (dest, gen_rtx_IOR (DImode, temp, GEN_INT (ud1)));\n     }\n+  else if (ud4 == 0xffff && ud3 == 0xffff && (ud1 & 0x8000))\n+    {\n+      /* li; xoris */\n+      temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (DImode);\n+      emit_move_insn (temp, GEN_INT (sext_hwi (ud1, 16)));\n+      emit_move_insn (dest, gen_rtx_XOR (DImode, temp,\n+\t\t\t\t\t GEN_INT ((ud2 ^ 0xffff) << 16)));\n+    }\n   else if (ud3 == 0 && ud4 == 0)\n     {\n       temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (DImode);\n \n       gcc_assert (ud2 & 0x8000);\n-      emit_move_insn (temp, GEN_INT (sext_hwi (ud2 << 16, 32)));\n-      if (ud1 != 0)\n-\temit_move_insn (temp, gen_rtx_IOR (DImode, temp, GEN_INT (ud1)));\n-      emit_move_insn (dest,\n-\t\t      gen_rtx_ZERO_EXTEND (DImode,\n-\t\t\t\t\t   gen_lowpart (SImode,temp)));\n+\n+      if (ud1 == 0)\n+\t{\n+\t  /* lis; rldicl */\n+\t  emit_move_insn (temp, GEN_INT (sext_hwi (ud2 << 16, 32)));\n+\t  emit_move_insn (dest,\n+\t\t\t  gen_rtx_AND (DImode, temp, GEN_INT (0xffffffff)));\n+\t}\n+      else if (!(ud1 & 0x8000))\n+\t{\n+\t  /* li; oris */\n+\t  emit_move_insn (temp, GEN_INT (ud1));\n+\t  emit_move_insn (dest,\n+\t\t\t  gen_rtx_IOR (DImode, temp, GEN_INT (ud2 << 16)));\n+\t}\n+      else\n+\t{\n+\t  /* lis; ori; rldicl */\n+\t  emit_move_insn (temp, GEN_INT (sext_hwi (ud2 << 16, 32)));\n+\t  emit_move_insn (temp, gen_rtx_IOR (DImode, temp, GEN_INT (ud1)));\n+\t  emit_move_insn (dest,\n+\t\t\t  gen_rtx_AND (DImode, temp, GEN_INT (0xffffffff)));\n+\t}\n     }\n   else if (ud1 == ud3 && ud2 == ud4)\n     {\n@@ -14925,6 +14950,71 @@ rs6000_reverse_condition (machine_mode mode, enum rtx_code code)\n     return reverse_condition (code);\n }\n \n+/* Check if C (as 64bit integer) can be rotated to a constant which constains\n+   nonzero bits at the LOWBITS low bits only.\n+\n+   Return true if C can be rotated to such constant.  If so, *ROT is written\n+   to the number by which C is rotated.\n+   Return false otherwise.  */\n+\n+bool\n+can_be_rotated_to_lowbits (unsigned HOST_WIDE_INT c, int lowbits, int *rot)\n+{\n+  int clz = HOST_BITS_PER_WIDE_INT - lowbits;\n+\n+  /* case a. 0..0xxx: already at least clz zeros.  */\n+  int lz = clz_hwi (c);\n+  if (lz >= clz)\n+    {\n+      *rot = 0;\n+      return true;\n+    }\n+\n+  /* case b. 0..0xxx0..0: at least clz zeros.  */\n+  int tz = ctz_hwi (c);\n+  if (lz + tz >= clz)\n+    {\n+      *rot = HOST_BITS_PER_WIDE_INT - tz;\n+      return true;\n+    }\n+\n+  /* case c. xx10.....0xx: rotate 'clz - 1' bits first, then check case b.\n+\t       ^bit -> Vbit, , then zeros are at head or tail.\n+\t     00...00xxx100, 'clz - 1' >= 'bits of xxxx'.  */\n+  const int rot_bits = lowbits + 1;\n+  unsigned HOST_WIDE_INT rc = (c >> rot_bits) | (c << (clz - 1));\n+  tz = ctz_hwi (rc);\n+  if (clz_hwi (rc) + tz >= clz)\n+    {\n+      *rot = HOST_BITS_PER_WIDE_INT - (tz + rot_bits);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Check if C (as 64bit integer) can be rotated to a positive 16bits constant\n+   which contains 48bits leading zeros and 16bits of any value.  */\n+\n+bool\n+can_be_rotated_to_positive_16bits (HOST_WIDE_INT c)\n+{\n+  int rot = 0;\n+  bool res = can_be_rotated_to_lowbits (c, 16, &rot);\n+  return res && rot > 0;\n+}\n+\n+/* Check if C (as 64bit integer) can be rotated to a negative 15bits constant\n+   which contains 49bits leading ones and 15bits of any value.  */\n+\n+bool\n+can_be_rotated_to_negative_15bits (HOST_WIDE_INT c)\n+{\n+  int rot = 0;\n+  bool res = can_be_rotated_to_lowbits (~c, 15, &rot);\n+  return res && rot > 0;\n+}\n+\n /* Generate a compare for CODE.  Return a brand-new rtx that\n    represents the result of the compare.  */\n "}, {"sha": "3cae64a264a0ce30228fb5761df75329255eaef7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -7765,6 +7765,71 @@\n   \"xscvdpsp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n+\n+(define_code_iterator eqne [eq ne])\n+\n+;; \"i == C\" ==> \"rotl(i,N) == rotl(C,N)\"\n+(define_insn_and_split \"*rotate_on_cmpdi\"\n+  [(set (pc)\n+\t(if_then_else (eqne (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t      (label_ref (match_operand 0 \"\"))\n+\t\t      (pc)))\n+  (clobber (match_scratch:DI 3 \"=r\"))\n+  (clobber (match_scratch:CCUNS 4 \"=y\"))]\n+  \"TARGET_POWERPC64 && num_insns_constant (operands[2], DImode) > 1\n+   && (can_be_rotated_to_positive_16bits (INTVAL (operands[2]))\n+       || can_be_rotated_to_negative_15bits (INTVAL (operands[2])))\"\n+   \"#\"\n+   \"&& 1\"\n+  [(pc)]\n+{\n+  bool sgn = false;\n+  unsigned HOST_WIDE_INT C = INTVAL (operands[2]);\n+  int rot;\n+\n+  /* cmpldi */\n+  if (!can_be_rotated_to_lowbits (C, 16, &rot))\n+    {\n+      /* cmpdi */\n+      sgn = true;\n+      bool res = can_be_rotated_to_lowbits (~C, 15, &rot);\n+      gcc_assert (res);\n+    }\n+\n+  rtx n = GEN_INT (rot);\n+\n+  /* i' = rotl (i, n) */\n+  rtx op0 = can_create_pseudo_p () ? gen_reg_rtx (DImode) : operands[3];\n+  emit_insn (gen_rtx_SET (op0, gen_rtx_ROTATE (DImode, operands[1], n)));\n+\n+  /* C' = rotl (C, n) */\n+  rtx op1 = GEN_INT ((C << rot) | (C >> (HOST_BITS_PER_WIDE_INT - rot)));\n+\n+  /* i' ==  C' */\n+  machine_mode comp_mode = sgn ? CCmode : CCUNSmode;\n+  rtx cc = can_create_pseudo_p () ? gen_reg_rtx (comp_mode) : operands[4];\n+  PUT_MODE (cc, comp_mode);\n+  emit_insn (gen_rtx_SET (cc, gen_rtx_COMPARE (comp_mode, op0, op1)));\n+  rtx cmp = gen_rtx_<eqne:CODE> (CCmode, cc, const0_rtx);\n+  rtx loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n+  emit_jump_insn (gen_rtx_SET (pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,\n+\t\t\t\t\t\t     loc_ref, pc_rtx)));\n+\n+  /* Keep the probability info for the prediction of the branch insn.  */\n+  rtx note = find_reg_note (curr_insn, REG_BR_PROB, 0);\n+  if (note)\n+    {\n+      profile_probability prob\n+\t= profile_probability::from_reg_br_prob_note (XINT (note, 0));\n+\n+      add_reg_br_prob_note (get_last_insn (), prob);\n+    }\n+\n+  DONE;\n+})\n+\n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n \n@@ -13463,7 +13528,6 @@\n ;; rs6000_legitimate_combined_insn prevents combine creating any of\n ;; the ctr<mode> insns.\n \n-(define_code_iterator eqne [eq ne])\n (define_code_attr bd [(eq \"bdz\") (ne \"bdnz\")])\n (define_code_attr bd_neg [(eq \"bdnz\") (ne \"bdz\")])\n "}, {"sha": "7f06bf22e21afaa86ae302dde0be3a1e0a3987ed", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -7218,7 +7218,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n \n strict_warn=\n save_CXXFLAGS=\"$CXXFLAGS\"\n-for real_option in -Wmissing-format-attribute -Woverloaded-virtual; do\n+for real_option in -Wmissing-format-attribute -Wconditionally-supported -Woverloaded-virtual; do\n   # Do the check with the no- prefix removed since gcc silently\n   # accepts any -Wno-* option on purpose\n   case $real_option in"}, {"sha": "275263d4ea85c37c017688c0a916c7349a11f0cf", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -580,7 +580,7 @@ ACX_PROG_CC_WARNING_OPTS(\n \tm4_quote(m4_do([-Wstrict-prototypes -Wmissing-prototypes ],\n \t\t       [])), [c_loose_warn])\n ACX_PROG_CXX_WARNING_OPTS(\n-\tm4_quote(m4_do([-Wmissing-format-attribute ],\n+\tm4_quote(m4_do([-Wmissing-format-attribute ], [-Wconditionally-supported ],\n \t\t       [-Woverloaded-virtual])), [strict_warn])\n ACX_PROG_CC_WARNING_OPTS(\n \tm4_quote(m4_do([-Wold-style-definition -Wc++-compat])), [c_strict_warn])"}, {"sha": "73f1c54dec71c1fdd48b2362699cc86fd486407b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,44 @@\n+2022-12-19  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/100881\n+\t* constexpr.cc (cxx_eval_builtin_function_call): Adjust calls\n+\tto fold_builtin_source_location.\n+\t* cp-gimplify.cc (cp_gimplify_expr): Likewise.\n+\t(cp_fold): Likewise.\n+\t(get_source_location_impl_type): Remove location_t parameter and\n+\tadjust accordingly.  No longer static.\n+\t(fold_builtin_source_location): Take a CALL_EXPR tree instead of a\n+\tlocation and obtain the impl type from its return type.\n+\t* cp-tree.h (enum cp_tree_index): Remove CPTI_SOURCE_LOCATION_IMPL\n+\tenumerator.\n+\t(source_location_impl): Remove.\n+\t(fold_builtin_source_location): Adjust parameter type.\n+\t(get_source_location_impl_type): Declare.\n+\t* decl.cc (cxx_init_decl_processing): Declare\n+\t__builtin_source_location with auto return type instead of\n+\tconst void*.\n+\t(require_deduced_type): Update the return type of\n+\t__builtin_source_location.\n+\n+2022-12-19  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/101886\n+\t* pt.cc (extract_autos_r): Recompute TYPE_CANONICAL after\n+\tadjusting the template type parameter's index.  Simplify\n+\tby using TEMPLATE_TYPE_IDX.  Add some sanity checks.\n+\n+2022-12-19  Arsen Arsenovi\u0107  <arsen@aarsen.me>\n+\n+\t* contracts.cc: Rename references to\n+\tcontract_violation_continuation_mode constants to be lowercase.\n+\n+2022-12-17  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107437\n+\tPR c++/87765\n+\t* pt.cc (convert_nontype_argument): Relax is_nondep_const_expr\n+\ttest to !inst_dep_expr_p.\n+\n 2022-12-16  Andrew Pinski  <pinskia@gmail.com>\n \t    Iain Sandoe  <iain@sandoe.co.uk>\n "}, {"sha": "d99c49bdbe2829a8914f11b9b7d13629a633585b", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1492,7 +1492,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n       temp_override<tree> ovr (current_function_decl);\n       if (ctx->call && ctx->call->fundef)\n \tcurrent_function_decl = ctx->call->fundef->decl;\n-      return fold_builtin_source_location (EXPR_LOCATION (t));\n+      return fold_builtin_source_location (t);\n     }\n \n   int strops = 0;"}, {"sha": "2631637238920963cbd37e265f52c97c50d8931d", "filename": "gcc/cp/contracts.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fcontracts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fcontracts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcontracts.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -41,9 +41,9 @@ along with GCC; see the file COPYING3.  If not see\n \t \"v > 0\", // comment,\n \t \"default\", // assertion_level,\n \t \"default\", // assertion_role,\n-\t MAYBE_CONTINUE, // continuation_mode\n+\t maybe_continue, // continuation_mode\n        });\n-       terminate (); // if NEVER_CONTINUE\n+       terminate (); // if never_continue\n      }\n \n    We use an internal type with the same layout as contract_violation rather"}, {"sha": "1e0b4f8c1cf5b0ff528a759bd9faf2bd8d8c7d9f", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -722,7 +722,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t\tbreak;\n \t      case CP_BUILT_IN_SOURCE_LOCATION:\n \t\t*expr_p\n-\t\t  = fold_builtin_source_location (EXPR_LOCATION (*expr_p));\n+\t\t  = fold_builtin_source_location (*expr_p);\n \t\tbreak;\n \t      case CP_BUILT_IN_IS_CORRESPONDING_MEMBER:\n \t\t*expr_p\n@@ -2850,7 +2850,7 @@ cp_fold (tree x)\n \t      case CP_BUILT_IN_IS_CONSTANT_EVALUATED:\n \t\tbreak;\n \t      case CP_BUILT_IN_SOURCE_LOCATION:\n-\t\tx = fold_builtin_source_location (EXPR_LOCATION (x));\n+\t\tx = fold_builtin_source_location (x);\n \t\tbreak;\n \t      case CP_BUILT_IN_IS_CORRESPONDING_MEMBER:\n \t        x = fold_builtin_is_corresponding_member\n@@ -2872,7 +2872,7 @@ cp_fold (tree x)\n \t    && fndecl_built_in_p (callee, CP_BUILT_IN_SOURCE_LOCATION,\n \t\t\t\t  BUILT_IN_FRONTEND))\n \t  {\n-\t    x = fold_builtin_source_location (EXPR_LOCATION (x));\n+\t    x = fold_builtin_source_location (x);\n \t    break;\n \t  }\n \n@@ -3171,22 +3171,21 @@ process_stmt_assume_attribute (tree std_attrs, tree statement,\n   return remove_attribute (\"gnu\", \"assume\", std_attrs);\n }\n \n-/* Helper of fold_builtin_source_location, return the\n-   std::source_location::__impl type after performing verification\n-   on it.  LOC is used for reporting any errors.  */\n+/* Return the type std::source_location::__impl after performing\n+   verification on it.  */\n \n-static tree\n-get_source_location_impl_type (location_t loc)\n+tree\n+get_source_location_impl_type ()\n {\n   tree name = get_identifier (\"source_location\");\n   tree decl = lookup_qualified_name (std_node, name);\n   if (TREE_CODE (decl) != TYPE_DECL)\n     {\n       auto_diagnostic_group d;\n       if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n-\tqualified_name_lookup_error (std_node, name, decl, loc);\n+\tqualified_name_lookup_error (std_node, name, decl, input_location);\n       else\n-\terror_at (loc, \"%qD is not a type\", decl);\n+\terror (\"%qD is not a type\", decl);\n       return error_mark_node;\n     }\n   name = get_identifier (\"__impl\");\n@@ -3196,15 +3195,15 @@ get_source_location_impl_type (location_t loc)\n     {\n       auto_diagnostic_group d;\n       if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n-\tqualified_name_lookup_error (type, name, decl, loc);\n+\tqualified_name_lookup_error (type, name, decl, input_location);\n       else\n-\terror_at (loc, \"%qD is not a type\", decl);\n+\terror (\"%qD is not a type\", decl);\n       return error_mark_node;\n     }\n   type = TREE_TYPE (decl);\n   if (TREE_CODE (type) != RECORD_TYPE)\n     {\n-      error_at (loc, \"%qD is not a class type\", decl);\n+      error (\"%qD is not a class type\", decl);\n       return error_mark_node;\n     }\n \n@@ -3221,8 +3220,7 @@ get_source_location_impl_type (location_t loc)\n \t    {\n \t      if (TREE_TYPE (field) != const_string_type_node)\n \t\t{\n-\t\t  error_at (loc, \"%qD does not have %<const char *%> type\",\n-\t\t\t    field);\n+\t\t  error (\"%qD does not have %<const char *%> type\", field);\n \t\t  return error_mark_node;\n \t\t}\n \t      cnt++;\n@@ -3232,7 +3230,7 @@ get_source_location_impl_type (location_t loc)\n \t    {\n \t      if (TREE_CODE (TREE_TYPE (field)) != INTEGER_TYPE)\n \t\t{\n-\t\t  error_at (loc, \"%qD does not have integral type\", field);\n+\t\t  error (\"%qD does not have integral type\", field);\n \t\t  return error_mark_node;\n \t\t}\n \t      cnt++;\n@@ -3244,9 +3242,9 @@ get_source_location_impl_type (location_t loc)\n     }\n   if (cnt != 4)\n     {\n-      error_at (loc, \"%<std::source_location::__impl%> does not contain only \"\n-\t\t     \"non-static data members %<_M_file_name%>, \"\n-\t\t     \"%<_M_function_name%>, %<_M_line%> and %<_M_column%>\");\n+      error (\"%<std::source_location::__impl%> does not contain only \"\n+\t     \"non-static data members %<_M_file_name%>, \"\n+\t     \"%<_M_function_name%>, %<_M_line%> and %<_M_column%>\");\n       return error_mark_node;\n     }\n   return build_qualified_type (type, TYPE_QUAL_CONST);\n@@ -3337,21 +3335,20 @@ static GTY(()) hash_table <source_location_table_entry_hash>\n   *source_location_table;\n static GTY(()) unsigned int source_location_id;\n \n-/* Fold __builtin_source_location () call.  LOC is the location\n-   of the call.  */\n+/* Fold the __builtin_source_location () call T.  */\n \n tree\n-fold_builtin_source_location (location_t loc)\n+fold_builtin_source_location (const_tree t)\n {\n-  if (source_location_impl == NULL_TREE)\n-    {\n-      auto_diagnostic_group d;\n-      source_location_impl = get_source_location_impl_type (loc);\n-      if (source_location_impl == error_mark_node)\n-\tinform (loc, \"evaluating %qs\", \"__builtin_source_location\");\n-    }\n+  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n+  /* TREE_TYPE (t) is const std::source_location::__impl*  */\n+  tree source_location_impl = TREE_TYPE (TREE_TYPE (t));\n   if (source_location_impl == error_mark_node)\n     return build_zero_cst (const_ptr_type_node);\n+  gcc_assert (CLASS_TYPE_P (source_location_impl)\n+\t      && id_equal (TYPE_IDENTIFIER (source_location_impl), \"__impl\"));\n+\n+  location_t loc = EXPR_LOCATION (t);\n   if (source_location_table == NULL)\n     source_location_table\n       = hash_table <source_location_table_entry_hash>::create_ggc (64);\n@@ -3427,7 +3424,7 @@ fold_builtin_source_location (location_t loc)\n       entryp->var = var;\n     }\n \n-  return build_fold_addr_expr_with_type_loc (loc, var, const_ptr_type_node);\n+  return build_fold_addr_expr_with_type_loc (loc, var, TREE_TYPE (t));\n }\n \n #include \"gt-cp-cp-gimplify.h\""}, {"sha": "541d760492d08355f27cb0f8994802504f4344f9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -235,8 +235,6 @@ enum cp_tree_index\n \n     CPTI_PSEUDO_CONTRACT_VIOLATION,\n \n-    CPTI_SOURCE_LOCATION_IMPL,\n-\n     CPTI_FALLBACK_DFLOAT32_TYPE,\n     CPTI_FALLBACK_DFLOAT64_TYPE,\n     CPTI_FALLBACK_DFLOAT128_TYPE,\n@@ -395,9 +393,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n /* A node which matches any template argument.  */\n #define any_targ_node\t\t\tcp_global_trees[CPTI_ANY_TARG]\n \n-/* std::source_location::__impl class.  */\n-#define source_location_impl\t\tcp_global_trees[CPTI_SOURCE_LOCATION_IMPL]\n-\n /* Node to indicate default access. This must be distinct from the\n    access nodes in tree.h.  */\n \n@@ -8296,7 +8291,8 @@ extern tree process_stmt_hotness_attribute\t(tree, location_t);\n extern tree build_assume_call\t\t\t(location_t, tree);\n extern tree process_stmt_assume_attribute\t(tree, tree, location_t);\n extern bool simple_empty_class_p\t\t(tree, tree, tree_code);\n-extern tree fold_builtin_source_location\t(location_t);\n+extern tree fold_builtin_source_location\t(const_tree);\n+extern tree get_source_location_impl_type\t();\n \n /* in name-lookup.cc */\n extern tree strip_using_decl                    (tree);"}, {"sha": "df74d886b281df136db322cfef6c4b55f1e4e63b", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -4670,9 +4670,13 @@ cxx_init_decl_processing (void)\n \t\t\t    BUILT_IN_FRONTEND, NULL, NULL_TREE);\n   set_call_expr_flags (decl, ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n \n-  tree cptr_ftype = build_function_type_list (const_ptr_type_node, NULL_TREE);\n+  /* The concrete return type of __builtin_source_location is\n+     const std::source_location::__impl*, but we can't form the type\n+     at this point.  So we initially declare it with an auto return\n+     type which we then \"deduce\" from require_deduced_type upon first use.  */\n+  tree auto_ftype = build_function_type_list (make_auto (), NULL_TREE);\n   decl = add_builtin_function (\"__builtin_source_location\",\n-\t\t\t       cptr_ftype, CP_BUILT_IN_SOURCE_LOCATION,\n+\t\t\t       auto_ftype, CP_BUILT_IN_SOURCE_LOCATION,\n \t\t\t       BUILT_IN_FRONTEND, NULL, NULL_TREE);\n   set_call_expr_flags (decl, ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n \n@@ -18752,6 +18756,23 @@ require_deduced_type (tree decl, tsubst_flags_t complain)\n {\n   if (undeduced_auto_decl (decl))\n     {\n+      if (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && fndecl_built_in_p (decl, BUILT_IN_FRONTEND)\n+\t  && DECL_FE_FUNCTION_CODE (decl) == CP_BUILT_IN_SOURCE_LOCATION)\n+\t{\n+\t  /* Set the return type of __builtin_source_location.  */\n+\t  tree type = get_source_location_impl_type ();\n+\t  if (type == error_mark_node)\n+\t    {\n+\t      inform (input_location, \"using %qs\", \"__builtin_source_location\");\n+\t      return false;\n+\t    }\n+\t  type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+\t  type = build_pointer_type (type);\n+\t  apply_deduced_return_type (decl, type);\n+\t  return true;\n+\t}\n+\n       if (warning_suppressed_p (decl) && seen_error ())\n \t/* We probably already complained about deduction failure.  */;\n       else if (complain & tf_error)"}, {"sha": "2b7b3756b68b39d4165c7fe9444d4a299f90b1ac", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -29243,18 +29243,24 @@ extract_autos_r (tree t, void *data)\n     {\n       /* All the autos were built with index 0; fix that up now.  */\n       tree *p = hash.find_slot (t, INSERT);\n-      unsigned idx;\n+      int idx;\n       if (*p)\n \t/* If this is a repeated constrained-type-specifier, use the index we\n \t   chose before.  */\n-\tidx = TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (*p));\n+\tidx = TEMPLATE_TYPE_IDX (*p);\n       else\n \t{\n \t  /* Otherwise this is new, so use the current count.  */\n \t  *p = t;\n \t  idx = hash.elements () - 1;\n \t}\n-      TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (t)) = idx;\n+      if (idx != TEMPLATE_TYPE_IDX (t))\n+\t{\n+\t  gcc_checking_assert (TEMPLATE_TYPE_IDX (t) == 0);\n+\t  gcc_checking_assert (TYPE_CANONICAL (t) != t);\n+\t  TEMPLATE_TYPE_IDX (t) = idx;\n+\t  TYPE_CANONICAL (t) = canonical_type_parameter (t);\n+\t}\n     }\n \n   /* Always keep walking.  */"}, {"sha": "ec31f0ac43e7221a85128e27487ece864106a352", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -4867,6 +4867,8 @@ supported as cross-compilation target only.\n @c alone is too unspecific and must be avoided.\n @anchor{x-x-solaris2}\n @heading *-*-solaris2*\n+Support for Solaris 11.3 and earlier has been obsoleted in GCC 13, but\n+can still be enabled by configuring with @option{--enable-obsolete}.\n Support for Solaris 10 has been removed in GCC 10.  Support for Solaris\n 9 has been removed in GCC 5.  Support for Solaris 8 has been removed in\n GCC 4.8.  Support for Solaris 7 has been removed in GCC 4.6."}, {"sha": "d8a2079760355a27058a30b5e70f486342ed8be8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -17693,7 +17693,8 @@ needs to build supplementary stub code for constructors to work.  On\n multi-libbed systems, @samp{gcc -shared} must select the correct support\n libraries to link against.  Failing to supply the correct flags may lead\n to subtle defects.  Supplying them in cases where they are not necessary\n-is innocuous.}\n+is innocuous. For x86, crtfastmath.o will not be added when\n+@option{-shared} is specified. }\n \n @item -shared-libgcc\n @itemx -static-libgcc"}, {"sha": "8ca9af2a996ee955e726c69ac281b7b7db085157", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,8 @@\n+2022-12-18  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/107397\n+\t* decl.cc (add_init_expr_to_sym): Add check with new error message.\n+\n 2022-12-14  Julian Brown  <julian@codesourcery.com>\n \n \tPR fortran/107214"}, {"sha": "1562dc22bc6e20d51d56c13d03c1b4aea1049e9b", "filename": "gcc/fortran/decl.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ffortran%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ffortran%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2221,6 +2221,14 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t    sym->ts.f90_type = init->ts.f90_type;\n \t}\n \n+      /* Catch the case:  type(t), parameter :: x = z'1'.  */\n+      if (sym->ts.type == BT_DERIVED && init->ts.type == BT_BOZ)\n+\t{\n+\t  gfc_error (\"Entity %qs at %L is incompatible with a BOZ \"\n+\t\t     \"literal constant\", name, &sym->declared_at);\n+\t  return false;\n+\t}\n+\n       /* Add initializer.  Make sure we keep the ranks sane.  */\n       if (sym->attr.dimension && init->rank == 0)\n \t{"}, {"sha": "6ed8eb69032b912fb4e293ba80e04d270d6f5d97", "filename": "gcc/m2/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,25 @@\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gm2-gcc/m2linemap.cc (m2linemap_ErrorAt, m2linemap_ErrorAtf,\n+\tm2linemap_WarningAtf, m2linemap_NoteAtf, m2linemap_internal_error):\n+\tCall functions with \"%s\", message rather than just message, so that\n+\t% chars in message aren't treated as format specifiers.\n+\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR modula2/108147\n+\t* gm2-gcc/m2linemap.def (ErrorAtf, WarningAtf, NoteAtf):\n+\tComment out prototypes with varargs.\n+\t* gm2-gcc/m2linemap.h (m2linemap_ErrorAtf, m2linemap_WarningAtf,\n+\tm2linemap_NoteAtf): No longer varargs.\n+\t* gm2-gcc/m2linemap.cc (m2linemap_ErrorAtf): Turned into a\n+\tnon-varargs wrapper around ...\n+\t(m2linemap_ErrorAtf_1): ... this.  New static function.\n+\t(m2linemap_WarningAtf): Turned into a non-varargs wrapper around ...\n+\t(m2linemap_WarningAtf_1): ... this.  New static function.\n+\t(m2linemap_NoteAtf): Turned into a non-varargs wrapper around ...\n+\t(m2linemap_NoteAtf_1): ... this.  New static function.\n+\n 2022-12-15  Gaius Mulley  <gaiusmod2@gmail.com>\n \n \t* configure.ac: Stop probing for realpath."}, {"sha": "ba09c0b8c8db1722ed6a2aff783576e2737615b5", "filename": "gcc/m2/gm2-gcc/m2linemap.cc", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -177,13 +177,13 @@ EXTERN\n void\n m2linemap_ErrorAt (location_t location, char *message)\n {\n-  error_at (location, message);\n+  error_at (location, \"%s\", message);\n }\n \n /* m2linemap_ErrorAtf - wraps up an error message.  */\n \n-void\n-m2linemap_ErrorAtf (location_t location, const char *message, ...)\n+static void\n+m2linemap_ErrorAtf_1 (location_t location, const char *message, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n@@ -195,10 +195,16 @@ m2linemap_ErrorAtf (location_t location, const char *message, ...)\n   va_end (ap);\n }\n \n+void\n+m2linemap_ErrorAtf (location_t location, const char *message)\n+{\n+  m2linemap_ErrorAtf_1 (location, \"%s\", message);\n+}\n+\n /* m2linemap_WarningAtf - wraps up a warning message.  */\n \n-void\n-m2linemap_WarningAtf (location_t location, const char *message, ...)\n+static void\n+m2linemap_WarningAtf_1 (location_t location, const char *message, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n@@ -210,10 +216,16 @@ m2linemap_WarningAtf (location_t location, const char *message, ...)\n   va_end (ap);\n }\n \n+void\n+m2linemap_WarningAtf (location_t location, const char *message)\n+{\n+  m2linemap_WarningAtf_1 (location, \"%s\", message);\n+}\n+\n /* m2linemap_NoteAtf - wraps up a note message.  */\n \n-void\n-m2linemap_NoteAtf (location_t location, const char *message, ...)\n+static void\n+m2linemap_NoteAtf_1 (location_t location, const char *message, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n@@ -225,12 +237,18 @@ m2linemap_NoteAtf (location_t location, const char *message, ...)\n   va_end (ap);\n }\n \n+void\n+m2linemap_NoteAtf (location_t location, const char *message)\n+{\n+  m2linemap_NoteAtf_1 (location, \"%s\", message);\n+}\n+\n /* m2linemap_internal_error - allow Modula-2 to use the GCC internal error.  */\n \n void\n m2linemap_internal_error (const char *message)\n {\n-  internal_error (message);\n+  internal_error (\"%s\", message);\n }\n \n /* UnknownLocation - return the predefined location representing an"}, {"sha": "689dcb4b4e194043ce4b233ef357e46b0cfcc535", "filename": "gcc/m2/gm2-gcc/m2linemap.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.def?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -47,11 +47,6 @@ PROCEDURE GetLineNoFromLocation (location: location_t) : INTEGER ;\n PROCEDURE GetColumnNoFromLocation (location: location_t) : INTEGER ;\n PROCEDURE GetFilenameFromLocation (location: location_t) : ADDRESS ;\n PROCEDURE ErrorAt (location: location_t; message: ADDRESS) ;\n-(*\n-PROCEDURE ErrorAtf (location: location_t; message: ADDRESS; ...) ;\n-PROCEDURE WarningAtf (location: location_t; message: ADDRESS; ...) ;\n-PROCEDURE NoteAtf (location: location_t; message: ADDRESS; ...) ;\n-*)\n PROCEDURE ErrorAtf (location: location_t; message: ADDRESS) ;\n PROCEDURE WarningAtf (location: location_t; message: ADDRESS) ;\n PROCEDURE NoteAtf (location: location_t; message: ADDRESS) ;"}, {"sha": "6941983284f40e48a53de5c19b916b101d3b6a60", "filename": "gcc/m2/gm2-gcc/m2linemap.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2linemap.h?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -55,9 +55,9 @@ EXTERN int m2linemap_GetLineNoFromLocation (location_t location);\n EXTERN int m2linemap_GetColumnNoFromLocation (location_t location);\n EXTERN const char *m2linemap_GetFilenameFromLocation (location_t location);\n EXTERN void m2linemap_ErrorAt (location_t location, char *message);\n-EXTERN void m2linemap_ErrorAtf (location_t location, const char *message, ...);\n-EXTERN void m2linemap_WarningAtf (location_t location, const char *message, ...);\n-EXTERN void m2linemap_NoteAtf (location_t location, const char *message, ...);\n+EXTERN void m2linemap_ErrorAtf (location_t location, const char *message);\n+EXTERN void m2linemap_WarningAtf (location_t location, const char *message);\n+EXTERN void m2linemap_NoteAtf (location_t location, const char *message);\n EXTERN void m2linemap_internal_error (const char *message);\n \n "}, {"sha": "eeddfcf1fefefba452a7e2437190d0650ffc3a41", "filename": "gcc/sort.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fsort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Fsort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsort.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -237,6 +237,10 @@ do {                                            \\\n }\n \n #if CHECKING_P\n+  /* Don't complain about cast from void* to function pointer.  */\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wconditionally-supported\"\n+\n /* Adapter for using two-argument comparators in functions expecting the\n    three-argument sort_r_cmp_fn type.  */\n static int\n@@ -266,6 +270,7 @@ gcc_qsort (void *vbase, size_t n, size_t size, cmp_fn *cmp)\n     free (buf);\n #if CHECKING_P\n   qsort_chk (vbase, n, size, cmp2to3, (void*)cmp);\n+#pragma GCC diagnostic pop\n #endif\n }\n "}, {"sha": "fdb864b0ccac26bb6ec9c97d8767bb30581d68dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,3 +1,338 @@\n+2022-12-19  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/100881\n+\t* g++.dg/cpp2a/srcloc3.C: Adjust expected note s/evaluating/using.\n+\t* g++.dg/cpp2a/srcloc4.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc5.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc6.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc7.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc8.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc9.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc10.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc11.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc12.C: Likewise.\n+\t* g++.dg/cpp2a/srcloc13.C: Likewise.\n+\t* g++.dg/modules/pr100881_a.C: New test.\n+\t* g++.dg/modules/pr100881_b.C: New test.\n+\n+2022-12-19  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/101886\n+\t* g++.dg/concepts/auto5.C: New test.\n+\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/108043\n+\t* gcc.dg/pr108043.c: New test.\n+\t* gcc.dg/c99-complit-2.c (foo): Adjust expected diagnostics for\n+\tcomplit with function type.\n+\n+2022-12-19  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/98487\n+\t* c-c++-common/Wsuggest-attribute-1.c: New test.\n+\n+2022-12-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108164\n+\t* gcc.dg/pr108164.c: New testcase.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-10.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-11.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-12.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-13.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-14.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-15.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-16.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-17.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-18.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-19.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-20.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-21.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-22.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-23.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-24.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-25.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-26.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-27.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-28.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-29.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-30.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-31.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-32.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-33.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-34.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-35.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-36.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-37.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-38.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-39.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-40.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-41.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-42.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-43.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-44.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-45.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-46.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-8.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-9.c: New test.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-10.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-11.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-12.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-13.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-14.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-15.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-16.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-17.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-18.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-19.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-20.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-21.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-22.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-23.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-24.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-25.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-26.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-27.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-28.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-8.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-9.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_call-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_call-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_call-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_call-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_complex_loop-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_complex_loop-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-10.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-11.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-12.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-8.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_conflict-9.c: New test.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-10.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-11.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-12.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-13.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-14.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-15.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-16.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-17.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-18.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-19.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-20.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-21.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-22.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-23.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-24.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-25.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-26.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-27.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-28.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-8.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-9.c: New test.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-10.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-11.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-12.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-13.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-14.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-15.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-16.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-17.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-18.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-19.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-20.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-21.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-22.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-23.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-24.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-25.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-26.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-27.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-28.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-8.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_phi-9.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-10.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-11.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-12.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-13.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-14.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-15.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-16.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-8.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-9.c: New test.\n+\n+2022-12-19  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* gcc.target/riscv/rvv/rvv.exp: Adjust to enable tests for VSETVL PASS.\n+\t* gcc.target/riscv/rvv/vsetvl/dump-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-10.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-11.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-12.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-13.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-14.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-15.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-16.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-17.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-18.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-19.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-8.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_block-9.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-1.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-2.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-3.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-4.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-5.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-6.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-7.c: New test.\n+\t* gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-8.c: New test.\n+\n+2022-12-19  Kito Cheng  <kito.cheng@sifive.com>\n+\n+\t* gcc.target/riscv/rvv/base/mov-1.c: Simplify operand check.\n+\t* gcc.target/riscv/rvv/base/mov-10.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-11.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-12.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-2.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-3.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-4.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-5.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-6.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-8.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-9.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/vread_csr.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/vsetvl-1.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/vwrite_csr.c: Ditto.\n+\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR testsuite/108151\n+\t* gcc.dg/pr64536.c (bar): Cast long to __INTPTR_TYPE__\n+\tbefore casting to long *.\n+\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR testsuite/108151\n+\t* gcc.dg/pr64536.c (bar): Use casts to __INTPTR_TYPE__ rather than\n+\tlong when casting pointer to integral type.\n+\n+2022-12-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR target/108140\n+\t* gcc.target/aarch64/acle/pr108140.c: New test.\n+\n+2022-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/107397\n+\t* gfortran.dg/pr107397.f90: Adjust expected diagnostic wording and\n+\tadd space between dg-error string and closing }.\n+\n+2022-12-19  Kito Cheng  <kito.cheng@sifive.com>\n+\n+\t* gcc.target/riscv/rvv/base/vread_csr.c: Use specific option\n+\tinstead.\n+\t* gcc.target/riscv/rvv/base/vwrite_csr.c: Ditto.\n+\n+2022-12-19  Jiufu Guo  <guojiufu@linux.ibm.com>\n+\n+\tPR target/106708\n+\t* gcc.target/powerpc/pr106708.c: New test.\n+\n+2022-12-19  Kito Cheng  <kito.cheng@sifive.com>\n+\n+\t* gcc.target/riscv/rvv/base/mov-1.c: Use double quotes to\n+\tinclude riscv_vector.h rather than angle brackets.\n+\t* gcc.target/riscv/rvv/base/mov-10.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-11.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-12.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-13.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-2.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-3.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-4.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-5.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-6.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-7.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-8.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/mov-9.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/vread_csr.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/vsetvl-1.c: Ditto.\n+\t* gcc.target/riscv/rvv/base/vwrite_csr.c: Ditto.\n+\n+2022-12-18  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2/pimcoroutines/run/pass/testtime.mod: Reduce sleep times in\n+\tthe test by a factor of 25.\n+\n+2022-12-18  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/107397\n+\t* gfortran.dg/pr107397.f90: New test.\n+\n+2022-12-17  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107437\n+\tPR c++/87765\n+\t* g++.dg/cpp1y/lambda-generic-107437.C: New test.\n+\t* g++.dg/cpp1z/constexpr-lambda26.C: Remove dg-ice.\n+\n 2022-12-16  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* lib/target-supports.exp (check_effective_target_static): Return 0"}, {"sha": "8b5b398fb78d74e8b49299109c15524b381d3022", "filename": "gcc/testsuite/c-c++-common/Wsuggest-attribute-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsuggest-attribute-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsuggest-attribute-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsuggest-attribute-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,36 @@\n+/* PR c/98487 */\n+/* { dg-do compile { target { c || c++11 } } } */\n+/* { dg-options \"-Wsuggest-attribute=format\" } */\n+\n+#include <stdarg.h>\n+\n+[[gnu::__format__(__printf__, 1, 2)]]\n+void\n+do_printf(const char * const a0, ...)\n+{\n+  va_list ap;\n+  va_start(ap, a0);\n+  __builtin_vprintf(a0, ap);\n+  va_end(ap);\n+}\n+\n+[[gnu::__format__(__scanf__, 1, 2)]]\n+void\n+do_scanf(const char * const a0, ...)\n+{\n+  va_list ap;\n+  va_start(ap, a0);\n+  __builtin_vscanf(a0, ap);\n+  va_end(ap);\n+}\n+\n+struct tm;\n+\n+[[gnu::__format__(__strftime__, 1, 0)]]\n+void\n+do_strftime(const char * const a0, struct tm * a1)\n+{\n+  char buff[256];\n+  __builtin_strftime(buff, sizeof(buff), a0, a1);\n+  __builtin_puts(buff);\n+}"}, {"sha": "f1d653efd87cded5d19d7abfa4f9776162fcac72", "filename": "gcc/testsuite/g++.dg/concepts/auto5.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto5.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/101886\n+// { dg-do compile { target c++17_only } }\n+// { dg-options \"-fconcepts-ts\" }\n+\n+template<typename...> struct A { };\n+\n+A<int, int> a;\n+A<auto, auto> b1 = a;\n+A<auto, auto> b2 = a;"}, {"sha": "aa8cf98880c0ba70b283a402616413f9ad2af34f", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc10.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -10,4 +10,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location::__impl' does not contain only non-static data members '_M_file_name', '_M_function_name', '_M_line' and '_M_column'\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "07281ca0ad0c29f794e5c4ac306a4056e79969e5", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc11.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -10,4 +10,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location::__impl' does not contain only non-static data members '_M_file_name', '_M_function_name', '_M_line' and '_M_column'\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "445c4a1337400deba0d71fd3aff37743d250a487", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc12.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc12.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -11,4 +11,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location::__impl::_M_file_name' does not have 'const char \\\\*' type\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "d63f6c7d932471c033003dcbeb3a55861a5140f9", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc13.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -12,4 +12,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location::__impl::_M_line' does not have integral type\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "324e03cd5480c5deec3f48f6df7dc9858d163946", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc3.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,4 +2,4 @@\n \n auto x = __builtin_source_location ();\t// { dg-error \"'source_location' is not a member of 'std'\" }\n // { dg-message \"std::source_location' is defined in header '<source_location>'; did you forget to '#include <source_location>'\" \"\" { target *-*-* } .-1 }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-2 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-2 }"}, {"sha": "9e92c449fc34713523cf109f3aad6f5a8763bcb5", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc4.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -5,4 +5,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'void std::source_location\\\\(\\\\)' is not a type\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "ed4b9351f74c7db33843d2eb380cca078853ba46", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc5.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -6,4 +6,4 @@ namespace std {\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location'\\[^\\n\\r]*is not a class type\" }\n // { dg-error \"'__impl' is not a member of 'std::source_location'\" \"\" { target *-*-* } .-1 }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-2 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-2 }"}, {"sha": "bec51e290b2dedd2e13d2fc2776336cbd7f217f8", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc6.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -6,4 +6,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'__impl' is not a member of 'std::source_location'\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "c81fa63f4189b940c182715e22a5dd94370b66fe", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc7.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -7,4 +7,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location::__impl\\\\(\\\\)' is not a type\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "158cc3f93d16cc645458d9588d5e8b955fd790d5", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc8.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -7,4 +7,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location::__impl()' is not a class type\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "618e09356326d81d76ff32908c0e79de78316dea", "filename": "gcc/testsuite/g++.dg/cpp2a/srcloc9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fsrcloc9.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -8,4 +8,4 @@ namespace std {\n }\n \n auto x = __builtin_source_location ();\t// { dg-error \"'std::source_location::__impl' does not contain only non-static data members '_M_file_name', '_M_function_name', '_M_line' and '_M_column'\" }\n-// { dg-message \"evaluating '__builtin_source_location'\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"using '__builtin_source_location'\" \"\" { target *-*-* } .-1 }"}, {"sha": "95546932dcaac48d93244398cd70ebc4a4331973", "filename": "gcc/testsuite/g++.dg/modules/pr100881_a.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr100881_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr100881_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr100881_a.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/100881\n+// { dg-additional-options \"-std=c++20 -fmodules-ts\" }\n+// { dg-module-cmi pr100881 }\n+module;\n+#include <source_location>\n+export module pr100881;\n+\n+export\n+consteval int\n+current_line_fn(const std::source_location& loc = std::source_location::current())\n+{\n+  return loc.line();\n+}\n+\n+export\n+struct current_line_cls\n+{\n+  int line = std::source_location::current().line();\n+};\n+\n+export\n+template<class T>\n+consteval int\n+current_line_fn_tmpl(const std::source_location& loc = std::source_location::current())\n+{\n+  return loc.line();\n+}\n+\n+export\n+template<class T>\n+struct current_line_cls_tmpl\n+{\n+  int line = std::source_location::current().line();\n+};"}, {"sha": "7f25b21b354d5aa4ea51309bf349dfa7f3423177", "filename": "gcc/testsuite/g++.dg/modules/pr100881_b.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr100881_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr100881_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr100881_b.C?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/100881\n+// { dg-additional-options \"-std=c++20 -fmodules-ts\" }\n+import pr100881;\n+\n+static_assert(current_line_fn() == 5);\n+static_assert(current_line_cls{}.line == 6);\n+static_assert(current_line_fn_tmpl<int>() == 7);\n+static_assert(current_line_cls_tmpl<int>{}.line == 8);"}, {"sha": "5e1b5be8e282bcc697786c2c4336c7c9a4c56dcb", "filename": "gcc/testsuite/gcc.dg/c99-complit-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -23,7 +23,7 @@ foo (int a)\n   /* { dg-error \"init\" \"incomplete union type\" { target *-*-* } .-1 } */\n   /* { dg-error \"invalid use of undefined type\" \"\" { target *-*-* } .-2 } */\n   (void (void)) { 0 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-  /* { dg-error \"init\" \"function type\" { target *-*-* } .-1 } */\n+  /* { dg-error \"compound literal has function type\" \"function type\" { target *-*-* } .-1 } */\n   (int [a]) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n   /* { dg-error \"init|variable\" \"VLA type\" { target *-*-* } .-1 } */\n   /* Initializers must not attempt to initialize outside the object"}, {"sha": "0cc0700f30a070965644ea03f7de25f236d3140e", "filename": "gcc/testsuite/gcc.dg/pr108043.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108043.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108043.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108043.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,12 @@\n+/* PR c/108043 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+typedef void F (void);\n+\n+void\n+foo (void)\n+{\n+  (F) {};\t\t/* { dg-error \"compound literal has function type\" } */\n+  (F) { foo };\t\t/* { dg-error \"compound literal has function type\" } */\n+}"}, {"sha": "d76d557876ef430f9d03af79f42c70f4f438e6f0", "filename": "gcc/testsuite/gcc.dg/pr108164.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108164.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108164.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108164.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-tree-dce\" } */\n+\n+int a, b, c;\n+int main()\n+{\n+  int e = -1;\n+  short f = -1;\n+  for (; c < 1; c++)\n+    while (f >= e)\n+      f++;\n+  for (; a < 2; a++) {\n+    short g = ~(~b | ~f);\n+    int h = -g;\n+    int i = (3 / ~h) / ~b;\n+    b = i;\n+  }\n+  return 0;\n+}"}, {"sha": "18afa9d02329ca7092e8f4da312690206adfaac3", "filename": "gcc/testsuite/gcc.dg/pr64536.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64536.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64536.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64536.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -40,8 +40,8 @@ bar (int x)\n \t      h->q = *f;\n \t    }\n \t  else\n-\t    i = (long *) (h->q = *f);\n-\t  *c++ = (long) f;\n+\t    i = (long *) (__INTPTR_TYPE__) (h->q = *f);\n+\t  *c++ = (__INTPTR_TYPE__) f;\n \t  e += 6;\n \t}\n       else\n@@ -54,8 +54,8 @@ bar (int x)\n \t      h->q = *f;\n \t    }\n \t  else\n-\t    i = (long *) (h->q = *f);\n-\t  *c++ = (long) f;\n+\t    i = (long *) (__INTPTR_TYPE__) (h->q = *f);\n+\t  *c++ = (__INTPTR_TYPE__) f;\n \t  e += 6;\n \t}\n     }"}, {"sha": "967928a7dca73c6d309312c17388ed9dae9905f4", "filename": "gcc/testsuite/gcc.target/aarch64/acle/pr108140.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fpr108140.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fpr108140.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fpr108140.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,15 @@\n+/* PR target/108140  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include<arm_acle.h>\n+\n+int\n+main(int argc, char *argv[])\n+{\n+\tunsigned long long input = argc-1;\n+\tunsigned long long v = __clz(__rbit(input));\n+\t__builtin_printf(\"%d %d\\n\", argc, v >= 64 ? 123 : 456);\n+\treturn 0;\n+}\n+"}, {"sha": "41c686bb4cbd8457348fa52dd36dc388a7aca416", "filename": "gcc/testsuite/gcc.target/powerpc/pr103743.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-options \"-O2\" } */\n+/* { dg-do compile { target has_arch_ppc64 } } */\n+\n+/* { dg-final { scan-assembler-times {\\mcmpldi\\M} 10  } } */\n+/* { dg-final { scan-assembler-times {\\mcmpdi\\M} 4  } } */\n+/* { dg-final { scan-assembler-times {\\mrotldi\\M} 14  } } */\n+\n+int foo (int a);\n+\n+int __attribute__ ((noinline)) udi_fun (unsigned long long in)\n+{\n+  if (in == (0x8642000000000000ULL))\n+    return foo (1);\n+  if (in == (0x7642000000000000ULL))\n+    return foo (12);\n+  if (in == (0x8000000000000000ULL))\n+    return foo (32);\n+  if (in == (0x8700000000000091ULL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFULL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFULL))\n+    return foo (51);\n+  if (in == (0x7567000000ULL))\n+    return foo (9);\n+  if (in == (0xFFF8567FFFFFFFFFULL))\n+    return foo (19);\n+\n+  return 0;\n+}\n+\n+int __attribute__ ((noinline)) di_fun (long long in)\n+{\n+  if (in == (0x8642000000000000LL))\n+    return foo (1);\n+  if (in == (0x7642000000000000LL))\n+    return foo (12);\n+  if (in == (0x8000000000000000LL))\n+    return foo (32);\n+  if (in == (0x8700000000000091LL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFLL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFLL))\n+    return foo (51);\n+  if (in == (0x7567000000LL))\n+    return foo (9);\n+  if (in == (0xFFF8567FFFFFFFFFLL))\n+    return foo (19);\n+\n+  return 0;\n+}"}, {"sha": "e128aae7574c2ea6988dbd1142a37a550a970cd5", "filename": "gcc/testsuite/gcc.target/powerpc/pr103743_1.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103743_1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+int\n+foo (int a)\n+{\n+  return a + 6;\n+}\n+\n+int __attribute__ ((noipa)) udi_fun (unsigned long long in)\n+{\n+  if (in == (0x8642000000000000ULL))\n+    return foo (1);\n+  if (in == (0x7642000000000000ULL))\n+    return foo (12);\n+  if (in == (0x8000000000000000ULL))\n+    return foo (32);\n+  if (in == (0x8700000000000091ULL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFULL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFULL))\n+    return foo (51);\n+  if (in == (0x7567000000ULL))\n+    return foo (9);\n+  if (in == (0xFFF8567FFFFFFFFFULL))\n+    return foo (19);\n+  \n+  return 0;\n+}\n+\n+int __attribute__ ((noipa)) di_fun (long long in)\n+{\n+  if (in == (0x8642000000000000LL))\n+    return foo (1);\n+  if (in == (0x7642000000000000LL))\n+    return foo (12);\n+  if (in == (0x8000000000000000LL))\n+    return foo (32);\n+  if (in == (0x8700000000000091LL))\n+    return foo (33);\n+  if (in == (0x8642FFFFFFFFFFFFLL))\n+    return foo (46);\n+  if (in == (0x7642FFFFFFFFFFFFLL))\n+    return foo (51);\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  int e = 0;\n+  if (udi_fun (6) != 0)\n+    e++;\n+  if (udi_fun (0x8642000000000000ULL) != foo (1))\n+    e++;\n+  if (udi_fun (0x7642000000000000ULL) != foo (12))\n+    e++;\n+  if (udi_fun (0x8000000000000000ULL) != foo (32))\n+    e++;\n+  if (udi_fun (0x8700000000000091ULL) != foo (33))\n+    e++;\n+  if (udi_fun (0x8642FFFFFFFFFFFFULL) != foo (46))\n+    e++;\n+  if (udi_fun (0x7642FFFFFFFFFFFFULL) != foo (51))\n+    e++;\n+  if (udi_fun (0x7567000000ULL) != foo (9))\n+    e++;\n+  if (udi_fun (0xFFF8567FFFFFFFFFULL) != foo (19))\n+    e++;\n+\n+  if (di_fun (6) != 0)\n+    e++;\n+  if (di_fun (0x8642000000000000LL) != foo (1))\n+    e++;\n+  if (di_fun (0x7642000000000000LL) != foo (12))\n+    e++;\n+  if (di_fun (0x8000000000000000LL) != foo (32))\n+    e++;\n+  if (di_fun (0x8700000000000091LL) != foo (33))\n+    e++;\n+  if (di_fun (0x8642FFFFFFFFFFFFLL) != foo (46))\n+    e++;\n+  if (di_fun (0x7642FFFFFFFFFFFFLL) != foo (51))\n+    e++;\n+  if (udi_fun (0x7567000000LL) != foo (9))\n+    e++;\n+  if (udi_fun (0xFFF8567FFFFFFFFFLL) != foo (19))\n+    e++;\n+\n+  if (e)\n+    __builtin_abort ();\n+  return 0;\n+}\n+"}, {"sha": "ddb9160d4b8e84e8a94bece3054d10a680432e45", "filename": "gcc/testsuite/gcc.target/powerpc/pr106708.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr106708.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr106708.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr106708.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,41 @@\n+/* PR target/106708 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mno-prefixed -save-temps\" } */\n+/* { dg-require-effective-target has_arch_ppc64 } */\n+\n+long long arr[]\n+  = {0xffffffff7cdeab55LL, 0x98765432LL, 0xabcd0000LL};\n+\n+void __attribute__ ((__noipa__)) test_li_xoris (long long *arg)\n+{\n+  *arg = 0xffffffff7cdeab55LL;\n+}\n+/* { dg-final { scan-assembler-times {\\mli .*,-21675\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxoris .*0x8321\\M} 1 } } */\n+\n+void __attribute__ ((__noipa__)) test_li_oris (long long *arg)\n+{\n+  *arg = 0x98765432LL;\n+}\n+/* { dg-final { scan-assembler-times {\\mli .*,21554\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\moris .*0x9876\\M} 1 } } */\n+\n+void __attribute__ ((__noipa__)) test_lis_rldicl (long long *arg)\n+{\n+  *arg = 0xabcd0000LL;\n+}\n+/* { dg-final { scan-assembler-times {\\mlis .*,0xabcd\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mrldicl .*,0,32\\M} 1 } } */\n+\n+int\n+main ()\n+{\n+  long long a[sizeof (arr) / sizeof (arr[0])];\n+\n+  test_li_xoris (a);\n+  test_li_oris (a + 1);\n+  test_lis_rldicl (a + 2);\n+  if (__builtin_memcmp (a, arr, sizeof (arr)) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "fbf2526c603d5b1c1104f7d85161ff5923028078", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-1.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,13 +2,13 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /*\n ** mov1:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov1 (int8_t *in, int8_t *out)\n@@ -19,9 +19,9 @@ void mov1 (int8_t *in, int8_t *out)\n \n /*\n ** mov2:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov2 (int8_t *in, int8_t *out)\n@@ -32,9 +32,9 @@ void mov2 (int8_t *in, int8_t *out)\n \n /*\n ** mov3:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov3 (int8_t *in, int8_t *out)\n@@ -45,8 +45,8 @@ void mov3 (int8_t *in, int8_t *out)\n \n /*\n ** mov4:\n-**\tvl1re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov4 (int8_t *in, int8_t *out)\n@@ -57,8 +57,8 @@ void mov4 (int8_t *in, int8_t *out)\n \n /*\n ** mov5:\n-**\tvl2re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov5 (int8_t *in, int8_t *out)\n@@ -69,8 +69,8 @@ void mov5 (int8_t *in, int8_t *out)\n \n /*\n ** mov6:\n-**\tvl4re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov6 (int8_t *in, int8_t *out)\n@@ -81,8 +81,8 @@ void mov6 (int8_t *in, int8_t *out)\n \n /*\n ** mov7:\n-**\tvl8re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov7 (int8_t *in, int8_t *out)\n@@ -93,9 +93,9 @@ void mov7 (int8_t *in, int8_t *out)\n \n /*\n ** mov8:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov8 (uint8_t *in, uint8_t *out)\n@@ -106,9 +106,9 @@ void mov8 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov9:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov9 (uint8_t *in, uint8_t *out)\n@@ -119,9 +119,9 @@ void mov9 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov10:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov10 (uint8_t *in, uint8_t *out)\n@@ -132,8 +132,8 @@ void mov10 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov11:\n-**\tvl1re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov11 (uint8_t *in, uint8_t *out)\n@@ -144,8 +144,8 @@ void mov11 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov12:\n-**\tvl2re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov12 (uint8_t *in, uint8_t *out)\n@@ -156,8 +156,8 @@ void mov12 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov13:\n-**\tvl4re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov13 (uint8_t *in, uint8_t *out)\n@@ -168,8 +168,8 @@ void mov13 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov14:\n-**\tvl8re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov14 (uint8_t *in, uint8_t *out)"}, {"sha": "d628f594fb31822154019437b94a3be0dff9a202", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-10.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,12 +2,12 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h> \n+#include \"riscv_vector.h\" \n \n /*\n ** mov1:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **  ...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -24,8 +24,8 @@ void mov1 (int8_t *in, int8_t *out)\n \n /*\n ** mov2:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -42,8 +42,8 @@ void mov2 (int8_t *in, int8_t *out)\n \n /*\n ** mov3:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -60,7 +60,7 @@ void mov3 (int8_t *in, int8_t *out)\n \n /*\n ** mov4:\n-**\tvl1re8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -77,7 +77,7 @@ void mov4 (int8_t *in, int8_t *out)\n \n /*\n ** mov5:\n-**\tvl2re8\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re8\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -94,7 +94,7 @@ void mov5 (int8_t *in, int8_t *out)\n \n /*\n ** mov6:\n-**\tvl4re8\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re8\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -111,7 +111,7 @@ void mov6 (int8_t *in, int8_t *out)\n \n /*\n ** mov7:\n-**\tvl8re8\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re8\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t...\n@@ -128,8 +128,8 @@ void mov7 (int8_t *in, int8_t *out)\n \n /*\n ** mov8:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -146,8 +146,8 @@ void mov8 (int16_t *in, int16_t *out)\n \n /*\n ** mov9:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -164,7 +164,7 @@ void mov9 (int16_t *in, int16_t *out)\n \n /*\n ** mov10:\n-**\tvl1re16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re16\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -181,7 +181,7 @@ void mov10 (int16_t *in, int16_t *out)\n \n /*\n ** mov11:\n-**\tvl2re16\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re16\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -198,7 +198,7 @@ void mov11 (int16_t *in, int16_t *out)\n \n /*\n ** mov12:\n-**\tvl4re16\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re16\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -215,7 +215,7 @@ void mov12 (int16_t *in, int16_t *out)\n \n /*\n ** mov13:\n-**\tvl8re16\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re16\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t...\n@@ -232,8 +232,8 @@ void mov13 (int32_t *in, int32_t *out)\n \n /*\n ** mov14:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -250,7 +250,7 @@ void mov14 (int32_t *in, int32_t *out)\n \n /*\n ** mov15:\n-**\tvl1re32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re32\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -267,7 +267,7 @@ void mov15 (int32_t *in, int32_t *out)\n \n /*\n ** mov16:\n-**\tvl2re32\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re32\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -284,7 +284,7 @@ void mov16 (int32_t *in, int32_t *out)\n \n /*\n ** mov17:\n-**\tvl4re32\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re32\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -301,7 +301,7 @@ void mov17 (int32_t *in, int32_t *out)\n \n /*\n ** mov18:\n-**\tvl8re32\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re32\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t...\n@@ -318,7 +318,7 @@ void mov18 (int32_t *in, int32_t *out)\n \n /*\n ** mov19:\n-**\tvl1re64\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re64\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -335,7 +335,7 @@ void mov19 (int64_t *in, int64_t *out)\n \n /*\n ** mov20:\n-**\tvl2re64\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re64\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -352,7 +352,7 @@ void mov20 (int64_t *in, int64_t *out)\n \n /*\n ** mov21:\n-**\tvl4re64\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re64\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -369,7 +369,7 @@ void mov21 (int64_t *in, int64_t *out)\n \n /*\n ** mov22:\n-**\tvl8re64\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re64\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t..."}, {"sha": "4429c0b88ee7df0c3b466c6ae63e0a080db24020", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-11.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,12 +2,12 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h> \n+#include \"riscv_vector.h\" \n \n /*\n ** mov1:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **  ...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -24,8 +24,8 @@ void mov1 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov2:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -42,8 +42,8 @@ void mov2 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov3:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -60,7 +60,7 @@ void mov3 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov4:\n-**\tvl1re8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re8\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -77,7 +77,7 @@ void mov4 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov5:\n-**\tvl2re8\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re8\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -94,7 +94,7 @@ void mov5 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov6:\n-**\tvl4re8\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re8\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -111,7 +111,7 @@ void mov6 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov7:\n-**\tvl8re8\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re8\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t...\n@@ -128,8 +128,8 @@ void mov7 (uint8_t *in, uint8_t *out)\n \n /*\n ** mov8:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -146,8 +146,8 @@ void mov8 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov9:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -164,7 +164,7 @@ void mov9 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov10:\n-**\tvl1re16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re16\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -181,7 +181,7 @@ void mov10 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov11:\n-**\tvl2re16\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re16\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -198,7 +198,7 @@ void mov11 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov12:\n-**\tvl4re16\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re16\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -215,7 +215,7 @@ void mov12 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov13:\n-**\tvl8re16\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re16\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t...\n@@ -232,8 +232,8 @@ void mov13 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov14:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -250,7 +250,7 @@ void mov14 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov15:\n-**\tvl1re32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re32\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -267,7 +267,7 @@ void mov15 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov16:\n-**\tvl2re32\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re32\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -284,7 +284,7 @@ void mov16 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov17:\n-**\tvl4re32\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re32\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -301,7 +301,7 @@ void mov17 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov18:\n-**\tvl8re32\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re32\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t...\n@@ -318,7 +318,7 @@ void mov18 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov19:\n-**\tvl1re64\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re64\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -335,7 +335,7 @@ void mov19 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov20:\n-**\tvl2re64\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re64\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -352,7 +352,7 @@ void mov20 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov21:\n-**\tvl4re64\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re64\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -369,7 +369,7 @@ void mov21 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov22:\n-**\tvl8re64\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re64\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t..."}, {"sha": "d34c139dbcf13b7b95f49232d65bd680e0fd1fb5", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-12.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,12 +2,12 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h> \n+#include \"riscv_vector.h\" \n \n /*\n ** mov14:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -24,7 +24,7 @@ void mov14 (float *in, float *out)\n \n /*\n ** mov15:\n-**\tvl1re32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re32\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -41,7 +41,7 @@ void mov15 (float *in, float *out)\n \n /*\n ** mov16:\n-**\tvl2re32\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re32\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -58,7 +58,7 @@ void mov16 (float *in, float *out)\n \n /*\n ** mov17:\n-**\tvl4re32\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re32\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -75,7 +75,7 @@ void mov17 (float *in, float *out)\n \n /*\n ** mov18:\n-**\tvl8re32\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re32\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t...\n@@ -92,7 +92,7 @@ void mov18 (float *in, float *out)\n \n /*\n ** mov19:\n-**\tvl1re64\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re64\\.v\\tv1,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv1r\\.v\\tv2,v1\n **\t...\n@@ -109,7 +109,7 @@ void mov19 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov20:\n-**\tvl2re64\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re64\\.v\\tv2,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv2r\\.v\\tv4,v2\n **\t...\n@@ -126,7 +126,7 @@ void mov20 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov21:\n-**\tvl4re64\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re64\\.v\\tv4,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv4r\\.v\\tv8,v4\n **\t...\n@@ -143,7 +143,7 @@ void mov21 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov22:\n-**\tvl8re64\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re64\\.v\\tv8,0\\s*\\([a-x0-9]+\\)\n **\t...\n **  vmv8r\\.v\\tv16,v8\n **\t..."}, {"sha": "9515e07eca19c82d35a335e8ce611c603357e271", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-13.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n \n-#include <riscv_vector.h> \n+#include \"riscv_vector.h\" \n \n void mov1 (int8_t *in, int8_t *out) \n { "}, {"sha": "630daf5d31df844e9a25573ced2dd1b76b49ffce", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-2.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,13 +2,13 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /*\n ** mov2:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov2 (int16_t *in, int16_t *out)\n@@ -19,9 +19,9 @@ void mov2 (int16_t *in, int16_t *out)\n \n /*\n ** mov3:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov3 (int16_t *in, int16_t *out)\n@@ -32,8 +32,8 @@ void mov3 (int16_t *in, int16_t *out)\n \n /*\n ** mov4:\n-**\tvl1re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov4 (int16_t *in, int16_t *out)\n@@ -44,8 +44,8 @@ void mov4 (int16_t *in, int16_t *out)\n \n /*\n ** mov5:\n-**\tvl2re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov5 (int16_t *in, int16_t *out)\n@@ -56,8 +56,8 @@ void mov5 (int16_t *in, int16_t *out)\n \n /*\n ** mov6:\n-**\tvl4re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov6 (int16_t *in, int16_t *out)\n@@ -68,8 +68,8 @@ void mov6 (int16_t *in, int16_t *out)\n \n /*\n ** mov7:\n-**\tvl8re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov7 (int16_t *in, int16_t *out)\n@@ -80,9 +80,9 @@ void mov7 (int16_t *in, int16_t *out)\n \n /*\n ** mov8:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov8 (uint16_t *in, uint16_t *out)\n@@ -93,9 +93,9 @@ void mov8 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov9:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov9 (uint16_t *in, uint16_t *out)\n@@ -106,8 +106,8 @@ void mov9 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov10:\n-**\tvl1re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov10 (uint16_t *in, uint16_t *out)\n@@ -118,8 +118,8 @@ void mov10 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov11:\n-**\tvl2re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov11 (uint16_t *in, uint16_t *out)\n@@ -130,8 +130,8 @@ void mov11 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov12:\n-**\tvl4re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov12 (uint16_t *in, uint16_t *out)\n@@ -142,8 +142,8 @@ void mov12 (uint16_t *in, uint16_t *out)\n \n /*\n ** mov13:\n-**\tvl8re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov13 (uint16_t *in, uint16_t *out)"}, {"sha": "bf847bc7a1aeb18b15e9eeea8ea83a0d865f14f3", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-3.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,13 +2,13 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /*\n ** mov3:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov3 (int32_t *in, int32_t *out)\n@@ -19,8 +19,8 @@ void mov3 (int32_t *in, int32_t *out)\n \n /*\n ** mov4:\n-**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov4 (int32_t *in, int32_t *out)\n@@ -31,8 +31,8 @@ void mov4 (int32_t *in, int32_t *out)\n \n /*\n ** mov5:\n-**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov5 (int32_t *in, int32_t *out)\n@@ -43,8 +43,8 @@ void mov5 (int32_t *in, int32_t *out)\n \n /*\n ** mov6:\n-**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov6 (int32_t *in, int32_t *out)\n@@ -55,8 +55,8 @@ void mov6 (int32_t *in, int32_t *out)\n \n /*\n ** mov7:\n-**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov7 (int32_t *in, int32_t *out)\n@@ -67,9 +67,9 @@ void mov7 (int32_t *in, int32_t *out)\n \n /*\n ** mov8:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov8 (uint32_t *in, uint32_t *out)\n@@ -80,8 +80,8 @@ void mov8 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov9:\n-**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov9 (uint32_t *in, uint32_t *out)\n@@ -92,8 +92,8 @@ void mov9 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov10:\n-**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov10 (uint32_t *in, uint32_t *out)\n@@ -104,8 +104,8 @@ void mov10 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov11:\n-**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov11 (uint32_t *in, uint32_t *out)\n@@ -116,8 +116,8 @@ void mov11 (uint32_t *in, uint32_t *out)\n \n /*\n ** mov12:\n-**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov12 (uint32_t *in, uint32_t *out)"}, {"sha": "b23a033be1602ed50034e1437e1dbd0730ab2666", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-4.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,12 +2,12 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /*\n ** mov4:\n-**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov4 (int64_t *in, int64_t *out)\n@@ -18,8 +18,8 @@ void mov4 (int64_t *in, int64_t *out)\n \n /*\n ** mov5:\n-**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov5 (int64_t *in, int64_t *out)\n@@ -30,8 +30,8 @@ void mov5 (int64_t *in, int64_t *out)\n \n /*\n ** mov6:\n-**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov6 (int64_t *in, int64_t *out)\n@@ -42,8 +42,8 @@ void mov6 (int64_t *in, int64_t *out)\n \n /*\n ** mov7:\n-**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov7 (int64_t *in, int64_t *out)\n@@ -54,8 +54,8 @@ void mov7 (int64_t *in, int64_t *out)\n \n /*\n ** mov8:\n-**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov8 (uint64_t *in, uint64_t *out)\n@@ -66,8 +66,8 @@ void mov8 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov9:\n-**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov9 (uint64_t *in, uint64_t *out)\n@@ -78,8 +78,8 @@ void mov9 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov10:\n-**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov10 (uint64_t *in, uint64_t *out)\n@@ -90,8 +90,8 @@ void mov10 (uint64_t *in, uint64_t *out)\n \n /*\n ** mov11:\n-**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov11 (uint64_t *in, uint64_t *out)"}, {"sha": "1348eec46fe145f6c95918d762b2b535a704114d", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-5.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,13 +2,13 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /*\n ** mov3:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov3 (float *in, float *out)\n@@ -19,8 +19,8 @@ void mov3 (float *in, float *out)\n \n /*\n ** mov4:\n-**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov4 (float *in, float *out)\n@@ -31,8 +31,8 @@ void mov4 (float *in, float *out)\n \n /*\n ** mov5:\n-**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov5 (float *in, float *out)\n@@ -43,8 +43,8 @@ void mov5 (float *in, float *out)\n \n /*\n ** mov6:\n-**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov6 (float *in, float *out)\n@@ -55,8 +55,8 @@ void mov6 (float *in, float *out)\n \n /*\n ** mov7:\n-**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov7 (float *in, float *out)"}, {"sha": "463be11b01a1cdd2f68458a3b99857c10fa03c3e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-6.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,12 +2,12 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /*\n ** mov4:\n-**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov4 (double *in, double *out)\n@@ -18,8 +18,8 @@ void mov4 (double *in, double *out)\n \n /*\n ** mov5:\n-**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov5 (double *in, double *out)\n@@ -30,8 +30,8 @@ void mov5 (double *in, double *out)\n \n /*\n ** mov6:\n-**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov6 (double *in, double *out)\n@@ -42,8 +42,8 @@ void mov6 (double *in, double *out)\n \n /*\n ** mov7:\n-**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov7 (double *in, double *out)"}, {"sha": "c60920a88477dec6fb5b8c240c1ae5b30fa7b31c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /* This testcase is testing whether RISC-V define REGMODE_NATURAL_SIZE.  */\n void foo (int8_t *in, int8_t *out)"}, {"sha": "26a699d6bb62503a3fd0520cf13010da6cdd175f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-8.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,13 +2,13 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /*\n ** mov1:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n-**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov1 (int8_t *in, int8_t *out)\n@@ -19,9 +19,9 @@ void mov1 (int8_t *in, int8_t *out)\n \n /*\n ** mov2:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov2 (int8_t *in, int8_t *out)\n@@ -32,9 +32,9 @@ void mov2 (int8_t *in, int8_t *out)\n \n /*\n ** mov3:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov3 (int8_t *in, int8_t *out)\n@@ -45,9 +45,9 @@ void mov3 (int8_t *in, int8_t *out)\n \n /*\n ** mov4:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\n-**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov4 (int8_t *in, int8_t *out)\n@@ -58,9 +58,9 @@ void mov4 (int8_t *in, int8_t *out)\n \n /*\n ** mov5:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\n-**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov5 (int8_t *in, int8_t *out)\n@@ -71,9 +71,9 @@ void mov5 (int8_t *in, int8_t *out)\n \n /*\n ** mov6:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\n-**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov6 (int8_t *in, int8_t *out)\n@@ -84,9 +84,9 @@ void mov6 (int8_t *in, int8_t *out)\n \n /*\n ** mov7:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\n-**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov7 (int8_t *in, int8_t *out)"}, {"sha": "7fd38f62769159f4dc79c5e0720406a5b573780f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-9.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,18 +2,18 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n /* Test tieable of RVV types with same LMUL.  */\n /*\n ** mov1:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**  addi\\t(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),1\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**  addi\\t(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),2\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**  addi\\t[a-x0-9]+,[a-x0-9]+,1\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**  addi\\t[a-x0-9]+,[a-x0-9]+,2\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov1 (int8_t *in, int8_t *out, int M)\n@@ -28,11 +28,11 @@ void mov1 (int8_t *in, int8_t *out, int M)\n \n /*\n ** mov2:\n-**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n-**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n-**  addi\\t(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),1\n-**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n+**  addi\\t[a-x0-9]+,[a-x0-9]+,1\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)\n **  ret\n */\n void mov2 (int8_t *in, int8_t *out, int M)"}, {"sha": "950b778919846d14c288aad2c960b706a4c16d0a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/vread_csr.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvread_csr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvread_csr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvread_csr.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,8 +1,7 @@\n /* { dg-do compile } */\n-/* { dg-additional-options \"-O3\" } */\n-/* { dg-skip-if \"test intrinsic using rvv\" { *-*-* } { \"*\" } { \"-march=rv*v*zfh*\" } } */\n+/* { dg-options \"-O3 -march=rv32gcv -mabi=ilp32d\" } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n unsigned long vread_csr_vstart(void) {\n   return vread_csr(RVV_VSTART);\n@@ -20,7 +19,7 @@ unsigned long vread_csr_vcsr(void) {\n   return vread_csr(RVV_VCSR);\n }\n \n-/* { dg-final { scan-assembler-times {csrr\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*vstart} 1 } } */\n-/* { dg-final { scan-assembler-times {csrr\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*vxsat} 1 } } */\n-/* { dg-final { scan-assembler-times {csrr\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*vxrm} 1 } } */\n-/* { dg-final { scan-assembler-times {csrr\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*vcsr} 1 } } */\n+/* { dg-final { scan-assembler-times {csrr\\s+[a-x0-9]+,\\s*vstart} 1 } } */\n+/* { dg-final { scan-assembler-times {csrr\\s+[a-x0-9]+,\\s*vxsat} 1 } } */\n+/* { dg-final { scan-assembler-times {csrr\\s+[a-x0-9]+,\\s*vxrm} 1 } } */\n+/* { dg-final { scan-assembler-times {csrr\\s+[a-x0-9]+,\\s*vcsr} 1 } } */"}, {"sha": "7921f128c501ff5beefa2a691b2a5c8a3c01238c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/vsetvl-1.c", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvsetvl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvsetvl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvsetvl-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -2,7 +2,7 @@\n /* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n \n #include <stddef.h>\n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n size_t test_vsetvl_e8mf8_imm0()\n {\n@@ -660,91 +660,91 @@ size_t test_vsetvlmax_e64m8()\n   return vl;\n }\n \n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e8,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e8,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e8,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e8,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e8,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e8,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e8,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e8,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e8,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e8,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e8,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e8,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e16,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e16,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e16,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e16,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e16,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e16,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e16,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e16,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e16,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e16,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e16,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e16,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e32,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e32,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e32,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e32,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e32,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e32,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e32,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e32,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e32,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e32,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e32,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e32,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e64,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e64,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e64,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e64,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e64,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e64,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e64,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e64,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e64,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e64,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e64,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e64,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*0,\\s*e64,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetivli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*31,\\s*e64,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*e64,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e64,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e8,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e8,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e8,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e8,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e8,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e8,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e8,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e8,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e8,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e8,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e8,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e8,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e16,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e16,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e16,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e16,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e16,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e16,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e16,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e16,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e16,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e16,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e16,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e16,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e32,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e32,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e32,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e32,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e32,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e32,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e32,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e32,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e32,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e32,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e32,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e32,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e64,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e64,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e64,\\s*m1,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e64,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e64,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e64,\\s*m2,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m2,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e64,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e64,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e64,\\s*m4,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m4,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*0,\\s*e64,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetivli\\s+[a-x0-9]+,\\s*31,\\s*e64,\\s*m8,\\s*ta,\\s*mu} 1 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*e64,\\s*m8,\\s*ta,\\s*mu} 2 } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m8,\\s*ta,\\s*mu} 1 } } */"}, {"sha": "e40636ed9c6a3c3d4426997200f70a4a1aea9100", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/vwrite_csr.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvwrite_csr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvwrite_csr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fvwrite_csr.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -1,8 +1,7 @@\n /* { dg-do compile } */\n-/* { dg-additional-options \"-O3\" } */\n-/* { dg-skip-if \"test intrinsic using rvv\" { *-*-* } { \"*\" } { \"-march=rv*v*zfh*\" } } */\n+/* { dg-options \"-O3 -march=rv32gcv -mabi=ilp32d\" } */\n \n-#include <riscv_vector.h>\n+#include \"riscv_vector.h\"\n \n void vwrite_csr_vstart(unsigned long value) {\n   vwrite_csr(RVV_VSTART, value);\n@@ -20,7 +19,7 @@ void vwrite_csr_vcsr(unsigned long value) {\n   vwrite_csr(RVV_VCSR, value);\n }\n \n-/* { dg-final { scan-assembler-times {csrw\\s+vstart,\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])} 1 } } */\n-/* { dg-final { scan-assembler-times {csrw\\s+vxsat,\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])} 1 } } */\n-/* { dg-final { scan-assembler-times {csrw\\s+vxrm,\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])} 1 } } */\n-/* { dg-final { scan-assembler-times {csrw\\s+vcsr,\\s*(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])} 1 } } */\n+/* { dg-final { scan-assembler-times {csrw\\s+vstart,\\s*[a-x0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {csrw\\s+vxsat,\\s*[a-x0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {csrw\\s+vxrm,\\s*[a-x0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {csrw\\s+vcsr,\\s*[a-x0-9]+} 1 } } */"}, {"sha": "2ed29e226063692e08b8b333f9f5d26bb2ceb22c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/rvv.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Frvv.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Frvv.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Frvv.exp?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -42,6 +42,8 @@ dg-init\n set CFLAGS \"$DEFAULT_CFLAGS -march=$gcc_march -O3\"\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/base/*.\\[cS\\]]] \\\n \t\"\" $CFLAGS\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vsetvl/*.\\[cS\\]]] \\\n+\t\"\" $CFLAGS\n \n # All done.\n dg-finish"}, {"sha": "fb4edb459a04bb02ef326892aff084916e88f5c3", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/dump-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fdump-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fdump-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fdump-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fdump-rtl-vsetvl-details\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v2;\n+      *(vuint16mf4_t*)(out + i + 1000) = v2;\n+      vbool32_t v4;\n+      *(vbool32_t*)(out + i + 3000) = v4;\n+      vbool16_t v5;\n+      *(vbool16_t*)(out + i + 4000) = v5;\n+      vbool8_t v6;\n+      *(vbool8_t*)(out + i + 5000) = v6;\n+      vbool4_t v7;\n+      *(vbool4_t*)(out + i + 6000) = v7;\n+      vbool2_t v8;\n+      *(vbool2_t*)(out + i + 7000) = v8;\n+      vbool1_t v9;\n+      *(vbool1_t*)(out + i + 8000) = v9;\n+      vuint32mf2_t v10;\n+      *(vuint32mf2_t*)(out + i + 100000) = v10;\n+    }\n+  \n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1 = *(vint8mf8_t*)(in + i + 100000);\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}"}, {"sha": "fbf451f3d4cd5e78ae1fd9a1af7da9582a2a58dd", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "ba289f24d230cc824e64a4ad054d5f5b25132a03", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-10.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond, int cond2, int cond3)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0)\n+  {\n+    if (cond2 == 11)\n+    {\n+      for (int i = 0; i < n; i++)\n+      {\n+        out[i] = out[i] + 2;\n+      }\n+    }\n+    else if (cond2 == 111)\n+    {\n+      if (cond3 == 300)\n+      {\n+        for (int i = 0; i < n; i++)\n+        {\n+          out[i] = out[i] + out[i];\n+        }\n+      }\n+    }\n+  }\n+\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "44e8a3f12f72216f064166b32b16b4e1b6148726", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-11.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond, int cond2, int cond3)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200 + i);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300 + i);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400 + i);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500 + i);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0)\n+  {\n+    if (cond2 == 11)\n+    {\n+      for (int i = 0; i < n; i++)\n+      {\n+        out[i] = out[i] + 2;\n+      }\n+    }\n+    else if (cond2 == 111)\n+    {\n+      if (cond3 == 300)\n+      {\n+        for (int i = 0; i < n; i++)\n+        {\n+          out[i] = out[i] + out[i];\n+        }\n+      } else {\n+        for (int i = 0; i < n; i++) {\n+          vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 2000 + i);\n+          *(vfloat32mf2_t*)(out + i + 4000) = v;\n+        }\n+      }\n+    }\n+  }\n+\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "a8f5af9f1fad4cd79ce8e82f133f939c0b08d149", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-12.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond, int cond2, int cond3)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200 + i);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300 + i);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400 + i);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500 + i);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0)\n+  {\n+    if (cond2 == 11)\n+    {\n+      for (int i = 0; i < n; i++)\n+      {\n+        out[i] = out[i] + 2;\n+      }\n+    }\n+    else if (cond2 == 111)\n+    {\n+      if (cond3 == 300)\n+      {\n+        for (int i = 0; i < n; i++)\n+        {\n+          out[i] = out[i] + out[i];\n+        }\n+      } else {\n+        for (int i = 0; i < n; i++) {\n+          vint8mf2_t v = *(vint8mf2_t*)(in + 2000 + i);\n+          *(vint8mf2_t*)(out + i + 4000) = v;\n+        }\n+      }\n+    }\n+  }\n+\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "31034bcfa253ff81f4db1a02b45744779f3dbf81", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-13.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-13.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond, int cond2, int cond3)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200 + i);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300 + i);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400 + i);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500 + i);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0)\n+  {\n+    if (cond2 == 11)\n+    {\n+      for (int i = 0; i < n; i++)\n+      {\n+        out[i] = out[i] + 2;\n+      }\n+    }\n+    else if (cond2 == 111)\n+    {\n+      if (cond3 == 300)\n+      {\n+        for (int i = 0; i < n; i++)\n+        {\n+          out[i] = out[i] + out[i];\n+        }\n+      } else {\n+        for (int i = 0; i < n; i++) {\n+          vint8mf2_t v = *(vint8mf2_t*)(in + 2000 + i);\n+          *(vint8mf2_t*)(out + i + 4000) = v;\n+        }\n+      }\n+    }\n+  }\n+\n+  for (int i = 0; i < n; i++) {\n+    vint16m1_t v;\n+    *(vint16m1_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "dececb45294e15cf87fe4bbd9a3c46e5a6418254", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-14.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-14.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+      *(vint8mf8_t*)(out + i + 333) = v;\n+    }\n+  } else if (cond == 1){\n+    for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 444);\n+    *(vint32mf2_t*)(out + i + 444) = v;\n+  }\n+  } else if (cond == 2) {\n+    for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 555);\n+    *(vint64m1_t*)(out + i + 555) = v;\n+  }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 666);\n+    *(vfloat64m1_t*)(out + i + 666) = v;\n+  }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "161d14c200947750f6390ba22bbdabb8c966538c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-15.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-15.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,143 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+      *(vint8mf8_t*)(out + i + 333) = v;\n+    }\n+  } else if (cond == 1){\n+    for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 444);\n+    *(vint32mf2_t*)(out + i + 444) = v;\n+  }\n+  } else if (cond == 2) {\n+    for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 555);\n+    *(vint64m1_t*)(out + i + 555) = v;\n+  }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 666);\n+    *(vfloat64m1_t*)(out + i + 666) = v;\n+  }\n+  }\n+ \n+   if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+      *(vint8mf8_t*)(out + i + 333) = v;\n+    }\n+  } else if (cond == 1){\n+    for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 444);\n+    *(vint32mf2_t*)(out + i + 444) = v;\n+  }\n+  } else if (cond == 2) {\n+    for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 555);\n+    *(vint64m1_t*)(out + i + 555) = v;\n+  }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 666);\n+    *(vfloat64m1_t*)(out + i + 666) = v;\n+  }\n+  }\n+\n+    if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+      *(vint8mf8_t*)(out + i + 333) = v;\n+    }\n+  } else if (cond == 1){\n+    for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 444);\n+    *(vint32mf2_t*)(out + i + 444) = v;\n+  }\n+  } else if (cond == 2) {\n+    for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 555);\n+    *(vint64m1_t*)(out + i + 555) = v;\n+  }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 666);\n+    *(vfloat64m1_t*)(out + i + 666) = v;\n+  }\n+  }\n+    if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+      *(vint8mf8_t*)(out + i + 333) = v;\n+    }\n+  } else if (cond == 1){\n+    for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 444);\n+    *(vint32mf2_t*)(out + i + 444) = v;\n+  }\n+  } else if (cond == 2) {\n+    for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 555);\n+    *(vint64m1_t*)(out + i + 555) = v;\n+  }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 666);\n+    *(vfloat64m1_t*)(out + i + 666) = v;\n+  }\n+  }\n+    if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+      *(vint8mf8_t*)(out + i + 333) = v;\n+    }\n+  } else if (cond == 1){\n+    for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 444);\n+    *(vint32mf2_t*)(out + i + 444) = v;\n+  }\n+  } else if (cond == 2) {\n+    for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 555);\n+    *(vint64m1_t*)(out + i + 555) = v;\n+  }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 666);\n+    *(vfloat64m1_t*)(out + i + 666) = v;\n+  }\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "84abe55a2b00a8c80c2e57d0e0a482a85a006636", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-16.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-16.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 771);\n+    *(vint8mf8_t*)(out + 771) = v;\n+    vint32mf2_t v2 = *(vint32mf2_t*)(in + 71);\n+    *(vint32mf2_t*)(out + 71) = v2;\n+    vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in + 17);\n+    *(vfloat32mf2_t*)(out + 17) = v3;\n+     vuint32mf2_t v4 = *(vuint32mf2_t*)(in + 117);\n+    *(vuint32mf2_t*)(out + 117) = v4;\n+  } else {\n+    vfloat32mf2_t v0 = *(vfloat32mf2_t*)(in + 1123);\n+    *(vfloat32mf2_t*)(out + 1123) = v0;\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+    *(vint8mf8_t*)(out + 333) = v;\n+    vbool64_t v2 = *(vbool64_t*)(in + 91);\n+    *(vbool64_t*)(out + 91) = v2;\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "1f3bae2342a08679ab27b43cbe4a3a1c86405a61", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-17.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-17.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++){\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 771 + i);\n+      *(vint8mf8_t*)(out + 771 + i) = v;\n+      vint32mf2_t v2 = *(vint32mf2_t*)(in + 71 + i);\n+      *(vint32mf2_t*)(out + 71 + i) = v2;\n+      vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in + 17 + i);\n+      *(vfloat32mf2_t*)(out + 17 + i) = v3;\n+       vuint32mf2_t v4 = *(vuint32mf2_t*)(in + 117 + i);\n+      *(vuint32mf2_t*)(out + 117 + i) = v4;\n+    }\n+  } else {\n+    for (int i = 0; i < n; i++){\n+      vfloat32mf2_t v0 = *(vfloat32mf2_t*)(in + 1123 + i);\n+      *(vfloat32mf2_t*)(out + 1123 + i) = v0;\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333 + i);\n+      *(vint8mf8_t*)(out + 333 + i) = v;\n+      vbool64_t v2 = *(vbool64_t*)(in + 91 + i);\n+      *(vbool64_t*)(out + 91 + i) = v2;\n+    }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "33885e77ae9a071b9be8dfe225fb772068acdc48", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-18.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-18.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++){\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 771 + i);\n+      *(vint8mf8_t*)(out + 771 + i) = v;\n+      vint32mf2_t v2 = *(vint32mf2_t*)(in + 71 + i);\n+      *(vint32mf2_t*)(out + 71 + i) = v2;\n+      vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in + 17 + i);\n+      *(vfloat32mf2_t*)(out + 17 + i) = v3;\n+       vuint32mf2_t v4 = *(vuint32mf2_t*)(in + 117 + i);\n+      *(vuint32mf2_t*)(out + 117 + i) = v4;\n+    }\n+  } else {\n+    vfloat32mf2_t v0 = *(vfloat32mf2_t*)(in + 1123);\n+    *(vfloat32mf2_t*)(out + 1123) = v0;\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+    *(vint8mf8_t*)(out + 333) = v;\n+    vbool64_t v2 = *(vbool64_t*)(in + 91);\n+    *(vbool64_t*)(out + 91) = v2;\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "213c48a1b55a16ae158a52151fd379e2d67b44ce", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-19.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-19.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 771);\n+    *(vint8mf8_t*)(out + 771) = v;\n+    vint32mf2_t v2 = *(vint32mf2_t*)(in + 71);\n+    *(vint32mf2_t*)(out + 71) = v2;\n+    vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in + 17);\n+    *(vfloat32mf2_t*)(out + 17) = v3;\n+     vuint32mf2_t v4 = *(vuint32mf2_t*)(in + 117);\n+    *(vuint32mf2_t*)(out + 117) = v4;\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b8c2cc05f38171c1d23cd1ca9169b458da982a4b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    out[i] = out[i] + 2;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    out[i] = out[i] + out[i];\n+  }\n+  for (int i = 0; i < n; i++) {\n+    out[i] = out[i] * 2;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    out[i] = out[i] * out[i];\n+  }\n+  for (int i = 0; i < n; i++) {\n+    out[i] = out[i] * out[i] + 100;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "1f3bae2342a08679ab27b43cbe4a3a1c86405a61", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-20.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-20.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++){\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 771 + i);\n+      *(vint8mf8_t*)(out + 771 + i) = v;\n+      vint32mf2_t v2 = *(vint32mf2_t*)(in + 71 + i);\n+      *(vint32mf2_t*)(out + 71 + i) = v2;\n+      vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in + 17 + i);\n+      *(vfloat32mf2_t*)(out + 17 + i) = v3;\n+       vuint32mf2_t v4 = *(vuint32mf2_t*)(in + 117 + i);\n+      *(vuint32mf2_t*)(out + 117 + i) = v4;\n+    }\n+  } else {\n+    for (int i = 0; i < n; i++){\n+      vfloat32mf2_t v0 = *(vfloat32mf2_t*)(in + 1123 + i);\n+      *(vfloat32mf2_t*)(out + 1123 + i) = v0;\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 333 + i);\n+      *(vint8mf8_t*)(out + 333 + i) = v;\n+      vbool64_t v2 = *(vbool64_t*)(in + 91 + i);\n+      *(vbool64_t*)(out + 91 + i) = v2;\n+    }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b60a6527262a95c093cf066ae15bc30b760860ee", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-21.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-21.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++){\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 771 + i);\n+      *(vint8mf8_t*)(out + 771 + i) = v;\n+      vint32mf2_t v2 = *(vint32mf2_t*)(in + 71 + i);\n+      *(vint32mf2_t*)(out + 71 + i) = v2;\n+      vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in + 17 + i);\n+      *(vfloat32mf2_t*)(out + 17 + i) = v3;\n+       vuint32mf2_t v4 = *(vuint32mf2_t*)(in + 117 + i);\n+      *(vuint32mf2_t*)(out + 117 + i) = v4;\n+    }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "c4a04511f344526710b4042064fab03d0b99791c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-22.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-22.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++){\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 771 + i);\n+      *(vint8mf8_t*)(out + 771 + i) = v;\n+      vint32mf2_t v2 = *(vint32mf2_t*)(in + 71 + i);\n+      *(vint32mf2_t*)(out + 71 + i) = v2;\n+      vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in + 17 + i);\n+      *(vfloat32mf2_t*)(out + 17 + i) = v3;\n+       vuint32mf2_t v4 = *(vuint32mf2_t*)(in + 117 + i);\n+      *(vuint32mf2_t*)(out + 117 + i) = v4;\n+    }\n+  } else {\n+    vfloat32mf2_t v0 = *(vfloat32mf2_t*)(in + 1123);\n+    *(vfloat32mf2_t*)(out + 1123) = v0;\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 333);\n+    *(vint8mf8_t*)(out + 333) = v;\n+    vbool64_t v2 = *(vbool64_t*)(in + 91);\n+    *(vbool64_t*)(out + 91) = v2;\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "36a18a40536407f17c47b4a1e1ac563dd1f4a28f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-23.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-23.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  vint32mf2_t v;\n+  *(vint32mf2_t*)(out + 7000) = v;\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 4 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b4d4240b8d47a30f47664c6e137a5f1c4d84b1d0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-24.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-24.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  vint32mf2_t v;\n+  *(vint32mf2_t*)(out + 7000) = v;\n+ \n+  for (int i = 0; i < n; i++) {\n+    vbool64_t v;\n+    *(vbool64_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "4295ac3a2bb4679b06672da8ad4658e14489079f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-25.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-25.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint16mf4_t v2;\n+        *(vint16mf4_t*)(out + i + 100) = v2;\n+      }\n+  } else if (cond == 1) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+    *(vint8mf8_t*)(out + 200) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint32mf2_t v2;\n+        *(vint32mf2_t*)(out + i + 200) = v2;\n+      }\n+  } else if (cond == 2) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 300);\n+    *(vint8mf8_t*)(out + 300) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint8mf8_t v2;\n+        *(vint8mf8_t*)(out + i + 300) = v2;\n+      }\n+  } else if (cond == 3) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 400);\n+    *(vint8mf8_t*)(out + 400) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint64m1_t v2;\n+        *(vint64m1_t*)(out + i + 400) = v2;\n+      }\n+  } else if (cond == 4) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vfloat32mf2_t v2;\n+        *(vfloat32mf2_t*)(out + i + 500) = v2;\n+      }\n+  } else if (cond == 5) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 600);\n+    *(vuint8mf8_t*)(out + 600) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint16mf4_t v2;\n+        *(vuint16mf4_t*)(out + i + 600) = v2;\n+      }\n+  } else if (cond == 6) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 700);\n+    *(vuint8mf8_t*)(out + 700) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint32mf2_t v2;\n+        *(vuint32mf2_t*)(out + i + 700) = v2;\n+      }\n+  } else if (cond == 7) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 800);\n+    *(vuint8mf8_t*)(out + 800) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint8mf8_t v2;\n+        *(vuint8mf8_t*)(out + i + 800) = v2;\n+      }\n+  } else if (cond == 8) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900);\n+    *(vuint8mf8_t*)(out + 900) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint64m1_t v2;\n+        *(vuint64m1_t*)(out + i + 900) = v2;\n+      }\n+  } else {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 1000);\n+    *(vuint8mf8_t*)(out + 1000) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vfloat32mf2_t v2;\n+        *(vfloat32mf2_t*)(out + i + 1000) = v2;\n+      }\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 10 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 20 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "59e069f21499e963835da3a3070b06d28968ad19", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-26.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-26.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint16mf4_t v2;\n+        *(vint16mf4_t*)(out + i + 100) = v2;\n+      }\n+  } else if (cond == 1) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+    *(vint8mf8_t*)(out + 200) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint32mf2_t v2;\n+        *(vint32mf2_t*)(out + i + 200) = v2;\n+      }\n+  } else if (cond == 2) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 300);\n+    *(vint8mf8_t*)(out + 300) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint8mf8_t v2;\n+        *(vint8mf8_t*)(out + i + 300) = v2;\n+      }\n+  } else if (cond == 3) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 400);\n+    *(vint8mf8_t*)(out + 400) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint64m1_t v2;\n+        *(vint64m1_t*)(out + i + 400) = v2;\n+      }\n+  } else if (cond == 4) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vfloat32mf2_t v2;\n+        *(vfloat32mf2_t*)(out + i + 500) = v2;\n+      }\n+  } else if (cond == 5) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 600);\n+    *(vuint8mf8_t*)(out + 600) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint16mf4_t v2;\n+        *(vuint16mf4_t*)(out + i + 600) = v2;\n+      }\n+  } else if (cond == 6) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 700);\n+    *(vuint8mf8_t*)(out + 700) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint32mf2_t v2;\n+        *(vuint32mf2_t*)(out + i + 700) = v2;\n+      }\n+  } else if (cond == 7) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 800);\n+    *(vuint8mf8_t*)(out + 800) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint8mf8_t v2;\n+        *(vuint8mf8_t*)(out + i + 800) = v2;\n+      }\n+  } else if (cond == 8) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900);\n+    *(vuint8mf8_t*)(out + 900) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vuint64m1_t v2;\n+        *(vuint64m1_t*)(out + i + 900) = v2;\n+      }\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 8 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 17 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "e148a1cc859c3a670bdb1791d865a2b9b3cf541f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-27.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-27.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  if (cond == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint16mf4_t v2;\n+        *(vint16mf4_t*)(out + i + 100) = v2;\n+      }\n+  } else {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 1000);\n+    *(vuint8mf8_t*)(out + 1000) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vfloat32mf2_t v2;\n+        *(vfloat32mf2_t*)(out + i + 1000) = v2;\n+        vbool64_t v3;\n+        *(vbool64_t*)(out + i + 2000) = v3;\n+        vbool32_t v4;\n+        *(vbool32_t*)(out + i + 3000) = v4;\n+        vbool16_t v5;\n+        *(vbool16_t*)(out + i + 4000) = v5;\n+        vbool8_t v6;\n+        *(vbool8_t*)(out + i + 5000) = v6;\n+        vbool4_t v7;\n+        *(vbool4_t*)(out + i + 6000) = v7;\n+        vbool2_t v8;\n+        *(vbool2_t*)(out + i + 7000) = v8;\n+        vbool1_t v9;\n+        *(vbool1_t*)(out + i + 8000) = v9;\n+      }\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 9 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "e8340a63ee27605fc2fa9c020343c5f4a487b90d", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-28.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-28.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  if (cond == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint16mf4_t v2;\n+        *(vint16mf4_t*)(out + i + 100) = v2;\n+      }\n+  } else {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 1000);\n+    *(vuint8mf8_t*)(out + 1000) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vfloat32mf2_t v2;\n+        *(vfloat32mf2_t*)(out + i + 1000) = v2;\n+        vbool64_t v3;\n+        *(vbool64_t*)(out + i + 2000) = v3;\n+        vbool32_t v4;\n+        *(vbool32_t*)(out + i + 3000) = v4;\n+        vbool16_t v5;\n+        *(vbool16_t*)(out + i + 4000) = v5;\n+        vbool8_t v6;\n+        *(vbool8_t*)(out + i + 5000) = v6;\n+        vbool4_t v7;\n+        *(vbool4_t*)(out + i + 6000) = v7;\n+        vbool2_t v8;\n+        *(vbool2_t*)(out + i + 7000) = v8;\n+        vbool1_t v9;\n+        *(vbool1_t*)(out + i + 8000) = v9;\n+        vuint32mf2_t v10;\n+        *(vuint32mf2_t*)(out + i + 100000) = v10;\n+      }\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 10 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "74584e7708b2c4d969e8004a706b55ec0ad2353a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-29.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-29.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  if (cond == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vint16mf4_t v2;\n+        *(vint16mf4_t*)(out + i + 100) = v2;\n+      }\n+  } else {\n+    vuint8mf8_t v;\n+    *(vuint8mf8_t*)(out + 1000) = v;\n+    for (int i = 0; i < n; i++)\n+      {\n+        vfloat32mf2_t v2;\n+        *(vfloat32mf2_t*)(out + i + 1000) = v2;\n+        vbool64_t v3;\n+        *(vbool64_t*)(out + i + 2000) = v3;\n+        vbool32_t v4;\n+        *(vbool32_t*)(out + i + 3000) = v4;\n+        vbool16_t v5;\n+        *(vbool16_t*)(out + i + 4000) = v5;\n+        vbool8_t v6;\n+        *(vbool8_t*)(out + i + 5000) = v6;\n+        vbool4_t v7;\n+        *(vbool4_t*)(out + i + 6000) = v7;\n+        vbool2_t v8;\n+        *(vbool2_t*)(out + i + 7000) = v8;\n+        vbool1_t v9;\n+        *(vbool1_t*)(out + i + 8000) = v9;\n+        vuint32mf2_t v10;\n+        *(vuint32mf2_t*)(out + i + 100000) = v10;\n+      }\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 11 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "63f6c72c60ebbc9eb661bf8e2c789bfbeb70d194", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 2;\n+    }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 3;\n+    }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "92bf3abaec7642ac808560681fe7321712555729", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-30.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-30.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      vfloat32mf2_t v2 = *(vfloat32mf2_t*)(in + i + 1000);\n+      *(vfloat32mf2_t*)(out + i + 1000) = v2;\n+      vbool32_t v4;\n+      *(vbool32_t*)(out + i + 3000) = v4;\n+      vbool16_t v5;\n+      *(vbool16_t*)(out + i + 4000) = v5;\n+      vbool8_t v6;\n+      *(vbool8_t*)(out + i + 5000) = v6;\n+      vbool4_t v7;\n+      *(vbool4_t*)(out + i + 6000) = v7;\n+      vbool2_t v8;\n+      *(vbool2_t*)(out + i + 7000) = v8;\n+      vbool1_t v9;\n+      *(vbool1_t*)(out + i + 8000) = v9;\n+      vuint32mf2_t v10 = *(vuint32mf2_t*)(in + i + 100000);\n+      *(vuint32mf2_t*)(out + i + 100000) = v10;\n+    }\n+  \n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1;\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 9 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "4d254570e4d0a0131615cf6f15d0f8bb9c078a86", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-31.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-31.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v2 = *(vuint16mf4_t*)(in + i + 1000);\n+      *(vuint16mf4_t*)(out + i + 1000) = v2;\n+      vbool32_t v4;\n+      *(vbool32_t*)(out + i + 3000) = v4;\n+      vbool16_t v5;\n+      *(vbool16_t*)(out + i + 4000) = v5;\n+      vbool8_t v6;\n+      *(vbool8_t*)(out + i + 5000) = v6;\n+      vbool4_t v7;\n+      *(vbool4_t*)(out + i + 6000) = v7;\n+      vbool2_t v8;\n+      *(vbool2_t*)(out + i + 7000) = v8;\n+      vbool1_t v9;\n+      *(vbool1_t*)(out + i + 8000) = v9;\n+      vuint32mf2_t v10 = *(vuint32mf2_t*)(in + i + 100000);\n+      *(vuint32mf2_t*)(out + i + 100000) = v10;\n+    }\n+  \n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1;\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 9 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "284df7245e73ce5b97592edfaedc4e4ff81b5183", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-32.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-32.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v2 = *(vuint16mf4_t*)(in + i + 1000);\n+      *(vuint16mf4_t*)(out + i + 1000) = v2;\n+      vbool32_t v4;\n+      *(vbool32_t*)(out + i + 3000) = v4;\n+      vbool16_t v5;\n+      *(vbool16_t*)(out + i + 4000) = v5;\n+      vbool8_t v6;\n+      *(vbool8_t*)(out + i + 5000) = v6;\n+      vbool4_t v7;\n+      *(vbool4_t*)(out + i + 6000) = v7;\n+      vbool2_t v8;\n+      *(vbool2_t*)(out + i + 7000) = v8;\n+      vbool1_t v9;\n+      *(vbool1_t*)(out + i + 8000) = v9;\n+      vuint32mf2_t v10;\n+      *(vuint32mf2_t*)(out + i + 100000) = v10;\n+    }\n+  \n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1 = *(vint8mf8_t*)(in + i + 100000);\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]:+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 8 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "1057b1bc00b4ea5f757175496928582c3696d4f4", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-33.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-33.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out, void * restrict in2, void * restrict out2,  int n, int cond)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v2;\n+      *(vuint16mf4_t*)(out + i + 1000) = v2;\n+      vbool32_t v4;\n+      *(vbool32_t*)(out + i + 3000) = v4;\n+      vbool16_t v5;\n+      *(vbool16_t*)(out + i + 4000) = v5;\n+      vbool8_t v6;\n+      *(vbool8_t*)(out + i + 5000) = v6;\n+      vbool4_t v7;\n+      *(vbool4_t*)(out + i + 6000) = v7;\n+      vbool2_t v8;\n+      *(vbool2_t*)(out + i + 7000) = v8;\n+      vbool1_t v9;\n+      *(vbool1_t*)(out + i + 8000) = v9;\n+      vuint32mf2_t v10;\n+      *(vuint32mf2_t*)(out + i + 100000) = v10;\n+    }\n+  \n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1 = *(vint8mf8_t*)(in + i + 100000);\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 8 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "9746ebed18c76391fa32dcae53ff7c9868bc97b4", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-34.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-34.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int32_t * restrict in2, int32_t * restrict out2,  int n, int cond)\n+{\n+  if (cond == 0)\n+    {\n+      for (int i = 0; i < n; i++)\n+        {\n+          out2[i] = out[i] + in[i];\n+        }\n+    }\n+  else if (cond == 1)\n+   {\n+      for (int i = 0; i < n; i++)\n+          {\n+            out2[i] = out[i] + in[i];\n+          }\n+      for (int i = 0; i < n; i++)\n+          {\n+            out[i] = out2[i] / in[i];\n+          }\n+      for (int i = 0; i < n; i++)\n+        {\n+          out2[i] = out[i] * in[i];\n+        }\n+   }\n+  else\n+   {\n+     for (int i = 0; i < n; i++)\n+      {\n+        out[i] = in[i] + 4;\n+      }\n+   }\n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1;\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "0547d62283852ee6f9abdcdbc3c689260078fadb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-35.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-35.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int32_t * restrict in2, int32_t * restrict out2,  int n, int cond)\n+{\n+  if (cond == 0)\n+    {\n+      for (int i = 0; i < n; i++)\n+        {\n+          out2[i] = out[i] + in[i];\n+        }\n+    }\n+  else if (cond == 1)\n+   {\n+      for (int i = 0; i < n; i++)\n+          {\n+            out2[i] = out[i] + in[i];\n+          }\n+      for (int i = 0; i < n; i++)\n+          {\n+            out[i] = out2[i] / in[i];\n+          }\n+      for (int i = 0; i < n; i++)\n+        {\n+          out2[i] = out[i] * in[i];\n+        }\n+   }\n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1;\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "a82b86f4d8896e517d4c66f2851cda2aa4ed60a2", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-36.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-36.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int32_t * restrict in2, int32_t * restrict out2,  int n, int cond)\n+{\n+  if (cond == 0)\n+    {\n+      for (int i = 0; i < n; i++)\n+        {\n+          out2[i] = out[i] + in[i];\n+        }\n+    }\n+  else if (cond == 1)\n+   {\n+      for (int i = 0; i < n; i++)\n+          {\n+            out2[i] = out[i] + in[i];\n+          }\n+      for (int i = 0; i < n; i++)\n+          {\n+            out[i] = out2[i] / in[i];\n+          }\n+      for (int i = 0; i < n; i++)\n+        {\n+          out2[i] = out[i] * in[i];\n+        }\n+   }\n+  else\n+   {\n+     for (int i = 0; i < n; i++) \n+      {\n+        vint32mf2_t v1 = *(vint32mf2_t*)in2;\n+        *(vint32mf2_t*)(out + i + 10) = v1;\n+      }\n+   }\n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1;\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+:} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "981e90ed6af4e54111e1d37168d5195ac9921afe", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-37.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-37.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void fn3 (void);\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int32_t * restrict in2, int32_t * restrict out2,  int n, int cond)\n+{\n+  if (cond == 0)\n+    {\n+      for (int i = 0; i < n; i++) \n+      {\n+        vfloat32mf2_t v1 = *(vfloat32mf2_t*)(in + 1000);\n+        *(vfloat32mf2_t*)(out + i + 1000) = v1;\n+      }\n+      for (int i = 0; i < n; i++) \n+      {\n+        vint32mf2_t v1 = *(vint32mf2_t*)in;\n+        *(vint32mf2_t*)(out + i + 10) = v1;\n+      }\n+    for (int i = 0; i < n; i++) \n+      {\n+        vint16mf4_t v1 = *(vint16mf4_t*)(in + 100);\n+        *(vint16mf4_t*)(out + i + 100) = v1;\n+      }\n+    }\n+  else\n+   {\n+     fn3 ();\n+   }\n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1;\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "79dbeefb5851f4f2234144177bd6ffa4544947d0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-38.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-38.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int32_t * restrict in2, int32_t * restrict out2,  int n, int cond, int cond2)\n+{\n+  if (cond == 0)\n+    {\n+      if (cond2) {\n+      for (int i = 0; i < n; i++) \n+      {\n+        vfloat32mf2_t v1 = *(vfloat32mf2_t*)(in + 1000);\n+        *(vfloat32mf2_t*)(out + i + 1000) = v1;\n+      }\n+      for (int i = 0; i < n; i++) \n+      {\n+        vint32mf2_t v1 = *(vint32mf2_t*)in;\n+        *(vint32mf2_t*)(out + i + 10) = v1;\n+      }\n+    for (int i = 0; i < n; i++) \n+      {\n+        vint16mf4_t v1 = *(vint16mf4_t*)(in + 100);\n+        *(vint16mf4_t*)(out + i + 100) = v1;\n+      }\n+      } else {\n+        for (int i = 0; i < n; i++) \n+      {\n+        vfloat32mf2_t v1 = *(vfloat32mf2_t*)(in + 2000);\n+        *(vfloat32mf2_t*)(out + i + 2000) = v1;\n+      }\n+      for (int i = 0; i < n; i++) \n+      {\n+        vint32mf2_t v1 = *(vint32mf2_t*)(in + 200);\n+        *(vint32mf2_t*)(out + i + 200) = v1;\n+      }\n+    for (int i = 0; i < n; i++) \n+      {\n+        vint16mf4_t v1 = *(vint16mf4_t*)(in + 300);\n+        *(vint16mf4_t*)(out + i + 300) = v1;\n+      }\n+      }\n+    }\n+  else\n+   {\n+     for (int i = 0; i < n; i++) \n+      {\n+        vint16mf4_t v1 = *(vint16mf4_t*)(in + 30000);\n+        *(vint16mf4_t*)(out + i + 30000) = v1;\n+      }\n+    for (int i = 0; i < n; i++) \n+      {\n+        vint32mf2_t v1 = *(vint32mf2_t*)(in + 40000);\n+        *(vint32mf2_t*)(out + i + 40000) = v1;\n+      }\n+    for (int i = 0; i < n; i++) \n+      {\n+        vuint32mf2_t v1 = *(vuint32mf2_t*)(in + 50000);\n+        *(vuint32mf2_t*)(out + i + 50000) = v1;\n+      }\n+   }\n+  for (int i = 0; i < n; i++) \n+    {\n+      vint8mf8_t v1;\n+      *(vint8mf8_t*)(out + i + 10) = v1;\n+    }\n+}\n+\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 4 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "c3eb6f9f6a79aeb6442e0bca693509296eca471a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-39.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-39.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_3 (int32_t * restrict in, int32_t * restrict out, size_t n, int cond)\n+{\n+  vint8mf2_t v;\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 2 == 0) {\n+        v = *(vint8mf2_t*)(in + i);\n+      } else {\n+        *(vint8mf2_t*)(out + i) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+j\\s+\\.L[0-9]+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "0ba60047699e417f713c10617b3a71bb9304bdcf", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-4.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 2;\n+    }\n+  } else if (cond == 1){\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 3;\n+    }\n+  } else if (cond == 2) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 5;\n+    }\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 6;\n+    }\n+  } else if (cond == 4) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 8;\n+    }\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 9;\n+    }\n+  } else if (cond == 5) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 10;\n+    }\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 11;\n+    }\n+  } else if (cond == 6) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 12;\n+    }\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 13;\n+    }\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] * out[i];\n+    }\n+  } else if (cond == 7) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 15;\n+    }\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 16;\n+    }\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + out[i];\n+    }\n+  } else if (cond == 8) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 101;\n+    }\n+  } else if (cond == 9) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] * 101;\n+    }\n+  } else if (cond == 10) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] >> 3;\n+    }\n+  } else {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] << 1;\n+    }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "67f1a3387ceb0732b3a7f508674ae459551db0bf", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-40.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-40.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_4 (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  vint8mf2_t v;\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      for (size_t j = 0; j < m; j += 1) {\n+        if (j % 2 == 0) {\n+          v = *(vint8mf2_t*)(in + i + j);\n+        } else {\n+          *(vint8mf2_t*)(out + i + j) = v;\n+        }\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b2f4feed76ee7f0b73cec20abd0562af1a9ae22b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-41.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-41.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_5 (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  vint8mf2_t v;\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 2) {\n+        for (size_t j = 0; j < m; j += 1) {\n+          if (j % 2 == 0) {\n+            v = *(vint8mf2_t*)(in + i + j);\n+          } else {\n+            *(vint8mf2_t*)(out + i + j) = v;\n+          }\n+        }\n+      } else {\n+        *(vint8mf2_t*)(out + i) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "4eb57de0de8abff161986fa5f975afd533d21524", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-42.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-42.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_6 (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  vint8mf2_t v;\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 2) {\n+        for (size_t j = 0; j < m; j += 1) {\n+          if (j % 2 == 0) {\n+            v = *(vint8mf2_t*)(in + i + j);\n+          } else {\n+            *(vint8mf2_t*)(out + i + j) = v;\n+          }\n+        }\n+      } else {\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "047369e7734fea8e05d0fdd284d403f0569367bb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-43.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-43.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_3 (int32_t * restrict in, int32_t * restrict out, size_t n, int cond)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 16 == 0) {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      } else if (i % 8 == 0) {\n+        vint16mf4_t v = *(vint16mf4_t*)(in + i + 200);\n+        *(vint16mf4_t*)(out + i + 200) = v;\n+      } else if (i % 4 == 0) {\n+        vint32mf2_t v = *(vint32mf2_t*)(in + i + 300);\n+        *(vint32mf2_t*)(out + i + 300) = v;\n+      } else {\n+        vbool64_t v = *(vbool64_t*)(in + i + 400);\n+        *(vbool64_t*)(out + i + 400) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "05e9810609ec8872cf6f5d1779e3aa7d125c8e92", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-44.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-44.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_4 (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      for (size_t j = 0; j < m; j += 1) {\n+        if (i % 16 == 0) {\n+          vint8mf8_t v = *(vint8mf8_t*)(in + i + 100 + j);\n+          *(vint8mf8_t*)(out + i + 100 + j) = v;\n+        } else if (i % 8 == 0) {\n+          vint16mf4_t v = *(vint16mf4_t*)(in + i + 200 + j);\n+          *(vint16mf4_t*)(out + i + 200 + j) = v;\n+        } else if (i % 4 == 0) {\n+          vint32mf2_t v = *(vint32mf2_t*)(in + i + 300 + j);\n+          *(vint32mf2_t*)(out + i + 300 + j) = v;\n+        } else {\n+          vbool64_t v = *(vbool64_t*)(in + i + 400 + j);\n+          *(vbool64_t*)(out + i + 400 + j) = v;\n+        }\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "0f6b96e6db6bede901fd858b81652281d30c30a8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-45.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-45.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_5 (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 2) {\n+        for (size_t j = 0; j < m; j += 1) {\n+          if (i % 16 == 0) {\n+          vint8mf8_t v = *(vint8mf8_t*)(in + i + 100 + j);\n+          *(vint8mf8_t*)(out + i + 100 + j) = v;\n+        } else if (i % 8 == 0) {\n+          vint16mf4_t v = *(vint16mf4_t*)(in + i + 200 + j);\n+          *(vint16mf4_t*)(out + i + 200 + j) = v;\n+        } else if (i % 4 == 0) {\n+          vint32mf2_t v = *(vint32mf2_t*)(in + i + 300 + j);\n+          *(vint32mf2_t*)(out + i + 300 + j) = v;\n+        } else {\n+          vbool64_t v = *(vbool64_t*)(in + i + 400 + j);\n+          *(vbool64_t*)(out + i + 400 + j) = v;\n+        }\n+        }\n+      } else {\n+        vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 88888);\n+        *(vfloat32mf2_t*)(out + 88888) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+j\\s+\\.L[0-9]+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "a211beda0e62d909a847d3d2f6344dada9fae498", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-46.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-46.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo5_6 (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 2) {\n+        for (size_t j = 0; j < m; j += 1) {\n+          if (i % 16 == 0) {\n+          vint8mf8_t v = *(vint8mf8_t*)(in + i + 100 + j);\n+          *(vint8mf8_t*)(out + i + 100 + j) = v;\n+        } else if (i % 8 == 0) {\n+          vint16mf4_t v = *(vint16mf4_t*)(in + i + 200 + j);\n+          *(vint16mf4_t*)(out + i + 200 + j) = v;\n+        } else if (i % 4 == 0) {\n+          vint32mf2_t v = *(vint32mf2_t*)(in + i + 300 + j);\n+          *(vint32mf2_t*)(out + i + 300 + j) = v;\n+        } else {\n+          vbool64_t v = *(vbool64_t*)(in + i + 400 + j);\n+          *(vbool64_t*)(out + i + 400 + j) = v;\n+        }\n+        }\n+      } else {\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b38e362b880595151fdb7dc037f5e17306cfb8d8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-5.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+  \n+  switch (cond)\n+  {\n+  case 0:\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 2;\n+    }\n+    break;\n+  \n+  default:\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 3;\n+    }\n+    break;\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}"}, {"sha": "2edc1810ab2e20b350e694028ecd828d5f76ece8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-6.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  switch (cond)\n+  {\n+  case 0:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 2;\n+      }\n+  }\n+  break;\n+  case 1:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 3;\n+      }\n+  }\n+  break;\n+  case 2:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 5;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 6;\n+      }\n+  }\n+  break;\n+  case 4:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 8;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 9;\n+      }\n+  }\n+  break;\n+  case 5:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 10;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 11;\n+      }\n+  }\n+  break;\n+  case 6:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 12;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 13;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] * out[i];\n+      }\n+  }\n+  break;\n+  case 7:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 15;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 16;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + out[i];\n+      }\n+  }\n+  break;\n+  case 8:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 101;\n+      }\n+  }\n+  break;\n+  case 9:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] * 101;\n+      }\n+  }\n+  break;\n+  case 10:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] >> 3;\n+      }\n+  }\n+  break;\n+  default:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] << 1;\n+      }\n+  }\n+  break;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "68d595fbbaab0c7172c13cccf873ab01d7f579e7", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-7.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 2;\n+    }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "f49eebdf20b8e230c3dbfedb9dee4491ae85aef0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-8.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  switch (cond)\n+  {\n+  case 0:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 2;\n+      }\n+  }\n+  break;\n+  case 1:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 3;\n+      }\n+  }\n+  break;\n+  case 2:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 5;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 6;\n+      }\n+  }\n+  break;\n+  case 4:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 8;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 9;\n+      }\n+  }\n+  break;\n+  case 5:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 10;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 11;\n+      }\n+  }\n+  break;\n+  case 6:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 12;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 13;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] * out[i];\n+      }\n+  }\n+  break;\n+  case 7:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 15;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 16;\n+      }\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + out[i];\n+      }\n+  }\n+  break;\n+  case 8:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] + 101;\n+      }\n+  }\n+  break;\n+  case 9:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] * 101;\n+      }\n+  }\n+  break;\n+  case 10:\n+  {\n+      for (int i = 0; i < n; i++)\n+      {\n+          out[i] = out[i] >> 3;\n+      }\n+  }\n+  break;\n+  default:\n+  break;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "8483cdc3e962dd83500e14a79a194a4b5362334b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_back_prop-9.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_back_prop-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, int n, int cond)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)in;\n+    *(vint8mf8_t*)(out + i + 200) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vint64m1_t v = *(vint64m1_t*)(in + 300);\n+    *(vint64m1_t*)(out + i + 400) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + i + 500) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat64m1_t v = *(vfloat64m1_t*)(in + 500);\n+    *(vfloat64m1_t*)(out + i + 600) = v;\n+  }\n+\n+  if (cond == 0) {\n+    for (int i = 0; i < n; i++) {\n+      out[i] = out[i] + 2;\n+    }\n+  }\n+ \n+  for (int i = 0; i < n; i++) {\n+    vint16mf4_t v;\n+    *(vint16mf4_t*)(out + i + 700) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "4e4e16ccd2aa75fe63fba84b057bc88a92e91f51", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-1.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,182 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 600);\n+    *(vint8mf8_t*)(out + 600) = v;\n+  } else {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 700);\n+    *(vint8mf8_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 600);\n+    *(vint8mf4_t*)(out + 600) = v;\n+  } else {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 700);\n+    *(vint8mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 600);\n+    *(vint8mf2_t*)(out + 600) = v;\n+  } else {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 700);\n+    *(vint8mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 600);\n+    *(vint16mf4_t*)(out + 600) = v;\n+  } else {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 700);\n+    *(vint16mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 600);\n+    *(vint16mf2_t*)(out + 600) = v;\n+  } else {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 700);\n+    *(vint16mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 600);\n+    *(vint32mf2_t*)(out + 600) = v;\n+  } else {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 700);\n+    *(vint32mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */"}, {"sha": "f78c3487979adc13fa61145268a3ff12af21f121", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-10.c", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,230 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 700);\n+    *(vint8mf8_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 700);\n+    *(vint8mf4_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 700);\n+    *(vint8mf2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 700);\n+    *(vint16mf4_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 700);\n+    *(vint16mf2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 700);\n+    *(vuint32mf2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */"}, {"sha": "1dfa2e9ed7686860519c7e067f73a4d72e85af21", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-11.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 700);\n+    *(vfloat32mf2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "fed1aa3afecd16c89adc9ad95ed0a6735e08ff19", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-12.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,266 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vbool64_t v = *(vbool64_t*)(in + 700);\n+    *(vbool64_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vbool32_t v = *(vbool32_t*)(in + 700);\n+    *(vbool32_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vbool16_t v = *(vbool16_t*)(in + 700);\n+    *(vbool16_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vbool8_t v = *(vbool8_t*)(in + 700);\n+    *(vbool8_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vbool4_t v = *(vbool4_t*)(in + 700);\n+    *(vbool4_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vbool2_t v = *(vbool2_t*)(in + 700);\n+    *(vbool2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f7 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vbool1_t v = *(vbool1_t*)(in + 700);\n+    *(vbool1_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" no-opts \"-O1\" } } } } */"}, {"sha": "bcf8e1c59bb15bd84e3b421248097a2efe01c6d0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-13.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-13.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,221 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "c2a8c3bd3b02560719377532c203cbdc1b1ef2c0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-14.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-14.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,221 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 500);\n+    *(vuint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 500);\n+    *(vuint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 500);\n+    *(vuint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 500);\n+    *(vuint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 500);\n+    *(vuint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 500);\n+    *(vuint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 500);\n+    *(vuint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 500);\n+    *(vuint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 500);\n+    *(vuint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 500);\n+    *(vuint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "e449078c79e0dfe7c62b728150265d0ef910b89e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-15.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-15.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "224fc2e5f86e89a11052bf962d6632968672b4aa", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-16.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-16.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,257 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f7 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */"}, {"sha": "7cbabab16d9ba8c4a2ccdd7d91384e5e7c3d43f4", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-17.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-17.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,177 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+      *(vint8mf8_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+      *(vint8mf8_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+      *(vint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 100);\n+      *(vint8mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 200);\n+      *(vint8mf4_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + i);\n+      *(vint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 100);\n+      *(vint8mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 200);\n+      *(vint8mf2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+      *(vint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 100);\n+      *(vint16mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 200);\n+      *(vint16mf4_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + i);\n+      *(vint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 100);\n+      *(vint16mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 200);\n+      *(vint16mf2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + i);\n+      *(vint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 100);\n+      *(vint32mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+      *(vint32mf2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + i);\n+      *(vint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "cfaba79eed2143fe5679a61840df5c20d201e5c0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-18.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-18.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,177 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 100);\n+      *(vuint8mf8_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 200);\n+      *(vuint8mf8_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + i);\n+      *(vuint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 100);\n+      *(vuint8mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 200);\n+      *(vuint8mf4_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + i);\n+      *(vuint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 100);\n+      *(vuint8mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 200);\n+      *(vuint8mf2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + i);\n+      *(vuint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 100);\n+      *(vuint16mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 200);\n+      *(vuint16mf4_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + i);\n+      *(vuint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 100);\n+      *(vuint16mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 200);\n+      *(vuint16mf2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + i);\n+      *(vuint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 100);\n+      *(vuint32mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 200);\n+      *(vuint32mf2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + i);\n+      *(vuint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "4ea46c790f9da177b9d9f5df10a11f2014018f3b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-19.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-19.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f6 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 100);\n+      *(vfloat32mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 200);\n+      *(vfloat32mf2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i);\n+      *(vfloat32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "4e478a825dfc18e3f5736cbcfcfa48d5f3de340c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-2.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,182 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 500);\n+    *(vuint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 600);\n+    *(vuint8mf8_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 700);\n+    *(vuint8mf8_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 500);\n+    *(vuint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 600);\n+    *(vuint8mf4_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 700);\n+    *(vuint8mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 500);\n+    *(vuint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 600);\n+    *(vuint8mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 700);\n+    *(vuint8mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 500);\n+    *(vuint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 600);\n+    *(vuint16mf4_t*)(out + 600) = v;\n+  } else {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 700);\n+    *(vuint16mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 500);\n+    *(vuint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 600);\n+    *(vuint16mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 700);\n+    *(vuint16mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 600);\n+    *(vuint32mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 700);\n+    *(vuint32mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" no-opts \"-O1\" } } } } */"}, {"sha": "9562d8fb889b1c7d1f36538e0ccfef9fdff843ca", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-20.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-20.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,203 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 100);\n+      *(vbool64_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 200);\n+      *(vbool64_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + i);\n+      *(vbool64_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 100);\n+      *(vbool32_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 200);\n+      *(vbool32_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + i);\n+      *(vbool32_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 100);\n+      *(vbool16_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 200);\n+      *(vbool16_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + i);\n+      *(vbool16_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 100);\n+      *(vbool8_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 200);\n+      *(vbool8_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + i);\n+      *(vbool8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 100);\n+      *(vbool4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 200);\n+      *(vbool4_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + i);\n+      *(vbool4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 100);\n+      *(vbool2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 200);\n+      *(vbool2_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + i);\n+      *(vbool2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f7 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 100);\n+      *(vbool1_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 200);\n+      *(vbool1_t*)(out + 200) = v;\n+      if (cond == 2)\n+        {\n+          out[1000] = 8000;\n+        }\n+      else\n+        {\n+          out[2000] = 9000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + i);\n+      *(vbool1_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 6 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "198b72fd8ca1870b4ec2add4a44e7622fcb2cb06", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-21.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-21.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+      *(vint8mf8_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+          *(vint8mf8_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+      *(vint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 100);\n+      *(vint8mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vint8mf4_t v = *(vint8mf4_t*)(in + 200);\n+          *(vint8mf4_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + i);\n+      *(vint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 100);\n+      *(vint8mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vint8mf2_t v = *(vint8mf2_t*)(in + 200);\n+          *(vint8mf2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+      *(vint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 100);\n+      *(vint16mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vint16mf4_t v = *(vint16mf4_t*)(in + 200);\n+          *(vint16mf4_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + i);\n+      *(vint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 100);\n+      *(vint16mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vint16mf2_t v = *(vint16mf2_t*)(in + 200);\n+          *(vint16mf2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + i);\n+      *(vint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 100);\n+      *(vint32mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+          *(vint32mf2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + i);\n+      *(vint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "ca20f2f6aa812a7ceadd0a56466f49a6887e9987", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-22.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-22.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 100);\n+      *(vuint8mf8_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vuint8mf8_t v = *(vuint8mf8_t*)(in + 200);\n+          *(vuint8mf8_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + i);\n+      *(vuint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 100);\n+      *(vuint8mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vuint8mf4_t v = *(vuint8mf4_t*)(in + 200);\n+          *(vuint8mf4_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + i);\n+      *(vuint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 100);\n+      *(vuint8mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vuint8mf2_t v = *(vuint8mf2_t*)(in + 200);\n+          *(vuint8mf2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + i);\n+      *(vuint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 100);\n+      *(vuint16mf4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vuint16mf4_t v = *(vuint16mf4_t*)(in + 200);\n+          *(vuint16mf4_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + i);\n+      *(vuint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 100);\n+      *(vuint16mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vuint16mf2_t v = *(vuint16mf2_t*)(in + 200);\n+          *(vuint16mf2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + i);\n+      *(vuint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 100);\n+      *(vuint32mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vuint32mf2_t v = *(vuint32mf2_t*)(in + 200);\n+          *(vuint32mf2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + i);\n+      *(vuint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "ecd8a202440fd4a82d8de26fcac4ae187f43ea18", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-23.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-23.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 100);\n+      *(vuint32mf2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vuint32mf2_t v = *(vuint32mf2_t*)(in + 200);\n+          *(vuint32mf2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + i);\n+      *(vuint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "a9ed21167a8832c3a7e5f258fb0efe3cc707b7b2", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-24.c", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-24.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,180 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 100);\n+      *(vbool64_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vbool64_t v = *(vbool64_t*)(in + 200);\n+          *(vbool64_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + i);\n+      *(vbool64_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 100);\n+      *(vbool32_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vbool32_t v = *(vbool32_t*)(in + 200);\n+          *(vbool32_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + i);\n+      *(vbool32_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 100);\n+      *(vbool16_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vbool16_t v = *(vbool16_t*)(in + 200);\n+          *(vbool16_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + i);\n+      *(vbool16_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 100);\n+      *(vbool8_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vbool8_t v = *(vbool8_t*)(in + 200);\n+          *(vbool8_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + i);\n+      *(vbool8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 100);\n+      *(vbool4_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vbool4_t v = *(vbool4_t*)(in + 200);\n+          *(vbool4_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + i);\n+      *(vbool4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 100);\n+      *(vbool2_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vbool2_t v = *(vbool2_t*)(in + 200);\n+          *(vbool2_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + i);\n+      *(vbool2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f7 (int * restrict in, int * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 100);\n+      *(vbool1_t*)(out + 100) = v;\n+    }\n+  else\n+    {\n+      if (cond == 2)\n+        {\n+          vbool1_t v = *(vbool1_t*)(in + 200);\n+          *(vbool1_t*)(out + 200) = v;\n+          out[1000] = 8000;\n+        }\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + i);\n+      *(vbool1_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "f87a8ccfad5117b929b4bf7ff44202335e7a672a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-25.c", "status": "added", "additions": 572, "deletions": 0, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-25.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,572 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool64_t v = *(vbool64_t*)(in + 600);\n+    *(vbool64_t*)(out + 600) = v;\n+  } else {\n+    vbool64_t v = *(vbool64_t*)(in + 700);\n+    *(vbool64_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool64_t v = *(vbool64_t*)(in + 600);\n+    *(vbool64_t*)(out + 600) = v;\n+  } else {\n+    vbool64_t v = *(vbool64_t*)(in + 700);\n+    *(vbool64_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool32_t v = *(vbool32_t*)(in + 600);\n+    *(vbool32_t*)(out + 600) = v;\n+  } else {\n+    vbool32_t v = *(vbool32_t*)(in + 700);\n+    *(vbool32_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool32_t v = *(vbool32_t*)(in + 600);\n+    *(vbool32_t*)(out + 600) = v;\n+  } else {\n+    vbool32_t v = *(vbool32_t*)(in + 700);\n+    *(vbool32_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool16_t v = *(vbool16_t*)(in + 600);\n+    *(vbool16_t*)(out + 600) = v;\n+  } else {\n+    vbool16_t v = *(vbool16_t*)(in + 700);\n+    *(vbool16_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool16_t v = *(vbool16_t*)(in + 600);\n+    *(vbool16_t*)(out + 600) = v;\n+  } else {\n+    vbool16_t v = *(vbool16_t*)(in + 700);\n+    *(vbool16_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool8_t v = *(vbool8_t*)(in + 600);\n+    *(vbool8_t*)(out + 600) = v;\n+  } else {\n+    vbool8_t v = *(vbool8_t*)(in + 700);\n+    *(vbool8_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool8_t v = *(vbool8_t*)(in + 600);\n+    *(vbool8_t*)(out + 600) = v;\n+  } else {\n+    vbool8_t v = *(vbool8_t*)(in + 700);\n+    *(vbool8_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool4_t v = *(vbool4_t*)(in + 600);\n+    *(vbool4_t*)(out + 600) = v;\n+  } else {\n+    vbool4_t v = *(vbool4_t*)(in + 700);\n+    *(vbool4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool4_t v = *(vbool4_t*)(in + 600);\n+    *(vbool4_t*)(out + 600) = v;\n+  } else {\n+    vbool4_t v = *(vbool4_t*)(in + 700);\n+    *(vbool4_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool2_t v = *(vbool2_t*)(in + 600);\n+    *(vbool2_t*)(out + 600) = v;\n+  } else {\n+    vbool2_t v = *(vbool2_t*)(in + 700);\n+    *(vbool2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool2_t v = *(vbool2_t*)(in + 600);\n+    *(vbool2_t*)(out + 600) = v;\n+  } else {\n+    vbool2_t v = *(vbool2_t*)(in + 700);\n+    *(vbool2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f7 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool1_t v = *(vbool1_t*)(in + 600);\n+    *(vbool1_t*)(out + 600) = v;\n+  } else {\n+    vbool1_t v = *(vbool1_t*)(in + 700);\n+    *(vbool1_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool1_t v = *(vbool1_t*)(in + 600);\n+    *(vbool1_t*)(out + 600) = v;\n+  } else {\n+    vbool1_t v = *(vbool1_t*)(in + 700);\n+    *(vbool1_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "c12385576cb37f48c31fab470753521c343a546e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-26.c", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-26.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,492 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 600);\n+    *(vint8mf8_t*)(out + 600) = v;\n+  } else {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 700);\n+    *(vint8mf8_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 600);\n+    *(vint8mf8_t*)(out + 600) = v;\n+  } else {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 700);\n+    *(vint8mf8_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 600);\n+    *(vint8mf4_t*)(out + 600) = v;\n+  } else {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 700);\n+    *(vint8mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 600);\n+    *(vint8mf4_t*)(out + 600) = v;\n+  } else {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 700);\n+    *(vint8mf4_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 600);\n+    *(vint8mf2_t*)(out + 600) = v;\n+  } else {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 700);\n+    *(vint8mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 600);\n+    *(vint8mf2_t*)(out + 600) = v;\n+  } else {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 700);\n+    *(vint8mf2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 600);\n+    *(vint16mf4_t*)(out + 600) = v;\n+  } else {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 700);\n+    *(vint16mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 600);\n+    *(vint16mf4_t*)(out + 600) = v;\n+  } else {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 700);\n+    *(vint16mf4_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 600);\n+    *(vint16mf2_t*)(out + 600) = v;\n+  } else {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 700);\n+    *(vint16mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 600);\n+    *(vint16mf2_t*)(out + 600) = v;\n+  } else {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 700);\n+    *(vint16mf2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 600);\n+    *(vint32mf2_t*)(out + 600) = v;\n+  } else {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 700);\n+    *(vint32mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 600);\n+    *(vint32mf2_t*)(out + 600) = v;\n+  } else {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 700);\n+    *(vint32mf2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "6265000a6e1c3d430b8e24f0d4b2d5b8992a2b8d", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-27.c", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-27.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,491 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 500);\n+    *(vuint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 600);\n+    *(vuint8mf8_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 700);\n+    *(vuint8mf8_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 500);\n+    *(vuint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 600);\n+    *(vuint8mf8_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 700);\n+    *(vuint8mf8_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 500);\n+    *(vuint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 600);\n+    *(vuint8mf4_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 700);\n+    *(vuint8mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 500);\n+    *(vuint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 600);\n+    *(vuint8mf4_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 700);\n+    *(vuint8mf4_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 500);\n+    *(vuint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 600);\n+    *(vuint8mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 700);\n+    *(vuint8mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 500);\n+    *(vuint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 600);\n+    *(vuint8mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 700);\n+    *(vuint8mf2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 500);\n+    *(vuint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 600);\n+    *(vuint16mf4_t*)(out + 600) = v;\n+  } else {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 700);\n+    *(vuint16mf4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 500);\n+    *(vuint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 600);\n+    *(vuint16mf4_t*)(out + 600) = v;\n+  } else {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 700);\n+    *(vuint16mf4_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 500);\n+    *(vuint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 600);\n+    *(vuint16mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 700);\n+    *(vuint16mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 500);\n+    *(vuint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 600);\n+    *(vuint16mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 700);\n+    *(vuint16mf2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 600);\n+    *(vuint32mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 700);\n+    *(vuint32mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 600);\n+    *(vuint32mf2_t*)(out + 600) = v;\n+  } else {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 700);\n+    *(vuint32mf2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "de7c5f9549148ed7be42c8e42920b1a9d3cac32d", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-28.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-28.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 600);\n+    *(vfloat32mf2_t*)(out + 600) = v;\n+  } else {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 700);\n+    *(vfloat32mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  if (n == 0) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 600);\n+    *(vfloat32mf2_t*)(out + 600) = v;\n+  } else {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 700);\n+    *(vfloat32mf2_t*)(out + 700) = v;\n+  }\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "f920017747bd9f29584042dacd9244c7bbd9e923", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-3.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 600);\n+    *(vfloat32mf2_t*)(out + 600) = v;\n+  } else {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 700);\n+    *(vfloat32mf2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "31a9e436e6be4a0e49d999e3fc9fef8166aa8aae", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-4.c", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,210 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool64_t v = *(vbool64_t*)(in + 600);\n+    *(vbool64_t*)(out + 600) = v;\n+  } else {\n+    vbool64_t v = *(vbool64_t*)(in + 700);\n+    *(vbool64_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool32_t v = *(vbool32_t*)(in + 600);\n+    *(vbool32_t*)(out + 600) = v;\n+  } else {\n+    vbool32_t v = *(vbool32_t*)(in + 700);\n+    *(vbool32_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool16_t v = *(vbool16_t*)(in + 600);\n+    *(vbool16_t*)(out + 600) = v;\n+  } else {\n+    vbool16_t v = *(vbool16_t*)(in + 700);\n+    *(vbool16_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool8_t v = *(vbool8_t*)(in + 600);\n+    *(vbool8_t*)(out + 600) = v;\n+  } else {\n+    vbool8_t v = *(vbool8_t*)(in + 700);\n+    *(vbool8_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool4_t v = *(vbool4_t*)(in + 600);\n+    *(vbool4_t*)(out + 600) = v;\n+  } else {\n+    vbool4_t v = *(vbool4_t*)(in + 700);\n+    *(vbool4_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool2_t v = *(vbool2_t*)(in + 600);\n+    *(vbool2_t*)(out + 600) = v;\n+  } else {\n+    vbool2_t v = *(vbool2_t*)(in + 700);\n+    *(vbool2_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f7 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool1_t v = *(vbool1_t*)(in + 600);\n+    *(vbool1_t*)(out + 600) = v;\n+  } else {\n+    vbool1_t v = *(vbool1_t*)(in + 700);\n+    *(vbool1_t*)(out + 700) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 6 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O2\" } } } } */"}, {"sha": "2cf28d7cd36ec1b0d43bf8831a6636ad5aad05f0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-5.c", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,167 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 600);\n+    *(vint8mf8_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 600);\n+    *(vint8mf4_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 600);\n+    *(vint8mf2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 600);\n+    *(vint16mf4_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 600);\n+    *(vint16mf2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 600);\n+    *(vint32mf2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */"}, {"sha": "d52c1bbecd3cbccebbc9c03ea82dfdd5111259fb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-6.c", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,167 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 600);\n+    *(vint8mf8_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 600);\n+    *(vint8mf4_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 600);\n+    *(vint8mf2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 600);\n+    *(vint16mf4_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 600);\n+    *(vint16mf2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 500);\n+    *(vuint32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 600);\n+    *(vuint32mf2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */"}, {"sha": "bd6d68bf780cfdcc324cb0e29eaf63b515a381ea", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-7.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 500);\n+    *(vfloat32mf2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 600);\n+    *(vfloat32mf2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */"}, {"sha": "d3b3fa3390e018e8c447789d566e87628112d8cd", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-8.c", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,194 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool64_t v = *(vbool64_t*)(in + 500);\n+    *(vbool64_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool64_t v = *(vbool64_t*)(in + 600);\n+    *(vbool64_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool32_t v = *(vbool32_t*)(in + 500);\n+    *(vbool32_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool32_t v = *(vbool32_t*)(in + 600);\n+    *(vbool32_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool16_t v = *(vbool16_t*)(in + 500);\n+    *(vbool16_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool16_t v = *(vbool16_t*)(in + 600);\n+    *(vbool16_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool8_t v = *(vbool8_t*)(in + 500);\n+    *(vbool8_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool8_t v = *(vbool8_t*)(in + 600);\n+    *(vbool8_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool4_t v = *(vbool4_t*)(in + 500);\n+    *(vbool4_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool4_t v = *(vbool4_t*)(in + 600);\n+    *(vbool4_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool2_t v = *(vbool2_t*)(in + 500);\n+    *(vbool2_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool2_t v = *(vbool2_t*)(in + 600);\n+    *(vbool2_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f7 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  if (n == 0) {\n+    vbool1_t v = *(vbool1_t*)(in + 500);\n+    *(vbool1_t*)(out + 500) = v;\n+  } else if (n == 1) {\n+    vbool1_t v = *(vbool1_t*)(in + 600);\n+    *(vbool1_t*)(out + 600) = v;\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */"}, {"sha": "e1c560953d59b8345bb046efc7372269dd78d6ff", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_bb_prop-9.c", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_bb_prop-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,230 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 500);\n+    *(vint8mf8_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 700);\n+    *(vint8mf8_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 500);\n+    *(vint8mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 700);\n+    *(vint8mf4_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 500);\n+    *(vint8mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 700);\n+    *(vint8mf2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 500);\n+    *(vint16mf4_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 700);\n+    *(vint16mf4_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 500);\n+    *(vint16mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 700);\n+    *(vint16mf2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  switch (n)\n+  {\n+  case 0:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  case 1:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 500);\n+    *(vint32mf2_t*)(out + 500) = v;\n+    break;\n+  }\n+  default:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 700);\n+    *(vint32mf2_t*)(out + 700) = v;\n+    break;\n+  }\n+  }\n+\n+  for (int i = 0 ; i < n * n; i++)\n+    out[i] = out[i] + out[i];\n+  \n+  for (int i = 0 ; i < n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+\n+  for (int i = 0 ; i < n * n * n * n; i++)\n+    out[i] = out[i] * out[i];\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 2 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */\n+/* { dg-final { scan-assembler-times {add\\ta[0-7],a[0-7],a[0-7]\\s+\\.L[0-9][0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-O1\" } } } } */"}, {"sha": "89b6abe397b5ef3885a61f2dd5f4612fadae4cd8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_call-1.c", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,239 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -O3 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void fn3 (void);\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool64_t v = *(vbool64_t*)(in + 900 + i);\n+    *(vbool64_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+int f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool32_t v = *(vbool32_t*)(in + 900 + i);\n+    *(vbool32_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+int f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool16_t v = *(vbool16_t*)(in + 900 + i);\n+    *(vbool16_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+int f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool8_t v = *(vbool8_t*)(in + 900 + i);\n+    *(vbool8_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+int f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool4_t v = *(vbool4_t*)(in + 900 + i);\n+    *(vbool4_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+int f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool2_t v = *(vbool2_t*)(in + 900 + i);\n+    *(vbool2_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+int f7 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vbool1_t v = *(vbool1_t*)(in + 900 + i);\n+    *(vbool1_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9][0-9]\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "930f6f88cf155612229614b227c67c1f1b33e580", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_call-2.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,207 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -O3 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void fn3 (void);\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 900 + i);\n+    *(vint8mf8_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 900 + i);\n+    *(vint8mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 900 + i);\n+    *(vint8mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 900 + i);\n+    *(vint16mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 900 + i);\n+    *(vint16mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 900 + i);\n+    *(vint32mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "e8b92e09fc4ae2930df048bbbe845d260643dcaa", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_call-3.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,207 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -O3 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void fn3 (void);\n+\n+void f (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 900 + i);\n+    *(vuint8mf8_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f2 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 900 + i);\n+    *(vuint8mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f3 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 900 + i);\n+    *(vuint8mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f4 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 900 + i);\n+    *(vuint16mf4_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f5 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 900 + i);\n+    *(vuint16mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 900 + i);\n+    *(vuint32mf2_t*)(out + 900 + i) = v;\n+  }\n+\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9][0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "27f11a8f8ed0c9013926081d0626c86e8fb6b083", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_call-4.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_call-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -O3 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void fn3 (void);\n+\n+void f6 (int8_t * restrict in, int8_t * restrict out, int n)\n+{\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  \n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+  fn3 ();\n+  for (int i = 0 ; i < n * n * n * n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 900 + i);\n+    *(vfloat32mf2_t*)(out + 900 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:\\s+vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 5 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "c5962e5a385cd4dc92ff602c2a9ef824c4a4a524", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_complex_loop-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_complex_loop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_complex_loop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_complex_loop-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 2) {\n+        \n+        if (cond) {\n+          vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i + 2000);\n+          *(vfloat32mf2_t*)out = v;\n+        } else {\n+          vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i + 3000);\n+          *(vfloat32mf2_t*)out = v;\n+        }\n+        \n+        for (size_t j = 0; j < m; j += 1) {\n+          if (j % 2 == 0) {\n+            vint8mf8_t v = *(vint8mf8_t*)(in + i + j + 100);\n+            *(vint8mf8_t*)out = v;\n+          } else {\n+            vint8mf8_t v = *(vint8mf8_t*)(in + i + j + 200);\n+            *(vint8mf8_t*)out = v;\n+          }\n+        }\n+        \n+        if (cond) {\n+          vuint16mf4_t v = *(vuint16mf4_t*)(in + i + 7000);\n+          *(vuint16mf4_t*)out = v;\n+        } else {\n+          vuint16mf4_t v = *(vuint16mf4_t*)(in + i + 8000);\n+          *(vuint16mf4_t*)out = v;\n+        }\n+      } else {\n+        if (cond) {\n+          vint8mf8_t v = *(vint8mf8_t*)(in + i + 4000);\n+          *(vint8mf8_t*)out = v;\n+        } else {\n+          vint8mf8_t v = *(vint8mf8_t*)(in + i + 5000);\n+          *(vint8mf8_t*)out = v;\n+        }\n+        \n+        vbool64_t v = *(vbool64_t*)(in + i + 300);\n+        *(vbool64_t*)out = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "8fa2bd8a8338986a589d75926f63fa78541a49de", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_complex_loop-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_complex_loop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_complex_loop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_complex_loop-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, int cond)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i % 2) {\n+        \n+        if (cond) {\n+          vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i + 2000);\n+          *(vfloat32mf2_t*)(out + i + 2000) = v;\n+        } else {\n+          vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i + 3000);\n+          *(vfloat32mf2_t*)(out + i + 3000) = v;\n+        }\n+        \n+        for (size_t j = 0; j < m; j += 1) {\n+          if (j % 2 == 0) {\n+            vint8mf8_t v = *(vint8mf8_t*)(in + i + j + 100);\n+            *(vint8mf8_t*)(out + i + j + 100) = v;\n+          } else {\n+            vint8mf8_t v = *(vint8mf8_t*)(in + i + j + 200);\n+            *(vint8mf8_t*)(out + i + j + 200) = v;\n+          }\n+        }\n+        \n+        if (cond) {\n+          vuint16mf4_t v = *(vuint16mf4_t*)(in + i + 7000);\n+          *(vuint16mf4_t*)(out + i + 7000) = v;\n+        } else {\n+          vuint16mf4_t v = *(vuint16mf4_t*)(in + i + 8000);\n+          *(vuint16mf4_t*)(out + i + 8000) = v;\n+        }\n+      } else {\n+        if (cond) {\n+          vuint16mf2_t v = *(vuint16mf2_t*)(in + i + 4000);\n+          *(vuint16mf2_t*)(out + i + 4000) = v;\n+        } else {\n+          vuint16mf2_t v = *(vuint16mf2_t*)(in + i + 5000);\n+          *(vuint16mf2_t*)(out + i + 5000) = v;\n+        }\n+        \n+        vbool1_t v = *(vbool1_t*)(in + i + 300);\n+        *(vbool1_t*)(out + i + 300) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 5 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-not {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "34ac4a541647f0dfc45b376cfcae7c0d0f9f6c19", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i != cond) {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      } else {\n+        vbool1_t v = *(vbool1_t*)(in + i + 400);\n+        *(vbool1_t*)(out + i + 400) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {\\.L[0-9]+:\\s+vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+j\\s+\\.L[0-9]+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "697b093f69ff67fad04058f7f940aed950225e2f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-10.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i != cond) {\n+        vbool16_t v = *(vbool16_t*)(in + i + 400);\n+        *(vbool16_t*)(out + i + 400) = v;\n+        for (int j = 0; j < m; j++) {\n+          vuint8mf2_t v = *(vuint8mf2_t*)(in + i + 100 + j);\n+          *(vuint8mf2_t*)(out + i + 100 + j) = v;\n+        }\n+      } else if (i == cond2) {\n+        vuint16mf2_t v = *(vuint16mf2_t*)(in + i + 200);\n+        *(vuint16mf2_t*)(out + i + 200) = v;\n+      } else {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 5 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "1dab5ed6e8494af514dbf06740c5756a0abe29b3", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-11.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, size_t cond, size_t cond2)\n+{\n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*) (in + i + 1);\n+    *(vint8mf8_t*) (out + i + 1) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v = *(vfloat32mf2_t*) (in + i + 2);\n+    *(vfloat32mf2_t*) (out + i + 2) = v;\n+  }\n+  for (int i = 0; i < n; i++) {\n+    vfloat32mf2_t v;\n+    *(vfloat32mf2_t*) (out + i + 3) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "38828bc56d50eca24dfe34d5f4caf5df084ba846", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-12.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f2 (int32_t * restrict in, int32_t * restrict in2, int32_t * restrict out, int32_t * restrict out2, size_t n, size_t m, size_t cond, size_t cond2)\n+{\n+  for (int i = 0; i < n; i++){\n+    out2[i] = in2[i] + out[i];\n+  }\n+  for (int i = 0; i < n; i++){\n+    out[i] = in[i] & out2[i];\n+  }\n+  for (int i = 0; i < n; i++){\n+    out2[i] = out[i] * out2[i];\n+  }\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i > cond) {\n+        if (cond2) {\n+          for (int j = 0; j < m; j++) {\n+            vint8mf8_t v2 = *(vint8mf8_t*)(in2 + i + 100 + j);\n+            *(vint8mf8_t*)(out2 + i + 100 + j) = v2;\n+          }\n+        } else {\n+          for (int j = 0; j < m; j++) {\n+            vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in2 + i + 300 + j);\n+            *(vfloat32mf2_t*)(out2 + i + 100 + j) = v3;\n+          }\n+        }\n+      } else {\n+        vbool64_t v = *(vbool64_t*)(in + i + 400);\n+        *(vbool64_t*)(out + i + 400) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "cd01c9f705b63ca3d36e03c992bc115c259b3416", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i == cond) {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      } else {\n+        vbool1_t v = *(vbool1_t*)(in + i + 400);\n+        *(vbool1_t*)(out + i + 400) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+j\\s+\\.L[0-9]+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "d79e83a3a87d3ae16f4db88ce0babd6bf2f44f5b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f2 (int32_t * restrict in, int32_t * restrict in2, int32_t * restrict out, int32_t * restrict out2, size_t n, size_t m, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i > cond) {\n+        if (cond2) {\n+          for (int j = 0; j < m; j++) {\n+            vint8mf8_t v2 = *(vint8mf8_t*)(in2 + i + 100 + j);\n+            *(vint8mf8_t*)(out2 + i + 100 + j) = v2;\n+          }\n+        } else {\n+          for (int j = 0; j < m; j++) {\n+            vfloat32mf2_t v3 = *(vfloat32mf2_t*)(in2 + i + 300 + j);\n+            *(vfloat32mf2_t*)(out2 + i + 100 + j) = v3;\n+          }\n+        }\n+      } else {\n+        vbool64_t v = *(vbool64_t*)(in + i + 400);\n+        *(vbool64_t*)(out + i + 400) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "44bd4d8be67bc8e96496491c45244b5aa0f16150", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-4.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i == cond) {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      } else if (i == cond2) {\n+        vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i + 200);\n+        *(vfloat32mf2_t*)(out + i + 200) = v;\n+      } else {\n+        vbool1_t v = *(vbool1_t*)(in + i + 400);\n+        *(vbool1_t*)(out + i + 400) = v;\n+      }\n+    }\n+}\n+\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]:+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 5 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "12f40f336afcd32fb6ae4f750330436f84ef1373", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-5.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i == cond) {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      } else if (i == cond2) {\n+        vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i + 200);\n+        *(vfloat32mf2_t*)(out + i + 200) = v;\n+      } else if (i == (cond2 - 1)) {\n+        vuint16mf2_t v = *(vuint16mf2_t*)(in + i + 300);\n+        *(vuint16mf2_t*)(out + i + 300) = v;\n+      } else {\n+        vbool1_t v = *(vbool1_t*)(in + i + 400);\n+        *(vbool1_t*)(out + i + 400) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]:+} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 7 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "217ce11f5a928d37a76cc6b75df4a67e37187c6c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-6.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * in, int32_t * out, int n, int cond)\n+{\n+  if (cond) {\n+    vint32mf2_t v = *(vint32mf2_t*) (in + 100);\n+    *(vint32mf2_t*) (out + 100) = v;\n+  } else {\n+    vint16mf2_t v = *(vint16mf2_t*) (in + 200);\n+    *(vint16mf2_t*) (out + 200) = v;\n+  }\n+  \n+  for (int i = 0; i < n; i++) {\n+    vint8mf8_t v = *(vint8mf8_t*) (in + 300 + i);\n+    *(vint8mf8_t*) (out + 300 + i) = v;\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.L[0-9]+:\\s+vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+:} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {\\.L[0-9]+:\\s+vle8\\.v} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "05058b8c0765d233de45c5424cde73b4921e7f38", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-7.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i != cond) {\n+        vbool1_t v = *(vbool1_t*)(in + i + 400);\n+        *(vbool1_t*)(out + i + 400) = v;\n+      } else if (i == cond2) {\n+        vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i + 200);\n+        *(vfloat32mf2_t*)(out + i + 200) = v;\n+      } else {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 4 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {j\\s+\\.L[0-9]+\\s+\\.L[0-9]+:\\s+vlm\\.v} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "79a02e47eb261f5dba1834754e2e69b0e2abb04a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i != cond) {\n+        vbool1_t v = *(vbool1_t*)(in + i + 400);\n+        *(vbool1_t*)(out + i + 400) = v;\n+      } else if (i == cond2) {\n+        vuint16mf2_t v = *(vuint16mf2_t*)(in + i + 200);\n+        *(vuint16mf2_t*)(out + i + 200) = v;\n+      } else {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 5 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {j\\s+\\.L[0-9]+\\s+\\.L[0-9]+:\\s+vlm\\.v} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 3 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "bd6d552b22eb3a55fa430db13b89511166ed8756", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_conflict-9.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_conflict-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-tree-vectorize\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (int32_t * restrict in, int32_t * restrict out, size_t n, size_t m, size_t cond, size_t cond2)\n+{\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      if (i != cond) {\n+        vbool1_t v = *(vbool1_t*)(in + i + 400);\n+        *(vbool1_t*)(out + i + 400) = v;\n+        for (int j = 0; j < m; j++) {\n+          vint32mf2_t v = *(vint32mf2_t*)(in + i + 100 + j);\n+          *(vint32mf2_t*)(out + i + 100 + j) = v;\n+        }\n+      } else if (i == cond2) {\n+        vuint16mf2_t v = *(vuint16mf2_t*)(in + i + 200);\n+        *(vuint16mf2_t*)(out + i + 200) = v;\n+      } else {\n+        vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+        *(vint8mf8_t*)(out + i + 100) = v;\n+      }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 7 { target { no-opts \"-O0\"  no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "db5f64ffad2224aabec683c3eb900f407165f570", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+      *(vint8mf8_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+      *(vint8mf8_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 300);\n+      *(vint8mf8_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+      *(vint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "d5c108c0872debb6b7543b0f12c51d21df410aeb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-10.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 100);\n+      *(vuint16mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 200);\n+      *(vuint16mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 300);\n+      *(vuint16mf2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + i);\n+      *(vuint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "2c8e0ba490bb70d262b884f69d56674a5fba3feb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-11.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 100);\n+      *(vint32mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+      *(vint32mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 300);\n+      *(vint32mf2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + i);\n+      *(vint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "50807adc3cd3c6dac50beec99d48c95a7b5816fd", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-12.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 100);\n+      *(vuint32mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 200);\n+      *(vuint32mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 300);\n+      *(vuint32mf2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + i);\n+      *(vuint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b9e0d207b84e4447d524ff6b5f1278c03ed8f3d9", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-13.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-13.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 100);\n+      *(vfloat32mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 200);\n+      *(vfloat32mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 300);\n+      *(vfloat32mf2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i);\n+      *(vfloat32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "efe51b2e0f996c55a102bd83e8091de0508a2760", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-14.c", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-14.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,189 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 100);\n+      *(vbool64_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 200);\n+      *(vbool64_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 300);\n+      *(vbool64_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + i);\n+      *(vbool64_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 100);\n+      *(vbool32_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 200);\n+      *(vbool32_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 300);\n+      *(vbool32_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + i);\n+      *(vbool32_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 100);\n+      *(vbool16_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 200);\n+      *(vbool16_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 300);\n+      *(vbool16_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + i);\n+      *(vbool16_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 100);\n+      *(vbool8_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 200);\n+      *(vbool8_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 300);\n+      *(vbool8_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + i);\n+      *(vbool8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 100);\n+      *(vbool4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 200);\n+      *(vbool4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 300);\n+      *(vbool4_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + i);\n+      *(vbool4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 100);\n+      *(vbool2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 200);\n+      *(vbool2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 300);\n+      *(vbool2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + i);\n+      *(vbool2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f7 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 100);\n+      *(vbool1_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 200);\n+      *(vbool1_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 300);\n+      *(vbool1_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + i);\n+      *(vbool1_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "3d4568e3bf07ae3914cc168a461959779e2fc638", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-15.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-15.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 300);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+      *(vint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "1b70c90c430e9ada02c96c8117ba46874aad0246", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-16.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-16.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 100);\n+    *(vuint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 200);\n+    *(vuint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 300);\n+    *(vuint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + i);\n+      *(vuint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b32b5618be6c0d521752cf3f6104bdbbf31fd699", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-17.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-17.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 100);\n+    *(vint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 200);\n+    *(vint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 300);\n+    *(vint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + i);\n+      *(vint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "bbbf40f1851eda5c1760799fcdb895e114fc318e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-18.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-18.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 100);\n+    *(vuint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 200);\n+    *(vuint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 300);\n+    *(vuint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + i);\n+      *(vuint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "36197ff00c85b7314b329b712b5b15ffe44b086c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-19.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-19.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 100);\n+    *(vint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 200);\n+    *(vint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 300);\n+    *(vint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+      *(vint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "ab6c1b13aa265eeb32ee50d342342fd57d5f3232", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 100);\n+      *(vuint8mf8_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 200);\n+      *(vuint8mf8_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 300);\n+      *(vuint8mf8_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + i);\n+      *(vuint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "4d5d55c1773a65f6bb76410f8356f7f804c60540", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-20.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-20.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 100);\n+    *(vuint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 200);\n+    *(vuint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 300);\n+    *(vuint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + i);\n+      *(vuint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "87e34bcc2dab8d9574770f7b4c50b2f6f51b7bb1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-21.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-21.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 100);\n+    *(vint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 200);\n+    *(vint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 300);\n+    *(vint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + i);\n+      *(vint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "b9ebf57769f574590790833780cfff498ad86777", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-22.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-22.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 100);\n+    *(vuint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 200);\n+    *(vuint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 300);\n+    *(vuint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + i);\n+      *(vuint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "12415de5d1d493936bd275728f4cac7bc604ea6a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-23.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-23.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 100);\n+    *(vint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 200);\n+    *(vint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 300);\n+    *(vint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + i);\n+      *(vint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "ee08fa8562e1ccdcedd47e3f507b970f5b923186", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-24.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-24.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 100);\n+    *(vuint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 200);\n+    *(vuint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 300);\n+    *(vuint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + i);\n+      *(vuint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "1f83d69a902d6d25f34a20bda3751486986539e5", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-25.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-25.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 100);\n+    *(vint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 300);\n+    *(vint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + i);\n+      *(vint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "8498754797e0942f4ed8acb0be205b2d7f1c7bd1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-26.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-26.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 100);\n+    *(vuint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 200);\n+    *(vuint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 300);\n+    *(vuint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + i);\n+      *(vuint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "750681935bdca7379b622fcb3fef909659d112dc", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-27.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-27.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 100);\n+    *(vfloat32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 200);\n+    *(vfloat32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 300);\n+    *(vfloat32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i);\n+      *(vfloat32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "17758e36a83990723692f9f958532c66a1d659eb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-28.c", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-28.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,231 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool64_t v = *(vbool64_t*)(in + 100);\n+    *(vbool64_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool64_t v = *(vbool64_t*)(in + 200);\n+    *(vbool64_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool64_t v = *(vbool64_t*)(in + 300);\n+    *(vbool64_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + i);\n+      *(vbool64_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool32_t v = *(vbool32_t*)(in + 100);\n+    *(vbool32_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool32_t v = *(vbool32_t*)(in + 200);\n+    *(vbool32_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool32_t v = *(vbool32_t*)(in + 300);\n+    *(vbool32_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + i);\n+      *(vbool32_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool16_t v = *(vbool16_t*)(in + 100);\n+    *(vbool16_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool16_t v = *(vbool16_t*)(in + 200);\n+    *(vbool16_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool16_t v = *(vbool16_t*)(in + 300);\n+    *(vbool16_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + i);\n+      *(vbool16_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool8_t v = *(vbool8_t*)(in + 100);\n+    *(vbool8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool8_t v = *(vbool8_t*)(in + 200);\n+    *(vbool8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool8_t v = *(vbool8_t*)(in + 300);\n+    *(vbool8_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + i);\n+      *(vbool8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool4_t v = *(vbool4_t*)(in + 100);\n+    *(vbool4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool4_t v = *(vbool4_t*)(in + 200);\n+    *(vbool4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool4_t v = *(vbool4_t*)(in + 300);\n+    *(vbool4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + i);\n+      *(vbool4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool2_t v = *(vbool2_t*)(in + 100);\n+    *(vbool2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool2_t v = *(vbool2_t*)(in + 200);\n+    *(vbool2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool2_t v = *(vbool2_t*)(in + 300);\n+    *(vbool2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + i);\n+      *(vbool2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f7 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool1_t v = *(vbool1_t*)(in + 100);\n+    *(vbool1_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool1_t v = *(vbool1_t*)(in + 200);\n+    *(vbool1_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool1_t v = *(vbool1_t*)(in + 300);\n+    *(vbool1_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + i);\n+      *(vbool1_t*)(out + i) = v;\n+    }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]+\\:} 1 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+"}, {"sha": "eb1afa55aabc4b5eee5fc8f14529b3f5428f0afa", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 100);\n+      *(vint8mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 200);\n+      *(vint8mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 300);\n+      *(vint8mf4_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + i);\n+      *(vint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "535f3261204a5d9245855c3f86cacf28a2a6f9d6", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 100);\n+      *(vuint8mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 200);\n+      *(vuint8mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 300);\n+      *(vuint8mf4_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + i);\n+      *(vuint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "ea7f4e3d2de1577a01aec91a8363a918f9085cee", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-5.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 100);\n+      *(vint8mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 200);\n+      *(vint8mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 300);\n+      *(vint8mf2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+      *(vint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "f340b44db31d94a2f3776084bba784610516b9c2", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-6.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 100);\n+      *(vuint8mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 200);\n+      *(vuint8mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 300);\n+      *(vuint8mf2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + i);\n+      *(vuint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "70aea4e7ea6ee8c496b75a3236ec9e99f4c52e59", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-7.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 100);\n+      *(vint16mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 200);\n+      *(vint16mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 300);\n+      *(vint16mf4_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + i);\n+      *(vint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "697d5faff2292fe3ad119787774fe2785093acb3", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-8.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 100);\n+      *(vuint16mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 200);\n+      *(vuint16mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 300);\n+      *(vuint16mf4_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + i);\n+      *(vuint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "f1edf8f68ecb55b56ef984112c48384651b0db95", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_miss_default-9.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_miss_default-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 100);\n+      *(vint16mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 200);\n+      *(vint16mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 300);\n+      *(vint16mf2_t*)(out + 300) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + i);\n+      *(vint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"   no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\\s+\\.L[0-9]\\:} 1 { target { no-opts \"-O0\"    no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" } } } } */"}, {"sha": "cd58e53a822e8da9d3886a26520c288e979f1eb0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+      *(vint8mf8_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+      *(vint8mf8_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 300);\n+      *(vint8mf8_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + 400);\n+      *(vint8mf8_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+      *(vint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,\\.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "1aaebdf4bc4dde14ec87d900060a179297731488", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-10.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 100);\n+      *(vuint16mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 200);\n+      *(vuint16mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 300);\n+      *(vuint16mf2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + 400);\n+      *(vuint16mf2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + i);\n+      *(vuint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "813ea49e705626293325a472024e43659fcb4ebf", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-11.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 100);\n+      *(vint32mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+      *(vint32mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 300);\n+      *(vint32mf2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + 400);\n+      *(vint32mf2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + i);\n+      *(vint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "9b59df9f78bd12d8b183d27167cb37affbe02da8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-12.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 100);\n+      *(vuint32mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 200);\n+      *(vuint32mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 300);\n+      *(vuint32mf2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + 400);\n+      *(vuint32mf2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + i);\n+      *(vuint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "35e4fd190af486cdcbd35788d5c4d355756dac93", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-13.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-13.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 100);\n+      *(vfloat32mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 200);\n+      *(vfloat32mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 300);\n+      *(vfloat32mf2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+      *(vfloat32mf2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i);\n+      *(vfloat32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "2330d34246f80a51d57e5781e7578aa8036aefe6", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-14.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-14.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,217 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 100);\n+      *(vbool64_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 200);\n+      *(vbool64_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 300);\n+      *(vbool64_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + 400);\n+      *(vbool64_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + i);\n+      *(vbool64_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 100);\n+      *(vbool32_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 200);\n+      *(vbool32_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 300);\n+      *(vbool32_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + 400);\n+      *(vbool32_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + i);\n+      *(vbool32_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 100);\n+      *(vbool16_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 200);\n+      *(vbool16_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 300);\n+      *(vbool16_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + 400);\n+      *(vbool16_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + i);\n+      *(vbool16_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 100);\n+      *(vbool8_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 200);\n+      *(vbool8_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 300);\n+      *(vbool8_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + 400);\n+      *(vbool8_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + i);\n+      *(vbool8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 100);\n+      *(vbool4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 200);\n+      *(vbool4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 300);\n+      *(vbool4_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + 400);\n+      *(vbool4_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + i);\n+      *(vbool4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 100);\n+      *(vbool2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 200);\n+      *(vbool2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 300);\n+      *(vbool2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + 400);\n+      *(vbool2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + i);\n+      *(vbool2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f7 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 100);\n+      *(vbool1_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 200);\n+      *(vbool1_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 300);\n+      *(vbool1_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + 400);\n+      *(vbool1_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + i);\n+      *(vbool1_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s+\\.L[0-9]+\\:\\s+vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 7 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "687ecdf0fa3c0c343589e374225558f2d8621266", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-15.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-15.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 100);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 200);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 300);\n+    *(vint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf8_t v = *(vint8mf8_t*)(in + 400);\n+    *(vint8mf8_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf8_t v = *(vint8mf8_t*)(in + i);\n+      *(vint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "d644fb6995557543e68381ce2466b7b8629184e4", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-16.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-16.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 100);\n+    *(vuint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 200);\n+    *(vuint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 300);\n+    *(vuint8mf8_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vuint8mf8_t v = *(vuint8mf8_t*)(in + 400);\n+    *(vuint8mf8_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + i);\n+      *(vuint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "ea4d95554bc52d6a182bd923e49a84ba416514db", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-17.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-17.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 100);\n+    *(vint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 200);\n+    *(vint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 300);\n+    *(vint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf4_t v = *(vint8mf4_t*)(in + 400);\n+    *(vint8mf4_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + i);\n+      *(vint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "cbbffb78966d814bc026fd3cfeb1c0d18f07f83b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-18.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-18.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 100);\n+    *(vuint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 200);\n+    *(vuint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 300);\n+    *(vuint8mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vuint8mf4_t v = *(vuint8mf4_t*)(in + 400);\n+    *(vuint8mf4_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + i);\n+      *(vuint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "21d5cc913107c3d5ca9dd25673acf05d15079741", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-19.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-19.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 100);\n+    *(vint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 200);\n+    *(vint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 300);\n+    *(vint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vint8mf2_t v = *(vint8mf2_t*)(in + 400);\n+    *(vint8mf2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+      *(vint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"   } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s+\\.L[0-9]+\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"   } } } } */"}, {"sha": "39d523b66764a09c41139426d5ab0fd2881194b5", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 100);\n+      *(vuint8mf8_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 200);\n+      *(vuint8mf8_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 300);\n+      *(vuint8mf8_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + 400);\n+      *(vuint8mf8_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf8_t v = *(vuint8mf8_t*)(in + i);\n+      *(vuint8mf8_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\"  no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "29dd2d6a774a80ed490d799c24db7b9bb6571656", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-20.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-20.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 100);\n+    *(vuint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 200);\n+    *(vuint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 300);\n+    *(vuint8mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vuint8mf2_t v = *(vuint8mf2_t*)(in + 400);\n+    *(vuint8mf2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + i);\n+      *(vuint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s+\\.L[0-9]+\\:\\s+vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "286a7439fb66c529af29e13925f99045f04d0a50", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-21.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-21.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 100);\n+    *(vint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 200);\n+    *(vint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 300);\n+    *(vint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vint16mf4_t v = *(vint16mf4_t*)(in + 400);\n+    *(vint16mf4_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + i);\n+      *(vint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s+\\.L[0-9]+\\:\\s+vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "4cd8a5dfc79c5dbb27284d3397699470a9b6c2ed", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-22.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-22.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 100);\n+    *(vuint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 200);\n+    *(vuint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 300);\n+    *(vuint16mf4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vuint16mf4_t v = *(vuint16mf4_t*)(in + 400);\n+    *(vuint16mf4_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + i);\n+      *(vuint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "5825f12a577fad3a2a39b8617ad13f079c290464", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-23.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-23.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 100);\n+    *(vint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 200);\n+    *(vint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 300);\n+    *(vint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vint16mf2_t v = *(vint16mf2_t*)(in + 400);\n+    *(vint16mf2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + i);\n+      *(vint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "e2b53313ee1811ccc61350ebe6195630159dd0c9", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-24.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-24.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 100);\n+    *(vuint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 200);\n+    *(vuint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 300);\n+    *(vuint16mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vuint16mf2_t v = *(vuint16mf2_t*)(in + 400);\n+    *(vuint16mf2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf2_t v = *(vuint16mf2_t*)(in + i);\n+      *(vuint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "f40ff57f57f0e2205d790b35c2cf119c2f2a7608", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-25.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-25.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 100);\n+    *(vint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 200);\n+    *(vint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 300);\n+    *(vint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vint32mf2_t v = *(vint32mf2_t*)(in + 400);\n+    *(vint32mf2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint32mf2_t v = *(vint32mf2_t*)(in + i);\n+      *(vint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "26a9933e8e221520a93335663de362e2b575d475", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-26.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-26.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 100);\n+    *(vuint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 200);\n+    *(vuint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 300);\n+    *(vuint32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vuint32mf2_t v = *(vuint32mf2_t*)(in + 400);\n+    *(vuint32mf2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint32mf2_t v = *(vuint32mf2_t*)(in + i);\n+      *(vuint32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "7028d9118bb1b5a09df5b3c171de1a2cc05371e0", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-27.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-27.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 100);\n+    *(vfloat32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 200);\n+    *(vfloat32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 300);\n+    *(vfloat32mf2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vfloat32mf2_t v = *(vfloat32mf2_t*)(in + 400);\n+    *(vfloat32mf2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vfloat32mf2_t v = *(vfloat32mf2_t*)(in + i);\n+      *(vfloat32mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "aa4c1a7f51d69cd6f9251b0abbf4d38f045fe6d4", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-28.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-28.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool64_t v = *(vbool64_t*)(in + 100);\n+    *(vbool64_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool64_t v = *(vbool64_t*)(in + 200);\n+    *(vbool64_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool64_t v = *(vbool64_t*)(in + 300);\n+    *(vbool64_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vbool64_t v = *(vbool64_t*)(in + 400);\n+    *(vbool64_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool64_t v = *(vbool64_t*)(in + i);\n+      *(vbool64_t*)(out + i) = v;\n+    }\n+}\n+\n+void f2 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool32_t v = *(vbool32_t*)(in + 100);\n+    *(vbool32_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool32_t v = *(vbool32_t*)(in + 200);\n+    *(vbool32_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool32_t v = *(vbool32_t*)(in + 300);\n+    *(vbool32_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vbool32_t v = *(vbool32_t*)(in + 400);\n+    *(vbool32_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool32_t v = *(vbool32_t*)(in + i);\n+      *(vbool32_t*)(out + i) = v;\n+    }\n+}\n+\n+void f3 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool16_t v = *(vbool16_t*)(in + 100);\n+    *(vbool16_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool16_t v = *(vbool16_t*)(in + 200);\n+    *(vbool16_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool16_t v = *(vbool16_t*)(in + 300);\n+    *(vbool16_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vbool16_t v = *(vbool16_t*)(in + 400);\n+    *(vbool16_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool16_t v = *(vbool16_t*)(in + i);\n+      *(vbool16_t*)(out + i) = v;\n+    }\n+}\n+\n+void f4 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool8_t v = *(vbool8_t*)(in + 100);\n+    *(vbool8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool8_t v = *(vbool8_t*)(in + 200);\n+    *(vbool8_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool8_t v = *(vbool8_t*)(in + 300);\n+    *(vbool8_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vbool8_t v = *(vbool8_t*)(in + 400);\n+    *(vbool8_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool8_t v = *(vbool8_t*)(in + i);\n+      *(vbool8_t*)(out + i) = v;\n+    }\n+}\n+\n+void f5 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool4_t v = *(vbool4_t*)(in + 100);\n+    *(vbool4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool4_t v = *(vbool4_t*)(in + 200);\n+    *(vbool4_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool4_t v = *(vbool4_t*)(in + 300);\n+    *(vbool4_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vbool4_t v = *(vbool4_t*)(in + 400);\n+    *(vbool4_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool4_t v = *(vbool4_t*)(in + i);\n+      *(vbool4_t*)(out + i) = v;\n+    }\n+}\n+\n+void f6 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool2_t v = *(vbool2_t*)(in + 100);\n+    *(vbool2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool2_t v = *(vbool2_t*)(in + 200);\n+    *(vbool2_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool2_t v = *(vbool2_t*)(in + 300);\n+    *(vbool2_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vbool2_t v = *(vbool2_t*)(in + 400);\n+    *(vbool2_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool2_t v = *(vbool2_t*)(in + i);\n+      *(vbool2_t*)(out + i) = v;\n+    }\n+}\n+\n+void f7 (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  switch (cond)\n+  {\n+  case 1:{\n+    vbool1_t v = *(vbool1_t*)(in + 100);\n+    *(vbool1_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 2:{\n+    vbool1_t v = *(vbool1_t*)(in + 200);\n+    *(vbool1_t*)(out + 100) = v;\n+    break;\n+  }\n+  case 3:{\n+    vbool1_t v = *(vbool1_t*)(in + 300);\n+    *(vbool1_t*)(out + 100) = v;\n+    break;\n+  }\n+  default:{\n+    vbool1_t v = *(vbool1_t*)(in + 400);\n+    *(vbool1_t*)(out + 400) = v;\n+    break;\n+  }\n+  }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vbool1_t v = *(vbool1_t*)(in + i);\n+      *(vbool1_t*)(out + i) = v;\n+    }\n+}\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vlm\\.v\\s*(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 7 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\"  } } } } */"}, {"sha": "41585d012e1d089ea53fc59e164da51d21d44d54", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-3.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 100);\n+      *(vint8mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 200);\n+      *(vint8mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 300);\n+      *(vint8mf4_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + 400);\n+      *(vint8mf4_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf4_t v = *(vint8mf4_t*)(in + i);\n+      *(vint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\"   no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\"   no-opts \"-flto\" } } } } */"}, {"sha": "d4890e31ff09bf8a35292002b09a742504e2f4fd", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-4.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 100);\n+      *(vuint8mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 200);\n+      *(vuint8mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 300);\n+      *(vuint8mf4_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + 400);\n+      *(vuint8mf4_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf4_t v = *(vuint8mf4_t*)(in + i);\n+      *(vuint8mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\"  no-opts \"-flto\"  } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\"  no-opts \"-flto\"  } } } } */"}, {"sha": "53905fca6feb470b37c262b718089370fc2d72b9", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-5.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 100);\n+      *(vint8mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 200);\n+      *(vint8mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 300);\n+      *(vint8mf2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + 400);\n+      *(vint8mf2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+      *(vint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "4d56ec5354071a2769d36dd5b646e9927fe27cfb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-6.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 100);\n+      *(vuint8mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 200);\n+      *(vuint8mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 300);\n+      *(vuint8mf2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + 400);\n+      *(vuint8mf2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint8mf2_t v = *(vuint8mf2_t*)(in + i);\n+      *(vuint8mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "f722ec49c02fd668137a1c85612c21f51dbde420", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 100);\n+      *(vint16mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 200);\n+      *(vint16mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 300);\n+      *(vint16mf4_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + 400);\n+      *(vint16mf4_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf4_t v = *(vint16mf4_t*)(in + i);\n+      *(vint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "69bd0be5fd662e473443f3bb515a7a91fe1ecc7c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-8.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 100);\n+      *(vuint16mf4_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 200);\n+      *(vuint16mf4_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 300);\n+      *(vuint16mf4_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + 400);\n+      *(vuint16mf4_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vuint16mf4_t v = *(vuint16mf4_t*)(in + i);\n+      *(vuint16mf4_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "208173fb4bbecff11b9f9aea3d630c4e238568d2", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_phi-9.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_phi-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+/* The for loop body should not have vsetvl instruction.  */\n+void f (void * restrict in, void * restrict out, int n, int cond)\n+{\n+  if (cond == 1)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 100);\n+      *(vint16mf2_t*)(out + 100) = v;\n+    }\n+  else if (cond == 2)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 200);\n+      *(vint16mf2_t*)(out + 200) = v;\n+    }\n+  else if (cond == 3)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 300);\n+      *(vint16mf2_t*)(out + 300) = v;\n+    }\n+  else\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + 400);\n+      *(vint16mf2_t*)(out + 400) = v;\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      vint16mf2_t v = *(vint16mf2_t*)(in + i);\n+      *(vint16mf2_t*)(out + i) = v;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 4 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */\n+/* { dg-final { scan-assembler-times {ble\\tra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7],zero,.L[0-9]+\\s*\\.L[0-9]+\\:\\s*vle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 1 { target { no-opts \"-O0\"  no-opts \"-Os\" no-opts \"-funroll-loops\" no-opts \"-g\" no-opts \"-flto\" } } } } */"}, {"sha": "fb1258f826ed713a1819414e2d76b544a5ff18de", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-1.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,154 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+/* Test insert-vsetvl PASS whether it's able to eliminate vsetvl for same vtype in VLMAX.  */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo1 (void * restrict in, void * restrict out)\n+{\n+  vbool64_t v1 = *(vbool64_t*)(in + 1);\n+  vbool64_t v2 = *(vbool64_t*)(in + 2);\n+  vbool64_t v3 = *(vbool64_t*)(in + 3);\n+  vbool64_t v4 = *(vbool64_t*)(in + 4);\n+  vbool64_t v5 = *(vbool64_t*)(in + 5);\n+  vbool64_t v6 = *(vbool64_t*)(in + 6);\n+  vbool64_t v7 = *(vbool64_t*)(in + 7);\n+  vbool64_t v8 = *(vbool64_t*)(in + 8);\n+  *(vbool64_t*)(out + 1) = v1;\n+  *(vbool64_t*)(out + 2) = v2;\n+  *(vbool64_t*)(out + 3) = v3;\n+  *(vbool64_t*)(out + 4) = v4;\n+  *(vbool64_t*)(out + 5) = v5;\n+  *(vbool64_t*)(out + 6) = v6;\n+  *(vbool64_t*)(out + 7) = v7;\n+  *(vbool64_t*)(out + 8) = v8;\n+}\n+\n+void foo2 (void * restrict in, void * restrict out)\n+{\n+  vbool32_t v1 = *(vbool32_t*)(in + 1);\n+  vbool32_t v2 = *(vbool32_t*)(in + 2);\n+  vbool32_t v3 = *(vbool32_t*)(in + 3);\n+  vbool32_t v4 = *(vbool32_t*)(in + 4);\n+  vbool32_t v5 = *(vbool32_t*)(in + 5);\n+  vbool32_t v6 = *(vbool32_t*)(in + 6);\n+  vbool32_t v7 = *(vbool32_t*)(in + 7);\n+  vbool32_t v8 = *(vbool32_t*)(in + 8);\n+  *(vbool32_t*)(out + 1) = v1;\n+  *(vbool32_t*)(out + 2) = v2;\n+  *(vbool32_t*)(out + 3) = v3;\n+  *(vbool32_t*)(out + 4) = v4;\n+  *(vbool32_t*)(out + 5) = v5;\n+  *(vbool32_t*)(out + 6) = v6;\n+  *(vbool32_t*)(out + 7) = v7;\n+  *(vbool32_t*)(out + 8) = v8;\n+}\n+\n+void foo3 (void * restrict in, void * restrict out)\n+{\n+  vbool16_t v1 = *(vbool16_t*)(in + 1);\n+  vbool16_t v2 = *(vbool16_t*)(in + 2);\n+  vbool16_t v3 = *(vbool16_t*)(in + 3);\n+  vbool16_t v4 = *(vbool16_t*)(in + 4);\n+  vbool16_t v5 = *(vbool16_t*)(in + 5);\n+  vbool16_t v6 = *(vbool16_t*)(in + 6);\n+  vbool16_t v7 = *(vbool16_t*)(in + 7);\n+  vbool16_t v8 = *(vbool16_t*)(in + 8);\n+  *(vbool16_t*)(out + 1) = v1;\n+  *(vbool16_t*)(out + 2) = v2;\n+  *(vbool16_t*)(out + 3) = v3;\n+  *(vbool16_t*)(out + 4) = v4;\n+  *(vbool16_t*)(out + 5) = v5;\n+  *(vbool16_t*)(out + 6) = v6;\n+  *(vbool16_t*)(out + 7) = v7;\n+  *(vbool16_t*)(out + 8) = v8;\n+}\n+\n+void foo4 (void * restrict in, void * restrict out)\n+{\n+  vbool8_t v1 = *(vbool8_t*)(in + 1);\n+  vbool8_t v2 = *(vbool8_t*)(in + 2);\n+  vbool8_t v3 = *(vbool8_t*)(in + 3);\n+  vbool8_t v4 = *(vbool8_t*)(in + 4);\n+  vbool8_t v5 = *(vbool8_t*)(in + 5);\n+  vbool8_t v6 = *(vbool8_t*)(in + 6);\n+  vbool8_t v7 = *(vbool8_t*)(in + 7);\n+  vbool8_t v8 = *(vbool8_t*)(in + 8);\n+  *(vbool8_t*)(out + 1) = v1;\n+  *(vbool8_t*)(out + 2) = v2;\n+  *(vbool8_t*)(out + 3) = v3;\n+  *(vbool8_t*)(out + 4) = v4;\n+  *(vbool8_t*)(out + 5) = v5;\n+  *(vbool8_t*)(out + 6) = v6;\n+  *(vbool8_t*)(out + 7) = v7;\n+  *(vbool8_t*)(out + 8) = v8;\n+}\n+\n+void foo5 (void * restrict in, void * restrict out)\n+{\n+  vbool4_t v1 = *(vbool4_t*)(in + 1);\n+  vbool4_t v2 = *(vbool4_t*)(in + 2);\n+  vbool4_t v3 = *(vbool4_t*)(in + 3);\n+  vbool4_t v4 = *(vbool4_t*)(in + 4);\n+  vbool4_t v5 = *(vbool4_t*)(in + 5);\n+  vbool4_t v6 = *(vbool4_t*)(in + 6);\n+  vbool4_t v7 = *(vbool4_t*)(in + 7);\n+  vbool4_t v8 = *(vbool4_t*)(in + 8);\n+  *(vbool4_t*)(out + 1) = v1;\n+  *(vbool4_t*)(out + 2) = v2;\n+  *(vbool4_t*)(out + 3) = v3;\n+  *(vbool4_t*)(out + 4) = v4;\n+  *(vbool4_t*)(out + 5) = v5;\n+  *(vbool4_t*)(out + 6) = v6;\n+  *(vbool4_t*)(out + 7) = v7;\n+  *(vbool4_t*)(out + 8) = v8;\n+}\n+\n+void foo6 (void * restrict in, void * restrict out)\n+{\n+  vbool2_t v1 = *(vbool2_t*)(in + 1);\n+  vbool2_t v2 = *(vbool2_t*)(in + 2);\n+  vbool2_t v3 = *(vbool2_t*)(in + 3);\n+  vbool2_t v4 = *(vbool2_t*)(in + 4);\n+  vbool2_t v5 = *(vbool2_t*)(in + 5);\n+  vbool2_t v6 = *(vbool2_t*)(in + 6);\n+  vbool2_t v7 = *(vbool2_t*)(in + 7);\n+  vbool2_t v8 = *(vbool2_t*)(in + 8);\n+  *(vbool2_t*)(out + 1) = v1;\n+  *(vbool2_t*)(out + 2) = v2;\n+  *(vbool2_t*)(out + 3) = v3;\n+  *(vbool2_t*)(out + 4) = v4;\n+  *(vbool2_t*)(out + 5) = v5;\n+  *(vbool2_t*)(out + 6) = v6;\n+  *(vbool2_t*)(out + 7) = v7;\n+  *(vbool2_t*)(out + 8) = v8;\n+}\n+\n+void foo7 (void * restrict in, void * restrict out)\n+{\n+  vbool1_t v1 = *(vbool1_t*)(in + 1);\n+  vbool1_t v2 = *(vbool1_t*)(in + 2);\n+  vbool1_t v3 = *(vbool1_t*)(in + 3);\n+  vbool1_t v4 = *(vbool1_t*)(in + 4);\n+  vbool1_t v5 = *(vbool1_t*)(in + 5);\n+  vbool1_t v6 = *(vbool1_t*)(in + 6);\n+  vbool1_t v7 = *(vbool1_t*)(in + 7);\n+  vbool1_t v8 = *(vbool1_t*)(in + 8);\n+  *(vbool1_t*)(out + 1) = v1;\n+  *(vbool1_t*)(out + 2) = v2;\n+  *(vbool1_t*)(out + 3) = v3;\n+  *(vbool1_t*)(out + 4) = v4;\n+  *(vbool1_t*)(out + 5) = v5;\n+  *(vbool1_t*)(out + 6) = v6;\n+  *(vbool1_t*)(out + 7) = v7;\n+  *(vbool1_t*)(out + 8) = v8;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */"}, {"sha": "bdfb964cc01472dc55857a380f78120dc062ce84", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-10.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,143 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f1 (void * restrict in, void * restrict out)\n+{\n+  vint16mf4_t v1 = *(vint16mf4_t*)(in + 1);\n+  vint8mf8_t v2;\n+  *(vint16mf4_t*)(out + 1) = v1;\n+  *(vint8mf8_t*)(out + 2) = v2;\n+}\n+\n+void f2 (void * restrict in, void * restrict out)\n+{\n+  vint16mf4_t v1 = *(vint16mf4_t*)(in + 1);\n+  vint32mf2_t v2;\n+  *(vint16mf4_t*)(out + 1) = v1;\n+  *(vint32mf2_t*)(out + 2) = v2;\n+}\n+\n+void f3 (void * restrict in, void * restrict out)\n+{\n+  vint16mf4_t v1 = *(vint16mf4_t*)(in + 1);\n+  vint64m1_t v2;\n+  *(vint16mf4_t*)(out + 1) = v1;\n+  *(vint64m1_t*)(out + 2) = v2;\n+}\n+\n+void f4 (void * restrict in, void * restrict out)\n+{\n+  vint16mf2_t v1 = *(vint16mf2_t*)(in + 1);\n+  vint8mf4_t v2;\n+  *(vint16mf2_t*)(out + 1) = v1;\n+  *(vint8mf4_t*)(out + 2) = v2;\n+}\n+\n+void f5 (void * restrict in, void * restrict out)\n+{\n+  vint16mf2_t v1 = *(vint16mf2_t*)(in + 1);\n+  vint32m1_t v2;\n+  *(vint16mf2_t*)(out + 1) = v1;\n+  *(vint32m1_t*)(out + 2) = v2;\n+}\n+\n+void f6 (void * restrict in, void * restrict out)\n+{\n+  vint16mf2_t v1 = *(vint16mf2_t*)(in + 1);\n+  vint64m2_t v2;\n+  *(vint16mf2_t*)(out + 1) = v1;\n+  *(vint64m2_t*)(out + 2) = v2;\n+}\n+\n+void f7 (void * restrict in, void * restrict out)\n+{\n+  vint16m1_t v1 = *(vint16m1_t*)(in + 1);\n+  vint8mf2_t v2;\n+  *(vint16m1_t*)(out + 1) = v1;\n+  *(vint8mf2_t*)(out + 2) = v2;\n+}\n+\n+void f8 (void * restrict in, void * restrict out)\n+{\n+  vint16m1_t v1 = *(vint16m1_t*)(in + 1);\n+  vint32m2_t v2;\n+  *(vint16m1_t*)(out + 1) = v1;\n+  *(vint32m2_t*)(out + 2) = v2;\n+}\n+\n+void f9 (void * restrict in, void * restrict out)\n+{\n+  vint16m1_t v1 = *(vint16m1_t*)(in + 1);\n+  vint64m4_t v2;\n+  *(vint16m1_t*)(out + 1) = v1;\n+  *(vint64m4_t*)(out + 2) = v2;\n+}\n+\n+void f10 (void * restrict in, void * restrict out)\n+{\n+  vint16m2_t v1 = *(vint16m2_t*)(in + 1);\n+  vint8m1_t v2;\n+  *(vint16m2_t*)(out + 1) = v1;\n+  *(vint8m1_t*)(out + 2) = v2;\n+}\n+\n+void f11 (void * restrict in, void * restrict out)\n+{\n+  vint16m2_t v1 = *(vint16m2_t*)(in + 1);\n+  vint32m4_t v2;\n+  *(vint16m2_t*)(out + 1) = v1;\n+  *(vint32m4_t*)(out + 2) = v2;\n+}\n+\n+void f12 (void * restrict in, void * restrict out)\n+{\n+  vint16m2_t v1 = *(vint16m2_t*)(in + 1);\n+  vint64m8_t v2;\n+  *(vint16m2_t*)(out + 1) = v1;\n+  *(vint64m8_t*)(out + 2) = v2;\n+}\n+\n+void f13 (void * restrict in, void * restrict out)\n+{\n+  vint16m4_t v1 = *(vint16m4_t*)(in + 1);\n+  vint8m2_t v2;\n+  *(vint16m4_t*)(out + 1) = v1;\n+  *(vint8m2_t*)(out + 2) = v2;\n+}\n+\n+void f14 (void * restrict in, void * restrict out)\n+{\n+  vint16m4_t v1 = *(vint16m4_t*)(in + 1);\n+  vint32m8_t v2;\n+  *(vint16m4_t*)(out + 1) = v1;\n+  *(vint32m8_t*)(out + 2) = v2;\n+}\n+\n+void f15 (void * restrict in, void * restrict out)\n+{\n+  vint16m8_t v1 = *(vint16m8_t*)(in + 1);\n+  vint8m4_t v2;\n+  *(vint16m8_t*)(out + 1) = v1;\n+  *(vint8m4_t*)(out + 2) = v2;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 15 { target { no-opts \"-O0\" } } } } */"}, {"sha": "17055f0f0bf09d7c08e244da27ad8ff9b028d665", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-11.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f1 (void * restrict in, void * restrict out)\n+{\n+  vint32mf2_t v1 = *(vint32mf2_t*)(in + 1);\n+  vint8mf8_t v2;\n+  *(vint32mf2_t*)(out + 1) = v1;\n+  *(vint8mf8_t*)(out + 2) = v2;\n+}\n+\n+void f2 (void * restrict in, void * restrict out)\n+{\n+  vint32mf2_t v1 = *(vint32mf2_t*)(in + 1);\n+  vint16mf4_t v2;\n+  *(vint32mf2_t*)(out + 1) = v1;\n+  *(vint16mf4_t*)(out + 2) = v2;\n+}\n+\n+void f3 (void * restrict in, void * restrict out)\n+{\n+  vint32mf2_t v1 = *(vint32mf2_t*)(in + 1);\n+  vint64m1_t v2;\n+  *(vint32mf2_t*)(out + 1) = v1;\n+  *(vint64m1_t*)(out + 2) = v2;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" } } } } */"}, {"sha": "1383995ac7214834e3f82560aa034d2f9cb01612", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-12.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f1 (void * restrict in, void * restrict out)\n+{\n+  vint8mf8_t v1 = *(vint8mf8_t*)(in + 1);\n+  vfloat32mf2_t v2;\n+  *(vint8mf8_t*)(out + 1) = v1;\n+  *(vfloat32mf2_t*)(out + 2) = v2;\n+}\n+\n+void f2 (void * restrict in, void * restrict out)\n+{\n+  vint8mf8_t v1 = *(vint8mf8_t*)(in + 1);\n+  vfloat64m1_t v2;\n+  *(vint8mf8_t*)(out + 1) = v1;\n+  *(vfloat64m1_t*)(out + 2) = v2;\n+}\n+\n+void f3 (void * restrict in, void * restrict out)\n+{\n+  vint8mf4_t v1 = *(vint8mf4_t*)(in + 1);\n+  vfloat32m1_t v2;\n+  *(vint8mf4_t*)(out + 1) = v1;\n+  *(vfloat32m1_t*)(out + 2) = v2;\n+}\n+\n+void f4 (void * restrict in, void * restrict out)\n+{\n+  vint8mf4_t v1 = *(vint8mf4_t*)(in + 1);\n+  vfloat64m2_t v2;\n+  *(vint8mf4_t*)(out + 1) = v1;\n+  *(vfloat64m2_t*)(out + 2) = v2;\n+}\n+\n+void f5 (void * restrict in, void * restrict out)\n+{\n+  vint8mf2_t v1 = *(vint8mf2_t*)(in + 1);\n+  vfloat32m2_t v2;\n+  *(vint8mf2_t*)(out + 1) = v1;\n+  *(vfloat32m2_t*)(out + 2) = v2;\n+}\n+\n+void f6 (void * restrict in, void * restrict out)\n+{\n+  vint8mf2_t v1 = *(vint8mf2_t*)(in + 1);\n+  vfloat64m4_t v2;\n+  *(vint8mf2_t*)(out + 1) = v1;\n+  *(vfloat64m4_t*)(out + 2) = v2;\n+}\n+\n+void f7 (void * restrict in, void * restrict out)\n+{\n+  vint8m1_t v1 = *(vint8m1_t*)(in + 1);\n+  vfloat32m4_t v2;\n+  *(vint8m1_t*)(out + 1) = v1;\n+  *(vfloat32m4_t*)(out + 2) = v2;\n+}\n+\n+void f8 (void * restrict in, void * restrict out)\n+{\n+  vint8m1_t v1 = *(vint8m1_t*)(in + 1);\n+  vfloat64m8_t v2;\n+  *(vint8m1_t*)(out + 1) = v1;\n+  *(vfloat64m8_t*)(out + 2) = v2;\n+}\n+\n+void f9 (void * restrict in, void * restrict out)\n+{\n+  vint8m2_t v1 = *(vint8m2_t*)(in + 1);\n+  vfloat32m8_t v2;\n+  *(vint8m2_t*)(out + 1) = v1;\n+  *(vfloat32m8_t*)(out + 2) = v2;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 9 { target { no-opts \"-O0\" } } } } */"}, {"sha": "ba4b5ef7c3b2443223fc23abf893f4262f80e3aa", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-13.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-13.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f1 (void * restrict in, void * restrict out)\n+{\n+  vint16mf4_t v1 = *(vint16mf4_t*)(in + 1);\n+  vfloat32mf2_t v2;\n+  *(vint16mf4_t*)(out + 1) = v1;\n+  *(vfloat32mf2_t*)(out + 2) = v2;\n+}\n+\n+void f2 (void * restrict in, void * restrict out)\n+{\n+  vint16mf4_t v1 = *(vint16mf4_t*)(in + 1);\n+  vfloat64m1_t v2;\n+  *(vint16mf4_t*)(out + 1) = v1;\n+  *(vfloat64m1_t*)(out + 2) = v2;\n+}\n+\n+void f3 (void * restrict in, void * restrict out)\n+{\n+  vint16mf2_t v1 = *(vint16mf2_t*)(in + 1);\n+  vfloat32m1_t v2;\n+  *(vint16mf2_t*)(out + 1) = v1;\n+  *(vfloat32m1_t*)(out + 2) = v2;\n+}\n+\n+void f4 (void * restrict in, void * restrict out)\n+{\n+  vint16mf2_t v1 = *(vint16mf2_t*)(in + 1);\n+  vfloat64m2_t v2;\n+  *(vint16mf2_t*)(out + 1) = v1;\n+  *(vfloat64m2_t*)(out + 2) = v2;\n+}\n+\n+void f5 (void * restrict in, void * restrict out)\n+{\n+  vint16m1_t v1 = *(vint16m1_t*)(in + 1);\n+  vfloat32m2_t v2;\n+  *(vint16m1_t*)(out + 1) = v1;\n+  *(vfloat32m2_t*)(out + 2) = v2;\n+}\n+\n+void f6 (void * restrict in, void * restrict out)\n+{\n+  vint16m1_t v1 = *(vint16m1_t*)(in + 1);\n+  vfloat64m4_t v2;\n+  *(vint16m1_t*)(out + 1) = v1;\n+  *(vfloat64m4_t*)(out + 2) = v2;\n+}\n+\n+void f7 (void * restrict in, void * restrict out)\n+{\n+  vint16m2_t v1 = *(vint16m2_t*)(in + 1);\n+  vfloat32m4_t v2;\n+  *(vint16m2_t*)(out + 1) = v1;\n+  *(vfloat32m4_t*)(out + 2) = v2;\n+}\n+\n+void f8 (void * restrict in, void * restrict out)\n+{\n+  vint16m2_t v1 = *(vint16m2_t*)(in + 1);\n+  vfloat64m8_t v2;\n+  *(vint16m2_t*)(out + 1) = v1;\n+  *(vfloat64m8_t*)(out + 2) = v2;\n+}\n+\n+void f9 (void * restrict in, void * restrict out)\n+{\n+  vint16m4_t v1 = *(vint16m4_t*)(in + 1);\n+  vfloat32m8_t v2;\n+  *(vint16m4_t*)(out + 1) = v1;\n+  *(vfloat32m8_t*)(out + 2) = v2;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 9 { target { no-opts \"-O0\" } } } } */"}, {"sha": "5f04c1929249f23cb6d09bcaa4ae0613152ed307", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-14.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-14.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f3 (void * restrict in, void * restrict out)\n+{\n+  vint32mf2_t v1 = *(vint32mf2_t*)(in + 1);\n+  vfloat64m1_t v2;\n+  *(vint32mf2_t*)(out + 1) = v1;\n+  *(vfloat64m1_t*)(out + 2) = v2;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 1 { target { no-opts \"-O0\" } } } } */"}, {"sha": "8debc17248f3a10cf2dc609b1b5f3b50a0c4566a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-15.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-15.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f1 (void * restrict in, void * restrict out)\n+{\n+  vfloat32mf2_t v1 = *(vfloat32mf2_t*)(in + 1);\n+  vint8mf8_t v2;\n+  *(vfloat32mf2_t*)(out + 1) = v1;\n+  *(vint8mf8_t*)(out + 2) = v2;\n+}\n+\n+void f2 (void * restrict in, void * restrict out)\n+{\n+  vfloat32mf2_t v1 = *(vfloat32mf2_t*)(in + 1);\n+  vint16mf4_t v2;\n+  *(vfloat32mf2_t*)(out + 1) = v1;\n+  *(vint16mf4_t*)(out + 2) = v2;\n+}\n+\n+void f3 (void * restrict in, void * restrict out)\n+{\n+  vfloat32mf2_t v1 = *(vfloat32mf2_t*)(in + 1);\n+  vint64m1_t v2;\n+  *(vfloat32mf2_t*)(out + 1) = v1;\n+  *(vint64m1_t*)(out + 2) = v2;\n+}\n+\n+void f4 (void * restrict in, void * restrict out)\n+{\n+  vfloat32mf2_t v1 = *(vfloat32mf2_t*)(in + 1);\n+  vfloat64m1_t v2;\n+  *(vfloat32mf2_t*)(out + 1) = v1;\n+  *(vfloat64m1_t*)(out + 2) = v2;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 2 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 4 { target { no-opts \"-O0\" } } } } */"}, {"sha": "c8913d8267d65078130ba63799022d5a6d25408c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-16.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-16.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,147 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f1 (void * restrict in, void * restrict out)\n+{\n+  vbool64_t v1 = *(vbool64_t*)(in + 1);\n+  vint16mf4_t v2;\n+  *(vbool64_t*)(out + 1) = v1;\n+  *(vint16mf4_t*)(out + 2) = v2;\n+}\n+\n+void f2 (void * restrict in, void * restrict out)\n+{\n+  vbool64_t v1 = *(vbool64_t*)(in + 1);\n+  vint32mf2_t v2;\n+  *(vbool64_t*)(out + 1) = v1;\n+  *(vint32mf2_t*)(out + 2) = v2;\n+}\n+\n+void f3 (void * restrict in, void * restrict out)\n+{\n+  vbool64_t v1 = *(vbool64_t*)(in + 1);\n+  vint64m1_t v2;\n+  *(vbool64_t*)(out + 1) = v1;\n+  *(vint64m1_t*)(out + 2) = v2;\n+}\n+\n+void f4 (void * restrict in, void * restrict out)\n+{\n+  vbool32_t v1 = *(vbool32_t*)(in + 1);\n+  vint16mf2_t v2;\n+  *(vbool32_t*)(out + 1) = v1;\n+  *(vint16mf2_t*)(out + 2) = v2;\n+}\n+\n+void f5 (void * restrict in, void * restrict out)\n+{\n+  vbool32_t v1 = *(vbool32_t*)(in + 1);\n+  vint32m1_t v2;\n+  *(vbool32_t*)(out + 1) = v1;\n+  *(vint32m1_t*)(out + 2) = v2;\n+}\n+\n+void f6 (void * restrict in, void * restrict out)\n+{\n+  vbool32_t v1 = *(vbool32_t*)(in + 1);\n+  vint64m2_t v2;\n+  *(vbool32_t*)(out + 1) = v1;\n+  *(vint64m2_t*)(out + 2) = v2;\n+}\n+\n+void f7 (void * restrict in, void * restrict out)\n+{\n+  vbool16_t v1 = *(vbool16_t*)(in + 1);\n+  vint16m1_t v2;\n+  *(vbool16_t*)(out + 1) = v1;\n+  *(vint16m1_t*)(out + 2) = v2;\n+}\n+\n+void f8 (void * restrict in, void * restrict out)\n+{\n+  vbool16_t v1 = *(vbool16_t*)(in + 1);\n+  vint32m2_t v2;\n+  *(vbool16_t*)(out + 1) = v1;\n+  *(vint32m2_t*)(out + 2) = v2;\n+}\n+\n+void f9 (void * restrict in, void * restrict out)\n+{\n+  vbool16_t v1 = *(vbool16_t*)(in + 1);\n+  vint64m4_t v2;\n+  *(vbool16_t*)(out + 1) = v1;\n+  *(vint64m4_t*)(out + 2) = v2;\n+}\n+\n+void f10 (void * restrict in, void * restrict out)\n+{\n+  vbool8_t v1 = *(vbool8_t*)(in + 1);\n+  vint16m2_t v2;\n+  *(vbool8_t*)(out + 1) = v1;\n+  *(vint16m2_t*)(out + 2) = v2;\n+}\n+\n+void f11 (void * restrict in, void * restrict out)\n+{\n+  vbool8_t v1 = *(vbool8_t*)(in + 1);\n+  vint32m4_t v2;\n+  *(vbool8_t*)(out + 1) = v1;\n+  *(vint32m4_t*)(out + 2) = v2;\n+}\n+\n+void f12 (void * restrict in, void * restrict out)\n+{\n+  vbool8_t v1 = *(vbool8_t*)(in + 1);\n+  vint64m8_t v2;\n+  *(vbool8_t*)(out + 1) = v1;\n+  *(vint64m8_t*)(out + 2) = v2;\n+}\n+\n+void f13 (void * restrict in, void * restrict out)\n+{\n+  vbool4_t v1 = *(vbool4_t*)(in + 1);\n+  vint16m4_t v2;\n+  *(vbool4_t*)(out + 1) = v1;\n+  *(vint16m4_t*)(out + 2) = v2;\n+}\n+\n+void f14 (void * restrict in, void * restrict out)\n+{\n+  vbool4_t v1 = *(vbool4_t*)(in + 1);\n+  vint32m8_t v2;\n+  *(vbool4_t*)(out + 1) = v1;\n+  *(vint32m8_t*)(out + 2) = v2;\n+}\n+\n+void f15 (void * restrict in, void * restrict out)\n+{\n+  vbool2_t v1 = *(vbool2_t*)(in + 1);\n+  vint16m8_t v2;\n+  *(vbool2_t*)(out + 1) = v1;\n+  *(vint16m8_t*)(out + 2) = v2;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e64,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 15 { target { no-opts \"-O0\" } } } } */"}, {"sha": "edb94218ede074b74d514967229765ed31aa471e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-17.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-17.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void foo7 (void * restrict in, void * restrict out)\n+{\n+  vbool1_t v1 = *(vbool1_t*)(in + 1);\n+  vbool2_t v2 = *(vbool2_t*)(in + 2);\n+  vbool4_t v3 = *(vbool4_t*)(in + 3);\n+  vbool8_t v4 = *(vbool8_t*)(in + 4);\n+  vbool16_t v5 = *(vbool16_t*)(in + 5);\n+  vbool32_t v6 = *(vbool32_t*)(in + 6);\n+  vbool64_t v7 = *(vbool64_t*)(in + 7);\n+  *(vbool1_t*)(out + 1) = v1;\n+  *(vbool2_t*)(out + 2) = v2;\n+  *(vbool4_t*)(out + 3) = v3;\n+  *(vbool8_t*)(out + 4) = v4;\n+  *(vbool16_t*)(out + 5) = v5;\n+  *(vbool32_t*)(out + 6) = v6;\n+  *(vbool64_t*)(out + 7) = v7;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 7 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\([a-x0-9]+\\)} 7 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */"}, {"sha": "e547b94621b8f0915a4569751b84377d781a01d6", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-18.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-18.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out)\n+{\n+  vint8mf8_t v1 = *(vint8mf8_t*)(in + 1);\n+  vint16mf4_t v2 = *(vint16mf4_t*)(in + 2);\n+  vint32mf2_t v3 = *(vint32mf2_t*)(in + 3);\n+  vfloat32mf2_t v4 = *(vfloat32mf2_t*)(in + 4);\n+  \n+  vint8mf4_t v5 = *(vint8mf4_t*)(in + 5);\n+  vint16mf2_t v6 = *(vint16mf2_t*)(in + 6);\n+  \n+  vint8mf2_t v7 = *(vint8mf2_t*)(in + 7);\n+  \n+  *(vint8mf8_t*)(out + 1) = v1;\n+  *(vint16mf4_t*)(out + 2) = v2;\n+  *(vint32mf2_t*)(out + 3) = v3;\n+  *(vfloat32mf2_t*)(out + 4) = v4;\n+  \n+  *(vint8mf4_t*)(out + 5) = v5;\n+  *(vint16mf2_t*)(out + 6) = v6;\n+  \n+  *(vint8mf2_t*)(out + 7) = v7;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" } } } } */"}, {"sha": "819e58281fec3c3e06c4c4293d7163a3cc11c35c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-19.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-19.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b", "patch": "@@ -0,0 +1,105 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32\" } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (void * restrict in, void * restrict out)\n+{\n+  vint8mf8_t v1 = *(vint8mf8_t*)(in + 1);\n+  vint16mf4_t v2;\n+  *(vint8mf8_t*)(out + 1) = v1;\n+  *(vint16mf4_t*)(out + 2) = v2;\n+  \n+  vint8mf8_t v3 = *(vint8mf8_t*)(in + 3);\n+  vint32mf2_t v4;\n+  *(vint8mf8_t*)(out + 3) = v3;\n+  *(vint32mf2_t*)(out + 4) = v4;\n+  \n+  vint8mf8_t v5 = *(vint8mf8_t*)(in + 5);\n+  vint64m1_t v6;\n+  *(vint8mf8_t*)(out + 5) = v5;\n+  *(vint64m1_t*)(out + 6) = v6;\n+  \n+  vint8mf4_t v7 = *(vint8mf4_t*)(in + 7);\n+  vint16mf2_t v8;\n+  *(vint8mf4_t*)(out + 7) = v7;\n+  *(vint16mf2_t*)(out + 8) = v8;\n+  \n+  vint8mf4_t v9 = *(vint8mf4_t*)(in + 9);\n+  vint32m1_t v10;\n+  *(vint8mf4_t*)(out + 9) = v9;\n+  *(vint32m1_t*)(out + 10) = v10;\n+  \n+  vint8mf4_t v11 = *(vint8mf4_t*)(in + 11);\n+  vint64m2_t v12;\n+  *(vint8mf4_t*)(out + 11) = v11;\n+  *(vint64m2_t*)(out + 12) = v12;\n+  \n+  vint8mf2_t v13 = *(vint8mf2_t*)(in + 13);\n+  vint16m1_t v14;\n+  *(vint8mf2_t*)(out + 13) = v13;\n+  *(vint16m1_t*)(out + 14) = v14;\n+  \n+  vint8mf2_t v15 = *(vint8mf2_t*)(in + 15);\n+  vint32m2_t v16;\n+  *(vint8mf2_t*)(out + 15) = v15;\n+  *(vint32m2_t*)(out + 16) = v16;\n+  \n+  vint8mf2_t v17 = *(vint8mf2_t*)(in + 17);\n+  vint64m4_t v18;\n+  *(vint8mf2_t*)(out + 17) = v17;\n+  *(vint64m4_t*)(out + 18) = v18;\n+  \n+  vint8m1_t v19 = *(vint8m1_t*)(in + 19);\n+  vint16m2_t v20;\n+  *(vint8m1_t*)(out + 19) = v19;\n+  *(vint16m2_t*)(out + 20) = v20;\n+  \n+  vint8m1_t v21 = *(vint8m1_t*)(in + 20);\n+  vint32m4_t v22;\n+  *(vint8m1_t*)(out + 20) = v21;\n+  *(vint32m4_t*)(out + 21) = v22;\n+  \n+  vint8m1_t v23 = *(vint8m1_t*)(in + 23);\n+  vint64m8_t v24;\n+  *(vint8m1_t*)(out + 21) = v23;\n+  *(vint64m8_t*)(out + 22) = v24;\n+  \n+  vint8m2_t v25 = *(vint8m2_t*)(in + 25);\n+  vint16m4_t v26;\n+  *(vint8m2_t*)(out + 25) = v25;\n+  *(vint16m4_t*)(out + 26) = v26;\n+  \n+  vint8m2_t v27 = *(vint8m2_t*)(in + 27);\n+  vint32m8_t v28;\n+  *(vint8m2_t*)(out + 27) = v27;\n+  *(vint32m8_t*)(out + 28) = v28;\n+  \n+  vint8m4_t v29 = *(vint8m4_t*)(in + 29);\n+  vint16m8_t v30;\n+  *(vint8m4_t*)(out + 29) = v29;\n+  *(vint16m8_t*)(out + 30) = v30;\n+}\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e64,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e64,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e64,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m2,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e64,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m4,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*zero,\\s*e32,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e16,\\s*m8,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */\n+\n+/* { dg-final { scan-assembler-times {vsetvli} 15 { target { no-opts \"-O0\" no-opts \"-O1\"  no-opts \"-Os\" no-opts \"-O2\" } } } } */"}, {"sha": "5ee37e99a45dc0885f40ea02c85ffeaeb343094d", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-2.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "ed3862753aba99df8437b1ae5e217a400f6a62ee", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "d8f1a0ba04e7cf3bc33fa79372ccea34fca6c747", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-4.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "293c818729ed21fc7d7c8df4a560b05f9b8c64c7", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-5.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "b0473708439dc95f101b7a008fe5099a201c4233", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-6.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "04d1930ee3e983a5e85e73720a4fa412fa681f12", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-7.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "abfbc1b3b78d6bd61cbdaaa49a7df0b8cc4c7653", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-8.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "6528c113a75d0f47e1dc5c4ef29c440d910586bb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_block-9.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_block-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "09f87d19cf9bf33361be833282c9de64747891e1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-1.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "48ac62495d06a4ec260f6f19a8ac4e195f6471f8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "43492800c9dff02150edea27a040b325ea4fec15", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-3.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "08c06b6080613e1525910b8ca8b314e1cc524a22", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-4.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "d3c71a03756cad8f74dfb89dac122df334e812ba", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-5.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "5986265e9bb8ebac6eb5bf4ecddaea74857abbbd", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "61728cfe7062e96bffab4fd0a4df4cbc3a85009d", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-7.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "82ce35b5fbc011bb6547fe03acf18c946ed26b2a", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_single_vtype-8.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_single_vtype-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "c8601a69281471b628b5c9cbdff85e4499c88670", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-1.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "b68932a680226736658c4aa01826f211701b6753", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-10.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-10.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "a6530a2712fe67b36e70e70524231eef0ecedc0b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-11.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-11.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "eaf69928d441b65ece498e0ce3bd152caa6119d1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-12.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-12.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "1f6ed17437a32d1c0e30a91de000600933bcefdb", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-13.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-13.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "291916f26003baf0fa12cde35726ce5c5234a4c1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-14.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-14.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "42930b6af0c9485690395fadad203afbf9802e30", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-15.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-15.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "087d97c0a6e84fee32dddfe2231613453d009d55", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-16.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-16.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "8bb6cbe7c35ceccd555e134cea4d5e2a32f6cb5e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-2.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "30c2e061c131398642022dea901279e0044a99f1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-3.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "7258f3f16060635fdd6ce69e9200fbd73b617495", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-4.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "7258f3f16060635fdd6ce69e9200fbd73b617495", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-5.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "32716591cded57f7c4ef531ff5ac81d697d74b4e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-6.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-6.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "ea91f0e966ae84addcf621eb75138aad2f450741", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-7.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-7.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "7537bfe925de9e885d596ff23066e409df51ccc1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-8.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-8.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "7537bfe925de9e885d596ff23066e409df51ccc1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vlmax_switch_vtype-9.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvlmax_switch_vtype-9.c?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "fd59bf1600701edb2efaec4545fc63603f095403", "filename": "gcc/testsuite/gfortran.dg/pr107397.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr107397.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr107397.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr107397.f90?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "2e770ae130a57931b95499adfff8de7d70a18a06", "filename": "gcc/testsuite/gm2/pimcoroutines/run/pass/testtime.mod", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgm2%2Fpimcoroutines%2Frun%2Fpass%2Ftesttime.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftestsuite%2Fgm2%2Fpimcoroutines%2Frun%2Fpass%2Ftesttime.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgm2%2Fpimcoroutines%2Frun%2Fpass%2Ftesttime.mod?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "5ec739ed218170c456d43d3db4f2a388af573dc5", "filename": "gcc/tree-vect-loop-manip.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftree-vect-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/gcc%2Ftree-vect-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.cc?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "7c9fd7b8072281b53602ec910630b3d4f0de2355", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "76857414654ea8bf299924b230ac8db52ba1d1c4", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "5a89189f6d8f95da8b40d5485e38a8ae4e71c312", "filename": "libsanitizer/hwasan/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libsanitizer%2Fhwasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libsanitizer%2Fhwasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2FMakefile.am?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "4240aa9014717450f21612ca438e5a1e20b552c3", "filename": "libsanitizer/hwasan/Makefile.in", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libsanitizer%2Fhwasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libsanitizer%2Fhwasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2FMakefile.in?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "3d5af68849e955a763e75380d0d366492a23e98d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}, {"sha": "a2babed63010414303ac4abd9e915481e9894bb5", "filename": "libstdc++-v3/include/experimental/contract", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fcontract", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6863cc3a23e8e47b9d8eec31710d5306cafcd65b/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fcontract", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fcontract?ref=6863cc3a23e8e47b9d8eec31710d5306cafcd65b"}]}