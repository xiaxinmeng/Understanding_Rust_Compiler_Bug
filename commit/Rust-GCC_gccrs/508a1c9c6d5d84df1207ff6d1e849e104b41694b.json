{"sha": "508a1c9c6d5d84df1207ff6d1e849e104b41694b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA4YTFjOWM2ZDVkODRkZjEyMDdmZjZkMWU4NDllMTA0YjQxNjk0Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-17T07:31:08Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-17T07:31:08Z"}, "message": "class.c (finish_struct_methods): Remove unncessary code.\n\n\t* class.c (finish_struct_methods): Remove unncessary code.\n\t(add_implicitly_declared_members): Create declarations for default\n\tconstructors and copy constructors lazily.\n\t* cp-tree.h (lang_type_class): Remove lazy_default_ctor and\n\tlazy_copy_ctor.\n\t(CLASSTYPE_LAZY_DEFAULT_CTOR): New macro.\n\t(CLASSTYPE_LAZY_COPY_CTOR): Likewise.\n\t* decl2.c (check_classfn): Robustify.\n\t(locate_dtor): Handle empty CLASSTYPE_METHOD_VEC.\n\t(locate_ctor): Handle lazy default constructors.\n\t(locate_copy): Handle lazy copy constructors.\n\t(implicitly_declare_fn): Make sure we're looking at the\n\tTYPE_MAIN_VARIANT for a class before creating functions.  Don't\n\tset TYPE_HAS_CONSTRUCTOR.\n\t(lazily_declare_fn): New function.\n\t* name-lookup.c (constructor_name_full): Simplify.\n\t* search.c (lookup_fnfields_1): Lazily create methods, as\n\tnecessary.\n\t(lookup_for_overrides): Handle empty CLASSTYPE_METHOD_VEC.\n\nFrom-SVN: r84851", "tree": {"sha": "2d69e1c139bcf0ee4f483089d38a6c6ff542bbce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d69e1c139bcf0ee4f483089d38a6c6ff542bbce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/508a1c9c6d5d84df1207ff6d1e849e104b41694b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508a1c9c6d5d84df1207ff6d1e849e104b41694b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508a1c9c6d5d84df1207ff6d1e849e104b41694b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508a1c9c6d5d84df1207ff6d1e849e104b41694b/comments", "author": null, "committer": null, "parents": [{"sha": "165b54c3f3249b748d8e7ac186d9ad93dab86d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165b54c3f3249b748d8e7ac186d9ad93dab86d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/165b54c3f3249b748d8e7ac186d9ad93dab86d86"}], "stats": {"total": 194, "additions": 134, "deletions": 60}, "files": [{"sha": "a67bfc37713892a20caf0e444c2e0aa2bb082451", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=508a1c9c6d5d84df1207ff6d1e849e104b41694b", "patch": "@@ -1,3 +1,25 @@\n+2004-07-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (finish_struct_methods): Remove unncessary code.\n+\t(add_implicitly_declared_members): Create declarations for default\n+\tconstructors and copy constructors lazily.\n+\t* cp-tree.h (lang_type_class): Remove lazy_default_ctor and\n+\tlazy_copy_ctor.\n+\t(CLASSTYPE_LAZY_DEFAULT_CTOR): New macro.\n+\t(CLASSTYPE_LAZY_COPY_CTOR): Likewise.\n+\t* decl2.c (check_classfn): Robustify.\n+\t(locate_dtor): Handle empty CLASSTYPE_METHOD_VEC.\n+\t(locate_ctor): Handle lazy default constructors.\n+\t(locate_copy): Handle lazy copy constructors.\n+\t(implicitly_declare_fn): Make sure we're looking at the\n+\tTYPE_MAIN_VARIANT for a class before creating functions.  Don't\n+\tset TYPE_HAS_CONSTRUCTOR.\n+\t(lazily_declare_fn): New function.\n+\t* name-lookup.c (constructor_name_full): Simplify.\n+\t* search.c (lookup_fnfields_1): Lazily create methods, as\n+\tnecessary.\n+\t(lookup_for_overrides): Handle empty CLASSTYPE_METHOD_VEC.\n+\n 2004-07-16  Steven Bosscher  <stevenb@suse.de>\n \n \t* cp-tree.h (struct lang_type): Don't have three GTY options on a"}, {"sha": "cc1dc7639000871bc0ee6a741005f94606f4fb82", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=508a1c9c6d5d84df1207ff6d1e849e104b41694b", "patch": "@@ -1714,18 +1714,10 @@ finish_struct_methods (tree t)\n   VEC(tree) *method_vec;\n   int slot, len;\n \n-  if (!TYPE_METHODS (t))\n-    {\n-      /* Clear these for safety; perhaps some parsing error could set\n-\t these incorrectly.  */\n-      TYPE_HAS_CONSTRUCTOR (t) = 0;\n-      TYPE_HAS_DESTRUCTOR (t) = 0;\n-      CLASSTYPE_METHOD_VEC (t) = NULL;\n-      return;\n-    }\n-\n   method_vec = CLASSTYPE_METHOD_VEC (t);\n-  my_friendly_assert (method_vec, 19991215);\n+  if (!method_vec)\n+    return;\n+\n   len = VEC_length (tree, method_vec);\n \n   /* First fill in entry 0 with the constructors, entry 1 with destructors,\n@@ -2554,21 +2546,17 @@ add_implicitly_declared_members (tree t,\n   /* Default constructor.  */\n   if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor)\n     {\n-      default_fn = implicitly_declare_fn (sfk_constructor, t, /*const_p=*/0);\n-      TREE_CHAIN (default_fn) = implicit_fns;\n-      implicit_fns = default_fn;\n+      TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 1;\n+      CLASSTYPE_LAZY_DEFAULT_CTOR (t) = 1;\n     }\n \n   /* Copy constructor.  */\n   if (! TYPE_HAS_INIT_REF (t) && ! TYPE_FOR_JAVA (t))\n     {\n-      /* ARM 12.18: You get either X(X&) or X(const X&), but\n-\t not both.  --Chip  */\n-      default_fn \n-\t= implicitly_declare_fn (sfk_copy_constructor, t,\n-\t\t\t\t /*const_p=*/!cant_have_const_cctor);\n-      TREE_CHAIN (default_fn) = implicit_fns;\n-      implicit_fns = default_fn;\n+      TYPE_HAS_INIT_REF (t) = 1;\n+      TYPE_HAS_CONST_INIT_REF (t) = !cant_have_const_cctor;\n+      CLASSTYPE_LAZY_COPY_CTOR (t) = 1;\n+      TYPE_HAS_CONSTRUCTOR (t) = 1;\n     }\n \n   /* If there is no assignment operator, one will be created if and"}, {"sha": "a7d35d46ecd0a6a4f0b24b401e92d13bbb75ba3c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=508a1c9c6d5d84df1207ff6d1e849e104b41694b", "patch": "@@ -991,6 +991,8 @@ struct lang_type_class GTY(())\n   unsigned ptrmemfunc_flag : 1;\n   unsigned was_anonymous : 1;\n \n+  unsigned lazy_default_ctor : 1;\n+  unsigned lazy_copy_ctor : 1;\n   unsigned has_const_init_ref : 1;\n   unsigned has_complex_init_ref : 1;\n   unsigned has_complex_assign_ref : 1;\n@@ -1004,7 +1006,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 11;\n+  unsigned dummy : 9;\n \n   tree primary_base;\n   tree vfields;\n@@ -1089,6 +1091,16 @@ struct lang_type GTY(())\n #define TYPE_HAS_CONVERSION(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->h.has_type_conversion)\n \n+/* Nonzero means that NODE (a class type) has a default constructor --\n+   but that it has not yet been declared.  */\n+#define CLASSTYPE_LAZY_DEFAULT_CTOR(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_default_ctor)\n+\n+/* Nonzero means that NODE (a class type) has a copy constructor --\n+   but that it has not yet been declared.  */\n+#define CLASSTYPE_LAZY_COPY_CTOR(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_copy_ctor)\n+\n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n #define TYPE_HAS_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_assign_ref)\n \n@@ -3884,6 +3896,7 @@ extern void finish_thunk (tree);\n extern void use_thunk (tree, bool);\n extern void synthesize_method (tree);\n extern tree implicitly_declare_fn (special_function_kind, tree, bool);\n+extern tree lazily_declare_fn (special_function_kind, tree);\n extern tree skip_artificial_parms_for (tree, tree);\n \n /* In optimize.c */"}, {"sha": "7257f696952bca817ee7f52655413e8a0ab01862", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=508a1c9c6d5d84df1207ff6d1e849e104b41694b", "patch": "@@ -693,9 +693,8 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \n \t  if (!fndecls && is_conv_op)\n \t    {\n-\t      if (VEC_length (tree, methods) > (size_t) ix)\n+\t      if (VEC_length (tree, methods) > (size_t) ++ix)\n \t\t{\n-\t\t  ix++;\n \t\t  fndecls = VEC_index (tree, methods, ix);\n \t\t  if (!DECL_CONV_FN_P (OVL_CURRENT (fndecls)))\n \t\t    {"}, {"sha": "984e0e90557da3b8052f8df473f3e7648d6efce3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=508a1c9c6d5d84df1207ff6d1e849e104b41694b", "patch": "@@ -825,7 +825,9 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n static tree\n locate_dtor (tree type, void *client ATTRIBUTE_UNUSED)\n {\n-  return CLASSTYPE_DESTRUCTORS (type);\n+  return (CLASSTYPE_METHOD_VEC (type) \n+\t  ? CLASSTYPE_DESTRUCTORS (type) \n+\t  : NULL_TREE);\n }\n \n /* Locate the default ctor of TYPE.  */\n@@ -838,6 +840,11 @@ locate_ctor (tree type, void *client ATTRIBUTE_UNUSED)\n   if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n     return NULL_TREE;\n \n+  /* Call lookup_fnfields_1 to create the constructor declarations, if\n+     necessary.  */\n+  if (CLASSTYPE_LAZY_DEFAULT_CTOR (type))\n+    return lazily_declare_fn (sfk_constructor, type);\n+\n   for (fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))\n     {\n       tree fn = OVL_CURRENT (fns);\n@@ -864,21 +871,27 @@ locate_copy (tree type, void *client_)\n {\n   struct copy_data *client = (struct copy_data *)client_;\n   tree fns;\n-  int ix = -1;\n   tree best = NULL_TREE;\n   bool excess_p = false;\n   \n   if (client->name)\n     {\n-      if (TYPE_HAS_ASSIGN_REF (type))\n-        ix = lookup_fnfields_1 (type, client->name);\n+      int ix;\n+      ix = lookup_fnfields_1 (type, client->name);\n+      if (ix < 0)\n+\treturn NULL_TREE;\n+      fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n     }\n   else if (TYPE_HAS_INIT_REF (type))\n-    ix = CLASSTYPE_CONSTRUCTOR_SLOT;\n-  if (ix < 0)\n+    {\n+      /* If construction of the copy constructor was postponed, create\n+\t it now.  */\n+      if (CLASSTYPE_LAZY_COPY_CTOR (type))\n+\tlazily_declare_fn (sfk_copy_constructor, type);\n+      fns = CLASSTYPE_CONSTRUCTORS (type);\n+    }\n+  else\n     return NULL_TREE;\n-  fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n-  \n   for (; fns; fns = OVL_NEXT (fns))\n     {\n       tree fn = OVL_CURRENT (fns);\n@@ -927,6 +940,8 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   tree rhs_parm_type = NULL_TREE;\n   tree name;\n \n+  type = TYPE_MAIN_VARIANT (type);\n+\n   switch (kind)\n     {\n     case sfk_destructor:\n@@ -939,12 +954,9 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       /* Default constructor.  */\n       name = constructor_name (type);\n       raises = synthesize_exception_spec (type, &locate_ctor, 0);\n-      TYPE_HAS_CONSTRUCTOR (type) = 1;\n       break;\n \n     case sfk_copy_constructor:\n-      TYPE_HAS_CONSTRUCTOR (type) = 1;\n-      /* Fall through. */\n     case sfk_assignment_operator:\n     {\n       struct copy_data data;\n@@ -1019,6 +1031,47 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   return fn;\n }\n \n+/* Add an implicit declaration to TYPE for the kind of function\n+   indicated by SFK.  Return the FUNCTION_DECL for the new implicit\n+   declaration.  */\n+\n+tree\n+lazily_declare_fn (special_function_kind sfk, tree type)\n+{\n+  tree fn;\n+  bool const_p;\n+\n+  /* Figure out whether or not the argument has a const reference\n+     type.  */\n+  if (sfk == sfk_copy_constructor)\n+    const_p = TYPE_HAS_CONST_INIT_REF (type);\n+  else if (sfk == sfk_assignment_operator)\n+    const_p = TYPE_HAS_CONST_ASSIGN_REF (type);\n+  else\n+    /* In this case, CONST_P will be ignored.  */\n+    const_p = false;\n+  /* Declare the function.  */\n+  fn = implicitly_declare_fn (sfk, type, const_p);\n+  /* Add it to CLASSTYPE_METHOD_VEC.  */\n+  add_method (type, fn);\n+  /* Add it to TYPE_METHODS.  */\n+  TREE_CHAIN (fn) = TYPE_METHODS (type);\n+  TYPE_METHODS (type) = fn;\n+  maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);\n+  if (sfk == sfk_constructor || sfk == sfk_copy_constructor)\n+    {\n+      /* Remember that the function has been created.  */\n+      if (sfk == sfk_constructor)\n+\tCLASSTYPE_LAZY_DEFAULT_CTOR (type) = 0;\n+      else\n+\tCLASSTYPE_LAZY_COPY_CTOR (type) = 0;\n+      /* Create appropriate clones.  */\n+      clone_function_decl (fn, /*update_method_vec=*/true);\n+    }\n+\n+  return fn;\n+}\n+\n /* Given a FUNCTION_DECL FN and a chain LIST, skip as many elements of LIST\n    as there are artificial parms in FN.  */\n "}, {"sha": "3a2f71ccaf71ad3162a4b37d746210853088cb3f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=508a1c9c6d5d84df1207ff6d1e849e104b41694b", "patch": "@@ -1794,12 +1794,7 @@ set_identifier_type_value (tree id, tree decl)\n tree\n constructor_name_full (tree type)\n {\n-  type = TYPE_MAIN_VARIANT (type);\n-  if (CLASS_TYPE_P (type) && TYPE_WAS_ANONYMOUS (type) \n-      && TYPE_HAS_CONSTRUCTOR (type))\n-    return DECL_NAME (OVL_CURRENT (CLASSTYPE_CONSTRUCTORS (type)));\n-  else\n-    return TYPE_IDENTIFIER (type);\n+  return TYPE_IDENTIFIER (TYPE_MAIN_VARIANT (type));\n }\n \n /* Return the name for the constructor (or destructor) for the"}, {"sha": "ceefa3cd05f1c3c98f6d65463e1e0d3e4ccdc2aa", "filename": "gcc/cp/search.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508a1c9c6d5d84df1207ff6d1e849e104b41694b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=508a1c9c6d5d84df1207ff6d1e849e104b41694b", "patch": "@@ -1368,8 +1368,24 @@ lookup_fnfields_1 (tree type, tree name)\n   if (!CLASS_TYPE_P (type))\n     return -1;\n \n-  method_vec = CLASSTYPE_METHOD_VEC (type);\n+  if (COMPLETE_TYPE_P (type))\n+    {\n+      if ((name == ctor_identifier\n+\t   || name == base_ctor_identifier\n+\t   || name == complete_ctor_identifier))\n+\t{\n+\t  if (CLASSTYPE_LAZY_DEFAULT_CTOR (type))\n+\t    lazily_declare_fn (sfk_constructor, type);\n+\t  if (CLASSTYPE_LAZY_COPY_CTOR (type))\n+\t    lazily_declare_fn (sfk_copy_constructor, type);\n+\t}\n+      else if (name == ansi_assopname(NOP_EXPR)\n+\t       && !TYPE_HAS_ASSIGN_REF (type)\n+\t       && !TYPE_FOR_JAVA (type))\n+\tlazily_declare_fn (sfk_assignment_operator, type);\n+    }\n \n+  method_vec = CLASSTYPE_METHOD_VEC (type);\n   if (!method_vec)\n     return -1;\n \n@@ -1405,24 +1421,6 @@ lookup_fnfields_1 (tree type, tree name)\n       int lo;\n       int hi;\n \n-      /* All non-Java classes have \"operator=\" -- but we do not\n-\t actually create the declaration until it is needed.  */\n-      if (name == ansi_assopname(NOP_EXPR)\n-\t  && !TYPE_HAS_ASSIGN_REF (type)\n-\t  && !TYPE_FOR_JAVA (type))\n-\t{\n-\t  tree fn;\n-\n-\t  /* Declare the function.  */\n-\t  fn = implicitly_declare_fn (sfk_assignment_operator, type,\n-\t\t\t\t      TYPE_HAS_CONST_ASSIGN_REF (type));\n-\t  add_method (type, fn);\n-\t  TREE_CHAIN (fn) = TYPE_METHODS (type);\n-\t  TYPE_METHODS (type) = fn;\n-\t  maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);\n-\t  method_vec = CLASSTYPE_METHOD_VEC (type);\n-\t}\n-\n       lo = i;\n       hi = VEC_length (tree, method_vec);\n       while (lo < hi)\n@@ -1789,6 +1787,12 @@ look_for_overrides_here (tree type, tree fndecl)\n {\n   int ix;\n \n+  /* If there are no methods in TYPE (meaning that only implicitly\n+     declared methods will ever be provided for TYPE), then there are\n+     no virtual functions.  */\n+  if (!CLASSTYPE_METHOD_VEC (type))\n+    return NULL_TREE;\n+\n   if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fndecl))\n     ix = CLASSTYPE_DESTRUCTOR_SLOT;\n   else"}]}