{"sha": "15f128a7193fe0724c9e1e4f0d6a015af7f1b97d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVmMTI4YTcxOTNmZTA3MjRjOWUxZTRmMGQ2YTAxNWFmN2YxYjk3ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-12T08:33:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-12T08:33:34Z"}, "message": "tree-vect-loop.c (vect_analyze_loop_operations): Move cost related code ...\n\n2015-10-12  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Move cost\n\trelated code ...\n\t(vect_analyze_loop_2): ... here.\n\nFrom-SVN: r228705", "tree": {"sha": "a9f4516e674424b99be4dba8d048a67249ba7543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9f4516e674424b99be4dba8d048a67249ba7543"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5a8677b3756ff2278a3f094bca7575514d90655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a8677b3756ff2278a3f094bca7575514d90655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5a8677b3756ff2278a3f094bca7575514d90655"}], "stats": {"total": 199, "additions": 101, "deletions": 98}, "files": [{"sha": "f46b4a64adbb5590d7a8808fa2e0726b280311dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15f128a7193fe0724c9e1e4f0d6a015af7f1b97d", "patch": "@@ -1,3 +1,9 @@\n+2015-10-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Move cost\n+\trelated code ...\n+\t(vect_analyze_loop_2): ... here.\n+\n 2015-10-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/67557"}, {"sha": "6b372389d6bde46e0c21a8696e02541fbacd9f27", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 95, "deletions": 98, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f128a7193fe0724c9e1e4f0d6a015af7f1b97d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=15f128a7193fe0724c9e1e4f0d6a015af7f1b97d", "patch": "@@ -1430,17 +1430,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  unsigned int vectorization_factor;\n   int i;\n   stmt_vec_info stmt_info;\n   bool need_to_vectorize = false;\n-  int min_profitable_iters;\n-  int min_scalar_loop_bound;\n-  unsigned int th;\n   bool ok;\n-  HOST_WIDE_INT max_niter;\n-  HOST_WIDE_INT estimated_niter;\n-  int min_profitable_estimate;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1585,94 +1578,6 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  gcc_assert (vectorization_factor != 0);\n-\n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"vectorization_factor = %d, niters = \"\n-\t\t     HOST_WIDE_INT_PRINT_DEC \"\\n\", vectorization_factor,\n-\t\t     LOOP_VINFO_INT_NITERS (loop_vinfo));\n-\n-  if ((LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-       && (LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor))\n-      || ((max_niter = max_stmt_executions_int (loop)) != -1\n-\t  && (unsigned HOST_WIDE_INT) max_niter < vectorization_factor))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: iteration count too small.\\n\");\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: iteration count smaller than \"\n-\t\t\t \"vectorization factor.\\n\");\n-      return false;\n-    }\n-\n-  /* Analyze cost.  Decide if worth while to vectorize.  */\n-\n-  vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n-\t\t\t\t      &min_profitable_estimate);\n-  LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n-\n-  if (min_profitable_iters < 0)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vector version will never be \"\n-\t\t\t \"profitable.\\n\");\n-      return false;\n-    }\n-\n-  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-                            * vectorization_factor) - 1);\n-\n-\n-  /* Use the cost model only if it is more conservative than user specified\n-     threshold.  */\n-\n-  th = (unsigned) min_scalar_loop_bound;\n-  if (min_profitable_iters\n-      && (!min_scalar_loop_bound\n-          || min_profitable_iters > min_scalar_loop_bound))\n-    th = (unsigned) min_profitable_iters;\n-\n-  LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = th;\n-\n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"not vectorized: iteration count smaller than user \"\n-\t\t\t \"specified loop bound parameter or minimum profitable \"\n-\t\t\t \"iterations (whichever is more conservative).\\n\");\n-      return false;\n-    }\n-\n-  if ((estimated_niter = estimated_stmt_executions_int (loop)) != -1\n-      && ((unsigned HOST_WIDE_INT) estimated_niter\n-          <= MAX (th, (unsigned)min_profitable_estimate)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: estimated iteration count too \"\n-                         \"small.\\n\");\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"not vectorized: estimated iteration count smaller \"\n-                         \"than specified loop bound parameter or minimum \"\n-                         \"profitable iterations (whichever is more \"\n-                         \"conservative).\\n\");\n-      return false;\n-    }\n-\n   return true;\n }\n \n@@ -1688,7 +1593,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   bool ok;\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   int min_vf = 2;\n-  unsigned int th;\n   unsigned int n_stmts = 0;\n \n   /* Find all data references in the loop (which correspond to vdefs/vuses)\n@@ -1786,6 +1690,33 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       vect_update_vf_for_slp (loop_vinfo);\n     }\n \n+  /* Now the vectorization factor is final.  */\n+  unsigned vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  gcc_assert (vectorization_factor != 0);\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"vectorization_factor = %d, niters = \"\n+\t\t     HOST_WIDE_INT_PRINT_DEC \"\\n\", vectorization_factor,\n+\t\t     LOOP_VINFO_INT_NITERS (loop_vinfo));\n+\n+  HOST_WIDE_INT max_niter\n+    = max_stmt_executions_int (LOOP_VINFO_LOOP (loop_vinfo));\n+  if ((LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+       && (LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor))\n+      || (max_niter != -1\n+\t  && (unsigned HOST_WIDE_INT) max_niter < vectorization_factor))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: iteration count too small.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: iteration count smaller than \"\n+\t\t\t \"vectorization factor.\\n\");\n+      return false;\n+    }\n+\n   /* Analyze the alignment of the data-refs in the loop.\n      Fail if a data reference is found that cannot be vectorized.  */\n \n@@ -1851,6 +1782,70 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n+  /* Analyze cost.  Decide if worth while to vectorize.  */\n+  int min_profitable_estimate, min_profitable_iters;\n+  vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n+\t\t\t\t      &min_profitable_estimate);\n+  LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n+\n+  if (min_profitable_iters < 0)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vector version will never be \"\n+\t\t\t \"profitable.\\n\");\n+      return false;\n+    }\n+\n+  int min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t\t\t\t* vectorization_factor) - 1);\n+\n+  /* Use the cost model only if it is more conservative than user specified\n+     threshold.  */\n+  unsigned th = (unsigned) min_scalar_loop_bound;\n+  if (min_profitable_iters\n+      && (!min_scalar_loop_bound\n+          || min_profitable_iters > min_scalar_loop_bound))\n+    th = (unsigned) min_profitable_iters;\n+\n+  LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = th;\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n+      if (dump_enabled_p ())\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"not vectorized: iteration count smaller than user \"\n+\t\t\t \"specified loop bound parameter or minimum profitable \"\n+\t\t\t \"iterations (whichever is more conservative).\\n\");\n+      return false;\n+    }\n+\n+  HOST_WIDE_INT estimated_niter\n+    = estimated_stmt_executions_int (LOOP_VINFO_LOOP (loop_vinfo));\n+  if (estimated_niter != -1\n+      && ((unsigned HOST_WIDE_INT) estimated_niter\n+          <= MAX (th, (unsigned)min_profitable_estimate)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: estimated iteration count too \"\n+                         \"small.\\n\");\n+      if (dump_enabled_p ())\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"not vectorized: estimated iteration count smaller \"\n+                         \"than specified loop bound parameter or minimum \"\n+                         \"profitable iterations (whichever is more \"\n+                         \"conservative).\\n\");\n+      return false;\n+    }\n+\n   /* Decide whether we need to create an epilogue loop to handle\n      remaining scalar iterations.  */\n   th = ((LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) + 1)\n@@ -1873,8 +1868,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n                   the epilogue is unnecessary.  */\n \t       && ((!LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo)\n \t            && !LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo))\n-                   || (unsigned HOST_WIDE_INT)max_stmt_executions_int\n-\t\t        (LOOP_VINFO_LOOP (loop_vinfo)) > th)))\n+                   || (unsigned HOST_WIDE_INT) max_niter > th)))\n     LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n \n   /* If an epilogue loop is required make sure we can create one.  */\n@@ -1896,6 +1890,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n         }\n     }\n \n+  gcc_assert (vectorization_factor\n+\t      == (unsigned)LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+\n   return true;\n }\n "}]}