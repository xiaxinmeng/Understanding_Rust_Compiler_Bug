{"sha": "b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRkMDA1MWJkOTdjN2M2Y2IyZTVlMmRjNjUyODY5ODVjZmNjYjM1Yw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-12-06T23:41:38Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-12-06T23:41:38Z"}, "message": "java-interp.h (class _Jv_InterpMethod): Added JV_MARKOBJ_DECL.\n\n\t* include/java-interp.h (class _Jv_InterpMethod): Added\n\tJV_MARKOBJ_DECL.\n\t* boehm.cc (_Jv_MarkObj): Consolidated interpreter code.  Also\n\tmark `prepared' field of interpreted method.\n\t* interpret.cc (compile): Use _Jv_AllocBytes.\n\nFrom-SVN: r59900", "tree": {"sha": "17255e0977815a30bda684d2dba5ea831676898f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17255e0977815a30bda684d2dba5ea831676898f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/comments", "author": null, "committer": null, "parents": [{"sha": "377dfc820f477c12d33c99b238171788c40fda02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/377dfc820f477c12d33c99b238171788c40fda02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/377dfc820f477c12d33c99b238171788c40fda02"}], "stats": {"total": 50, "additions": 34, "deletions": 16}, "files": [{"sha": "3e3ba7842d22cc5e0109cf753f11936b898748bc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "patch": "@@ -1,3 +1,11 @@\n+2002-12-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* include/java-interp.h (class _Jv_InterpMethod): Added\n+\tJV_MARKOBJ_DECL.\n+\t* boehm.cc (_Jv_MarkObj): Consolidated interpreter code.  Also\n+\tmark `prepared' field of interpreted method.\n+\t* interpret.cc (compile): Use _Jv_AllocBytes.\n+\n 2002-12-05  Andrew Haley  <aph@redhat.com>\n \n \t* gnu/gcj/runtime/natStackTrace.cc (fillInStackTrace): Throw"}, {"sha": "90796f2ddf0491d718825e9fd4e5344360157dde", "filename": "libjava/boehm.cc", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "patch": "@@ -39,7 +39,6 @@ extern \"C\"\n   ptr_t GC_debug_generic_malloc (size_t size, int k, GC_EXTRA_PARAMS);\n };\n \n-// We must check for plausibility ourselves.\n #define MAYBE_MARK(Obj, Top, Limit, Source, Exit)  \\\n \tTop=GC_MARK_AND_PUSH((GC_PTR)Obj, Top, Limit, (GC_PTR *)Source)\n \n@@ -153,19 +152,6 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n \t      p = (ptr_t) c->methods[i].signature;\n \t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t     cm2label);\n-\n-\t      // FIXME: `ncode' entry?\n-\n-#ifdef INTERPRETER\n-\t      // The interpreter installs a heap-allocated\n-\t      // trampoline here, so we'll mark it. \n-\t      if (_Jv_IsInterpretedClass (c))\n-\t\t  {\n-\t\t      p = (ptr_t) c->methods[i].ncode;\n-\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n-\t\t\t\t  cm3label);\n-\t\t  }\n-#endif\n \t    }\n \t}\n \n@@ -221,7 +207,7 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))\n \t{\n-\t  _Jv_InterpClass* ic = (_Jv_InterpClass*)c;\n+\t  _Jv_InterpClass* ic = (_Jv_InterpClass*) c;\n \n \t  p = (ptr_t) ic->interpreted_methods;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cElabel);\n@@ -231,6 +217,26 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n \t      p = (ptr_t) ic->interpreted_methods[i];\n \t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, \\\n \t\t\t  cFlabel);\n+\n+\t      // Mark the direct-threaded code.\n+\t      if ((c->methods[i].accflags\n+\t\t   & java::lang::reflect::Modifier::NATIVE) == 0)\n+\t\t{\n+\t\t  _Jv_InterpMethod *im\n+\t\t    = (_Jv_InterpMethod *) ic->interpreted_methods[i];\n+\t\t  if (im)\n+\t\t    {\n+\t\t      p = (ptr_t) im->prepared;\n+\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, \\\n+\t\t\t\t  cFlabel);\n+\t\t    }\n+\t\t}\n+\n+\t      // The interpreter installs a heap-allocated trampoline\n+\t      // here, so we'll mark it.\n+\t      p = (ptr_t) c->methods[i].ncode;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n+\t\t\t  cm3label);\n \t    }\n \n \t  p = (ptr_t) ic->field_initializers;"}, {"sha": "a44db38ca85080ccf0443d2b5115367e45c836f8", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "patch": "@@ -144,6 +144,10 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   friend class gnu::gcj::runtime::StackTrace;\n \n   friend void _Jv_PrepareClass(jclass);\n+\n+#ifdef JV_MARKOBJ_DECL\n+  friend JV_MARKOBJ_DECL;\n+#endif\n };\n \n class _Jv_InterpClass : public java::lang::Class"}, {"sha": "9791b4a5cd801d607f7a7cfa1fd6424c2cef7e24", "filename": "libjava/interpret.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=b4d0051bd97c7c6cb2e5e2dc65286985cfccb35c", "patch": "@@ -312,7 +312,7 @@ _Jv_InterpMethod::compile (const void * const *insn_targets)\n \n       if (! first_pass)\n \t{\n-\t  insns = (insn_slot *) _Jv_Malloc (sizeof (insn_slot) * next);\n+\t  insns = (insn_slot *) _Jv_AllocBytes (sizeof (insn_slot) * next);\n \t  next = 0;\n \t}\n "}]}