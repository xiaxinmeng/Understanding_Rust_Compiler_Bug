{"sha": "cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlODc0OWVjNTJlZmI0N2JhMmIxYzZiMjY2ZDUzZmMyMzlhMmYwZg==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-03-14T05:17:02Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-03-14T05:17:02Z"}, "message": "entered into RCS\n\nFrom-SVN: r479", "tree": {"sha": "5b16a7e6bc39e80c5df13422139c60ff07ce7884", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b16a7e6bc39e80c5df13422139c60ff07ce7884"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/comments", "author": null, "committer": null, "parents": [{"sha": "b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def"}], "stats": {"total": 2507, "additions": 2507, "deletions": 0}, "files": [{"sha": "8ef04c4cdf5662a653ad4f00a9546c077a989a70", "filename": "gcc/config/arm/arm.c", "status": "added", "additions": 1336, "deletions": 0, "changes": 1336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "patch": "@@ -0,0 +1,1336 @@\n+/* Output routines for GCC for ARM/RISCiX.\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+   Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n+   \t      and Martin Simmons (@harleqn.co.uk).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+\n+/* The maximum number of insns skipped which will be conditionalised if\n+   possible.  */\n+#define MAX_INSNS_SKIPPED  5\n+\n+/* Some function declarations.  */\n+extern void *xmalloc ();\n+extern FILE *asm_out_file;\n+extern char *output_multi_immediate ();\n+extern char *arm_output_asm_insn ();\n+extern void arm_increase_location ();\n+\n+/* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n+   must report the mode of the memory reference from PRINT_OPERAND to\n+   PRINT_OPERAND_ADDRESS.  */\n+int output_memory_reference_mode;\n+\n+/* Nonzero if the prologue must setup `fp'.  */\n+int current_function_anonymous_args;\n+\n+/* Location counter of .text segment.  */\n+int arm_text_location = 0;\n+\n+/* A hash table is used to store text segment labels and their associated\n+   offset from the start of the text segment.  */\n+struct label_offset\n+{\n+  char *name;\n+  int offset;\n+  struct label_offset *cdr;\n+};\n+\n+#define LABEL_HASH_SIZE  257\n+\n+static struct label_offset *offset_table[LABEL_HASH_SIZE];\n+\n+/* For an explanation of these variables, see final_prescan_insn below.  */\n+int arm_ccfsm_state;\n+int arm_current_cc;\n+rtx arm_target_insn;\n+int arm_target_label;\n+char *arm_condition_codes[];\n+\f\n+/* Return the number of mov instructions needed to get the constant VALUE into\n+   a register.  */\n+\n+int\n+arm_const_nmoves (value)\n+     register int value;\n+{\n+  register int i;\n+\n+  if (value == 0)\n+    return (1);\n+  for (i = 0; value; i++, value &= ~0xff)\n+    while ((value & 3) == 0)\n+      value = (value >> 2) | ((value & 3) << 30);\n+  return (i);\n+} /* arm_const_nmoves */\n+\n+\n+/* Return TRUE if int I is a valid immediate ARM constant.  */\n+\n+int\n+const_ok_for_arm (i)\n+     int i;\n+{\n+  unsigned int mask = ~0xFF;\n+\n+  do\n+    {\n+      if ((i & mask) == 0)\n+\treturn(TRUE);\n+      mask = (mask << 2) | (mask >> (32 - 2));\n+    } while (mask != ~0xFF);\n+\n+  return (FALSE);\n+} /* const_ok_for_arm */\n+\n+/* Return TRUE if rtx X is a valid immediate FPU constant. */\n+\n+int\n+const_double_rtx_ok_for_fpu (x)\n+     rtx x;\n+{\n+  double d;\n+  union real_extract u;\n+  u.i[0] = CONST_DOUBLE_LOW(x);\n+  u.i[1] = CONST_DOUBLE_HIGH(x);\n+  d = u.d;\n+\n+  return (d == 0.0 || d == 1.0 || d == 2.0 || d == 3.0\n+\t  || d == 4.0 || d == 5.0 || d == 0.5 || d == 10.0);\n+} /* const_double_rtx_ok_for_fpu */\n+\f\n+/* Predicates for `match_operand' and `match_operator'.  */\n+\n+/* Return TRUE for valid operands for the rhs of an ARM instruction.  */\n+\n+int\n+arm_rhs_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op))));\n+} /* arm_rhs_operand */\n+\n+/* Return TRUE for valid operands for the rhs of an FPU instruction.  */\n+\n+int\n+fpu_rhs_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return(TRUE);\n+  else if (GET_CODE (op) == CONST_DOUBLE)\n+    return (const_double_rtx_ok_for_fpu (op));\n+  else return (FALSE);\n+} /* fpu_rhs_operand */\n+\n+/* Return nonzero if OP is a constant power of two.  */\n+\n+int\n+power_of_two_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      int value = INTVAL(op);\n+      return (value != 0  &&  (value & (value-1)) == 0);\n+    }\n+  return (FALSE);\n+} /* power_of_two_operand */\n+\n+/* Return TRUE for a valid operand of a DImode operation.\n+   Either: REG, CONST_DOUBLE or MEM(offsettable).\n+   Note that this disallows MEM(REG+REG).  */\n+\n+int\n+di_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return (TRUE);\n+\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+      return (TRUE);\n+    case MEM:\n+      return (memory_address_p (DImode, XEXP (op, 0))\n+\t      && offsettable_address_p (FALSE, DImode, XEXP (op, 0)));\n+    default:\n+      return (FALSE);\n+    }\n+} /* di_operand */\n+\n+/* Return TRUE for valid index operands. */\n+\n+int\n+index_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand(op, mode)\n+\t  || (immediate_operand (op, mode) && abs (INTVAL (op)) < 4096));\n+} /* index_operand */\n+\n+/* Return TRUE for arithmetic operators which can be combined with a multiply\n+   (shift).  */\n+\n+int\n+shiftable_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (x) != mode)\n+    return FALSE;\n+  else\n+    {\n+      enum rtx_code code = GET_CODE (x);\n+\n+      return (code == PLUS || code == MINUS\n+\t      || code == IOR || code == XOR || code == AND);\n+    }\n+} /* shiftable_operator */\n+\n+/* Return TRUE for shift operators. */\n+\n+int\n+shift_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (x) != mode)\n+    return FALSE;\n+  else\n+    {\n+      enum rtx_code code = GET_CODE (x);\n+\n+      return (code == ASHIFT || code == LSHIFT\n+\t      || code == ASHIFTRT || code == LSHIFTRT);\n+    }\n+} /* shift_operator */\n+\f\n+/* Routines to output assembly language.  */\n+\n+/* Output the operands of a LDM/STM instruction to STREAM.\n+   MASK is the ARM register set mask of which only bits 0-15 are important.\n+   INSTR is the possibly suffixed base register.  HAT unequals zero if a hat\n+   must follow the register list.  */\n+\n+void\n+print_multi_reg (stream, instr, mask, hat)\n+     FILE *stream;\n+     char *instr;\n+     int mask, hat;\n+{\n+  int i;\n+  int not_first = FALSE;\n+\n+  fprintf (stream, \"\\t%s, {\", instr);\n+  for (i = 0; i < 16; i++)\n+    if (mask & (1 << i))\n+      {\n+\tif (not_first)\n+\t  fprintf (stream, \", \");\n+\tfprintf (stream, \"%s\", reg_names[i]);\n+\tnot_first = TRUE;\n+      }\n+  fprintf (stream, \"}%s\\n\", hat ? \"^\" : \"\");\n+} /* print_multi_reg */\n+\n+/* Output a 'call' insn. */\n+\n+char *\n+output_call (operands)\n+\trtx operands[];\n+{\n+  operands[0] = XEXP (operands[0], 0);\n+\n+  /* Handle calls to lr using ip (which may be clobbered in subr anyway). */\n+\n+  if (REGNO (operands[0]) == 14)\n+    {\n+      operands[0] = gen_rtx (REG, SImode, 12);\n+      arm_output_asm_insn (\"mov\\t%0, lr\", operands);\n+    }\n+  arm_output_asm_insn (\"mov\\tlr, pc\", operands);\n+  arm_output_asm_insn (\"mov\\tpc, %0\", operands);\n+  return (\"\");\n+} /* output_call */\n+\n+/* Output a move from arm registers to an fpu registers.\n+   OPERANDS[0] is an fpu register.\n+   OPERANDS[1] is the first registers of an arm register pair.  */\n+\n+char *\n+output_mov_double_fpu_from_arm (operands)\n+     rtx operands[];\n+{\n+  int arm_reg0 = REGNO (operands[1]);\n+  rtx ops[2];\n+\n+  if (arm_reg0 == 12)\n+    abort();\n+  ops[0] = gen_rtx (REG, SImode, arm_reg0);\n+  ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n+  arm_output_asm_insn (\"stmfd\\tsp!, {%0, %1}\", ops);\n+  arm_output_asm_insn (\"ldfd\\t%0, [sp], #8\", operands);\n+  return (\"\");\n+} /* output_mov_double_fpu_from_arm */\n+\n+/* Output a move from an fpu register to arm registers.\n+   OPERANDS[0] is the first registers of an arm register pair.\n+   OPERANDS[1] is an fpu register.  */\n+\n+char *\n+output_mov_double_arm_from_fpu (operands)\n+     rtx operands[];\n+{\n+  int arm_reg0 = REGNO (operands[0]);\n+  rtx ops[2];\n+\n+  if (arm_reg0 == 12)\n+    abort();\n+  ops[0] = gen_rtx (REG, SImode, arm_reg0);\n+  ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n+  arm_output_asm_insn (\"stfd\\t%1, [sp, #-8]!\", operands);\n+  arm_output_asm_insn (\"ldmfd\\tsp!, {%0, %1}\", ops);\n+  return(\"\");\n+} /* output_mov_double_arm_from_fpu */\n+\n+/* Output a move between double words.\n+   It must be REG<-REG, REG<-CONST_DOUBLE, REG<-CONST_INT, REG<-MEM\n+   or MEM<-REG and all MEMs must be offsettable addresses.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx operands[];\n+{\n+  enum rtx_code code0 = GET_CODE (operands[0]);\n+  enum rtx_code code1 = GET_CODE (operands[1]);\n+  rtx otherops[2];\n+\n+  if (code0 == REG)\n+    {\n+      int reg0 = REGNO (operands[0]);\n+\n+      otherops[0] = gen_rtx (REG, SImode, 1 + reg0);\n+      if (code1 == REG)\n+\t{\n+\t  int reg1 = REGNO (operands[1]);\n+\t  if (reg1 == 12)\n+\t    abort();\n+\t  otherops[1] = gen_rtx (REG, SImode, 1 + reg1);\n+\n+\t  /* Ensure the second source is not overwritten */\n+\t  if (reg0 == 1 + reg1)\n+\t    {\n+\t      arm_output_asm_insn(\"mov\\t%0, %1\", otherops);\n+\t      arm_output_asm_insn(\"mov\\t%0, %1\", operands);\n+\t    }\n+\t  else\n+\t    {\n+\t      arm_output_asm_insn(\"mov\\t%0, %1\", operands);\n+\t      arm_output_asm_insn(\"mov\\t%0, %1\", otherops);\n+\t    }\n+\t}\n+      else if (code1 == CONST_DOUBLE)\n+\t{\n+\t  otherops[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_HIGH (operands[1]));\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_LOW (operands[1]));\n+\t  arm_output_asm_insn (\"mov\\t%0, %1\", operands);\n+\t  arm_output_asm_insn (\"mov\\t%0, %1\", otherops);\n+\t}\n+      else if (code1 == CONST_INT)\n+\t{\n+\t  otherops[1] = const0_rtx;\n+\t  arm_output_asm_insn (\"mov\\t%0, %1\", operands);\n+\t  arm_output_asm_insn (\"mov\\t%0, %1\", otherops);\n+\t}\n+      else if (code1 == MEM)\n+\t{\n+\t  if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+\t    {\n+\t      /* Handle the simple case where address is [r, #0] more\n+\t\t efficient.  */\n+\t      operands[1] = XEXP (operands[1], 0);\n+\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t    }\n+\t  else\n+\t    {\n+\t      otherops[1] = adj_offsettable_operand (operands[1], 4);\n+\t      /* Take care of overlapping base/data reg.  */\n+\t      if (reg_mentioned_p (operands[0], operands[1]))\n+\t\t{\n+\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", otherops);\n+\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", operands);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", operands);\n+\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", otherops);\n+\t\t}\n+\t    }\n+\t}\n+      else abort();  /* Constraints should prevent this */\n+    }\n+  else if (code0 == MEM && code1 == REG)\n+    {\n+      if (REGNO (operands[1]) == 12)\n+\tabort();\n+\n+      if (GET_CODE (XEXP (operands[0], 0)) == REG)\n+\t{\n+\t  operands[0] = XEXP (operands[0], 0);\n+\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t}\n+      else\n+\t{\n+\t  otherops[0] = adj_offsettable_operand (operands[0], 4);\n+\t  otherops[1] = gen_rtx (REG, SImode, 1 + REGNO (operands[1]));\n+\t  arm_output_asm_insn (\"str\\t%1, %0\", operands);\n+\t  arm_output_asm_insn (\"str\\t%1, %0\", otherops);\n+\t}\n+    }\n+  else abort();  /* Constraints should prevent this */\n+\n+  return(\"\");\n+} /* output_move_double */\n+\n+\n+/* Output an arbitrary MOV reg, #n.\n+   OPERANDS[0] is a register.  OPERANDS[1] is a const_int.  */\n+\n+char *\n+output_mov_immediate (operands)\n+     rtx operands[2];\n+{\n+  int n = INTVAL (operands[1]);\n+  int n_ones = 0;\n+  int i;\n+\n+  /* Try to use one MOV */\n+\n+  if (const_ok_for_arm (n))\n+    return (arm_output_asm_insn (\"mov\\t%0, %1\", operands));\n+\n+  /* Try to use one MVN */\n+\n+  if (const_ok_for_arm(~n))\n+    {\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, ~n);\n+      return (arm_output_asm_insn (\"mvn\\t%0, %1\", operands));\n+    }\n+\n+  /* If all else fails, make it out of ORRs or BICs as appropriate. */\n+\n+  for (i=0; i < 32; i++)\n+    if (n & 1 << i)\n+      n_ones++;\n+\n+  if (n_ones > 16)  /* Shorter to use MVN with BIC in this case. */\n+    output_multi_immediate(operands, \"mvn\\t%0, %1\", \"bic\\t%0, %0, %1\", 1, ~n);\n+  else\n+    output_multi_immediate(operands, \"mov\\t%0, %1\", \"orr\\t%0, %0, %1\", 1, n);\n+  return(\"\");\n+} /* output_mov_immediate */\n+\n+\n+/* Output an ADD r, s, #n where n may be too big for one instruction.  If\n+   adding zero to one register, output nothing.  */\n+\n+char *\n+output_add_immediate (operands)\n+     rtx operands[3];\n+{\n+  int n = INTVAL (operands[2]);\n+\n+  if (n != 0 || REGNO (operands[0]) != REGNO (operands[1]))\n+    {\n+      if (n < 0)\n+\toutput_multi_immediate (operands,\n+\t\t\t\t\"sub\\t%0, %1, %2\", \"sub\\t%0, %0, %2\", 2, -n);\n+      else\n+\toutput_multi_immediate (operands,\n+\t\t\t\t\"add\\t%0, %1, %2\", \"add\\t%0, %0, %2\", 2, n);\n+    }\n+  return(\"\");\n+} /* output_add_immediate */\n+\n+\n+/* Output a multiple immediate operation.\n+   OPERANDS is the vector of operands referred to in the output patterns.\n+   INSTR1 is the output pattern to use for the first constant.\n+   INSTR2 is the output pattern to use for subsequent constants.\n+   IMMED_OP is the index of the constant slot in OPERANDS.\n+   N is the constant value.  */\n+\n+char *\n+output_multi_immediate (operands, instr1, instr2, immed_op, n)\n+     rtx operands[];\n+     char *instr1, *instr2;\n+     int immed_op, n;\n+{\n+  if (n == 0)\n+    {\n+      operands[immed_op] = const0_rtx;\n+      arm_output_asm_insn (instr1, operands); /* Quick and easy output */\n+    }\n+  else\n+    {\n+      int i;\n+      char *instr = instr1;\n+\n+      /* Note that n is never zero here (which would give no output) */\n+\n+      for (i = 0; i < 32; i += 2)\n+\t{\n+\t  if (n & (3 << i))\n+\t    {\n+\t      operands[immed_op] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t    n & (255 << i));\n+\t      arm_output_asm_insn (instr, operands);\n+\t      instr = instr2;\n+\t      i += 6;\n+\t    }\n+\t}\n+    }\n+  return (\"\");\n+} /* output_multi_immediate */\n+\n+\n+/* Return the appropriate ARM instruction for the operation code.\n+   The returned result should not be overwritten.  OP is the rtx of the\n+   operation.  SHIFT_FIRST_ARG is TRUE if the first argument of the operator\n+   was shifted.  */\n+\n+char *\n+arithmetic_instr (op, shift_first_arg)\n+     rtx op;\n+{\n+  switch (GET_CODE(op))\n+    {\n+    case PLUS:\n+      return (\"add\");\n+    case MINUS:\n+      if (shift_first_arg)\n+\treturn (\"rsb\");\n+      else\n+\treturn (\"sub\");\n+    case IOR:\n+      return (\"orr\");\n+    case XOR:\n+      return (\"eor\");\n+    case AND:\n+      return (\"and\");\n+    default:\n+      abort();\n+    }\n+  return (\"\");\t\t\t/* stupid cc */\n+} /* arithmetic_instr */\n+\n+\n+/* Ensure valid constant shifts and return the appropriate shift mnemonic\n+   for the operation code.  The returned result should not be overwritten.\n+   OP is the rtx code of the shift.\n+   SHIFT_PTR points to the shift size operand.  */\n+\n+char *\n+shift_instr (op, shift_ptr)\n+     enum rtx_code op;\n+     rtx *shift_ptr;\n+{\n+  int min_shift = 0;\n+  int max_shift = 31;\n+  char *mnem;\n+\n+  switch (op)\n+    {\n+    case ASHIFT:\n+      mnem = \"asl\";\n+      break;\n+    case LSHIFT:\n+      mnem = \"lsl\";\n+      break;\n+    case ASHIFTRT:\n+      mnem = \"asr\";\n+      max_shift = 32;\n+      break;\n+    case LSHIFTRT:\n+      mnem = \"lsr\";\n+      max_shift = 32;\n+      break;\n+    default:\n+      abort();\n+    }\n+\n+  if (GET_CODE (*shift_ptr) == CONST_INT)\n+    {\n+      int shift = INTVAL (*shift_ptr);\n+\n+      if (shift < min_shift)\n+\t*shift_ptr = gen_rtx (CONST_INT, VOIDmode, 0);\n+      else if (shift > max_shift)\n+\t*shift_ptr = gen_rtx (CONST_INT, VOIDmode, max_shift);\n+    }\n+  return (mnem);\n+} /* shift_instr */\n+\n+\n+/* Obtain the shift from the POWER of two. */\n+\n+int\n+int_log2 (power)\n+     unsigned int power;\n+{\n+  int shift = 0;\n+\n+  while (((1 << shift) & power) == 0)\n+    {\n+      if (shift > 31)\n+\tabort();\n+      shift++;\n+    }\n+  return (shift);\n+} /* int_log2 */\n+\n+\n+/* Output an arithmetic instruction which may set the condition code.\n+   OPERANDS[0] is the destination register.\n+   OPERANDS[1] is the arithmetic operator expression.\n+   OPERANDS[2] is the left hand argument.\n+   OPERANDS[3] is the right hand argument.\n+   CONST_FIRST_ARG is TRUE if the first argument of the operator was constant.\n+   SET_COND is TRUE when the condition code should be set.  */\n+\n+char *\n+output_arithmetic (operands, const_first_arg, set_cond)\n+     rtx operands[4];\n+     int const_first_arg;\n+     int set_cond;\n+{\n+  char mnemonic[80];\n+  char *instr = arithmetic_instr (operands[1], const_first_arg);\n+\n+  sprintf (mnemonic, \"%s%s\\t%%0, %%2, %%3\", instr, set_cond ? \"s\" : \"\");\n+  return (arm_output_asm_insn (mnemonic, operands));\n+} /* output_arithmetic */\n+\n+\n+/* Output an arithmetic instruction with a shift.\n+   OPERANDS[0] is the destination register.\n+   OPERANDS[1] is the arithmetic operator expression.\n+   OPERANDS[2] is the unshifted register.\n+   OPERANDS[3] is the shift operator expression.\n+   OPERANDS[4] is the shifted register.\n+   OPERANDS[5] is the shift constant or register.\n+   SHIFT_FIRST_ARG is TRUE if the first argument of the operator was shifted.\n+   SET_COND is TRUE when the condition code should be set.  */\n+\n+char *\n+output_arithmetic_with_shift (operands, shift_first_arg, set_cond)\n+     rtx operands[6];\n+     int shift_first_arg;\n+     int set_cond;\n+{\n+  char mnemonic[80];\n+  char *instr = arithmetic_instr (operands[1], shift_first_arg);\n+  char *condbit = set_cond ? \"s\" : \"\";\n+  char *shift = shift_instr (GET_CODE (operands[3]), &operands[5]);\n+\n+  sprintf (mnemonic, \"%s%s\\t%%0, %%2, %%4, %s %%5\", instr, condbit, shift);\n+  return (arm_output_asm_insn (mnemonic, operands));\n+} /* output_arithmetic_with_shift */\n+\n+\n+/* Output an arithmetic instruction with a power of two multiplication.\n+   OPERANDS[0] is the destination register.\n+   OPERANDS[1] is the arithmetic operator expression.\n+   OPERANDS[2] is the unmultiplied register.\n+   OPERANDS[3] is the multiplied register.\n+   OPERANDS[4] is the constant multiple (power of two).\n+   SHIFT_FIRST_ARG is TRUE if the first arg of the operator was multiplied.  */\n+\n+char *\n+output_arithmetic_with_immediate_multiply (operands, shift_first_arg)\n+     rtx operands[5];\n+     int shift_first_arg;\n+{\n+  char mnemonic[80];\n+  char *instr = arithmetic_instr (operands[1], shift_first_arg);\n+  int shift = int_log2 (INTVAL (operands[4]));\n+\n+  sprintf (mnemonic, \"%s\\t%%0, %%2, %%3, asl#%d\", instr, shift);\n+  return (arm_output_asm_insn (mnemonic, operands));\n+} /* output_arithmetic_with_immediate_multiply */\n+\n+\n+/* Output a move with a shift.\n+   OP is the shift rtx code.\n+   OPERANDS[0] = destination register.\n+   OPERANDS[1] = source register.\n+   OPERANDS[2] = shift constant or register.  */\n+\n+char *\n+output_shifted_move (op, operands)\n+     enum rtx_code op;\n+     rtx operands[2];\n+{\n+  char mnemonic[80];\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0)\n+    sprintf (mnemonic, \"mov\\t%%0, %%1\");\n+  else\n+    sprintf (mnemonic, \"mov\\t%%0, %%1, %s %%2\",\n+\t     shift_instr (op, &operands[2]));\n+  return (arm_output_asm_insn (mnemonic, operands));\n+} /* output_shifted_move */\n+\n+\n+/* Output a .ascii pseudo-op, keeping track of lengths.  This is because\n+   /bin/as is horribly restrictive.  */\n+\n+void\n+output_ascii_pseudo_op (stream, p, len)\n+     FILE *stream;\n+     char *p;\n+     int len;\n+{\n+  int i;\n+  int len_so_far = 1000;\n+  int chars_so_far = 0;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      register int c = p[i];\n+\n+      if (len_so_far > 50)\n+\t{\n+\t  if (chars_so_far)\n+\t    fputs (\"\\\"\\n\", stream);\n+\t  fputs (\"\\t.ascii\\t\\\"\", stream);\n+\t  len_so_far = 0;\n+\t  arm_increase_location (chars_so_far);\n+\t  chars_so_far = 0;\n+\t}\n+\n+      if (c == '\\\"' || c == '\\\\')\n+\t{\n+\t  putc('\\\\', stream);\n+\t  len_so_far++;\n+\t}\n+      if (c >= ' ' && c < 0177)\n+\t{\n+\t  putc (c, stream);\n+\t  len_so_far++;\n+\t}\n+      else\n+\t{\n+\t  fprintf (stream, \"\\\\%03o\", c);\n+\t  len_so_far +=4;\n+\t}\n+      chars_so_far++;\n+    }\n+  fputs (\"\\\"\\n\", stream);\n+  arm_increase_location (chars_so_far);\n+} /* output_ascii_pseudo_op */\n+\f\n+void\n+output_prologue (f, frame_size)\n+     FILE *f;\n+     int frame_size;\n+{\n+\n+  int reg, live_regs_mask = 0, code_size = 0;\n+  rtx operands[3];\n+\n+  /* Nonzero if the `fp' (argument pointer) register is needed.  */\n+  int fp_needed = 0;\n+\n+  /* Nonzero if we must stuff some register arguments onto the stack as if\n+     they were passed there.  */\n+  int store_arg_regs = 0;\n+\n+  fprintf (f, \"\\t@ args = %d, pretend = %d, frame = %d\\n\",\n+\t   current_function_args_size, current_function_pretend_args_size, frame_size);\n+  fprintf (f, \"\\t@ frame_pointer_needed = %d, current_function_anonymous_args = %d\\n\",\n+\t   frame_pointer_needed, current_function_anonymous_args);\n+\n+  if (current_function_pretend_args_size || current_function_args_size\n+      || frame_pointer_needed || current_function_anonymous_args || TARGET_APCS)\n+    fp_needed = 1;\n+\n+  if (current_function_anonymous_args && current_function_pretend_args_size)\n+    store_arg_regs = 1;\n+\n+  for (reg = 4; reg < 10; reg++)\n+    if (regs_ever_live[reg])\n+      live_regs_mask |= (1 << reg);\n+\n+  if (fp_needed)\n+    {\n+      live_regs_mask |= 0xD800;\n+      /* The following statement is probably redundant now\n+\t because the frame pointer is recorded in regs_ever_live.  */\n+      if (frame_pointer_needed)\n+\tlive_regs_mask |= (1 << FRAME_POINTER_REGNUM);\n+      fputs (\"\\tmov\\tip, sp\\n\", f);\n+      code_size += 4;\n+    }\n+  else if (regs_ever_live[14])\n+    live_regs_mask |= 0x4000;\n+\n+  /* If CURRENT_FUNCTION_PRETEND_ARGS_SIZE, adjust the stack pointer to make\n+     room.  If also STORE_ARG_REGS store the argument registers involved in\n+     the created slot (this is for stdarg and varargs).  */\n+  if (current_function_pretend_args_size)\n+    {\n+      if (store_arg_regs)\n+\t{\n+\t  int arg_size, mask = 0;\n+\n+\t  assert (current_function_pretend_args_size <= 16);\n+\t  for (reg = 3, arg_size = current_function_pretend_args_size;\n+\t       arg_size > 0; reg--, arg_size -= 4)\n+\t    mask |= (1 << reg);\n+\t  print_multi_reg (f, \"stmfd\\tsp!\", mask, FALSE);\n+\t}\n+      else\n+\t{\n+\t  operands[0] = operands[1] = stack_pointer_rtx;\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t -current_function_pretend_args_size);\n+\t  output_add_immediate (operands);\n+\t}\n+    }\n+\n+  if (live_regs_mask)\n+    {\n+      print_multi_reg (f, \"stmfd\\tsp!\", live_regs_mask, FALSE);\n+      code_size += 4;\n+    }\n+\n+  for (reg = 23; reg > 19; reg--)\n+    if (regs_ever_live[reg])\n+      {\n+\tfprintf (f, \"\\tstfe\\t%s, [sp, #-12]!\\n\", reg_names[reg]);\n+\tcode_size += 4;\n+      }\n+\n+  if (fp_needed)\n+    {\n+      /* Make `fp' point to saved value of `pc'. */\n+\n+      operands[0] = arg_pointer_rtx;\n+      operands[1] = gen_rtx (REG, SImode, 12);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     - (4 + current_function_pretend_args_size));\n+      output_add_immediate (operands);\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      fprintf (f, \"\\tmov\\trfp, sp\\n\");\n+      code_size += 4;\n+    }\n+\n+  if (frame_size)\n+    {\n+      operands[0] = operands[1] = stack_pointer_rtx;\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, -frame_size);\n+      output_add_immediate (operands);\n+    }\n+\n+  arm_increase_location (code_size);\n+} /* output_prologue */\n+\n+\n+void\n+output_epilogue (f, frame_size)\n+     FILE *f;\n+     int frame_size;\n+{\n+  int reg, live_regs_mask = 0, code_size = 0, fp_needed = 0;\n+  rtx operands[3];\n+\n+  if (current_function_pretend_args_size || current_function_args_size\n+      || frame_pointer_needed || current_function_anonymous_args || TARGET_APCS)\n+    fp_needed = 1;\n+\n+  for (reg = 4; reg < 10; reg++)\n+    if (regs_ever_live[reg])\n+      live_regs_mask |= (1 << reg);\n+\n+  if (fp_needed)\n+    {\n+      live_regs_mask |= 0xA800;\n+      if (frame_pointer_needed)\n+        live_regs_mask |= (1 << FRAME_POINTER_REGNUM);\n+    }\n+  else if (regs_ever_live[14])\n+    live_regs_mask |= 0x4000;\n+\n+  for (reg = 20; reg < 24; reg++)\n+    if (regs_ever_live[reg])\n+      {\n+\tfprintf (f, \"\\tldfe\\t%s, [%s], #12\\n\", reg_names[reg],\n+\t\t frame_pointer_needed ? \"rfp\" : \"sp\");\n+\tcode_size += 4;\n+      }\n+\n+  if (fp_needed)\n+    {\n+      print_multi_reg (f, \"ldmea\\tfp\", live_regs_mask, TRUE);\n+      code_size += 4;\n+    }\n+  else\n+    {\n+      if (current_function_pretend_args_size == 0 && regs_ever_live[14])\n+\t{\n+\t  print_multi_reg (f, \"ldmfd\\tsp!\",\n+\t\t\t   (live_regs_mask & ~0x4000) | 0x8000, TRUE);\n+\t  code_size += 4;\n+\t}\n+      else\n+\t{\n+\t  if (live_regs_mask)\n+\t    {\n+\t      print_multi_reg (f, \"ldmfd\\tsp!\", live_regs_mask, FALSE);\n+\t      code_size += 4;\n+\t    }\n+\t  if (current_function_pretend_args_size)\n+\t    {\n+\t      operands[0] = operands[1] = stack_pointer_rtx;\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     current_function_pretend_args_size);\n+\t      output_add_immediate (operands);\n+\t    }\n+\t  fputs (\"\\tmovs\\tpc, lr\\n\", f);\n+\t  code_size += 4;\n+\t}\n+    }\n+  arm_increase_location (code_size);\n+  current_function_anonymous_args = 0;\n+} /* output_epilogue */\n+\f\n+/* Increase the `arm_text_location' by AMOUNT if we're in the text\n+   segment.  */\n+\n+void\n+arm_increase_location (amount)\n+     int amount;\n+{\n+  if (in_text_section ())\n+    arm_text_location += amount;\n+} /* arm_increase_location */\n+\n+\n+/* Like output_asm_insn (), but also increases the arm_text_location (if in\n+   the .text segment, of course, even though this will always be true).\n+   Returns the empty string.  */\n+\n+char *\n+arm_output_asm_insn (template, operands)\n+     char *template;\n+     rtx *operands;\n+{\n+  extern FILE *asm_out_file;\n+\n+  output_asm_insn (template, operands);\n+  if (in_text_section ())\n+    arm_text_location += 4;\n+  fflush (asm_out_file);\n+  return (\"\");\n+} /* arm_output_asm_insn */\n+\n+\n+/* Output a label definition.  If this label is within the .text segment, it\n+   is stored in OFFSET_TABLE, to be used when building `llc' instructions.\n+   Maybe GCC remembers names not starting with a `*' for a long time, but this\n+   is a minority anyway, so we just make a copy.  Do not store the leading `*'\n+   if the name starts with one.  */\n+\n+void\n+arm_asm_output_label (stream, name)\n+     FILE *stream;\n+     char *name;\n+{\n+  char *real_name, *s;\n+  struct label_offset *cur;\n+  int hash = 0;\n+\n+  assemble_name (stream, name);\n+  fputs (\":\\n\", stream);\n+  if (! in_text_section ())\n+    return;\n+\n+  if (name[0] == '*')\n+    {\n+      real_name = xmalloc (1 + strlen (&name[1]));\n+      strcpy (real_name, &name[1]);\n+    }\n+  else\n+    {\n+      real_name = xmalloc (2 + strlen (name));\n+      strcpy (real_name, \"_\");\n+      strcat (real_name, name);\n+    }\n+  for (s = real_name; *s; s++)\n+    hash += *s;\n+  hash = hash % LABEL_HASH_SIZE;\n+  cur = xmalloc (sizeof (struct label_offset));\n+  cur->name = real_name;\n+  cur->offset = arm_text_location;\n+  cur->cdr = offset_table[hash];\n+  offset_table[hash] = cur;\n+} /* arm_asm_output_label */\n+\n+\n+/* Output the instructions needed to perform what Martin's /bin/as called\n+   llc: load an SImode thing from the function's constant pool.\n+\n+   XXX This could be enhanced in that we do not really need a pointer in the\n+   constant pool pointing to the real thing.  If we can address this pointer,\n+   we can also address what it is pointing at, in fact, anything in the text\n+   segment which has been defined already within this .s file.  */\n+\n+char *\n+arm_output_llc (operands)\n+     rtx *operands;\n+{\n+  char *s, *name = XSTR (XEXP (operands[1], 0), 0);\n+  struct label_offset *he;\n+  int hash = 0, conditional = (arm_ccfsm_state == 3 || arm_ccfsm_state == 4);\n+\n+  if (*name != '*')\n+    abort ();\n+\n+  for (s = &name[1]; *s; s++)\n+    hash += *s;\n+  hash = hash % LABEL_HASH_SIZE;\n+  he = offset_table[hash];\n+  while (he && strcmp (he->name, &name[1]))\n+    he = he->cdr;\n+\n+  if (!he)\n+    abort ();\n+\n+  if (arm_text_location + 8 - he->offset < 4095)\n+    {\n+      fprintf (asm_out_file, \"\\tldr%s\\t%s, [pc, #%s - . - 8]\\n\",\n+\t       conditional ? arm_condition_codes[arm_current_cc] : \"\",\n+\t       reg_names[REGNO (operands[0])], &name[1]);\n+      arm_increase_location (4);\n+      return (\"\");\n+    }\n+  else\n+    {\n+      int offset = - (arm_text_location + 8 - he->offset);\n+      char *reg_name = reg_names[REGNO (operands[0])];\n+\n+      /* ??? This is a hack, assuming the constant pool never is more than\n+\t (1 + 255) * 4096 == 1Meg away from the PC.  */\n+\n+      if (offset > 1000000)\n+\tabort ();\n+\n+      fprintf (asm_out_file, \"\\tsub%s\\t%s, pc, #(8 + . - %s) & ~4095\\n\",\n+\t       conditional ? arm_condition_codes[arm_current_cc] : \"\",\n+\t       reg_name, &name[1]);\n+      fprintf (asm_out_file, \"\\tldr%s\\t%s, [%s, #- ((4 + . - %s) & 4095)]\\n\",\n+\t       conditional ? arm_condition_codes[arm_current_cc] : \"\",\n+\t       reg_name, reg_name, &name[1]);\n+      arm_increase_location (8);\n+    }\n+  return (\"\");\n+} /* arm_output_llc */\n+\n+\n+/* Output code resembling an .lcomm directive.  /bin/as doesn't have this\n+   directive hence this hack, which works by reserving some `.space' in the\n+   bss segment directly.\n+\n+   XXX This is a severe hack, which is guaranteed NOT to work since it doesn't\n+   define STATIC COMMON space but merely STATIC BSS space.  */\n+\n+void\n+output_lcomm_directive (stream, name, size, rounded)\n+     FILE *stream;\n+     char *name;\n+     int size, rounded;\n+{\n+  fputs (\"\\n\\t.bss\\t@ .lcomm\\n\", stream);\n+  assemble_name (stream, name);\n+  fprintf (stream, \":\\t.space\\t%d\\n\", rounded);\n+  if (in_text_section ())\n+    fputs (\"\\n\\t.text\\n\", stream);\n+  else\n+    fputs (\"\\n\\t.data\\n\", stream);\n+} /* output_lcomm_directive */\n+\f\n+/* A finite state machine takes care of noticing whether or not instructions\n+   can be conditionally executed, and thus decrease execution time and code\n+   size by deleting branch instructions.  The fsm is controlled by\n+   final_prescan_insn, and controls the actions of ASM_OUTPUT_OPCODE.  */\n+\n+/* The state of the fsm controlling condition codes are:\n+   0: normal, do nothing special\n+   1: make ASM_OUTPUT_OPCODE not output this instruction\n+   2: make ASM_OUTPUT_OPCODE not output this instruction\n+   3: make instructions conditional\n+   4: make instructions conditional\n+\n+   State transitions (state->state by whom under condition):\n+   0 -> 1 final_prescan_insn if the `target' is a label\n+   0 -> 2 final_prescan_insn if the `target' is an unconditional branch\n+   1 -> 3 ASM_OUTPUT_OPCODE after not having output the conditional branch\n+   2 -> 4 ASM_OUTPUT_OPCODE after not having output the conditional branch\n+   3 -> 0 ASM_OUTPUT_INTERNAL_LABEL if the `target' label is reached\n+          (the target label has CODE_LABEL_NUMBER equal to arm_target_label).\n+   4 -> 0 final_prescan_insn if the `target' unconditional branch is reached\n+          (the target insn is arm_target_insn).\n+\n+   XXX In case the `target' is an unconditional branch, this conditionalising\n+   of the instructions always reduces code size, but not always execution\n+   time.  But then, I want to reduce the code size to somewhere near what\n+   /bin/cc produces.  */\n+\n+/* The condition codes of the ARM, and the inverse function.  */\n+char *arm_condition_codes[] =\n+{\n+  \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n+  \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\"\n+};\n+\n+#define ARM_INVERSE_CONDITION_CODE(X)  ((X) ^ 1)\n+\n+/* Returns the index of the ARM condition code string in\n+   `arm_condition_codes'.  COMPARISON should be an rtx like\n+   `(eq (...) (...))'.  */\n+\n+int\n+get_arm_condition_code (comparison)\n+     rtx comparison;\n+{\n+  switch (GET_CODE (comparison))\n+    {\n+    case NE: return (1);\n+    case EQ: return (0);\n+    case GE: return (10);\n+    case GT: return (12);\n+    case LE: return (13);\n+    case LT: return (11);\n+    case GEU: return (2);\n+    case GTU: return (8);\n+    case LEU: return (9);\n+    case LTU: return (3);\n+    default: abort ();\n+    }\n+  /*NOTREACHED*/\n+  return (42);\n+} /* get_arm_condition_code */\n+\n+\n+void\n+final_prescan_insn (insn, opvec, noperands)\n+     rtx insn;\n+     rtx *opvec;\n+     int noperands;\n+{\n+  /* BODY will hold the body of INSN.  */\n+  register rtx body = PATTERN (insn);\n+\n+  /* This will be 1 if trying to repeat the trick, and things need to be\n+     reversed if it appears to fail.  */\n+  int reverse = 0;\n+\n+  /* START_INSN will hold the insn from where we start looking.  This is the\n+     first insn after the following code_label if REVERSE is true.  */\n+  rtx start_insn = insn;\n+\n+  /* If in state 4, check if the target branch is reached, in order to\n+     change back to state 0.  */\n+  if (arm_ccfsm_state == 4)\n+    {\n+      if (insn == arm_target_insn)\n+\tarm_ccfsm_state = 0;\n+      return;\n+    }\n+\n+  /* If in state 3, it is possible to repeat the trick, if this insn is an\n+     unconditional branch to a label, and immediately following this branch\n+     is the previous target label which is only used once, and the label this\n+     branch jumps to is not too far off.  */\n+  if (arm_ccfsm_state == 3)\n+    {\n+      if (simplejump_p (insn))\n+\t{\n+\t  start_insn = next_nonnote_insn (start_insn);\n+\t  if (GET_CODE (start_insn) == BARRIER)\n+\t    {\n+\t      /* XXX Isn't this always a barrier?  */\n+\t      start_insn = next_nonnote_insn (start_insn);\n+\t    }\n+\t  if (GET_CODE (start_insn) == CODE_LABEL\n+\t      && CODE_LABEL_NUMBER (start_insn) == arm_target_label\n+\t      && LABEL_NUSES (start_insn) == 1)\n+\t    reverse = TRUE;\n+\t  else\n+\t    return;\n+\t}\n+      else\n+\treturn;\n+    }\n+\n+  if (arm_ccfsm_state != 0 && !reverse)\n+    abort ();\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    return;\n+\n+  if (reverse\n+      || (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == PC\n+\t  && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE))\n+    {\n+      int insns_skipped = 0, fail = FALSE, succeed = FALSE;\n+      /* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */\n+      int then_not_else = TRUE;\n+      rtx this_insn = start_insn, label;\n+\n+      /* Register the insn jumped to.  */\n+      if (reverse)\n+\tlabel = XEXP (SET_SRC (body), 0);\n+      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == LABEL_REF)\n+\tlabel = XEXP (XEXP (SET_SRC (body), 1), 0);\n+      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == LABEL_REF)\n+\t{\n+\t  label = XEXP (XEXP (SET_SRC (body), 2), 0);\n+\t  then_not_else = FALSE;\n+\t}\n+      else\n+\tabort ();\n+\n+      /* See how many insns this branch skips, and what kind of insns.  If all\n+\t insns are okay, and the label or unconditional branch to the same\n+\t label is not too far away, succeed.  */\n+      for (insns_skipped = 0;\n+\t   !fail && !succeed && insns_skipped < MAX_INSNS_SKIPPED;\n+\t   insns_skipped++)\n+\t{\n+\t  rtx scanbody;\n+\n+\t  this_insn = next_nonnote_insn (this_insn);\n+\t  if (!this_insn)\n+\t    break;\n+\n+\t  scanbody = PATTERN (this_insn);\n+\n+\t  switch (GET_CODE (this_insn))\n+\t    {\n+\t    case CODE_LABEL:\n+\t      /* Succeed if it is the target label, otherwise fail since\n+\t\t control falls in from somewhere else.  */\n+\t      if (this_insn == label)\n+\t\t{\n+\t\t  arm_ccfsm_state = 1;\n+\t\t  succeed = TRUE;\n+\t\t}\n+\t      else\n+\t\tfail = TRUE;\n+\t      break;\n+\n+\t    case BARRIER:\t/* XXX Is this case necessary?  */\n+\t      /* Succeed if the following insn is the target label.\n+\t\t Otherwise fail.  */\n+\t      this_insn = next_nonnote_insn (this_insn);\n+\t      if (this_insn == label)\n+\t\t{\n+\t\t  arm_ccfsm_state = 1;\n+\t\t  succeed = TRUE;\n+\t\t}\n+\t      else\n+\t\tfail = TRUE;\n+\t      break;\n+\n+\t    case JUMP_INSN:\n+      \t      /* If this is an unconditional branch to the same label, succeed.\n+\t\t If it is to another label, do nothing.  If it is conditional,\n+\t\t fail.  */\n+\t      /* XXX Probably, the test for the SET and the PC are unnecessary. */\n+\n+\t      if (GET_CODE (scanbody) == SET && GET_CODE (SET_DEST (scanbody)) == PC)\n+\t\t{\n+\t\t  if (GET_CODE (SET_SRC (scanbody)) == LABEL_REF\n+\t\t      && XEXP (SET_SRC (scanbody), 0) == label && !reverse)\n+\t\t    {\n+\t\t      arm_ccfsm_state = 2;\n+\t\t      succeed = TRUE;\n+\t\t    }\n+\t\t  else if (GET_CODE (SET_SRC (scanbody)) == IF_THEN_ELSE)\n+\t\t    fail = TRUE;\n+\t\t}\n+\t      break;\n+\n+\t    case INSN:\n+\t      /* Instructions affecting the condition codes make it fail.  */\n+\t      if (sets_cc0_p (scanbody))\n+\t\tfail = TRUE;\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      if (succeed)\n+\t{\n+\t  if (arm_ccfsm_state == 1 || reverse)\n+\t    arm_target_label = CODE_LABEL_NUMBER (label);\n+\t  else if (arm_ccfsm_state == 2)\n+\t    arm_target_insn = this_insn;\n+\t  else\n+\t    abort ();\n+\n+\t  /* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from what\n+\t     it was.  */\n+\t  if (!reverse)\n+\t    arm_current_cc = get_arm_condition_code (XEXP (SET_SRC (body), 0));\n+\t  if (reverse || then_not_else)\n+\t    arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n+\t}\n+    }\n+} /* final_prescan_insn */\n+\n+/* EOF */"}, {"sha": "810175ab3be2afe7c7b019b0a51fd48aff574f60", "filename": "gcc/config/tahoe/tahoe.c", "status": "added", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.c?ref=cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "patch": "@@ -0,0 +1,564 @@\n+/* Subroutines for insn-output.c for Tahoe.\n+   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+/*\n+ * File: output-tahoe.c\n+ *\n+ * Original port made at the University of Buffalo by Devon Bowen,\n+ * Dale Wiles and Kevin Zachmann.\n+ *\n+ * Changes for HCX by Piet van Oostrum,\n+ * University of Utrecht, The Netherlands (piet@cs.ruu.nl)\n+ *\n+ * Speed tweaks by Michael Tiemann (tiemann@lurch.stanford.edu).\n+ *\n+ * Mail bugs reports or fixes to:\tgcc@cs.buffalo.edu\n+ */\n+\n+\n+/* On tahoe, you have to go to memory to convert a register\n+   from sub-word to word.  */\n+\n+rtx tahoe_reg_conversion_loc;\n+\n+int\n+extendable_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if ((GET_CODE (op) == REG\n+       || (GET_CODE (op) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (op)) == REG))\n+      && tahoe_reg_conversion_loc == 0)\n+    tahoe_reg_conversion_loc = assign_stack_local (SImode, GET_MODE_SIZE (SImode));\n+  return general_operand (op, mode);\n+}\n+\n+/* most of the print_operand_address function was taken from the vax\t*/\n+/* since the modes are basically the same. I had to add a special case,\t*/\n+/* though, for symbol references with offsets.\t\t\t\t*/\n+\n+#include <stdio.h>\n+\n+print_operand_address (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  register rtx reg1, reg2, breg, ireg;\n+  rtx offset;\n+  static char *reg_name[] = REGISTER_NAMES;\n+\n+ retry:\n+  switch (GET_CODE (addr))\n+    {\n+    case MEM:\n+      fprintf (file, \"*\");\n+      addr = XEXP (addr, 0);\n+      goto retry;\n+\n+    case REG:\n+      fprintf (file, \"(%s)\", reg_name [REGNO (addr)]);\n+      break;\n+\n+    case PRE_DEC:\n+      fprintf (file, \"-(%s)\", reg_name [REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case POST_INC:\n+      fprintf (file, \"(%s)+\", reg_name [REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case PLUS:\n+      reg1 = 0;\treg2 = 0;\n+      ireg = 0;\tbreg = 0;\n+      offset = 0;\n+\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n+\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\toutput_addr_const (file, addr);\n+\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n+\t  && GET_CODE (XEXP (addr, 0)) == CONST_INT)\n+\toutput_addr_const (file, addr);\n+\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n+\t  || GET_CODE (XEXP (addr, 0)) == MEM)\n+\t{\n+\t  offset = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n+\t       || GET_CODE (XEXP (addr, 1)) == MEM)\n+\t{\n+\t  offset = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) != PLUS)\n+\t;\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)\n+\t{\n+\t  if (reg1 == 0)\n+\t    reg1 = addr;\n+\t  else\n+\t    reg2 = addr;\n+\t  addr = 0;\n+\t}\n+      if (offset != 0)\n+\t{\n+\t  if (addr != 0) abort ();\n+\t  addr = offset;\n+\t}\n+      if (reg1 != 0 && GET_CODE (reg1) == MULT)\n+\t{\n+\t  breg = reg2;\n+\t  ireg = reg1;\n+\t}\n+      else if (reg2 != 0 && GET_CODE (reg2) == MULT)\n+\t{\n+\t  breg = reg1;\n+\t  ireg = reg2;\n+\t}\n+      else if (reg2 != 0 || GET_CODE (addr) == MEM)\n+\t{\n+\t  breg = reg2;\n+\t  ireg = reg1;\n+\t}\n+      else\n+\t{\n+\t  breg = reg1;\n+\t  ireg = reg2;\n+\t}\n+      if (addr != 0)\n+\toutput_address (offset);\n+      if (breg != 0)\n+\t{\n+\t  if (GET_CODE (breg) != REG)\n+\t    abort ();\n+\t  fprintf (file, \"(%s)\", reg_name[REGNO (breg)]);\n+\t}\n+      if (ireg != 0)\n+\t{\n+\t  if (GET_CODE (ireg) == MULT)\n+\t    ireg = XEXP (ireg, 0);\n+\t  if (GET_CODE (ireg) != REG)\n+\t    abort ();\n+\t  fprintf (file, \"[%s]\", reg_name[REGNO (ireg)]);\n+\t}\n+      break;\n+\n+    default:\n+      output_addr_const (file, addr);\n+    }\n+}\n+\n+/* Do a quick check and find out what the best way to do the */\n+/* mini-move is. Could be a push or a move.....\t\t     */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (operands[1] == const0_rtx)\n+      return \"clrl %0\";\n+  if (push_operand (operands[0], SImode))\n+    return \"pushl %1\";\n+  return \"movl %1,%0\";\n+}\n+\n+/* given the rtx for an address, return true if the given */\n+/* register number is used in the address somewhere.\t  */\n+\n+regisused(addr,regnum)\n+rtx addr;\n+int regnum;\n+{\n+\tif (GET_CODE(addr) == REG)\n+\t\tif (REGNO(addr) == regnum)\n+\t\t\treturn (1);\n+\t\telse\n+\t\t\treturn (0);\n+\n+\tif (GET_CODE(addr) == MEM)\n+\t\treturn regisused(XEXP(addr,0),regnum);\n+\n+\tif ((GET_CODE(addr) == MULT) || (GET_CODE(addr) == PLUS))\n+\t\treturn ((regisused(XEXP(addr,0),regnum)) ||\n+\t\t\t\t\t(regisused(XEXP(addr,1),regnum)));\n+\n+\treturn 0;\n+}\n+\n+\n+/* Given some rtx, traverse it and return the register used in a */\n+/* index. If no index is found, return 0.\t\t\t */\n+\n+rtx\n+index_reg(addr)\n+rtx addr;\n+{\n+\trtx temp;\n+\n+\tif (GET_CODE(addr) == MEM)\n+\t\treturn index_reg(XEXP(addr,0));\n+\n+\tif (GET_CODE(addr) == MULT)\n+\t\tif (GET_CODE(XEXP(addr,0)) == REG)\n+\t\t\treturn XEXP(addr,0);\n+\t\telse\n+\t\t\treturn XEXP(addr,1);\n+\n+\tif (GET_CODE(addr) == PLUS)\n+\t\tif (temp = index_reg(XEXP(addr,0)))\n+\t\t\treturn temp;\n+\t\telse\n+\t\t\treturn index_reg(XEXP(addr,1));\n+\n+\treturn 0;\n+}\n+\n+\n+/* simulate the move double by generating two movl's. You have */\n+/* to be careful about mixing modes here.\t\t       */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, INDOP, CNSTOP, RNDOP }\n+    optype0, optype1;\n+  rtx latehalf[2];\n+  rtx shftreg0 = 0, shftreg1 = 0;\n+  rtx temp0 = 0, temp1 = 0;\n+  rtx addreg0 = 0, addreg1 = 0;\n+  int dohighfirst = 0;\n+\n+  /* First classify both operands. */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if ((GET_CODE(operands[0])==MEM) && (shftreg0=index_reg(operands[0])))\n+    optype0 = INDOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC) {\n+    optype0 = PUSHOP;\n+    dohighfirst++;\n+  } else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if ((GET_CODE(operands[1])==MEM) && (shftreg1=index_reg(operands[1])))\n+    optype1 = INDOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    optype1 = POPOP; \n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* set up for the high byte move for operand zero */\n+\n+  switch (optype0) {\n+\n+\t/* if it's a register, just use the next highest in the */\n+\t/* high address move.\t\t\t\t\t*/\n+\n+\tcase REGOP  : latehalf[0] = gen_rtx (REG,SImode,REGNO(operands[0])+1);\n+\t\t      break;\n+\n+\t/* for an offsettable address, use the gcc function to  */\n+\t/* modify the operand to get an offset of 4 higher for  */\n+\t/* the second move.\t\t\t\t\t*/\n+\n+\tcase OFFSOP : latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+\t\t      break;\n+\n+\t/* if the operand is MEMOP type, it must be a pointer\t*/\n+\t/* to a pointer. So just remember to increase the mem\t*/\n+\t/* location and use the same operand.\t\t\t*/\n+\n+\tcase MEMOP  : latehalf[0] = operands[0];\n+\t\t      addreg0 = XEXP(operands[0],0);\n+\t\t      break;\n+\n+\t/* if we're dealing with a push instruction, just leave */\n+\t/* the operand alone since it auto-increments.\t\t*/\n+\n+\tcase PUSHOP : latehalf[0] = operands[0];\n+\t\t      break;\n+\n+\t/* YUCK! Indexed addressing!! If the address is considered   */\n+\t/* offsettable, go use the offset in the high part. Otherwise */\n+\t/* find what exactly is being added to the multiplication. If */\n+\t/* it's a mem reference, increment that with the high part   */\n+\t/* being unchanged to cause the shift. If it's a reg, do the */\n+\t/* same. If you can't identify it, abort. Remember that the  */\n+\t/* shift register was already set during identification.     */\n+\n+\tcase INDOP  : if (offsettable_memref_p(operands[0])) {\n+\t\t\t   latehalf[0] = adj_offsettable_operand(operands[0],4);\n+\t\t\t   break;\n+\t\t      }\n+\n+\t\t      latehalf[0] = operands[0];\n+\n+\t\t      temp0 = XEXP(XEXP(operands[0],0),0);\n+                      if (GET_CODE(temp0) == MULT) {\n+\t\t\t   temp1 = temp0;\n+\t\t\t   temp0 = XEXP(XEXP(operands[0],0),1);\n+\t\t      } else {\n+\t\t\t   temp1 = XEXP(XEXP(operands[0],0),1);\n+\t\t\t   if (GET_CODE(temp1) != MULT)\n+\t\t\t\tabort();\n+\t\t      }\n+\n+\t\t      if (GET_CODE(temp0) == MEM)\n+\t\t\t   addreg0 = temp0;\n+\t\t      else if (GET_CODE(temp0) == REG)\n+\t\t\t   addreg0 = temp0;\n+\t\t      else\n+\t\t\t   abort();\n+\n+\t\t      break;\n+\n+\t/* if we don't know the operand type, print a friendly  */\n+\t/* little error message...   8-)\t\t\t*/\n+\n+\tcase RNDOP  :\n+\tdefault     : abort();\n+  }\n+\n+  /* do the same setup for operand one */\n+\n+  switch (optype1) {\n+\n+\tcase REGOP  : latehalf[1] = gen_rtx(REG,SImode,REGNO(operands[1])+1);\n+\t\t      break;\n+\n+\tcase OFFSOP : latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+\t\t      break;\n+\n+\tcase MEMOP  : latehalf[1] = operands[1];\n+\t\t      addreg1 = XEXP(operands[1],0);\n+\t\t      break;\n+\n+\tcase POPOP  : latehalf[1] = operands[1];\n+\t\t      break;\n+\n+\tcase INDOP  : if (offsettable_memref_p(operands[1])) {\n+\t\t\t   latehalf[1] = adj_offsettable_operand(operands[1],4);\n+\t\t\t   break;\n+\t\t      }\n+\n+\t\t      latehalf[1] = operands[1];\n+\n+\t\t      temp0 = XEXP(XEXP(operands[1],0),0);\n+                      if (GET_CODE(temp0) == MULT) {\n+\t\t\t   temp1 = temp0;\n+\t\t\t   temp0 = XEXP(XEXP(operands[1],0),1);\n+\t\t      } else {\n+\t\t\t   temp1 = XEXP(XEXP(operands[1],0),1);\n+\t\t\t   if (GET_CODE(temp1) != MULT)\n+\t\t\t\tabort();\n+\t\t      }\n+\n+\t\t      if (GET_CODE(temp0) == MEM)\n+\t\t\t   addreg1 = temp0;\n+\t\t      else if (GET_CODE(temp0) == REG)\n+\t\t\t   addreg1 = temp0;\n+\t\t      else\n+\t\t\t   abort();\n+\n+\t\t      break;\n+\n+\tcase CNSTOP :\n+\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    split_double (operands[1], &operands[1], &latehalf[1]);\n+\t  else if (CONSTANT_P (operands[1]))\n+\t    latehalf[1] = const0_rtx;\n+\t  else abort ();\n+\t  break;\n+\n+\tcase RNDOP  :\n+\tdefault     : abort();\n+  }\n+\n+\n+  /* double the register used for shifting in both of the operands */\n+  /* but make sure the same register isn't doubled twice!\t   */\n+\n+  if (shftreg0 && shftreg1 && (rtx_equal_p(shftreg0,shftreg1)))\n+\toutput_asm_insn(\"addl2 %0,%0\", &shftreg0);\n+  else {\n+\tif (shftreg0)\n+\t\toutput_asm_insn(\"addl2 %0,%0\", &shftreg0);\n+\tif (shftreg1)\n+\t\toutput_asm_insn(\"addl2 %0,%0\", &shftreg1);\n+  }\n+\n+  /* if the destination is a register and that register is needed in  */\n+  /* the source addressing mode, swap the order of the moves since we */\n+  /* don't want this destroyed til last. If both regs are used, not   */\n+  /* much we can do, so abort. If these becomes a problem, maybe we   */\n+  /* can do it on the stack?\t\t\t\t\t      */\n+\n+  if (GET_CODE(operands[0])==REG && regisused(operands[1],REGNO(operands[0])))\n+\tif (regisused(latehalf[1],REGNO(latehalf[0])))\n+\t\t8;\n+\telse\n+\t\tdohighfirst++;\n+\n+  /* if we're pushing, do the high address part first. */\n+\n+  if (dohighfirst) {\n+\n+\tif (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n+\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n+\telse {\n+\t\tif (addreg0)\n+\t\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n+\t\tif (addreg1)\n+\t\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg1);\n+\t}\n+\n+\toutput_asm_insn(singlemove_string(latehalf), latehalf);\n+\n+\tif (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n+\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n+\telse {\n+\t\tif (addreg0)\n+\t\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n+\t\tif (addreg1)\n+\t\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg1);\n+\t}\n+\n+\treturn singlemove_string(operands);\n+  }\n+\n+  output_asm_insn(singlemove_string(operands), operands);\n+\n+  if (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n+\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n+  else {\n+\tif (addreg0)\n+\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n+\tif (addreg1)\n+\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg1);\n+  }\n+\n+  output_asm_insn(singlemove_string(latehalf), latehalf);\n+\n+  if (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n+\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n+  else {\n+\tif (addreg0)\n+\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n+\tif (addreg1)\n+\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg1);\n+  }\n+\n+  if (shftreg0 && shftreg1 && (rtx_equal_p(shftreg0,shftreg1)))\n+\toutput_asm_insn(\"shar $1,%0,%0\", &shftreg0);\n+  else {\n+\tif (shftreg0)\n+\t\toutput_asm_insn(\"shar $1,%0,%0\", &shftreg0);\n+\tif (shftreg1)\n+\t\toutput_asm_insn(\"shar $1,%0,%0\", &shftreg1);\n+  }\n+\n+  return \"\";\n+}\n+\n+\n+/* This checks if a zero_extended cmp[bw] can be replaced by a sign_extended\n+   cmp[bw]. This can be done if the operand is a constant that fits in a\n+   byte/word or a memory operand. Besides that the next instruction must be an\n+   unsigned compare. Some of these tests are done by the machine description */\n+\n+int\n+tahoe_cmp_check (insn, op, max)\n+rtx insn, op; int max;\n+{\n+    if (GET_CODE (op) == CONST_INT\n+\t&& ( INTVAL (op) < 0 || INTVAL (op) > max ))\n+\treturn 0;\n+    {\n+\tregister rtx next = NEXT_INSN (insn);\n+\n+\tif ((GET_CODE (next) == JUMP_INSN\n+\t   || GET_CODE (next) == INSN\n+\t   || GET_CODE (next) == CALL_INSN))\n+\t    {\n+\t\tnext = PATTERN (next);\n+\t\tif (GET_CODE (next) == SET\n+\t\t    && SET_DEST (next) == pc_rtx\n+\t\t    && GET_CODE (SET_SRC (next)) == IF_THEN_ELSE)\n+\t\t    switch (GET_CODE (XEXP (SET_SRC (next), 0)))\n+\t\t\t{\n+\t\t\tcase EQ:\n+\t\t\tcase NE:\n+\t\t\tcase LTU:\n+\t\t\tcase GTU:\n+\t\t\tcase LEU:\n+\t\t\tcase GEU:\n+\t\t\t    return 1;\n+\t\t\t}\n+\t    }\n+    }\n+    return 0;\n+}"}, {"sha": "a5f06e94de5d2e4e220a78ba64c425a8050fd5b3", "filename": "gcc/config/tahoe/xm-tahoe.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fconfig%2Ftahoe%2Fxm-tahoe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fconfig%2Ftahoe%2Fxm-tahoe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Fxm-tahoe.h?ref=cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "patch": "@@ -0,0 +1,63 @@\n+/* Configuration for GNU C-compiler for Tahoe.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/*\n+ * File: xm-tahoe.h\n+ *\n+ * Original port made at the University of Buffalo by Devon Bowen,\n+ * Dale Wiles and Kevin Zachmann.\n+ *\n+ * Changes for HCX by Piet van Oostrum,\n+ * University of Utrecht, The Netherlands (piet@cs.ruu.nl)\n+ *\n+ * Mail bugs reports or fixes to:\tgcc@cs.buffalo.edu\n+ */\n+\n+\n+/* This file has the same stuff the vax version does */\n+\n+/* defines that need visibility everywhere */\n+\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* target machine dependencies\n+   tm.h is a symbolic link to the actual target specific file.   */\n+\n+#include \"tm.h\"\n+\n+/* This describes the machine the compiler is hosted on.  */\n+\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+#define HOST_WORDS_BIG_ENDIAN\n+\n+/* Arguments to use with `exit'.  */\n+\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* If compiled with GNU C, use the built-in alloca */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#endif"}, {"sha": "47d7740fb64fc9c4ade6f7ad4b927fdcda77d1fc", "filename": "gcc/stupid.c", "status": "added", "additions": 544, "deletions": 0, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "patch": "@@ -0,0 +1,544 @@\n+/* Dummy data flow analysis for GNU compiler in nonoptimizing mode.\n+   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file performs stupid register allocation, which is used\n+   when cc1 gets the -noreg switch (which is when cc does not get -O).\n+\n+   Stupid register allocation goes in place of the the flow_analysis,\n+   local_alloc and global_alloc passes.  combine_instructions cannot\n+   be done with stupid allocation because the data flow info that it needs\n+   is not computed here.\n+\n+   In stupid allocation, the only user-defined variables that can\n+   go in registers are those declared \"register\".  They are assumed\n+   to have a life span equal to their scope.  Other user variables\n+   are given stack slots in the rtl-generation pass and are not\n+   represented as pseudo regs.  A compiler-generated temporary\n+   is assumed to live from its first mention to its last mention.\n+\n+   Since each pseudo-reg's life span is just an interval, it can be\n+   represented as a pair of numbers, each of which identifies an insn by\n+   its position in the function (number of insns before it).  The first\n+   thing done for stupid allocation is to compute such a number for each\n+   insn.  It is called the suid.  Then the life-interval of each\n+   pseudo reg is computed.  Then the pseudo regs are ordered by priority\n+   and assigned hard regs in priority order.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"regs.h\"\n+#include \"flags.h\"\n+\f\n+/* Vector mapping INSN_UIDs to suids.\n+   The suids are like uids but increase monotonically always.\n+   We use them to see whether a subroutine call came\n+   between a variable's birth and its death.  */\n+\n+static int *uid_suid;\n+\n+/* Get the suid of an insn.  */\n+\n+#define INSN_SUID(INSN) (uid_suid[INSN_UID (INSN)])\n+\n+/* Record the suid of the last CALL_INSN\n+   so we can tell whether a pseudo reg crosses any calls.  */\n+\n+static int last_call_suid;\n+\n+/* Record the suid of the last JUMP_INSN\n+   so we can tell whether a pseudo reg crosses any jumps.  */\n+\n+static int last_jump_suid;\n+\n+/* Record the suid of the last CODE_LABEL\n+   so we can tell whether a pseudo reg crosses any labels.  */\n+\n+static int last_label_suid;\n+\n+/* Element N is suid of insn where life span of pseudo reg N ends.\n+   Element is  0 if register N has not been seen yet on backward scan.  */\n+\n+static int *reg_where_dead;\n+\n+/* Element N is suid of insn where life span of pseudo reg N begins.  */\n+\n+static int *reg_where_born;\n+\n+/* Element N is 1 if pseudo reg N lives across labels or jumps.  */\n+\n+static char *reg_crosses_blocks;\n+\n+/* Numbers of pseudo-regs to be allocated, highest priority first.  */\n+\n+static int *reg_order;\n+\n+/* Indexed by reg number (hard or pseudo), nonzero if register is live\n+   at the current point in the instruction stream.  */\n+\n+static char *regs_live;\n+\n+/* Indexed by insn's suid, the set of hard regs live after that insn.  */\n+\n+static HARD_REG_SET *after_insn_hard_regs;\n+\n+/* Record that hard reg REGNO is live after insn INSN.  */\n+\n+#define MARK_LIVE_AFTER(INSN,REGNO)  \\\n+  SET_HARD_REG_BIT (after_insn_hard_regs[INSN_SUID (INSN)], (REGNO))\n+\n+static void stupid_mark_refs ();\n+static int stupid_reg_compare ();\n+static int stupid_find_reg ();\n+\f\n+/* Stupid life analysis is for the case where only variables declared\n+   `register' go in registers.  For this case, we mark all\n+   pseudo-registers that belong to register variables as\n+   dying in the last instruction of the function, and all other\n+   pseudo registers as dying in the last place they are referenced.\n+   Hard registers are marked as dying in the last reference before\n+   the end or before each store into them.  */\n+\n+void\n+stupid_life_analysis (f, nregs, file)\n+     rtx f;\n+     int nregs;\n+     FILE *file;\n+{\n+  register int i;\n+  register rtx last, insn;\n+  int max_uid;\n+\n+  bzero (regs_ever_live, sizeof regs_ever_live);\n+\n+  regs_live = (char *) alloca (nregs);\n+\n+  /* First find the last real insn, and count the number of insns,\n+     and assign insns their suids.  */\n+\n+  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n+    if (INSN_UID (insn) > i)\n+      i = INSN_UID (insn);\n+\n+  max_uid = i + 1;\n+  uid_suid = (int *) alloca ((i + 1) * sizeof (int));\n+\n+  /* Compute the mapping from uids to suids.\n+     Suids are numbers assigned to insns, like uids,\n+     except that suids increase monotonically through the code.  */\n+\n+  last = 0;\t\t\t/* In case of empty function body */\n+  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n+\t  || GET_CODE (insn) == JUMP_INSN)\n+\tlast = insn;\n+      INSN_SUID (insn) = ++i;\n+    }\n+\n+  last_call_suid = i + 1;\n+  last_jump_suid = i + 1;\n+  last_label_suid = i + 1;\n+\n+  max_regno = nregs;\n+\n+  /* Allocate tables to record info about regs.  */\n+\n+  reg_where_dead = (int *) alloca (nregs * sizeof (int));\n+  bzero (reg_where_dead, nregs * sizeof (int));\n+\n+  reg_where_born = (int *) alloca (nregs * sizeof (int));\n+  bzero (reg_where_born, nregs * sizeof (int));\n+\n+  reg_crosses_blocks = (char *) alloca (nregs);\n+  bzero (reg_crosses_blocks, nregs);\n+\n+  reg_order = (int *) alloca (nregs * sizeof (int));\n+  bzero (reg_order, nregs * sizeof (int));\n+\n+  reg_renumber = (short *) oballoc (nregs * sizeof (short));\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    reg_renumber[i] = i;\n+\n+  for (i = FIRST_VIRTUAL_REGISTER; i <= LAST_VIRTUAL_REGISTER; i++)\n+    reg_renumber[i] = -1;\n+\n+  after_insn_hard_regs = (HARD_REG_SET *) alloca (max_uid * sizeof (HARD_REG_SET));\n+  bzero (after_insn_hard_regs, max_uid * sizeof (HARD_REG_SET));\n+\n+  /* Allocate and zero out many data structures\n+     that will record the data from lifetime analysis.  */\n+\n+  allocate_for_life_analysis ();\n+\n+  for (i = 0; i < max_regno; i++)\n+    {\n+      reg_n_deaths[i] = 1;\n+    }\n+\n+  bzero (regs_live, nregs);\n+\n+  /* Find where each pseudo register is born and dies,\n+     by scanning all insns from the end to the start\n+     and noting all mentions of the registers.\n+\n+     Also find where each hard register is live\n+     and record that info in after_insn_hard_regs.\n+     regs_live[I] is 1 if hard reg I is live\n+     at the current point in the scan.  */\n+\n+  for (insn = last; insn; insn = PREV_INSN (insn))\n+    {\n+      register HARD_REG_SET *p = after_insn_hard_regs + INSN_SUID (insn);\n+\n+      /* Copy the info in regs_live\n+\t into the element of after_insn_hard_regs\n+\t for the current position in the rtl code.  */\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (regs_live[i])\n+\t  SET_HARD_REG_BIT (*p, i);\n+\n+      /* Mark all call-clobbered regs as live after each call insn\n+\t so that a pseudo whose life span includes this insn\n+\t will not go in one of them.\n+\t Then mark those regs as all dead for the continuing scan\n+\t of the insns before the call.  */\n+\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  last_call_suid = INSN_SUID (insn);\n+\t  IOR_HARD_REG_SET (after_insn_hard_regs[last_call_suid],\n+\t\t\t    call_used_reg_set);\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (call_used_regs[i])\n+\t      regs_live[i] = 0;\n+\t}\n+\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\tlast_jump_suid = INSN_SUID (insn);\n+\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tlast_label_suid = INSN_SUID (insn);\n+\n+      /* Update which hard regs are currently live\n+\t and also the birth and death suids of pseudo regs\n+\t based on the pattern of this insn.  */\n+\n+      if (GET_CODE (insn) == INSN\n+\t  || GET_CODE (insn) == CALL_INSN\n+\t  || GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  stupid_mark_refs (PATTERN (insn), insn);\n+\t}\n+    }\n+\n+  /* Now decide the order in which to allocate the pseudo registers.  */\n+\n+  for (i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n+    reg_order[i] = i;\n+\n+  qsort (&reg_order[LAST_VIRTUAL_REGISTER + 1],\n+\t max_regno - LAST_VIRTUAL_REGISTER - 1, sizeof (int),\n+\t stupid_reg_compare);\n+\n+  /* Now, in that order, try to find hard registers for those pseudo regs.  */\n+\n+  for (i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n+    {\n+      register int r = reg_order[i];\n+      enum reg_class class;\n+\n+      /* Some regnos disappear from the rtl.  Ignore them to avoid crash.  */\n+      if (regno_reg_rtx[r] == 0)\n+\tcontinue;\n+\n+      /* Now find the best hard-register class for this pseudo register */\n+      if (N_REG_CLASSES > 1)\n+\t{\n+\t  class = reg_preferred_class (r);\n+\n+\t  reg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r], class,\n+\t\t\t\t\t     PSEUDO_REGNO_MODE (r),\n+\t\t\t\t\t     reg_where_born[r],\n+\t\t\t\t\t     reg_where_dead[r],\n+\t\t\t\t\t     reg_crosses_blocks[r]);\n+\t}\n+      else\n+\treg_renumber[r] = -1;\n+\n+      /* If no reg available in that class,\n+\t try any reg.  */\n+      if (reg_renumber[r] == -1)\n+\treg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r],\n+\t\t\t\t\t   GENERAL_REGS,\n+\t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n+\t\t\t\t\t   reg_where_born[r],\n+\t\t\t\t\t   reg_where_dead[r],\n+\t\t\t\t\t   reg_crosses_blocks[r]);\n+    }\n+\n+  if (file)\n+    dump_flow_info (file);\n+}\n+\n+/* Comparison function for qsort.\n+   Returns -1 (1) if register *R1P is higher priority than *R2P.  */\n+\n+static int\n+stupid_reg_compare (r1p, r2p)\n+     int *r1p, *r2p;\n+{\n+  register int r1 = *r1p, r2 = *r2p;\n+  register int len1 = reg_where_dead[r1] - reg_where_born[r1];\n+  register int len2 = reg_where_dead[r2] - reg_where_born[r2];\n+  int tem;\n+\n+  tem = len2 - len1;\n+  if (tem != 0) return tem;\n+\n+  tem = reg_n_refs[r1] - reg_n_refs[r2];\n+  if (tem != 0) return tem;\n+\n+  /* If regs are equally good, sort by regno,\n+     so that the results of qsort leave nothing to chance.  */\n+  return r1 - r2;\n+}\n+\f\n+/* Find a block of SIZE words of hard registers in reg_class CLASS\n+   that can hold a value of machine-mode MODE\n+     (but actually we test only the first of the block for holding MODE)\n+   currently free from after insn whose suid is BIRTH\n+   through the insn whose suid is DEATH,\n+   and return the number of the first of them.\n+   Return -1 if such a block cannot be found.\n+\n+   If CALL_PRESERVED is nonzero, insist on registers preserved\n+   over subroutine calls, and return -1 if cannot find such.\n+   If CROSSES_BLOCKS is nonzero, reject registers for which\n+   PRESERVE_DEATH_INFO_REGNO_P is true.  */\n+\n+static int\n+stupid_find_reg (call_preserved, class, mode,\n+\t\t born_insn, dead_insn, crosses_blocks)\n+     int call_preserved;\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     int born_insn, dead_insn;\n+     int crosses_blocks;\n+{\n+  register int i, ins;\n+#ifdef HARD_REG_SET\n+  register\t\t/* Declare them register if they are scalars.  */\n+#endif\n+    HARD_REG_SET used, this_reg;\n+#ifdef ELIMINABLE_REGS\n+  static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n+#endif\n+\n+  COPY_HARD_REG_SET (used,\n+\t\t     call_preserved ? call_used_reg_set : fixed_reg_set);\n+\n+#ifdef ELIMINABLE_REGS\n+  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+    SET_HARD_REG_BIT (used, eliminables[i].from);\n+#else\n+  SET_HARD_REG_BIT (used, FRAME_POINTER_REGNUM);\n+#endif\n+\n+  for (ins = born_insn; ins < dead_insn; ins++)\n+    IOR_HARD_REG_SET (used, after_insn_hard_regs[ins]);\n+\n+  IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) class]);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+#ifdef REG_ALLOC_ORDER\n+      int regno = reg_alloc_order[i];\n+#else\n+      int regno = i;\n+#endif\n+\n+      /* If we need reasonable death info on this hard reg,\n+\t don't use it for anything whose life spans a label or a jump.  */\n+#ifdef PRESERVE_DEATH_INFO_REGNO_P\n+      if (PRESERVE_DEATH_INFO_REGNO_P (regno)\n+\t  && crosses_blocks)\n+\tcontinue;\n+#endif\n+      /* If a register has screwy overlap problems,\n+\t don't use it at all if not optimizing.\n+\t Actually this is only for the 387 stack register,\n+\t and it's because subsequent code won't work.  */\n+#ifdef OVERLAPPING_REGNO_P\n+      if (OVERLAPPING_REGNO_P (regno))\n+\tcontinue;\n+#endif\n+\n+      if (! TEST_HARD_REG_BIT (used, regno)\n+\t  && HARD_REGNO_MODE_OK (regno, mode))\n+\t{\n+\t  register int j;\n+\t  register int size1 = HARD_REGNO_NREGS (regno, mode);\n+\t  for (j = 1; j < size1 && ! TEST_HARD_REG_BIT (used, regno + j); j++);\n+\t  if (j == size1)\n+\t    {\n+\t      CLEAR_HARD_REG_SET (this_reg);\n+\t      while (--j >= 0)\n+\t\tSET_HARD_REG_BIT (this_reg, regno + j);\n+\t      for (ins = born_insn; ins < dead_insn; ins++)\n+\t\t{\n+\t\t  IOR_HARD_REG_SET (after_insn_hard_regs[ins], this_reg);\n+\t\t}\n+\t      return regno;\n+\t    }\n+#ifndef REG_ALLOC_ORDER\n+\t  i += j;\t\t\t/* Skip starting points we know will lose */\n+#endif\n+\t}\n+    }\n+  return -1;\n+}\n+\f\n+/* Walk X, noting all assignments and references to registers\n+   and recording what they imply about life spans.\n+   INSN is the current insn, supplied so we can find its suid.  */\n+\n+static void\n+stupid_mark_refs (x, insn)\n+     rtx x, insn;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  register char *fmt;\n+  register int regno, i;\n+\n+  if (code == SET || code == CLOBBER)\n+    {\n+      if (SET_DEST (x) != 0 && GET_CODE (SET_DEST (x)) == REG)\n+\t{\n+\t  /* Register is being assigned.  */\n+\t  regno = REGNO (SET_DEST (x));\n+\n+\t  /* For hard regs, update the where-live info.  */\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      register int j\n+\t\t= HARD_REGNO_NREGS (regno, GET_MODE (SET_DEST (x)));\n+\t      while (--j >= 0)\n+\t\t{\n+\t\t  regs_ever_live[regno+j] = 1;\n+\t\t  regs_live[regno+j] = 0;\n+\t\t  /* The following line is for unused outputs;\n+\t\t     they do get stored even though never used again.  */\n+\t\t  MARK_LIVE_AFTER (insn, regno);\n+\t\t  /* When a hard reg is clobbered, mark it in use\n+\t\t     just before this insn, so it is live all through.  */\n+\t\t  if (code == CLOBBER && INSN_SUID (insn) > 0)\n+\t\t    SET_HARD_REG_BIT (after_insn_hard_regs[INSN_SUID (insn) - 1],\n+\t\t\t\t      regno);\n+\t\t}\n+\t    }\n+\t  /* For pseudo regs, record where born, where dead, number of\n+\t     times used, and whether live across a call.  */\n+\t  else\n+\t    {\n+\t      /* Update the life-interval bounds of this pseudo reg.  */\n+\n+\t      /* When a pseudo-reg is CLOBBERed, it is born just before\n+\t\t the clobbering insn.  When setting, just after.  */\n+\t      int where_born = INSN_SUID (insn) - (code == CLOBBER);\n+\n+\t      reg_where_born[regno] = where_born;\n+\t      /* The reg must live at least one insn even\n+\t\t in it is never again used--because it has to go\n+\t\t in SOME hard reg.  Mark it as dying after the current\n+\t\t insn so that it will conflict with any other outputs of\n+\t\t this insn.  */\n+\t      if (reg_where_dead[regno] < where_born + 2)\n+\t\treg_where_dead[regno] = where_born + 2;\n+\n+\t      /* Count the refs of this reg.  */\n+\t      reg_n_refs[regno]++;\n+\n+\t      if (last_call_suid < reg_where_dead[regno])\n+\t\treg_n_calls_crossed[regno] += 1;\n+\t      if (last_jump_suid < reg_where_dead[regno]\n+\t\t  || last_label_suid < reg_where_dead[regno])\n+\t\treg_crosses_blocks[regno] = 1;\n+\t    }\n+\t}\n+      /* Record references from the value being set,\n+\t or from addresses in the place being set if that's not a reg.\n+\t If setting a SUBREG, we treat the entire reg as *used*.  */\n+      if (code == SET)\n+\t{\n+\t  stupid_mark_refs (SET_SRC (x), insn);\n+\t  if (GET_CODE (SET_DEST (x)) != REG)\n+\t    stupid_mark_refs (SET_DEST (x), insn);\n+\t}\n+      return;\n+    }\n+\n+  /* Register value being used, not set.  */\n+\n+  if (code == REG)\n+    {\n+      regno = REGNO (x);\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  /* Hard reg: mark it live for continuing scan of previous insns.  */\n+\t  register int j = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t  while (--j >= 0)\n+\t    {\n+\t      regs_ever_live[regno+j] = 1;\n+\t      regs_live[regno+j] = 1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Pseudo reg: record first use, last use and number of uses.  */\n+\n+\t  reg_where_born[regno] = INSN_SUID (insn);\n+\t  reg_n_refs[regno]++;\n+\t  if (regs_live[regno] == 0)\n+\t    {\n+\t      regs_live[regno] = 1;\n+\t      reg_where_dead[regno] = INSN_SUID (insn);\n+\t    }\n+\t}\n+      return;\n+    }\n+\n+  /* Recursive scan of all other rtx's.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tstupid_mark_refs (XEXP (x, i), insn);\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    stupid_mark_refs (XVECEXP (x, i, j), insn);\n+\t}\n+    }\n+}"}]}