{"sha": "a5e6b29b07b0971b9a8a49d65d342407deef89c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlNmIyOWIwN2IwOTcxYjlhOGE0OWQ2NWQzNDI0MDdkZWVmODljNQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-10-14T20:34:41Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-10-14T20:34:41Z"}, "message": "Breack out decl.c (3/n)\n\n\tBreack out decl.c (3/n)\n\t* name-lookup.c: Include flags.h\n\t(lookup_name_current_level): Make static.\n\t(add_decl_to_level): Likewise.\n\t(push_local_binding): Likewise.\n\t(push_overloaded_decl): Likewise.\n\t(lookup_using_namespace): Likewise.\n\t(qualified_lookup_using_namespace): Likewise.\n\t(lookup_type_current_level): Likewise.\n\t(unqualified_namespace_lookup): Likewise.\n\t(namespace_ancestor): Likewise.\n\t(push_using_directive): Likewise.\n\t* decl.c (pushdecl): Move to name-lookup.c.\n\t(pushdecl_top_level_1): Likewise.\n\t(pushdecl_top_level): Likewise.\n\t(pushdecl_top_level_and_finish): Likewise.\n\t(maybe_push_decl): Likewise.\n\t(push_using_decl): Likewise.\n\t(push_overloaded_decl): Likewise.\n\t(make_anon_name): Likewise.\n\t(anon_cnt): Likewise.\n\t(clear_anon_tags): Likewise.\n\t(maybe_inject_for_scope_var): Likewise.\n\t(check_for_out_of_scope_variable): Likewise.\n\t* Make-lang.in (cp/name-lookup.o): Depend on flags.h.\n\t* decl.c (warn_extern_redeclared_static): Export.\n\t* cp-tree.h (warn_extern_redeclared_static): Declare.\n\nFrom-SVN: r72492", "tree": {"sha": "7702e6868d44b1748368cc92f84ceb0e7c0f98e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7702e6868d44b1748368cc92f84ceb0e7c0f98e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5e6b29b07b0971b9a8a49d65d342407deef89c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e6b29b07b0971b9a8a49d65d342407deef89c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5e6b29b07b0971b9a8a49d65d342407deef89c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e6b29b07b0971b9a8a49d65d342407deef89c5/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7f86e619d6fc887bdab16a04a6fce0615b41c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f86e619d6fc887bdab16a04a6fce0615b41c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f86e619d6fc887bdab16a04a6fce0615b41c6b"}], "stats": {"total": 1712, "additions": 871, "deletions": 841}, "files": [{"sha": "2cb90015f109fda6cc03e3b534eb6659d2731899", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a5e6b29b07b0971b9a8a49d65d342407deef89c5", "patch": "@@ -1,3 +1,33 @@\n+2003-10-14  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tBreack out decl.c (3/n)\n+\t* name-lookup.c: Include flags.h\n+\t(lookup_name_current_level): Make static.\n+\t(add_decl_to_level): Likewise.\n+\t(push_local_binding): Likewise.\n+\t(push_overloaded_decl): Likewise.\n+\t(lookup_using_namespace): Likewise.\n+\t(qualified_lookup_using_namespace): Likewise.\n+\t(lookup_type_current_level): Likewise.\n+\t(unqualified_namespace_lookup): Likewise.\n+\t(namespace_ancestor): Likewise.\n+\t(push_using_directive): Likewise.\n+\t* decl.c (pushdecl): Move to name-lookup.c.\n+\t(pushdecl_top_level_1): Likewise.\n+\t(pushdecl_top_level): Likewise.\n+\t(pushdecl_top_level_and_finish): Likewise.\n+\t(maybe_push_decl): Likewise.\n+\t(push_using_decl): Likewise.\n+\t(push_overloaded_decl): Likewise.\n+\t(make_anon_name): Likewise.\n+\t(anon_cnt): Likewise.\n+\t(clear_anon_tags): Likewise.\n+\t(maybe_inject_for_scope_var): Likewise.\n+\t(check_for_out_of_scope_variable): Likewise.\n+\t* Make-lang.in (cp/name-lookup.o): Depend on flags.h.\n+\t* decl.c (warn_extern_redeclared_static): Export.\n+\t* cp-tree.h (warn_extern_redeclared_static): Declare.\n+\n 2003-10-14  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* Make-lang.in: Replace uses of $(target_alias) with"}, {"sha": "b36627fb50c4d9a275999f608e311b86b041c991", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=a5e6b29b07b0971b9a8a49d65d342407deef89c5", "patch": "@@ -280,7 +280,7 @@ cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) diagnostic.h gt-cp-parser.h outpu\n \n cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TM_H) $(CXX_TREE_H) timevar.h gt-cp-name-lookup.h toplev.h \\\n-\t$(DIAGNOSTIC_H)\n+\t$(DIAGNOSTIC_H) flags.h\n \n cp/cxx-pretty-print.o: cp/cxx-pretty-print.c $(CXX_PRETTY_PRINT_H) \\\n   $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h $(CXX_TREE_H)"}, {"sha": "4bc82d266cb5bb787213ae172d58fe844c6765dc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a5e6b29b07b0971b9a8a49d65d342407deef89c5", "patch": "@@ -3662,7 +3662,6 @@ extern void fixup_anonymous_aggr                (tree);\n extern int check_static_variable_definition     (tree, tree);\n extern tree compute_array_index_type\t\t(tree, tree);\n extern tree check_default_argument              (tree, tree);\n-extern tree push_overloaded_decl\t\t(tree, int);\n extern int vtable_decl_p                        (tree, void *);\n extern int vtype_decl_p                         (tree, void *);\n extern int sigtable_decl_p                      (tree, void *);\n@@ -3685,6 +3684,7 @@ extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n extern tree cp_fname_init\t\t\t(const char *);\n extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n extern tree cxx_builtin_type_decls              (void);\n+extern void warn_extern_redeclared_static (tree, tree);\n \n extern bool have_extern_spec;\n extern GTY(()) tree last_function_parms;"}, {"sha": "7b0f86847a01aeed2ef4dfc5cdc1d7f9f62beb90", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 821, "changes": 822, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a5e6b29b07b0971b9a8a49d65d342407deef89c5", "patch": "@@ -60,7 +60,6 @@ static void require_complete_types_for_parms (tree);\n static int ambi_op_p (enum tree_code);\n static int unary_op_p (enum tree_code);\n static void push_local_name (tree);\n-static void warn_extern_redeclared_static (tree, tree);\n static tree grok_reference_init (tree, tree, tree, tree *);\n static tree grokfndecl (tree, tree, tree, tree, int,\n \t\t\tenum overload_flags, tree,\n@@ -987,43 +986,6 @@ push_local_name (tree decl)\n   VARRAY_PUSH_TREE (local_names, decl);\n   timevar_pop (TV_NAME_LOOKUP);\n }\n-\n-/* Counter used to create anonymous type names.  */\n-\n-static GTY(()) int anon_cnt;\n-\n-/* Return an IDENTIFIER which can be used as a name for\n-   anonymous structs and unions.  */\n-\n-tree\n-make_anon_name (void)\n-{\n-  char buf[32];\n-\n-  sprintf (buf, ANON_AGGRNAME_FORMAT, anon_cnt++);\n-  return get_identifier (buf);\n-}\n-\n-/* Clear the TREE_PURPOSE slot of UTDs which have anonymous typenames.\n-   This keeps dbxout from getting confused.  */\n-\n-void\n-clear_anon_tags (void)\n-{\n-  register struct cp_binding_level *b;\n-  static int last_cnt = 0;\n-\n-  /* Fast out if no new anon names were declared.  */\n-  if (last_cnt == anon_cnt)\n-    return;\n-\n-  b = current_binding_level;\n-  while (b->kind == sk_cleanup)\n-    b = b->level_chain;\n-  if (b->type_decls != NULL)\n-    binding_table_remove_anonymous_types (b->type_decls);\n-  last_cnt = anon_cnt;\n-}\n \f\n /* Subroutine of duplicate_decls: return truthvalue of whether\n    or not types of these decls match.\n@@ -1136,7 +1098,7 @@ decls_match (tree newdecl, tree olddecl)\n    Don't complain about built-in functions, since they are beyond\n    the user's control.  */\n \n-static void\n+void\n warn_extern_redeclared_static (tree newdecl, tree olddecl)\n {\n   static const char *const explicit_extern_static_warning\n@@ -1953,676 +1915,6 @@ duplicate_decls (tree newdecl, tree olddecl)\n \n   return 1;\n }\n-\n-/* Record a decl-node X as belonging to the current lexical scope.\n-   Check for errors (such as an incompatible declaration for the same\n-   name already seen in the same scope).\n-\n-   Returns either X or an old decl for the same name.\n-   If an old decl is returned, it may have been smashed\n-   to agree with what X says.  */\n-\n-tree\n-pushdecl (tree x)\n-{\n-  register tree t;\n-  register tree name;\n-  int need_new_binding;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-\n-  need_new_binding = 1;\n-\n-  if (DECL_TEMPLATE_PARM_P (x))\n-    /* Template parameters have no context; they are not X::T even\n-       when declared within a class or namespace.  */\n-    ;\n-  else\n-    {\n-      if (current_function_decl && x != current_function_decl\n-\t  /* A local declaration for a function doesn't constitute\n-             nesting.  */\n-\t  && !(TREE_CODE (x) == FUNCTION_DECL && !DECL_INITIAL (x))\n-\t  /* A local declaration for an `extern' variable is in the\n-\t     scope of the current namespace, not the current\n-\t     function.  */\n-\t  && !(TREE_CODE (x) == VAR_DECL && DECL_EXTERNAL (x))\n-\t  && !DECL_CONTEXT (x))\n-\tDECL_CONTEXT (x) = current_function_decl;\n-\n-      /* If this is the declaration for a namespace-scope function,\n-\t but the declaration itself is in a local scope, mark the\n-\t declaration.  */\n-      if (TREE_CODE (x) == FUNCTION_DECL\n-\t  && DECL_NAMESPACE_SCOPE_P (x)\n-\t  && current_function_decl\n-\t  && x != current_function_decl)\n-\tDECL_LOCAL_FUNCTION_P (x) = 1;\n-    }\n-\n-  name = DECL_NAME (x);\n-  if (name)\n-    {\n-      int different_binding_level = 0;\n-\n-      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\tname = TREE_OPERAND (name, 0);\n-\n-      /* In case this decl was explicitly namespace-qualified, look it\n-\t up in its namespace context.  */\n-      if (TREE_CODE (x) == VAR_DECL && DECL_NAMESPACE_SCOPE_P (x)\n-\t  && namespace_bindings_p ())\n-\tt = namespace_binding (name, DECL_CONTEXT (x));\n-      else\n-\tt = lookup_name_current_level (name);\n-\n-      /* [basic.link] If there is a visible declaration of an entity\n-\t with linkage having the same name and type, ignoring entities\n-\t declared outside the innermost enclosing namespace scope, the\n-\t block scope declaration declares that same entity and\n-\t receives the linkage of the previous declaration.  */\n-      if (! t && current_function_decl && x != current_function_decl\n-\t  && (TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)\n-\t  && DECL_EXTERNAL (x))\n-\t{\n-\t  /* Look in block scope.  */\n-\t  t = IDENTIFIER_VALUE (name);\n-\t  /* Or in the innermost namespace.  */\n-\t  if (! t)\n-\t    t = namespace_binding (name, DECL_CONTEXT (x));\n-\t  /* Does it have linkage?  Note that if this isn't a DECL, it's an\n-\t     OVERLOAD, which is OK.  */\n-\t  if (t && DECL_P (t) && ! (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n-\t    t = NULL_TREE;\n-\t  if (t)\n-\t    different_binding_level = 1;\n-\t}\n-\n-      /* If we are declaring a function, and the result of name-lookup\n-\t was an OVERLOAD, look for an overloaded instance that is\n-\t actually the same as the function we are declaring.  (If\n-\t there is one, we have to merge our declaration with the\n-\t previous declaration.)  */\n-      if (t && TREE_CODE (t) == OVERLOAD)\n-\t{\n-\t  tree match;\n-\n-\t  if (TREE_CODE (x) == FUNCTION_DECL)\n-\t    for (match = t; match; match = OVL_NEXT (match))\n-\t      {\n-\t\tif (decls_match (OVL_CURRENT (match), x))\n-\t\t  break;\n-\t      }\n-\t  else\n-\t    /* Just choose one.  */\n-\t    match = t;\n-\n-\t  if (match)\n-\t    t = OVL_CURRENT (match);\n-\t  else\n-\t    t = NULL_TREE;\n-\t}\n-\n-      if (t == error_mark_node)\n-\t{\n-\t  /* error_mark_node is 0 for a while during initialization!  */\n-\t  t = NULL_TREE;\n-\t  cp_error_at (\"`%#D' used prior to declaration\", x);\n-\t}\n-      else if (t != NULL_TREE)\n-\t{\n-\t  if (different_binding_level)\n-\t    {\n-\t      if (decls_match (x, t))\n-\t\t/* The standard only says that the local extern\n-\t\t   inherits linkage from the previous decl; in\n-\t\t   particular, default args are not shared.  It would\n-\t\t   be nice to propagate inlining info, though.  FIXME.  */\n-\t\tTREE_PUBLIC (x) = TREE_PUBLIC (t);\n-\t    }\n-\t  else if (TREE_CODE (t) == PARM_DECL)\n-\t    {\n-\t      if (DECL_CONTEXT (t) == NULL_TREE)\n-\t\t/* This is probably caused by too many errors, but calling\n-\t\t   abort will say that if errors have occurred.  */\n-\t\tabort ();\n-\n-\t      /* Check for duplicate params.  */\n-\t      if (duplicate_decls (x, t))\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t    }\n-\t  else if ((DECL_EXTERN_C_FUNCTION_P (x)\n-\t\t    || DECL_FUNCTION_TEMPLATE_P (x))\n-\t\t   && is_overloaded_fn (t))\n-\t    /* Don't do anything just yet.  */;\n-\t  else if (t == wchar_decl_node)\n-\t    {\n-\t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n-\t\tpedwarn (\"redeclaration of `wchar_t' as `%T'\",\n-\t\t\t    TREE_TYPE (x));\n-\n-\t      /* Throw away the redeclaration.  */\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t    }\n-\t  else if (TREE_CODE (t) != TREE_CODE (x))\n-\t    {\n-\t      if (duplicate_decls (x, t))\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t    }\n-\t  else if (duplicate_decls (x, t))\n-\t    {\n-\t      if (TREE_CODE (t) == TYPE_DECL)\n-\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n-\t      else if (TREE_CODE (t) == FUNCTION_DECL)\n-\t\tcheck_default_args (t);\n-\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t    }\n-\t  else if (DECL_MAIN_P (x))\n-\t    {\n-\t      /* A redeclaration of main, but not a duplicate of the\n-\t\t previous one.\n-\n-\t\t [basic.start.main]\n-\n-\t         This function shall not be overloaded.  */\n-\t      cp_error_at (\"invalid redeclaration of `%D'\", t);\n-\t      error (\"as `%D'\", x);\n-\t      /* We don't try to push this declaration since that\n-\t\t causes a crash.  */\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n-\t    }\n-\t}\n-\n-      check_template_shadow (x);\n-\n-      /* If this is a function conjured up by the backend, massage it\n-\t so it looks friendly.  */\n-      if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_LANG_SPECIFIC (x))\n-\t{\n-\t  retrofit_lang_decl (x);\n-\t  SET_DECL_LANGUAGE (x, lang_c);\n-\t}\n-\n-      if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_FUNCTION_MEMBER_P (x))\n-\t{\n-\t  t = push_overloaded_decl (x, PUSH_LOCAL);\n-\t  if (t != x)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t  if (!namespace_bindings_p ())\n-\t    /* We do not need to create a binding for this name;\n-\t       push_overloaded_decl will have already done so if\n-\t       necessary.  */\n-\t    need_new_binding = 0;\n-\t}\n-      else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_NAMESPACE_SCOPE_P (x))\n-\t{\n-\t  t = push_overloaded_decl (x, PUSH_GLOBAL);\n-\t  if (t == x)\n-\t    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t}\n-\n-      /* If declaring a type as a typedef, copy the type (unless we're\n-\t at line 0), and install this TYPE_DECL as the new type's typedef\n-\t name.  See the extensive comment in ../c-decl.c (pushdecl).  */\n-      if (TREE_CODE (x) == TYPE_DECL)\n-\t{\n-\t  tree type = TREE_TYPE (x);\n-\t  if (DECL_SOURCE_LINE (x) == 0)\n-            {\n-\t      if (TYPE_NAME (type) == 0)\n-\t        TYPE_NAME (type) = x;\n-            }\n-          else if (type != error_mark_node && TYPE_NAME (type) != x\n-\t\t   /* We don't want to copy the type when all we're\n-\t\t      doing is making a TYPE_DECL for the purposes of\n-\t\t      inlining.  */\n-\t\t   && (!TYPE_NAME (type)\n-\t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n-            {\n-\t      DECL_ORIGINAL_TYPE (x) = type;\n-              type = build_type_copy (type);\n-\t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n-              TYPE_NAME (type) = x;\n-              TREE_TYPE (x) = type;\n-            }\n-\n-\t  if (type != error_mark_node\n-\t      && TYPE_NAME (type)\n-\t      && TYPE_IDENTIFIER (type))\n-            set_identifier_type_value (DECL_NAME (x), x);\n-\t}\n-\n-      /* Multiple external decls of the same identifier ought to match.\n-\n-\t We get warnings about inline functions where they are defined.\n-\t We get warnings about other functions from push_overloaded_decl.\n-\n-\t Avoid duplicate warnings where they are used.  */\n-      if (TREE_PUBLIC (x) && TREE_CODE (x) != FUNCTION_DECL)\n-\t{\n-\t  tree decl;\n-\n-\t  decl = IDENTIFIER_NAMESPACE_VALUE (name);\n-\t  if (decl && TREE_CODE (decl) == OVERLOAD)\n-\t    decl = OVL_FUNCTION (decl);\n-\n-\t  if (decl && decl != error_mark_node\n-\t      && (DECL_EXTERNAL (decl) || TREE_PUBLIC (decl))\n-\t      /* If different sort of thing, we already gave an error.  */\n-\t      && TREE_CODE (decl) == TREE_CODE (x)\n-\t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n-\t    {\n-\t      pedwarn (\"type mismatch with previous external decl of `%#D'\", x);\n-\t      cp_pedwarn_at (\"previous external decl of `%#D'\", decl);\n-\t    }\n-\t}\n-\n-      /* This name is new in its binding level.\n-\t Install the new declaration and return it.  */\n-      if (namespace_bindings_p ())\n-\t{\n-\t  /* Install a global value.  */\n-\n-\t  /* If the first global decl has external linkage,\n-\t     warn if we later see static one.  */\n-\t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n-\t    TREE_PUBLIC (name) = 1;\n-\n- \t  /* Bind the name for the entity.  */\n- \t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n-  \t\t&& t != NULL_TREE)\n- \t      && (TREE_CODE (x) == TYPE_DECL\n- \t\t  || TREE_CODE (x) == VAR_DECL\n- \t\t  || TREE_CODE (x) == ALIAS_DECL\n- \t\t  || TREE_CODE (x) == NAMESPACE_DECL\n- \t\t  || TREE_CODE (x) == CONST_DECL\n- \t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n- \t    SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n-\n-\t  /* Don't forget if the function was used via an implicit decl.  */\n-\t  if (IDENTIFIER_IMPLICIT_DECL (name)\n-\t      && TREE_USED (IDENTIFIER_IMPLICIT_DECL (name)))\n-\t    TREE_USED (x) = 1;\n-\n-\t  /* Don't forget if its address was taken in that way.  */\n-\t  if (IDENTIFIER_IMPLICIT_DECL (name)\n-\t      && TREE_ADDRESSABLE (IDENTIFIER_IMPLICIT_DECL (name)))\n-\t    TREE_ADDRESSABLE (x) = 1;\n-\n-\t  /* Warn about mismatches against previous implicit decl.  */\n-\t  if (IDENTIFIER_IMPLICIT_DECL (name) != NULL_TREE\n-\t      /* If this real decl matches the implicit, don't complain.  */\n-\t      && ! (TREE_CODE (x) == FUNCTION_DECL\n-\t\t    && TREE_TYPE (TREE_TYPE (x)) == integer_type_node))\n-\t    warning\n-\t      (\"`%D' was previously implicitly declared to return `int'\", x);\n-\n-\t  /* If new decl is `static' and an `extern' was seen previously,\n-\t     warn about it.  */\n-\t  if (x != NULL_TREE && t != NULL_TREE && decls_match (x, t))\n-\t    warn_extern_redeclared_static (x, t);\n-\t}\n-      else\n-\t{\n-\t  /* Here to install a non-global value.  */\n-\t  tree oldlocal = IDENTIFIER_VALUE (name);\n-\t  tree oldglobal = IDENTIFIER_NAMESPACE_VALUE (name);\n-\n-\t  if (need_new_binding)\n-\t    {\n-\t      push_local_binding (name, x, 0);\n-\t      /* Because push_local_binding will hook X on to the\n-\t\t current_binding_level's name list, we don't want to\n-\t\t do that again below.  */\n-\t      need_new_binding = 0;\n-\t    }\n-\n-\t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n-\t  if (TREE_CODE (x) == TYPE_DECL)\n-\t    set_identifier_type_value (name, x);\n-\n-\t  /* Clear out any TYPE_DECL shadowed by a namespace so that\n-\t     we won't think this is a type.  The C struct hack doesn't\n-\t     go through namespaces.  */\n-\t  if (TREE_CODE (x) == NAMESPACE_DECL)\n-\t    set_identifier_type_value (name, NULL_TREE);\n-\n-\t  if (oldlocal)\n-\t    {\n-\t      tree d = oldlocal;\n-\n-\t      while (oldlocal\n-\t\t     && TREE_CODE (oldlocal) == VAR_DECL\n-\t\t     && DECL_DEAD_FOR_LOCAL (oldlocal))\n-\t\toldlocal = DECL_SHADOWED_FOR_VAR (oldlocal);\n-\n-\t      if (oldlocal == NULL_TREE)\n-\t\toldlocal = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (d));\n-\t    }\n-\n-\t  /* If this is an extern function declaration, see if we\n-\t     have a global definition or declaration for the function.  */\n-\t  if (oldlocal == NULL_TREE\n-\t      && DECL_EXTERNAL (x)\n-\t      && oldglobal != NULL_TREE\n-\t      && TREE_CODE (x) == FUNCTION_DECL\n-\t      && TREE_CODE (oldglobal) == FUNCTION_DECL)\n-\t    {\n-\t      /* We have one.  Their types must agree.  */\n-\t      if (decls_match (x, oldglobal))\n-\t\t/* OK */;\n-\t      else\n-\t\t{\n-\t\t  warning (\"extern declaration of `%#D' doesn't match\", x);\n-\t\t  cp_warning_at (\"global declaration `%#D'\", oldglobal);\n-\t\t}\n-\t    }\n-\t  /* If we have a local external declaration,\n-\t     and no file-scope declaration has yet been seen,\n-\t     then if we later have a file-scope decl it must not be static.  */\n-\t  if (oldlocal == NULL_TREE\n-\t      && oldglobal == NULL_TREE\n-\t      && DECL_EXTERNAL (x)\n-\t      && TREE_PUBLIC (x))\n-\t    TREE_PUBLIC (name) = 1;\n-\n-\t  /* Warn if shadowing an argument at the top level of the body.  */\n-\t  if (oldlocal != NULL_TREE && !DECL_EXTERNAL (x)\n-\t      /* Inline decls shadow nothing.  */\n-\t      && !DECL_FROM_INLINE (x)\n-\t      && TREE_CODE (oldlocal) == PARM_DECL\n-\t      /* Don't check the `this' parameter.  */\n-\t      && !DECL_ARTIFICIAL (oldlocal))\n-\t    {\n-\t      bool err = false;\n-\n-\t      /* Don't complain if it's from an enclosing function.  */\n-\t      if (DECL_CONTEXT (oldlocal) == current_function_decl\n-\t\t  && TREE_CODE (x) != PARM_DECL)\n-\t\t{\n-\t\t  /* Go to where the parms should be and see if we find\n-\t\t     them there.  */\n-\t\t  struct cp_binding_level *b = current_binding_level->level_chain;\n-\n-\t\t  /* Skip the ctor/dtor cleanup level.  */\n-\t\t  b = b->level_chain;\n-\n-\t\t  /* ARM $8.3 */\n-\t\t  if (b->kind == sk_function_parms)\n-\t\t    {\n-\t\t      error (\"declaration of `%#D' shadows a parameter\",\n-\t\t\t     name);\n-\t\t      err = true;\n-\t\t    }\n-\t\t}\n-\n-\t      if (warn_shadow && !err)\n-\t\tshadow_warning (SW_PARAM,\n-\t\t\t\tIDENTIFIER_POINTER (name), oldlocal);\n-\t    }\n-\n-\t  /* Maybe warn if shadowing something else.  */\n-\t  else if (warn_shadow && !DECL_EXTERNAL (x)\n-\t      /* No shadow warnings for internally generated vars.  */\n-\t      && ! DECL_ARTIFICIAL (x)\n-\t      /* No shadow warnings for vars made for inlining.  */\n-\t      && ! DECL_FROM_INLINE (x))\n-\t    {\n-\t      if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE\n-\t\t       && current_class_ptr\n-\t\t       && !TREE_STATIC (name))\n-\t\twarning (\"declaration of `%s' shadows a member of `this'\",\n-\t\t\t    IDENTIFIER_POINTER (name));\n-\t      else if (oldlocal != NULL_TREE\n-\t\t       && TREE_CODE (oldlocal) == VAR_DECL)\n-\t\tshadow_warning (SW_LOCAL,\n-\t\t\t\tIDENTIFIER_POINTER (name), oldlocal);\n-\t      else if (oldglobal != NULL_TREE\n-\t\t       && TREE_CODE (oldglobal) == VAR_DECL)\n-\t\t/* XXX shadow warnings in outer-more namespaces */\n-\t\tshadow_warning (SW_GLOBAL,\n-\t\t\t\tIDENTIFIER_POINTER (name), oldglobal);\n-\t    }\n-\t}\n-\n-      if (TREE_CODE (x) == FUNCTION_DECL)\n-\tcheck_default_args (x);\n-\n-      if (TREE_CODE (x) == VAR_DECL)\n-\tmaybe_register_incomplete_var (x);\n-    }\n-\n-  if (need_new_binding)\n-    add_decl_to_level (x,\n-\t\t       DECL_NAMESPACE_SCOPE_P (x)\n-\t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n-\t\t       : current_binding_level);\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n-}\n-\n-/* Like pushdecl, only it places X in the global scope if appropriate.\n-   Calls cp_finish_decl to register the variable, initializing it with\n-   *INIT, if INIT is non-NULL.  */\n-\n-static tree\n-pushdecl_top_level_1 (tree x, tree *init)\n-{\n-  timevar_push (TV_NAME_LOOKUP);\n-  push_to_top_level ();\n-  x = pushdecl_namespace_level (x);\n-  if (init)\n-    cp_finish_decl (x, *init, NULL_TREE, 0);\n-  pop_from_top_level ();\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n-}\n-\n-/* Like pushdecl, only it places X in the global scope if appropriate.  */\n-\n-tree\n-pushdecl_top_level (tree x)\n-{\n-  return pushdecl_top_level_1 (x, NULL);\n-}\n-\n-/* Like pushdecl, only it places X in the global scope if\n-   appropriate.  Calls cp_finish_decl to register the variable,\n-   initializing it with INIT.  */\n-\n-tree\n-pushdecl_top_level_and_finish (tree x, tree init)\n-{\n-  return pushdecl_top_level_1 (x, &init);\n-}\n-\n-/* Enter DECL into the symbol table, if that's appropriate.  Returns\n-   DECL, or a modified version thereof.  */\n-\n-tree\n-maybe_push_decl (tree decl)\n-{\n-  tree type = TREE_TYPE (decl);\n-\n-  /* Add this decl to the current binding level, but not if it comes\n-     from another scope, e.g. a static member variable.  TEM may equal\n-     DECL or it may be a previous decl of the same name.  */\n-  if (decl == error_mark_node\n-      || (TREE_CODE (decl) != PARM_DECL\n-\t  && DECL_CONTEXT (decl) != NULL_TREE\n-\t  /* Definitions of namespace members outside their namespace are\n-\t     possible.  */\n-\t  && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n-      || (TREE_CODE (decl) == TEMPLATE_DECL && !namespace_bindings_p ())\n-      || TREE_CODE (type) == UNKNOWN_TYPE\n-      /* The declaration of a template specialization does not affect\n-\t the functions available for overload resolution, so we do not\n-\t call pushdecl.  */\n-      || (TREE_CODE (decl) == FUNCTION_DECL\n-\t  && DECL_TEMPLATE_SPECIALIZATION (decl)))\n-    return decl;\n-  else\n-    return pushdecl (decl);\n-}\n-\n-/* Insert another USING_DECL into the current binding level, returning\n-   this declaration. If this is a redeclaration, do nothing, and\n-   return NULL_TREE if this not in namespace scope (in namespace\n-   scope, a using decl might extend any previous bindings).  */\n-\n-tree\n-push_using_decl (tree scope, tree name)\n-{\n-  tree decl;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (TREE_CODE (scope) == NAMESPACE_DECL, 383);\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 384);\n-  for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n-    if (DECL_INITIAL (decl) == scope && DECL_NAME (decl) == name)\n-      break;\n-  if (decl)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                            namespace_bindings_p () ? decl : NULL_TREE);\n-  decl = build_lang_decl (USING_DECL, name, void_type_node);\n-  DECL_INITIAL (decl) = scope;\n-  TREE_CHAIN (decl) = current_binding_level->usings;\n-  current_binding_level->usings = decl;\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-}\n-\n-/* DECL is a FUNCTION_DECL for a non-member function, which may have\n-   other definitions already in place.  We get around this by making\n-   the value of the identifier point to a list of all the things that\n-   want to be referenced by that name.  It is then up to the users of\n-   that name to decide what to do with that list.\n-\n-   DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its\n-   DECL_TEMPLATE_RESULT.  It is dealt with the same way.\n-\n-   FLAGS is a bitwise-or of the following values:\n-     PUSH_LOCAL: Bind DECL in the current scope, rather than at\n-                 namespace scope.\n-     PUSH_USING: DECL is being pushed as the result of a using\n-                 declaration.\n-\n-   The value returned may be a previous declaration if we guessed wrong\n-   about what language DECL should belong to (C or C++).  Otherwise,\n-   it's always DECL (and never something that's not a _DECL).  */\n-\n-tree\n-push_overloaded_decl (tree decl, int flags)\n-{\n-  tree name = DECL_NAME (decl);\n-  tree old;\n-  tree new_binding;\n-  int doing_global = (namespace_bindings_p () || !(flags & PUSH_LOCAL));\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (doing_global)\n-    old = namespace_binding (name, DECL_CONTEXT (decl));\n-  else\n-    old = lookup_name_current_level (name);\n-\n-  if (old)\n-    {\n-      if (TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n-\t{\n-\t  tree t = TREE_TYPE (old);\n-\t  if (IS_AGGR_TYPE (t) && warn_shadow\n-\t      && (! DECL_IN_SYSTEM_HEADER (decl)\n-\t\t  || ! DECL_IN_SYSTEM_HEADER (old)))\n-\t    warning (\"`%#D' hides constructor for `%#T'\", decl, t);\n-\t  old = NULL_TREE;\n-\t}\n-      else if (is_overloaded_fn (old))\n-        {\n-          tree tmp;\n-\n-\t  for (tmp = old; tmp; tmp = OVL_NEXT (tmp))\n-\t    {\n-\t      tree fn = OVL_CURRENT (tmp);\n-\n-\t      if (TREE_CODE (tmp) == OVERLOAD && OVL_USED (tmp)\n-\t\t  && !(flags & PUSH_USING)\n-\t\t  && compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)),\n-\t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl))))\n-\t\terror (\"`%#D' conflicts with previous using declaration `%#D'\",\n-\t\t\t  decl, fn);\n-\n-\t      if (duplicate_decls (decl, fn))\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n-\t    }\n-\t}\n-      else if (old == error_mark_node)\n-\t/* Ignore the undefined symbol marker.  */\n-\told = NULL_TREE;\n-      else\n-\t{\n-\t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n-\t  error (\"conflicts with function declaration `%#D'\", decl);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-\t}\n-    }\n-\n-  if (old || TREE_CODE (decl) == TEMPLATE_DECL)\n-    {\n-      if (old && TREE_CODE (old) != OVERLOAD)\n-\tnew_binding = ovl_cons (decl, ovl_cons (old, NULL_TREE));\n-      else\n-\tnew_binding = ovl_cons (decl, old);\n-      if (flags & PUSH_USING)\n-\tOVL_USED (new_binding) = 1;\n-    }\n-  else\n-    /* NAME is not ambiguous.  */\n-    new_binding = decl;\n-\n-  if (doing_global)\n-    set_namespace_binding (name, current_namespace, new_binding);\n-  else\n-    {\n-      /* We only create an OVERLOAD if there was a previous binding at\n-\t this level, or if decl is a template. In the former case, we\n-\t need to remove the old binding and replace it with the new\n-\t binding.  We must also run through the NAMES on the binding\n-\t level where the name was bound to update the chain.  */\n-\n-      if (TREE_CODE (new_binding) == OVERLOAD && old)\n-\t{\n-\t  tree *d;\n-\n-\t  for (d = &IDENTIFIER_BINDING (name)->scope->names;\n-\t       *d;\n-\t       d = &TREE_CHAIN (*d))\n-\t    if (*d == old\n-\t\t|| (TREE_CODE (*d) == TREE_LIST\n-\t\t    && TREE_VALUE (*d) == old))\n-\t      {\n-\t\tif (TREE_CODE (*d) == TREE_LIST)\n-\t\t  /* Just replace the old binding with the new.  */\n-\t\t  TREE_VALUE (*d) = new_binding;\n-\t\telse\n-\t\t  /* Build a TREE_LIST to wrap the OVERLOAD.  */\n-\t\t  *d = tree_cons (NULL_TREE, new_binding,\n-\t\t\t\t  TREE_CHAIN (*d));\n-\n-\t\t/* And update the cxx_binding node.  */\n-\t\tIDENTIFIER_BINDING (name)->value = new_binding;\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-\t      }\n-\n-\t  /* We should always find a previous binding in this case.  */\n-\t  abort ();\n-\t}\n-\n-      /* Install the new binding.  */\n-      push_local_binding (name, new_binding, flags);\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-}\n \f\n /* Generate an implicit declaration for identifier FUNCTIONID\n    as a function of type int ().  Print a warning if appropriate.  */\n@@ -3436,65 +2728,6 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n   return t;\n }\n \n-/* Check to see whether or not DECL is a variable that would have been\n-   in scope under the ARM, but is not in scope under the ANSI/ISO\n-   standard.  If so, issue an error message.  If name lookup would\n-   work in both cases, but return a different result, this function\n-   returns the result of ANSI/ISO lookup.  Otherwise, it returns\n-   DECL.  */\n-\n-tree\n-check_for_out_of_scope_variable (tree decl)\n-{\n-  tree shadowed;\n-\n-  /* We only care about out of scope variables.  */\n-  if (!(TREE_CODE (decl) == VAR_DECL && DECL_DEAD_FOR_LOCAL (decl)))\n-    return decl;\n-\n-  shadowed = DECL_SHADOWED_FOR_VAR (decl);\n-  while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n-\t && DECL_DEAD_FOR_LOCAL (shadowed))\n-    shadowed = DECL_SHADOWED_FOR_VAR (shadowed);\n-  if (!shadowed)\n-    shadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (decl));\n-  if (shadowed)\n-    {\n-      if (!DECL_ERROR_REPORTED (decl))\n-\t{\n-\t  warning (\"name lookup of `%D' changed\",\n-\t\t      DECL_NAME (decl));\n-\t  cp_warning_at (\"  matches this `%D' under ISO standard rules\",\n-\t\t\t shadowed);\n-\t  cp_warning_at (\"  matches this `%D' under old rules\", decl);\n-\t  DECL_ERROR_REPORTED (decl) = 1;\n-\t}\n-      return shadowed;\n-    }\n-\n-  /* If we have already complained about this declaration, there's no\n-     need to do it again.  */\n-  if (DECL_ERROR_REPORTED (decl))\n-    return decl;\n-\n-  DECL_ERROR_REPORTED (decl) = 1;\n-  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n-    {\n-      error (\"name lookup of `%D' changed for new ISO `for' scoping\",\n-\t     DECL_NAME (decl));\n-      cp_error_at (\"  cannot use obsolete binding at `%D' because it has a destructor\", decl);\n-      return error_mark_node;\n-    }\n-  else\n-    {\n-      pedwarn (\"name lookup of `%D' changed for new ISO `for' scoping\",\n-\t       DECL_NAME (decl));\n-      cp_pedwarn_at (\"  using obsolete binding at `%D'\", decl);\n-    }\n-\n-  return decl;\n-}\n-\n \f\n \n /* A chain of TYPE_DECLs for the builtin types.  */\n@@ -5344,59 +4577,6 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n     rest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n }\n \n-/* The old ARM scoping rules injected variables declared in the\n-   initialization statement of a for-statement into the surrounding\n-   scope.  We support this usage, in order to be backward-compatible.\n-   DECL is a just-declared VAR_DECL; if necessary inject its\n-   declaration into the surrounding scope.  */\n-\n-void\n-maybe_inject_for_scope_var (tree decl)\n-{\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (!DECL_NAME (decl))\n-    {\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n-  \n-  /* Declarations of __FUNCTION__ and its ilk appear magically when\n-     the variable is first used.  If that happens to be inside a\n-     for-loop, we don't want to do anything special.  */\n-  if (DECL_PRETTY_FUNCTION_P (decl))\n-    {\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n-\n-  if (current_binding_level->kind == sk_for)\n-    {\n-      struct cp_binding_level *outer\n-\t= current_binding_level->level_chain;\n-\n-      /* Check to see if the same name is already bound at the outer\n-\t level, either because it was directly declared, or because a\n-\t dead for-decl got preserved.  In either case, the code would\n-\t not have been valid under the ARM scope rules, so clear\n-\t is_for_scope for the current_binding_level.\n-\n-\t Otherwise, we need to preserve the temp slot for decl to last\n-\t into the outer binding level.  */\n-\n-      cxx_binding *outer_binding\n-\t= IDENTIFIER_BINDING (DECL_NAME (decl))->previous;\n-\n-      if (outer_binding && outer_binding->scope == outer\n-\t  && (TREE_CODE (outer_binding->value) == VAR_DECL)\n-\t  && DECL_DEAD_FOR_LOCAL (outer_binding->value))\n-\t{\n-\t  outer_binding->value = DECL_SHADOWED_FOR_VAR (outer_binding->value);\n-\t  current_binding_level->kind = sk_block;\n-\t}\n-    }\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n /* Generate code to initialize DECL (a local variable).  */\n \n static void"}, {"sha": "7bc7782e618ece3a6c24559863faf9c6dcbbe2c0", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 838, "deletions": 9, "changes": 847, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=a5e6b29b07b0971b9a8a49d65d342407deef89c5", "patch": "@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"flags.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"name-lookup.h\"\n@@ -33,6 +34,15 @@ Boston, MA 02111-1307, USA.  */\n static cxx_scope *innermost_nonclass_level (void);\n static tree select_decl (cxx_binding *, int);\n static cxx_binding *binding_for_name (cxx_scope *, tree);\n+static tree lookup_name_current_level (tree);\n+static void push_local_binding (tree, tree, int);\n+static tree push_overloaded_decl (tree, int);\n+static bool lookup_using_namespace (tree, cxx_binding *, tree,\n+                                    tree, int, tree *);\n+static bool qualified_lookup_using_namespace (tree, tree, cxx_binding *, int);\n+static tree lookup_type_current_level (tree);\n+static tree push_using_directive (tree);\n+\n \n /* The :: namespace.  */\n \n@@ -486,7 +496,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n \n /* Add DECL to the list of things declared in B.  */\n \n-void\n+static void\n add_decl_to_level (tree decl, cxx_scope *b)\n {\n   if (TREE_CODE (decl) == NAMESPACE_DECL \n@@ -517,12 +527,490 @@ add_decl_to_level (tree decl, cxx_scope *b)\n     }\n }\n \n+/* Record a decl-node X as belonging to the current lexical scope.\n+   Check for errors (such as an incompatible declaration for the same\n+   name already seen in the same scope).\n+\n+   Returns either X or an old decl for the same name.\n+   If an old decl is returned, it may have been smashed\n+   to agree with what X says.  */\n+\n+tree\n+pushdecl (tree x)\n+{\n+  register tree t;\n+  register tree name;\n+  int need_new_binding;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+\n+  need_new_binding = 1;\n+\n+  if (DECL_TEMPLATE_PARM_P (x))\n+    /* Template parameters have no context; they are not X::T even\n+       when declared within a class or namespace.  */\n+    ;\n+  else\n+    {\n+      if (current_function_decl && x != current_function_decl\n+\t  /* A local declaration for a function doesn't constitute\n+             nesting.  */\n+\t  && !(TREE_CODE (x) == FUNCTION_DECL && !DECL_INITIAL (x))\n+\t  /* A local declaration for an `extern' variable is in the\n+\t     scope of the current namespace, not the current\n+\t     function.  */\n+\t  && !(TREE_CODE (x) == VAR_DECL && DECL_EXTERNAL (x))\n+\t  && !DECL_CONTEXT (x))\n+\tDECL_CONTEXT (x) = current_function_decl;\n+\n+      /* If this is the declaration for a namespace-scope function,\n+\t but the declaration itself is in a local scope, mark the\n+\t declaration.  */\n+      if (TREE_CODE (x) == FUNCTION_DECL\n+\t  && DECL_NAMESPACE_SCOPE_P (x)\n+\t  && current_function_decl\n+\t  && x != current_function_decl)\n+\tDECL_LOCAL_FUNCTION_P (x) = 1;\n+    }\n+\n+  name = DECL_NAME (x);\n+  if (name)\n+    {\n+      int different_binding_level = 0;\n+\n+      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+\tname = TREE_OPERAND (name, 0);\n+\n+      /* In case this decl was explicitly namespace-qualified, look it\n+\t up in its namespace context.  */\n+      if (TREE_CODE (x) == VAR_DECL && DECL_NAMESPACE_SCOPE_P (x)\n+\t  && namespace_bindings_p ())\n+\tt = namespace_binding (name, DECL_CONTEXT (x));\n+      else\n+\tt = lookup_name_current_level (name);\n+\n+      /* [basic.link] If there is a visible declaration of an entity\n+\t with linkage having the same name and type, ignoring entities\n+\t declared outside the innermost enclosing namespace scope, the\n+\t block scope declaration declares that same entity and\n+\t receives the linkage of the previous declaration.  */\n+      if (! t && current_function_decl && x != current_function_decl\n+\t  && (TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)\n+\t  && DECL_EXTERNAL (x))\n+\t{\n+\t  /* Look in block scope.  */\n+\t  t = IDENTIFIER_VALUE (name);\n+\t  /* Or in the innermost namespace.  */\n+\t  if (! t)\n+\t    t = namespace_binding (name, DECL_CONTEXT (x));\n+\t  /* Does it have linkage?  Note that if this isn't a DECL, it's an\n+\t     OVERLOAD, which is OK.  */\n+\t  if (t && DECL_P (t) && ! (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n+\t    t = NULL_TREE;\n+\t  if (t)\n+\t    different_binding_level = 1;\n+\t}\n+\n+      /* If we are declaring a function, and the result of name-lookup\n+\t was an OVERLOAD, look for an overloaded instance that is\n+\t actually the same as the function we are declaring.  (If\n+\t there is one, we have to merge our declaration with the\n+\t previous declaration.)  */\n+      if (t && TREE_CODE (t) == OVERLOAD)\n+\t{\n+\t  tree match;\n+\n+\t  if (TREE_CODE (x) == FUNCTION_DECL)\n+\t    for (match = t; match; match = OVL_NEXT (match))\n+\t      {\n+\t\tif (decls_match (OVL_CURRENT (match), x))\n+\t\t  break;\n+\t      }\n+\t  else\n+\t    /* Just choose one.  */\n+\t    match = t;\n+\n+\t  if (match)\n+\t    t = OVL_CURRENT (match);\n+\t  else\n+\t    t = NULL_TREE;\n+\t}\n+\n+      if (t == error_mark_node)\n+\t{\n+\t  /* error_mark_node is 0 for a while during initialization!  */\n+\t  t = NULL_TREE;\n+\t  cp_error_at (\"`%#D' used prior to declaration\", x);\n+\t}\n+      else if (t != NULL_TREE)\n+\t{\n+\t  if (different_binding_level)\n+\t    {\n+\t      if (decls_match (x, t))\n+\t\t/* The standard only says that the local extern\n+\t\t   inherits linkage from the previous decl; in\n+\t\t   particular, default args are not shared.  It would\n+\t\t   be nice to propagate inlining info, though.  FIXME.  */\n+\t\tTREE_PUBLIC (x) = TREE_PUBLIC (t);\n+\t    }\n+\t  else if (TREE_CODE (t) == PARM_DECL)\n+\t    {\n+\t      if (DECL_CONTEXT (t) == NULL_TREE)\n+\t\t/* This is probably caused by too many errors, but calling\n+\t\t   abort will say that if errors have occurred.  */\n+\t\tabort ();\n+\n+\t      /* Check for duplicate params.  */\n+\t      if (duplicate_decls (x, t))\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t    }\n+\t  else if ((DECL_EXTERN_C_FUNCTION_P (x)\n+\t\t    || DECL_FUNCTION_TEMPLATE_P (x))\n+\t\t   && is_overloaded_fn (t))\n+\t    /* Don't do anything just yet.  */;\n+\t  else if (t == wchar_decl_node)\n+\t    {\n+\t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n+\t\tpedwarn (\"redeclaration of `wchar_t' as `%T'\",\n+\t\t\t    TREE_TYPE (x));\n+\n+\t      /* Throw away the redeclaration.  */\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t    }\n+\t  else if (TREE_CODE (t) != TREE_CODE (x))\n+\t    {\n+\t      if (duplicate_decls (x, t))\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t    }\n+\t  else if (duplicate_decls (x, t))\n+\t    {\n+\t      if (TREE_CODE (t) == TYPE_DECL)\n+\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n+\t      else if (TREE_CODE (t) == FUNCTION_DECL)\n+\t\tcheck_default_args (t);\n+\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t    }\n+\t  else if (DECL_MAIN_P (x))\n+\t    {\n+\t      /* A redeclaration of main, but not a duplicate of the\n+\t\t previous one.\n+\n+\t\t [basic.start.main]\n+\n+\t         This function shall not be overloaded.  */\n+\t      cp_error_at (\"invalid redeclaration of `%D'\", t);\n+\t      error (\"as `%D'\", x);\n+\t      /* We don't try to push this declaration since that\n+\t\t causes a crash.  */\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+\t    }\n+\t}\n+\n+      check_template_shadow (x);\n+\n+      /* If this is a function conjured up by the backend, massage it\n+\t so it looks friendly.  */\n+      if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_LANG_SPECIFIC (x))\n+\t{\n+\t  retrofit_lang_decl (x);\n+\t  SET_DECL_LANGUAGE (x, lang_c);\n+\t}\n+\n+      if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_FUNCTION_MEMBER_P (x))\n+\t{\n+\t  t = push_overloaded_decl (x, PUSH_LOCAL);\n+\t  if (t != x)\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t  if (!namespace_bindings_p ())\n+\t    /* We do not need to create a binding for this name;\n+\t       push_overloaded_decl will have already done so if\n+\t       necessary.  */\n+\t    need_new_binding = 0;\n+\t}\n+      else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_NAMESPACE_SCOPE_P (x))\n+\t{\n+\t  t = push_overloaded_decl (x, PUSH_GLOBAL);\n+\t  if (t == x)\n+\t    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t}\n+\n+      /* If declaring a type as a typedef, copy the type (unless we're\n+\t at line 0), and install this TYPE_DECL as the new type's typedef\n+\t name.  See the extensive comment in ../c-decl.c (pushdecl).  */\n+      if (TREE_CODE (x) == TYPE_DECL)\n+\t{\n+\t  tree type = TREE_TYPE (x);\n+\t  if (DECL_SOURCE_LINE (x) == 0)\n+            {\n+\t      if (TYPE_NAME (type) == 0)\n+\t        TYPE_NAME (type) = x;\n+            }\n+          else if (type != error_mark_node && TYPE_NAME (type) != x\n+\t\t   /* We don't want to copy the type when all we're\n+\t\t      doing is making a TYPE_DECL for the purposes of\n+\t\t      inlining.  */\n+\t\t   && (!TYPE_NAME (type)\n+\t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n+            {\n+\t      DECL_ORIGINAL_TYPE (x) = type;\n+              type = build_type_copy (type);\n+\t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n+              TYPE_NAME (type) = x;\n+              TREE_TYPE (x) = type;\n+            }\n+\n+\t  if (type != error_mark_node\n+\t      && TYPE_NAME (type)\n+\t      && TYPE_IDENTIFIER (type))\n+            set_identifier_type_value (DECL_NAME (x), x);\n+\t}\n+\n+      /* Multiple external decls of the same identifier ought to match.\n+\n+\t We get warnings about inline functions where they are defined.\n+\t We get warnings about other functions from push_overloaded_decl.\n+\n+\t Avoid duplicate warnings where they are used.  */\n+      if (TREE_PUBLIC (x) && TREE_CODE (x) != FUNCTION_DECL)\n+\t{\n+\t  tree decl;\n+\n+\t  decl = IDENTIFIER_NAMESPACE_VALUE (name);\n+\t  if (decl && TREE_CODE (decl) == OVERLOAD)\n+\t    decl = OVL_FUNCTION (decl);\n+\n+\t  if (decl && decl != error_mark_node\n+\t      && (DECL_EXTERNAL (decl) || TREE_PUBLIC (decl))\n+\t      /* If different sort of thing, we already gave an error.  */\n+\t      && TREE_CODE (decl) == TREE_CODE (x)\n+\t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n+\t    {\n+\t      pedwarn (\"type mismatch with previous external decl of `%#D'\", x);\n+\t      cp_pedwarn_at (\"previous external decl of `%#D'\", decl);\n+\t    }\n+\t}\n+\n+      /* This name is new in its binding level.\n+\t Install the new declaration and return it.  */\n+      if (namespace_bindings_p ())\n+\t{\n+\t  /* Install a global value.  */\n+\n+\t  /* If the first global decl has external linkage,\n+\t     warn if we later see static one.  */\n+\t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n+\t    TREE_PUBLIC (name) = 1;\n+\n+ \t  /* Bind the name for the entity.  */\n+ \t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n+  \t\t&& t != NULL_TREE)\n+ \t      && (TREE_CODE (x) == TYPE_DECL\n+ \t\t  || TREE_CODE (x) == VAR_DECL\n+ \t\t  || TREE_CODE (x) == ALIAS_DECL\n+ \t\t  || TREE_CODE (x) == NAMESPACE_DECL\n+ \t\t  || TREE_CODE (x) == CONST_DECL\n+ \t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n+ \t    SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n+\n+\t  /* Don't forget if the function was used via an implicit decl.  */\n+\t  if (IDENTIFIER_IMPLICIT_DECL (name)\n+\t      && TREE_USED (IDENTIFIER_IMPLICIT_DECL (name)))\n+\t    TREE_USED (x) = 1;\n+\n+\t  /* Don't forget if its address was taken in that way.  */\n+\t  if (IDENTIFIER_IMPLICIT_DECL (name)\n+\t      && TREE_ADDRESSABLE (IDENTIFIER_IMPLICIT_DECL (name)))\n+\t    TREE_ADDRESSABLE (x) = 1;\n+\n+\t  /* Warn about mismatches against previous implicit decl.  */\n+\t  if (IDENTIFIER_IMPLICIT_DECL (name) != NULL_TREE\n+\t      /* If this real decl matches the implicit, don't complain.  */\n+\t      && ! (TREE_CODE (x) == FUNCTION_DECL\n+\t\t    && TREE_TYPE (TREE_TYPE (x)) == integer_type_node))\n+\t    warning\n+\t      (\"`%D' was previously implicitly declared to return `int'\", x);\n+\n+\t  /* If new decl is `static' and an `extern' was seen previously,\n+\t     warn about it.  */\n+\t  if (x != NULL_TREE && t != NULL_TREE && decls_match (x, t))\n+\t    warn_extern_redeclared_static (x, t);\n+\t}\n+      else\n+\t{\n+\t  /* Here to install a non-global value.  */\n+\t  tree oldlocal = IDENTIFIER_VALUE (name);\n+\t  tree oldglobal = IDENTIFIER_NAMESPACE_VALUE (name);\n+\n+\t  if (need_new_binding)\n+\t    {\n+\t      push_local_binding (name, x, 0);\n+\t      /* Because push_local_binding will hook X on to the\n+\t\t current_binding_level's name list, we don't want to\n+\t\t do that again below.  */\n+\t      need_new_binding = 0;\n+\t    }\n+\n+\t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n+\t  if (TREE_CODE (x) == TYPE_DECL)\n+\t    set_identifier_type_value (name, x);\n+\n+\t  /* Clear out any TYPE_DECL shadowed by a namespace so that\n+\t     we won't think this is a type.  The C struct hack doesn't\n+\t     go through namespaces.  */\n+\t  if (TREE_CODE (x) == NAMESPACE_DECL)\n+\t    set_identifier_type_value (name, NULL_TREE);\n+\n+\t  if (oldlocal)\n+\t    {\n+\t      tree d = oldlocal;\n+\n+\t      while (oldlocal\n+\t\t     && TREE_CODE (oldlocal) == VAR_DECL\n+\t\t     && DECL_DEAD_FOR_LOCAL (oldlocal))\n+\t\toldlocal = DECL_SHADOWED_FOR_VAR (oldlocal);\n+\n+\t      if (oldlocal == NULL_TREE)\n+\t\toldlocal = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (d));\n+\t    }\n+\n+\t  /* If this is an extern function declaration, see if we\n+\t     have a global definition or declaration for the function.  */\n+\t  if (oldlocal == NULL_TREE\n+\t      && DECL_EXTERNAL (x)\n+\t      && oldglobal != NULL_TREE\n+\t      && TREE_CODE (x) == FUNCTION_DECL\n+\t      && TREE_CODE (oldglobal) == FUNCTION_DECL)\n+\t    {\n+\t      /* We have one.  Their types must agree.  */\n+\t      if (decls_match (x, oldglobal))\n+\t\t/* OK */;\n+\t      else\n+\t\t{\n+\t\t  warning (\"extern declaration of `%#D' doesn't match\", x);\n+\t\t  cp_warning_at (\"global declaration `%#D'\", oldglobal);\n+\t\t}\n+\t    }\n+\t  /* If we have a local external declaration,\n+\t     and no file-scope declaration has yet been seen,\n+\t     then if we later have a file-scope decl it must not be static.  */\n+\t  if (oldlocal == NULL_TREE\n+\t      && oldglobal == NULL_TREE\n+\t      && DECL_EXTERNAL (x)\n+\t      && TREE_PUBLIC (x))\n+\t    TREE_PUBLIC (name) = 1;\n+\n+\t  /* Warn if shadowing an argument at the top level of the body.  */\n+\t  if (oldlocal != NULL_TREE && !DECL_EXTERNAL (x)\n+\t      /* Inline decls shadow nothing.  */\n+\t      && !DECL_FROM_INLINE (x)\n+\t      && TREE_CODE (oldlocal) == PARM_DECL\n+\t      /* Don't check the `this' parameter.  */\n+\t      && !DECL_ARTIFICIAL (oldlocal))\n+\t    {\n+\t      bool err = false;\n+\n+\t      /* Don't complain if it's from an enclosing function.  */\n+\t      if (DECL_CONTEXT (oldlocal) == current_function_decl\n+\t\t  && TREE_CODE (x) != PARM_DECL)\n+\t\t{\n+\t\t  /* Go to where the parms should be and see if we find\n+\t\t     them there.  */\n+\t\t  struct cp_binding_level *b = current_binding_level->level_chain;\n+\n+\t\t  /* Skip the ctor/dtor cleanup level.  */\n+\t\t  b = b->level_chain;\n+\n+\t\t  /* ARM $8.3 */\n+\t\t  if (b->kind == sk_function_parms)\n+\t\t    {\n+\t\t      error (\"declaration of `%#D' shadows a parameter\",\n+\t\t\t     name);\n+\t\t      err = true;\n+\t\t    }\n+\t\t}\n+\n+\t      if (warn_shadow && !err)\n+\t\tshadow_warning (SW_PARAM,\n+\t\t\t\tIDENTIFIER_POINTER (name), oldlocal);\n+\t    }\n+\n+\t  /* Maybe warn if shadowing something else.  */\n+\t  else if (warn_shadow && !DECL_EXTERNAL (x)\n+\t      /* No shadow warnings for internally generated vars.  */\n+\t      && ! DECL_ARTIFICIAL (x)\n+\t      /* No shadow warnings for vars made for inlining.  */\n+\t      && ! DECL_FROM_INLINE (x))\n+\t    {\n+\t      if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE\n+\t\t       && current_class_ptr\n+\t\t       && !TREE_STATIC (name))\n+\t\twarning (\"declaration of `%s' shadows a member of `this'\",\n+\t\t\t    IDENTIFIER_POINTER (name));\n+\t      else if (oldlocal != NULL_TREE\n+\t\t       && TREE_CODE (oldlocal) == VAR_DECL)\n+\t\tshadow_warning (SW_LOCAL,\n+\t\t\t\tIDENTIFIER_POINTER (name), oldlocal);\n+\t      else if (oldglobal != NULL_TREE\n+\t\t       && TREE_CODE (oldglobal) == VAR_DECL)\n+\t\t/* XXX shadow warnings in outer-more namespaces */\n+\t\tshadow_warning (SW_GLOBAL,\n+\t\t\t\tIDENTIFIER_POINTER (name), oldglobal);\n+\t    }\n+\t}\n+\n+      if (TREE_CODE (x) == FUNCTION_DECL)\n+\tcheck_default_args (x);\n+\n+      if (TREE_CODE (x) == VAR_DECL)\n+\tmaybe_register_incomplete_var (x);\n+    }\n+\n+  if (need_new_binding)\n+    add_decl_to_level (x,\n+\t\t       DECL_NAMESPACE_SCOPE_P (x)\n+\t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n+\t\t       : current_binding_level);\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+}\n+\n+/* Enter DECL into the symbol table, if that's appropriate.  Returns\n+   DECL, or a modified version thereof.  */\n+\n+tree\n+maybe_push_decl (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  /* Add this decl to the current binding level, but not if it comes\n+     from another scope, e.g. a static member variable.  TEM may equal\n+     DECL or it may be a previous decl of the same name.  */\n+  if (decl == error_mark_node\n+      || (TREE_CODE (decl) != PARM_DECL\n+\t  && DECL_CONTEXT (decl) != NULL_TREE\n+\t  /* Definitions of namespace members outside their namespace are\n+\t     possible.  */\n+\t  && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n+      || (TREE_CODE (decl) == TEMPLATE_DECL && !namespace_bindings_p ())\n+      || TREE_CODE (type) == UNKNOWN_TYPE\n+      /* The declaration of a template specialization does not affect\n+\t the functions available for overload resolution, so we do not\n+\t call pushdecl.  */\n+      || (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && DECL_TEMPLATE_SPECIALIZATION (decl)))\n+    return decl;\n+  else\n+    return pushdecl (decl);\n+}\n+\n /* Bind DECL to ID in the current_binding_level, assumed to be a local\n    binding level.  If PUSH_USING is set in FLAGS, we know that DECL\n    doesn't really belong to this binding level, that it got here\n    through a using-declaration.  */\n \n-void\n+static void\n push_local_binding (tree id, tree decl, int flags)\n {\n   struct cp_binding_level *b;\n@@ -554,6 +1042,118 @@ push_local_binding (tree id, tree decl, int flags)\n      binding level.  */\n   add_decl_to_level (decl, b);\n }\n+\n+/* The old ARM scoping rules injected variables declared in the\n+   initialization statement of a for-statement into the surrounding\n+   scope.  We support this usage, in order to be backward-compatible.\n+   DECL is a just-declared VAR_DECL; if necessary inject its\n+   declaration into the surrounding scope.  */\n+\n+void\n+maybe_inject_for_scope_var (tree decl)\n+{\n+  timevar_push (TV_NAME_LOOKUP);\n+  if (!DECL_NAME (decl))\n+    {\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n+  \n+  /* Declarations of __FUNCTION__ and its ilk appear magically when\n+     the variable is first used.  If that happens to be inside a\n+     for-loop, we don't want to do anything special.  */\n+  if (DECL_PRETTY_FUNCTION_P (decl))\n+    {\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n+\n+  if (current_binding_level->kind == sk_for)\n+    {\n+      struct cp_binding_level *outer\n+\t= current_binding_level->level_chain;\n+\n+      /* Check to see if the same name is already bound at the outer\n+\t level, either because it was directly declared, or because a\n+\t dead for-decl got preserved.  In either case, the code would\n+\t not have been valid under the ARM scope rules, so clear\n+\t is_for_scope for the current_binding_level.\n+\n+\t Otherwise, we need to preserve the temp slot for decl to last\n+\t into the outer binding level.  */\n+\n+      cxx_binding *outer_binding\n+\t= IDENTIFIER_BINDING (DECL_NAME (decl))->previous;\n+\n+      if (outer_binding && outer_binding->scope == outer\n+\t  && (TREE_CODE (outer_binding->value) == VAR_DECL)\n+\t  && DECL_DEAD_FOR_LOCAL (outer_binding->value))\n+\t{\n+\t  outer_binding->value = DECL_SHADOWED_FOR_VAR (outer_binding->value);\n+\t  current_binding_level->kind = sk_block;\n+\t}\n+    }\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Check to see whether or not DECL is a variable that would have been\n+   in scope under the ARM, but is not in scope under the ANSI/ISO\n+   standard.  If so, issue an error message.  If name lookup would\n+   work in both cases, but return a different result, this function\n+   returns the result of ANSI/ISO lookup.  Otherwise, it returns\n+   DECL.  */\n+\n+tree\n+check_for_out_of_scope_variable (tree decl)\n+{\n+  tree shadowed;\n+\n+  /* We only care about out of scope variables.  */\n+  if (!(TREE_CODE (decl) == VAR_DECL && DECL_DEAD_FOR_LOCAL (decl)))\n+    return decl;\n+\n+  shadowed = DECL_SHADOWED_FOR_VAR (decl);\n+  while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n+\t && DECL_DEAD_FOR_LOCAL (shadowed))\n+    shadowed = DECL_SHADOWED_FOR_VAR (shadowed);\n+  if (!shadowed)\n+    shadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (decl));\n+  if (shadowed)\n+    {\n+      if (!DECL_ERROR_REPORTED (decl))\n+\t{\n+\t  warning (\"name lookup of `%D' changed\",\n+\t\t      DECL_NAME (decl));\n+\t  cp_warning_at (\"  matches this `%D' under ISO standard rules\",\n+\t\t\t shadowed);\n+\t  cp_warning_at (\"  matches this `%D' under old rules\", decl);\n+\t  DECL_ERROR_REPORTED (decl) = 1;\n+\t}\n+      return shadowed;\n+    }\n+\n+  /* If we have already complained about this declaration, there's no\n+     need to do it again.  */\n+  if (DECL_ERROR_REPORTED (decl))\n+    return decl;\n+\n+  DECL_ERROR_REPORTED (decl) = 1;\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+    {\n+      error (\"name lookup of `%D' changed for new ISO `for' scoping\",\n+\t     DECL_NAME (decl));\n+      cp_error_at (\"  cannot use obsolete binding at `%D' because it has a destructor\", decl);\n+      return error_mark_node;\n+    }\n+  else\n+    {\n+      pedwarn (\"name lookup of `%D' changed for new ISO `for' scoping\",\n+\t       DECL_NAME (decl));\n+      cp_pedwarn_at (\"  using obsolete binding at `%D'\", decl);\n+    }\n+\n+  return decl;\n+}\n \f\n /* true means unconditionally make a BLOCK for the next level pushed.  */\n \n@@ -1177,6 +1777,43 @@ constructor_name_p (tree name, tree type)\n   return false;\n }\n \n+/* Counter used to create anonymous type names.  */\n+\n+static GTY(()) int anon_cnt;\n+\n+/* Return an IDENTIFIER which can be used as a name for\n+   anonymous structs and unions.  */\n+\n+tree\n+make_anon_name (void)\n+{\n+  char buf[32];\n+\n+  sprintf (buf, ANON_AGGRNAME_FORMAT, anon_cnt++);\n+  return get_identifier (buf);\n+}\n+\n+/* Clear the TREE_PURPOSE slot of UTDs which have anonymous typenames.\n+   This keeps dbxout from getting confused.  */\n+\n+void\n+clear_anon_tags (void)\n+{\n+  register struct cp_binding_level *b;\n+  static int last_cnt = 0;\n+\n+  /* Fast out if no new anon names were declared.  */\n+  if (last_cnt == anon_cnt)\n+    return;\n+\n+  b = current_binding_level;\n+  while (b->kind == sk_cleanup)\n+    b = b->level_chain;\n+  if (b->type_decls != NULL)\n+    binding_table_remove_anonymous_types (b->type_decls);\n+  last_cnt = anon_cnt;\n+}\n+\f\n /* Return (from the stack of) the BINDING, if any, establihsed at SCOPE.  */ \n \n static inline cxx_binding *\n@@ -1228,6 +1865,32 @@ binding_for_name (cxx_scope *scope, tree name)\n   return result;\n }\n \n+/* Insert another USING_DECL into the current binding level, returning\n+   this declaration. If this is a redeclaration, do nothing, and\n+   return NULL_TREE if this not in namespace scope (in namespace\n+   scope, a using decl might extend any previous bindings).  */\n+\n+tree\n+push_using_decl (tree scope, tree name)\n+{\n+  tree decl;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  my_friendly_assert (TREE_CODE (scope) == NAMESPACE_DECL, 383);\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 384);\n+  for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n+    if (DECL_INITIAL (decl) == scope && DECL_NAME (decl) == name)\n+      break;\n+  if (decl)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                            namespace_bindings_p () ? decl : NULL_TREE);\n+  decl = build_lang_decl (USING_DECL, name, void_type_node);\n+  DECL_INITIAL (decl) = scope;\n+  TREE_CHAIN (decl) = current_binding_level->usings;\n+  current_binding_level->usings = decl;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+}\n+\n /* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the\n    caller to set DECL_CONTEXT properly.  */\n \n@@ -1257,6 +1920,138 @@ pushdecl_with_scope (tree x, cxx_scope *level)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }\n \n+/* DECL is a FUNCTION_DECL for a non-member function, which may have\n+   other definitions already in place.  We get around this by making\n+   the value of the identifier point to a list of all the things that\n+   want to be referenced by that name.  It is then up to the users of\n+   that name to decide what to do with that list.\n+\n+   DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its\n+   DECL_TEMPLATE_RESULT.  It is dealt with the same way.\n+\n+   FLAGS is a bitwise-or of the following values:\n+     PUSH_LOCAL: Bind DECL in the current scope, rather than at\n+                 namespace scope.\n+     PUSH_USING: DECL is being pushed as the result of a using\n+                 declaration.\n+\n+   The value returned may be a previous declaration if we guessed wrong\n+   about what language DECL should belong to (C or C++).  Otherwise,\n+   it's always DECL (and never something that's not a _DECL).  */\n+\n+static tree\n+push_overloaded_decl (tree decl, int flags)\n+{\n+  tree name = DECL_NAME (decl);\n+  tree old;\n+  tree new_binding;\n+  int doing_global = (namespace_bindings_p () || !(flags & PUSH_LOCAL));\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  if (doing_global)\n+    old = namespace_binding (name, DECL_CONTEXT (decl));\n+  else\n+    old = lookup_name_current_level (name);\n+\n+  if (old)\n+    {\n+      if (TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n+\t{\n+\t  tree t = TREE_TYPE (old);\n+\t  if (IS_AGGR_TYPE (t) && warn_shadow\n+\t      && (! DECL_IN_SYSTEM_HEADER (decl)\n+\t\t  || ! DECL_IN_SYSTEM_HEADER (old)))\n+\t    warning (\"`%#D' hides constructor for `%#T'\", decl, t);\n+\t  old = NULL_TREE;\n+\t}\n+      else if (is_overloaded_fn (old))\n+        {\n+          tree tmp;\n+\n+\t  for (tmp = old; tmp; tmp = OVL_NEXT (tmp))\n+\t    {\n+\t      tree fn = OVL_CURRENT (tmp);\n+\n+\t      if (TREE_CODE (tmp) == OVERLOAD && OVL_USED (tmp)\n+\t\t  && !(flags & PUSH_USING)\n+\t\t  && compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)),\n+\t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl))))\n+\t\terror (\"`%#D' conflicts with previous using declaration `%#D'\",\n+\t\t\t  decl, fn);\n+\n+\t      if (duplicate_decls (decl, fn))\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n+\t    }\n+\t}\n+      else if (old == error_mark_node)\n+\t/* Ignore the undefined symbol marker.  */\n+\told = NULL_TREE;\n+      else\n+\t{\n+\t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n+\t  error (\"conflicts with function declaration `%#D'\", decl);\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+\t}\n+    }\n+\n+  if (old || TREE_CODE (decl) == TEMPLATE_DECL)\n+    {\n+      if (old && TREE_CODE (old) != OVERLOAD)\n+\tnew_binding = ovl_cons (decl, ovl_cons (old, NULL_TREE));\n+      else\n+\tnew_binding = ovl_cons (decl, old);\n+      if (flags & PUSH_USING)\n+\tOVL_USED (new_binding) = 1;\n+    }\n+  else\n+    /* NAME is not ambiguous.  */\n+    new_binding = decl;\n+\n+  if (doing_global)\n+    set_namespace_binding (name, current_namespace, new_binding);\n+  else\n+    {\n+      /* We only create an OVERLOAD if there was a previous binding at\n+\t this level, or if decl is a template. In the former case, we\n+\t need to remove the old binding and replace it with the new\n+\t binding.  We must also run through the NAMES on the binding\n+\t level where the name was bound to update the chain.  */\n+\n+      if (TREE_CODE (new_binding) == OVERLOAD && old)\n+\t{\n+\t  tree *d;\n+\n+\t  for (d = &IDENTIFIER_BINDING (name)->scope->names;\n+\t       *d;\n+\t       d = &TREE_CHAIN (*d))\n+\t    if (*d == old\n+\t\t|| (TREE_CODE (*d) == TREE_LIST\n+\t\t    && TREE_VALUE (*d) == old))\n+\t      {\n+\t\tif (TREE_CODE (*d) == TREE_LIST)\n+\t\t  /* Just replace the old binding with the new.  */\n+\t\t  TREE_VALUE (*d) = new_binding;\n+\t\telse\n+\t\t  /* Build a TREE_LIST to wrap the OVERLOAD.  */\n+\t\t  *d = tree_cons (NULL_TREE, new_binding,\n+\t\t\t\t  TREE_CHAIN (*d));\n+\n+\t\t/* And update the cxx_binding node.  */\n+\t\tIDENTIFIER_BINDING (name)->value = new_binding;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+\t      }\n+\n+\t  /* We should always find a previous binding in this case.  */\n+\t  abort ();\n+\t}\n+\n+      /* Install the new binding.  */\n+      push_local_binding (name, new_binding, flags);\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+}\n+\n /* Check a non-member using-declaration. Return the name and scope\n    being used, and the USING_DECL, or NULL_TREE on failure.  */\n \n@@ -2302,7 +3097,7 @@ pop_decl_namespace (void)\n /* Return the namespace that is the common ancestor \n    of two given namespaces.  */\n \n-tree\n+static tree\n namespace_ancestor (tree ns1, tree ns2)\n {\n   timevar_push (TV_NAME_LOOKUP);\n@@ -2488,6 +3283,40 @@ do_using_directive (tree namespace)\n     add_using_namespace (current_namespace, namespace, 0);\n }\n \n+/* Like pushdecl, only it places X in the global scope if appropriate.\n+   Calls cp_finish_decl to register the variable, initializing it with\n+   *INIT, if INIT is non-NULL.  */\n+\n+static tree\n+pushdecl_top_level_1 (tree x, tree *init)\n+{\n+  timevar_push (TV_NAME_LOOKUP);\n+  push_to_top_level ();\n+  x = pushdecl_namespace_level (x);\n+  if (init)\n+    cp_finish_decl (x, *init, NULL_TREE, 0);\n+  pop_from_top_level ();\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+}\n+\n+/* Like pushdecl, only it places X in the global scope if appropriate.  */\n+\n+tree\n+pushdecl_top_level (tree x)\n+{\n+  return pushdecl_top_level_1 (x, NULL);\n+}\n+\n+/* Like pushdecl, only it places X in the global scope if\n+   appropriate.  Calls cp_finish_decl to register the variable,\n+   initializing it with INIT.  */\n+\n+tree\n+pushdecl_top_level_and_finish (tree x, tree init)\n+{\n+  return pushdecl_top_level_1 (x, &init);\n+}\n+\n /* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n    duplicates.  The first list becomes the tail of the result.\n \n@@ -2765,7 +3594,7 @@ select_decl (cxx_binding *binding, int flags)\n    considering using-directives.  If SPACESP is non-NULL, store a list\n    of the namespaces we've considered in it.  */\n \n-tree\n+static tree\n unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n {\n   tree initial = current_decl_namespace ();\n@@ -2872,7 +3701,7 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n    which have SCOPE as a common ancestor with the current scope.\n    Returns false on errors.  */\n \n-bool\n+static bool\n lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n                         int flags, tree *spacesp)\n {\n@@ -2900,7 +3729,7 @@ lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n    Returns the name/type pair found into the cxx_binding *RESULT,\n    or false on error.  */\n \n-bool\n+static bool\n qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n                                   int flags)\n {\n@@ -3058,7 +3887,7 @@ lookup_name (tree name, int prefer_type)\n /* Similar to `lookup_name' but look only in the innermost non-class\n    binding level.  */\n \n-tree\n+static tree\n lookup_name_current_level (tree name)\n {\n   struct cp_binding_level *b;\n@@ -3095,7 +3924,7 @@ lookup_name_current_level (tree name)\n \n /* Like lookup_name_current_level, but for types.  */\n \n-tree\n+static tree\n lookup_type_current_level (tree name)\n {\n   register tree t = NULL_TREE;\n@@ -3476,7 +4305,7 @@ lookup_arg_dependent (tree name, tree fns, tree args)\n    changed (i.e. there was already a directive), or the fresh\n    TREE_LIST otherwise.  */\n \n-tree\n+static tree\n push_using_directive (tree used)\n {\n   tree ud = current_binding_level->using_directives;"}, {"sha": "36643b26d2912614a80b81ef3b4bd0bf02f92f26", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e6b29b07b0971b9a8a49d65d342407deef89c5/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=a5e6b29b07b0971b9a8a49d65d342407deef89c5", "patch": "@@ -275,28 +275,19 @@ extern void push_namespace (tree);\n extern void pop_namespace (void);\n extern void push_nested_namespace (tree);\n extern void pop_nested_namespace (tree);\n-extern tree namespace_ancestor (tree, tree);\n-extern tree push_using_directive (tree);\n extern void pushlevel_class (void);\n extern void poplevel_class (void);\n extern tree pushdecl_with_scope (tree, cxx_scope *);\n extern tree lookup_tag (enum tree_code, tree, cxx_scope *, int);\n extern tree lookup_tag_reverse (tree, tree);\n extern tree lookup_name\t(tree, int);\n extern tree lookup_name_real (tree, int, int, int, int);\n-extern tree lookup_name_current_level (tree);\n-extern tree lookup_type_current_level (tree);\n-extern bool lookup_using_namespace (tree, cxx_binding *, tree, tree, int, tree *);\n-extern bool qualified_lookup_using_namespace (tree, tree, cxx_binding *, int);\n extern tree namespace_binding (tree, tree);\n-extern void add_decl_to_level (tree, cxx_scope *);\n extern void set_namespace_binding (tree, tree, tree);\n extern tree lookup_namespace_name (tree, tree);\n-extern tree unqualified_namespace_lookup (tree, int, tree *);\n extern tree lookup_qualified_name (tree, tree, bool, bool);\n extern tree lookup_name_nonclass (tree);\n extern tree lookup_function_nonclass (tree, tree);\n-extern void push_local_binding (tree, tree, int);\n extern int push_class_binding (tree, tree);\n extern bool pushdecl_class_level (tree);\n extern tree pushdecl_namespace_level (tree);"}]}