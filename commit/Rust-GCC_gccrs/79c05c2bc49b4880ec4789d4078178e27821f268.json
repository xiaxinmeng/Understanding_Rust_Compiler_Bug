{"sha": "79c05c2bc49b4880ec4789d4078178e27821f268", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljMDVjMmJjNDliNDg4MGVjNDc4OWQ0MDc4MTc4ZTI3ODIxZjI2OA==", "commit": {"author": {"name": "Andrew Sutton", "email": "asutton@lock3software.com", "date": "2019-10-24T15:03:49Z"}, "committer": {"name": "Andrew Sutton", "email": "asutton@gcc.gnu.org", "date": "2019-10-24T15:03:49Z"}, "message": "Finish moving constraint and logic functionality of out pt.c.\n\nAlso, reimplement and re-enable subsumption caching.\n\ngcc/cp/\n\t* config-lang.in (gtfiles): Add logic.cc.\n\t* constraint.cc (atomic_constraints_identical_p): Add assertions.\n\t(hash_atomic_constraint): Likewise.\n\t(constraints_equivalent_p): New.\n\t(inchash::add_constraint): New.\n\t(iterative_hash_constraint): New.\n\t(decl_constraints): Moved from pt.c.\n\t(get_constraints): Likewise.\n\t(set_constraints): Likewise.\n\t(remove_constraints): Likewise.\n\t* cp-tree.h (CONSTR_P): New.\n\t(init_constraint_processing): Remove.\n\t(constraints_equivalent_p, iterative_hash_constraint): Declare.\n\t* decl.c (cxx_init_decl_processing): Don't initialize constraints.\n\t* logic.cc (subsumption_entry): Moved from pt.c.\n\t(subsumption_hasher): Likewise.\n\t(subsumption_cache): Likewise.\n\t(lookup_subsumption): Likewise.\n\t(save_subsumption): Likewise.\n\t(subsumes_constraints_nonnull): Use subsumption cache.\n\t* pt.c: Move aforementioned declarations out of this file.\n\t(init_constraint_processing): Remove.\n\nFrom-SVN: r277407", "tree": {"sha": "e26a1b04787b484f4bffdf08b8b1ebb70414beb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e26a1b04787b484f4bffdf08b8b1ebb70414beb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79c05c2bc49b4880ec4789d4078178e27821f268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c05c2bc49b4880ec4789d4078178e27821f268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c05c2bc49b4880ec4789d4078178e27821f268", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c05c2bc49b4880ec4789d4078178e27821f268/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4352288a3df915575a2b820f702242908740106f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4352288a3df915575a2b820f702242908740106f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4352288a3df915575a2b820f702242908740106f"}], "stats": {"total": 412, "additions": 244, "deletions": 168}, "files": [{"sha": "1917b8c4f595f94c8cc22247d091e08776534495", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=79c05c2bc49b4880ec4789d4078178e27821f268", "patch": "@@ -149,6 +149,34 @@\n \t* decl.c (cxx_maybe_build_cleanup): When clearing location of cleanup,\n \tif cleanup is a nop, clear location of its operand too.\n \n+2019-10-15  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tFinish moving constraint and logic functionality of out pt.c.\n+\tReimplement and re-enable subsumption caching.\n+\n+\t* config-lang.in (gtfiles): Add logic.cc.\n+\t* constraint.cc (atomic_constraints_identical_p): Add assertions.\n+\t(hash_atomic_constraint): Likewise.\n+\t(constraints_equivalent_p): New.\n+\t(inchash::add_constraint): New.\n+\t(iterative_hash_constraint): New.\n+\t(decl_constraints): Moved from pt.c.\n+\t(get_constraints): Likewise.\n+\t(set_constraints): Likewise.\n+\t(remove_constraints): Likewise.\n+\t* cp-tree.h (CONSTR_P): New.\n+\t(init_constraint_processing): Remove.\n+\t(constraints_equivalent_p, iterative_hash_constraint): Declare.\n+\t* decl.c (cxx_init_decl_processing): Don't initialize constraints.\n+\t* logic.cc (subsumption_entry): Moved from pt.c.\n+\t(subsumption_hasher): Likewise.\n+\t(subsumption_cache): Likewise.\n+\t(lookup_subsumption): Likewise.\n+\t(save_subsumption): Likewise.\n+\t(subsumes_constraints_nonnull): Use subsumption cache.\n+\t* pt.c: Move aforementioned declarations out of this file.\n+\t(init_constraint_processing): Remove.\n+\n 2019-10-15  Andrew Sutton  <asutton@lock3software.com>\n \n \t* parser.c (cp_parser_constructor_declarator_p): Pass an empty"}, {"sha": "0176866a045519e5c0ab644bb67f0d91877a08ba", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=79c05c2bc49b4880ec4789d4078178e27821f268", "patch": "@@ -46,7 +46,7 @@ gtfiles=\"\\\n \\$(srcdir)/cp/except.c \\\n \\$(srcdir)/cp/friend.c \\\n \\$(srcdir)/cp/init.c \\\n-\\$(srcdir)/cp/lambda.c \\$(srcdir)/cp/lex.c \\\n+\\$(srcdir)/cp/lambda.c \\$(srcdir)/cp/lex.c \\$(srcdir)/cp/logic.cc \\\n \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/method.c \\\n \\$(srcdir)/cp/name-lookup.c \\\n \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/pt.c \\"}, {"sha": "b8a2645d8c9d2b7254c8f039a16c3c503c03bcf4", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=79c05c2bc49b4880ec4789d4078178e27821f268", "patch": "@@ -905,6 +905,9 @@ normalize_constraint_expression (tree expr, bool diag = false)\n bool\n atomic_constraints_identical_p (tree t1, tree t2)\n {\n+  gcc_assert (TREE_CODE (t1) == ATOMIC_CONSTR);\n+  gcc_assert (TREE_CODE (t2) == ATOMIC_CONSTR);\n+\n   if (ATOMIC_CONSTR_EXPR (t1) != ATOMIC_CONSTR_EXPR (t2))\n     return false;\n \n@@ -914,9 +917,44 @@ atomic_constraints_identical_p (tree t1, tree t2)\n   return true;\n }\n \n+/* True if T1 and T2 are equivalent, meaning they have the same syntactic\n+   structure and all corresponding constraints are identical.  */\n+\n+bool\n+constraints_equivalent_p (tree t1, tree t2)\n+{\n+  gcc_assert (CONSTR_P (t1));\n+  gcc_assert (CONSTR_P (t2));\n+\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  switch (TREE_CODE (t1))\n+  {\n+  case CONJ_CONSTR:\n+  case DISJ_CONSTR:\n+    if (!constraints_equivalent_p (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0)))\n+      return false;\n+    if (!constraints_equivalent_p (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1)))\n+      return false;\n+    break;\n+  case ATOMIC_CONSTR:\n+    if (!atomic_constraints_identical_p(t1, t2))\n+      return false;\n+    break;\n+  default:\n+    gcc_unreachable ();\n+  }\n+  return true;\n+}\n+\n+/* Compute the hash value for T.  */\n+\n hashval_t\n hash_atomic_constraint (tree t)\n {\n+  gcc_assert (TREE_CODE (t) == ATOMIC_CONSTR);\n+\n   /* Hash the identity of the expression.  */\n   hashval_t val = htab_hash_pointer (ATOMIC_CONSTR_EXPR (t));\n \n@@ -931,6 +969,41 @@ hash_atomic_constraint (tree t)\n   return val;\n }\n \n+namespace inchash\n+{\n+\n+static void\n+add_constraint (tree t, hash& h)\n+{\n+  h.add_int(TREE_CODE (t));\n+  switch (TREE_CODE (t))\n+  {\n+  case CONJ_CONSTR:\n+  case DISJ_CONSTR:\n+    add_constraint (TREE_OPERAND (t, 0), h);\n+    add_constraint (TREE_OPERAND (t, 1), h);\n+    break;\n+  case ATOMIC_CONSTR:\n+    h.merge_hash (hash_atomic_constraint (t));\n+    break;\n+  default:\n+    gcc_unreachable ();\n+  }\n+}\n+\n+}\n+\n+/* Computes a hash code for the constraint T.  */\n+\n+hashval_t\n+iterative_hash_constraint (tree t, hashval_t val)\n+{\n+  gcc_assert (CONSTR_P (t));\n+  inchash::hash h (val);\n+  inchash::add_constraint (t, h);\n+  return h.end ();\n+}\n+\n // -------------------------------------------------------------------------- //\n // Constraint Semantic Processing\n //\n@@ -1017,6 +1090,61 @@ build_constraints (tree tr, tree dr)\n   return (tree)ci;\n }\n \n+/* A mapping from declarations to constraint information.  */\n+\n+static GTY ((cache)) tree_cache_map *decl_constraints;\n+\n+/* Returns the template constraints of declaration T. If T is not\n+   constrained, return NULL_TREE. Note that T must be non-null. */\n+\n+tree\n+get_constraints (tree t)\n+{\n+  if (!flag_concepts)\n+    return NULL_TREE;\n+  if (!decl_constraints)\n+    return NULL_TREE;\n+\n+  gcc_assert (DECL_P (t));\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+  tree* found = decl_constraints->get (t);\n+  if (found)\n+    return *found;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Associate the given constraint information CI with the declaration\n+   T. If T is a template, then the constraints are associated with\n+   its underlying declaration. Don't build associations if CI is\n+   NULL_TREE.  */\n+\n+void\n+set_constraints (tree t, tree ci)\n+{\n+  if (!ci)\n+    return;\n+  gcc_assert (t && flag_concepts);\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+  bool found = hash_map_safe_put<hm_ggc> (decl_constraints, t, ci);\n+  gcc_assert (!found);\n+}\n+\n+/* Remove the associated constraints of the declaration T.  */\n+\n+void\n+remove_constraints (tree t)\n+{\n+  gcc_assert (DECL_P (t));\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+\n+  if (decl_constraints)\n+    decl_constraints->remove (t);\n+}\n+\n /* Returns the template-head requires clause for the template\n    declaration T or NULL_TREE if none.  */\n "}, {"sha": "7e0c41c222e267f23474ec7d71f437111cb6edbf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=79c05c2bc49b4880ec4789d4078178e27821f268", "patch": "@@ -1551,6 +1551,12 @@ check_constraint_info (tree t)\n #define PLACEHOLDER_TYPE_CONSTRAINTS(NODE) \\\n   DECL_SIZE_UNIT (TYPE_NAME (NODE))\n \n+/* True if NODE is a constraint.  */\n+#define CONSTR_P(NODE)                  \\\n+  (TREE_CODE (NODE) == ATOMIC_CONSTR    \\\n+   || TREE_CODE (NODE) == CONJ_CONSTR   \\\n+   || TREE_CODE (NODE) == DISJ_CONSTR)\n+\n /* Valid for any normalized constraint.  */\n #define CONSTR_CHECK(NODE) \\\n   TREE_CHECK3 (NODE, ATOMIC_CONSTR, CONJ_CONSTR, DISJ_CONSTR)\n@@ -7693,7 +7699,6 @@ struct diagnosing_failed_constraint\n \n /* in constraint.cc */\n \n-extern void init_constraint_processing\t\t();\n extern cp_expr finish_constraint_or_expr\t(location_t, cp_expr, cp_expr);\n extern cp_expr finish_constraint_and_expr\t(location_t, cp_expr, cp_expr);\n extern cp_expr finish_constraint_primary_expr\t(cp_expr);\n@@ -7761,8 +7766,10 @@ extern bool subsumes_constraints                (tree, tree);\n extern bool strictly_subsumes\t\t\t(tree, tree, tree);\n extern bool weakly_subsumes\t\t\t(tree, tree, tree);\n extern int more_constrained                     (tree, tree);\n+extern bool constraints_equivalent_p            (tree, tree);\n extern bool atomic_constraints_identical_p\t(tree, tree);\n-extern hashval_t hash_atomic_constraint\t\t(tree);\n+extern hashval_t iterative_hash_constraint      (tree, hashval_t);\n+extern hashval_t hash_atomic_constraint         (tree);\n extern void diagnose_constraints                (location_t, tree, tree);\n \n /* in logic.cc */"}, {"sha": "6c90b1d030a7a7603a118d64af22c0e698e05759", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=79c05c2bc49b4880ec4789d4078178e27821f268", "patch": "@@ -4409,9 +4409,6 @@ cxx_init_decl_processing (void)\n     /* Ensure attribs.c is initialized.  */\n     init_attributes ();\n \n-    /* Ensure constraint.cc is initialized. */\n-    init_constraint_processing ();\n-\n     extvisattr = build_tree_list (get_identifier (\"externally_visible\"),\n \t\t\t\t  NULL_TREE);\n     newattrs = tree_cons (get_identifier (\"alloc_size\"),"}, {"sha": "ee68b54c0adb4aeb704550b997e5a52f5fefa62e", "filename": "gcc/cp/logic.cc", "status": "modified", "additions": 78, "deletions": 5, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Flogic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Flogic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flogic.cc?ref=79c05c2bc49b4880ec4789d4078178e27821f268", "patch": "@@ -780,6 +780,73 @@ diagnose_constraint_size (tree t)\n   return false;\n }\n \n+/* Key/value pair for caching subsumption results. This associates a pair of\n+   constraints with a boolean value indicating the result.  */\n+\n+struct GTY((for_user)) subsumption_entry\n+{\n+  tree lhs;\n+  tree rhs;\n+  bool result;\n+};\n+\n+/* Hashing function and equality for constraint entries.  */\n+\n+struct subsumption_hasher : ggc_ptr_hash<subsumption_entry>\n+{\n+  static hashval_t hash (subsumption_entry *e)\n+  {\n+    hashval_t val = 0;\n+    val = iterative_hash_constraint (e->lhs, val);\n+    val = iterative_hash_constraint (e->rhs, val);\n+    return val;\n+  }\n+\n+  static bool equal (subsumption_entry *e1, subsumption_entry *e2)\n+  {\n+    if (!constraints_equivalent_p (e1->lhs, e2->lhs))\n+      return false;\n+    if (!constraints_equivalent_p (e1->rhs, e2->rhs))\n+      return false;\n+    return true;\n+  }\n+};\n+\n+/* Caches the results of subsumes_non_null(t1, t1).  */\n+\n+static GTY ((deletable)) hash_table<subsumption_hasher> *subsumption_cache;\n+\n+/* Search for a previously cached subsumption result. */\n+\n+static bool*\n+lookup_subsumption (tree t1, tree t2)\n+{\n+  if (!subsumption_cache)\n+    return NULL;\n+  subsumption_entry elt = { t1, t2, false };\n+  subsumption_entry* found = subsumption_cache->find (&elt);\n+  if (found)\n+    return &found->result;\n+  else\n+    return 0;\n+}\n+\n+/* Save a subsumption result. */\n+\n+static bool\n+save_subsumption (tree t1, tree t2, bool result)\n+{\n+  if (!subsumption_cache)\n+    subsumption_cache = hash_table<subsumption_hasher>::create_ggc(31);\n+  subsumption_entry elt = {t1, t2, result};\n+  subsumption_entry** slot = subsumption_cache->find_slot (&elt, INSERT);\n+  subsumption_entry* entry = ggc_alloc<subsumption_entry> ();\n+  *entry = elt;\n+  *slot = entry;\n+  return result;\n+}\n+\n+\n /* Returns true if the LEFT constraint subsume the RIGHT constraints.\n    This is done by deriving a proof of the conclusions on the RIGHT\n    from the assumptions on the LEFT assumptions.  */\n@@ -789,6 +856,9 @@ subsumes_constraints_nonnull (tree lhs, tree rhs)\n {\n   auto_timevar time (TV_CONSTRAINT_SUB);\n \n+  if (bool *b = lookup_subsumption(lhs, rhs))\n+    return *b;\n+\n   int n1 = dnf_size (lhs);\n   int n2 = cnf_size (rhs);\n \n@@ -803,19 +873,20 @@ subsumes_constraints_nonnull (tree lhs, tree rhs)\n     }\n \n   /* Decompose the smaller of the two formulas, and recursively\n-     check the implication using the larger.  Note that for\n-     constraints that are largely comprised of conjunctions the\n-     it will usually be the case that n1 <= n2. */\n+     check for implication of the larger.  */\n+  bool result;\n   if (n1 <= n2)\n     {\n       formula dnf = decompose_antecedents (lhs);\n-      return derive_proofs (dnf, rhs, left);\n+      result = derive_proofs (dnf, rhs, left);\n     }\n   else\n     {\n       formula cnf = decompose_consequents (rhs);\n-      return derive_proofs (cnf, lhs, right);\n+      result = derive_proofs (cnf, lhs, right);\n     }\n+\n+  return save_subsumption (lhs, rhs, result);\n }\n \n /* Returns true if the LEFT constraints subsume the RIGHT\n@@ -832,3 +903,5 @@ subsumes (tree lhs, tree rhs)\n     return true;\n   return subsumes_constraints_nonnull (lhs, rhs);\n }\n+\n+#include \"gt-cp-logic.h\""}, {"sha": "095bc32c542d446086987a60cbcadf8cb78f4c71", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c05c2bc49b4880ec4789d4078178e27821f268/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=79c05c2bc49b4880ec4789d4078178e27821f268", "patch": "@@ -28483,163 +28483,6 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n   return tsubst (parm, replacement, tf_none, NULL_TREE);\n }\n \n-/* A mapping from declarations to constraint information. Note that\n-   both templates and their underlying declarations are mapped to the\n-   same constraint information.\n-\n-   FIXME: This is defined in pt.c because garbage collection\n-   code is not being generated for constraint.cc. */\n-\n-static GTY ((cache)) tree_cache_map *decl_constraints;\n-\n-/* Returns the template constraints of declaration T. If T is not\n-   constrained, return NULL_TREE. Note that T must be non-null. */\n-\n-tree\n-get_constraints (tree t)\n-{\n-  if (!flag_concepts)\n-    return NULL_TREE;\n-  if (!decl_constraints)\n-    return NULL_TREE;\n-\n-  gcc_assert (DECL_P (t));\n-  if (TREE_CODE (t) == TEMPLATE_DECL)\n-    t = DECL_TEMPLATE_RESULT (t);\n-  tree* found = decl_constraints->get (t);\n-  if (found)\n-    return *found;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Associate the given constraint information CI with the declaration\n-   T. If T is a template, then the constraints are associated with\n-   its underlying declaration. Don't build associations if CI is\n-   NULL_TREE.  */\n-\n-void\n-set_constraints (tree t, tree ci)\n-{\n-  if (!ci)\n-    return;\n-  gcc_assert (t && flag_concepts);\n-  if (TREE_CODE (t) == TEMPLATE_DECL)\n-    t = DECL_TEMPLATE_RESULT (t);\n-  bool found = hash_map_safe_put<hm_ggc> (decl_constraints, t, ci);\n-  gcc_assert (!found);\n-}\n-\n-/* Remove the associated constraints of the declaration T.  */\n-\n-void\n-remove_constraints (tree t)\n-{\n-  gcc_assert (DECL_P (t));\n-  if (TREE_CODE (t) == TEMPLATE_DECL)\n-    t = DECL_TEMPLATE_RESULT (t);\n-\n-  if (decl_constraints)\n-    decl_constraints->remove (t);\n-}\n-\n-static hashval_t\n-hash_subsumption_args (tree t1, tree t2)\n-{\n-  gcc_assert (TREE_CODE (t1) == CHECK_CONSTR);\n-  gcc_assert (TREE_CODE (t2) == CHECK_CONSTR);\n-  int val = 0;\n-  val = iterative_hash_object (CHECK_CONSTR_CONCEPT (t1), val);\n-  val = iterative_hash_template_arg (CHECK_CONSTR_ARGS (t1), val);\n-  val = iterative_hash_object (CHECK_CONSTR_CONCEPT (t2), val);\n-  val = iterative_hash_template_arg (CHECK_CONSTR_ARGS (t2), val);\n-  return val;\n-}\n-\n-/* Compare the constraints of two subsumption entries.  The LEFT1 and\n-   LEFT2 arguments comprise the first subsumption pair and the RIGHT1\n-   and RIGHT2 arguments comprise the second. These are all CHECK_CONSTRs. */\n-\n-static bool\n-comp_subsumption_args (tree left1, tree left2, tree right1, tree right2)\n-{\n-  if (CHECK_CONSTR_CONCEPT (left1) == CHECK_CONSTR_CONCEPT (right1))\n-    if (CHECK_CONSTR_CONCEPT (left2) == CHECK_CONSTR_CONCEPT (right2))\n-      if (comp_template_args (CHECK_CONSTR_ARGS (left1),\n-                             CHECK_CONSTR_ARGS (right1)))\n-        return comp_template_args (CHECK_CONSTR_ARGS (left2),\n-                                  CHECK_CONSTR_ARGS (right2));\n-  return false;\n-}\n-\n-/* Key/value pair for learning and memoizing subsumption results. This\n-   associates a pair of check constraints (including arguments) with\n-   a boolean value indicating the result.  */\n-\n-struct GTY((for_user)) subsumption_entry\n-{\n-  tree t1;\n-  tree t2;\n-  bool result;\n-};\n-\n-/* Hashing function and equality for constraint entries.  */\n-\n-struct subsumption_hasher : ggc_ptr_hash<subsumption_entry>\n-{\n-  static hashval_t hash (subsumption_entry *e)\n-  {\n-    return hash_subsumption_args (e->t1, e->t2);\n-  }\n-\n-  static bool equal (subsumption_entry *e1, subsumption_entry *e2)\n-  {\n-    ++comparing_specializations;\n-    bool eq = comp_subsumption_args(e1->t1, e1->t2, e2->t1, e2->t2);\n-    --comparing_specializations;\n-    return eq;\n-  }\n-};\n-\n-static GTY (()) hash_table<subsumption_hasher> *subsumption_table;\n-\n-/* Search for a previously cached subsumption result. */\n-\n-bool*\n-lookup_subsumption_result (tree t1, tree t2)\n-{\n-  subsumption_entry elt = { t1, t2, false };\n-  subsumption_entry* found = subsumption_table->find (&elt);\n-  if (found)\n-    return &found->result;\n-  else\n-    return 0;\n-}\n-\n-/* Save a subsumption result. */\n-\n-bool\n-save_subsumption_result (tree t1, tree t2, bool result)\n-{\n-  subsumption_entry elt = {t1, t2, result};\n-  subsumption_entry** slot = subsumption_table->find_slot (&elt, INSERT);\n-  subsumption_entry* entry = ggc_alloc<subsumption_entry> ();\n-  *entry = elt;\n-  *slot = entry;\n-  return result;\n-}\n-\n-/* Set up the hash table for constraint association. */\n-\n-void\n-init_constraint_processing (void)\n-{\n-  if (!flag_concepts)\n-    return;\n-\n-  subsumption_table = hash_table<subsumption_hasher>::create_ggc(37);\n-}\n-\n GTY(()) tree current_failed_constraint;\n \n /* __integer_pack(N) in a pack expansion expands to a sequence of numbers from"}]}