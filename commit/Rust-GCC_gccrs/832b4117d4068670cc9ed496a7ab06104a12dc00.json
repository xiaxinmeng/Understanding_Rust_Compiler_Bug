{"sha": "832b4117d4068670cc9ed496a7ab06104a12dc00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMyYjQxMTdkNDA2ODY3MGNjOWVkNDk2YTdhYjA2MTA0YTEyZGMwMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-03T13:36:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-03T13:36:45Z"}, "message": "Add DR_STEP_ALIGNMENT\n\nA later patch adds base alignment information to innermost_loop_behavior.\nAfter that, the only remaining piece of alignment information that wasn't\nimmediately obvious was the step alignment.  Adding that allows a minor\nsimplification to vect_compute_data_ref_alignment, and also potentially\nimproves the handling of variable strides for outer loop vectorisation.\nA later patch will also use it to give the alignment of the DR as a whole.\n\n2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-data-ref.h (innermost_loop_behavior): Add a step_alignment\n\tfield.\n\t(DR_STEP_ALIGNMENT): New macro.\n\t* tree-vectorizer.h (STMT_VINFO_DR_STEP_ALIGNMENT): Likewise.\n\t* tree-data-ref.c (dr_analyze_innermost): Initalize step_alignment.\n\t(create_data_ref): Print it.\n\t* tree-vect-stmts.c (vectorizable_load): Use the step alignment\n\tto tell whether the step preserves vector (mis)alignment.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Likewise.\n\tMove the check for an integer step and generalise to all INTEGER_CST.\n\t(vect_analyze_data_refs): Set DR_STEP_ALIGNMENT when setting DR_STEP.\n\tPrint the outer step alignment.\n\nFrom-SVN: r249915", "tree": {"sha": "212a6cb0ef5981580051a51ecd93ab60de8b92c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/212a6cb0ef5981580051a51ecd93ab60de8b92c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/832b4117d4068670cc9ed496a7ab06104a12dc00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832b4117d4068670cc9ed496a7ab06104a12dc00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/832b4117d4068670cc9ed496a7ab06104a12dc00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832b4117d4068670cc9ed496a7ab06104a12dc00/comments", "author": null, "committer": null, "parents": [{"sha": "e054a1852bf903139a80f34c726453d34338e008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e054a1852bf903139a80f34c726453d34338e008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e054a1852bf903139a80f34c726453d34338e008"}], "stats": {"total": 46, "additions": 36, "deletions": 10}, "files": [{"sha": "42a8bc0bf905ea0d16d25b4f29de5c349e2fcb49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=832b4117d4068670cc9ed496a7ab06104a12dc00", "patch": "@@ -1,3 +1,18 @@\n+2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-data-ref.h (innermost_loop_behavior): Add a step_alignment\n+\tfield.\n+\t(DR_STEP_ALIGNMENT): New macro.\n+\t* tree-vectorizer.h (STMT_VINFO_DR_STEP_ALIGNMENT): Likewise.\n+\t* tree-data-ref.c (dr_analyze_innermost): Initalize step_alignment.\n+\t(create_data_ref): Print it.\n+\t* tree-vect-stmts.c (vectorizable_load): Use the step alignment\n+\tto tell whether the step preserves vector (mis)alignment.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Likewise.\n+\tMove the check for an integer step and generalise to all INTEGER_CST.\n+\t(vect_analyze_data_refs): Set DR_STEP_ALIGNMENT when setting DR_STEP.\n+\tPrint the outer step alignment.\n+\n 2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-data-ref.h (innermost_loop_behavior): Replace aligned_to"}, {"sha": "03dfb2046850aa7b485a02e4692c332d366d7a46", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=832b4117d4068670cc9ed496a7ab06104a12dc00", "patch": "@@ -870,6 +870,7 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n   drb->init = init;\n   drb->step = step;\n   drb->offset_alignment = highest_pow2_factor (offset_iv.base);\n+  drb->step_alignment = highest_pow2_factor (step);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"success.\\n\");\n@@ -1086,6 +1087,7 @@ create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n       print_generic_expr (dump_file, DR_STEP (dr), TDF_SLIM);\n       fprintf (dump_file, \"\\n\\toffset alignment: %d\",\n \t       DR_OFFSET_ALIGNMENT (dr));\n+      fprintf (dump_file, \"\\n\\tstep alignment: %d\", DR_STEP_ALIGNMENT (dr));\n       fprintf (dump_file, \"\\n\\tbase_object: \");\n       print_generic_expr (dump_file, DR_BASE_OBJECT (dr), TDF_SLIM);\n       fprintf (dump_file, \"\\n\");"}, {"sha": "3a5068d3a1fdefaa4563d72181d6667b06aa25d9", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=832b4117d4068670cc9ed496a7ab06104a12dc00", "patch": "@@ -56,6 +56,9 @@ struct innermost_loop_behavior\n      high value if the offset is zero.  This is a byte rather than a bit\n      quantity.  */\n   unsigned int offset_alignment;\n+\n+  /* Likewise for STEP.  */\n+  unsigned int step_alignment;\n };\n \n /* Describes the evolutions of indices of the memory reference.  The indices\n@@ -145,6 +148,7 @@ struct data_reference\n #define DR_STEP(DR)                (DR)->innermost.step\n #define DR_PTR_INFO(DR)            (DR)->alias.ptr_info\n #define DR_OFFSET_ALIGNMENT(DR)    (DR)->innermost.offset_alignment\n+#define DR_STEP_ALIGNMENT(DR)      (DR)->innermost.step_alignment\n #define DR_INNERMOST(DR)           (DR)->innermost\n \n typedef struct data_reference *data_reference_p;"}, {"sha": "9ee53ec9879986688efef69be68e8f9de3df182f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=832b4117d4068670cc9ed496a7ab06104a12dc00", "patch": "@@ -698,10 +698,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n      divides by the vector size.  */\n   else if (nested_in_vect_loop_p (loop, stmt))\n     {\n-      tree step = DR_STEP (dr);\n       step_preserves_misalignment_p\n-\t= (tree_fits_shwi_p (step)\n-\t   && tree_to_shwi (step) % GET_MODE_SIZE (TYPE_MODE (vectype)) == 0);\n+\t= (DR_STEP_ALIGNMENT (dr)\n+\t   % GET_MODE_SIZE (TYPE_MODE (vectype))) == 0;\n \n       if (dump_enabled_p ())\n \t{\n@@ -720,12 +719,10 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n      the dataref evenly divides by the vector size.  */\n   else\n     {\n-      tree step = DR_STEP (dr);\n       unsigned vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       step_preserves_misalignment_p\n-\t= (tree_fits_shwi_p (step)\n-\t   && ((tree_to_shwi (step) * vf)\n-\t       % GET_MODE_SIZE (TYPE_MODE (vectype)) == 0));\n+\t= ((DR_STEP_ALIGNMENT (dr) * vf)\n+\t   % GET_MODE_SIZE (TYPE_MODE (vectype))) == 0;\n \n       if (!step_preserves_misalignment_p && dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -773,7 +770,10 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   alignment = TYPE_ALIGN_UNIT (vectype);\n \n   if (drb->offset_alignment < alignment\n-      || !step_preserves_misalignment_p)\n+      || !step_preserves_misalignment_p\n+      /* We need to know whether the step wrt the vectorized loop is\n+\t negative when computing the starting misalignment below.  */\n+      || TREE_CODE (drb->step) != INTEGER_CST)\n     {\n       if (dump_enabled_p ())\n \t{\n@@ -3414,6 +3414,8 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \t\t\t\t      DR_STEP (newdr) = step;\n \t\t\t\t      DR_OFFSET_ALIGNMENT (newdr)\n \t\t\t\t\t= BIGGEST_ALIGNMENT;\n+\t\t\t\t      DR_STEP_ALIGNMENT (newdr)\n+\t\t\t\t\t= highest_pow2_factor (step);\n \t\t\t\t      dr = newdr;\n \t\t\t\t      simd_lane_access = true;\n \t\t\t\t    }\n@@ -3665,6 +3667,8 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n                                  STMT_VINFO_DR_STEP (stmt_info));\n \t      dump_printf (MSG_NOTE, \"\\n\\touter offset alignment: %d\\n\",\n \t\t\t   STMT_VINFO_DR_OFFSET_ALIGNMENT (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\\touter step alignment: %d\\n\",\n+\t\t\t   STMT_VINFO_DR_STEP_ALIGNMENT (stmt_info));\n \t    }\n \t}\n "}, {"sha": "f01f297eaeb7be6bece6ab9fa9adc9dcb3381bc4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=832b4117d4068670cc9ed496a7ab06104a12dc00", "patch": "@@ -7288,8 +7288,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n      nested within an outer-loop that is being vectorized.  */\n \n   if (nested_in_vect_loop\n-      && (TREE_INT_CST_LOW (DR_STEP (dr))\n-\t  % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0))\n+      && (DR_STEP_ALIGNMENT (dr) % GET_MODE_SIZE (TYPE_MODE (vectype))) != 0)\n     {\n       gcc_assert (alignment_support_scheme != dr_explicit_realign_optimized);\n       compute_in_loop = true;"}, {"sha": "fba5151654dc27cdcdb8b2bfa107a518e50baf46", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832b4117d4068670cc9ed496a7ab06104a12dc00/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=832b4117d4068670cc9ed496a7ab06104a12dc00", "patch": "@@ -711,6 +711,8 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_DR_STEP(S)              (S)->dr_wrt_vec_loop.step\n #define STMT_VINFO_DR_OFFSET_ALIGNMENT(S) \\\n   (S)->dr_wrt_vec_loop.offset_alignment\n+#define STMT_VINFO_DR_STEP_ALIGNMENT(S) \\\n+  (S)->dr_wrt_vec_loop.step_alignment\n \n #define STMT_VINFO_IN_PATTERN_P(S)         (S)->in_pattern_p\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt"}]}