{"sha": "50ac25005f8b8c8bb91d74a6f1895bc5e11e8680", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBhYzI1MDA1ZjhiOGM4YmI5MWQ3NGE2ZjE4OTViYzVlMTFlODY4MA==", "commit": {"author": {"name": "Kyle Galloway", "email": "kgallowa@gcc.gnu.org", "date": "2006-08-15T20:40:10Z"}, "committer": {"name": "Kyle Galloway", "email": "kgallowa@gcc.gnu.org", "date": "2006-08-15T20:40:10Z"}, "message": "java-interp.h (_Jv_InterpMethod::run_debug): New method.\n\n2006-08-15  Kyle Galloway  <kgallowa@redhat.com>\n\n  * include/java-interp.h (_Jv_InterpMethod::run_debug): New method.\n  * interpret.cc: Added placeholder for debug variable type info to STORE*\n  macros.\n  (_Jv_InterpMethod::run_debug): New method.\n  (_Jv_InterpMethod::run_sync_object_debug): New method.\n  (_Jv_InterpMethod::run_sync_class_debug): New method.\n  (_Jv_InterpMethod::run_normal_debug): New method.\n  (_Jv_InterpMethod::run_class_debug): New method.\n  (_Jv_InterpMethod::ncode ()): Changed to select either debug or normal\n  versions of these functions.\n  * interpret-run.cc: New file, holds contents of old \t\n  _Jv_InterpMethod::run method.\n  * stacktrace.cc (_Jv_StackTrace::UnwindTraceFn): Changed to select\n  appropriate function for debug or normal mode.\n\nFrom-SVN: r116167", "tree": {"sha": "d7ad1399148e8d614e2fe328c387031a515b8fb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7ad1399148e8d614e2fe328c387031a515b8fb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/comments", "author": null, "committer": null, "parents": [{"sha": "4adb785d4481822edd5350f38b3fd2d3bcbfddca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4adb785d4481822edd5350f38b3fd2d3bcbfddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4adb785d4481822edd5350f38b3fd2d3bcbfddca"}], "stats": {"total": 5527, "additions": 2842, "deletions": 2685}, "files": [{"sha": "efb8b414200c35fb92e64ae2ea37a15b0d09b42b", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=50ac25005f8b8c8bb91d74a6f1895bc5e11e8680", "patch": "@@ -176,21 +176,31 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   static void run_synch_object (ffi_cif*, void*, ffi_raw*, void*);\n   static void run_class (ffi_cif*, void*, ffi_raw*, void*);\n   static void run_synch_class (ffi_cif*, void*, ffi_raw*, void*);\n+  \n+  static void run_normal_debug (ffi_cif*, void*, ffi_raw*, void*);\n+  static void run_synch_object_debug (ffi_cif*, void*, ffi_raw*, void*);\n+  static void run_class_debug (ffi_cif*, void*, ffi_raw*, void*);\n+  static void run_synch_class_debug (ffi_cif*, void*, ffi_raw*, void*);\n \n-  static void run (void*, ffi_raw *, _Jv_InterpMethod *);\n+  static void run (void *, ffi_raw *, _Jv_InterpMethod *);\n+  static void run_debug (void *, ffi_raw *, _Jv_InterpMethod *);\n+  \n \n+  \n   // Returns source file line number for given PC value, or -1 if line\n   // number info is unavailable.\n   int get_source_line(pc_t mpc);\n \n+\n+\n #ifdef DIRECT_THREADED\n   // Convenience function for indexing bytecode PC/insn slots in\n   // line tables for JDWP\n   jlong insn_index (pc_t pc);\n #endif\n-\n- public:\n-\n+  \n+   public:\n+   \n   /* Get the line table for this method.\n    * start  is the lowest index in the method\n    * end    is the  highest index in the method"}, {"sha": "ee9fcad5a68c6a1d6def64320d007818069e17f9", "filename": "libjava/interpret-run.cc", "status": "added", "additions": 2508, "deletions": 0, "changes": 2508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Finterpret-run.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Finterpret-run.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret-run.cc?ref=50ac25005f8b8c8bb91d74a6f1895bc5e11e8680", "patch": "@@ -0,0 +1,2508 @@\n+// interpret-run.cc - Code to interpret bytecode\n+\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* This file is meant only to be included in interpret.cc, it should not be\n+ * compiled directly.\t*/\n+\n+  using namespace java::lang::reflect;\n+\n+  // FRAME_DESC registers this particular invocation as the top-most\n+  // interpreter frame.  This lets the stack tracing code (for\n+  // Throwable) print information about the method being interpreted\n+  // rather than about the interpreter itself.  FRAME_DESC has a\n+  // destructor so it cleans up automatically when the interpreter\n+  // returns.\n+  java::lang::Thread *thread = java::lang::Thread::currentThread();\n+  _Jv_InterpFrame frame_desc (meth, thread);\n+\n+  _Jv_word stack[meth->max_stack];\n+  _Jv_word *sp = stack;\n+\n+  _Jv_word locals[meth->max_locals];\n+\n+#define INSN_LABEL(op) &&insn_##op\n+\n+  static const void *const insn_target[] = \n+  {\n+    INSN_LABEL(nop),\n+    INSN_LABEL(aconst_null),\n+    INSN_LABEL(iconst_m1),\n+    INSN_LABEL(iconst_0),\n+    INSN_LABEL(iconst_1),\n+    INSN_LABEL(iconst_2),\n+    INSN_LABEL(iconst_3),\n+    INSN_LABEL(iconst_4),\n+    INSN_LABEL(iconst_5),\n+    INSN_LABEL(lconst_0),\n+    INSN_LABEL(lconst_1),\n+    INSN_LABEL(fconst_0),\n+    INSN_LABEL(fconst_1),\n+    INSN_LABEL(fconst_2),\n+    INSN_LABEL(dconst_0),\n+    INSN_LABEL(dconst_1),\n+    INSN_LABEL(bipush),\n+    INSN_LABEL(sipush),\n+    INSN_LABEL(ldc),\n+    INSN_LABEL(ldc_w),\n+    INSN_LABEL(ldc2_w),\n+    INSN_LABEL(iload),\n+    INSN_LABEL(lload),\n+    INSN_LABEL(fload),\n+    INSN_LABEL(dload),\n+    INSN_LABEL(aload),\n+    INSN_LABEL(iload_0),\n+    INSN_LABEL(iload_1),\n+    INSN_LABEL(iload_2),\n+    INSN_LABEL(iload_3),\n+    INSN_LABEL(lload_0),\n+    INSN_LABEL(lload_1),\n+    INSN_LABEL(lload_2),\n+    INSN_LABEL(lload_3),\n+    INSN_LABEL(fload_0),\n+    INSN_LABEL(fload_1),\n+    INSN_LABEL(fload_2),\n+    INSN_LABEL(fload_3),\n+    INSN_LABEL(dload_0),\n+    INSN_LABEL(dload_1),\n+    INSN_LABEL(dload_2),\n+    INSN_LABEL(dload_3),\n+    INSN_LABEL(aload_0),\n+    INSN_LABEL(aload_1),\n+    INSN_LABEL(aload_2),\n+    INSN_LABEL(aload_3),\n+    INSN_LABEL(iaload),\n+    INSN_LABEL(laload),\n+    INSN_LABEL(faload),\n+    INSN_LABEL(daload),\n+    INSN_LABEL(aaload),\n+    INSN_LABEL(baload),\n+    INSN_LABEL(caload),\n+    INSN_LABEL(saload),\n+    INSN_LABEL(istore),\n+    INSN_LABEL(lstore),\n+    INSN_LABEL(fstore),\n+    INSN_LABEL(dstore),\n+    INSN_LABEL(astore),\n+    INSN_LABEL(istore_0),\n+    INSN_LABEL(istore_1),\n+    INSN_LABEL(istore_2),\n+    INSN_LABEL(istore_3),\n+    INSN_LABEL(lstore_0),\n+    INSN_LABEL(lstore_1),\n+    INSN_LABEL(lstore_2),\n+    INSN_LABEL(lstore_3),\n+    INSN_LABEL(fstore_0),\n+    INSN_LABEL(fstore_1),\n+    INSN_LABEL(fstore_2),\n+    INSN_LABEL(fstore_3),\n+    INSN_LABEL(dstore_0),\n+    INSN_LABEL(dstore_1),\n+    INSN_LABEL(dstore_2),\n+    INSN_LABEL(dstore_3),\n+    INSN_LABEL(astore_0),\n+    INSN_LABEL(astore_1),\n+    INSN_LABEL(astore_2),\n+    INSN_LABEL(astore_3),\n+    INSN_LABEL(iastore),\n+    INSN_LABEL(lastore),\n+    INSN_LABEL(fastore),\n+    INSN_LABEL(dastore),\n+    INSN_LABEL(aastore),\n+    INSN_LABEL(bastore),\n+    INSN_LABEL(castore),\n+    INSN_LABEL(sastore),\n+    INSN_LABEL(pop),\n+    INSN_LABEL(pop2),\n+    INSN_LABEL(dup),\n+    INSN_LABEL(dup_x1),\n+    INSN_LABEL(dup_x2),\n+    INSN_LABEL(dup2),\n+    INSN_LABEL(dup2_x1),\n+    INSN_LABEL(dup2_x2),\n+    INSN_LABEL(swap),\n+    INSN_LABEL(iadd),\n+    INSN_LABEL(ladd),\n+    INSN_LABEL(fadd),\n+    INSN_LABEL(dadd),\n+    INSN_LABEL(isub),\n+    INSN_LABEL(lsub),\n+    INSN_LABEL(fsub),\n+    INSN_LABEL(dsub),\n+    INSN_LABEL(imul),\n+    INSN_LABEL(lmul),\n+    INSN_LABEL(fmul),\n+    INSN_LABEL(dmul),\n+    INSN_LABEL(idiv),\n+    INSN_LABEL(ldiv),\n+    INSN_LABEL(fdiv),\n+    INSN_LABEL(ddiv),\n+    INSN_LABEL(irem),\n+    INSN_LABEL(lrem),\n+    INSN_LABEL(frem),\n+    INSN_LABEL(drem),\n+    INSN_LABEL(ineg),\n+    INSN_LABEL(lneg),\n+    INSN_LABEL(fneg),\n+    INSN_LABEL(dneg),\n+    INSN_LABEL(ishl),\n+    INSN_LABEL(lshl),\n+    INSN_LABEL(ishr),\n+    INSN_LABEL(lshr),\n+    INSN_LABEL(iushr),\n+    INSN_LABEL(lushr),\n+    INSN_LABEL(iand),\n+    INSN_LABEL(land),\n+    INSN_LABEL(ior),\n+    INSN_LABEL(lor),\n+    INSN_LABEL(ixor),\n+    INSN_LABEL(lxor),\n+    INSN_LABEL(iinc),\n+    INSN_LABEL(i2l),\n+    INSN_LABEL(i2f),\n+    INSN_LABEL(i2d),\n+    INSN_LABEL(l2i),\n+    INSN_LABEL(l2f),\n+    INSN_LABEL(l2d),\n+    INSN_LABEL(f2i),\n+    INSN_LABEL(f2l),\n+    INSN_LABEL(f2d),\n+    INSN_LABEL(d2i),\n+    INSN_LABEL(d2l),\n+    INSN_LABEL(d2f),\n+    INSN_LABEL(i2b),\n+    INSN_LABEL(i2c),\n+    INSN_LABEL(i2s),\n+    INSN_LABEL(lcmp),\n+    INSN_LABEL(fcmpl),\n+    INSN_LABEL(fcmpg),\n+    INSN_LABEL(dcmpl),\n+    INSN_LABEL(dcmpg),\n+    INSN_LABEL(ifeq),\n+    INSN_LABEL(ifne),\n+    INSN_LABEL(iflt),\n+    INSN_LABEL(ifge),\n+    INSN_LABEL(ifgt),\n+    INSN_LABEL(ifle),\n+    INSN_LABEL(if_icmpeq),\n+    INSN_LABEL(if_icmpne),\n+    INSN_LABEL(if_icmplt),\n+    INSN_LABEL(if_icmpge),\n+    INSN_LABEL(if_icmpgt),\n+    INSN_LABEL(if_icmple),\n+    INSN_LABEL(if_acmpeq),\n+    INSN_LABEL(if_acmpne),\n+    INSN_LABEL(goto), \n+    INSN_LABEL(jsr),\n+    INSN_LABEL(ret),\n+    INSN_LABEL(tableswitch),\n+    INSN_LABEL(lookupswitch),\n+    INSN_LABEL(ireturn),\n+    INSN_LABEL(lreturn),\n+    INSN_LABEL(freturn),\n+    INSN_LABEL(dreturn),\n+    INSN_LABEL(areturn),\n+    INSN_LABEL(return),\n+    INSN_LABEL(getstatic),\n+    INSN_LABEL(putstatic),\n+    INSN_LABEL(getfield),\n+    INSN_LABEL(putfield),\n+    INSN_LABEL(invokevirtual),\n+    INSN_LABEL(invokespecial),\n+    INSN_LABEL(invokestatic),\n+    INSN_LABEL(invokeinterface),\n+    0, /* Unused.  */\n+    INSN_LABEL(new),\n+    INSN_LABEL(newarray),\n+    INSN_LABEL(anewarray),\n+    INSN_LABEL(arraylength),\n+    INSN_LABEL(athrow),\n+    INSN_LABEL(checkcast),\n+    INSN_LABEL(instanceof),\n+    INSN_LABEL(monitorenter),\n+    INSN_LABEL(monitorexit),\n+#ifdef DIRECT_THREADED\n+    0, // wide\n+#else\n+    INSN_LABEL(wide),\n+#endif\n+    INSN_LABEL(multianewarray),\n+    INSN_LABEL(ifnull),\n+    INSN_LABEL(ifnonnull),\n+    INSN_LABEL(goto_w),\n+    INSN_LABEL(jsr_w),\n+#ifdef DIRECT_THREADED\n+    INSN_LABEL (ldc_class)\n+#else\n+    0\n+#endif\n+  };\n+\n+  pc_t pc;\n+\n+#ifdef DIRECT_THREADED\n+\n+#define NEXT_INSN goto *((pc++)->insn)\n+#define INTVAL() ((pc++)->int_val)\n+#define AVAL() ((pc++)->datum)\n+\n+#define GET1S() INTVAL ()\n+#define GET2S() INTVAL ()\n+#define GET1U() INTVAL ()\n+#define GET2U() INTVAL ()\n+#define AVAL1U() AVAL ()\n+#define AVAL2U() AVAL ()\n+#define AVAL2UP() AVAL ()\n+#define SKIP_GOTO ++pc\n+#define GOTO_VAL() (insn_slot *) pc->datum\n+#define PCVAL(unionval) unionval.p\n+#define AMPAMP(label) &&label\n+\n+  // Compile if we must. NOTE: Double-check locking.\n+  if (meth->prepared == NULL)\n+    {\n+      _Jv_MutexLock (&compile_mutex);\n+      if (meth->prepared == NULL)\n+\tmeth->compile (insn_target);\n+      _Jv_MutexUnlock (&compile_mutex);\n+    }\n+\n+  // If we're only compiling, stop here\n+  if (args == NULL)\n+    return;\n+\n+  pc = (insn_slot *) meth->prepared;\n+\n+#else\n+\n+#define NEXT_INSN goto *(insn_target[*pc++])\n+\n+#define GET1S() get1s (pc++)\n+#define GET2S() (pc += 2, get2s (pc- 2))\n+#define GET1U() get1u (pc++)\n+#define GET2U() (pc += 2, get2u (pc - 2))\n+  // Note that these could be more efficient when not handling 'ldc\n+  // class'.\n+#define AVAL1U()\t\t\t\t\t\t\\\n+  ({ int index = get1u (pc++);\t\t\t\t\t\\\n+      resolve_pool_entry (meth->defining_class, index).o; })\n+#define AVAL2U()\t\t\t\t\t\t\\\n+  ({ int index = get2u (pc); pc += 2;\t\t\t\t\\\n+      resolve_pool_entry (meth->defining_class, index).o; })\n+  // Note that we don't need to resolve the pool entry here as class\n+  // constants are never wide.\n+#define AVAL2UP() ({ int index = get2u (pc); pc += 2; &pool_data[index]; })\n+#define SKIP_GOTO pc += 2\n+#define GOTO_VAL() pc - 1 + get2s (pc)\n+#define PCVAL(unionval) unionval.i\n+#define AMPAMP(label) NULL\n+\n+  pc = bytecode ();\n+\n+#endif /* DIRECT_THREADED */\n+\n+#define TAKE_GOTO pc = GOTO_VAL ()\n+\n+  /* Go straight at it!  the ffi raw format matches the internal\n+     stack representation exactly.  At least, that's the idea.\n+  */\n+  memcpy ((void*) locals, (void*) args, meth->args_raw_size);\n+\n+  _Jv_word *pool_data = meth->defining_class->constants.data;\n+\n+  /* These three are temporaries for common code used by several\n+     instructions.  */\n+  void (*fun)();\n+  _Jv_ResolvedMethod* rmeth;\n+  int tmpval;\n+\n+  try\n+    {\n+      // We keep nop around.  It is used if we're interpreting the\n+      // bytecodes and not doing direct threading.\n+    insn_nop:\n+      NEXT_INSN;\n+\n+      /* The first few instructions here are ordered according to their\n+\t frequency, in the hope that this will improve code locality a\n+\t little.  */\n+\n+    insn_aload_0:\t\t// 0x2a\n+      LOADA (0);\n+      NEXT_INSN;\n+\n+    insn_iload:\t\t// 0x15\n+      LOADI (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_iload_1:\t\t// 0x1b\n+      LOADI (1);\n+      NEXT_INSN;\n+\n+    insn_invokevirtual:\t// 0xb6\n+      {\n+\tSAVE_PC();\n+\tint index = GET2U ();\n+\n+\t/* _Jv_Linker::resolve_pool_entry returns immediately if the\n+\t * value already is resolved.  If we want to clutter up the\n+\t * code here to gain a little performance, then we can check\n+\t * the corresponding bit JV_CONSTANT_ResolvedFlag in the tag\n+\t * directly.  For now, I don't think it is worth it.  */\n+\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n+\n+\tsp -= rmeth->stack_item_count;\n+\n+\tif (rmeth->method->accflags & Modifier::FINAL)\n+\t  {\n+\t    // We can't rely on NULLCHECK working if the method is final.\n+\t    if (! sp[0].o)\n+\t      throw_null_pointer_exception ();\n+\n+\t    // Final methods might not appear in the vtable.\n+\t    fun = (void (*)()) rmeth->method->ncode;\n+\t  }\n+\telse\n+\t  {\n+\t    NULLCHECK (sp[0].o);\n+\t    jobject rcv = sp[0].o;\n+\t    _Jv_VTable *table = *(_Jv_VTable**) rcv;\n+\t    fun = (void (*)()) table->get_method (rmeth->method->index);\n+\t  }\n+\n+#ifdef DIRECT_THREADED\n+\t// Rewrite instruction so that we use a faster pre-resolved\n+\t// method.\n+\tpc[-2].insn = &&invokevirtual_resolved;\n+\tpc[-1].datum = rmeth;\n+#endif /* DIRECT_THREADED */\n+      }\n+      goto perform_invoke;\n+\n+#ifdef DIRECT_THREADED\n+    invokevirtual_resolved:\n+      {\n+\tSAVE_PC();\n+\trmeth = (_Jv_ResolvedMethod *) AVAL ();\n+\tsp -= rmeth->stack_item_count;\n+\n+\tif (rmeth->method->accflags & Modifier::FINAL)\n+\t  {\n+\t    // We can't rely on NULLCHECK working if the method is final.\n+\t    if (! sp[0].o)\n+\t      throw_null_pointer_exception ();\n+\n+\t    // Final methods might not appear in the vtable.\n+\t    fun = (void (*)()) rmeth->method->ncode;\n+\t  }\n+\telse\n+\t  {\n+\t    jobject rcv = sp[0].o;\n+\t    _Jv_VTable *table = *(_Jv_VTable**) rcv;\n+\t    fun = (void (*)()) table->get_method (rmeth->method->index);\n+\t  }\n+      }\n+      goto perform_invoke;\n+#endif /* DIRECT_THREADED */\n+\n+    perform_invoke:\n+      {\n+\t/* here goes the magic again... */\n+\tffi_cif *cif = &rmeth->cif;\n+\tffi_raw *raw = (ffi_raw*) sp;\n+\n+\t_Jv_value rvalue;\n+\n+#if FFI_NATIVE_RAW_API\n+\t/* We assume that this is only implemented if it's correct\t*/\n+\t/* to use it here.  On a 64 bit machine, it never is.\t\t*/\n+\tffi_raw_call (cif, fun, (void*)&rvalue, raw);\n+#else\n+\tffi_java_raw_call (cif, fun, (void*)&rvalue, raw);\n+#endif\n+\n+\tint rtype = cif->rtype->type;\n+\n+\t/* the likelyhood of object, int, or void return is very high,\n+\t * so those are checked before the switch */\n+\tif (rtype == FFI_TYPE_POINTER)\n+\t  {\n+\t    PUSHA (rvalue.object_value);\n+\t  }\n+\telse if (rtype == FFI_TYPE_SINT32)\n+\t  {\n+\t    PUSHI (rvalue.int_value);\n+\t  }\n+\telse if (rtype == FFI_TYPE_VOID)\n+\t  {\n+\t    /* skip */\n+\t  }\n+\telse\n+\t  {\n+\t    switch (rtype)\n+\t      {\n+\t      case FFI_TYPE_SINT8:\n+\t\tPUSHI ((jbyte)(rvalue.int_value & 0xff));\n+\t\tbreak;\n+\n+\t      case FFI_TYPE_SINT16:\n+\t\tPUSHI ((jshort)(rvalue.int_value & 0xffff));\n+\t\tbreak;\n+\n+\t      case FFI_TYPE_UINT16:\n+\t\tPUSHI (rvalue.int_value & 0xffff);\n+\t\tbreak;\n+\n+\t      case FFI_TYPE_FLOAT:\n+\t        PUSHF (rvalue.float_value);\n+\t\tbreak;\n+\n+\t      case FFI_TYPE_DOUBLE:\n+\t        PUSHD (rvalue.double_value);\n+\t\tbreak;\n+\n+\t      case FFI_TYPE_SINT64:\n+\t        PUSHL (rvalue.long_value);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tthrow_internal_error (\"unknown return type in invokeXXX\");\n+\t      }\n+\t  }\n+      }\n+      NEXT_INSN;\n+\n+    insn_aconst_null:\n+      PUSHA (NULL);\n+      NEXT_INSN;\n+\n+    insn_iconst_m1:\n+      PUSHI (-1);\n+      NEXT_INSN;\n+\n+    insn_iconst_0:\n+      PUSHI (0);\n+      NEXT_INSN;\n+\n+    insn_iconst_1:\n+      PUSHI (1);\n+      NEXT_INSN;\n+\n+    insn_iconst_2:\n+      PUSHI (2);\n+      NEXT_INSN;\n+\n+    insn_iconst_3:\n+      PUSHI (3);\n+      NEXT_INSN;\n+\n+    insn_iconst_4:\n+      PUSHI (4);\n+      NEXT_INSN;\n+\n+    insn_iconst_5:\n+      PUSHI (5);\n+      NEXT_INSN;\n+\n+    insn_lconst_0:\n+      PUSHL (0);\n+      NEXT_INSN;\n+\n+    insn_lconst_1:\n+      PUSHL (1);\n+      NEXT_INSN;\n+\n+    insn_fconst_0:\n+      PUSHF (0);\n+      NEXT_INSN;\n+\n+    insn_fconst_1:\n+      PUSHF (1);\n+      NEXT_INSN;\n+\n+    insn_fconst_2:\n+      PUSHF (2);\n+      NEXT_INSN;\n+\n+    insn_dconst_0:\n+      PUSHD (0);\n+      NEXT_INSN;\n+\n+    insn_dconst_1:\n+      PUSHD (1);\n+      NEXT_INSN;\n+\n+    insn_bipush:\n+      // For direct threaded, bipush and sipush are the same.\n+#ifndef DIRECT_THREADED\n+      PUSHI (GET1S ());\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+    insn_sipush:\n+      PUSHI (GET2S ());\n+      NEXT_INSN;\n+\n+    insn_ldc:\n+      // For direct threaded, ldc and ldc_w are the same.\n+#ifndef DIRECT_THREADED\n+      PUSHA ((jobject) AVAL1U ());\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+    insn_ldc_w:\n+      PUSHA ((jobject) AVAL2U ());\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+      // For direct threaded we have a separate 'ldc class' operation.\n+    insn_ldc_class:\n+      {\n+\tSAVE_PC();\n+\t// We could rewrite the instruction at this point.\n+\tint index = INTVAL ();\n+\tjobject k = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t     index)).o;\n+\tPUSHA (k);\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_ldc2_w:\n+      {\n+\tvoid *where = AVAL2UP ();\n+\tmemcpy (sp, where, 2*sizeof (_Jv_word));\n+\tsp += 2;\n+      }\n+      NEXT_INSN;\n+\n+    insn_lload:\n+      LOADL (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_fload:\n+      LOADF (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_dload:\n+      LOADD (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_aload:\n+      LOADA (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_iload_0:\n+      LOADI (0);\n+      NEXT_INSN;\n+\n+    insn_iload_2:\n+      LOADI (2);\n+      NEXT_INSN;\n+\n+    insn_iload_3:\n+      LOADI (3);\n+      NEXT_INSN;\n+\n+    insn_lload_0:\n+      LOADL (0);\n+      NEXT_INSN;\n+\n+    insn_lload_1:\n+      LOADL (1);\n+      NEXT_INSN;\n+\n+    insn_lload_2:\n+      LOADL (2);\n+      NEXT_INSN;\n+\n+    insn_lload_3:\n+      LOADL (3);\n+      NEXT_INSN;\n+\n+    insn_fload_0:\n+      LOADF (0);\n+      NEXT_INSN;\n+\n+    insn_fload_1:\n+      LOADF (1);\n+      NEXT_INSN;\n+\n+    insn_fload_2:\n+      LOADF (2);\n+      NEXT_INSN;\n+\n+    insn_fload_3:\n+      LOADF (3);\n+      NEXT_INSN;\n+\n+    insn_dload_0:\n+      LOADD (0);\n+      NEXT_INSN;\n+\n+    insn_dload_1:\n+      LOADD (1);\n+      NEXT_INSN;\n+\n+    insn_dload_2:\n+      LOADD (2);\n+      NEXT_INSN;\n+\n+    insn_dload_3:\n+      LOADD (3);\n+      NEXT_INSN;\n+\n+    insn_aload_1:\n+      LOADA(1);\n+      NEXT_INSN;\n+\n+    insn_aload_2:\n+      LOADA(2);\n+      NEXT_INSN;\n+\n+    insn_aload_3:\n+      LOADA(3);\n+      NEXT_INSN;\n+\n+    insn_iaload:\n+      {\n+\tjint index = POPI();\n+\tjintArray arr = (jintArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_laload:\n+      {\n+\tjint index = POPI();\n+\tjlongArray arr = (jlongArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHL( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_faload:\n+      {\n+\tjint index = POPI();\n+\tjfloatArray arr = (jfloatArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHF( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_daload:\n+      {\n+\tjint index = POPI();\n+\tjdoubleArray arr = (jdoubleArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHD( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_aaload:\n+      {\n+\tjint index = POPI();\n+\tjobjectArray arr = (jobjectArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHA( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_baload:\n+      {\n+\tjint index = POPI();\n+\tjbyteArray arr = (jbyteArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_caload:\n+      {\n+\tjint index = POPI();\n+\tjcharArray arr = (jcharArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_saload:\n+      {\n+\tjint index = POPI();\n+\tjshortArray arr = (jshortArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      NEXT_INSN;\n+\n+    insn_istore:\n+      STOREI (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_lstore:\n+      STOREL (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_fstore:\n+      STOREF (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_dstore:\n+      STORED (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_astore:\n+      STOREA (GET1U ());\n+      NEXT_INSN;\n+\n+    insn_istore_0:\n+      STOREI (0);\n+      NEXT_INSN;\n+\n+    insn_istore_1:\n+      STOREI (1);\n+      NEXT_INSN;\n+\n+    insn_istore_2:\n+      STOREI (2);\n+      NEXT_INSN;\n+\n+    insn_istore_3:\n+      STOREI (3);\n+      NEXT_INSN;\n+\n+    insn_lstore_0:\n+      STOREL (0);\n+      NEXT_INSN;\n+\n+    insn_lstore_1:\n+      STOREL (1);\n+      NEXT_INSN;\n+\n+    insn_lstore_2:\n+      STOREL (2);\n+      NEXT_INSN;\n+\n+    insn_lstore_3:\n+      STOREL (3);\n+      NEXT_INSN;\n+\n+    insn_fstore_0:\n+      STOREF (0);\n+      NEXT_INSN;\n+\n+    insn_fstore_1:\n+      STOREF (1);\n+      NEXT_INSN;\n+\n+    insn_fstore_2:\n+      STOREF (2);\n+      NEXT_INSN;\n+\n+    insn_fstore_3:\n+      STOREF (3);\n+      NEXT_INSN;\n+\n+    insn_dstore_0:\n+      STORED (0);\n+      NEXT_INSN;\n+\n+    insn_dstore_1:\n+      STORED (1);\n+      NEXT_INSN;\n+\n+    insn_dstore_2:\n+      STORED (2);\n+      NEXT_INSN;\n+\n+    insn_dstore_3:\n+      STORED (3);\n+      NEXT_INSN;\n+\n+    insn_astore_0:\n+      STOREA(0);\n+      NEXT_INSN;\n+\n+    insn_astore_1:\n+      STOREA(1);\n+      NEXT_INSN;\n+\n+    insn_astore_2:\n+      STOREA(2);\n+      NEXT_INSN;\n+\n+    insn_astore_3:\n+      STOREA(3);\n+      NEXT_INSN;\n+\n+    insn_iastore:\n+      {\n+\tjint value = POPI();\n+\tjint index  = POPI();\n+\tjintArray arr = (jintArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_lastore:\n+      {\n+\tjlong value = POPL();\n+\tjint index  = POPI();\n+\tjlongArray arr = (jlongArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_fastore:\n+      {\n+\tjfloat value = POPF();\n+\tjint index  = POPI();\n+\tjfloatArray arr = (jfloatArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_dastore:\n+      {\n+\tjdouble value = POPD();\n+\tjint index  = POPI();\n+\tjdoubleArray arr = (jdoubleArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_aastore:\n+      {\n+\tjobject value = POPA();\n+\tjint index  = POPI();\n+\tjobjectArray arr = (jobjectArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\t_Jv_CheckArrayStore (arr, value);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_bastore:\n+      {\n+\tjbyte value = (jbyte) POPI();\n+\tjint index  = POPI();\n+\tjbyteArray arr = (jbyteArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_castore:\n+      {\n+\tjchar value = (jchar) POPI();\n+\tjint index  = POPI();\n+\tjcharArray arr = (jcharArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_sastore:\n+      {\n+\tjshort value = (jshort) POPI();\n+\tjint index  = POPI();\n+\tjshortArray arr = (jshortArray) POPA();\n+\tNULLARRAYCHECK (arr);\n+\tARRAYBOUNDSCHECK (arr, index);\n+\telements(arr)[index] = value;\n+      }\n+      NEXT_INSN;\n+\n+    insn_pop:\n+      sp -= 1;\n+      NEXT_INSN;\n+\n+    insn_pop2:\n+      sp -= 2;\n+      NEXT_INSN;\n+\n+    insn_dup:\n+      sp[0] = sp[-1];\n+      sp += 1;\n+      NEXT_INSN;\n+\n+    insn_dup_x1:\n+      dupx (sp, 1, 1); sp+=1;\n+      NEXT_INSN;\n+\n+    insn_dup_x2:\n+      dupx (sp, 1, 2); sp+=1;\n+      NEXT_INSN;\n+\n+    insn_dup2:\n+      sp[0] = sp[-2];\n+      sp[1] = sp[-1];\n+      sp += 2;\n+      NEXT_INSN;\n+\n+    insn_dup2_x1:\n+      dupx (sp, 2, 1); sp+=2;\n+      NEXT_INSN;\n+\n+    insn_dup2_x2:\n+      dupx (sp, 2, 2); sp+=2;\n+      NEXT_INSN;\n+\n+    insn_swap:\n+      {\n+\tjobject tmp1 = POPA();\n+\tjobject tmp2 = POPA();\n+\tPUSHA (tmp1);\n+\tPUSHA (tmp2);\n+      }\n+      NEXT_INSN;\n+\n+    insn_iadd:\n+      BINOPI(+);\n+      NEXT_INSN;\n+\n+    insn_ladd:\n+      BINOPL(+);\n+      NEXT_INSN;\n+\n+    insn_fadd:\n+      BINOPF(+);\n+      NEXT_INSN;\n+\n+    insn_dadd:\n+      BINOPD(+);\n+      NEXT_INSN;\n+\n+    insn_isub:\n+      BINOPI(-);\n+      NEXT_INSN;\n+\n+    insn_lsub:\n+      BINOPL(-);\n+      NEXT_INSN;\n+\n+    insn_fsub:\n+      BINOPF(-);\n+      NEXT_INSN;\n+\n+    insn_dsub:\n+      BINOPD(-);\n+      NEXT_INSN;\n+\n+    insn_imul:\n+      BINOPI(*);\n+      NEXT_INSN;\n+\n+    insn_lmul:\n+      BINOPL(*);\n+      NEXT_INSN;\n+\n+    insn_fmul:\n+      BINOPF(*);\n+      NEXT_INSN;\n+\n+    insn_dmul:\n+      BINOPD(*);\n+      NEXT_INSN;\n+\n+    insn_idiv:\n+      {\n+\tSAVE_PC();\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tjint res = _Jv_divI (value1, value2);\n+\tPUSHI (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_ldiv:\n+      {\n+\tSAVE_PC();\n+\tjlong value2 = POPL();\n+\tjlong value1 = POPL();\n+\tjlong res = _Jv_divJ (value1, value2);\n+\tPUSHL (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_fdiv:\n+      {\n+\tjfloat value2 = POPF();\n+\tjfloat value1 = POPF();\n+\tjfloat res = value1 / value2;\n+\tPUSHF (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_ddiv:\n+      {\n+\tjdouble value2 = POPD();\n+\tjdouble value1 = POPD();\n+\tjdouble res = value1 / value2;\n+\tPUSHD (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_irem:\n+      {\n+\tSAVE_PC();\n+\tjint value2 = POPI();\n+\tjint value1 =  POPI();\n+\tjint res = _Jv_remI (value1, value2);\n+\tPUSHI (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_lrem:\n+      {\n+\tSAVE_PC();\n+\tjlong value2 = POPL();\n+\tjlong value1 = POPL();\n+\tjlong res = _Jv_remJ (value1, value2);\n+\tPUSHL (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_frem:\n+      {\n+\tjfloat value2 = POPF();\n+\tjfloat value1 = POPF();\n+\tjfloat res    = __ieee754_fmod (value1, value2);\n+\tPUSHF (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_drem:\n+      {\n+\tjdouble value2 = POPD();\n+\tjdouble value1 = POPD();\n+\tjdouble res    = __ieee754_fmod (value1, value2);\n+\tPUSHD (res);\n+      }\n+      NEXT_INSN;\n+\n+    insn_ineg:\n+      {\n+\tjint value = POPI();\n+\tPUSHI (value * -1);\n+      }\n+      NEXT_INSN;\n+\n+    insn_lneg:\n+      {\n+\tjlong value = POPL();\n+\tPUSHL (value * -1);\n+      }\n+      NEXT_INSN;\n+\n+    insn_fneg:\n+      {\n+\tjfloat value = POPF();\n+\tPUSHF (value * -1);\n+      }\n+      NEXT_INSN;\n+\n+    insn_dneg:\n+      {\n+\tjdouble value = POPD();\n+\tPUSHD (value * -1);\n+      }\n+      NEXT_INSN;\n+\n+    insn_ishl:\n+      {\n+\tjint shift = (POPI() & 0x1f);\n+\tjint value = POPI();\n+\tPUSHI (value << shift);\n+      }\n+      NEXT_INSN;\n+\n+    insn_lshl:\n+      {\n+\tjint shift = (POPI() & 0x3f);\n+\tjlong value = POPL();\n+\tPUSHL (value << shift);\n+      }\n+      NEXT_INSN;\n+\n+    insn_ishr:\n+      {\n+\tjint shift = (POPI() & 0x1f);\n+\tjint value = POPI();\n+\tPUSHI (value >> shift);\n+      }\n+      NEXT_INSN;\n+\n+    insn_lshr:\n+      {\n+\tjint shift = (POPI() & 0x3f);\n+\tjlong value = POPL();\n+\tPUSHL (value >> shift);\n+      }\n+      NEXT_INSN;\n+\n+    insn_iushr:\n+      {\n+\tjint shift = (POPI() & 0x1f);\n+\t_Jv_uint value = (_Jv_uint) POPI();\n+\tPUSHI ((jint) (value >> shift));\n+      }\n+      NEXT_INSN;\n+\n+    insn_lushr:\n+      {\n+\tjint shift = (POPI() & 0x3f);\n+\t_Jv_ulong value = (_Jv_ulong) POPL();\n+\tPUSHL ((jlong) (value >> shift));\n+      }\n+      NEXT_INSN;\n+\n+    insn_iand:\n+      BINOPI (&);\n+      NEXT_INSN;\n+\n+    insn_land:\n+      BINOPL (&);\n+      NEXT_INSN;\n+\n+    insn_ior:\n+      BINOPI (|);\n+      NEXT_INSN;\n+\n+    insn_lor:\n+      BINOPL (|);\n+      NEXT_INSN;\n+\n+    insn_ixor:\n+      BINOPI (^);\n+      NEXT_INSN;\n+\n+    insn_lxor:\n+      BINOPL (^);\n+      NEXT_INSN;\n+\n+    insn_iinc:\n+      {\n+\tjint index  = GET1U ();\n+\tjint amount = GET1S ();\n+\tlocals[index].i += amount;\n+      }\n+      NEXT_INSN;\n+\n+    insn_i2l:\n+      {jlong value = POPI(); PUSHL (value);}\n+      NEXT_INSN;\n+\n+    insn_i2f:\n+      {jfloat value = POPI(); PUSHF (value);}\n+      NEXT_INSN;\n+\n+    insn_i2d:\n+      {jdouble value = POPI(); PUSHD (value);}\n+      NEXT_INSN;\n+\n+    insn_l2i:\n+      {jint value = POPL(); PUSHI (value);}\n+      NEXT_INSN;\n+\n+    insn_l2f:\n+      {jfloat value = POPL(); PUSHF (value);}\n+      NEXT_INSN;\n+\n+    insn_l2d:\n+      {jdouble value = POPL(); PUSHD (value);}\n+      NEXT_INSN;\n+\n+    insn_f2i:\n+      {\n+\tusing namespace java::lang;\n+\tjint value = convert (POPF (), Integer::MIN_VALUE, Integer::MAX_VALUE);\n+\tPUSHI(value);\n+      }\n+      NEXT_INSN;\n+\n+    insn_f2l:\n+      {\n+\tusing namespace java::lang;\n+\tjlong value = convert (POPF (), Long::MIN_VALUE, Long::MAX_VALUE);\n+\tPUSHL(value);\n+      }\n+      NEXT_INSN;\n+\n+    insn_f2d:\n+      { jdouble value = POPF (); PUSHD(value); }\n+      NEXT_INSN;\n+\n+    insn_d2i:\n+      {\n+\tusing namespace java::lang;\n+\tjint value = convert (POPD (), Integer::MIN_VALUE, Integer::MAX_VALUE);\n+\tPUSHI(value);\n+      }\n+      NEXT_INSN;\n+\n+    insn_d2l:\n+      {\n+\tusing namespace java::lang;\n+\tjlong value = convert (POPD (), Long::MIN_VALUE, Long::MAX_VALUE);\n+\tPUSHL(value);\n+      }\n+      NEXT_INSN;\n+\n+    insn_d2f:\n+      { jfloat value = POPD (); PUSHF(value); }\n+      NEXT_INSN;\n+\n+    insn_i2b:\n+      { jbyte value = POPI (); PUSHI(value); }\n+      NEXT_INSN;\n+\n+    insn_i2c:\n+      { jchar value = POPI (); PUSHI(value); }\n+      NEXT_INSN;\n+\n+    insn_i2s:\n+      { jshort value = POPI (); PUSHI(value); }\n+      NEXT_INSN;\n+\n+    insn_lcmp:\n+      {\n+\tjlong value2 = POPL ();\n+\tjlong value1 = POPL ();\n+\tif (value1 > value2)\n+\t  { PUSHI (1); }\n+\telse if (value1 == value2)\n+\t  { PUSHI (0); }\n+\telse\n+\t  { PUSHI (-1); }\n+      }\n+      NEXT_INSN;\n+\n+    insn_fcmpl:\n+      tmpval = -1;\n+      goto fcmp;\n+\n+    insn_fcmpg:\n+      tmpval = 1;\n+\n+    fcmp:\n+      {\n+\tjfloat value2 = POPF ();\n+\tjfloat value1 = POPF ();\n+\tif (value1 > value2)\n+\t  PUSHI (1);\n+\telse if (value1 == value2)\n+\t  PUSHI (0);\n+\telse if (value1 < value2)\n+\t  PUSHI (-1);\n+\telse\n+\t  PUSHI (tmpval);\n+      }\n+      NEXT_INSN;\n+\n+    insn_dcmpl:\n+      tmpval = -1;\n+      goto dcmp;\n+\n+    insn_dcmpg:\n+      tmpval = 1;\n+\n+    dcmp:\n+      {\n+\tjdouble value2 = POPD ();\n+\tjdouble value1 = POPD ();\n+\tif (value1 > value2)\n+\t  PUSHI (1);\n+\telse if (value1 == value2)\n+\t  PUSHI (0);\n+\telse if (value1 < value2)\n+\t  PUSHI (-1);\n+\telse\n+\t  PUSHI (tmpval);\n+      }\n+      NEXT_INSN;\n+\n+    insn_ifeq:\n+      {\n+\tif (POPI() == 0)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_ifne:\n+      {\n+\tif (POPI() != 0)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_iflt:\n+      {\n+\tif (POPI() < 0)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_ifge:\n+      {\n+\tif (POPI() >= 0)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_ifgt:\n+      {\n+\tif (POPI() > 0)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_ifle:\n+      {\n+\tif (POPI() <= 0)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_icmpeq:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 == value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_icmpne:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 != value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_icmplt:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 < value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_icmpge:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 >= value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_icmpgt:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 > value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_icmple:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 <= value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_acmpeq:\n+      {\n+\tjobject value2 = POPA();\n+\tjobject value1 = POPA();\n+\tif (value1 == value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_if_acmpne:\n+      {\n+\tjobject value2 = POPA();\n+\tjobject value1 = POPA();\n+\tif (value1 != value2)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_goto_w:\n+#ifndef DIRECT_THREADED\n+      // For direct threaded, goto and goto_w are the same.\n+      pc = pc - 1 + get4 (pc);\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+    insn_goto:\n+      TAKE_GOTO;\n+      NEXT_INSN;\n+\n+    insn_jsr_w:\n+#ifndef DIRECT_THREADED\n+      // For direct threaded, jsr and jsr_w are the same.\n+      {\n+\tpc_t next = pc - 1 + get4 (pc);\n+\tpc += 4;\n+\tPUSHA ((jobject) pc);\n+\tpc = next;\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+    insn_jsr:\n+      {\n+\tpc_t next = GOTO_VAL();\n+\tSKIP_GOTO;\n+\tPUSHA ((jobject) pc);\n+\tpc = next;\n+      }\n+      NEXT_INSN;\n+\n+    insn_ret:\n+      {\n+\tjint index = GET1U ();\n+\tpc = (pc_t) PEEKA (index);\n+      }\n+      NEXT_INSN;\n+\n+    insn_tableswitch:\n+      {\n+#ifdef DIRECT_THREADED\n+\tvoid *def = (pc++)->datum;\n+\n+\tint index = POPI();\n+\n+\tjint low = INTVAL ();\n+\tjint high = INTVAL ();\n+\n+\tif (index < low || index > high)\n+\t  pc = (insn_slot *) def;\n+\telse\n+\t  pc = (insn_slot *) ((pc + index - low)->datum);\n+#else\n+\tpc_t base_pc = pc - 1;\n+\tint index = POPI ();\n+\n+\tpc_t base = (pc_t) bytecode ();\n+\twhile ((pc - base) % 4 != 0)\n+\t  ++pc;\n+\n+\tjint def = get4 (pc);\n+\tjint low = get4 (pc + 4);\n+\tjint high = get4 (pc + 8);\n+\tif (index < low || index > high)\n+\t  pc = base_pc + def;\n+\telse\n+\t  pc = base_pc + get4 (pc + 4 * (index - low + 3));\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+    insn_lookupswitch:\n+      {\n+#ifdef DIRECT_THREADED\n+\tvoid *def = (pc++)->insn;\n+\n+\tint index = POPI();\n+\n+\tjint npairs = INTVAL ();\n+\n+\tint max = npairs - 1;\n+\tint min = 0;\n+\n+\t// Simple binary search...\n+\twhile (min < max)\n+\t  {\n+\t    int half = (min + max) / 2;\n+\t    int match = pc[2 * half].int_val;\n+\n+\t    if (index == match)\n+\t      {\n+\t\t// Found it.\n+\t\tpc = (insn_slot *) pc[2 * half + 1].datum;\n+\t\tNEXT_INSN;\n+\t      }\n+\t    else if (index < match)\n+\t      // We can use HALF - 1 here because we check again on\n+\t      // loop exit.\n+\t      max = half - 1;\n+\t    else\n+\t      // We can use HALF + 1 here because we check again on\n+\t      // loop exit.\n+\t      min = half + 1;\n+\t  }\n+\tif (index == pc[2 * min].int_val)\n+\t  pc = (insn_slot *) pc[2 * min + 1].datum;\n+\telse\n+\t  pc = (insn_slot *) def;\n+#else\n+\tunsigned char *base_pc = pc-1;\n+\tint index = POPI();\n+\n+\tunsigned char* base = bytecode ();\n+\twhile ((pc-base) % 4 != 0)\n+\t  ++pc;\n+\n+\tjint def     = get4 (pc);\n+\tjint npairs  = get4 (pc+4);\n+\n+\tint max = npairs-1;\n+\tint min = 0;\n+\n+\t// Simple binary search...\n+\twhile (min < max)\n+\t  {\n+\t    int half = (min+max)/2;\n+\t    int match = get4 (pc+ 4*(2 + 2*half));\n+\n+\t    if (index == match)\n+\t      min = max = half;\n+\t    else if (index < match)\n+\t      // We can use HALF - 1 here because we check again on\n+\t      // loop exit.\n+\t      max = half - 1;\n+\t    else\n+\t      // We can use HALF + 1 here because we check again on\n+\t      // loop exit.\n+\t      min = half + 1;\n+\t  }\n+\n+\tif (index == get4 (pc+ 4*(2 + 2*min)))\n+\t  pc = base_pc + get4 (pc+ 4*(2 + 2*min + 1));\n+\telse\n+\t  pc = base_pc + def;    \n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+    insn_areturn:\n+      *(jobject *) retp = POPA ();\n+      return;\n+\n+    insn_lreturn:\n+      *(jlong *) retp = POPL ();\n+      return;\n+\n+    insn_freturn:\n+      *(jfloat *) retp = POPF ();\n+      return;\n+\n+    insn_dreturn:\n+      *(jdouble *) retp = POPD ();\n+      return;\n+\n+    insn_ireturn:\n+      *(jint *) retp = POPI ();\n+      return;\n+\n+    insn_return:\n+      return;\n+\n+    insn_getstatic:\n+      {\n+\tjint fieldref_index = GET2U ();\n+        SAVE_PC(); // Constant pool resolution could throw.\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n+\t_Jv_Field *field = pool_data[fieldref_index].field;\n+\n+\tif ((field->flags & Modifier::STATIC) == 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field no longer static\"));\n+\n+\tjclass type = field->type;\n+\n+\t// We rewrite the instruction once we discover what it refers\n+\t// to.\n+\tvoid *newinsn = NULL;\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes)\n+\t      {\n+\t      case 1:\n+\t\tPUSHI (*field->u.byte_addr);\n+\t\tnewinsn = AMPAMP (getstatic_resolved_1);\n+\t\tbreak;\n+\n+\t      case 2:\n+\t\tif (type == JvPrimClass (char))\n+\t\t  {\n+\t\t    PUSHI (*field->u.char_addr);\n+\t\t    newinsn = AMPAMP (getstatic_resolved_char);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    PUSHI (*field->u.short_addr);\n+\t\t    newinsn = AMPAMP (getstatic_resolved_short);\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case 4:\n+\t        PUSHI(*field->u.int_addr);\n+\t\tnewinsn = AMPAMP (getstatic_resolved_4);\n+\t\tbreak;\n+\n+\t      case 8:\n+\t        PUSHL(*field->u.long_addr);\n+\t\tnewinsn = AMPAMP (getstatic_resolved_8);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    PUSHA(*field->u.object_addr);\n+\t    newinsn = AMPAMP (getstatic_resolved_obj);\n+\t  }\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = newinsn;\n+\tpc[-1].datum = field->u.addr;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    getstatic_resolved_1:\n+      PUSHI (*(jbyte *) AVAL ());\n+      NEXT_INSN;\n+\n+    getstatic_resolved_char:\n+      PUSHI (*(jchar *) AVAL ());\n+      NEXT_INSN;\n+\n+    getstatic_resolved_short:\n+      PUSHI (*(jshort *) AVAL ());\n+      NEXT_INSN;\n+\n+    getstatic_resolved_4:\n+      PUSHI (*(jint *) AVAL ());\n+      NEXT_INSN;\n+\n+    getstatic_resolved_8:\n+      PUSHL (*(jlong *) AVAL ());\n+      NEXT_INSN;\n+\n+    getstatic_resolved_obj:\n+      PUSHA (*(jobject *) AVAL ());\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_getfield:\n+      {\n+\tSAVE_PC();\n+\tjint fieldref_index = GET2U ();\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n+\t_Jv_Field *field = pool_data[fieldref_index].field;\n+\n+\tif ((field->flags & Modifier::STATIC) != 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field is static\"));\n+\n+\tjclass type = field->type;\n+\tjint field_offset = field->u.boffset;\n+\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\n+\tvoid *newinsn = NULL;\n+\t_Jv_value *val = (_Jv_value *) ((char *)obj + field_offset);\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes)\n+\t      {\n+\t      case 1:\n+\t        PUSHI (val->byte_value);\n+\t\tnewinsn = AMPAMP (getfield_resolved_1);\n+\t\tbreak;\n+\n+\t      case 2:\n+\t\tif (type == JvPrimClass (char))\n+\t\t  {\n+\t\t    PUSHI (val->char_value);\n+\t\t    newinsn = AMPAMP (getfield_resolved_char);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    PUSHI (val->short_value);\n+\t\t    newinsn = AMPAMP (getfield_resolved_short);\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case 4:\n+\t\tPUSHI (val->int_value);\n+\t\tnewinsn = AMPAMP (getfield_resolved_4);\n+\t\tbreak;\n+\n+\t      case 8:\n+\t        PUSHL (val->long_value);\n+\t\tnewinsn = AMPAMP (getfield_resolved_8);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    PUSHA (val->object_value);\n+\t    newinsn = AMPAMP (getfield_resolved_obj);\n+\t  }\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = newinsn;\n+\tpc[-1].int_val = field_offset;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    getfield_resolved_1:\n+      {\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\tPUSHI (*(jbyte *) (obj + INTVAL ()));\n+      }\n+      NEXT_INSN;\n+\n+    getfield_resolved_char:\n+      {\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\tPUSHI (*(jchar *) (obj + INTVAL ()));\n+      }\n+      NEXT_INSN;\n+\n+    getfield_resolved_short:\n+      {\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\tPUSHI (*(jshort *) (obj + INTVAL ()));\n+      }\n+      NEXT_INSN;\n+\n+    getfield_resolved_4:\n+      {\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\tPUSHI (*(jint *) (obj + INTVAL ()));\n+      }\n+      NEXT_INSN;\n+\n+    getfield_resolved_8:\n+      {\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\tPUSHL (*(jlong *) (obj + INTVAL ()));\n+      }\n+      NEXT_INSN;\n+\n+    getfield_resolved_obj:\n+      {\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\tPUSHA (*(jobject *) (obj + INTVAL ()));\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_putstatic:\n+      {\n+\tSAVE_PC();\n+\tjint fieldref_index = GET2U ();\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n+\t_Jv_Field *field = pool_data[fieldref_index].field;\n+\n+\tjclass type = field->type;\n+\n+\t// ResolvePoolEntry cannot check this\n+\tif ((field->flags & Modifier::STATIC) == 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field no longer static\"));\n+\n+\tvoid *newinsn = NULL;\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes) \n+\t      {\n+\t      case 1:\n+\t\t{\n+\t\t  jint value = POPI();\n+\t\t  *field->u.byte_addr = value;\n+\t\t  newinsn = AMPAMP (putstatic_resolved_1);\n+\t\t  break;\n+\t\t}\n+\n+\t      case 2:\n+\t\t{\n+\t\t  jint value = POPI();\n+\t\t  *field->u.char_addr = value;\n+\t\t  newinsn = AMPAMP (putstatic_resolved_2);\n+\t\t  break;\n+\t\t}\n+\n+\t      case 4:\n+\t\t{\n+\t\t  jint value = POPI();\n+\t\t  *field->u.int_addr = value;\n+\t\t  newinsn = AMPAMP (putstatic_resolved_4);\n+\t\t  break;\n+\t\t}\n+\n+\t      case 8:\n+\t\t{\n+\t\t  jlong value = POPL();\n+\t\t  *field->u.long_addr = value;\n+\t\t  newinsn = AMPAMP (putstatic_resolved_8);\n+\t\t  break;\n+\t\t}\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    jobject value = POPA();\n+\t    *field->u.object_addr = value;\n+\t    newinsn = AMPAMP (putstatic_resolved_obj);\n+\t  }\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = newinsn;\n+\tpc[-1].datum = field->u.addr;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    putstatic_resolved_1:\n+      *(jbyte *) AVAL () = POPI ();\n+      NEXT_INSN;\n+\n+    putstatic_resolved_2:\n+      *(jchar *) AVAL () = POPI ();\n+      NEXT_INSN;\n+\n+    putstatic_resolved_4:\n+      *(jint *) AVAL () = POPI ();\n+      NEXT_INSN;\n+\n+    putstatic_resolved_8:\n+      *(jlong *) AVAL () = POPL ();\n+      NEXT_INSN;\n+\n+    putstatic_resolved_obj:\n+      *(jobject *) AVAL () = POPA ();\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_putfield:\n+      {\n+\tSAVE_PC();\n+\tjint fieldref_index = GET2U ();\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n+\t_Jv_Field *field = pool_data[fieldref_index].field;\n+\n+\tjclass type = field->type;\n+\n+\tif ((field->flags & Modifier::STATIC) != 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field is static\"));\n+\n+\tjint field_offset = field->u.boffset;\n+\n+\tvoid *newinsn = NULL;\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes) \n+\t      {\n+\t      case 1:\n+\t\t{\n+\t\t  jint    value = POPI();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jbyte*) ((char*)obj + field_offset) = value;\n+\t\t  newinsn = AMPAMP (putfield_resolved_1);\n+\t\t  break;\n+\t\t}\n+\n+\t      case 2:\n+\t\t{\n+\t\t  jint    value = POPI();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jchar*) ((char*)obj + field_offset) = value;\n+\t\t  newinsn = AMPAMP (putfield_resolved_2);\n+\t\t  break;\n+\t\t}\n+\n+\t      case 4:\n+\t\t{\n+\t\t  jint    value = POPI();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jint*) ((char*)obj + field_offset) = value;\n+\t\t  newinsn = AMPAMP (putfield_resolved_4);\n+\t\t  break;\n+\t\t}\n+\n+\t      case 8:\n+\t\t{\n+\t\t  jlong   value = POPL();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jlong*) ((char*)obj + field_offset) = value;\n+\t\t  newinsn = AMPAMP (putfield_resolved_8);\n+\t\t  break;\n+\t\t}\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    jobject value = POPA();\n+\t    jobject obj   = POPA();\n+\t    NULLCHECK(obj);\n+\t    *(jobject*) ((char*)obj + field_offset) = value;\n+\t    newinsn = AMPAMP (putfield_resolved_obj);\n+\t  }\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = newinsn;\n+\tpc[-1].int_val = field_offset;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    putfield_resolved_1:\n+      {\n+\tjint val = POPI ();\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\t*(jbyte *) (obj + INTVAL ()) = val;\n+      }\n+      NEXT_INSN;\n+\n+    putfield_resolved_2:\n+      {\n+\tjint val = POPI ();\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\t*(jchar *) (obj + INTVAL ()) = val;\n+      }\n+      NEXT_INSN;\n+\n+    putfield_resolved_4:\n+      {\n+\tjint val = POPI ();\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\t*(jint *) (obj + INTVAL ()) = val;\n+      }\n+      NEXT_INSN;\n+\n+    putfield_resolved_8:\n+      {\n+\tjlong val = POPL ();\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\t*(jlong *) (obj + INTVAL ()) = val;\n+      }\n+      NEXT_INSN;\n+\n+    putfield_resolved_obj:\n+      {\n+\tjobject val = POPA ();\n+\tchar *obj = (char *) POPA ();\n+\tNULLCHECK (obj);\n+\t*(jobject *) (obj + INTVAL ()) = val;\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_invokespecial:\n+      {\n+\tSAVE_PC();\n+\tint index = GET2U ();\n+\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n+\n+\tsp -= rmeth->stack_item_count;\n+\n+\t// We don't use NULLCHECK here because we can't rely on that\n+\t// working for <init>.  So instead we do an explicit test.\n+\tif (! sp[0].o)\n+\t  {\n+\t    SAVE_PC();\n+\t    throw_null_pointer_exception ();\n+\t  }\n+\n+\tfun = (void (*)()) rmeth->method->ncode;\n+\n+#ifdef DIRECT_THREADED\n+\t// Rewrite instruction so that we use a faster pre-resolved\n+\t// method.\n+\tpc[-2].insn = &&invokespecial_resolved;\n+\tpc[-1].datum = rmeth;\n+#endif /* DIRECT_THREADED */\n+      }\n+      goto perform_invoke;\n+\n+#ifdef DIRECT_THREADED\n+    invokespecial_resolved:\n+      {\n+\tSAVE_PC();\n+\trmeth = (_Jv_ResolvedMethod *) AVAL ();\n+\tsp -= rmeth->stack_item_count;\n+\t// We don't use NULLCHECK here because we can't rely on that\n+\t// working for <init>.  So instead we do an explicit test.\n+\tif (! sp[0].o)\n+\t  {\n+\t    throw_null_pointer_exception ();\n+\t  }\n+\tfun = (void (*)()) rmeth->method->ncode;\n+      }\n+      goto perform_invoke;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_invokestatic:\n+      {\n+\tSAVE_PC();\n+\tint index = GET2U ();\n+\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n+\n+\tsp -= rmeth->stack_item_count;\n+\n+\tfun = (void (*)()) rmeth->method->ncode;\n+\n+#ifdef DIRECT_THREADED\n+\t// Rewrite instruction so that we use a faster pre-resolved\n+\t// method.\n+\tpc[-2].insn = &&invokestatic_resolved;\n+\tpc[-1].datum = rmeth;\n+#endif /* DIRECT_THREADED */\n+      }\n+      goto perform_invoke;\n+\n+#ifdef DIRECT_THREADED\n+    invokestatic_resolved:\n+      {\n+\tSAVE_PC();\n+\trmeth = (_Jv_ResolvedMethod *) AVAL ();\n+\tsp -= rmeth->stack_item_count;\n+\tfun = (void (*)()) rmeth->method->ncode;\n+      }\n+      goto perform_invoke;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_invokeinterface:\n+      {\n+\tSAVE_PC();\n+\tint index = GET2U ();\n+\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n+\n+\tsp -= rmeth->stack_item_count;\n+\n+\tjobject rcv = sp[0].o;\n+\n+\tNULLCHECK (rcv);\n+\n+\tfun = (void (*)())\n+\t  _Jv_LookupInterfaceMethod (rcv->getClass (),\n+\t\t\t\t     rmeth->method->name,\n+\t\t\t\t     rmeth->method->signature);\n+\n+#ifdef DIRECT_THREADED\n+\t// Rewrite instruction so that we use a faster pre-resolved\n+\t// method.\n+\tpc[-2].insn = &&invokeinterface_resolved;\n+\tpc[-1].datum = rmeth;\n+#else\n+\t// Skip dummy bytes.\n+\tpc += 2;\n+#endif /* DIRECT_THREADED */\n+      }\n+      goto perform_invoke;\n+\n+#ifdef DIRECT_THREADED\n+    invokeinterface_resolved:\n+      {\n+\tSAVE_PC();\n+\trmeth = (_Jv_ResolvedMethod *) AVAL ();\n+\tsp -= rmeth->stack_item_count;\n+\tjobject rcv = sp[0].o;\n+\tNULLCHECK (rcv);\n+\tfun = (void (*)())\n+\t  _Jv_LookupInterfaceMethod (rcv->getClass (),\n+\t\t\t\t     rmeth->method->name,\n+\t\t\t\t     rmeth->method->signature);\n+      }\n+      goto perform_invoke;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_new:\n+      {\n+\tSAVE_PC();\n+\tint index = GET2U ();\n+\tjclass klass = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t\t  index)).clazz;\n+\t/* VM spec, section 3.11.5 */\n+\tif ((klass->getModifiers() & Modifier::ABSTRACT)\n+\t    || klass->isInterface())\n+\t  throw new java::lang::InstantiationException;\n+\tjobject res = _Jv_AllocObject (klass);\n+\tPUSHA (res);\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = &&new_resolved;\n+\tpc[-1].datum = klass;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    new_resolved:\n+      {\n+\tjclass klass = (jclass) AVAL ();\n+\tjobject res = _Jv_AllocObject (klass);\n+\tPUSHA (res);\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_newarray:\n+      {\n+\tint atype = GET1U ();\n+\tint size  = POPI();\n+\tjobject result = _Jv_NewArray (atype, size);\n+\tPUSHA (result);\n+      }\n+      NEXT_INSN;\n+\n+    insn_anewarray:\n+      {\n+\tSAVE_PC();\n+\tint index = GET2U ();\n+\tjclass klass = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t\t  index)).clazz;\n+\tint size  = POPI();\n+\tjobject result = _Jv_NewObjectArray (size, klass, 0);\n+\tPUSHA (result);\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = &&anewarray_resolved;\n+\tpc[-1].datum = klass;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    anewarray_resolved:\n+      {\n+\tjclass klass = (jclass) AVAL ();\n+\tint size = POPI ();\n+\tjobject result = _Jv_NewObjectArray (size, klass, 0);\n+\tPUSHA (result);\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_arraylength:\n+      {\n+\t__JArray *arr = (__JArray*)POPA();\n+\tNULLARRAYCHECK (arr);\n+\tPUSHI (arr->length);\n+      }\n+      NEXT_INSN;\n+\n+    insn_athrow:\n+      {\n+\tjobject value = POPA();\n+\tthrow static_cast<jthrowable>(value);\n+      }\n+      NEXT_INSN;\n+\n+    insn_checkcast:\n+      {\n+        SAVE_PC();\n+\tjobject value = POPA();\n+\tjint index = GET2U ();\n+\tjclass to = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t       index)).clazz;\n+\n+\tvalue = (jobject) _Jv_CheckCast (to, value);\n+\n+\tPUSHA (value);\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = &&checkcast_resolved;\n+\tpc[-1].datum = to;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    checkcast_resolved:\n+      {\n+        SAVE_PC();\n+\tjobject value = POPA ();\n+\tjclass to = (jclass) AVAL ();\n+\tvalue = (jobject) _Jv_CheckCast (to, value);\n+\tPUSHA (value);\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_instanceof:\n+      {\n+        SAVE_PC();\n+\tjobject value = POPA();\n+\tjint index = GET2U ();\n+\tjclass to = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t\t       index)).clazz;\n+\tPUSHI (to->isInstance (value));\n+\n+#ifdef DIRECT_THREADED\n+\tpc[-2].insn = &&instanceof_resolved;\n+\tpc[-1].datum = to;\n+#endif /* DIRECT_THREADED */\n+      }\n+      NEXT_INSN;\n+\n+#ifdef DIRECT_THREADED\n+    instanceof_resolved:\n+      {\n+\tjobject value = POPA ();\n+\tjclass to = (jclass) AVAL ();\n+\tPUSHI (to->isInstance (value));\n+      }\n+      NEXT_INSN;\n+#endif /* DIRECT_THREADED */\n+\n+    insn_monitorenter:\n+      {\n+\tjobject value = POPA();\n+\tNULLCHECK(value);\n+\t_Jv_MonitorEnter (value);\n+      }\n+      NEXT_INSN;\n+\n+    insn_monitorexit:\n+      {\n+\tjobject value = POPA();\n+\tNULLCHECK(value);\n+\t_Jv_MonitorExit (value);\n+      }\n+      NEXT_INSN;\n+\n+    insn_ifnull:\n+      {\n+\tjobject val = POPA();\n+\tif (val == NULL)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_ifnonnull:\n+      {\n+\tjobject val = POPA();\n+\tif (val != NULL)\n+\t  TAKE_GOTO;\n+\telse\n+\t  SKIP_GOTO;\n+      }\n+      NEXT_INSN;\n+\n+    insn_multianewarray:\n+      {\n+\tSAVE_PC();\n+\tint kind_index = GET2U ();\n+\tint dim        = GET1U ();\n+\n+\tjclass type    \n+\t  = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n+\t\t\t\t\t       kind_index)).clazz;\n+\tjint *sizes    = (jint*) __builtin_alloca (sizeof (jint)*dim);\n+\n+\tfor (int i = dim - 1; i >= 0; i--)\n+\t  {\n+\t    sizes[i] = POPI ();\n+\t  }\n+\n+\tjobject res    = _Jv_NewMultiArray (type,dim, sizes);\n+\n+\tPUSHA (res);\n+      }\n+      NEXT_INSN;\n+\n+#ifndef DIRECT_THREADED\n+    insn_wide:\n+      {\n+\tjint the_mod_op = get1u (pc++);\n+\tjint wide       = get2u (pc); pc += 2;\n+\n+\tswitch (the_mod_op)\n+\t  {\n+\t  case op_istore:\n+\t    STOREI (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_fstore:\n+\t    STOREF (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_astore:\n+\t    STOREA (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_lload:\n+\t    LOADL (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_dload:\n+\t    LOADD (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_iload:\n+\t    LOADI (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_fload:\n+\t    LOADF (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_aload:\n+\t    LOADA (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_lstore:\n+\t    STOREL (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_dstore:\n+\t    STORED (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_ret:\n+\t    pc = (unsigned char*) PEEKA (wide);\n+\t    NEXT_INSN;\n+\n+\t  case op_iinc:\n+\t    {\n+\t      jint amount = get2s (pc); pc += 2;\n+\t      jint value = PEEKI (wide);\n+\t      POKEI (wide, value+amount);\n+\t    }\n+\t    NEXT_INSN;\n+\n+\t  default:\n+\t    throw_internal_error (\"illegal bytecode modified by wide\");\n+\t  }\n+\n+      }\n+#endif /* DIRECT_THREADED */\n+    }\n+  catch (java::lang::Throwable *ex)\n+    {\n+#ifdef DIRECT_THREADED\n+      void *logical_pc = (void *) ((insn_slot *) pc - 1);\n+#else\n+      int logical_pc = pc - 1 - bytecode ();\n+#endif\n+      _Jv_InterpException *exc = meth->exceptions ();\n+      jclass exc_class = ex->getClass ();\n+\n+      for (int i = 0; i < meth->exc_count; i++)\n+\t{\n+\t  if (PCVAL (exc[i].start_pc) <= logical_pc\n+\t      && logical_pc < PCVAL (exc[i].end_pc))\n+\t    {\n+#ifdef DIRECT_THREADED\n+\t      jclass handler = (jclass) exc[i].handler_type.p;\n+#else\n+\t      jclass handler = NULL;\n+\t      if (exc[i].handler_type.i != 0)\n+\t\thandler = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t\t     exc[i].handler_type.i)).clazz;\n+#endif /* DIRECT_THREADED */\n+\n+\t      if (handler == NULL || handler->isAssignableFrom (exc_class))\n+\t\t{\n+\n+#ifdef DIRECT_THREADED\n+\t\t  pc = (insn_slot *) exc[i].handler_pc.p;\n+#else\n+\t\t  pc = bytecode () + exc[i].handler_pc.i;\n+#endif /* DIRECT_THREADED */\n+\t\t  sp = stack;\n+\t\t  sp++->o = ex; // Push exception.\n+\t\t  NEXT_INSN;\n+\t\t}\n+\t    }\n+\t}\n+\n+      // No handler, so re-throw.\n+      throw ex;\n+    }"}, {"sha": "22196aa30a141eb55a15e5052d4739bc959ea6d0", "filename": "libjava/interpret.cc", "status": "modified", "additions": 312, "deletions": 2680, "changes": 2992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=50ac25005f8b8c8bb91d74a6f1895bc5e11e8680"}, {"sha": "3e6f04cd2c66b1ddfad053ece884765aa7cadbf8", "filename": "libjava/stacktrace.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ac25005f8b8c8bb91d74a6f1895bc5e11e8680/libjava%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fstacktrace.cc?ref=50ac25005f8b8c8bb91d74a6f1895bc5e11e8680", "patch": "@@ -24,6 +24,7 @@ details.  */\n #include <java/security/AccessController.h>\n #include <java/util/ArrayList.h>\n #include <java/util/IdentityHashMap.h>\n+#include <gnu/classpath/jdwp/Jdwp.h>\n #include <gnu/java/lang/MainThread.h>\n #include <gnu/gcj/runtime/NameFinder.h>\n #include <gnu/gcj/runtime/StringBuffer.h>\n@@ -113,7 +114,13 @@ _Jv_StackTrace::UnwindTraceFn (struct _Unwind_Context *context, void *state_ptr)\n   // correspondance between call frames in the interpreted stack and occurances\n   // of _Jv_InterpMethod::run() on the native stack.\n #ifdef INTERPRETER\n-  void *interp_run = (void *) &_Jv_InterpMethod::run;\n+  void *interp_run = NULL;\n+  \n+  if (::gnu::classpath::jdwp::Jdwp::isDebugging)\n+  \tinterp_run = (void *) &_Jv_InterpMethod::run_debug;\n+  else\n+    interp_run = (void *) &_Jv_InterpMethod::run;\n+  \t\n   if (func_addr == UNWRAP_FUNCTION_DESCRIPTOR (interp_run))\n     {\n       state->frames[pos].type = frame_interpreter;"}]}