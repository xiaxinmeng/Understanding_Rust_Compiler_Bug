{"sha": "b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5YTZhOTA3YzFlM2UxY2QwYjgwYjBkNzg3OWIxNzA5YmRmODFlNw==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "1999-09-11T19:48:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-11T19:48:37Z"}, "message": "Alex Samuel  <samuel@codesourcery.com>\n\n        * ggc.h (rtvec_def): Forward declare.\n        (tree_node): Likewise.\n        (ggc_root): Define.\n        (roots): Declare.\n        (ggc_set_mark_rtx): Add prototype.\n        (ggc_set_mark_rtvec): Likewise.\n        (ggc_set_mark_tree): Likewise.\n        * ggc-simple.c (ggc_root): Don't define.\n        (roots): Don't declare.\n        (ggc_mark_rtx): Remove.\n        (ggc_mark_rtvec): Likewise.\n        (ggc_mark_tree): Likewise.\n        (ggc_mark_varray): Likewise.\n        (ggc_mark_tree_hash_table_entry): Likewise.\n        (ggc_mark_tree_hash_table): Likewise.\n        (ggc_set_mart_rtx): New function.\n        (ggc_set_mark_rtvec): Likewise.\n        (ggc_set_mark_tree): Likewise.\n        (ggc_add_root): Remove.\n        (ggc_add_rtx_root): Likewise.\n        (ggc_remove_tree_root): Likewise.\n        (ggc_add_string_root): Likewise.\n        (ggc_add_tree_varray_root): Likewise.\n        (ggc_add_tree_hash_table_root): Likewise.\n        (ggc_del_root): Likewise.\n        (ggc_mark_rtx_ptr): Likewise.\n        (ggc_mark_tree_ptr): Likewise.\n        (ggc_mark_string_ptr): Likewise.\n        (ggc_mark_tree_varray_ptr): Likewise.\n        (ggc_mark_tree_hash_table_ptr): Likewise.\n        * ggc-common.c: New file.\n        * Makefile.in (OBJS): Add ggc-common.o.\n        (ggc-common.o): List dependencies.\n\nFrom-SVN: r29281", "tree": {"sha": "25e4668ec01e4ed6581ac2e1bbd77e7e268b4b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25e4668ec01e4ed6581ac2e1bbd77e7e268b4b96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/comments", "author": null, "committer": null, "parents": [{"sha": "61efc8c246bac26c0b61a8d5eabebe18976c7810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61efc8c246bac26c0b61a8d5eabebe18976c7810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61efc8c246bac26c0b61a8d5eabebe18976c7810"}], "stats": {"total": 935, "additions": 524, "deletions": 411}, "files": [{"sha": "16f2ca62c11ccaab78ff0ef7fe792dc578b65aba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "patch": "@@ -1,3 +1,39 @@\n+Sat Sep 11 12:41:55 1999  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* ggc.h (rtvec_def): Forward declare.\n+\t(tree_node): Likewise.\n+\t(ggc_root): Define.\n+\t(roots): Declare.\n+\t(ggc_set_mark_rtx): Add prototype.\n+\t(ggc_set_mark_rtvec): Likewise.\n+\t(ggc_set_mark_tree): Likewise.\n+\t* ggc-simple.c (ggc_root): Don't define.\n+\t(roots): Don't declare.\n+\t(ggc_mark_rtx): Remove.\n+\t(ggc_mark_rtvec): Likewise.\n+\t(ggc_mark_tree): Likewise.\n+\t(ggc_mark_varray): Likewise.\n+\t(ggc_mark_tree_hash_table_entry): Likewise.\n+\t(ggc_mark_tree_hash_table): Likewise.\n+\t(ggc_set_mart_rtx): New function.\n+\t(ggc_set_mark_rtvec): Likewise.\n+\t(ggc_set_mark_tree): Likewise.\n+\t(ggc_add_root): Remove.\n+\t(ggc_add_rtx_root): Likewise.\n+\t(ggc_remove_tree_root): Likewise.\n+\t(ggc_add_string_root): Likewise.\n+\t(ggc_add_tree_varray_root): Likewise.\n+\t(ggc_add_tree_hash_table_root): Likewise.\n+\t(ggc_del_root): Likewise.\n+\t(ggc_mark_rtx_ptr): Likewise.\n+\t(ggc_mark_tree_ptr): Likewise.\n+\t(ggc_mark_string_ptr): Likewise.\n+\t(ggc_mark_tree_varray_ptr): Likewise.\n+\t(ggc_mark_tree_hash_table_ptr): Likewise.\n+\t* ggc-common.c: New file.\n+\t* Makefile.in (OBJS): Add ggc-common.o.\n+\t(ggc-common.o): List dependencies.\n+\n 1999-09-10 22:37 -0700  Zack Weinberg  <zack@bitmover.com>\n \n \t* cppalloc.c (xstrdup): Use memcpy."}, {"sha": "8e3623a9161224176c792edb31f5c269a1382b6b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "patch": "@@ -675,7 +675,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n- lists.o $(GGC)\n+ lists.o ggc-common.o $(GGC)\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1445,6 +1445,9 @@ dumpvers: dumpvers.c\n \n version.o: version.c\n \n+ggc-common.o: ggc-common.c $(CONFIG_H) $(RTL_BASE_H) $(TREE_H) \\\n+\tflags.h ggc.h varray.h hash.h\n+\n ggc-simple.o: ggc-simple.c $(CONFIG_H) $(RTL_BASE_H) $(TREE_H) flags.h \\\n \tggc.h varray.h hash.h\n "}, {"sha": "7fc20681fa138ce329b36e1dd0e8a4597e19f108", "filename": "gcc/ggc-common.c", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "patch": "@@ -0,0 +1,417 @@\n+/* Simple garbage collection for the GNU compiler.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* Generic garbage collection (GC) functions and data, not specific to\n+   any particular GC implementation.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ggc.h\"\n+#include \"hash.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"varray.h\"\n+\n+\n+/* Maintain global roots that are preserved during GC.  */\n+\n+struct ggc_root *roots;\n+\n+/* Type-correct function to pass to ggc_add_root.  It just forwards\n+   *ELT (which is an rtx) to ggc_mark_tree_varray.  */\n+\n+static void\n+ggc_mark_rtx_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_rtx (*(rtx *)elt);\n+}\n+\n+/* Type-correct function to pass to ggc_add_root.  It just forwards\n+   *ELT (which is a tree) to ggc_mark_tree.  */\n+\n+static void\n+ggc_mark_tree_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_tree (*(tree *)elt);\n+}\n+\n+/* Type-correct function to pass to ggc_add_root.  It just forwards\n+   ELT (which is really a varray_type *) to ggc_mark_tree_varray.  */\n+\n+static void\n+ggc_mark_tree_varray_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_tree_varray (*(varray_type *)elt);\n+}\n+\n+/* Type-correct function to pass to ggc_add_root.  It just forwards\n+   ELT (which is really a struct hash_table **) to\n+   ggc_mark_tree_hash_table.  */\n+\n+static void\n+ggc_mark_tree_hash_table_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_tree_hash_table (*(struct hash_table **) elt);\n+}\n+\n+static void\n+ggc_mark_string_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_string (*(char **)elt);\n+}\n+\n+void\n+ggc_add_root (base, nelt, size, cb)\n+     void *base;\n+     int nelt, size;\n+     void (*cb) PROTO ((void *));\n+{\n+  struct ggc_root *x = (struct ggc_root *) xmalloc (sizeof (*x));\n+\n+  x->next = roots;\n+  x->base = base;\n+  x->nelt = nelt;\n+  x->size = size;\n+  x->cb = cb;\n+\n+  roots = x;\n+}\n+\n+void\n+ggc_add_rtx_root (base, nelt)\n+     rtx *base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof(rtx), ggc_mark_rtx_ptr);\n+}\n+\n+void\n+ggc_add_tree_root (base, nelt)\n+     tree *base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof(tree), ggc_mark_tree_ptr);\n+}\n+\n+/* Add V (a varray full of trees) to the list of GC roots.  */\n+\n+void\n+ggc_add_tree_varray_root (base, nelt)\n+     varray_type *base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof (varray_type), \n+\t\tggc_mark_tree_varray_ptr);\n+}\n+\n+/* Add HT (a hash-table where ever key is a tree) to the list of GC\n+   roots.  */\n+\n+void\n+ggc_add_tree_hash_table_root (base, nelt)\n+     struct hash_table **base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof (struct hash_table *), \n+\t\tggc_mark_tree_hash_table_ptr);\n+}\n+\n+void\n+ggc_add_string_root (base, nelt)\n+     char **base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof (char *), ggc_mark_string_ptr);\n+}\n+\n+\n+void\n+ggc_del_root (base)\n+     void *base;\n+{\n+  struct ggc_root *x, **p;\n+\n+  p = &roots, x = roots;\n+  while (x)\n+    {\n+      if (x->base == base)\n+\t{\n+\t  *p = x->next;\n+\t  free (x);\n+\t  return;\n+\t}\n+      p = &x->next;\n+      x = x->next;\n+    }\n+\n+  abort();\n+}\n+\n+void\n+ggc_mark_rtx (r)\n+     rtx r;\n+{\n+  const char *fmt;\n+  int i;\n+\n+  if (r == NULL_RTX || ggc_set_mark_rtx (r))\n+    return;\n+\n+  /* ??? If (some of) these are really pass-dependant info, do we have\n+     any right poking our noses in?  */\n+  switch (GET_CODE (r))\n+    {\n+    case JUMP_INSN:\n+      ggc_mark_rtx (JUMP_LABEL (r));\n+      break;\n+    case CODE_LABEL:\n+      ggc_mark_rtx (LABEL_REFS (r));\n+      break;\n+    case LABEL_REF:\n+      ggc_mark_rtx (LABEL_NEXTREF (r));\n+      ggc_mark_rtx (CONTAINING_INSN (r));\n+      break;\n+    case ADDRESSOF:\n+      ggc_mark_tree (ADDRESSOF_DECL (r));\n+      break;\n+    case CONST_DOUBLE:\n+      ggc_mark_rtx (CONST_DOUBLE_CHAIN (r));\n+      break;\n+    case NOTE:\n+      switch (NOTE_LINE_NUMBER (r))\n+\t{\n+\tcase NOTE_INSN_RANGE_START:\n+\tcase NOTE_INSN_RANGE_END:\n+\tcase NOTE_INSN_LIVE:\n+\t  ggc_mark_rtx (NOTE_RANGE_INFO (r));\n+\t  break;\n+\n+\tdefault:\n+\t  if (NOTE_LINE_NUMBER (r) >= 0)\n+\t    ggc_mark_string (NOTE_SOURCE_FILE (r));\n+\t  break;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (fmt = GET_RTX_FORMAT (GET_CODE (r)), i = 0; *fmt ; ++fmt, ++i)\n+    {\n+      switch (*fmt)\n+\t{\n+\tcase 'e': case 'u':\n+\t  ggc_mark_rtx (XEXP (r, i));\n+\t  break;\n+\tcase 'V': case 'E':\n+\t  ggc_mark_rtvec (XVEC (r, i));\n+\t  break;\n+\tcase 'S': case 's':\n+\t  ggc_mark_string (XSTR (r, i));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+void\n+ggc_mark_rtvec (v)\n+     rtvec v;\n+{\n+  int i;\n+\n+  if (v == NULL || ggc_set_mark_rtvec (v))\n+    return;\n+\n+  i = GET_NUM_ELEM (v);\n+  while (--i >= 0)\n+    ggc_mark_rtx (RTVEC_ELT (v, i));\n+}\n+\n+void\n+ggc_mark_tree (t)\n+     tree t;\n+{\n+  /* FIXME what if t == NULL_TREE ? */\n+  if (t == NULL || ggc_set_mark_tree (t))\n+    return;\n+\n+  /* Bits from common.  */\n+  ggc_mark_tree (TREE_TYPE (t));\n+  ggc_mark_tree (TREE_CHAIN (t));\n+\n+  /* Some nodes require special handling.  */\n+  switch (TREE_CODE (t))\n+    {\n+    case TREE_LIST:\n+      ggc_mark_tree (TREE_PURPOSE (t));\n+      ggc_mark_tree (TREE_VALUE (t));\n+      return;\n+\n+    case TREE_VEC:\n+      {\n+\tint i = TREE_VEC_LENGTH (t);\n+\twhile (--i >= 0)\n+\t  ggc_mark_tree (TREE_VEC_ELT (t, i));\n+\treturn;\n+      }\n+\n+    case SAVE_EXPR:\n+      ggc_mark_tree (TREE_OPERAND (t, 0));\n+      ggc_mark_tree (SAVE_EXPR_CONTEXT (t));\n+      ggc_mark_rtx (SAVE_EXPR_RTL (t));\n+      return;\n+\n+    case RTL_EXPR:\n+      ggc_mark_rtx (RTL_EXPR_SEQUENCE (t));\n+      ggc_mark_rtx (RTL_EXPR_RTL (t));\n+      return;\n+\n+    case CALL_EXPR:\n+      ggc_mark_tree (TREE_OPERAND (t, 0));\n+      ggc_mark_tree (TREE_OPERAND (t, 1));\n+      ggc_mark_rtx (CALL_EXPR_RTL (t));\n+      return;\n+\n+    case COMPLEX_CST:\n+      ggc_mark_tree (TREE_REALPART (t));\n+      ggc_mark_tree (TREE_IMAGPART (t));\n+      break;\n+\n+    case STRING_CST:\n+      ggc_mark_string (TREE_STRING_POINTER (t));\n+      break;\n+\n+    case PARM_DECL:\n+      ggc_mark_rtx (DECL_INCOMING_RTL (t));\n+      break;\n+\n+    case IDENTIFIER_NODE:\n+      ggc_mark_string (IDENTIFIER_POINTER (t));\n+      lang_mark_tree (t);\n+      return;\n+\n+    default:\n+      break;\n+    }\n+  \n+  /* But in general we can handle them by class.  */\n+  switch (TREE_CODE_CLASS (TREE_CODE (t)))\n+    {\n+    case 'd': /* A decl node.  */\n+      ggc_mark_tree (DECL_SIZE (t));\n+      ggc_mark_tree (DECL_NAME (t));\n+      ggc_mark_tree (DECL_CONTEXT (t));\n+      ggc_mark_tree (DECL_ARGUMENTS (t));\n+      ggc_mark_tree (DECL_RESULT (t));\n+      ggc_mark_tree (DECL_INITIAL (t));\n+      ggc_mark_tree (DECL_ABSTRACT_ORIGIN (t));\n+      ggc_mark_tree (DECL_ASSEMBLER_NAME (t));\n+      ggc_mark_tree (DECL_SECTION_NAME (t));\n+      ggc_mark_tree (DECL_MACHINE_ATTRIBUTES (t));\n+      ggc_mark_rtx (DECL_RTL (t));\n+      ggc_mark_tree (DECL_VINDEX (t));\n+      lang_mark_tree (t);\n+      break;\n+\n+    case 't': /* A type node.  */\n+      ggc_mark_tree (TYPE_SIZE (t));\n+      ggc_mark_tree (TYPE_SIZE_UNIT (t));\n+      ggc_mark_tree (TYPE_ATTRIBUTES (t));\n+      ggc_mark_tree (TYPE_VALUES (t));\n+      ggc_mark_tree (TYPE_POINTER_TO (t));\n+      ggc_mark_tree (TYPE_REFERENCE_TO (t));\n+      ggc_mark_tree (TYPE_NAME (t));\n+      ggc_mark_tree (TYPE_MIN_VALUE (t));\n+      ggc_mark_tree (TYPE_MAX_VALUE (t));\n+      ggc_mark_tree (TYPE_NEXT_VARIANT (t));\n+      ggc_mark_tree (TYPE_MAIN_VARIANT (t));\n+      ggc_mark_tree (TYPE_BINFO (t));\n+      ggc_mark_tree (TYPE_NONCOPIED_PARTS (t));\n+      ggc_mark_tree (TYPE_CONTEXT (t));\n+      lang_mark_tree (t);\n+      break;\n+\n+    case 'b': /* A lexical block.  */\n+      ggc_mark_tree (BLOCK_VARS (t));\n+      ggc_mark_tree (BLOCK_TYPE_TAGS (t));\n+      ggc_mark_tree (BLOCK_SUBBLOCKS (t));\n+      ggc_mark_tree (BLOCK_SUPERCONTEXT (t));\n+      ggc_mark_tree (BLOCK_ABSTRACT_ORIGIN (t));\n+      ggc_mark_rtx (BLOCK_END_NOTE (t));\n+      break;\n+\n+    case 'c': /* A constant.  */\n+      ggc_mark_rtx (TREE_CST_RTL (t));\n+      break;\n+\n+    case 'r': case '<': case '1':\n+    case '2': case 'e': case 's': /* Expressions.  */\n+      {\n+\tint i = tree_code_length[TREE_CODE (t)];\n+\twhile (--i >= 0)\n+\t  ggc_mark_tree (TREE_OPERAND (t, i));\n+\tbreak;\n+      }\n+\n+    case 'x':\n+      lang_mark_tree (t);\n+      break;\n+    }\n+}\n+\n+/* Mark all the elements of the varray V, which contains trees.  */\n+\n+void\n+ggc_mark_tree_varray (v)\n+     varray_type v;\n+{\n+  int i;\n+\n+  if (v)\n+    for (i = v->num_elements - 1; i >= 0; --i) \n+      ggc_mark_tree (VARRAY_TREE (v, i));\n+}\n+\n+/* Mark the hash table-entry HE.  It's key field is really a tree.  */\n+\n+static boolean\n+ggc_mark_tree_hash_table_entry (he, k)\n+     struct hash_entry *he;\n+     hash_table_key k ATTRIBUTE_UNUSED;\n+{\n+  ggc_mark_tree ((tree) he->key);\n+  return true;\n+}\n+\n+/* Mark all the elements of the hash-table H, which contains trees.  */\n+\n+void\n+ggc_mark_tree_hash_table (ht)\n+     struct hash_table *ht;\n+{\n+  hash_traverse (ht, ggc_mark_tree_hash_table_entry, /*info=*/0);\n+}\n+"}, {"sha": "12120be3fd16717f94ed100e5e47a23adf8d4d11", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 19, "deletions": 389, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "patch": "@@ -50,17 +50,6 @@\n \n /* Global lists of roots, rtxs, and trees.  */\n \n-struct ggc_root\n-{\n-  struct ggc_root *next;\n-  void *base;\n-  int nelt;\n-  int size;\n-  void (*cb) PROTO ((void *));\n-};\n-\n-static struct ggc_root *roots;\n-\n struct ggc_rtx\n {\n   struct ggc_rtx *chain;\n@@ -137,14 +126,6 @@ static void ggc_free_tree PROTO ((struct ggc_tree *t));\n static void ggc_free_string PROTO ((struct ggc_string *s));\n static void ggc_free_any PROTO ((struct ggc_any *a));\n \n-static void ggc_mark_rtx_ptr PROTO ((void *elt));\n-static void ggc_mark_tree_ptr PROTO ((void *elt));\n-static void ggc_mark_string_ptr PROTO ((void *elt));\n-static void ggc_mark_tree_varray_ptr PROTO ((void *elt));\n-static void ggc_mark_tree_hash_table_ptr PROTO ((void *elt));\n-static boolean ggc_mark_tree_hash_table_entry PROTO ((struct hash_entry *,\n-\t\t\t\t\t\t      hash_table_key));\n-\n /* Called once to initialize the garbage collector.  */\n \n void \n@@ -346,7 +327,7 @@ ggc_alloc (bytes)\n \n /* Freeing a bit of rtl is as simple as calling free.  */\n \n-static inline void \n+static inline void\n ggc_free_rtx (r)\n      struct ggc_rtx *r;\n {\n@@ -430,252 +411,34 @@ ggc_free_any (a)\n \n /* Mark a node.  */\n \n-void\n-ggc_mark_rtx (r)\n+int\n+ggc_set_mark_rtx (r)\n      rtx r;\n {\n-  const char *fmt;\n-  int i;\n-\n-  if (r == NULL_RTX || r->gc_mark)\n-    return;\n-  r->gc_mark = 1;\n-\n-  /* ??? If (some of) these are really pass-dependant info, do we have\n-     any right poking our noses in?  */\n-  switch (GET_CODE (r))\n-    {\n-    case JUMP_INSN:\n-      ggc_mark_rtx (JUMP_LABEL (r));\n-      break;\n-    case CODE_LABEL:\n-      ggc_mark_rtx (LABEL_REFS (r));\n-      break;\n-    case LABEL_REF:\n-      ggc_mark_rtx (LABEL_NEXTREF (r));\n-      ggc_mark_rtx (CONTAINING_INSN (r));\n-      break;\n-    case ADDRESSOF:\n-      ggc_mark_tree (ADDRESSOF_DECL (r));\n-      break;\n-    case CONST_DOUBLE:\n-      ggc_mark_rtx (CONST_DOUBLE_CHAIN (r));\n-      break;\n-    case NOTE:\n-      switch (NOTE_LINE_NUMBER (r))\n-\t{\n-\tcase NOTE_INSN_RANGE_START:\n-\tcase NOTE_INSN_RANGE_END:\n-\tcase NOTE_INSN_LIVE:\n-\t  ggc_mark_rtx (NOTE_RANGE_INFO (r));\n-\t  break;\n-\n-\tdefault:\n-\t  if (NOTE_LINE_NUMBER (r) >= 0)\n-\t    ggc_mark_string (NOTE_SOURCE_FILE (r));\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  for (fmt = GET_RTX_FORMAT (GET_CODE (r)), i = 0; *fmt ; ++fmt, ++i)\n-    {\n-      switch (*fmt)\n-\t{\n-\tcase 'e': case 'u':\n-\t  ggc_mark_rtx (XEXP (r, i));\n-\t  break;\n-\tcase 'V': case 'E':\n-\t  ggc_mark_rtvec (XVEC (r, i));\n-\t  break;\n-\tcase 'S': case 's':\n-\t  ggc_mark_string (XSTR (r, i));\n-\t  break;\n-\t}\n-    }\n+  int marked = r->gc_mark;\n+  if (! marked)\n+    r->gc_mark = 1;\n+  return marked;\n }\n \n-void\n-ggc_mark_rtvec (v)\n+int\n+ggc_set_mark_rtvec (v)\n      rtvec v;\n {\n-  int i;\n-\n-  if (v == NULL || v->gc_mark)\n-    return;\n-  v->gc_mark = 1;\n-\n-  i = GET_NUM_ELEM (v);\n-  while (--i >= 0)\n-    ggc_mark_rtx (RTVEC_ELT (v, i));\n+  int marked = v->gc_mark;\n+  if (! marked)\n+    v->gc_mark = 1;\n+  return marked;\n }\n \n-void\n-ggc_mark_tree (t)\n+int\n+ggc_set_mark_tree (t)\n      tree t;\n {\n-  if (t == NULL_TREE || t->common.gc_mark)\n-    return;\n-  t->common.gc_mark = 1;\n-\n-  /* Bits from common.  */\n-  ggc_mark_tree (TREE_TYPE (t));\n-  ggc_mark_tree (TREE_CHAIN (t));\n-\n-  /* Some nodes require special handling.  */\n-  switch (TREE_CODE (t))\n-    {\n-    case TREE_LIST:\n-      ggc_mark_tree (TREE_PURPOSE (t));\n-      ggc_mark_tree (TREE_VALUE (t));\n-      return;\n-\n-    case TREE_VEC:\n-      {\n-\tint i = TREE_VEC_LENGTH (t);\n-\twhile (--i >= 0)\n-\t  ggc_mark_tree (TREE_VEC_ELT (t, i));\n-\treturn;\n-      }\n-\n-    case SAVE_EXPR:\n-      ggc_mark_tree (TREE_OPERAND (t, 0));\n-      ggc_mark_tree (SAVE_EXPR_CONTEXT (t));\n-      ggc_mark_rtx (SAVE_EXPR_RTL (t));\n-      return;\n-\n-    case RTL_EXPR:\n-      ggc_mark_rtx (RTL_EXPR_SEQUENCE (t));\n-      ggc_mark_rtx (RTL_EXPR_RTL (t));\n-      return;\n-\n-    case CALL_EXPR:\n-      ggc_mark_tree (TREE_OPERAND (t, 0));\n-      ggc_mark_tree (TREE_OPERAND (t, 1));\n-      ggc_mark_rtx (CALL_EXPR_RTL (t));\n-      return;\n-\n-    case COMPLEX_CST:\n-      ggc_mark_tree (TREE_REALPART (t));\n-      ggc_mark_tree (TREE_IMAGPART (t));\n-      break;\n-\n-    case STRING_CST:\n-      ggc_mark_string (TREE_STRING_POINTER (t));\n-      break;\n-\n-    case PARM_DECL:\n-      ggc_mark_rtx (DECL_INCOMING_RTL (t));\n-      break;\n-\n-    case IDENTIFIER_NODE:\n-      ggc_mark_string (IDENTIFIER_POINTER (t));\n-      lang_mark_tree (t);\n-      return;\n-\n-    default:\n-      break;\n-    }\n-  \n-  /* But in general we can handle them by class.  */\n-  switch (TREE_CODE_CLASS (TREE_CODE (t)))\n-    {\n-    case 'd': /* A decl node.  */\n-      ggc_mark_tree (DECL_SIZE (t));\n-      ggc_mark_tree (DECL_NAME (t));\n-      ggc_mark_tree (DECL_CONTEXT (t));\n-      ggc_mark_tree (DECL_ARGUMENTS (t));\n-      ggc_mark_tree (DECL_RESULT (t));\n-      ggc_mark_tree (DECL_INITIAL (t));\n-      ggc_mark_tree (DECL_ABSTRACT_ORIGIN (t));\n-      ggc_mark_tree (DECL_ASSEMBLER_NAME (t));\n-      ggc_mark_tree (DECL_SECTION_NAME (t));\n-      ggc_mark_tree (DECL_MACHINE_ATTRIBUTES (t));\n-      ggc_mark_rtx (DECL_RTL (t));\n-      ggc_mark_tree (DECL_VINDEX (t));\n-      lang_mark_tree (t);\n-      break;\n-\n-    case 't': /* A type node.  */\n-      ggc_mark_tree (TYPE_SIZE (t));\n-      ggc_mark_tree (TYPE_SIZE_UNIT (t));\n-      ggc_mark_tree (TYPE_ATTRIBUTES (t));\n-      ggc_mark_tree (TYPE_VALUES (t));\n-      ggc_mark_tree (TYPE_POINTER_TO (t));\n-      ggc_mark_tree (TYPE_REFERENCE_TO (t));\n-      ggc_mark_tree (TYPE_NAME (t));\n-      ggc_mark_tree (TYPE_MIN_VALUE (t));\n-      ggc_mark_tree (TYPE_MAX_VALUE (t));\n-      ggc_mark_tree (TYPE_NEXT_VARIANT (t));\n-      ggc_mark_tree (TYPE_MAIN_VARIANT (t));\n-      ggc_mark_tree (TYPE_BINFO (t));\n-      ggc_mark_tree (TYPE_NONCOPIED_PARTS (t));\n-      ggc_mark_tree (TYPE_CONTEXT (t));\n-      lang_mark_tree (t);\n-      break;\n-\n-    case 'b': /* A lexical block.  */\n-      ggc_mark_tree (BLOCK_VARS (t));\n-      ggc_mark_tree (BLOCK_TYPE_TAGS (t));\n-      ggc_mark_tree (BLOCK_SUBBLOCKS (t));\n-      ggc_mark_tree (BLOCK_SUPERCONTEXT (t));\n-      ggc_mark_tree (BLOCK_ABSTRACT_ORIGIN (t));\n-      ggc_mark_rtx (BLOCK_END_NOTE (t));\n-      break;\n-\n-    case 'c': /* A constant.  */\n-      ggc_mark_rtx (TREE_CST_RTL (t));\n-      break;\n-\n-    case 'r': case '<': case '1':\n-    case '2': case 'e': case 's': /* Expressions.  */\n-      {\n-\tint i = tree_code_length[TREE_CODE (t)];\n-\twhile (--i >= 0)\n-\t  ggc_mark_tree (TREE_OPERAND (t, i));\n-\tbreak;\n-      }\n-\n-    case 'x':\n-      lang_mark_tree (t);\n-      break;\n-    }\n-}\n-\n-/* Mark all the elements of the varray V, which contains trees.  */\n-\n-void\n-ggc_mark_tree_varray (v)\n-     varray_type v;\n-{\n-  int i;\n-\n-  if (v)\n-    for (i = v->num_elements - 1; i >= 0; --i) \n-      ggc_mark_tree (VARRAY_TREE (v, i));\n-}\n-\n-/* Mark the hash table-entry HE.  It's key field is really a tree.  */\n-\n-static boolean\n-ggc_mark_tree_hash_table_entry (he, k)\n-     struct hash_entry *he;\n-     hash_table_key k ATTRIBUTE_UNUSED;\n-{\n-  ggc_mark_tree ((tree) he->key);\n-  return true;\n-}\n-\n-/* Mark all the elements of the hash-table H, which contains trees.  */\n-\n-void\n-ggc_mark_tree_hash_table (ht)\n-     struct hash_table *ht;\n-{\n-  hash_traverse (ht, ggc_mark_tree_hash_table_entry, /*info=*/0);\n+  int marked = t->common.gc_mark;\n+  if (! marked)\n+    t->common.gc_mark = 1;\n+  return marked;\n }\n \n void\n@@ -883,139 +646,6 @@ ggc_collect ()\n     }\n }\n \n-/* Manipulate global roots that are needed between calls to gc.  */\n-\n-void\n-ggc_add_root (base, nelt, size, cb)\n-     void *base;\n-     int nelt, size;\n-     void (*cb) PROTO ((void *));\n-{\n-  struct ggc_root *x = (struct ggc_root *) xmalloc (sizeof(*x));\n-\n-  x->next = roots;\n-  x->base = base;\n-  x->nelt = nelt;\n-  x->size = size;\n-  x->cb = cb;\n-\n-  roots = x;\n-}\n-\n-void\n-ggc_add_rtx_root (base, nelt)\n-     rtx *base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof(rtx), ggc_mark_rtx_ptr);\n-}\n-\n-void\n-ggc_add_tree_root (base, nelt)\n-     tree *base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof(tree), ggc_mark_tree_ptr);\n-}\n-\n-void\n-ggc_add_string_root (base, nelt)\n-     char **base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof(char *), ggc_mark_string_ptr);\n-}\n-\n-/* Add V (a varray full of trees) to the list of GC roots.  */\n-\n-void\n-ggc_add_tree_varray_root (base, nelt)\n-     varray_type *base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (varray_type), \n-\t\tggc_mark_tree_varray_ptr);\n-}\n-\n-/* Add HT (a hash-table where ever key is a tree) to the list of GC\n-   roots.  */\n-\n-void\n-ggc_add_tree_hash_table_root (base, nelt)\n-     struct hash_table **base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (struct hash_table *), \n-\t\tggc_mark_tree_hash_table_ptr);\n-}\n-\n-void\n-ggc_del_root (base)\n-     void *base;\n-{\n-  struct ggc_root *x, **p;\n-\n-  p = &roots, x = roots;\n-  while (x)\n-    {\n-      if (x->base == base)\n-\t{\n-\t  *p = x->next;\n-\t  free (x);\n-\t  return;\n-\t}\n-      p = &x->next;\n-      x = x->next;\n-    }\n-\n-  abort();\n-}\n-\n-static void\n-ggc_mark_rtx_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_rtx (*(rtx *)elt);\n-}\n-\n-static void\n-ggc_mark_tree_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_tree (*(tree *)elt);\n-}\n-\n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   ELT (which is really a char **) to ggc_mark_string.  */\n-\n-static void\n-ggc_mark_string_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_string (*(char **)elt);\n-}\n-\n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   ELT (which is really a varray_type *) to ggc_mark_tree_varray.  */\n-\n-static void\n-ggc_mark_tree_varray_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_tree_varray (*(varray_type *)elt);\n-}\n-\n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   ELT (which is really a struct hash_table **) to\n-   ggc_mark_tree_hash_table.  */\n-\n-static void\n-ggc_mark_tree_hash_table_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_tree_hash_table (*(struct hash_table **) elt);\n-}\n-\n #if 0\n /* GDB really should have a memory search function.  Since this is just\n    for initial debugging, I won't even pretend to get the __data_start"}, {"sha": "d7111d62e322018e5904deac25c9b77649afab97", "filename": "gcc/ggc.h", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=b49a6a907c1e3e1cd0b80b0d7879b1709bdf81e7", "patch": "@@ -31,27 +31,63 @@ extern int ggc_p;\n    compiler.  However, rather than force everyone who includes this\n    header to include all the headers in which they are declared, we\n    just forward-declare them here.  */\n-struct label_node;\n struct eh_status;\n struct emit_status;\n+struct hash_table;\n+struct label_node;\n+struct rtvec_def;\n struct stmt_status;\n+union  tree_node;\n struct varasm_status;\n struct varray_head_tag;\n-struct hash_table;\n \n-/* Startup */\n+/* Global roots that are preserved during calls to gc.  */\n+\n+struct ggc_root\n+{\n+  struct ggc_root *next;\n+  void *base;\n+  int nelt;\n+  int size;\n+  void (*cb) PROTO ((void *));\n+};\n+\n+extern struct ggc_root *roots;\n+\n+/* Manipulate global roots that are needed between calls to gc.  */\n+void ggc_add_root PROTO ((void *base, int nelt, int size, void (*)(void *)));\n+void ggc_add_rtx_root PROTO ((struct rtx_def **, int nelt));\n+void ggc_add_tree_root PROTO ((union tree_node **, int nelt));\n+void ggc_add_string_root PROTO ((char **, int nelt));\n+void ggc_add_tree_varray_root PROTO ((struct varray_head_tag **, int nelt));\n+void ggc_add_tree_hash_table_root PROTO ((struct hash_table **, int nelt));\n+void ggc_del_root PROTO ((void *base));\n \n+/* Mark nodes from the gc_add_root callback.  These functions follow\n+   pointers to mark other objects too.  */\n+void ggc_mark_rtx PROTO ((struct rtx_def *));\n+void ggc_mark_rtvec PROTO ((struct rtvec_def *));\n+void ggc_mark_tree PROTO ((union tree_node *));\n+void ggc_mark_tree_varray PROTO ((struct varray_head_tag *));\n+void ggc_mark_tree_hash_table PROTO ((struct hash_table *));\n+void ggc_mark_string PROTO ((char *));\n+void ggc_mark PROTO ((void *));\n+\n+\n+/* A GC implementation must provide these functions.  */\n+\n+/* Initialize the garbage collector.   */\n extern void init_ggc PROTO ((void));\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n extern void ggc_pop_context PROTO ((void));\n+\n /* Finish a GC context.  Any uncollected memory in the new context\n    will be merged with the old context.  */\n extern void ggc_push_context PROTO ((void));\n \n /* Allocation.  */\n-\n struct rtx_def *ggc_alloc_rtx PROTO ((int nslots));\n struct rtvec_def *ggc_alloc_rtvec PROTO ((int nelt));\n union tree_node *ggc_alloc_tree PROTO ((int length));\n@@ -60,26 +96,17 @@ void *ggc_alloc PROTO ((size_t));\n \n /* Invoke the collector.  This is really just a hint, but in the case of\n    the simple collector, the only time it will happen.  */\n-\n void ggc_collect PROTO ((void));\n \n-/* Manipulate global roots that are needed between calls to gc.  */\n-void ggc_add_root PROTO ((void *base, int nelt, int size, void (*)(void *)));\n-void ggc_add_rtx_root PROTO ((struct rtx_def **, int nelt));\n-void ggc_add_tree_root PROTO ((union tree_node **, int nelt));\n-void ggc_add_string_root PROTO ((char **, int nelt));\n-void ggc_add_tree_varray_root PROTO ((struct varray_head_tag **, int nelt));\n-void ggc_add_tree_hash_table_root PROTO ((struct hash_table **, int nelt));\n-void ggc_del_root PROTO ((void *base));\n+/* Actually set the mark on a particular region of memory, but don't\n+   follow pointers.  These functions are called by ggc_mark_*.  They\n+   return zero if the object was not previously marked; they return\n+   non-zero if the object was already marked, or if, for any other\n+   reason, pointers in this data structure should not be traversed.  */\n+int ggc_set_mark_rtx PROTO ((struct rtx_def *));\n+int ggc_set_mark_rtvec PROTO ((struct rtvec_def *));\n+int ggc_set_mark_tree PROTO ((union tree_node *));\n \n-/* Mark nodes from the gc_add_root callback.  */\n-void ggc_mark_rtx PROTO ((struct rtx_def *));\n-void ggc_mark_rtvec PROTO ((struct rtvec_def *));\n-void ggc_mark_tree PROTO ((union tree_node *));\n-void ggc_mark_tree_varray PROTO ((struct varray_head_tag *));\n-void ggc_mark_tree_hash_table PROTO ((struct hash_table *));\n-void ggc_mark_string PROTO ((char *));\n-void ggc_mark PROTO ((void *));\n \n /* Callbacks to the languages.  */\n "}]}