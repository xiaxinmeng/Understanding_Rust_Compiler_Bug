{"sha": "08293addce3c3a274d00a4e9f1eb3612b17e69d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgyOTNhZGRjZTNjM2EyNzRkMDBhNGU5ZjFlYjM2MTJiMTdlNjlkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-27T16:18:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-27T16:18:46Z"}, "message": "(get_inner_unaligned_p): Deleted.\n\n(expand_assignment): Remove special-case of constant array.\n(expand_expr, case ARRAY_REF): Likewise, and clean up remaining code.\n\nFrom-SVN: r14536", "tree": {"sha": "768e01b87eb27d3a1fe3cfc3f0f8e140d08f4abd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/768e01b87eb27d3a1fe3cfc3f0f8e140d08f4abd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08293addce3c3a274d00a4e9f1eb3612b17e69d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08293addce3c3a274d00a4e9f1eb3612b17e69d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08293addce3c3a274d00a4e9f1eb3612b17e69d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08293addce3c3a274d00a4e9f1eb3612b17e69d7/comments", "author": null, "committer": null, "parents": [{"sha": "95a086b10a85107c2354d267a0969e2efb6cf361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a086b10a85107c2354d267a0969e2efb6cf361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95a086b10a85107c2354d267a0969e2efb6cf361"}], "stats": {"total": 122, "additions": 11, "deletions": 111}, "files": [{"sha": "0feb691be3b1fa727406a4cd68977692ff0934cf", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 111, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08293addce3c3a274d00a4e9f1eb3612b17e69d7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08293addce3c3a274d00a4e9f1eb3612b17e69d7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=08293addce3c3a274d00a4e9f1eb3612b17e69d7", "patch": "@@ -168,7 +168,6 @@ static int mostly_zeros_p\tPROTO((tree));\n static void store_constructor\tPROTO((tree, rtx, int));\n static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n \t\t\t\t       enum machine_mode, int, int, int));\n-static int get_inner_unaligned_p PROTO((tree));\n static tree save_noncopied_parts PROTO((tree, tree));\n static tree init_noncopied_parts PROTO((tree, tree));\n static int safe_from_p\t\tPROTO((rtx, tree));\n@@ -2780,12 +2779,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n      an array element in an unaligned packed structure field, has the same\n      problem.  */\n \n-  if (TREE_CODE (to) == COMPONENT_REF\n-      || TREE_CODE (to) == BIT_FIELD_REF\n-      || (TREE_CODE (to) == ARRAY_REF\n-\t  && ((TREE_CODE (TREE_OPERAND (to, 1)) == INTEGER_CST\n-\t       && TREE_CODE (TYPE_SIZE (TREE_TYPE (to))) == INTEGER_CST)\n-\t      || (SLOW_UNALIGNED_ACCESS && get_inner_unaligned_p (to)))))\n+  if (TREE_CODE (to) == COMPONENT_REF || TREE_CODE (to) == BIT_FIELD_REF\n+      || TREE_CODE (to) == ARRAY_REF)\n     {\n       enum machine_mode mode1;\n       int bitsize;\n@@ -4089,37 +4084,6 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n     }\n }\n \f\n-/* Return true if any object containing the innermost array is an unaligned\n-   packed structure field.  */\n-\n-static int\n-get_inner_unaligned_p (exp)\n-     tree exp;\n-{\n-  int needed_alignment = TYPE_ALIGN (TREE_TYPE (exp));\n-\n-  while (1)\n-    {\n-      if (TREE_CODE (exp) == COMPONENT_REF || TREE_CODE (exp) == BIT_FIELD_REF)\n-\t{\n-\t  if (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t      < needed_alignment)\n-\t    return 1;\n-\t}\n-      else if (TREE_CODE (exp) != ARRAY_REF\n-\t       && TREE_CODE (exp) != NON_LVALUE_EXPR\n-\t       && ! ((TREE_CODE (exp) == NOP_EXPR\n-\t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n-\t\t     && (TYPE_MODE (TREE_TYPE (exp))\n-\t\t\t == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))))\n-\tbreak;\n-\n-      exp = TREE_OPERAND (exp, 0);\n-    }\n-\n-  return 0;\n-}\n-\n /* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,\n    or an ARRAY_REF, look for nested COMPONENT_REFs, BIT_FIELD_REFs, or\n    ARRAY_REFs and find the ultimate containing object, which we return.\n@@ -5272,11 +5236,7 @@ expand_expr (exp, target, tmode, modifier)\n \ttree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n \ttree index = TREE_OPERAND (exp, 1);\n \ttree index_type = TREE_TYPE (index);\n-\tint i;\n-\n-\tif (TREE_CODE (low_bound) != INTEGER_CST\n-\t    && contains_placeholder_p (low_bound))\n-\t  low_bound = build (WITH_RECORD_EXPR, sizetype, low_bound, exp);\n+\tHOST_WIDE_INT i;\n \n \t/* Optimize the special-case of a zero lower bound.\n \n@@ -5293,69 +5253,6 @@ expand_expr (exp, target, tmode, modifier)\n \t  index = fold (build (MINUS_EXPR, index_type, index,\n \t\t\t       convert (sizetype, low_bound)));\n \n-\tif ((TREE_CODE (index) != INTEGER_CST\n-\t     || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-\t    && (! SLOW_UNALIGNED_ACCESS || ! get_inner_unaligned_p (exp)))\n-\t  {\n-\t    /* Nonconstant array index or nonconstant element size, and\n-\t       not an array in an unaligned (packed) structure field.\n-\t       Generate the tree for *(&array+index) and expand that,\n-\t       except do it in a language-independent way\n-\t       and don't complain about non-lvalue arrays.\n-\t       `mark_addressable' should already have been called\n-\t       for any array for which this case will be reached.  */\n-\n-\t    /* Don't forget the const or volatile flag from the array\n-\t       element.  */\n-\t    tree variant_type = build_type_variant (type,\n-\t\t\t\t\t\t    TREE_READONLY (exp),\n-\t\t\t\t\t\t    TREE_THIS_VOLATILE (exp));\n-\t    tree array_adr = build1 (ADDR_EXPR,\n-\t\t\t\t     build_pointer_type (variant_type), array);\n-\t    tree elt;\n-\t    tree size = size_in_bytes (type);\n-\n-\t    /* Convert the integer argument to a type the same size as sizetype\n-\t       so the multiply won't overflow spuriously.  */\n-\t    if (TYPE_PRECISION (index_type) != TYPE_PRECISION (sizetype))\n-\t      index = convert (type_for_size (TYPE_PRECISION (sizetype), 0),\n-\t\t\t       index);\n-\n-\t    if (TREE_CODE (size) != INTEGER_CST\n-\t\t&& contains_placeholder_p (size))\n-\t      size = build (WITH_RECORD_EXPR, sizetype, size, exp);\n-\n-\t    /* Don't think the address has side effects\n-\t       just because the array does.\n-\t       (In some cases the address might have side effects,\n-\t       and we fail to record that fact here.  However, it should not\n-\t       matter, since expand_expr should not care.)  */\n-\t    TREE_SIDE_EFFECTS (array_adr) = 0;\n-\n-\t    elt\n-\t      = build1\n-\t\t(INDIRECT_REF, type,\n-\t\t fold (build (PLUS_EXPR,\n-\t\t\t      TYPE_POINTER_TO (variant_type),\n-\t\t\t      array_adr,\n-\t\t\t      fold\n-\t\t\t      (build1\n-\t\t\t       (NOP_EXPR,\n-\t\t\t\tTYPE_POINTER_TO (variant_type),\n-\t\t\t\tfold (build (MULT_EXPR, TREE_TYPE (index),\n-\t\t\t\t\t     index,\n-\t\t\t\t\t     convert (TREE_TYPE (index),\n-\t\t\t\t\t\t      size))))))));;\n-\n-\t    /* Volatility, etc., of new expression is same as old\n-\t       expression.  */\n-\t    TREE_SIDE_EFFECTS (elt) = TREE_SIDE_EFFECTS (exp);\n-\t    TREE_THIS_VOLATILE (elt) = TREE_THIS_VOLATILE (exp);\n-\t    TREE_READONLY (elt) = TREE_READONLY (exp);\n-\n-\t    return expand_expr (elt, target, tmode, modifier);\n-\t  }\n-\n \t/* Fold an expression like: \"foo\"[2].\n \t   This is not done in fold so it won't happen inside &.\n \t   Don't fold if this is for wide characters since it's too\n@@ -5395,8 +5292,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n \t\t && TREE_CODE (DECL_INITIAL (array)) != ERROR_MARK)\n \t  {\n-\t    if (TREE_CODE (index) == INTEGER_CST\n-\t\t&& TREE_INT_CST_HIGH (index) == 0)\n+\t    if (TREE_CODE (index) == INTEGER_CST)\n \t      {\n \t\ttree init = DECL_INITIAL (array);\n \n@@ -5413,13 +5309,17 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t  tmode, modifier);\n \t\t  }\n \t\telse if (TREE_CODE (init) == STRING_CST\n-\t\t\t && i < TREE_STRING_LENGTH (init))\n-\t\t  return GEN_INT (TREE_STRING_POINTER (init)[i]);\n+\t\t\t && TREE_INT_CST_HIGH (index) == 0\n+\t\t\t && (TREE_INT_CST_LOW (index)\n+\t\t\t     < TREE_STRING_LENGTH (init)))\n+\t\t  return (GEN_INT\n+\t\t\t  (TREE_STRING_POINTER\n+\t\t\t   (init)[TREE_INT_CST_LOW (index)]));\n \t      }\n \t  }\n       }\n \n-      /* Treat array-ref with constant index as a component-ref.  */\n+      /* ... fall through ... */\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:"}]}