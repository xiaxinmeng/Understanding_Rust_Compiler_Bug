{"sha": "edff249168080e7c7c893f57c0c578819afcb348", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRmZjI0OTE2ODA4MGU3YzdjODkzZjU3YzBjNTc4ODE5YWZjYjM0OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-17T15:25:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-17T15:25:37Z"}, "message": "(allocate_dynamic_stack_space): Call probe_stack_range.\n\n(emit_stack_probe, probe_stack_range): New functions.\n\nFrom-SVN: r14469", "tree": {"sha": "611e8a3cb4aaafe227783a44930a27d7ddbc236b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/611e8a3cb4aaafe227783a44930a27d7ddbc236b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edff249168080e7c7c893f57c0c578819afcb348", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edff249168080e7c7c893f57c0c578819afcb348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edff249168080e7c7c893f57c0c578819afcb348", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edff249168080e7c7c893f57c0c578819afcb348/comments", "author": null, "committer": null, "parents": [{"sha": "bf1c53323f786a2ddb581faa32372f6fdf9939ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1c53323f786a2ddb581faa32372f6fdf9939ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1c53323f786a2ddb581faa32372f6fdf9939ee"}], "stats": {"total": 134, "additions": 133, "deletions": 1}, "files": [{"sha": "bb34272b3f8f58dadbcdcb1ba5bb383feb135f08", "filename": "gcc/explow.c", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edff249168080e7c7c893f57c0c578819afcb348/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edff249168080e7c7c893f57c0c578819afcb348/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=edff249168080e7c7c893f57c0c578819afcb348", "patch": "@@ -31,7 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-codes.h\"\n \n static rtx break_out_memory_refs\tPROTO((rtx));\n-\n+static void emit_stack_probe\t\tPROTO((rtx));\n /* Return an rtx for the sum of X and the integer C.\n \n    This function should be used via the `plus_constant' macro.  */\n@@ -1077,6 +1077,11 @@ allocate_dynamic_stack_space (size, target, known_align)\n \n   do_pending_stack_adjust ();\n \n+  /* If needed, check that we have the required amount of stack.  Take into\n+     account what has already been checked.  */\n+  if (flag_stack_check && ! STACK_CHECK_BUILTIN)\n+    probe_stack_range (STACK_CHECK_MAX_FRAME_SIZE + STACK_CHECK_PROTECT, size);\n+\n   /* Don't use a TARGET that isn't a pseudo.  */\n   if (target == 0 || GET_CODE (target) != REG\n       || REGNO (target) < FIRST_PSEUDO_REGISTER)\n@@ -1147,6 +1152,133 @@ allocate_dynamic_stack_space (size, target, known_align)\n   return target;\n }\n \f\n+/* Emit one stack probe at ADDRESS, an address within the stack.  */\n+\n+static void\n+emit_stack_probe (address)\n+     rtx address;\n+{\n+  rtx memref = gen_rtx (MEM, word_mode, address);\n+\n+  MEM_VOLATILE_P (memref) = 1;\n+\n+  if (STACK_CHECK_PROBE_LOAD)\n+    emit_move_insn (gen_reg_rtx (word_mode), memref);\n+  else\n+    emit_move_insn (memref, const0_rtx);\n+}\n+\n+/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive. \n+   FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n+   current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n+   subtract from the stack.  If SIZE is constant, this is done\n+   with a fixed number of probes.  Otherwise, we must make a loop.  */\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+#define STACK_GROW_OP MINUS\n+#else\n+#define STACK_GROW_OP PLUS\n+#endif\n+\n+void\n+probe_stack_range (first, size)\n+     HOST_WIDE_INT first;\n+     rtx size;\n+{\n+  /* First see if we have an insn to check the stack.  Use it if so.  */\n+#ifdef HAVE_check_stack\n+  if (HAVE_check_stack)\n+    {\n+      rtx last_addr = force_operand (gen_rtx (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      plus_constant (size, first)),\n+\t\t\t\t     NULL_RTX);\n+\n+      if (insn_operand_predicate[(int) CODE_FOR_check_stack][0]\n+\t  && ! ((*insn_operand_predicate[(int) CODE_FOR_check_stack][0])\n+\t\t(last_address, Pmode)))\n+\tlast_address = copy_to_mode_reg (Pmode, last_address);\n+\n+      emit_insn (gen_check_stack (last_address));\n+      return;\n+    }\n+#endif\n+\n+  /* If we have to generate explicit probes, see if we have a constant\n+     number of them to generate.  If so, that's the easy case.  */\n+  if (GET_CODE (size) == CONST_INT)\n+    {\n+      HOST_WIDE_INT offset;\n+\n+      /* Start probing at FIRST + N * STACK_CHECK_PROBE_INTERVAL\n+\t for values of N from 1 until it exceeds LAST.  If only one\n+\t probe is needed, this will not generate any code.  Then probe\n+\t at LAST.  */\n+      for (offset = first + STACK_CHECK_PROBE_INTERVAL;\n+\t   offset < INTVAL (size);\n+\t   offset = offset + STACK_CHECK_PROBE_INTERVAL)\n+\temit_stack_probe (gen_rtx (STACK_GROW_OP, Pmode,\n+\t\t\t\t   stack_pointer_rtx, GEN_INT (offset)));\n+\n+      emit_stack_probe (gen_rtx (STACK_GROW_OP, Pmode, stack_pointer_rtx,\n+\t\t\t\t plus_constant (size, first)));\n+    }\n+\n+  /* In the variable case, do the same as above, but in a loop.  We emit loop\n+     notes so that loop optimization can be done.  */\n+  else\n+    {\n+      rtx test_addr\n+\t= force_operand (gen_rtx (STACK_GROW_OP, Pmode, stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (first\n+\t\t\t\t\t   + STACK_CHECK_PROBE_INTERVAL)),\n+\t\t\t NULL_RTX);\n+      rtx last_addr\n+\t= force_operand (gen_rtx (STACK_GROW_OP, Pmode, stack_pointer_rtx,\n+\t\t\t\t  plus_constant (size, first)),\n+\t\t\t NULL_RTX);\n+      rtx incr = GEN_INT (STACK_CHECK_PROBE_INTERVAL);\n+      rtx loop_lab = gen_label_rtx ();\n+      rtx test_lab = gen_label_rtx ();\n+      rtx end_lab = gen_label_rtx ();\n+      rtx temp;\n+\n+      if (GET_CODE (test_addr) != REG\n+\t  || REGNO (test_addr) < FIRST_PSEUDO_REGISTER)\n+\ttest_addr = force_reg (Pmode, test_addr);\n+\n+      emit_note (NULL_PTR, NOTE_INSN_LOOP_BEG);\n+      emit_jump (test_lab);\n+\n+      emit_label (loop_lab);\n+      emit_stack_probe (test_addr);\n+\n+      emit_note (NULL_PTR, NOTE_INSN_LOOP_CONT);\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+#define CMP_OPCODE GTU\n+      temp = expand_binop (Pmode, sub_optab, test_addr, incr, test_addr,\n+\t\t\t   1, OPTAB_WIDEN);\n+#else\n+#define CMP_OPCODE LTU\n+      temp = expand_binop (Pmode, add_optab, test_addr, incr, test_addr,\n+\t\t\t   1, OPTAB_WIDEN);\n+#endif\n+\n+      if (temp != test_addr)\n+\tabort ();\n+\n+      emit_label (test_lab);\n+      emit_cmp_insn (test_addr, last_addr, CMP_OPCODE, NULL_RTX, Pmode, 1, 0);\n+      emit_jump_insn ((*bcc_gen_fctn[(int) CMP_OPCODE]) (loop_lab));\n+      emit_jump (end_lab);\n+      emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n+      emit_label (end_lab);\n+\n+      emit_stack_probe (last_addr);\n+    }\n+}\n+\f\n /* Return an rtx representing the register or memory location\n    in which a scalar value of data type VALTYPE\n    was returned by a function call to function FUNC."}]}