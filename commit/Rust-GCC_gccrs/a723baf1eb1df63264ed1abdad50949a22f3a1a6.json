{"sha": "a723baf1eb1df63264ed1abdad50949a22f3a1a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcyM2JhZjFlYjFkZjYzMjY0ZWQxYWJkYWQ1MDk0OWEyMmYzYTFhNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-12-28T08:03:42Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-12-28T08:03:42Z"}, "message": "Make-lang.in (po-generated): Remove parse.c.\n\n\t* Make-lang.in (po-generated): Remove parse.c.\n\t(CXX_OBJS): Remove parse.o and spew.o.  Add parser.o.\n\t($(srcdir)/cp/parse.h): Remove target.\n\t($(srcdir)/cp/parse.c): Likewise.\n\t(gt-cp-parse.h): Likewise.\n\t(gt-cp-parser.h): New target.\n\t(c++.distclean): Do not remove parse.output.\n\t(c++.maintainer-clean): Do not remove parse.c or parse.h.\n\t(cp/spew.o): Remove target.\n\t(cp/lex.o): Adjust dependencies.\n\t(cp/pt.o): Likewise.\n\t(cp/parse.o): Likewise.\n\t(cp/TAGS): Do not mention parse.c.\n\t(cp/parser.o): New target.\n\t* NEWS: Mention the new parser.\n\t* call.c (build_scoped_method_call): Simplify.\n\t(build_method_call): Likewise.\n\t(build_new_function_call): Adjust calls to add_function_candidate\n\tand add_template_candidate.\n\t(build_new_op): Improve handling of erroroneous operands.\n\t(convert_default_arg): Remove circular argument processing.\n\t(name_as_c_string): New function.\n\t(build_new_method_call): Use it.\n\t(perform_implicit_conversion): Use error_operand_p.\n\t* class.c (finish_struct_anon): Use constructor_name_p.\n\t(check_field_decls): Likewise.\n\t(pop_nested_class): Use OVL_NEXT, not OVL_CHAIN.\n\t(resolve_address_of_overloaded_function): Likewise.\n\t(instantiate_type): Tweak pointer-to-member handling.\n\t(get_primary_binfo): Remove incorrect assertion.\n\t* config-lang.in (gtfiles): Add parser.c, remove parse.c.\n\t* cp-tree.h (DEFARG_TOKENS): New macro.\n\t(default_arg): New structure.\n\t(cp_tree_node_structure_enum): Add TS_CP_DEFAULT_ARG.\n\t(lang_tree_node): Add default_arg.\n\t(cp_tree_index): Add CPTI_TYPE_INFO_REF_TYPE.\n\t(type_info_ref_type): New macro.\n\t(saved_scope): Make processing_explicit_instantiation a boolean.\n\t(check_access): New field.\n\t(unparsed_text): Remove.\n\t(language_function): Remove unparsed_inlines.\n\t(error_operand_p): New macro.\n\t(lang_decl): Adjust pending_inline_info.\n\t(DEFARG_POINTER): Remove.\n\t(tag_types): Add typenames.\n\t(lookup_ualified_name): Declare.\n\t(lookup_name_real): Likewise.\n\t(shadow_tag): Adjust prototype.\n\t(get_scope_of_declarator): Declare it.\n\t(process_next_inline): Remove it.\n\t(check_for_missing_semicolon): Likewise.\n\t(maybe_get_template_decl_from_type_decl): Declare it.\n\t(finish_label_stmt): Adjust prototype.\n\t(finish_non_static_data_meber): Declare it.\n\t(finish_pseudo_destructor_call_expr): Rename to ...\n\t(finish_pseudo_destructor_expr): ... this.\n\t(finish_compound_literal): Declare it.\n\t(begin_inline_definitions): Remove it.\n\t(init_spew): Remove.\n\t(peekyylex): Likewise.\n\t(arbitrate_lookup): Likewise.\n\t(frob_opname): Likewise.\n\t(maybe_snarf_defarg): Likewise.\n\t(add_defarg_fn): Likewise.\n\t(do_pending_defargs): Likewise.\n\t(done_pending_defargs): Likewise.\n\t(unprocessed_defarg_fn): Likewise.\n\t(replace_defarg): Likewise.\n\t(end_input): Likewise.\n\t(get_overloaded_fn): Likewise.\n\t* cvt.c (convert_to_reference): Improve error handling.\n\t* decl.c (lookup_name_real): Do not declare it static.\n\t(maybe_push_to_top_level): Set check_access.\n\t(identifier_type_value): Adjust call to lookup_name_real.\n\t(lookup_qualified_name): New method.\n\t(lookup_name_real): Remove special-case parsing code.\n\t(lookup_name-nonclass): Adjust call to lookup_name_real.\n\t(lookup_name_namespace_only): Likewise.\n\t(lookup_name): Likewise.\n\t(check_tag_decl): Return the type declared.\n\t(shadow_tag): Likewise.\n\t(register_dtor_fn): Tweak check_access.\n\t(grokfndecl): Use constructor_name_p.\n\t(get_scope_of_declarator): New function.\n\t(grokdeclarator): Obscure tweaks for slightly different declarator\n\trepresentations.\n\t(start_method): Return error_mark_node to indicate failure.\n\t(cp_tree_node_structure_enum): Use TS_CP_DEFAULT_ARG for DEFAULT_ARGs.\n\t* decl2.c (constructor_name_full): Simplify.\n\t(constructor_name): Use it.\n\t(build_expr_from_tree): Adjust for changes to do new parser.\n\t(push_scope): Improve robustness.\n\t(validate_nonmember_using_decl): Process declarations, not names.\n\t(do_class_using_decl): Likewise.\n\t(handle_class_head): Do not mess with CLASSTYPE_DECLARED_CLASS\n\there.\n\t* error.c (dump_expr): Handle IDENTIFIER_NODEs and BASELINKs.\n\t* expr.c (cxx_expand_expr): Handle BASELINKs.\n\t* init.c (member_init_ok_or_else): Issue more errors.\n\t(build_offset_ref): Tweak handling of FUNCTION_DECLs.\n\t* lex.c: Do not include parse.h.\n\t(yypring): Do not declare.\n\t(yylval): Likewise.\n\t(make_reference_declarator): Remove error-generating code.\n\t(rid_to_yy): Remove.\n\t(cxx_init): Do not call init_spew.\n\t(yypring): Remove.\n\t(check_for_missing_semicolon): Remove.\n\t* lex.h (got_scope): Remove.\n\t(got_object): Remove.\n\t* method.c (hack_identifier): Use finish_non_static_data_member.\n\t(implicitly_declare_fn): Adjust use of constructor_name.\n\t* parser.c: New file.\n\t* pt.c (parse.h): Do not include it.\n\t(maybe_get_template_decl_from_template): Do not declare it.\n\t(finish_member_template_decl): Tweak.\n\t(begin_explicit_instantiation): Adjust for\n\tprocessing_explicit_instantiation being boolean.\n\t(end_explicit_instantiation): Likewise.\n\t(maybe_process_partial_specialization): Tighten specialization\n\ttest.\n\t(retrieve_local_specialization): Adjust ue of hash table.\n\t(eq_local_specializations): New function.\n\t(register_local_specialization): Likewise.\n\t(push_template_decl_real): Remove unnecessary test.\n\t(maybe_get_template_decl_from_type_decl): Don't make it static.\n\t(for_each_template_parm_r): Handle TYPEOF_TYPE.\n\t(tsubst_copy): Use retrieive_local_specialization to handle\n\tPARM_DECL.  Adjust handling of CONST_DECLs.  Handle BASELINKs.\n\tHandle COMPONENT_REFs with pseudo-destructor-expressions.\n\tSimplify handling of CALL_EXPR and METHOD_CALL_EXPR.\n\t(tsubst_expr): Pass decls, not names, to do_local_using_decl.\n\t(unify): Tweak handling of CONST_DECLs.\n\t(regenerate_decl_from_template): Use push_nested_class.\n\t(template_for_substitution): New funciton.\n\t(instantiate_decl): Use it.  Register parameters as local\n\tspecializations.\n\t* rtti.c (init_rtti_processing): Set type_info_ref_type.\n\t(build_typeid): Use it.\n\t(get_typeid): Likeise.\n\t* search.c (accessible_p): Use check_access, not\n\tflag_access_control.\n\t(adjust_result_of_qualified_name_lookup): Pay attention to the\n\tcontext_class.\n\t* semantics.c (finish_asm_stmt): Adjust error handling.\n\t(finish_label_stmt): Return the statement.\n\t(finish_non_static_data_member): New function.\n\t(finish_class_expr): Handle BASELINKs.\n\t(finish_call_expr): Handle PSEUDO_DTOR_EXPR.\n\t(finish_object_call_expr): Simplify handling during templates.\n\t(finish_pseudo_destructor_call_expr): Rename to ...\n\t(finish_pseudo_dtor_expr): ... this.\n\t(finish_compound_literal): New function.\n\t(begin_inline_definitions): Remove.\n\t(finish_sizeof): Remove special template handling.\n\t* spew.c: Do not include parse.h.\n\t* tree.c (get_overloaded_fn): Remove.\n\t* typeck.c (build_class_member_access_expr): Handle\n\tPSEUDO_DTOR_EXPR.  Adjust handling of static member functions.\n\t(lookup_destructor): New function.\n\t(finish_class_member_access_expr): Use it.\n\t(convert_arguments): Simplify.\n\t(build_unary_op): Handle BASELINKs.\n\nFrom-SVN: r60560", "tree": {"sha": "d28b4e9177babf3ab20501e8815d90b01ecf7162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d28b4e9177babf3ab20501e8815d90b01ecf7162"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a723baf1eb1df63264ed1abdad50949a22f3a1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a723baf1eb1df63264ed1abdad50949a22f3a1a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a723baf1eb1df63264ed1abdad50949a22f3a1a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a723baf1eb1df63264ed1abdad50949a22f3a1a6/comments", "author": null, "committer": null, "parents": [{"sha": "876200a8b7c2cb7e4af9c2d01c712fe78d7bc197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876200a8b7c2cb7e4af9c2d01c712fe78d7bc197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876200a8b7c2cb7e4af9c2d01c712fe78d7bc197"}], "stats": {"total": 17263, "additions": 16151, "deletions": 1112}, "files": [{"sha": "077b97b1acbfa3d0b74810e1c5d2df01fc90ad9b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -1,3 +1,169 @@\n+2002-12-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Make-lang.in (po-generated): Remove parse.c.\n+\t(CXX_OBJS): Remove parse.o and spew.o.  Add parser.o.\n+\t($(srcdir)/cp/parse.h): Remove target.\n+\t($(srcdir)/cp/parse.c): Likewise.\n+\t(gt-cp-parse.h): Likewise.\n+\t(gt-cp-parser.h): New target.\n+\t(c++.distclean): Do not remove parse.output.\n+\t(c++.maintainer-clean): Do not remove parse.c or parse.h.\n+\t(cp/spew.o): Remove target.\n+\t(cp/lex.o): Adjust dependencies.\n+\t(cp/pt.o): Likewise.\n+\t(cp/parse.o): Likewise.\n+\t(cp/TAGS): Do not mention parse.c.\n+\t(cp/parser.o): New target.\n+\t* NEWS: Mention the new parser.\n+\t* call.c (build_scoped_method_call): Simplify.\n+\t(build_method_call): Likewise.\n+\t(build_new_function_call): Adjust calls to add_function_candidate\n+\tand add_template_candidate.\n+\t(build_new_op): Improve handling of erroroneous operands.\n+\t(convert_default_arg): Remove circular argument processing.\n+\t(name_as_c_string): New function.\n+\t(build_new_method_call): Use it.\n+\t(perform_implicit_conversion): Use error_operand_p.\n+\t* class.c (finish_struct_anon): Use constructor_name_p.\n+\t(check_field_decls): Likewise.\n+\t(pop_nested_class): Use OVL_NEXT, not OVL_CHAIN.\n+\t(resolve_address_of_overloaded_function): Likewise.\n+\t(instantiate_type): Tweak pointer-to-member handling.\n+\t(get_primary_binfo): Remove incorrect assertion.\n+\t* config-lang.in (gtfiles): Add parser.c, remove parse.c.\n+\t* cp-tree.h (DEFARG_TOKENS): New macro.\n+\t(default_arg): New structure.\n+\t(cp_tree_node_structure_enum): Add TS_CP_DEFAULT_ARG.\n+\t(lang_tree_node): Add default_arg.\n+\t(cp_tree_index): Add CPTI_TYPE_INFO_REF_TYPE.\n+\t(type_info_ref_type): New macro.\n+\t(saved_scope): Make processing_explicit_instantiation a boolean.\n+\t(check_access): New field.\n+\t(unparsed_text): Remove.\n+\t(language_function): Remove unparsed_inlines.\n+\t(error_operand_p): New macro.\n+\t(lang_decl): Adjust pending_inline_info.\n+\t(DEFARG_POINTER): Remove.\n+\t(tag_types): Add typenames.\n+\t(lookup_ualified_name): Declare.\n+\t(lookup_name_real): Likewise.\n+\t(shadow_tag): Adjust prototype.\n+\t(get_scope_of_declarator): Declare it.\n+\t(process_next_inline): Remove it.\n+\t(check_for_missing_semicolon): Likewise.\n+\t(maybe_get_template_decl_from_type_decl): Declare it.\n+\t(finish_label_stmt): Adjust prototype.\n+\t(finish_non_static_data_meber): Declare it.\n+\t(finish_pseudo_destructor_call_expr): Rename to ...\n+\t(finish_pseudo_destructor_expr): ... this.\n+\t(finish_compound_literal): Declare it.\n+\t(begin_inline_definitions): Remove it.\n+\t(init_spew): Remove.\n+\t(peekyylex): Likewise.\n+\t(arbitrate_lookup): Likewise.\n+\t(frob_opname): Likewise.\n+\t(maybe_snarf_defarg): Likewise.\n+\t(add_defarg_fn): Likewise.\n+\t(do_pending_defargs): Likewise.\n+\t(done_pending_defargs): Likewise.\n+\t(unprocessed_defarg_fn): Likewise.\n+\t(replace_defarg): Likewise.\n+\t(end_input): Likewise.\n+\t(get_overloaded_fn): Likewise.\n+\t* cvt.c (convert_to_reference): Improve error handling.\n+\t* decl.c (lookup_name_real): Do not declare it static.\n+\t(maybe_push_to_top_level): Set check_access.\n+\t(identifier_type_value): Adjust call to lookup_name_real.\n+\t(lookup_qualified_name): New method.\n+\t(lookup_name_real): Remove special-case parsing code.\n+\t(lookup_name-nonclass): Adjust call to lookup_name_real.\n+\t(lookup_name_namespace_only): Likewise.\n+\t(lookup_name): Likewise.\n+\t(check_tag_decl): Return the type declared.\n+\t(shadow_tag): Likewise.\n+\t(register_dtor_fn): Tweak check_access.\n+\t(grokfndecl): Use constructor_name_p.\n+\t(get_scope_of_declarator): New function.\n+\t(grokdeclarator): Obscure tweaks for slightly different declarator\n+\trepresentations.\n+\t(start_method): Return error_mark_node to indicate failure.\n+\t(cp_tree_node_structure_enum): Use TS_CP_DEFAULT_ARG for DEFAULT_ARGs. \n+\t* decl2.c (constructor_name_full): Simplify.\n+\t(constructor_name): Use it.\n+\t(build_expr_from_tree): Adjust for changes to do new parser.\n+\t(push_scope): Improve robustness.\n+\t(validate_nonmember_using_decl): Process declarations, not names.\n+\t(do_class_using_decl): Likewise.\n+\t(handle_class_head): Do not mess with CLASSTYPE_DECLARED_CLASS\n+\there.\n+\t* error.c (dump_expr): Handle IDENTIFIER_NODEs and BASELINKs.\n+\t* expr.c (cxx_expand_expr): Handle BASELINKs.\n+\t* init.c (member_init_ok_or_else): Issue more errors.\n+\t(build_offset_ref): Tweak handling of FUNCTION_DECLs.\n+\t* lex.c: Do not include parse.h.\n+\t(yypring): Do not declare.\n+\t(yylval): Likewise.\n+\t(make_reference_declarator): Remove error-generating code.\n+\t(rid_to_yy): Remove.\n+\t(cxx_init): Do not call init_spew.\n+\t(yypring): Remove.\n+\t(check_for_missing_semicolon): Remove.\n+\t* lex.h (got_scope): Remove.\n+\t(got_object): Remove.\n+\t* method.c (hack_identifier): Use finish_non_static_data_member.\n+\t(implicitly_declare_fn): Adjust use of constructor_name.\n+\t* parser.c: New file.\n+\t* pt.c (parse.h): Do not include it.\n+\t(maybe_get_template_decl_from_template): Do not declare it.\n+\t(finish_member_template_decl): Tweak.\n+\t(begin_explicit_instantiation): Adjust for\n+\tprocessing_explicit_instantiation being boolean.\n+\t(end_explicit_instantiation): Likewise.\n+\t(maybe_process_partial_specialization): Tighten specialization\n+\ttest.\n+\t(retrieve_local_specialization): Adjust ue of hash table.\n+\t(eq_local_specializations): New function.\n+\t(register_local_specialization): Likewise.\n+\t(push_template_decl_real): Remove unnecessary test.\n+\t(maybe_get_template_decl_from_type_decl): Don't make it static.\n+\t(for_each_template_parm_r): Handle TYPEOF_TYPE.\n+\t(tsubst_copy): Use retrieive_local_specialization to handle\n+\tPARM_DECL.  Adjust handling of CONST_DECLs.  Handle BASELINKs.\n+\tHandle COMPONENT_REFs with pseudo-destructor-expressions.\n+\tSimplify handling of CALL_EXPR and METHOD_CALL_EXPR.\n+\t(tsubst_expr): Pass decls, not names, to do_local_using_decl.\n+\t(unify): Tweak handling of CONST_DECLs.\n+\t(regenerate_decl_from_template): Use push_nested_class.\n+\t(template_for_substitution): New funciton.\n+\t(instantiate_decl): Use it.  Register parameters as local\n+\tspecializations.\n+\t* rtti.c (init_rtti_processing): Set type_info_ref_type.\n+\t(build_typeid): Use it.\n+\t(get_typeid): Likeise.\n+\t* search.c (accessible_p): Use check_access, not\n+\tflag_access_control.\n+\t(adjust_result_of_qualified_name_lookup): Pay attention to the\n+\tcontext_class.\n+\t* semantics.c (finish_asm_stmt): Adjust error handling.\n+\t(finish_label_stmt): Return the statement.\n+\t(finish_non_static_data_member): New function.\n+\t(finish_class_expr): Handle BASELINKs.\n+\t(finish_call_expr): Handle PSEUDO_DTOR_EXPR.\n+\t(finish_object_call_expr): Simplify handling during templates.\n+\t(finish_pseudo_destructor_call_expr): Rename to ...\n+\t(finish_pseudo_dtor_expr): ... this.\n+\t(finish_compound_literal): New function.\n+\t(begin_inline_definitions): Remove.\n+\t(finish_sizeof): Remove special template handling.\n+\t* spew.c: Do not include parse.h.\n+\t* tree.c (get_overloaded_fn): Remove.\n+\t* typeck.c (build_class_member_access_expr): Handle\n+\tPSEUDO_DTOR_EXPR.  Adjust handling of static member functions.\n+\t(lookup_destructor): New function.\n+\t(finish_class_member_access_expr): Use it.\n+\t(convert_arguments): Simplify.\n+\t(build_unary_op): Handle BASELINKs.\n+\t\n 2002-12-26  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/4803"}, {"sha": "294ee52a3a07242e66f88693d21015ac8cf04318", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -63,7 +63,7 @@ g++spec.o: $(srcdir)/cp/g++spec.c $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) $(CON\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(DRIVER_DEFINES) \\\n \t\t$(INCLUDES) $(srcdir)/cp/g++spec.c)\n \n-po-generated: $(srcdir)/cp/parse.c\n+po-generated:\n \n # Create the compiler driver for g++.\n GXX_OBJS = gcc.o g++spec.o intl.o prefix.o version.o \n@@ -83,8 +83,8 @@ CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n- cp/class.o cp/decl2.o cp/error.o cp/lex.o cp/parse.o cp/ptree.o cp/rtti.o \\\n- cp/spew.o cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n+ cp/class.o cp/decl2.o cp/error.o cp/lex.o cp/parser.o cp/ptree.o cp/rtti.o \\\n+ cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o \\\n  cp/optimize.o cp/mangle.o cp/cp-lang.o\n \n@@ -101,21 +101,8 @@ $(srcdir)/cp/cfns.h: $(srcdir)/cp/cfns.gperf\n \tgperf -o -C -E -k '1-6,$$' -j1 -D -N 'libc_name_p' \\\n \t\t$(srcdir)/cp/cfns.gperf > $(srcdir)/cp/cfns.h\n \n-$(srcdir)/cp/parse.h: $(srcdir)/cp/parse.c\n-$(srcdir)/cp/parse.c: $(srcdir)/cp/parse.y\n-\t@echo \"Expect 33 shift/reduce conflicts and 58 reduce/reduce conflicts.\"\n-\tcd $(srcdir)/cp && \\\n-\tif $(BISON) $(BISONFLAGS) -d -o p$$$$.c parse.y; then \\\n-\t  grep '^#define[ \t]*YYEMPTY' p$$$$.c >> p$$$$.h ; \\\n-\t  test -f p$$$$.output && mv -f p$$$$.output parse.output ; \\\n-\t  mv -f p$$$$.c parse.c ; mv -f p$$$$.h parse.h ; \\\n-\telse \\\n-\t  rm -f p$$$$.* ; \\\n-\t  false ; \\\n-\tfi\n-\n gtype-cp.h gt-cp-call.h gt-cp-decl.h gt-cp-decl2.h : s-gtype; @true\n-gt-cp-parse.h gt-cp-pt.h gt-cp-repo.h gt-cp-spew.h : s-gtype; @true\n+gt-cp-pt.h gt-cp-repo.h gt-cp-spew.h gt-cp-parser.h : s-gtype; @true\n gt-cp-tree.h : s-gtype; @true\n \n #\f\n@@ -199,10 +186,8 @@ c++.mostlyclean:\n c++.clean:\n c++.distclean:\n \t-rm -f cp/config.status cp/Makefile\n-\t-rm -f $(srcdir)/cp/parse.output\n c++.extraclean:\n c++.maintainer-clean:\n-\t-rm -f $(srcdir)/cp/parse.c $(srcdir)/cp/parse.h\n #\f\n # Stage hooks:\n # The main makefile has already created stage?/cp.\n@@ -222,9 +207,7 @@ CXX_TREE_H = $(TREE_H) cp/cp-tree.h c-common.h cp/cp-tree.def c-common.def \\\n \tfunction.h varray.h $(SYSTEM_H) coretypes.h $(CONFIG_H) $(TARGET_H) \\\n \t$(srcdir)/../include/hashtab.h $(srcdir)/../include/splay-tree.h\n \n-cp/spew.o: cp/spew.c $(CXX_TREE_H) $(TM_H) $(srcdir)/cp/parse.h flags.h cp/lex.h \\\n-  toplev.h gt-cp-spew.h\n-cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) $(srcdir)/cp/parse.h flags.h cp/lex.h \\\n+cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h \\\n   c-pragma.h toplev.h output.h mbchar.h $(GGC_H) input.h diagnostic.h \\\n   cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h langhooks.h \\\n@@ -257,7 +240,7 @@ cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h toplev.\n   cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n-cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h $(srcdir)/cp/parse.h cp/lex.h \\\n+cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/lex.h \\\n   toplev.h $(GGC_H) $(RTL_H) except.h tree-inline.h gt-cp-pt.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) toplev.h diagnostic.h flags.h real.h \\\n   $(LANGHOOKS_DEF_H)\n@@ -271,17 +254,13 @@ cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h integrate.h insn-config\n   input.h $(PARAMS_H) debug.h tree-inline.h\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h real.h\n \n-cp/parse.o: cp/parse.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h except.h output.h \\\n-\tcp/decl.h toplev.h $(GGC_H) gt-cp-parse.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n-\t\t$(srcdir)/cp/parse.c $(OUTPUT_OPTION)\n+cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) diagnostic.h gt-cp-parser.h output.h\n #\f\n # These exist for maintenance purposes.\n \n # Update the tags table.\n cp/TAGS: force\n \tcd $(srcdir)/cp ;\t\t\t\\\n-\tetags --no-globals -l c `echo *.c | sed 's/parse.c//'` \\\n-\t  parse.y *.h ../*.c ../*.h;\n+\tetags --no-globals -l c *.c *.h ../*.c ../*.h;\n \n .PHONY: cp/TAGS"}, {"sha": "a94852cfac7367c2e48ad4e518560866d3ac7558", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -1,3 +1,75 @@\n+*** Changes in GCC 3.4:\n+\n+* The C++ parser in G++ has been rewritten from scratch.  As a result, G++ \n+  is considerably more compliant to the C++ standard.  As a result, it \n+  accepts more valid programs, and rejects more invalid programs.  \n+\n+  Many of the changes below are a consequence of the new parser.\n+\n+* Friend declarations that refer to template specializations are rejected\n+  if the template has not already been declared.\n+\n+  For example:\n+\n+    template <typename T>\n+    class C {\n+      friend void f<>(C&);\n+    };\n+\n+  is rejected; you must first declare `f' as a template:\n+\n+    template <typename T>\n+    void f(T);\n+\n+* You must use \"template <>\" to introduce template specializations, as \n+  required by the standard.  For example:\n+\n+    template <typename T>\n+    struct S;\n+    \n+    struct S<int> { };\n+\n+  is rejected; you must write:\n+\n+    template <> struct S<int> {};\n+\n+* You must now use the `typename' and `template' keywords to disambiguate\n+  dependent names, as required by the C++ standard.\n+\n+* The \"named return value\" extension has been removed.\n+\n+* The \"implicit typename\" extension has been removed.\n+\n+* G++ used to accept code like this:\n+\n+    struct S {\n+      int h();\n+      void f(int i = g());\n+      int g(int i = h());\n+    };\n+\n+  This behavior is not mandated by the standard. \n+\n+  Now G++ issues an error about this code.  To avoid the error, you must\n+  move the declaration of `g' before the declaration of `f'.  The \n+  default arguments for `g' must be visible at the point where it is\n+  called.\n+\n+* When -pedantic is used, G++ now issues errors about spurious semicolons;\n+  for example:\n+\n+    namespace N {}; // Invalid semicolon.\n+    void f() {}; // Invalid semicolon.\n+  \n+* G++ no longer accepts attributes for a declarator after the\n+  initializer associated with that declarator.  For example:\n+\n+    X x(1) __attribute__((...));\n+\n+  is no longer accepted.  Instead, use:\n+\n+    X x __attribute__((...)) (1);\n+\n *** Changes in GCC 3.3:\n \n * The \"new X = 3\" extension has been removed; you must now use \"new X(3)\"."}, {"sha": "805e5b27e3decc83544055b441ee92b4100d93e2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 123, "deletions": 104, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -102,6 +102,7 @@ static tree convert_class_to_reference (tree, tree, tree);\n static tree direct_reference_binding (tree, tree);\n static bool promoted_arithmetic_type_p (tree);\n static tree conditional_conversion (tree, tree);\n+static char *name_as_c_string (tree, tree, bool *);\n static tree call_builtin_trap (void);\n \n tree\n@@ -221,13 +222,6 @@ build_scoped_method_call (tree exp, tree basetype, tree name, tree parms)\n \n   if (processing_template_decl)\n     {\n-      if (TREE_CODE (name) == BIT_NOT_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (name, 0)) == IDENTIFIER_NODE)\n-\t{\n-\t  tree type = get_aggr_from_typedef (TREE_OPERAND (name, 0), 0);\n-\t  if (type)\n-\t    name = build_min_nt (BIT_NOT_EXPR, type);\n-\t}\n       name = build_min_nt (SCOPE_REF, basetype, name);\n       return build_min_nt (METHOD_CALL_EXPR, name, exp, parms, NULL_TREE);\n     }\n@@ -477,24 +471,7 @@ build_method_call (tree instance, tree name, tree parms,\n     return error_mark_node;\n \n   if (processing_template_decl)\n-    {\n-      /* We need to process template parm names here so that tsubst catches\n-\t them properly.  Other type names can wait.  */\n-      if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\t{\n-\t  tree type = NULL_TREE;\n-\n-\t  if (TREE_CODE (TREE_OPERAND (name, 0)) == IDENTIFIER_NODE)\n-\t    type = get_aggr_from_typedef (TREE_OPERAND (name, 0), 0);\n-\t  else if (TREE_CODE (TREE_OPERAND (name, 0)) == TYPE_DECL)\n-\t    type = TREE_TYPE (TREE_OPERAND (name, 0));\n-\n-\t  if (type && TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n-\t    name = build_min_nt (BIT_NOT_EXPR, type);\n-\t}\n-\n-      return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, NULL_TREE);\n-    }\n+    return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, NULL_TREE);\n \n   if (TREE_CODE (instance) == OFFSET_REF)\n     instance = resolve_offset_ref (instance);\n@@ -2685,8 +2662,8 @@ resolve_args (tree args)\n   return args;\n }\n \n-/* Return an expression for a call to FN (a namespace-scope function)\n-   with the ARGS.  */\n+/* Return an expression for a call to FN (a namespace-scope function,\n+   or a static member function) with the ARGS.  */\n       \n tree\n build_new_function_call (tree fn, tree args)\n@@ -2726,18 +2703,21 @@ build_new_function_call (tree fn, tree args)\n \t{\n \t  tree t = OVL_CURRENT (t1);\n \n+\t  my_friendly_assert (!DECL_FUNCTION_MEMBER_P (t), 20020913);\n+\n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n \t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n \t\t(candidates, t, NULL_TREE, explicit_targs, args, \n-\t\t NULL_TREE,\n-\t\t /*access_path=*/NULL_TREE, /*conversion_path=*/NULL_TREE,\n+\t\t NULL_TREE, /*access_path=*/NULL_TREE, \n+\t\t /*conversion_path=*/NULL_TREE,\n \t\t LOOKUP_NORMAL, DEDUCE_CALL);  \n \t    }\n \t  else if (! template_only)\n \t    candidates = add_function_candidate\n-\t      (candidates, t, NULL_TREE, args, /*access_path=*/NULL_TREE, \n+\t      (candidates, t, NULL_TREE, args, \n+\t       /*access_path=*/NULL_TREE,\n \t       /*conversion_path=*/NULL_TREE, LOOKUP_NORMAL);\n \t}\n \n@@ -3318,9 +3298,9 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n   tree conv;\n   bool viable_candidates;\n \n-  if (arg1 == error_mark_node\n-      || arg2 == error_mark_node\n-      || arg3 == error_mark_node)\n+  if (error_operand_p (arg1) \n+      || error_operand_p (arg2) \n+      || error_operand_p (arg3))\n     return error_mark_node;\n \n   /* This can happen if a template takes all non-type parameters, e.g.\n@@ -4186,24 +4166,14 @@ cxx_type_promotes_to (tree type)\n tree\n convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n {\n+  /* If the ARG is an unparsed default argument expression, the\n+     conversion cannot be performed.  */\n   if (TREE_CODE (arg) == DEFAULT_ARG)\n     {\n-      /* When processing the default args for a class, we can find that\n-         there is an ordering constraint, and we call a function who's\n-         default args have not yet been converted. For instance,\n-          class A {\n-              A (int = 0);\n-              void Foo (A const & = A ());\n-          };\n-         We must process A::A before A::Foo's default arg can be converted.\n-         Remember the dependent function, so do_pending_defargs can retry,\n-         and check loops.  */\n-      unprocessed_defarg_fn (fn);\n-      \n-      /* Don't return error_mark node, as we won't be able to distinguish\n-         genuine errors from this case, and that would lead to repeated\n-         diagnostics.  Just make something of the right type.  */\n-      return build1 (NOP_EXPR, type, integer_zero_node);\n+      error (\"the default argument for parameter %d of `%D' has \"\n+\t     \"not yet been parsed\",\n+\t     parmnum, fn);\n+      return error_mark_node;\n     }\n \n   if (fn && DECL_TEMPLATE_INFO (fn))\n@@ -4685,6 +4655,42 @@ build_special_member_call (tree instance, tree name, tree args,\n   return build_new_method_call (instance, fns, args, binfo, flags);\n }\n \n+/* Return the NAME, as a C string.  The NAME indicates a function that\n+   is a member of TYPE.  *FREE_P is set to true if the caller must\n+   free the memory returned.  \n+\n+   Rather than go through all of this, we should simply set the names\n+   of constructors and destructors appropriately, and dispense with\n+   ctor_identifier, dtor_identifier, etc.  */\n+\n+static char *\n+name_as_c_string (tree name, tree type, bool *free_p)\n+{\n+  char *pretty_name;\n+\n+  /* Assume that we will not allocate memory.  */\n+  *free_p = false;\n+  /* Constructors and destructors are special.  */\n+  if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n+    {\n+      pretty_name \n+\t= (char *) IDENTIFIER_POINTER (constructor_name (type));\n+      /* For a destructor, add the '~'.  */\n+      if (name == complete_dtor_identifier\n+\t  || name == base_dtor_identifier\n+\t  || name == deleting_dtor_identifier)\n+\t{\n+\t  pretty_name = concat (\"~\", pretty_name, NULL);\n+\t  /* Remember that we need to free the memory allocated.  */\n+\t  *free_p = true;\n+\t}\n+    }\n+  else\n+    pretty_name = (char *) IDENTIFIER_POINTER (name);\n+\n+  return pretty_name;\n+}\n+\n /* Build a call to \"INSTANCE.FN (ARGS)\".  */\n \n tree\n@@ -4697,15 +4703,18 @@ build_new_method_call (tree instance, tree fns, tree args,\n   tree access_binfo;\n   tree optype;\n   tree mem_args = NULL_TREE, instance_ptr;\n-  tree name, pretty_name;\n+  tree name;\n   tree user_args;\n   tree templates = NULL_TREE;\n   tree call;\n+  tree fn;\n+  tree class_type;\n   int template_only = 0;\n \n   my_friendly_assert (instance != NULL_TREE, 20020729);\n \n-  if (instance == error_mark_node || fns == error_mark_node \n+  if (error_operand_p (instance) \n+      || error_operand_p (fns)\n       || args == error_mark_node)\n     return error_mark_node;\n \n@@ -4759,7 +4768,8 @@ build_new_method_call (tree instance, tree fns, tree args,\n       return error_mark_node;\n     }\n \n-  name = DECL_NAME (get_first_fn (fns));\n+  fn = get_first_fn (fns);\n+  name = DECL_NAME (fn);\n \n   if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     {\n@@ -4768,61 +4778,56 @@ build_new_method_call (tree instance, tree fns, tree args,\n       my_friendly_assert (name != ctor_identifier, 20000408);\n       /* Similarly for destructors.  */\n       my_friendly_assert (name != dtor_identifier, 20000408);\n-      \n-      if (name == complete_ctor_identifier\n-\t  || name == base_ctor_identifier)\n-\tpretty_name = constructor_name (basetype);\n-      else\n-\tpretty_name = dtor_identifier;\n     }\n-  else\n-    pretty_name = name;\n \n-  if (fns)\n+  /* It's OK to call destructors on cv-qualified objects.  Therefore,\n+     convert the INSTANCE_PTR to the unqualified type, if necessary.  */\n+  if (DECL_DESTRUCTOR_P (fn))\n     {\n-      tree fn;\n-      tree class_type = (conversion_path \n-\t\t\t ? BINFO_TYPE (conversion_path)\n-\t\t\t : NULL_TREE);\n+      tree type = build_pointer_type (basetype);\n+      if (!same_type_p (type, TREE_TYPE (instance_ptr)))\n+\tinstance_ptr = build1 (NOP_EXPR, type, instance_ptr);\n+    }\n \n-      mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n-      for (fn = fns; fn; fn = OVL_NEXT (fn))\n-\t{\n-\t  tree t = OVL_CURRENT (fn);\n-\t  tree this_arglist;\n+  class_type = (conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE);\n+  mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n \n-\t  /* We can end up here for copy-init of same or base class.  */\n-\t  if ((flags & LOOKUP_ONLYCONVERTING)\n-\t      && DECL_NONCONVERTING_P (t))\n-\t    continue;\n+  for (fn = fns; fn; fn = OVL_NEXT (fn))\n+    {\n+      tree t = OVL_CURRENT (fn);\n+      tree this_arglist;\n \n-\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n-\t    this_arglist = mem_args;\n-\t  else\n-\t    this_arglist = args;\n+      /* We can end up here for copy-init of same or base class.  */\n+      if ((flags & LOOKUP_ONLYCONVERTING)\n+\t  && DECL_NONCONVERTING_P (t))\n+\tcontinue;\n \n-\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    {\n-\t      /* A member template.  */\n-\t      templates = tree_cons (NULL_TREE, t, templates);\n-\t      candidates = \n-\t\tadd_template_candidate (candidates, t, \n-\t\t\t\t\tclass_type,\n-\t\t\t\t\texplicit_targs,\n-\t\t\t\t\tthis_arglist, optype,\n-\t\t\t\t\taccess_binfo, \n-\t\t\t\t\tconversion_path,\n-\t\t\t\t\tflags,\n-\t\t\t\t\tDEDUCE_CALL);\n-\t    }\n-\t  else if (! template_only)\n-\t    candidates = add_function_candidate (candidates, t, \n-\t\t\t\t\t\t class_type,\n-\t\t\t\t\t\t this_arglist,\n-\t\t\t\t\t\t access_binfo,\n-\t\t\t\t\t\t conversion_path,\n-\t\t\t\t\t\t flags);\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n+\tthis_arglist = mem_args;\n+      else\n+\tthis_arglist = args;\n+\n+      if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t{\n+\t  /* A member template.  */\n+\t  templates = tree_cons (NULL_TREE, t, templates);\n+\t  candidates = \n+\t    add_template_candidate (candidates, t, \n+\t\t\t\t    class_type,\n+\t\t\t\t    explicit_targs,\n+\t\t\t\t    this_arglist, optype,\n+\t\t\t\t    access_binfo, \n+\t\t\t\t    conversion_path,\n+\t\t\t\t    flags,\n+\t\t\t\t    DEDUCE_CALL);\n \t}\n+      else if (! template_only)\n+\tcandidates = add_function_candidate (candidates, t, \n+\t\t\t\t\t     class_type,\n+\t\t\t\t\t     this_arglist,\n+\t\t\t\t\t     access_binfo,\n+\t\t\t\t\t     conversion_path,\n+\t\t\t\t\t     flags);\n     }\n \n   if (! any_viable (candidates))\n@@ -4833,9 +4838,17 @@ build_new_method_call (tree instance, tree fns, tree args,\n       if (!COMPLETE_TYPE_P (basetype))\n \tcxx_incomplete_type_error (instance_ptr, basetype);\n       else\n-\terror (\"no matching function for call to `%T::%D(%A)%#V'\",\n-\t       basetype, pretty_name, user_args,\n-\t       TREE_TYPE (TREE_TYPE (instance_ptr)));\n+\t{\n+\t  char *pretty_name;\n+\t  bool free_p;\n+\n+\t  pretty_name = name_as_c_string (name, basetype, &free_p);\n+\t  error (\"no matching function for call to `%T::%s(%A)%#V'\",\n+\t\t basetype, pretty_name, user_args,\n+\t\t TREE_TYPE (TREE_TYPE (instance_ptr)));\n+\t  if (free_p)\n+\t    free (pretty_name);\n+\t}\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -4844,9 +4857,15 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n   if (cand == 0)\n     {\n+      char *pretty_name;\n+      bool free_p;\n+\n+      pretty_name = name_as_c_string (name, basetype, &free_p);\n       error (\"call of overloaded `%D(%A)' is ambiguous\", pretty_name,\n-\t\tuser_args);\n+\t     user_args);\n       print_z_candidates (candidates);\n+      if (free_p)\n+\tfree (pretty_name);\n       return error_mark_node;\n     }\n \n@@ -5745,7 +5764,7 @@ perform_implicit_conversion (tree type, tree expr)\n {\n   tree conv;\n   \n-  if (expr == error_mark_node)\n+  if (error_operand_p (expr))\n     return error_mark_node;\n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      LOOKUP_NORMAL);"}, {"sha": "32f49a7bb116cb43baf506c67e2c9180613c5bde", "filename": "gcc/cp/class.c", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -2739,7 +2739,7 @@ finish_struct_anon (t)\n \t\t      || TYPE_ANONYMOUS_P (TREE_TYPE (elt))))\n \t\tcontinue;\n \n-\t      if (DECL_NAME (elt) == constructor_name (t))\n+\t      if (constructor_name_p (DECL_NAME (elt), t))\n \t\tcp_pedwarn_at (\"ISO C++ forbids member `%D' with same name as enclosing class\",\n \t\t\t       elt);\n \n@@ -3341,8 +3341,7 @@ check_field_decls (tree t, tree *access_decls,\n       /* Core issue 80: A nonstatic data member is required to have a\n \t different name from the class iff the class has a\n \t user-defined constructor.  */\n-      if (DECL_NAME (x) == constructor_name (t)\n-\t  && TYPE_HAS_CONSTRUCTOR (t))\n+      if (constructor_name_p (x, t) && TYPE_HAS_CONSTRUCTOR (t))\n \tcp_pedwarn_at (\"field `%#D' with same name as class\", x);\n \n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n@@ -5642,15 +5641,8 @@ init_class_processing ()\n   ridpointers[(int) RID_PROTECTED] = access_protected_node;\n }\n \n-/* Set current scope to NAME. CODE tells us if this is a\n-   STRUCT, UNION, or ENUM environment.\n-\n-   NAME may end up being NULL_TREE if this is an anonymous or\n-   late-bound struct (as in \"struct { ... } foo;\")  */\n-\n-/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE to\n-   appropriate values, found by looking up the type definition of\n-   NAME (as a CODE).\n+/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE as\n+   appropriate for TYPE.\n \n    If MODIFY is 1, we set IDENTIFIER_CLASS_VALUE's of names\n    which can be seen locally to the class.  They are shadowed by\n@@ -5860,7 +5852,7 @@ push_nested_class (type, modify)\n   pushclass (type, modify);\n }\n \n-/* Undoes a push_nested_class call.  MODIFY is passed on to popclass.  */\n+/* Undoes a push_nested_class call.  */\n \n void\n pop_nested_class ()\n@@ -6024,9 +6016,9 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n     {\n       tree fns;\n \n-      for (fns = overload; fns; fns = OVL_CHAIN (fns))\n+      for (fns = overload; fns; fns = OVL_NEXT (fns))\n \t{\n-\t  tree fn = OVL_FUNCTION (fns);\n+\t  tree fn = OVL_CURRENT (fns);\n \t  tree fntype;\n \n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n@@ -6073,9 +6065,9 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n       if (TREE_CODE (target_fn_type) == METHOD_TYPE)\n \ttarget_arg_types = TREE_CHAIN (target_arg_types);\n \t  \n-      for (fns = overload; fns; fns = OVL_CHAIN (fns))\n+      for (fns = overload; fns; fns = OVL_NEXT (fns))\n \t{\n-\t  tree fn = OVL_FUNCTION (fns);\n+\t  tree fn = OVL_CURRENT (fns);\n \t  tree instantiation;\n \t  tree instantiation_type;\n \t  tree targs;\n@@ -6235,10 +6227,19 @@ instantiate_type (lhstype, rhs, flags)\n     {\n       if (comptypes (lhstype, TREE_TYPE (rhs), strict))\n \treturn rhs;\n-      if (complain)\n-\terror (\"argument of type `%T' does not match `%T'\",\n-\t\t  TREE_TYPE (rhs), lhstype);\n-      return error_mark_node;\n+      if (flag_ms_extensions \n+\t  && TYPE_PTRMEMFUNC_P (lhstype)\n+\t  && !TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n+\t/* Microsoft allows `A::f' to be resolved to a\n+\t   pointer-to-member.  */\n+\t;\n+      else\n+\t{\n+\t  if (complain)\n+\t    error (\"argument of type `%T' does not match `%T'\",\n+\t\t   TREE_TYPE (rhs), lhstype);\n+\t  return error_mark_node;\n+\t}\n     }\n \n   if (TREE_CODE (rhs) == BASELINK)\n@@ -6314,6 +6315,7 @@ instantiate_type (lhstype, rhs, flags)\n       }\n \n     case OVERLOAD:\n+    case FUNCTION_DECL:\n       return \n \tresolve_address_of_overloaded_function (lhstype, \n \t\t\t\t\t\trhs,\n@@ -6771,10 +6773,8 @@ get_primary_binfo (binfo)\n \n   if (TREE_CHAIN (virtuals))\n     {\n-      /* We found more than one instance of the base. We must make\n-         sure that, if one is the canonical one, it is the first one\n-         we found. As the chain is in reverse dfs order, that means\n-         the last on the list.  */\n+      /* We found more than one instance of the base.  If one is the\n+\t canonical one, choose that one.  */\n       tree complete_binfo;\n       tree canonical;\n       \n@@ -6790,12 +6790,7 @@ get_primary_binfo (binfo)\n \t  result = TREE_VALUE (virtuals);\n \n \t  if (canonical == result)\n-\t    {\n-\t      /* This is the unshared instance. Make sure it was the\n-\t\t first one found.  */\n-\t      my_friendly_assert (!TREE_CHAIN (virtuals), 20010612);\n-\t      break;\n-\t    }\n+\t    break;\n \t}\n     }\n   else"}, {"sha": "73617f576edff550595e00c413d3f2473f4f0afb", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"${libstdcxx_version} target-gperf\"\n \n-gtfiles=\"\\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/lex.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/parse.y \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/spew.c \\$(srcdir)/cp/tree.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/lex.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-pragma.c\""}, {"sha": "5ffc6176b74fd916fc43b364cef9d9e4236250b4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -501,6 +501,17 @@ struct tree_srcloc GTY(())\n #define C_SET_EXP_ORIGINAL_CODE(EXP, CODE) \\\n   (TREE_COMPLEXITY (EXP) = (int)(CODE))\n \n+/* The tokens stored in the default argument.  */\n+\n+#define DEFARG_TOKENS(NODE) \\\n+  (((struct tree_default_arg *)DEFAULT_ARG_CHECK (NODE))->tokens)\n+\n+struct tree_default_arg GTY (())\n+{\n+  struct tree_common common;\n+  struct cp_token_cache *tokens;\n+};\n+\n enum cp_tree_node_structure_enum {\n   TS_CP_COMMON,\n   TS_CP_GENERIC,\n@@ -511,6 +522,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_OVERLOAD,\n   TS_CP_WRAPPER,\n   TS_CP_SRCLOC,\n+  TS_CP_DEFAULT_ARG,\n   LAST_TS_CP_ENUM\n };\n \n@@ -527,6 +539,7 @@ union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n   struct tree_overload GTY ((tag (\"TS_CP_OVERLOAD\"))) overload;\n   struct tree_wrapper GTY ((tag (\"TS_CP_WRAPPER\"))) wrapper;\n   struct tree_srcloc GTY ((tag (\"TS_CP_SRCLOC\"))) srcloc;\n+  struct tree_default_arg GTY ((tag (\"TS_CP_DEFAULT_ARG\"))) default_arg;\n   struct lang_identifier GTY ((tag (\"TS_CP_IDENTIFIER\"))) identifier;\n };\n \n@@ -572,6 +585,7 @@ enum cp_tree_index\n     CPTI_ABI,\n     CPTI_TYPE_INFO_TYPE,\n     CPTI_TYPE_INFO_PTR_TYPE,\n+    CPTI_TYPE_INFO_REF_TYPE,\n     CPTI_ABORT_FNDECL,\n     CPTI_GLOBAL_DELETE_FNDECL,\n     CPTI_AGGR_TAG,\n@@ -661,6 +675,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define abi_node                        cp_global_trees[CPTI_ABI]\n #define type_info_type_node\t\tcp_global_trees[CPTI_TYPE_INFO_TYPE]\n #define type_info_ptr_type\t\tcp_global_trees[CPTI_TYPE_INFO_PTR_TYPE]\n+#define type_info_ref_type              cp_global_trees[CPTI_TYPE_INFO_REF_TYPE]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n@@ -772,8 +787,9 @@ struct saved_scope GTY(())\n \n   HOST_WIDE_INT x_processing_template_decl;\n   int x_processing_specialization;\n-  int x_processing_explicit_instantiation;\n+  bool x_processing_explicit_instantiation;\n   int need_pop_function_context;\n+  int check_access;\n \n   struct stmt_tree_s x_stmt_tree;\n \n@@ -837,8 +853,6 @@ struct saved_scope GTY(())\n \n extern GTY(()) struct saved_scope *scope_chain;\n \n-struct unparsed_text;\n-\n /* Global state pertinent to the current function.  */\n \n struct language_function GTY(())\n@@ -865,7 +879,6 @@ struct language_function GTY(())\n   varray_type x_local_names;\n \n   const char *cannot_inline;\n-  struct unparsed_text *unparsed_inlines;\n };\n \n /* The current C++-specific per-function global variables.  */\n@@ -943,6 +956,12 @@ extern GTY(()) tree global_namespace;\n #define ansi_assopname(CODE) \\\n   (assignment_operator_name_info[(int) (CODE)].identifier)\n \n+/* True if NODE is an erroneous expression.  */\n+\n+#define error_operand_p(NODE)\t\t\t\t\t\\\n+  ((NODE) == error_mark_node \t\t\t\t\t\\\n+   || ((NODE) && TREE_TYPE ((NODE)) == error_mark_node))\n+\n /* INTERFACE_ONLY nonzero means that we are in an \"interface\"\n    section of the compiler.  INTERFACE_UNKNOWN nonzero means\n    we cannot trust the value of INTERFACE_ONLY.  If INTERFACE_UNKNOWN\n@@ -1799,7 +1818,7 @@ struct lang_decl GTY(())\n \tunion lang_decl_u3\n \t{\n \t  tree GTY ((tag (\"0\"))) sorted_fields;\n-\t  struct unparsed_text * GTY ((tag (\"2\"))) pending_inline_info;\n+ \t  struct cp_token_cache * GTY ((tag (\"2\"))) pending_inline_info;\n \t  struct language_function * GTY ((tag (\"1\"))) \n \t       saved_language_function;\n \t} GTY ((desc (\"%1.u3sel + %1.pending_inline_p\"))) u;\n@@ -1822,8 +1841,6 @@ struct lang_decl GTY(())\n \n #endif /* ENABLE_TREE_CHECKING */\n \n-#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK (NODE)->identifier.id.str)\n-\n /* DECL_NEEDED_P holds of a declaration when we need to emit its\n    definition.  This is true when the back-end tells us that\n    the symbol has been referenced in the generated code.  If, however,\n@@ -2998,7 +3015,14 @@ struct lang_decl GTY(())\n   (TREE_TYPE (NODE))\n \n /* An enumeration of the kind of tags that C++ accepts.  */\n-enum tag_types { record_type, class_type, union_type, enum_type };\n+enum tag_types { \n+  none_type = 0, /* Not a tag type.  */\n+  record_type,   /* \"struct\" types.  */\n+  class_type,    /* \"class\" types.  */\n+  union_type,    /* \"union\" types.  */\n+  enum_type,     /* \"enum\" types.  */\n+  typename_type  /* \"typename\" types.  */\n+};\n \n /* The various kinds of lvalues we distinguish.  */\n typedef enum cp_lvalue_kind {\n@@ -3703,10 +3727,12 @@ extern tree make_typename_type\t\t\tPARAMS ((tree, tree, tsubst_flags_t));\n extern tree make_unbound_class_template\t\tPARAMS ((tree, tree, tsubst_flags_t));\n extern tree lookup_name_nonclass\t\tPARAMS ((tree));\n extern tree lookup_function_nonclass            PARAMS ((tree, tree));\n+extern tree lookup_qualified_name               (tree, tree, bool, int);\n extern tree lookup_name\t\t\t\tPARAMS ((tree, int));\n extern tree lookup_name_current_level\t\tPARAMS ((tree));\n extern tree lookup_type_current_level\t\tPARAMS ((tree));\n extern tree lookup_name_namespace_only          PARAMS ((tree));\n+extern tree lookup_name_real                    (tree, int, int, int, int);\n extern void begin_only_namespace_names          PARAMS ((void));\n extern void end_only_namespace_names            PARAMS ((void));\n extern tree namespace_ancestor\t\t\tPARAMS ((tree, tree));\n@@ -3722,7 +3748,7 @@ extern tree push_void_library_fn\t\tPARAMS ((tree, tree));\n extern tree push_throw_library_fn\t\tPARAMS ((tree, tree));\n extern int init_type_desc\t\t\tPARAMS ((void));\n extern tree check_tag_decl\t\t\tPARAMS ((tree));\n-extern void shadow_tag\t\t\t\tPARAMS ((tree));\n+extern tree shadow_tag\t\t\t\tPARAMS ((tree));\n extern tree groktypename\t\t\tPARAMS ((tree));\n extern tree start_decl\t\t\t\tPARAMS ((tree, tree, int, tree, tree));\n extern void start_decl_1\t\t\tPARAMS ((tree));\n@@ -3736,6 +3762,7 @@ extern tree build_ptrmem_type                   (tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n extern int parmlist_is_exprlist\t\t\tPARAMS ((tree));\n extern int copy_fn_p\t\t\t\tPARAMS ((tree));\n+extern tree get_scope_of_declarator             PARAMS ((tree));\n extern void grok_special_member_properties\tPARAMS ((tree));\n extern int grok_ctor_properties\t\t\tPARAMS ((tree, tree));\n extern void grok_op_properties\t\t\tPARAMS ((tree, int));\n@@ -3937,12 +3964,9 @@ extern tree make_call_declarator\t\tPARAMS ((tree, tree, tree, tree));\n extern void set_quals_and_spec\t\t\tPARAMS ((tree, tree, tree));\n extern void print_parse_statistics\t\tPARAMS ((void));\n extern void do_pending_inlines\t\t\tPARAMS ((void));\n-extern void process_next_inline\t\t\tPARAMS ((struct unparsed_text *));\n-\n extern void yyungetc\t\t\t\tPARAMS ((int, int));\n extern void snarf_method\t\t\tPARAMS ((tree));\n \n-extern void check_for_missing_semicolon\t\tPARAMS ((tree));\n extern void note_got_semicolon\t\t\tPARAMS ((tree));\n extern void note_list_got_semicolon\t\tPARAMS ((tree));\n extern void do_pending_lang_change\t\tPARAMS ((void));\n@@ -4037,6 +4061,7 @@ extern tree get_mostly_instantiated_function_type PARAMS ((tree));\n extern int problematic_instantiation_changed    PARAMS ((void));\n extern void record_last_problematic_instantiation PARAMS ((void));\n extern tree current_instantiation               PARAMS ((void));\n+extern tree maybe_get_template_decl_from_type_decl (tree);\n extern int processing_template_parmlist;\n \n /* in repo.c */\n@@ -4154,20 +4179,22 @@ extern void finish_cleanup                      PARAMS ((tree, tree));\n extern tree begin_compound_stmt                 PARAMS ((int));\n extern tree finish_compound_stmt                PARAMS ((int, tree));\n extern tree finish_asm_stmt                     PARAMS ((tree, tree, tree, tree, tree));\n-extern void finish_label_stmt                   PARAMS ((tree));\n+extern tree finish_label_stmt                   PARAMS ((tree));\n extern void finish_label_decl                   PARAMS ((tree));\n extern void finish_subobject                    PARAMS ((tree));\n extern tree finish_parenthesized_expr           PARAMS ((tree));\n+extern tree finish_non_static_data_member       PARAMS ((tree, tree));\n extern tree begin_stmt_expr                     PARAMS ((void));\n extern tree finish_stmt_expr                    PARAMS ((tree));\n extern tree finish_call_expr                    (tree, tree, bool);\n extern tree finish_increment_expr               PARAMS ((tree, enum tree_code));\n extern tree finish_this_expr                    PARAMS ((void));\n extern tree finish_object_call_expr             PARAMS ((tree, tree, tree));\n extern tree finish_qualified_object_call_expr   PARAMS ((tree, tree, tree));\n-extern tree finish_pseudo_destructor_call_expr  PARAMS ((tree, tree, tree));\n+extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n extern tree finish_unary_op_expr                PARAMS ((enum tree_code, tree));\n extern tree finish_id_expr                      PARAMS ((tree));\n+extern tree finish_compound_literal             (tree, tree);\n extern tree finish_fname                        (tree);\n extern void save_type_access_control\t\tPARAMS ((tree));\n extern void reset_type_access_control           PARAMS ((void));\n@@ -4182,7 +4209,6 @@ extern tree finish_parmlist                     PARAMS ((tree, int));\n extern tree begin_class_definition              PARAMS ((tree));\n extern tree finish_class_definition             PARAMS ((tree, tree, int, int));\n extern void finish_default_args                 PARAMS ((void));\n-extern void begin_inline_definitions            PARAMS ((void));\n extern tree finish_member_class_template        PARAMS ((tree));\n extern void finish_template_decl                PARAMS ((tree));\n extern tree finish_template_type                PARAMS ((tree, tree, int));\n@@ -4208,19 +4234,6 @@ extern tree begin_global_stmt_expr              PARAMS ((void));\n extern tree finish_global_stmt_expr             PARAMS ((tree));\n extern tree check_template_template_default_arg (tree);\n \n-/* in spew.c */\n-extern void init_spew\t\t\t\tPARAMS ((void));\n-extern int peekyylex\t\t\t\tPARAMS ((void));\n-extern tree arbitrate_lookup\t\t\tPARAMS ((tree, tree, tree));\n-extern tree frob_opname                         PARAMS ((tree));\n-extern void maybe_snarf_defarg\t\t\tPARAMS ((void));\n-extern void add_defarg_fn\t\t\tPARAMS ((tree));\n-extern void do_pending_defargs\t\t\tPARAMS ((void));\n-extern void done_pending_defargs\t\tPARAMS ((void));\n-extern void unprocessed_defarg_fn               PARAMS ((tree));\n-extern void replace_defarg\t\t\tPARAMS ((tree, tree));\n-extern void end_input\t\t\t\tPARAMS ((void));\n-\n /* in tree.c */\n extern void lang_check_failed\t\t\tPARAMS ((const char *, int,\n \t\t\t\t\t\t\t const char *));\n@@ -4252,7 +4265,6 @@ extern tree make_binfo\t\t\t\tPARAMS ((tree, tree, tree, tree));\n extern tree reverse_path\t\t\tPARAMS ((tree));\n extern int count_functions\t\t\tPARAMS ((tree));\n extern int is_overloaded_fn\t\t\tPARAMS ((tree));\n-extern tree get_overloaded_fn                   PARAMS ((tree));\n extern tree get_first_fn\t\t\tPARAMS ((tree));\n extern int bound_pmf_p\t\t\t\tPARAMS ((tree));\n extern tree ovl_cons                            PARAMS ((tree, tree));"}, {"sha": "50d4a2ae953cb972fe95f34bbb0f34863dbdf6ec", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -484,20 +484,16 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \n   if (TREE_CODE (type) == FUNCTION_TYPE \n       && TREE_TYPE (expr) == unknown_type_node)\n-    {\n-      expr = instantiate_type (type, expr, \n-\t\t\t       (flags & LOOKUP_COMPLAIN)\n-\t                       ? tf_error | tf_warning : tf_none);\n-      if (expr == error_mark_node)\n-\treturn error_mark_node;\n-\n-      intype = TREE_TYPE (expr);\n-    }\n+    expr = instantiate_type (type, expr, \n+\t\t\t     (flags & LOOKUP_COMPLAIN)\n+\t\t\t     ? tf_error | tf_warning : tf_none);\n   else\n-    {\n-      expr = convert_from_reference (expr);\n-      intype = TREE_TYPE (expr);\n-    }\n+    expr = convert_from_reference (expr);\n+\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  intype = TREE_TYPE (expr);\n \n   my_friendly_assert (TREE_CODE (intype) != REFERENCE_TYPE, 364);\n "}, {"sha": "fd3fc00a8ce8dbe2e35c491fdffe0d5f2f5d0cfc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 227, "deletions": 261, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -69,7 +69,6 @@ static int ambi_op_p PARAMS ((enum tree_code));\n static int unary_op_p PARAMS ((enum tree_code));\n static tree store_bindings PARAMS ((tree, tree));\n static tree lookup_tag_reverse PARAMS ((tree, tree));\n-static tree lookup_name_real PARAMS ((tree, int, int, int));\n static void push_local_name PARAMS ((tree));\n static void warn_extern_redeclared_static PARAMS ((tree, tree));\n static tree grok_reference_init PARAMS ((tree, tree, tree));\n@@ -2428,6 +2427,7 @@ maybe_push_to_top_level (pseudo)\n   s->need_pop_function_context = need_pop;\n   s->function_decl = current_function_decl;\n   s->last_parms = last_function_parms;\n+  s->check_access = flag_access_control;\n \n   scope_chain = s;\n   current_function_decl = NULL_TREE;\n@@ -2532,8 +2532,8 @@ identifier_type_value (id)\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n     return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n-     Ask lookup_name not to return non-types.  */\n-  id = lookup_name_real (id, 2, 1, 0);\n+     Ask lookup_name not to return non-types. */\n+  id = lookup_name_real (id, 2, 1, 0, LOOKUP_COMPLAIN);\n   if (id)\n     return TREE_TYPE (id);\n   return NULL_TREE;\n@@ -5980,6 +5980,32 @@ warn_about_implicit_typename_lookup (typename, binding)\n     }\n }\n \n+/* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n+   or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type\n+   bindings.  \n+\n+   Returns a DECL (or OVERLOAD, or BASELINK) representing the\n+   declaration found.  */\n+\n+tree\n+lookup_qualified_name (tree scope, tree name, bool is_type_p, int flags)\n+{\n+  if (TREE_CODE (scope) == NAMESPACE_DECL)\n+    {\n+      tree val;\n+\n+      val = make_node (CPLUS_BINDING);\n+      flags |= LOOKUP_COMPLAIN;\n+      if (is_type_p)\n+\tflags |= LOOKUP_PREFER_TYPES;\n+      if (!qualified_lookup_using_namespace (name, scope, val, flags))\n+\treturn NULL_TREE;\n+      return select_decl (val, flags);\n+    }\n+  else\n+    return lookup_member (scope, name, 0, is_type_p);\n+}\n+\n /* Check to see whether or not DECL is a variable that would have been\n    in scope under the ARM, but is not in scope under the ANSI/ISO\n    standard.  If so, issue an error message.  If name lookup would\n@@ -6047,112 +6073,58 @@ check_for_out_of_scope_variable (tree decl)\n \n    If PREFER_TYPE is > 0, we prefer TYPE_DECLs or namespaces.\n    If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n-   If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)\n    Otherwise we prefer non-TYPE_DECLs.\n \n    If NONCLASS is nonzero, we don't look for the NAME in class scope,\n    using IDENTIFIER_CLASS_VALUE.  */\n \n-static tree\n-lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n-     tree name;\n-     int prefer_type, nonclass, namespaces_only;\n+tree\n+lookup_name_real (tree name, \n+\t\t  int prefer_type, \n+\t\t  int nonclass, \n+\t\t  int namespaces_only,\n+\t\t  int flags)\n {\n   tree t;\n   tree val = NULL_TREE;\n   int yylex = 0;\n-  tree from_obj = NULL_TREE;\n-  int flags;\n   int val_is_implicit_typename = 0;\n \n-  /* Hack: copy flag set by parser, if set.  */\n-  if (only_namespace_names)\n-    namespaces_only = 1;\n-\n-  if (prefer_type == -2)\n+  /* Conversion operators are handled specially because ordinary\n+     unqualified name lookup will not find template conversion\n+     operators.  */\n+  if (IDENTIFIER_TYPENAME_P (name)) \n     {\n-      extern int looking_for_typename;\n-      tree type = NULL_TREE;\n-\n-      yylex = 1;\n-      prefer_type = looking_for_typename;\n-\n-      flags = lookup_flags (prefer_type, namespaces_only);\n-      /* If the next thing is '<', class templates are types.  */\n-      if (looking_for_template)\n-        flags |= LOOKUP_TEMPLATES_EXPECTED;\n-\n-      if (got_scope)\n-\ttype = got_scope;\n-      else if (got_object != error_mark_node)\n-\ttype = got_object;\n+      struct cp_binding_level *level;\n \n-      if (type)\n+      for (level = current_binding_level; \n+\t   level && !level->namespace_p; \n+\t   level = level->level_chain)\n \t{\n-\t  if (type == error_mark_node)\n-\t    return error_mark_node;\n-\t  if (TREE_CODE (type) == TYPENAME_TYPE && TREE_TYPE (type))\n-\t    type = TREE_TYPE (type);\n-\n-\t  if (TYPE_P (type))\n-\t    type = complete_type (type);\n-\n-\t  if (TREE_CODE (type) == VOID_TYPE)\n-\t    type = global_namespace;\n-\t  if (TREE_CODE (type) == NAMESPACE_DECL)\n-\t    {\n-\t      val = make_node (CPLUS_BINDING);\n-\t      flags |= LOOKUP_COMPLAIN;\n-\t      if (!qualified_lookup_using_namespace (name, type, val, flags))\n-\t\treturn NULL_TREE;\n-\t      val = select_decl (val, flags);\n-\t    }\n-\t  else if (! IS_AGGR_TYPE (type)\n-\t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-\t\t   || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM\n-\t\t   || TREE_CODE (type) == TYPENAME_TYPE)\n-\t    /* Someone else will give an error about this if needed.  */\n-\t    val = NULL_TREE;\n-\t  else if (type == current_class_type)\n-\t    val = IDENTIFIER_CLASS_VALUE (name);\n-\t  else\n-\t    {\n-\t      val = lookup_member (type, name, 0, prefer_type);\n-\t      if (!uses_template_parms (type))\n-\t\ttype_access_control (type, val);\n-\n-\t      /* Restore the containing TYPENAME_TYPE if we looked\n-\t\t through it before.  */\n-\t      if (got_scope && got_scope != type\n-\t\t  && val && TREE_CODE (val) == TYPE_DECL\n-\t\t  && TREE_CODE (TREE_TYPE (val)) == TYPENAME_TYPE)\n-\t\t{\n-\t\t  val = TREE_TYPE (val);\n-\t\t  val = build_typename_type (got_scope, name,\n-\t\t\t\t\t     TYPENAME_TYPE_FULLNAME (val),\n-\t\t\t\t\t     TREE_TYPE (val));\n-\t\t  val = TYPE_STUB_DECL (val);\n-\t\t}\n-\t    }\n+\t  tree class_type;\n+\t  tree operators;\n+\t  \n+\t  /* A conversion operator can only be declared in a class \n+\t     scope.  */\n+\t  if (level->parm_flag != 2)\n+\t    continue;\n+\t  \n+\t  /* Lookup the conversion operator in the class.  */\n+\t  class_type = level->this_class;\n+\t  operators = lookup_fnfields (class_type, name, /*protect=*/0);\n+\t  if (operators)\n+\t    return operators;\n \t}\n-      else\n-\tval = NULL_TREE;\n \n-      if (got_scope)\n-\tgoto done;\n-      else if (got_object && val)\n-\t{\n-\t  from_obj = val;\n-\t  val = NULL_TREE;\n-\t}\n-    }\n-  else\n-    {\n-      flags = lookup_flags (prefer_type, namespaces_only);\n-      /* If we're not parsing, we need to complain.  */\n-      flags |= LOOKUP_COMPLAIN;\n+      return NULL_TREE;\n     }\n \n+  /* Hack: copy flag set by parser, if set. */\n+  if (only_namespace_names)\n+    namespaces_only = 1;\n+\n+  flags |= lookup_flags (prefer_type, namespaces_only);\n+\n   /* First, look in non-namespace scopes.  */\n \n   if (current_class_type == NULL_TREE)\n@@ -6175,11 +6147,6 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       else\n \tbinding = NULL_TREE;\n \n-      /* Handle access control on types from enclosing or base classes.  */\n-      if (binding && ! yylex\n-\t  && BINDING_LEVEL (t) && BINDING_LEVEL (t)->parm_flag == 2)\n-\ttype_access_control (BINDING_LEVEL (t)->this_class, binding);\n-\n       if (binding\n \t  && (!val || !IMPLICIT_TYPENAME_TYPE_DECL_P (binding)))\n \t{\n@@ -6205,36 +6172,12 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t}\n     }\n \n- done:\n   if (val)\n     {\n-      /* This should only warn about types used in qualified-ids.  */\n-      if (from_obj && from_obj != val)\n-\t{\n-\t  if (looking_for_typename && TREE_CODE (from_obj) == TYPE_DECL\n-\t      && TREE_CODE (val) == TYPE_DECL\n-\t      && ! same_type_p (TREE_TYPE (from_obj), TREE_TYPE (val)))\n-\t    pedwarn (\"\\\n-lookup of `%D' in the scope of `%#T' (`%#D') \\\n-does not match lookup in the current scope (`%#D')\",\n-\t\t\tname, got_object, from_obj, val);\n-\n-\t  /* We don't change val to from_obj if got_object depends on\n-\t     template parms because that breaks implicit typename for\n-\t     destructor calls.  */\n-\t  if (! uses_template_parms (got_object))\n-\t    val = from_obj;\n-\t}\n-\n       /* If we have a single function from a using decl, pull it out.  */\n       if (TREE_CODE (val) == OVERLOAD && ! really_overloaded_fn (val))\n \tval = OVL_FUNCTION (val);\n     }\n-  else if (from_obj)\n-    val = from_obj;\n-\n-  if (val && TREE_CODE (val) == ALIAS_DECL)\n-    val = DECL_INITIAL (val);\n \n   return val;\n }\n@@ -6243,7 +6186,7 @@ tree\n lookup_name_nonclass (name)\n      tree name;\n {\n-  return lookup_name_real (name, 0, 1, 0);\n+  return lookup_name_real (name, 0, 1, 0, LOOKUP_COMPLAIN);\n }\n \n tree\n@@ -6259,15 +6202,15 @@ lookup_name_namespace_only (name)\n      tree name;\n {\n   /* type-or-namespace, nonclass, namespace_only */\n-  return lookup_name_real (name, 1, 1, 1);\n+  return lookup_name_real (name, 1, 1, 1, LOOKUP_COMPLAIN);\n }\n \n tree\n lookup_name (name, prefer_type)\n      tree name;\n      int prefer_type;\n {\n-  return lookup_name_real (name, prefer_type, 0, 0);\n+  return lookup_name_real (name, prefer_type, 0, 0, LOOKUP_COMPLAIN);\n }\n \n /* Similar to `lookup_name' but look only in the innermost non-class\n@@ -7062,9 +7005,9 @@ fixup_anonymous_aggr (t)\n }\n \n /* Make sure that a declaration with no declarator is well-formed, i.e.\n-   just defines a tagged type or anonymous union.\n+   just declares a tagged type or anonymous union.\n \n-   Returns the type defined, if any.  */\n+   Returns the type declared; or NULL_TREE if none.  */\n \n tree\n check_tag_decl (declspecs)\n@@ -7075,11 +7018,16 @@ check_tag_decl (declspecs)\n   int saw_typedef = 0;\n   tree ob_modifier = NULL_TREE;\n   register tree link;\n-  register tree t = NULL_TREE;\n+  /* If a class, struct, or enum type is declared by the DECLSPECS\n+     (i.e, if a class-specifier, enum-specifier, or non-typename\n+     elaborated-type-specifier appears in the DECLSPECS),\n+     DECLARED_TYPE is set to the corresponding type.  */\n+  tree declared_type = NULL_TREE;\n+  bool error_p = false;\n \n   for (link = declspecs; link; link = TREE_CHAIN (link))\n     {\n-      register tree value = TREE_VALUE (link);\n+      tree value = TREE_VALUE (link);\n \n       if (TYPE_P (value)\n \t  || TREE_CODE (value) == TYPE_DECL\n@@ -7101,7 +7049,7 @@ check_tag_decl (declspecs)\n \t\t  || TREE_CODE (value) == ENUMERAL_TYPE))\n \t    {\n \t      my_friendly_assert (TYPE_MAIN_DECL (value) != NULL_TREE, 261);\n-\t      t = value;\n+\t      declared_type = value;\n \t    }\n \t}\n       else if (value == ridpointers[(int) RID_TYPEDEF])\n@@ -7125,17 +7073,18 @@ check_tag_decl (declspecs)\n \t       || value == ridpointers[(int) RID_EXPLICIT]\n \t       || value == ridpointers[(int) RID_THREAD])\n \tob_modifier = value;\n+      else if (value == error_mark_node)\n+\terror_p = true;\n     }\n \n   if (found_type > 1)\n     error (\"multiple types in one declaration\");\n \n-  if (t == NULL_TREE && ! saw_friend)\n+  if (declared_type == NULL_TREE && ! saw_friend && !error_p)\n     pedwarn (\"declaration does not declare anything\");\n-\n   /* Check for an anonymous union.  */\n-  else if (t && IS_AGGR_TYPE_CODE (TREE_CODE (t))\n-\t   && TYPE_ANONYMOUS_P (t))\n+  else if (declared_type && IS_AGGR_TYPE_CODE (TREE_CODE (declared_type))\n+\t   && TYPE_ANONYMOUS_P (declared_type))\n     {\n       /* 7/3 In a simple-declaration, the optional init-declarator-list\n          can be omitted only when declaring a class (clause 9) or\n@@ -7159,9 +7108,10 @@ check_tag_decl (declspecs)\n           return NULL_TREE;\n         }\n       /* Anonymous unions are objects, so they can have specifiers.  */;\n-      SET_ANON_AGGR_TYPE_P (t);\n+      SET_ANON_AGGR_TYPE_P (declared_type);\n \n-      if (TREE_CODE (t) != UNION_TYPE && pedantic && ! in_system_header)\n+      if (TREE_CODE (declared_type) != UNION_TYPE && pedantic \n+\t  && !in_system_header)\n \tpedwarn (\"ISO C++ prohibits anonymous structs\");\n     }\n \n@@ -7180,7 +7130,7 @@ check_tag_decl (declspecs)\n \t\t  ob_modifier);\n     }\n \n-  return t;\n+  return declared_type;\n }\n \n /* Called when a declaration is seen that contains no names to declare.\n@@ -7192,23 +7142,27 @@ check_tag_decl (declspecs)\n    Otherwise, it is an error.\n \n    C++: may have to grok the declspecs to learn about static,\n-   complain for anonymous unions.  */\n+   complain for anonymous unions.  \n \n-void\n+   Returns the TYPE declared -- or NULL_TREE if none.  */\n+\n+tree\n shadow_tag (declspecs)\n      tree declspecs;\n {\n   tree t = check_tag_decl (declspecs);\n \n-  if (t)\n-    maybe_process_partial_specialization (t);\n+  if (!t)\n+    return NULL_TREE;\n+\n+  maybe_process_partial_specialization (t);\n \n   /* This is where the variables in an anonymous union are\n      declared.  An anonymous union declaration looks like:\n      union { ... } ;\n      because there is no declarator after the union, the parser\n      sends that declaration here.  */\n-  if (t && ANON_AGGR_TYPE_P (t))\n+  if (ANON_AGGR_TYPE_P (t))\n     {\n       fixup_anonymous_aggr (t);\n \n@@ -7219,6 +7173,8 @@ shadow_tag (declspecs)\n \t  finish_anon_union (decl);\n \t}\n     }\n+\n+  return t;\n }\n \f\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n@@ -7374,9 +7330,10 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t    {\n \t      if (DECL_CONTEXT (field) != context)\n \t\t{\n-\t\t  pedwarn (\"ISO C++ does not permit `%T::%D' to be defined as `%T::%D'\",\n-\t\t\t      DECL_CONTEXT (field), DECL_NAME (decl),\n-\t\t\t      context, DECL_NAME (decl));\n+\t\t  if (!same_type_p (DECL_CONTEXT (field), context))\n+\t\t    pedwarn (\"ISO C++ does not permit `%T::%D' to be defined as `%T::%D'\",\n+\t\t\t     DECL_CONTEXT (field), DECL_NAME (decl),\n+\t\t\t     context, DECL_NAME (decl));\n \t\t  DECL_CONTEXT (decl) = DECL_CONTEXT (field);\n \t\t}\n \t      /* Static data member are tricky; an in-class initialization\n@@ -7529,9 +7486,6 @@ grok_reference_init (decl, type, init)\n       return NULL_TREE;\n     }\n \n-  if (init == error_mark_node)\n-    return NULL_TREE;\n-\n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n       error (\"ISO C++ forbids use of initializer list to initialize reference `%D'\", decl);\n@@ -8800,7 +8754,6 @@ register_dtor_fn (decl)\n   tree compound_stmt;\n   tree args;\n   tree fcall;\n-\n   int saved_flag_access_control;\n \n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n@@ -8819,9 +8772,9 @@ register_dtor_fn (decl)\n      will make the back-end think that nested functions are in use,\n      which causes confusion.  */\n   saved_flag_access_control = flag_access_control;\n-  flag_access_control = 0;\n+  scope_chain->check_access = flag_access_control = 0;\n   fcall = build_cleanup (decl);\n-  flag_access_control = saved_flag_access_control;\n+  scope_chain->check_access = flag_access_control = saved_flag_access_control;\n \n   /* Create the body of the anonymous function.  */\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n@@ -9333,9 +9286,6 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t}\n     }\n \n-  if (has_default_arg)\n-    add_defarg_fn (decl);\n-\n   if (funcdef_flag)\n     /* Make the init_value nonzero so pushdecl knows this is not\n        tentative.  error_mark_node is replaced later with the BLOCK.  */\n@@ -9348,7 +9298,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   if (check < 0)\n     return decl;\n \n-  if (flags == NO_SPECIAL && ctype && constructor_name (ctype) == declarator)\n+  if (flags == NO_SPECIAL && ctype && constructor_name_p (declarator, ctype))\n     DECL_CONSTRUCTOR_P (decl) = 1;\n \n   /* Function gets the ugly name, field gets the nice one.  This call\n@@ -9782,6 +9732,48 @@ compute_array_index_type (name, size)\n   return build_index_type (itype);\n }\n \n+/* Returns the scope (if any) in which the entity declared by\n+   DECLARATOR will be located.  If the entity was declared with an\n+   unqualified name, NULL_TREE is returned.  */\n+\n+tree\n+get_scope_of_declarator (declarator)\n+     tree declarator;\n+{\n+  if (!declarator)\n+    return NULL_TREE;\n+  \n+  switch (TREE_CODE (declarator))\n+    {\n+    case CALL_EXPR:\n+    case ARRAY_REF:\n+    case INDIRECT_REF:\n+    case ADDR_EXPR:\n+      /* For any of these, the main declarator is the first operand.  */\n+      return get_scope_of_declarator (TREE_OPERAND\n+\t\t\t\t      (declarator, 0));\n+\n+    case SCOPE_REF:\n+      /* For a pointer-to-member, continue descending.  */\n+      if (TREE_CODE (TREE_OPERAND (declarator, 1))\n+\t  == INDIRECT_REF)\n+\treturn get_scope_of_declarator (TREE_OPERAND\n+\t\t\t\t\t(declarator, 1));\n+      /* Otherwise, if the declarator-id is a SCOPE_REF, the scope in\n+\t which the declaration occurs is the first operand.  */\n+      return TREE_OPERAND (declarator, 0);\n+\n+    case TREE_LIST:\n+      /* Attributes to be applied. The declarator is TREE_VALUE.  */\n+      return get_scope_of_declarator (TREE_VALUE (declarator));\n+      \n+    default:\n+      /* Otherwise, we have a declarator-id which is not a qualified\n+\t name; the entity will be declared in the current scope.  */\n+      return NULL_TREE;\n+    }\n+}\n+\n /* Returns an ARRAY_TYPE for an array with SIZE elements of the\n    indicated TYPE.  If non-NULL, NAME is the NAME of the declaration\n    with this type.  */\n@@ -9906,11 +9898,9 @@ check_special_function_return_type (sfk, type, optype)\n   return type;\n }\n \n-/* Given declspecs and a declarator,\n-   determine the name and type of the object declared\n-   and construct a ..._DECL node for it.\n-   (In one case we can return a ..._TYPE node instead.\n-    For invalid input we sometimes return 0.)\n+/* Given declspecs and a declarator (abstract or otherwise), determine\n+   the name and type of the object declared and construct a DECL node\n+   for it.\n \n    DECLSPECS is a chain of tree_list nodes whose value fields\n     are the storage classes and type specifiers.\n@@ -9937,35 +9927,15 @@ check_special_function_return_type (sfk, type, optype)\n    if there are none; *ATTRLIST may be modified if attributes from inside\n    the declarator should be applied to the declaration.\n \n-   In the TYPENAME case, DECLARATOR is really an abstract declarator.\n-   It may also be so in the PARM case, for a prototype where the\n-   argument type is specified but not the name.\n+   When this function is called, scoping variables (such as\n+   CURRENT_CLASS_TYPE) should reflect the scope in which the\n+   declaration occurs, not the scope in which the new declaration will\n+   be placed.  For example, on:\n \n-   This function is where the complicated C meanings of `static'\n-   and `extern' are interpreted.\n+     void S::f() { ... }\n \n-   For C++, if there is any monkey business to do, the function which\n-   calls this one must do it, i.e., prepending instance variables,\n-   renaming overloaded function names, etc.\n-\n-   Note that for this C++, it is an error to define a method within a class\n-   which does not belong to that class.\n-\n-   Except in the case where SCOPE_REFs are implicitly known (such as\n-   methods within a class being redundantly qualified),\n-   declarations which involve SCOPE_REFs are returned as SCOPE_REFs\n-   (class_name::decl_name).  The caller must also deal with this.\n-\n-   If a constructor or destructor is seen, and the context is FIELD,\n-   then the type gains the attribute TREE_HAS_x.  If such a declaration\n-   is erroneous, NULL_TREE is returned.\n-\n-   QUALS is used only for FUNCDEF and MEMFUNCDEF cases.  For a member\n-   function, these are the qualifiers to give to the `this' pointer. We\n-   apply TYPE_QUAL_RESTRICT to the this ptr, not the object.\n-\n-   May return void_type_node if the declarator turned out to be a friend.\n-   See grokfield for details.  */\n+   when grokdeclarator is called for `S::f', the CURRENT_CLASS_TYPE\n+   should not be `S'.  */\n \n tree\n grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n@@ -10016,6 +9986,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   int template_count = 0;\n   tree in_namespace = NULL_TREE;\n   tree returned_attrs = NULL_TREE;\n+  tree scope = NULL_TREE;\n \n   RIDBIT_RESET_ALL (specbits);\n   if (decl_context == FUNCDEF)\n@@ -10055,7 +10026,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      my_friendly_assert (flags == NO_SPECIAL, 152);\n \t      flags = DTOR_FLAG;\n \t      sfk = sfk_destructor;\n-\t      if (TREE_CODE (name) == TYPE_DECL)\n+\t      if (TYPE_P (name))\n \t\tTREE_OPERAND (decl, 0) = name = constructor_name (name);\n \t      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 153);\n \t      if (ctype == NULL_TREE)\n@@ -10067,7 +10038,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      tree t = constructor_name (current_class_name);\n+\t\t      tree t = constructor_name (current_class_type);\n \t\t      if (t != name)\n \t\t\trename = t;\n \t\t    }\n@@ -10153,7 +10124,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    decl = *next;\n \t    if (ctype != NULL_TREE\n \t\t&& decl != NULL_TREE && flags != DTOR_FLAG\n-\t\t&& decl == constructor_name (ctype))\n+\t\t&& constructor_name_p (decl, ctype))\n \t      {\n \t\tsfk = sfk_constructor;\n \t\tctor_return_type = ctype;\n@@ -10220,10 +10191,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t{\n \t\t  ctype = NULL_TREE;\n \t\t  in_namespace = TREE_OPERAND (decl, 0);\n-\t\t  TREE_OPERAND (decl, 0) = NULL_TREE;\n \t\t}\n \t      else if (! is_aggr_type (cname, 1))\n-\t\tTREE_OPERAND (decl, 0) = NULL_TREE;\n+\t\tctype = NULL_TREE;\n \t      /* Must test TREE_OPERAND (decl, 1), in case user gives\n \t\t us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */\n \t      else if (TREE_OPERAND (decl, 1)\n@@ -10240,19 +10210,35 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      else if (ctype == NULL_TREE)\n \t\tctype = cname;\n \t      else if (TREE_COMPLEXITY (decl) == current_class_depth)\n-\t\tTREE_OPERAND (decl, 0) = ctype;\n+\t\t;\n \t      else\n \t\t{\n \t\t  if (! UNIQUELY_DERIVED_FROM_P (cname, ctype))\n \t\t    {\n \t\t      error (\"type `%T' is not derived from type `%T'\",\n \t\t\t\tcname, ctype);\n-\t\t      TREE_OPERAND (decl, 0) = NULL_TREE;\n+\t\t      ctype = NULL_TREE;\n \t\t    }\n \t\t  else\n \t\t    ctype = cname;\n \t\t}\n \n+\t      /* It is valid to write:\n+\n+\t\t   class C { void f(); };\n+\t\t   typedef C D;\n+\t\t   void D::f();\n+\n+\t\t The standard is not clear about whether `typedef const C D' is\n+\t\t legal; as of 2002-09-15 the committee is considering\n+\t\t that question.  EDG 3.0 allows that syntax.\n+\t\t Therefore, we do as well.  */\n+\t      if (ctype)\n+\t\tctype = TYPE_MAIN_VARIANT (ctype);\n+\t      /* Update the declarator so that when we process it\n+\t\t again the correct type is present.  */\n+\t      TREE_OPERAND (decl, 0) = ctype;\n+\n \t      if (ctype && TREE_CODE (TREE_OPERAND (decl, 1)) == TYPE_DECL\n \t\t  && constructor_name_p (DECL_NAME (TREE_OPERAND (decl, 1)),\n \t\t\t\t\t ctype))\n@@ -10262,7 +10248,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      if (ctype)\n \t\t{\n \t\t  if (TREE_CODE (decl) == IDENTIFIER_NODE\n-\t\t      && constructor_name (ctype) == decl)\n+\t\t      && constructor_name_p (decl, ctype))\n \t\t    {\n \t\t      sfk = sfk_constructor;\n \t\t      ctor_return_type = ctype;\n@@ -10890,6 +10876,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   if (nclasses > 0 && friendp)\n     error (\"storage class specifiers invalid in friend function declarations\");\n \n+  scope = get_scope_of_declarator (declarator);\n+\n   /* Now figure out the structure of the declarator proper.\n      Descend through it, creating more complex types, until we reach\n      the declared identifier (or NULL_TREE, in an abstract declarator).  */\n@@ -10937,7 +10925,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      tree dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n \t      grok_method_quals (ctype, dummy, quals);\n \t      type = TREE_TYPE (dummy);\n-\t      ctype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (type)));\n \t      quals = NULL_TREE;\n \t    }\n \t}\n@@ -11045,7 +11032,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    if (ctype && sfk == sfk_conversion)\n \t      TYPE_HAS_CONVERSION (ctype) = 1;\n-\t    if (ctype && constructor_name (ctype) == dname)\n+\t    if (ctype && constructor_name_p (dname, ctype))\n \t      {\n \t\t/* We are within a class's scope. If our declarator name\n \t\t   is the same as the class name, and we are defining\n@@ -11163,17 +11150,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    /* ANSI says that `const int foo ();'\n \t       does not make the function foo const.  */\n \t    type = build_function_type (type, arg_types);\n-\n-\t    {\n-\t      tree t;\n-\t      for (t = arg_types; t; t = TREE_CHAIN (t))\n-\t\tif (TREE_PURPOSE (t)\n-\t\t    && TREE_CODE (TREE_PURPOSE (t)) == DEFAULT_ARG)\n-\t\t  {\n-\t\t    add_defarg_fn (type);\n-\t\t    break;\n-\t\t  }\n-\t    }\n \t  }\n \t  break;\n \n@@ -11278,44 +11254,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    if (TREE_CODE (sname) == BIT_NOT_EXPR)\n \t      sname = TREE_OPERAND (sname, 0);\n \n-\t    if (TREE_COMPLEXITY (declarator) == 0)\n-\t      /* This needs to be here, in case we are called\n-\t\t multiple times.  */ ;\n-\t    else if (TREE_COMPLEXITY (declarator) == -1)\n-\t      /* Namespace member.  */\n-\t      pop_decl_namespace ();\n-\t    else if (friendp && (TREE_COMPLEXITY (declarator) < 2))\n-\t      /* Don't fall out into global scope. Hides real bug? --eichin */ ;\n-\t    else if (!TREE_OPERAND (declarator, 0)\n-\t\t     || !IS_AGGR_TYPE_CODE\n-\t\t          (TREE_CODE (TREE_OPERAND (declarator, 0))))\n-\t      ;\n-\t    else if (TREE_COMPLEXITY (declarator) == current_class_depth)\n-\t      {\n-\t\t/* Resolve any TYPENAME_TYPEs from the decl-specifier-seq\n-\t\t   that refer to ctype.  They couldn't be resolved earlier\n-\t\t   because we hadn't pushed into the class yet.\n-\t\t   Example: resolve 'B<T>::type' in\n-\t\t   'B<typename B<T>::type> B<T>::f () { }'.  */\n-\t\tif (current_template_parms\n-\t\t    && uses_template_parms (type)\n-\t\t    && uses_template_parms (current_class_type))\n-\t\t  {\n-\t\t    tree args = current_template_args ();\n-\t\t    type = tsubst (type, args, tf_error | tf_warning,\n-\t\t\t\t   NULL_TREE);\n-\t\t  }\n-\n-\t\t/* This pop_nested_class corresponds to the\n-                   push_nested_class used to push into class scope for\n-                   parsing the argument list of a function decl, in\n-                   qualified_id.  */\n-\t\tpop_nested_class ();\n-\t\tTREE_COMPLEXITY (declarator) = current_class_depth;\n-\t      }\n-\t    else\n-\t      abort ();\n-\n \t    if (TREE_OPERAND (declarator, 0) == NULL_TREE)\n \t      {\n \t\t/* We had a reference to a global decl, or\n@@ -11379,7 +11317,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t      {\n \t\t\terror (\"cannot declare member function `%T::%s' within `%T'\",\n \t\t\t\t  ctype, name, current_class_type);\n-\t\t\treturn void_type_node;\n+\t\t\treturn error_mark_node;\n \t\t      }\n \t\t  }\n \t\telse if (RIDBIT_SETP (RID_TYPEDEF, specbits)\n@@ -11452,6 +11390,35 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \tattrlist = &returned_attrs;\n     }\n \n+  /* Resolve any TYPENAME_TYPEs from the decl-specifier-seq that refer\n+     to ctype.  They couldn't be resolved earlier because we hadn't\n+     pushed into the class yet.  \n+\n+     For example, consider:\n+\n+       template <typename T>\n+       struct S {\n+         typedef T X;\n+         X f();\n+       };\n+\n+       template <typename T>\n+       typename S<T>::X f() {}\n+\n+       When parsing the decl-specifier-seq for the definition of `f',\n+       we construct a TYPENAME_TYPE for `S<T>::X'.  By substituting\n+       here, we resolve it to the correct type.  */\n+  if (scope && CLASS_TYPE_P (scope)\n+      && current_template_parms\n+      && uses_template_parms (scope))\n+    {\n+      tree args = current_template_args ();\n+      push_scope (scope);\n+      type = tsubst (type, args, tf_error | tf_warning,\n+\t\t     NULL_TREE);\n+      pop_scope (scope);\n+    }\n+\n   /* Now TYPE has the actual type.  */\n \n   /* Did array size calculations overflow?  */\n@@ -11540,14 +11507,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n       if (decl_context == FIELD)\n \t{\n-\t  if (declarator == constructor_name (current_class_type))\n+\t  if (constructor_name_p (declarator, current_class_type))\n \t    pedwarn (\"ISO C++ forbids nested type `%D' with same name as enclosing class\",\n \t\t\tdeclarator);\n \t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n \t}\n       else\n \t{\n \t  decl = build_decl (TYPE_DECL, declarator, type);\n+\t  if (in_namespace || ctype)\n+\t    cp_error_at (\"typedef name may not be a nested-name-specifier\",\n+\t\t\t decl);\n \t  if (!current_function_decl)\n \t    DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \t}\n@@ -11588,12 +11558,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t     type with external linkage have external linkage.  */\n \t}\n \n-      if (TREE_CODE (type) == OFFSET_TYPE || TREE_CODE (type) == METHOD_TYPE)\n-\t{\n-\t  cp_error_at (\"typedef name may not be class-qualified\", decl);\n-\t  return NULL_TREE;\n-\t}\n-      else if (quals)\n+      if (quals)\n \t{\n \t  if (ctype == NULL_TREE)\n \t    {\n@@ -12011,7 +11976,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \n \t    /* 9.2p13 [class.mem] */\n-\t    if (declarator == constructor_name (current_class_type)\n+\t    if (constructor_name_p (declarator, current_class_type)\n \t\t/* The standard does not allow non-static data members\n \t\t   here either, but we agreed at the 10/99 meeting\n \t\t   to change that in TC 1 so that they are allowed in\n@@ -14616,9 +14581,14 @@ start_method (declspecs, declarator, attrlist)\n   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n \t\t\t\t&attrlist);\n \n-  /* Something too ugly to handle.  */\n-  if (fndecl == NULL_TREE)\n-    return NULL_TREE;\n+  if (fndecl == error_mark_node)\n+    return error_mark_node;\n+\n+  if (fndecl == NULL || TREE_CODE (fndecl) != FUNCTION_DECL)\n+    {\n+      error (\"invalid member function declaration\");\n+      return error_mark_node;\n+    }\n \n   if (attrlist)\n     cplus_decl_attributes (&fndecl, attrlist, 0);\n@@ -14627,10 +14597,6 @@ start_method (declspecs, declarator, attrlist)\n   if (fndecl == void_type_node)\n     return fndecl;\n \n-  if (TREE_CODE (fndecl) != FUNCTION_DECL)\n-    /* Not a function, tell parser to report parse error.  */\n-    return NULL_TREE;\n-\n   if (DECL_IN_AGGR_P (fndecl))\n     {\n       if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (fndecl)) != current_class_type)\n@@ -14908,7 +14874,7 @@ cp_tree_node_structure (t)\n {\n   switch (TREE_CODE (&t->generic))\n     {\n-    case DEFAULT_ARG:\t\treturn TS_CP_IDENTIFIER;\n+    case DEFAULT_ARG:\t\treturn TS_CP_DEFAULT_ARG;\n     case IDENTIFIER_NODE:\treturn TS_CP_IDENTIFIER;\n     case CPLUS_BINDING:\t\treturn TS_CP_BINDING;\n     case OVERLOAD:\t\treturn TS_CP_OVERLOAD;"}, {"sha": "be91e713f3bb10bbe3e37d23b6b43e7a79fcb84f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 141, "deletions": 97, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -1220,51 +1220,34 @@ cplus_decl_attributes (decl, attributes, flags)\n     SET_IDENTIFIER_TYPE_VALUE (DECL_NAME (*decl), TREE_TYPE (*decl));\n }\n \f\n-/* CONSTRUCTOR_NAME:\n-   Return the name for the constructor (or destructor) for the\n-   specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or\n-   IDENTIFIER_NODE.  When given a template, this routine doesn't\n+/* Return the name for the constructor (or destructor) for the\n+   specified class TYPE.  When given a template, this routine doesn't\n    lose the specialization.  */\n \n tree\n-constructor_name_full (thing)\n-     tree thing;\n+constructor_name_full (tree type)\n {\n-  if (TREE_CODE (thing) == TEMPLATE_TYPE_PARM\n-      || TREE_CODE (thing) == BOUND_TEMPLATE_TEMPLATE_PARM\n-      || TREE_CODE (thing) == TYPENAME_TYPE)\n-    thing = TYPE_NAME (thing);\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n-    {\n-      if (TYPE_WAS_ANONYMOUS (thing) && TYPE_HAS_CONSTRUCTOR (thing))\n-\tthing = DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (thing), 0)));\n-      else\n-\tthing = TYPE_NAME (thing);\n-    }\n-  if (TREE_CODE (thing) == TYPE_DECL\n-      || (TREE_CODE (thing) == TEMPLATE_DECL\n-\t  && TREE_CODE (DECL_TEMPLATE_RESULT (thing)) == TYPE_DECL))\n-    thing = DECL_NAME (thing);\n-  my_friendly_assert (TREE_CODE (thing) == IDENTIFIER_NODE, 197);\n-  return thing;\n+  type = TYPE_MAIN_VARIANT (type);\n+  if (CLASS_TYPE_P (type) && TYPE_WAS_ANONYMOUS (type) \n+      && TYPE_HAS_CONSTRUCTOR (type))\n+    return DECL_NAME (OVL_CURRENT (CLASSTYPE_CONSTRUCTORS (type)));\n+  else\n+    return TYPE_IDENTIFIER (type);\n }\n \n-/* CONSTRUCTOR_NAME:\n-   Return the name for the constructor (or destructor) for the\n-   specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or\n-   IDENTIFIER_NODE.  When given a template, return the plain\n+/* Return the name for the constructor (or destructor) for the\n+   specified class.  When given a template, return the plain\n    unspecialized name.  */\n \n tree\n-constructor_name (thing)\n-     tree thing;\n+constructor_name (type)\n+     tree type;\n {\n-  tree t;\n-  thing = constructor_name_full (thing);\n-  t = IDENTIFIER_TEMPLATE (thing);\n-  if (!t)\n-    return thing;\n-  return t;\n+  tree name;\n+  name = constructor_name_full (type);\n+  if (IDENTIFIER_TEMPLATE (name))\n+    name = IDENTIFIER_TEMPLATE (name);\n+  return name;\n }\n \n /* Returns TRUE if NAME is the name for the constructor for TYPE.  */\n@@ -3036,7 +3019,12 @@ build_expr_from_tree (t)\n \t  return do_scoped_id (token, IDENTIFIER_GLOBAL_VALUE (token));\n \t}\n       else\n-\treturn do_identifier (TREE_OPERAND (t, 0), 0, NULL_TREE);\n+\t{\n+\t  t = do_identifier (TREE_OPERAND (t, 0), 0, NULL_TREE);\n+\t  if (TREE_CODE (t) == ALIAS_DECL)\n+\t    t = DECL_INITIAL (t);\n+\t  return t;\n+\t}\n \n     case TEMPLATE_ID_EXPR:\n       {\n@@ -3292,7 +3280,7 @@ build_expr_from_tree (t)\n \t build_expr_from_tree (TREE_OPERAND (t, 2)));\n \n     case PSEUDO_DTOR_EXPR:\n-      return (finish_pseudo_destructor_call_expr \n+      return (finish_pseudo_destructor_expr \n \t      (build_expr_from_tree (TREE_OPERAND (t, 0)),\n \t       build_expr_from_tree (TREE_OPERAND (t, 1)),\n \t       build_expr_from_tree (TREE_OPERAND (t, 2))));\n@@ -3319,8 +3307,48 @@ build_expr_from_tree (t)\n     case COMPONENT_REF:\n       {\n \ttree object = build_expr_from_tree (TREE_OPERAND (t, 0));\n-\treturn finish_class_member_access_expr (object, \n-\t\t\t\t\t\tTREE_OPERAND (t, 1));\n+\ttree member = TREE_OPERAND (t, 1);\n+\n+\tif (!CLASS_TYPE_P (TREE_TYPE (object)))\n+\t  {\n+\t    if (TREE_CODE (member) == BIT_NOT_EXPR)\n+\t      return finish_pseudo_destructor_expr (object, \n+\t\t\t\t\t\t    NULL_TREE,\n+\t\t\t\t\t\t    TREE_TYPE (object));\n+\t    else if (TREE_CODE (member) == SCOPE_REF\n+\t\t     && (TREE_CODE (TREE_OPERAND (member, 1)) == BIT_NOT_EXPR))\n+\t      return finish_pseudo_destructor_expr (object, \n+\t\t\t\t\t\t    TREE_OPERAND (t, 0),\n+\t\t\t\t\t\t    TREE_TYPE (object));\n+\t  }\n+\telse if (TREE_CODE (member) == SCOPE_REF\n+\t\t && TREE_CODE (TREE_OPERAND (member, 1)) == TEMPLATE_ID_EXPR)\n+\t  {\n+\t    tree tmpl;\n+\t    tree args;\n+\t\n+\t    /* Lookup the template functions now that we know what the\n+\t       scope is.  */\n+\t    tmpl = TREE_OPERAND (TREE_OPERAND (member, 1), 0);\n+\t    args = TREE_OPERAND (TREE_OPERAND (member, 1), 1);\n+\t    member = lookup_qualified_name (TREE_OPERAND (member, 0),\n+\t\t\t\t\t    tmpl, \n+\t\t\t\t\t    /*is_type=*/0,\n+\t\t\t\t\t    /*flags=*/0);\n+\t    if (BASELINK_P (member))\n+\t      BASELINK_FUNCTIONS (member) \n+\t\t= build_nt (TEMPLATE_ID_EXPR, BASELINK_FUNCTIONS (member),\n+\t\t\t    args);\n+\t    else\n+\t      {\n+\t\terror (\"`%D' is not a member of `%T'\",\n+\t\t       tmpl, TREE_TYPE (object));\n+\t\treturn error_mark_node;\n+\t      }\n+\t  }\n+\n+\n+\treturn finish_class_member_access_expr (object, member);\n       }\n \n     case THROW_EXPR:\n@@ -3366,6 +3394,7 @@ build_expr_from_tree (t)\n \treturn get_typeid (TREE_OPERAND (t, 0));\n       return build_typeid (build_expr_from_tree (TREE_OPERAND (t, 0)));\n \n+    case PARM_DECL:\n     case VAR_DECL:\n       return convert_from_reference (t);\n \n@@ -3857,13 +3886,19 @@ set_decl_namespace (decl, scope, friendp)\n       if (!is_overloaded_fn (old))\n \tgoto complain;\n       if (processing_template_decl || processing_specialization)\n-\t/* We have not yet called push_template_decl to turn the\n+\t/* We have not yet called push_template_decl to turn a\n \t   FUNCTION_DECL into a TEMPLATE_DECL, so the declarations\n \t   won't match.  But, we'll check later, when we construct the\n \t   template.  */\n \treturn;\n-      for (; old; old = OVL_NEXT (old))\n-\tif (decls_match (decl, OVL_CURRENT (old)))\n+      if (is_overloaded_fn (old))\n+\t{\n+\t  for (; old; old = OVL_NEXT (old))\n+\t    if (decls_match (decl, OVL_CURRENT (old)))\n+\t      return;\n+\t}\n+      else\n+\tif (decls_match (decl, old))\n \t  return;\n     }\n   else\n@@ -3939,8 +3974,8 @@ push_scope (t)\n {\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     push_decl_namespace (t);\n-  else\n-    pushclass (t, 2);\n+  else if CLASS_TYPE_P (t)\n+    push_nested_class (t, 2);\n }\n \n /* Leave scope pushed by push_scope.  */\n@@ -3951,8 +3986,8 @@ pop_scope (t)\n {\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     pop_decl_namespace ();\n-  else\n-    popclass ();\n+  else if CLASS_TYPE_P (t)\n+    pop_nested_class ();\n }\n \n /* [basic.lookup.koenig] */\n@@ -4340,52 +4375,47 @@ validate_nonmember_using_decl (decl, scope, name)\n      tree *scope;\n      tree *name;\n {\n-  if (TREE_CODE (decl) == SCOPE_REF)\n-    {\n-      *scope = TREE_OPERAND (decl, 0);\n-      *name = TREE_OPERAND (decl, 1);\n+  *scope = global_namespace;\n+  *name = NULL_TREE;\n \n-      if (!processing_template_decl)\n-        {\n-          /* [namespace.udecl]\n-             A using-declaration for a class member shall be a\n-             member-declaration.  */\n-          if(TREE_CODE (*scope) != NAMESPACE_DECL)\n-            {\n-              if (TYPE_P (*scope))\n-                error (\"`%T' is not a namespace\", *scope);\n-              else\n-                error (\"`%D' is not a namespace\", *scope);\n-              return NULL_TREE;\n-            }\n-          \n-          /* 7.3.3/5\n-             A using-declaration shall not name a template-id.  */\n-          if (TREE_CODE (*name) == TEMPLATE_ID_EXPR)\n-            {\n-              *name = TREE_OPERAND (*name, 0);\n-              error (\"a using-declaration cannot specify a template-id.  Try `using %D'\", *name);\n-              return NULL_TREE;\n-            }\n-        }\n-    }\n-  else if (TREE_CODE (decl) == IDENTIFIER_NODE\n-           || TREE_CODE (decl) == TYPE_DECL\n-\t   || TREE_CODE (decl) == TEMPLATE_DECL)\n+  if (TREE_CODE (decl) == TEMPLATE_ID_EXPR)\n     {\n-      *scope = global_namespace;\n-      *name = decl;\n+      *name = TREE_OPERAND (decl, 0);\n+      /* 7.3.3/5\n+\t   A using-declaration shall not name a template-id.  */\n+      error (\"a using-declaration cannot specify a template-id.  Try `using %D'\", *name);\n+      return NULL_TREE;\n     }\n-  else if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\n+  if (TREE_CODE (decl) == NAMESPACE_DECL)\n     {\n       error (\"namespace `%D' not allowed in using-declaration\", decl);\n       return NULL_TREE;\n     }\n+\n+  if (is_overloaded_fn (decl))\n+    decl = get_first_fn (decl);\n+\n+  my_friendly_assert (DECL_P (decl), 20020908);\n+\n+  if (TREE_CODE (decl) == CONST_DECL)\n+    /* Enumeration constants to not have DECL_CONTEXT set.  */\n+    *scope = TYPE_CONTEXT (TREE_TYPE (decl));\n   else\n-    abort ();\n-  if (DECL_P (*name))\n-    *name = DECL_NAME (*name);\n-  /* Make a USING_DECL.  */\n+    *scope = DECL_CONTEXT (decl);\n+  if (!*scope)\n+    *scope = global_namespace;\n+\n+  /* [namespace.udecl]\n+       A using-declaration for a class member shall be a\n+       member-declaration.  */\n+  if (TYPE_P (*scope))\n+    {\n+      error (\"`%T' is not a namespace\", *scope);\n+      return NULL_TREE;\n+    }\n+  *name = DECL_NAME (decl);\n+  /* Make a USING_DECL. */\n   return push_using_decl (*scope, *name);\n }\n \n@@ -4591,14 +4621,32 @@ do_class_using_decl (decl)\n       error (\"a using-declaration cannot specify a template-id.  Try  `using %T::%D'\", TREE_OPERAND (decl, 0), name);\n       return NULL_TREE;\n     }\n-  if (TREE_CODE (name) == TYPE_DECL || TREE_CODE (name) == TEMPLATE_DECL)\n-    name = DECL_NAME (name);\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    {\n+      tree type = TREE_TYPE (name);\n+      if (CLASSTYPE_USE_TEMPLATE (TREE_TYPE (name)))\n+\t{\n+\t  name = DECL_NAME (CLASSTYPE_TI_TEMPLATE (type));\n+\t  error (\"a using-declaration cannot specify a template-id.\");\n+\t  return NULL_TREE;\n+\t}\n+      name = DECL_NAME (name);\n+    }\n+  else if (TREE_CODE (name) == TEMPLATE_DECL)\n+     name = DECL_NAME (name);\n   else if (BASELINK_P (name))\n     {\n-      name = BASELINK_FUNCTIONS (name);\n-      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\tname = TREE_OPERAND (name, 0);\n-      name = DECL_NAME (get_first_fn (name));\n+      tree fns;\n+\n+      fns = BASELINK_FUNCTIONS (name);\n+      if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n+\t{\n+\t  fns = TREE_OPERAND (fns, 0);\n+\t  error (\"a using-declaration cannot specify a template-id.  Try  `using %T::%D'\", \n+\t\t BASELINK_ACCESS_BINFO (name),\n+\t\t DECL_NAME (get_first_fn (fns)));\n+\t}\n+      name = DECL_NAME (get_first_fn (fns));\n     }\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n@@ -4785,13 +4833,9 @@ handle_class_head (tag_kind, scope, id, attributes, defn_p, new_type_p)\n       if (*new_type_p)\n \tpush_scope (context);\n \n-      if (TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE)\n-\t/* It is valid to define a class with a different class key,\n-\t   and this changes the default member access.  */\n-\tCLASSTYPE_DECLARED_CLASS (TREE_TYPE (decl))\n-\t  = (tag_kind == class_type);\n-\t\n-      if (!xrefd_p && PROCESSING_REAL_TEMPLATE_DECL_P ())\n+      if (!xrefd_p \n+\t  && PROCESSING_REAL_TEMPLATE_DECL_P ()\n+\t  && !CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n \tdecl = push_template_decl (decl);\n     }\n "}, {"sha": "d7b293f7ba4f8daf98e54781707a23302ab4d394", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -1439,6 +1439,7 @@ dump_expr (t, flags)\n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n     case OVERLOAD:\n+    case IDENTIFIER_NODE:\n       dump_decl (t, flags & ~TFF_DECL_SPECIFIERS);\n       break;\n \n@@ -1913,10 +1914,6 @@ dump_expr (t, flags)\n       dump_decl (TEMPLATE_PARM_DECL (t), flags & ~TFF_DECL_SPECIFIERS);\n       break;\n \n-    case IDENTIFIER_NODE:\n-      print_tree_identifier (scratch_buffer, t);\n-      break;\n-\n     case SCOPE_REF:\n       dump_type (TREE_OPERAND (t, 0), flags);\n       print_scope_operator (scratch_buffer);\n@@ -2031,12 +2028,10 @@ dump_expr (t, flags)\n       output_add_string (scratch_buffer, \") break; \");\n       break;\n \n-    case TREE_LIST:\n-      if (TREE_VALUE (t) && TREE_CODE (TREE_VALUE (t)) == FUNCTION_DECL)\n-\t{\n-\t  print_tree_identifier (scratch_buffer, DECL_NAME (TREE_VALUE (t)));\n-\t  break;\n-\t}\n+    case BASELINK:\n+      print_tree_identifier (scratch_buffer, DECL_NAME (get_first_fn (t)));\n+      break;\n+\n       /* else fall through */\n \n       /*  This list is incomplete, but should suffice for now."}, {"sha": "a550c675f44a89103ce5b333cc14294d2d4cb732", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -122,6 +122,10 @@ cxx_expand_expr (exp, target, tmode, modifier)\n       /* We don't need to generate any code for an empty class.  */\n       return const0_rtx;\n \n+    case BASELINK:\n+      return expand_expr (BASELINK_FUNCTIONS (exp), target, tmode,\n+\t\t\t  modifier);\n+\n     default:\n       return c_expand_expr (exp, target, tmode, modifier);\n     }"}, {"sha": "91dbf8a141ccebdc4aad4708a06cc5eb2a7e6e2f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -913,16 +913,29 @@ member_init_ok_or_else (field, type, member_name)\n {\n   if (field == error_mark_node)\n     return 0;\n-  if (field == NULL_TREE || initializing_context (field) != type)\n+  if (!field)\n     {\n       error (\"class `%T' does not have any field named `%D'\", type,\n-\t\tmember_name);\n+\t     member_name);\n       return 0;\n     }\n-  if (TREE_STATIC (field))\n+  if (TREE_CODE (field) == VAR_DECL)\n     {\n-      error (\"field `%#D' is static; the only point of initialization is its definition\",\n-\t\tfield);\n+      error (\"`%#D' is a static data member; it can only be \"\n+\t     \"initialized at its definition\",\n+\t     field);\n+      return 0;\n+    }\n+  if (TREE_CODE (field) != FIELD_DECL)\n+    {\n+      error (\"`%#D' is not a non-static data member of `%T'\",\n+\t     field, type);\n+      return 0;\n+    }\n+  if (initializing_context (field) != type)\n+    {\n+      error (\"class `%T' does not have any field named `%D'\", type,\n+\t\tmember_name);\n       return 0;\n     }\n \n@@ -1601,7 +1614,7 @@ build_offset_ref (type, name)\n \n   decl = maybe_dummy_object (type, &basebinfo);\n \n-  if (BASELINK_P (name))\n+  if (BASELINK_P (name) || DECL_P (name))\n     member = name;\n   else\n     {"}, {"sha": "92d0aa6384881d9068dbf321a3be80dc9757c974", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -32,7 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"cpplib.h\"\n #include \"lex.h\"\n-#include \"parse.h\"\n #include \"flags.h\"\n #include \"c-pragma.h\"\n #include \"toplev.h\"\n@@ -47,8 +46,6 @@ Boston, MA 02111-1307, USA.  */\n #include <locale.h>\n #endif\n \n-extern void yyprint PARAMS ((FILE *, int, YYSTYPE));\n-\n static int interface_strcmp PARAMS ((const char *));\n static int *init_cpp_parse PARAMS ((void));\n static void init_cp_pragma PARAMS ((void));\n@@ -80,8 +77,6 @@ static void copy_lang_type PARAMS ((tree));\n #include \"cpplib.h\"\n \n extern int yychar;\t\t/*  the lookahead symbol\t\t*/\n-extern YYSTYPE yylval;\t\t/*  the semantic value of the\t\t*/\n-\t\t\t\t/*  lookahead symbol\t\t\t*/\n \n /* the declaration found for the last IDENTIFIER token read in.  yylex\n    must look this up to detect typedefs, which get token type\n@@ -153,21 +148,6 @@ tree\n make_reference_declarator (cv_qualifiers, target)\n      tree cv_qualifiers, target;\n {\n-  if (target)\n-    {\n-      if (TREE_CODE (target) == ADDR_EXPR)\n-\t{\n-\t  error (\"cannot declare references to references\");\n-\t  return target;\n-\t}\n-      if (TREE_CODE (target) == INDIRECT_REF)\n-\t{\n-\t  error (\"cannot declare pointers to references\");\n-\t  return target;\n-\t}\n-      if (TREE_CODE (target) == IDENTIFIER_NODE && ANON_AGGRNAME_P (target))\n-\t  error (\"type name expected before `&'\");\n-    }\n   target = build_nt (ADDR_EXPR, target);\n   TREE_TYPE (target) = cv_qualifiers;\n   return target;\n@@ -431,134 +411,6 @@ static const struct resword reswords[] =\n \n };\n \n-/* Table mapping from RID_* constants to yacc token numbers.\n-   Unfortunately we have to have entries for all the keywords in all\n-   three languages.  */\n-const short rid_to_yy[RID_MAX] =\n-{\n-  /* RID_STATIC */\tSCSPEC,\n-  /* RID_UNSIGNED */\tTYPESPEC,\n-  /* RID_LONG */\tTYPESPEC,\n-  /* RID_CONST */\tCV_QUALIFIER,\n-  /* RID_EXTERN */\tSCSPEC,\n-  /* RID_REGISTER */\tSCSPEC,\n-  /* RID_TYPEDEF */\tSCSPEC,\n-  /* RID_SHORT */\tTYPESPEC,\n-  /* RID_INLINE */\tSCSPEC,\n-  /* RID_VOLATILE */\tCV_QUALIFIER,\n-  /* RID_SIGNED */\tTYPESPEC,\n-  /* RID_AUTO */\tSCSPEC,\n-  /* RID_RESTRICT */\tCV_QUALIFIER,\n-\n-  /* C extensions.  Bounded pointers are not yet in C++ */\n-  /* RID_BOUNDED */\t0,\n-  /* RID_UNBOUNDED */\t0,\n-  /* RID_COMPLEX */\tTYPESPEC,\n-  /* RID_THREAD */\tSCSPEC,\n-\n-  /* C++ */\n-  /* RID_FRIEND */\tSCSPEC,\n-  /* RID_VIRTUAL */\tSCSPEC,\n-  /* RID_EXPLICIT */\tSCSPEC,\n-  /* RID_EXPORT */\tEXPORT,\n-  /* RID_MUTABLE */\tSCSPEC,\n-\n-  /* ObjC */\n-  /* RID_IN */\t\t0,\n-  /* RID_OUT */\t\t0,\n-  /* RID_INOUT */\t0,\n-  /* RID_BYCOPY */\t0,\n-  /* RID_BYREF */\t0,\n-  /* RID_ONEWAY */\t0,\n-\n-  /* C */\n-  /* RID_INT */\t\tTYPESPEC,\n-  /* RID_CHAR */\tTYPESPEC,\n-  /* RID_FLOAT */\tTYPESPEC,\n-  /* RID_DOUBLE */\tTYPESPEC,\n-  /* RID_VOID */\tTYPESPEC,\n-  /* RID_ENUM */\tENUM,\n-  /* RID_STRUCT */\tAGGR,\n-  /* RID_UNION */\tAGGR,\n-  /* RID_IF */\t\tIF,\n-  /* RID_ELSE */\tELSE,\n-  /* RID_WHILE */\tWHILE,\n-  /* RID_DO */\t\tDO,\n-  /* RID_FOR */\t\tFOR,\n-  /* RID_SWITCH */\tSWITCH,\n-  /* RID_CASE */\tCASE,\n-  /* RID_DEFAULT */\tDEFAULT,\n-  /* RID_BREAK */\tBREAK,\n-  /* RID_CONTINUE */\tCONTINUE,\n-  /* RID_RETURN */\tRETURN_KEYWORD,\n-  /* RID_GOTO */\tGOTO,\n-  /* RID_SIZEOF */\tSIZEOF,\n-\n-  /* C extensions */\n-  /* RID_ASM */\t\tASM_KEYWORD,\n-  /* RID_TYPEOF */\tTYPEOF,\n-  /* RID_ALIGNOF */\tALIGNOF,\n-  /* RID_ATTRIBUTE */\tATTRIBUTE,\n-  /* RID_VA_ARG */\tVA_ARG,\n-  /* RID_EXTENSION */\tEXTENSION,\n-  /* RID_IMAGPART */\tIMAGPART,\n-  /* RID_REALPART */\tREALPART,\n-  /* RID_LABEL */\tLABEL,\n-  /* RID_PTRBASE */\t0,\n-  /* RID_PTREXTENT */\t0,\n-  /* RID_PTRVALUE */\t0,\n-  /* RID_CHOOSE_EXPR */\t0,\n-  /* RID_TYPES_COMPATIBLE_P */ 0,\n-\n-  /* RID_FUNCTION_NAME */\tVAR_FUNC_NAME,\n-  /* RID_PRETTY_FUNCTION_NAME */ VAR_FUNC_NAME,\n-  /* RID_c99_FUNCTION_NAME */\tVAR_FUNC_NAME,\n-\n-  /* C++ */\n-  /* RID_BOOL */\tTYPESPEC,\n-  /* RID_WCHAR */\tTYPESPEC,\n-  /* RID_CLASS */\tAGGR,\n-  /* RID_PUBLIC */\tVISSPEC,\n-  /* RID_PRIVATE */\tVISSPEC,\n-  /* RID_PROTECTED */\tVISSPEC,\n-  /* RID_TEMPLATE */\tTEMPLATE,\n-  /* RID_NULL */\tCONSTANT,\n-  /* RID_CATCH */\tCATCH,\n-  /* RID_DELETE */\tDELETE,\n-  /* RID_FALSE */\tCXX_FALSE,\n-  /* RID_NAMESPACE */\tNAMESPACE,\n-  /* RID_NEW */\t\tNEW,\n-  /* RID_OPERATOR */\tOPERATOR,\n-  /* RID_THIS */\tTHIS,\n-  /* RID_THROW */\tTHROW,\n-  /* RID_TRUE */\tCXX_TRUE,\n-  /* RID_TRY */\t\tTRY,\n-  /* RID_TYPENAME */\tTYPENAME_KEYWORD,\n-  /* RID_TYPEID */\tTYPEID,\n-  /* RID_USING */\tUSING,\n-\n-  /* casts */\n-  /* RID_CONSTCAST */\tCONST_CAST,\n-  /* RID_DYNCAST */\tDYNAMIC_CAST,\n-  /* RID_REINTCAST */\tREINTERPRET_CAST,\n-  /* RID_STATCAST */\tSTATIC_CAST,\n-\n-  /* Objective-C */\n-  /* RID_ID */\t\t\t0,\n-  /* RID_AT_ENCODE */\t\t0,\n-  /* RID_AT_END */\t\t0,\n-  /* RID_AT_CLASS */\t\t0,\n-  /* RID_AT_ALIAS */\t\t0,\n-  /* RID_AT_DEFS */\t\t0,\n-  /* RID_AT_PRIVATE */\t\t0,\n-  /* RID_AT_PROTECTED */\t0,\n-  /* RID_AT_PUBLIC */\t\t0,\n-  /* RID_AT_PROTOCOL */\t\t0,\n-  /* RID_AT_SELECTOR */\t\t0,\n-  /* RID_AT_INTERFACE */\t0,\n-  /* RID_AT_IMPLEMENTATION */\t0\n-};\n-\n void\n init_reswords ()\n {\n@@ -609,7 +461,6 @@ cxx_init (filename)\n   input_filename = \"<internal>\";\n \n   init_reswords ();\n-  init_spew ();\n   init_tree ();\n   init_cp_semantics ();\n   init_operators ();\n@@ -655,75 +506,6 @@ cxx_init (filename)\n   return filename;\n }\n \f\n-inline void\n-yyprint (file, yychar, yylval)\n-     FILE *file;\n-     int yychar;\n-     YYSTYPE yylval;\n-{\n-  tree t;\n-  switch (yychar)\n-    {\n-    case IDENTIFIER:\n-    case tTYPENAME:\n-    case TYPESPEC:\n-    case PTYPENAME:\n-    case PFUNCNAME:\n-    case IDENTIFIER_DEFN:\n-    case TYPENAME_DEFN:\n-    case PTYPENAME_DEFN:\n-    case SCSPEC:\n-    case PRE_PARSED_CLASS_DECL:\n-      t = yylval.ttype;\n-      if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (t) == TEMPLATE_DECL)\n-\t{\n-\t  fprintf (file, \" `%s'\", IDENTIFIER_POINTER (DECL_NAME (t)));\n-\t  break;\n-\t}\n-      my_friendly_assert (TREE_CODE (t) == IDENTIFIER_NODE, 224);\n-      if (IDENTIFIER_POINTER (t))\n-\t  fprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n-      break;\n-\n-    case AGGR:\n-      if (yylval.ttype == class_type_node)\n-\tfprintf (file, \" `class'\");\n-      else if (yylval.ttype == record_type_node)\n-\tfprintf (file, \" `struct'\");\n-      else if (yylval.ttype == union_type_node)\n-\tfprintf (file, \" `union'\");\n-      else if (yylval.ttype == enum_type_node)\n-\tfprintf (file, \" `enum'\");\n-      else\n-\tabort ();\n-      break;\n-\n-    case CONSTANT:\n-      t = yylval.ttype;\n-      if (TREE_CODE (t) == INTEGER_CST)\n-\tfprintf (file,\n-#if HOST_BITS_PER_WIDE_INT == 64\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\t\t \" 0x%x%016x\",\n-#else\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n-\t\t \" 0x%lx%016lx\",\n-#else\n-\t\t \" 0x%llx%016llx\",\n-#endif\n-#endif\n-#else\n-#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n-\t\t \" 0x%lx%08lx\",\n-#else\n-\t\t \" 0x%x%08x\",\n-#endif\n-#endif\n-\t\t TREE_INT_CST_HIGH (t), TREE_INT_CST_LOW (t));\n-      break;\n-    }\n-}\n-\n #if defined(GATHER_STATISTICS) && defined(REDUCE_LENGTH)\n static int *reduce_count;\n #endif\n@@ -873,36 +655,6 @@ interface_strcmp (s)\n   return 1;\n }\n \n-/* Heuristic to tell whether the user is missing a semicolon\n-   after a struct or enum declaration.  Emit an error message\n-   if we know the user has blown it.  */\n-\n-void\n-check_for_missing_semicolon (type)\n-     tree type;\n-{\n-  if (yychar < 0)\n-    yychar = yylex ();\n-\n-  if ((yychar > 255\n-       && yychar != SCSPEC\n-       && yychar != IDENTIFIER\n-       && yychar != tTYPENAME\n-       && yychar != CV_QUALIFIER\n-       && yychar != SELFNAME)\n-      || yychar == 0  /* EOF */)\n-    {\n-      if (TYPE_ANONYMOUS_P (type))\n-\terror (\"semicolon missing after %s declaration\",\n-\t       TREE_CODE (type) == ENUMERAL_TYPE ? \"enum\" : \"struct\");\n-      else\n-\terror (\"semicolon missing after declaration of `%T'\", type);\n-      shadow_tag (build_tree_list (0, type));\n-    }\n-  /* Could probably also hack cases where class { ... } f (); appears.  */\n-  clear_anon_tags ();\n-}\n-\n void\n note_got_semicolon (type)\n      tree type;"}, {"sha": "ecd5861f686426188150c5c9c7797bed7fa84ed8", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -74,10 +74,6 @@ extern GTY(()) tree lastiddecl;\n extern int looking_for_typename;\n extern int looking_for_template;\n \n-/* Tell the lexer where to look for names.  */\n-extern GTY(()) tree got_scope;\n-extern GTY(()) tree got_object;\n-\n /* Pending language change.\n    Positive is push count, negative is pop count.  */\n extern int pending_lang_change;"}, {"sha": "707a4987e91af3c465a7b636391b5c7ba60c8c40", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -145,43 +145,8 @@ hack_identifier (tree value, tree name)\n \n   type = TREE_TYPE (value);\n   if (TREE_CODE (value) == FIELD_DECL)\n-    {\n-      if (current_class_ptr == NULL_TREE)\n-\t{\n-\t  if (current_function_decl \n-\t      && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\t    error (\"invalid use of member `%D' in static member function\",\n-\t\t      value);\n-\t  else\n-\t    /* We can get here when processing a bad default\n-\t       argument, like:\n-\t         struct S { int a; void f(int i = a); }  */\n-\t    error (\"invalid use of member `%D'\", value);\n-\n-\t  return error_mark_node;\n-\t}\n-      TREE_USED (current_class_ptr) = 1;\n-      if (processing_template_decl)\n-\tvalue = build_min_nt (COMPONENT_REF, current_class_ref, name);\n-      else\n-\t{\n-\t  tree access_type = current_class_type;\n-\t  \n-\t  while (!DERIVED_FROM_P (context_for_name_lookup (value), \n-\t\t\t\t  access_type))\n-\t    {\n-\t      access_type = TYPE_CONTEXT (access_type);\n-\t      while (DECL_P (access_type))\n-\t\taccess_type = DECL_CONTEXT (access_type);\n-\t    }\n-\n-\t  enforce_access (access_type, value);\n-\t  value \n-\t    = build_class_member_access_expr (current_class_ref, value,\n-\t\t\t\t\t      /*access_path=*/NULL_TREE,\n-\t\t\t\t\t      /*preserve_reference=*/false);\n-\t}\n-    }\n+    value = finish_non_static_data_member (value, \n+\t\t\t\t\t   /*qualifying_scope=*/NULL_TREE);\n   else if ((TREE_CODE (value) == FUNCTION_DECL\n \t    && DECL_FUNCTION_MEMBER_P (value))\n \t   || (TREE_CODE (value) == OVERLOAD\n@@ -1013,7 +978,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   tree raises = empty_except_spec;\n   bool retref = false;\n   bool has_parm = false;\n-  tree name = constructor_name (TYPE_IDENTIFIER (type));\n+  tree name = constructor_name (type);\n \n   switch (kind)\n     {"}, {"sha": "af5410e64285c7ec32eb313dd42e25e3251b34a3", "filename": "gcc/cp/parser.c", "status": "added", "additions": 14825, "deletions": 0, "changes": 14825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6"}, {"sha": "a7d1af13ff73a2e13cc90769ad3c7090ea1e58f5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 234, "deletions": 131, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -36,7 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"tree-inline.h\"\n #include \"decl.h\"\n-#include \"parse.h\"\n #include \"lex.h\"\n #include \"output.h\"\n #include \"except.h\"\n@@ -135,7 +134,6 @@ static tree tsubst_friend_class PARAMS ((tree, tree));\n static int can_complete_type_without_circularity PARAMS ((tree));\n static tree get_bindings_real PARAMS ((tree, tree, tree, int, int, int));\n static int template_decl_level PARAMS ((tree));\n-static tree maybe_get_template_decl_from_type_decl PARAMS ((tree));\n static int check_cv_quals_for_unify PARAMS ((int, tree, tree));\n static tree tsubst_template_arg_vector PARAMS ((tree, tree, tsubst_flags_t));\n static tree tsubst_template_parms PARAMS ((tree, tree, tsubst_flags_t));\n@@ -167,30 +165,33 @@ static tree for_each_template_parm_r PARAMS ((tree *, int *, void *));\n static tree copy_default_args_to_explicit_spec_1 PARAMS ((tree, tree));\n static void copy_default_args_to_explicit_spec PARAMS ((tree));\n static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n+static int eq_local_specializations (const void *, const void *);\n+static tree template_for_substitution (tree);\n \n-/* Do any processing required when DECL (a member template declaration\n-   using TEMPLATE_PARAMETERS as its innermost parameter list) is\n-   finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless\n-   it is a specialization, in which case the DECL itself is returned.  */\n+/* Do any processing required when DECL (a member template\n+   declaration) is finished.  Returns the TEMPLATE_DECL corresponding\n+   to DECL, unless it is a specialization, in which case the DECL\n+   itself is returned.  */\n \n tree\n finish_member_template_decl (decl)\n   tree decl;\n {\n-  if (decl == NULL_TREE || decl == void_type_node)\n-    return NULL_TREE;\n-  else if (decl == error_mark_node)\n-    /* By returning NULL_TREE, the parser will just ignore this\n-       declaration.  We have already issued the error.  */\n-    return NULL_TREE;\n-  else if (TREE_CODE (decl) == TREE_LIST)\n+  if (decl == error_mark_node)\n+    return error_mark_node;\n+\n+  my_friendly_assert (DECL_P (decl), 20020812);\n+\n+  if (TREE_CODE (decl) == TYPE_DECL)\n     {\n-      /* Assume that the class is the only declspec.  */\n-      decl = TREE_VALUE (decl);\n-      if (IS_AGGR_TYPE (decl) && CLASSTYPE_TEMPLATE_INFO (decl)\n-\t  && ! CLASSTYPE_TEMPLATE_SPECIALIZATION (decl))\n+      tree type;\n+\n+      type = TREE_TYPE (decl);\n+      if (IS_AGGR_TYPE (type) \n+\t  && CLASSTYPE_TEMPLATE_INFO (type)\n+\t  && !CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n \t{\n-\t  tree tmpl = CLASSTYPE_TI_TEMPLATE (decl);\n+\t  tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n \t  check_member_template (tmpl);\n \t  return tmpl;\n \t}\n@@ -665,15 +666,16 @@ note_template_header (specialization)\n void\n begin_explicit_instantiation ()\n {\n-  ++processing_explicit_instantiation;\n+  my_friendly_assert (!processing_explicit_instantiation, 20020913);\n+  processing_explicit_instantiation = true;\n }\n \n \n void\n end_explicit_instantiation ()\n {\n-  my_friendly_assert(processing_explicit_instantiation > 0, 0);\n-  --processing_explicit_instantiation;\n+  my_friendly_assert(processing_explicit_instantiation, 20020913);\n+  processing_explicit_instantiation = false;\n }\n \n /* The TYPE is being declared.  If it is a template type, that means it\n@@ -683,7 +685,7 @@ void\n maybe_process_partial_specialization (type)\n      tree type;\n {\n-  if (IS_AGGR_TYPE (type) && CLASSTYPE_USE_TEMPLATE (type))\n+  if (CLASS_TYPE_P (type) && CLASSTYPE_USE_TEMPLATE (type))\n     {\n       if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n \t  && !COMPLETE_TYPE_P (type))\n@@ -743,7 +745,10 @@ static tree\n retrieve_local_specialization (tmpl)\n      tree tmpl;\n {\n-  return (tree) htab_find (local_specializations, tmpl);\n+  tree spec = \n+    (tree) htab_find_with_hash (local_specializations, tmpl,\n+\t\t\t\thtab_hash_pointer (tmpl));\n+  return spec ? TREE_PURPOSE (spec) : NULL_TREE;\n }\n \n /* Returns nonzero iff DECL is a specialization of TMPL.  */\n@@ -909,6 +914,16 @@ unregister_specialization (spec, tmpl)\n   return 0;\n }\n \n+/* Compare an entry in the local specializations hash table P1 (which\n+   is really a pointer to a TREE_LIST) with P2 (which is really a\n+   DECL).  */\n+\n+static int\n+eq_local_specializations (const void *p1, const void *p2)\n+{\n+  return TREE_VALUE ((tree) p1) == (tree) p2;\n+}\n+\n /* Like register_specialization, but for local declarations.  We are\n    registering SPEC, an instantiation of TMPL.  */\n \n@@ -919,8 +934,9 @@ register_local_specialization (spec, tmpl)\n {\n   void **slot;\n \n-  slot = htab_find_slot (local_specializations, tmpl, INSERT);\n-  *slot = spec;\n+  slot = htab_find_slot_with_hash (local_specializations, tmpl, \n+\t\t\t\t   htab_hash_pointer (tmpl), INSERT);\n+  *slot = build_tree_list (spec, tmpl);\n }\n \n /* Print the list of candidate FNS in an error message.  */\n@@ -2600,9 +2616,7 @@ push_template_decl_real (decl, is_friend)\n \n   if (!ctx \n       || TREE_CODE (ctx) == FUNCTION_DECL\n-      || (TREE_CODE (ctx) != TEMPLATE_TYPE_PARM\n-\t  && TREE_CODE (ctx) != BOUND_TEMPLATE_TEMPLATE_PARM\n-\t  && TYPE_BEING_DEFINED (ctx))\n+      || (CLASS_TYPE_P (ctx) && TYPE_BEING_DEFINED (ctx))\n       || (is_friend && !DECL_TEMPLATE_INFO (decl)))\n     {\n       if (DECL_LANG_SPECIFIC (decl)\n@@ -3875,7 +3889,7 @@ lookup_template_function (fns, arglist)\n    return the associated TEMPLATE_DECL.  Otherwise, the original\n    DECL is returned.  */\n \n-static tree\n+tree\n maybe_get_template_decl_from_type_decl (decl)\n      tree decl;\n {\n@@ -4427,6 +4441,12 @@ for_each_template_parm_r (tp, walk_subtrees, d)\n       }\n       break;\n \n+    case TYPEOF_TYPE:\n+      if (for_each_template_parm (TYPE_FIELDS (t), fn, data, \n+\t\t\t\t  pfd->visited))\n+\treturn error_mark_node;\n+      break;\n+\n     case FUNCTION_DECL:\n     case VAR_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t)\n@@ -4435,8 +4455,12 @@ for_each_template_parm_r (tp, walk_subtrees, d)\n \treturn error_mark_node;\n       /* Fall through.  */\n \n-    case CONST_DECL:\n     case PARM_DECL:\n+    case CONST_DECL:\n+      if (TREE_CODE (t) == CONST_DECL && DECL_TEMPLATE_PARM_P (t)\n+\t  && for_each_template_parm (DECL_INITIAL (t), fn, data,\n+\t\t\t\t     pfd->visited))\n+\treturn error_mark_node;\n       if (DECL_CONTEXT (t) \n \t  && for_each_template_parm (DECL_CONTEXT (t), fn, data,\n \t\t\t\t     pfd->visited))\n@@ -5951,10 +5975,6 @@ tsubst_decl (t, args, type, complain)\n \t       being called from tsubst_friend_function, and we want\n \t       only to create a new decl (R) with appropriate types so\n \t       that we can call determine_specialization.  */\n-\t    my_friendly_assert ((TREE_CODE (DECL_TI_TEMPLATE (t)) \n-\t\t\t\t == LOOKUP_EXPR)\n-\t\t\t\t|| (TREE_CODE (DECL_TI_TEMPLATE (t))\n-\t\t\t\t    == IDENTIFIER_NODE), 0);\n \t    gen_tmpl = NULL_TREE;\n \t  }\n \n@@ -7059,13 +7079,17 @@ tsubst_copy (t, args, complain, in_decl)\n   switch (code)\n     {\n     case PARM_DECL:\n-      return do_identifier (DECL_NAME (t), 0, NULL_TREE);\n+      r = retrieve_local_specialization (t);\n+      my_friendly_assert (r != NULL, 20020903);\n+      return r;\n \n     case CONST_DECL:\n       {\n \ttree enum_type;\n \ttree v;\n \n+\tif (DECL_TEMPLATE_PARM_P (t))\n+\t  return tsubst_copy (DECL_INITIAL (t), args, complain, in_decl);\n \tif (!DECL_CONTEXT (t))\n \t  /* This is a global enumeration constant.  */\n \t  return t;\n@@ -7111,13 +7135,53 @@ tsubst_copy (t, args, complain, in_decl)\n \n     case VAR_DECL:\n     case FUNCTION_DECL:\n-      if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n+      if ((DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n+\t  || local_variable_p (t))\n \tt = tsubst (t, args, complain, in_decl);\n       mark_used (t);\n       return t;\n \n+    case BASELINK:\n+      {\n+\ttree name;\n+\ttree qualifying_scope;\n+\ttree fns;\n+\ttree template_args;\n+\tbool template_id_p = false;\n+\n+\t/* A baselink indicates a function from a base class.  The\n+\t   BASELINK_ACCESS_BINFO and BASELINK_BINFO are going to have\n+\t   non-dependent types; otherwise, the lookup could not have\n+\t   succeeded.  However, they may indicate bases of the template\n+\t   class, rather than the instantiated class.  \n+\t   \n+\t   In addition, lookups that were not ambiguous before may be\n+\t   ambiguous now.  Therefore, we perform the lookup again. */\n+\tqualifying_scope = BINFO_TYPE (BASELINK_ACCESS_BINFO (t));\n+\tfns = BASELINK_FUNCTIONS (t);\n+\tif (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n+\t  {\n+\t    template_id_p = true;\n+\t    template_args = TREE_OPERAND (fns, 1);\n+\t    fns = TREE_OPERAND (fns, 0);\n+\t  }\n+\tname = DECL_NAME (get_first_fn (fns));\n+\tt = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n+\tif (BASELINK_P (t) && template_id_p)\n+\t  BASELINK_FUNCTIONS (t) \n+\t    = build_nt (TEMPLATE_ID_EXPR,\n+\t\t\tBASELINK_FUNCTIONS (t),\n+\t\t\ttemplate_args);\n+\treturn adjust_result_of_qualified_name_lookup (t, \n+\t\t\t\t\t\t       qualifying_scope,\n+\t\t\t\t\t\t       current_class_type);\n+      }\n+\n     case TEMPLATE_DECL:\n-      if (is_member_template (t))\n+      if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n+\treturn tsubst (TREE_TYPE (DECL_TEMPLATE_RESULT (t)), \n+\t\t       args, complain, in_decl);\n+      else if (is_member_template (t))\n \treturn tsubst (t, args, complain, in_decl);\n       else\n \treturn t;\n@@ -7168,6 +7232,35 @@ tsubst_copy (t, args, complain, in_decl)\n \t(code, tsubst (TREE_TYPE (t), args, complain, in_decl),\n \t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));\n \n+    case COMPONENT_REF:\n+      {\n+\ttree object;\n+\ttree name;\n+\n+\tobject = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\tname = TREE_OPERAND (t, 1);\n+\tif (TREE_CODE (name) == BIT_NOT_EXPR) \n+\t  {\n+\t    name = tsubst_copy (TREE_OPERAND (name, 0), args,\n+\t\t\t\tcomplain, in_decl);\n+\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n+\t  }\n+\telse if (TREE_CODE (name) == SCOPE_REF\n+\t\t && TREE_CODE (TREE_OPERAND (name, 1)) == BIT_NOT_EXPR)\n+\t  {\n+\t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args,\n+\t\t\t\t     complain, in_decl);\n+\t    name = TREE_OPERAND (name, 1);\n+\t    name = tsubst_copy (TREE_OPERAND (name, 0), args,\n+\t\t\t\tcomplain, in_decl);\n+\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n+\t    name = build_nt (SCOPE_REF, base, name);\n+\t  }\n+\telse\n+\t  name = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\treturn build_nt (COMPONENT_REF, object, name);\n+      }\n+\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:\n@@ -7198,7 +7291,6 @@ tsubst_copy (t, args, complain, in_decl)\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n-    case COMPONENT_REF:\n     case ARRAY_REF:\n     case COMPOUND_EXPR:\n     case SCOPE_REF:\n@@ -7213,48 +7305,20 @@ tsubst_copy (t, args, complain, in_decl)\n \t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n \n     case CALL_EXPR:\n-      {\n-\ttree fn = TREE_OPERAND (t, 0);\n-\tif (is_overloaded_fn (fn))\n-\t  fn = tsubst_copy (get_first_fn (fn), args, complain, in_decl);\n-\telse\n-\t  /* Sometimes FN is a LOOKUP_EXPR.  */\n-\t  fn = tsubst_copy (fn, args, complain, in_decl);\n-\treturn build_nt\n-\t  (code, fn, tsubst_copy (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t  in_decl),\n-\t   NULL_TREE);\n-      }\n+      return build_nt (code, \n+\t\t       tsubst_copy (TREE_OPERAND (t, 0), args,\n+\t\t\t\t    complain, in_decl),\n+\t\t       tsubst_copy (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t\t    in_decl),\n+\t\t       NULL_TREE);\n \n     case METHOD_CALL_EXPR:\n-      {\n-\ttree name = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (name) == BIT_NOT_EXPR)\n-\t  {\n-\t    name = tsubst_copy (TREE_OPERAND (name, 0), args,\n-\t\t\t\tcomplain, in_decl);\n-\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n-\t  }\n-\telse if (TREE_CODE (name) == SCOPE_REF\n-\t\t && TREE_CODE (TREE_OPERAND (name, 1)) == BIT_NOT_EXPR)\n-\t  {\n-\t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args,\n-\t\t\t\t     complain, in_decl);\n-\t    name = TREE_OPERAND (TREE_OPERAND (name, 1), 0);\n-\t    if (TREE_CODE (name) == TYPE_DECL)\n-\t      name = TREE_TYPE (name);\n-\t    name = tsubst_copy (name, args, complain, in_decl);\n-\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n-\t    name = build_nt (SCOPE_REF, base, name);\n-\t  }\n-\telse\n-\t  name = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\treturn build_nt\n-\t  (code, name, tsubst_copy (TREE_OPERAND (t, 1), args,\n-\t\t\t\t    complain, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl),\n-\t   NULL_TREE);\n-      }\n+      return build_nt\n+\t(code, \n+\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl),\n+\t NULL_TREE);\n \n     case STMT_EXPR:\n       /* This processing should really occur in tsubst_expr, However,\n@@ -7465,7 +7529,10 @@ tsubst_expr (t, args, complain, in_decl)\n \t    tree name = DECL_NAME (decl);\n \t    \n \t    scope = tsubst_expr (scope, args, complain, in_decl);\n-\t    do_local_using_decl (build_nt (SCOPE_REF, scope, name));\n+\t    do_local_using_decl (lookup_qualified_name (scope,\n+\t\t\t\t\t\t\tname, \n+\t\t\t\t\t\t\t/*is_type_p=*/0,\n+\t\t\t\t\t\t\t/*flags=*/0));\n \t  }\n \telse\n \t  {\n@@ -9123,6 +9190,8 @@ unify (tparms, targs, parm, arg, strict)\n \t\t    strict);\n \n     case CONST_DECL:\n+      if (DECL_TEMPLATE_PARM_P (parm))\n+\treturn unify (tparms, targs, DECL_INITIAL (parm), arg, strict);\n       if (arg != decl_constant_value (parm)) \n \treturn 1;\n       return 0;\n@@ -9915,7 +9984,7 @@ regenerate_decl_from_template (decl, tmpl)\n     /* Make sure that we can see identifiers, and compute access\n        correctly, for the class members used in the declaration of\n        this static variable or function.  */\n-    pushclass (DECL_CONTEXT (decl), 2);\n+    push_nested_class (DECL_CONTEXT (decl), 2);\n \n   /* Do the substitution to get the new declaration.  */\n   new_decl = tsubst (code_pattern, args, tf_error, NULL_TREE);\n@@ -9939,7 +10008,7 @@ regenerate_decl_from_template (decl, tmpl)\n \n   /* Pop the class context we pushed above.  */\n   if (DECL_CLASS_SCOPE_P (decl))\n-    popclass ();\n+    pop_nested_class ();\n \n   /* The immediate parent of the new template is still whatever it was\n      before, even though tsubst sets DECL_TI_TEMPLATE up as the most\n@@ -9960,6 +10029,65 @@ regenerate_decl_from_template (decl, tmpl)\n   register_specialization (decl, gen_tmpl, args);\n }\n \n+/* Return the TEMPLATE_DECL into which DECL_TI_ARGS(DECL) should be\n+   substituted to get DECL.  */\n+\n+static tree\n+template_for_substitution (tree decl)\n+{\n+  tree tmpl = DECL_TI_TEMPLATE (decl);\n+\n+  /* Set TMPL to the template whose DECL_TEMPLATE_RESULT is the pattern\n+     for the instantiation.  This is not always the most general\n+     template.  Consider, for example:\n+\n+        template <class T>\n+\tstruct S { template <class U> void f();\n+\t           template <> void f<int>(); };\n+\n+     and an instantiation of S<double>::f<int>.  We want TD to be the\n+     specialization S<T>::f<int>, not the more general S<T>::f<U>.  */\n+  while (/* An instantiation cannot have a definition, so we need a\n+\t    more general template.  */\n+\t DECL_TEMPLATE_INSTANTIATION (tmpl)\n+\t   /* We must also deal with friend templates.  Given:\n+\n+\t\ttemplate <class T> struct S { \n+\t\t  template <class U> friend void f() {};\n+\t\t};\n+\n+\t      S<int>::f<U> say, is not an instantiation of S<T>::f<U>,\n+\t      so far as the language is concerned, but that's still\n+\t      where we get the pattern for the instantiation from.  On\n+\t      other hand, if the definition comes outside the class, say:\n+\n+\t\ttemplate <class T> struct S { \n+\t\t  template <class U> friend void f();\n+\t\t};\n+\t\ttemplate <class U> friend void f() {}\n+\n+\t      we don't need to look any further.  That's what the check for\n+\t      DECL_INITIAL is for.  */\n+\t  || (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (tmpl)\n+\t      && !DECL_INITIAL (DECL_TEMPLATE_RESULT (tmpl))))\n+    {\n+      /* The present template, TD, should not be a definition.  If it\n+\t were a definition, we should be using it!  Note that we\n+\t cannot restructure the loop to just keep going until we find\n+\t a template with a definition, since that might go too far if\n+\t a specialization was declared, but not defined.  */\n+      my_friendly_assert (!(TREE_CODE (decl) == VAR_DECL\n+\t\t\t    && !DECL_IN_AGGR_P (DECL_TEMPLATE_RESULT (tmpl))), \n+\t\t\t  0); \n+      \n+      /* Fetch the more general template.  */\n+      tmpl = DECL_TI_TEMPLATE (tmpl);\n+    }\n+\n+  return tmpl;\n+}\n+\n /* Produce the definition of D, a _DECL generated from a template.  If\n    DEFER_OK is nonzero, then we don't have to actually do the\n    instantiation now; we just have to do it sometime.  */\n@@ -10017,54 +10145,8 @@ instantiate_decl (d, defer_ok)\n   timevar_push (TV_PARSE);\n \n   /* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern\n-     for the instantiation.  This is not always the most general\n-     template.  Consider, for example:\n-\n-        template <class T>\n-\tstruct S { template <class U> void f();\n-\t           template <> void f<int>(); };\n-\n-     and an instantiation of S<double>::f<int>.  We want TD to be the\n-     specialization S<T>::f<int>, not the more general S<T>::f<U>.  */\n-  td = tmpl;\n-  while (/* An instantiation cannot have a definition, so we need a\n-\t    more general template.  */\n-\t DECL_TEMPLATE_INSTANTIATION (td)\n-\t   /* We must also deal with friend templates.  Given:\n-\n-\t\ttemplate <class T> struct S { \n-\t\t  template <class U> friend void f() {};\n-\t\t};\n-\n-\t      S<int>::f<U> say, is not an instantiation of S<T>::f<U>,\n-\t      so far as the language is concerned, but that's still\n-\t      where we get the pattern for the instantiation from.  On\n-\t      other hand, if the definition comes outside the class, say:\n-\n-\t\ttemplate <class T> struct S { \n-\t\t  template <class U> friend void f();\n-\t\t};\n-\t\ttemplate <class U> friend void f() {}\n-\n-\t      we don't need to look any further.  That's what the check for\n-\t      DECL_INITIAL is for.  */\n-\t  || (TREE_CODE (d) == FUNCTION_DECL\n-\t      && DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (td)\n-\t      && !DECL_INITIAL (DECL_TEMPLATE_RESULT (td))))\n-    {\n-      /* The present template, TD, should not be a definition.  If it\n-\t were a definition, we should be using it!  Note that we\n-\t cannot restructure the loop to just keep going until we find\n-\t a template with a definition, since that might go too far if\n-\t a specialization was declared, but not defined.  */\n-      my_friendly_assert (!(TREE_CODE (d) == VAR_DECL\n-\t\t\t    && !DECL_IN_AGGR_P (DECL_TEMPLATE_RESULT (td))), \n-\t\t\t  0); \n-      \n-      /* Fetch the more general template.  */\n-      td = DECL_TI_TEMPLATE (td);\n-    }\n-\n+     for the instantiation.  */\n+  td = template_for_substitution (d);\n   code_pattern = DECL_TEMPLATE_RESULT (td);\n \n   /* In the case of a friend template whose definition is provided\n@@ -10223,20 +10305,41 @@ instantiate_decl (d, defer_ok)\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n       htab_t saved_local_specializations;\n+      tree subst_decl;\n+      tree tmpl_parm;\n+      tree spec_parm;\n \n       /* Save away the current list, in case we are instantiating one\n \t template from within the body of another.  */\n       saved_local_specializations = local_specializations;\n \n       /* Set up the list of local specializations.  */\n       local_specializations = htab_create (37, \n-\t\t\t\t\t   htab_hash_pointer,\n-\t\t\t\t\t   htab_eq_pointer,\n+\t\t\t\t\t   NULL,\n+\t\t\t\t\t   eq_local_specializations,\n \t\t\t\t\t   NULL);\n \n       /* Set up context.  */\n       start_function (NULL_TREE, d, NULL_TREE, SF_PRE_PARSED);\n \n+      /* Create substitution entries for the parameters.  */\n+      subst_decl = DECL_TEMPLATE_RESULT (template_for_substitution (d));\n+      tmpl_parm = DECL_ARGUMENTS (subst_decl);\n+      spec_parm = DECL_ARGUMENTS (d);\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (d))\n+\t{\n+\t  register_local_specialization (spec_parm, tmpl_parm);\n+\t  spec_parm = skip_artificial_parms_for (d, spec_parm);\n+\t  tmpl_parm = skip_artificial_parms_for (subst_decl, tmpl_parm);\n+\t}\n+      while (tmpl_parm)\n+\t{\n+\t  register_local_specialization (spec_parm, tmpl_parm);\n+\t  tmpl_parm = TREE_CHAIN (tmpl_parm);\n+\t  spec_parm = TREE_CHAIN (spec_parm);\n+\t}\n+      my_friendly_assert (!spec_parm, 20020813);\n+\n       /* Substitute into the body of the function.  */\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n \t\t   tf_error | tf_warning, tmpl);"}, {"sha": "c1a4d824afe94071fb743d37554b581bba64748b", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -110,14 +110,17 @@ static int doing_runtime = 0;\n void\n init_rtti_processing ()\n {\n+  tree const_type_info_type;\n+\n   push_namespace (std_identifier);\n   type_info_type_node \n     = xref_tag (class_type, get_identifier (\"type_info\"),\n \t\t/*attributes=*/NULL_TREE, 1);\n   pop_namespace ();\n-  type_info_ptr_type = \n-    build_pointer_type\n-     (build_qualified_type (type_info_type_node, TYPE_QUAL_CONST));\n+  const_type_info_type = build_qualified_type (type_info_type_node, \n+\t\t\t\t\t       TYPE_QUAL_CONST);\n+  type_info_ptr_type = build_pointer_type (const_type_info_type);\n+  type_info_ref_type = build_reference_type (const_type_info_type);\n \n   create_tinfo_types ();\n }\n@@ -263,7 +266,7 @@ build_typeid (exp)\n     return error_mark_node;\n \n   if (processing_template_decl)\n-    return build_min_nt (TYPEID_EXPR, exp);\n+    return build_min (TYPEID_EXPR, type_info_ref_type, exp);\n \n   if (TREE_CODE (exp) == INDIRECT_REF\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n@@ -394,7 +397,7 @@ get_typeid (type)\n     return error_mark_node;\n   \n   if (processing_template_decl)\n-    return build_min_nt (TYPEID_EXPR, type);\n+    return build_min (TYPEID_EXPR, type_info_ref_type, type);\n \n   /* If the type of the type-id is a reference type, the result of the\n      typeid expression refers to a type_info object representing the"}, {"sha": "263cda5bb433e17e622683001156b47b88a510f5", "filename": "gcc/cp/search.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -1035,7 +1035,7 @@ accessible_p (type, decl)\n   int protected_ok = 0;\n \n   /* If we're not checking access, everything is accessible.  */\n-  if (!flag_access_control)\n+  if (!scope_chain->check_access)\n     return 1;\n \n   /* If this declaration is in a block or namespace scope, there's no\n@@ -1674,11 +1674,11 @@ lookup_fnfields_1 (type, name)\n   return -1;\n }\n \n-/* DECL is the result of a qualified name lookup.  QUALIFYING_CLASS\n-   was the class used to qualify the name.  CONTEXT_CLASS is the class\n-   corresponding to the object in which DECL will be used.  Return a\n-   possibly modified version of DECL that takes into account the\n-   CONTEXT_CLASS.\n+/* DECL is the result of a qualified name lookup.  QUALIFYING_SCOPE is\n+   the class or namespace used to qualify the name.  CONTEXT_CLASS is\n+   the class corresponding to the object in which DECL will be used.\n+   Return a possibly modified version of DECL that takes into account\n+   the CONTEXT_CLASS.\n \n    In particular, consider an expression like `B::m' in the context of\n    a derived class `D'.  If `B::m' has been resolved to a BASELINK,\n@@ -1687,22 +1687,22 @@ lookup_fnfields_1 (type, name)\n \n tree\n adjust_result_of_qualified_name_lookup (tree decl, \n-\t\t\t\t\ttree qualifying_class,\n+\t\t\t\t\ttree qualifying_scope,\n \t\t\t\t\ttree context_class)\n {\n-  my_friendly_assert (CLASS_TYPE_P (qualifying_class), 20020808);\n-  my_friendly_assert (CLASS_TYPE_P (context_class), 20020808);\n-\n-  if (BASELINK_P (decl) \n-      && DERIVED_FROM_P (qualifying_class, context_class))\n+  if (context_class && CLASS_TYPE_P (qualifying_scope) \n+      && DERIVED_FROM_P (qualifying_scope, context_class)\n+      && BASELINK_P (decl))\n     {\n       tree base;\n \n-      /* Look for the QUALIFYING_CLASS as a base of the\n-\t CONTEXT_CLASS.  If QUALIFYING_CLASS is ambiguous, we cannot\n+      my_friendly_assert (CLASS_TYPE_P (context_class), 20020808);\n+\n+      /* Look for the QUALIFYING_SCOPE as a base of the\n+\t CONTEXT_CLASS.  If QUALIFYING_SCOPE is ambiguous, we cannot\n \t be sure yet than an error has occurred; perhaps the function\n \t chosen by overload resolution will be static.  */\n-      base = lookup_base (context_class, qualifying_class,\n+      base = lookup_base (context_class, qualifying_scope,\n \t\t\t  ba_ignore | ba_quiet, NULL);\n       if (base)\n \t{"}, {"sha": "6e06da54f38dd5758c7395436fa672ed2a2c4a7d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 154, "deletions": 37, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -947,9 +947,9 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n \t\t\t\t\t&allows_reg,\n \t\t\t\t\t&is_inout))\n \t    {\n-\t      /* By marking the type as erroneous, we will not try to\n-\t\t process this operand again in expand_asm_operands.  */\n-\t      TREE_TYPE (operand) = error_mark_node;\n+\t      /* By marking this operand as erroneous, we will not try\n+\t\t to process this operand again in expand_asm_operands.  */\n+\t      TREE_VALUE (t) = error_mark_node;\n \t      continue;\n \t    }\n \n@@ -972,12 +972,12 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n \n /* Finish a label with the indicated NAME.  */\n \n-void\n+tree\n finish_label_stmt (name)\n      tree name;\n {\n   tree decl = define_label (input_filename, lineno, name);\n-  add_stmt (build_stmt (LABEL_STMT, decl));\n+  return add_stmt (build_stmt (LABEL_STMT, decl));\n }\n \n /* Finish a series of declarations for local labels.  G++ allows users\n@@ -1146,6 +1146,58 @@ finish_parenthesized_expr (expr)\n   return expr;\n }\n \n+/* Finish a reference to a non-static data member (DECL) that is not\n+   preceded by `.' or `->'.  */\n+\n+tree\n+finish_non_static_data_member (tree decl, tree qualifying_scope)\n+{\n+  my_friendly_assert (TREE_CODE (decl) == FIELD_DECL, 20020909);\n+\n+  if (current_class_ptr == NULL_TREE)\n+    {\n+      if (current_function_decl \n+\t  && DECL_STATIC_FUNCTION_P (current_function_decl))\n+\tcp_error_at (\"invalid use of member `%D' in static member function\",\n+\t\t     decl);\n+      else\n+\tcp_error_at (\"invalid use of non-static data member `%D'\", decl);\n+      error (\"from this location\");\n+\n+      return error_mark_node;\n+    }\n+  TREE_USED (current_class_ptr) = 1;\n+  if (processing_template_decl)\n+    return build_min_nt (COMPONENT_REF, current_class_ref, DECL_NAME (decl));\n+  else\n+    {\n+      tree access_type = current_class_type;\n+      tree object = current_class_ref;\n+\n+      while (!DERIVED_FROM_P (context_for_name_lookup (decl), access_type))\n+\t{\n+\t  access_type = TYPE_CONTEXT (access_type);\n+\t  while (DECL_P (access_type))\n+\t    access_type = DECL_CONTEXT (access_type);\n+\t}\n+\n+      enforce_access (access_type, decl);\n+\n+      /* If the data member was named `C::M', convert `*this' to `C'\n+\t first.  */\n+      if (qualifying_scope)\n+\t{\n+\t  tree binfo = NULL_TREE;\n+\t  object = build_scoped_ref (object, qualifying_scope,\n+\t\t\t\t     &binfo);\n+\t}\n+\n+      return build_class_member_access_expr (object, decl,\n+\t\t\t\t\t     /*access_path=*/NULL_TREE,\n+\t\t\t\t\t     /*preserve_reference=*/false);\n+    }\n+}\n+\n /* Begin a statement-expression.  The value returned must be passed to\n    finish_stmt_expr.  */\n \n@@ -1251,6 +1303,26 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n   my_friendly_assert (!args || TREE_CODE (args) == TREE_LIST,\n \t\t      20020712);\n \n+  /* A reference to a member function will appear as an overloaded\n+     function (rather than a BASELINK) if an unqualified name was used\n+     to refer to it.  */\n+  if (!BASELINK_P (fn) && is_overloaded_fn (fn))\n+    {\n+      tree f;\n+\n+      if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+\tf = get_first_fn (TREE_OPERAND (fn, 0));\n+      else\n+\tf = get_first_fn (fn);\n+      if (DECL_FUNCTION_MEMBER_P (f))\n+\t{\n+\t  tree type = currently_open_derived_class (DECL_CONTEXT (f));\n+\t  fn = build_baselink (TYPE_BINFO (type),\n+\t\t\t       TYPE_BINFO (type),\n+\t\t\t       fn, /*optype=*/NULL_TREE);\n+\t}\n+    }\n+\n   if (BASELINK_P (fn))\n     {\n       tree object;\n@@ -1296,6 +1368,20 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n   else if (is_overloaded_fn (fn))\n     /* A call to a namespace-scope function.  */\n     return build_new_function_call (fn, args);\n+  else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)\n+    {\n+      tree result;\n+\n+      if (args)\n+\terror (\"arguments to destructor are not allowed\");\n+      /* Mark the pseudo-destructor call as having side-effects so\n+\t that we do not issue warnings about its use.  */\n+      result = build1 (NOP_EXPR,\n+\t\t       void_type_node,\n+\t\t       TREE_OPERAND (fn, 0));\n+      TREE_SIDE_EFFECTS (result) = 1;\n+      return result;\n+    }\n   else if (CLASS_TYPE_P (TREE_TYPE (fn)))\n     {\n       /* If the \"function\" is really an object of class type, it might\n@@ -1386,6 +1472,11 @@ finish_object_call_expr (fn, object, args)\n \t}\n     }\n   \n+  if (processing_template_decl)\n+    return build_nt (CALL_EXPR,\n+\t\t     build_nt (COMPONENT_REF, object, fn),\n+\t\t     args);\n+\n   if (name_p (fn))\n     return build_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n   else\n@@ -1405,29 +1496,38 @@ finish_qualified_object_call_expr (fn, object, args)\n \t\t\t\t   TREE_OPERAND (fn, 1), args);\n }\n \n-/* Finish a pseudo-destructor call expression of OBJECT, with SCOPE\n-   being the scope, if any, of DESTRUCTOR.  Returns an expression for\n-   the call.  */\n+/* Finish a pseudo-destructor expression.  If SCOPE is NULL, the\n+   expression was of the form `OBJECT.~DESTRUCTOR' where DESTRUCTOR is\n+   the TYPE for the type given.  If SCOPE is non-NULL, the expression\n+   was of the form `OBJECT.SCOPE::~DESTRUCTOR'.  */\n \n tree \n-finish_pseudo_destructor_call_expr (object, scope, destructor)\n+finish_pseudo_destructor_expr (object, scope, destructor)\n      tree object;\n      tree scope;\n      tree destructor;\n {\n-  if (processing_template_decl)\n-    return build_min_nt (PSEUDO_DTOR_EXPR, object, scope, destructor);\n+  if (destructor == error_mark_node)\n+    return error_mark_node;\n \n-  if (scope && scope != destructor)\n-    error (\"destructor specifier `%T::~%T()' must have matching names\", \n-\t      scope, destructor);\n+  my_friendly_assert (TYPE_P (destructor), 20010905);\n \n-  if ((scope == NULL_TREE || IDENTIFIER_GLOBAL_VALUE (destructor))\n-      && (TREE_CODE (TREE_TYPE (object)) !=\n-\t  TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (destructor)))))\n-    error (\"`%E' is not of type `%T'\", object, destructor);\n+  if (!processing_template_decl)\n+    {\n+      if (scope == error_mark_node)\n+\t{\n+\t  error (\"invalid qualifying scope in pseudo-destructor name\");\n+\t  return error_mark_node;\n+\t}\n+      \n+      if (!same_type_p (TREE_TYPE (object), destructor))\n+\t{\n+\t  error (\"`%E' is not of type `%T'\", object, destructor);\n+\t  return error_mark_node;\n+\t}\n+    }\n \n-  return cp_convert (void_type_node, object);\n+  return build (PSEUDO_DTOR_EXPR, void_type_node, object, scope, destructor);\n }\n \n /* Finish an expression of the form CODE EXPR.  */\n@@ -1464,6 +1564,40 @@ finish_id_expr (expr)\n   return expr;\n }\n \n+/* Finish a compound-literal expression.  TYPE is the type to which\n+   the INITIALIZER_LIST is being cast.  */\n+\n+tree\n+finish_compound_literal (type, initializer_list)\n+     tree type;\n+     tree initializer_list;\n+{\n+  tree compound_literal;\n+\n+  /* Build a CONSTRUCTOR for the INITIALIZER_LIST.  */\n+  compound_literal = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t       initializer_list);\n+  /* Mark it as a compound-literal.  */\n+  TREE_HAS_CONSTRUCTOR (compound_literal) = 1;\n+  if (processing_template_decl)\n+    TREE_TYPE (compound_literal) = type;\n+  else\n+    {\n+      /* Check the initialization.  */\n+      compound_literal = digest_init (type, compound_literal, NULL);\n+      /* If the TYPE was an array type with an unknown bound, then we can\n+\t figure out the dimension now.  For example, something like:\n+\n+\t   `(int []) { 2, 3 }'\n+\n+\t implies that the array has two elements.  */\n+      if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n+\tcomplete_array_type (type, compound_literal, 1);\n+    }\n+\n+  return compound_literal;\n+}\n+\n /* Return the declaration for the function-name variable indicated by\n    ID.  */\n \n@@ -1922,26 +2056,12 @@ finish_class_definition (t, attributes, semi, pop_scope_p)\n \tnote_got_semicolon (t);\n     }\n \n-  if (! semi)\n-    check_for_missing_semicolon (t); \n   if (pop_scope_p)\n     pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (t)));\n-  if (current_scope () == current_function_decl)\n-    do_pending_defargs ();\n \n   return t;\n }\n \n-/* Finish processing the default argument expressions cached during\n-   the processing of a class definition.  */\n-\n-void\n-begin_inline_definitions ()\n-{\n-  if (current_scope () == current_function_decl)\n-    do_pending_inlines ();\n-}\n-\n /* Finish processing the declaration of a member class template\n    TYPES whose template parameters are given by PARMS.  */\n \n@@ -2124,9 +2244,6 @@ tree\n finish_sizeof (t)\n      tree t;\n {\n-  if (processing_template_decl)\n-    return build_min_nt (SIZEOF_EXPR, t);\n-\n   return TYPE_P (t) ? cxx_sizeof (t) : expr_sizeof (t);\n }\n \n@@ -2138,7 +2255,7 @@ finish_alignof (t)\n      tree t;\n {\n   if (processing_template_decl)\n-    return build_min_nt (ALIGNOF_EXPR, t);\n+    return build_min (ALIGNOF_EXPR, size_type_node, t);\n \n   return TYPE_P (t) ? cxx_alignof (t) : c_alignof_expr (t);\n }"}, {"sha": "d50c926b0951424811b82c3eaa59ed9141085e9a", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"c-pragma.h\"\n #include \"lex.h\"\n-#include \"parse.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n #include \"toplev.h\""}, {"sha": "271fd0f2dbcc6d4866e5e029e7b08073ca557f0e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -1034,20 +1034,6 @@ really_overloaded_fn (x)\n \t  || TREE_CODE (x) == TEMPLATE_ID_EXPR);\n }\n \n-/* Return the OVERLOAD or FUNCTION_DECL inside FNS.  FNS can be an\n-   OVERLOAD, FUNCTION_DECL, TEMPLATE_ID_EXPR, or baselink.  */\n-\n-tree\n-get_overloaded_fn (fns)\n-     tree fns;\n-{\n-  if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n-    fns = TREE_OPERAND (fns, 0);\n-  if (BASELINK_P (fns))\n-    fns = BASELINK_FUNCTIONS (fns);\n-  return fns;\n-}\n-\n tree\n get_first_fn (from)\n      tree from;"}, {"sha": "2e95f572705ad77258c14190b0dc35dd0d1f8109", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 70, "deletions": 38, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a723baf1eb1df63264ed1abdad50949a22f3a1a6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a723baf1eb1df63264ed1abdad50949a22f3a1a6", "patch": "@@ -66,6 +66,7 @@ static void casts_away_constness_r PARAMS ((tree *, tree *));\n static int casts_away_constness PARAMS ((tree, tree));\n static void maybe_warn_about_returning_address_of_local PARAMS ((tree));\n static tree strip_all_pointer_quals PARAMS ((tree));\n+static tree lookup_destructor (tree, tree, tree);\n \n /* Return the target type of TYPE, which means return T for:\n    T*, T&, T[], T (...), and otherwise, just T.  */\n@@ -1858,6 +1859,9 @@ build_class_member_access_expr (tree object, tree member,\n   if (object == error_mark_node || member == error_mark_node)\n     return error_mark_node;\n \n+  if (TREE_CODE (member) == PSEUDO_DTOR_EXPR)\n+    return member;\n+\n   my_friendly_assert (DECL_P (member) || BASELINK_P (member),\n \t\t      20020801);\n \n@@ -1988,7 +1992,14 @@ build_class_member_access_expr (tree object, tree member,\n \t anonymous union.  Generate a reference to the anonymous union\n \t itself, and recur to find MEMBER.  */\n       if (ANON_AGGR_TYPE_P (DECL_CONTEXT (member))\n-\t  && !same_type_p (object_type, DECL_CONTEXT (member)))\n+\t  /* When this code is called from build_field_call, the\n+\t     object already has the type of the anonymous union.\n+\t     That is because the COMPONENT_REF was already\n+\t     constructed, and was then disassembled before calling\n+\t     build_field_call.  After the function-call code is\n+\t     cleaned up, this waste can be eliminated.  */\n+\t  && (!same_type_ignoring_top_level_qualifiers_p \n+\t      (TREE_TYPE (object), DECL_CONTEXT (member))))\n \t{\n \t  tree anonymous_union;\n \n@@ -2030,26 +2041,20 @@ build_class_member_access_expr (tree object, tree member,\n     {\n       /* The member is a (possibly overloaded) member function.  */\n       tree functions;\n+      tree type;\n \n       /* If the MEMBER is exactly one static member function, then we\n \t know the type of the expression.  Otherwise, we must wait\n \t until overload resolution has been performed.  */\n       functions = BASELINK_FUNCTIONS (member);\n       if (TREE_CODE (functions) == FUNCTION_DECL\n \t  && DECL_STATIC_FUNCTION_P (functions))\n-\t{\n-\t  /* A static member function.  */\n-\t  result = functions;\n-\t  mark_used (result);\n-\t  /* If OBJECT has side-effects, they are supposed to occur.  */\n-\t  if (TREE_SIDE_EFFECTS (object))\n-\t    result = build (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t\t    object, result);\n-\t}\n+\ttype = TREE_TYPE (functions);\n       else\n-\t/* Note that we do not convert OBJECT to the BASELINK_BINFO\n-\t   base.  That will happen when the function is called.  */\n-\tresult = build (COMPONENT_REF, unknown_type_node, object, member);\n+\ttype = unknown_type_node;\n+      /* Note that we do not convert OBJECT to the BASELINK_BINFO\n+\t base.  That will happen when the function is called.  */\n+      result = build (COMPONENT_REF, type, object, member);\n     }\n   else if (TREE_CODE (member) == CONST_DECL)\n     {\n@@ -2076,6 +2081,34 @@ build_class_member_access_expr (tree object, tree member,\n   return result;\n }\n \n+/* Return the destructor denoted by OBJECT.SCOPE::~DTOR_NAME, or, if\n+   SCOPE is NULL, by OBJECT.~DTOR_NAME.  */\n+\n+static tree\n+lookup_destructor (tree object, tree scope, tree dtor_name)\n+{\n+  tree object_type = TREE_TYPE (object);\n+  tree dtor_type = TREE_OPERAND (dtor_name, 0);\n+\n+  if (scope && !check_dtor_name (scope, dtor_name))\n+    {\n+      error (\"qualified type `%T' does not match destructor name `~%T'\",\n+\t     scope, dtor_type);\n+      return error_mark_node;\n+    }\n+  if (!same_type_p (dtor_type, TYPE_MAIN_VARIANT (object_type)))\n+    {\n+      error (\"destructor name `%T' does not match type `%T' of expression\",\n+\t     dtor_type, object_type);\n+      return error_mark_node;\n+    }\n+  if (!TYPE_HAS_DESTRUCTOR (object_type))\n+    return build (PSEUDO_DTOR_EXPR, void_type_node, object, scope,\n+\t\t  dtor_type);\n+  return lookup_member (object_type, complete_dtor_identifier,\n+\t\t\t/*protect=*/1, /*want_type=*/0);\n+}\n+\n /* This function is called by the parser to process a class member\n    access expression of the form OBJECT.NAME.  NAME is a node used by\n    the parser to represent a name; it is not yet a DECL.  It may,\n@@ -2171,33 +2204,24 @@ finish_class_member_access_expr (tree object, tree name)\n \t  if (!access_path || access_path == error_mark_node)\n \t    return error_mark_node;\n \n-\t  /* Look up the member.  */\n-\t  member = lookup_member (access_path, name, /*protect=*/1, \n-\t\t\t\t  /*want_type=*/0);\n-\t  if (member == NULL_TREE)\n+\t  if (TREE_CODE (name) == BIT_NOT_EXPR)\n+\t    member = lookup_destructor (object, scope, name);\n+\t  else\n \t    {\n-\t      error (\"'%D' has no member named '%E'\", object_type, name);\n-\t      return error_mark_node;\n+\t      /* Look up the member.  */\n+\t      member = lookup_member (access_path, name, /*protect=*/1, \n+\t\t\t\t      /*want_type=*/0);\n+\t      if (member == NULL_TREE)\n+\t\t{\n+\t\t  error (\"'%D' has no member named '%E'\", object_type, name);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      if (member == error_mark_node)\n+\t\treturn error_mark_node;\n \t    }\n-\t  else if (member == error_mark_node)\n-\t    return error_mark_node;\n \t}\n       else if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\t{\n-\t  /* A destructor.  */\n-\t  if (TYPE_IDENTIFIER (object_type) != TREE_OPERAND (name, 0))\n-\t    {\n-\t      error (\"destructor specifier `%T::~%T' must have matching names\",\n-\t\t     object_type, TREE_OPERAND (name, 0));\n-\t      return error_mark_node;\n-\t    }\n-\t  if (! TYPE_HAS_DESTRUCTOR (object_type))\n-\t    {\n-\t      error (\"type `%T' has no destructor\", object_type);\n-\t      return error_mark_node;\n-\t    }\n-\t  member = CLASSTYPE_DESTRUCTORS (object_type);\n-\t}\n+\tmember = lookup_destructor (object, /*scope=*/NULL_TREE, name);\n       else if (TREE_CODE (name) == IDENTIFIER_NODE)\n \t{\n \t  /* An unqualified name.  */\n@@ -2238,6 +2262,9 @@ finish_class_member_access_expr (tree object, tree name)\n \t}\n     }\n \n+  if (TREE_DEPRECATED (member))\n+    warn_deprecated_use (member);\n+\n   return build_class_member_access_expr (object, member, access_path,\n \t\t\t\t\t /*preserve_reference=*/false);\n }\n@@ -2907,7 +2934,8 @@ convert_arguments (typelist, values, fndecl, flags)\n   if (typetail != 0 && typetail != void_list_node)\n     {\n       /* See if there are default arguments that can be used */\n-      if (TREE_PURPOSE (typetail))\n+      if (TREE_PURPOSE (typetail) \n+\t  && TREE_CODE (TREE_PURPOSE (typetail)) != DEFAULT_ARG)\n \t{\n \t  for (; typetail != void_list_node; ++i)\n \t    {\n@@ -4233,7 +4261,7 @@ build_unary_op (code, xarg, noconvert)\n \t      if (current_class_type\n \t\t  && TREE_OPERAND (arg, 0) == current_class_ref)\n \t\t/* An expression like &memfn.  */\n-\t\tpedwarn (\"ISO C++ forbids taking the address of an unqualified non-static member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n+\t\tpedwarn (\"ISO C++ forbids taking the address of an unqualified or parenthesized non-static member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n \t      else\n \t\tpedwarn (\"ISO C++ forbids taking the address of a bound member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n \t    }\n@@ -4287,6 +4315,10 @@ build_unary_op (code, xarg, noconvert)\n       {\n \ttree addr;\n \n+\tif (TREE_CODE (arg) == COMPONENT_REF\n+\t    && TREE_CODE (TREE_OPERAND (arg, 1)) == BASELINK)\n+\t  arg = BASELINK_FUNCTIONS (TREE_OPERAND (arg, 1));\n+\n \tif (TREE_CODE (arg) == COMPONENT_REF\n \t    && DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n \t  {"}]}