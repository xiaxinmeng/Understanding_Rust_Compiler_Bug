{"sha": "5fd8383e9493adf43f561d1e2f376260f6ad66cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZkODM4M2U5NDkzYWRmNDNmNTYxZDFlMmYzNzYyNjBmNmFkNjZjZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T22:05:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T22:05:53Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1482", "tree": {"sha": "be402be0ca468e66193842c59baa933e192edf81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be402be0ca468e66193842c59baa933e192edf81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fd8383e9493adf43f561d1e2f376260f6ad66cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd8383e9493adf43f561d1e2f376260f6ad66cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd8383e9493adf43f561d1e2f376260f6ad66cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd8383e9493adf43f561d1e2f376260f6ad66cf/comments", "author": null, "committer": null, "parents": [{"sha": "95393dfdf89145c8cc8224c1c2e1782ce2d8273c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95393dfdf89145c8cc8224c1c2e1782ce2d8273c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95393dfdf89145c8cc8224c1c2e1782ce2d8273c"}], "stats": {"total": 174, "additions": 87, "deletions": 87}, "files": [{"sha": "454357ca97c8762680f2277fb9a19859668d2605", "filename": "gcc/loop.c", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd8383e9493adf43f561d1e2f376260f6ad66cf/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd8383e9493adf43f561d1e2f376260f6ad66cf/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5fd8383e9493adf43f561d1e2f376260f6ad66cf", "patch": "@@ -1,5 +1,5 @@\n /* Move constant computations out of loops.\n-   Copyright (C) 1987, 1988, 1989, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1991, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -97,12 +97,12 @@ static char *loop_invalid;\n rtx *loop_number_exit_labels;\n \n /* Holds the number of loop iterations.  It is zero if the number could not be\n-   calculated.  Must be unsigned long since the number of iterations can\n-   be as high as 2^31-1.  For loops with a DImode iterator, this number will\n-   will be zero if the number of loop iterations is too large for an\n-   unsigned long to hold.  */\n+   calculated.  Must be unsigned since the number of iterations can\n+   be as high as 2^wordsize-1.  For loops with a wider iterator, this number\n+   will will be zero if the number of loop iterations is too large for an\n+   unsigned integer to hold.  */\n \n-unsigned long loop_n_iterations;\n+unsigned HOST_WIDE_INT loop_n_iterations;\n \n /* Nonzero if there is a subroutine call in the current loop.\n    (unknown_address_altered is also nonzero in this case.)  */\n@@ -298,7 +298,7 @@ init_loop ()\n {\n   char *free_point = (char *) oballoc (1);\n   rtx reg = gen_rtx (REG, SImode, 0);\n-  rtx pow2 = gen_rtx (CONST_INT, VOIDmode, 32);\n+  rtx pow2 = GEN_INT (32);\n   rtx lea;\n   int i;\n \n@@ -307,11 +307,8 @@ init_loop ()\n   /* We multiply by 2 to reconcile the difference in scale between\n      these two ways of computing costs.  Otherwise the cost of a copy\n      will be far less than the cost of an add.  */\n-#ifdef REGISTER_MOVE_COST\n-  copy_cost = REGISTER_MOVE_COST (GENERAL_REGS, GENERAL_REGS) * 2;\n-#else\n+\n   copy_cost = 2 * 2;\n-#endif\n \n   /* Free the objects we just allocated.  */\n   obfree (free_point);\n@@ -637,10 +634,10 @@ scan_loop (loop_start, end, nregs)\n \t}\n \n       if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t  && find_reg_note (p, REG_LIBCALL, 0))\n+\t  && find_reg_note (p, REG_LIBCALL, NULL_RTX))\n \tin_libcall = 1;\n       else if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t       && find_reg_note (p, REG_RETVAL, 0))\n+\t       && find_reg_note (p, REG_RETVAL, NULL_RTX))\n \tin_libcall = 0;\n \n       if (GET_CODE (p) == INSN\n@@ -662,15 +659,15 @@ scan_loop (loop_start, end, nregs)\n \n \t     Otherwise, only use the REG_EQUAL contents if a REG_RETVAL note\n \t     is present.  */\n-\t  temp = find_reg_note (p, REG_EQUIV, 0);\n+\t  temp = find_reg_note (p, REG_EQUIV, NULL_RTX);\n \t  if (temp)\n \t    src = XEXP (temp, 0), move_insn = 1;\n \t  else \n \t    {\n-\t      temp = find_reg_note (p, REG_EQUAL, 0);\n+\t      temp = find_reg_note (p, REG_EQUAL, NULL_RTX);\n \t      if (temp && CONSTANT_P (XEXP (temp, 0)))\n \t\tsrc = XEXP (temp, 0), move_insn = 1;\n-\t      if (temp && find_reg_note (p, REG_RETVAL, 0))\n+\t      if (temp && find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\t{\n \t\t  src = XEXP (temp, 0);\n \t\t  /* A libcall block can use regs that don't appear in\n@@ -736,7 +733,7 @@ scan_loop (loop_start, end, nregs)\n \t\t      == INSN_UID (reg_single_usage[regno]))\n \t\t  && n_times_set[REGNO (SET_DEST (set))] == 1\n \t\t  && ! side_effects_p (SET_SRC (set))\n-\t\t  && ! find_reg_note (p, REG_RETVAL, 0)\n+\t\t  && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n #ifdef SMALL_REGISTER_CLASSES\n \t\t  && ! (GET_CODE (SET_SRC (set)) == REG\n \t\t\t&& REGNO (SET_SRC (set)) < FIRST_PSEUDO_REGISTER)\n@@ -773,7 +770,7 @@ scan_loop (loop_start, end, nregs)\n \t      m->forces = 0;\n \t      m->partial = 0;\n \t      m->move_insn = move_insn;\n-\t      m->is_equiv = (find_reg_note (p, REG_EQUIV, 0) != 0);\n+\t      m->is_equiv = (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n \t      m->savemode = VOIDmode;\n \t      m->regno = regno;\n \t      /* Set M->cond if either invariant_p or consec_sets_invariant_p\n@@ -785,7 +782,7 @@ scan_loop (loop_start, end, nregs)\n \t      m->lifetime = (uid_luid[regno_last_uid[regno]]\n \t\t\t     - uid_luid[regno_first_uid[regno]]);\n \t      m->savings = n_times_used[regno];\n-\t      if (find_reg_note (p, REG_RETVAL, 0))\n+\t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n \t      n_times_set[regno] = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n@@ -807,19 +804,19 @@ scan_loop (loop_start, end, nregs)\n \t\t  /* We must now reset m->move_insn, m->is_equiv, and possibly\n \t\t     m->set_src to correspond to the effects of all the\n \t\t     insns.  */\n-\t\t  temp = find_reg_note (p, REG_EQUIV, 0);\n+\t\t  temp = find_reg_note (p, REG_EQUIV, NULL_RTX);\n \t\t  if (temp)\n \t\t    m->set_src = XEXP (temp, 0), m->move_insn = 1;\n \t\t  else\n \t\t    {\n-\t\t      temp = find_reg_note (p, REG_EQUAL, 0);\n+\t\t      temp = find_reg_note (p, REG_EQUAL, NULL_RTX);\n \t\t      if (temp && CONSTANT_P (XEXP (temp, 0)))\n \t\t\tm->set_src = XEXP (temp, 0), m->move_insn = 1;\n \t\t      else\n \t\t\tm->move_insn = 0;\n \n \t\t    }\n-\t\t  m->is_equiv = (find_reg_note (p, REG_EQUIV, 0) != 0);\n+\t\t  m->is_equiv = (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n \t\t}\n \t    }\n \t  /* If this register is always set within a STRICT_LOW_PART\n@@ -1025,7 +1022,7 @@ static rtx\n libcall_other_reg (insn, equiv)\n      rtx insn, equiv;\n {\n-  rtx note = find_reg_note (insn, REG_RETVAL, 0);\n+  rtx note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n   rtx p = XEXP (note, 0);\n   rtx output = 0;\n \n@@ -1100,7 +1097,7 @@ libcall_benefit (last)\n   rtx insn;\n   int benefit = 0;\n \n-  for (insn = XEXP (find_reg_note (last, REG_RETVAL, 0), 0);\n+  for (insn = XEXP (find_reg_note (last, REG_RETVAL, NULL_RTX), 0);\n        insn != last; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == CALL_INSN)\n@@ -1130,7 +1127,7 @@ skip_consec_insns (insn, count)\n       /* Do this at start of loop, since INSN is guaranteed to \n \t be an insn here.  */\n       if (GET_CODE (insn) != NOTE\n-\t  && (temp = find_reg_note (insn, REG_LIBCALL, 0)))\n+\t  && (temp = find_reg_note (insn, REG_LIBCALL, NULL_RTX)))\n \tinsn = XEXP (temp, 0);\n \n       do insn = NEXT_INSN (insn);\n@@ -1154,7 +1151,7 @@ ignore_some_movables (movables)\n   for (m = movables; m; m = m->next)\n     {\n       /* Is this a movable for the value of a libcall?  */\n-      rtx note = find_reg_note (m->insn, REG_RETVAL, 0);\n+      rtx note = find_reg_note (m->insn, REG_RETVAL, NULL_RTX);\n       if (note)\n \t{\n \t  rtx insn;\n@@ -1418,6 +1415,11 @@ rtx_equal_for_loop_p (x, y, movables)\n     {\n       switch (fmt[i])\n \t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))\n \t    return 0;\n@@ -1652,14 +1654,14 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t      /* If this is the first insn of a library call sequence,\n \t\t\t skip to the end.  */\n \t\t      if (GET_CODE (p) != NOTE\n-\t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, 0)))\n+\t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n \t\t\tp = XEXP (temp, 0);\n \n \t\t      /* If this is the last insn of a libcall sequence, then\n \t\t\t delete every insn in the sequence except the last.\n \t\t\t The last insn is handled in the normal manner.  */\n \t\t      if (GET_CODE (p) != NOTE\n-\t\t\t  && (temp = find_reg_note (p, REG_RETVAL, 0)))\n+\t\t\t  && (temp = find_reg_note (p, REG_RETVAL, NULL_RTX)))\n \t\t\t{\n \t\t\t  temp = XEXP (temp, 0);\n \t\t\t  while (temp != p)\n@@ -1677,7 +1679,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t  add_label_notes (m->set_src, temp);\n \n \t\t  i1 = emit_insns_before (temp, loop_start);\n-\t\t  if (! find_reg_note (i1, REG_EQUAL, 0))\n+\t\t  if (! find_reg_note (i1, REG_EQUAL, NULL_RTX))\n \t\t    REG_NOTES (i1)\n \t\t      = gen_rtx (EXPR_LIST,\n \t\t\t\t m->is_equiv ? REG_EQUIV : REG_EQUAL,\n@@ -1699,14 +1701,14 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t      /* Do this at start of loop, since p is guaranteed to \n \t\t\t be an insn here.  */\n \t\t      if (GET_CODE (p) != NOTE\n-\t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, 0)))\n+\t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n \t\t\tp = XEXP (temp, 0);\n \n \t\t      /* If last insn of libcall sequence, move all\n \t\t\t insns except the last before the loop.  The last\n \t\t\t insn is handled in the normal manner.  */\n \t\t      if (GET_CODE (p) != NOTE\n-\t\t\t  && (temp = find_reg_note (p, REG_RETVAL, 0)))\n+\t\t\t  && (temp = find_reg_note (p, REG_RETVAL, NULL_RTX)))\n \t\t\t{\n \t\t\t  rtx fn_address = 0;\n \t\t\t  rtx fn_reg = 0;\n@@ -1748,7 +1750,8 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t\t      if (GET_CODE (next) == CALL_INSN\n \t\t\t\t  && GET_CODE (body) == SET\n \t\t\t\t  && GET_CODE (SET_DEST (body)) == REG\n-\t\t\t\t  && (n = find_reg_note (temp, REG_EQUAL, 0)))\n+\t\t\t\t  && (n = find_reg_note (temp, REG_EQUAL,\n+\t\t\t\t\t\t\t NULL_RTX)))\n \t\t\t\t{\n \t\t\t\t  fn_reg = SET_SRC (body);\n \t\t\t\t  if (GET_CODE (fn_reg) != REG)\n@@ -1790,8 +1793,8 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t\t  start_sequence ();\n \t\t\t  tem = expand_binop\n \t\t\t    (GET_MODE (reg), and_optab, reg,\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t      ((1 << GET_MODE_BITSIZE (m->savemode)))\n+\t\t\t     GEN_INT ((((HOST_WIDE_INT) 1\n+\t\t\t\t\t<< GET_MODE_BITSIZE (m->savemode)))\n \t\t\t\t      - 1),\n \t\t\t     reg, 1, OPTAB_LIB_WIDEN);\n \t\t\t  if (tem == 0)\n@@ -1832,10 +1835,10 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t      /* If library call, now fix the REG_NOTES that contain\n \t\t\t insn pointers, namely REG_LIBCALL on FIRST\n \t\t\t and REG_RETVAL on I1.  */\n-\t\t      if (temp = find_reg_note (i1, REG_RETVAL, 0))\n+\t\t      if (temp = find_reg_note (i1, REG_RETVAL, NULL_RTX))\n \t\t\t{\n \t\t\t  XEXP (temp, 0) = first;\n-\t\t\t  temp = find_reg_note (first, REG_LIBCALL, 0);\n+\t\t\t  temp = find_reg_note (first, REG_LIBCALL, NULL_RTX);\n \t\t\t  XEXP (temp, 0) = i1;\n \t\t\t}\n \n@@ -1898,7 +1901,8 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \n \t\t      /* if library call, delete all insn except last, which\n \t\t\t is deleted below */\n-\t\t      if (temp = find_reg_note (m1->insn, REG_RETVAL, 0))\n+\t\t      if (temp = find_reg_note (m1->insn, REG_RETVAL,\n+\t\t\t\t\t\tNULL_RTX))\n \t\t\t{\n \t\t\t  for (temp = XEXP (temp, 0); temp != m1->insn;\n \t\t\t       temp = NEXT_INSN (temp))\n@@ -2662,9 +2666,9 @@ int\n addr_overlap_p (other, base, size)\n      rtx other;\n      rtx base;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n-  int start = 0, end;\n+  HOST_WIDE_INT start = 0, end;\n \n   if (GET_CODE (base) == CONST)\n     base = XEXP (base, 0);\n@@ -2718,7 +2722,7 @@ consec_sets_invariant_p (reg, n_sets, insn)\n       code = GET_CODE (p);\n \n       /* If library call, skip to end of of it.  */\n-      if (code == INSN && (temp = find_reg_note (p, REG_LIBCALL, 0)))\n+      if (code == INSN && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n \tp = XEXP (temp, 0);\n \n       this = 0;\n@@ -2730,7 +2734,7 @@ consec_sets_invariant_p (reg, n_sets, insn)\n \t  this = invariant_p (SET_SRC (set));\n \t  if (this != 0)\n \t    value |= this;\n-\t  else if (temp = find_reg_note (p, REG_EQUAL, 0))\n+\t  else if (temp = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t    {\n \t      this = invariant_p (XEXP (temp, 0));\n \t      if (this != 0)\n@@ -3416,7 +3420,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t\t\t\t\t &src_reg, &add_val,\n \t\t\t\t\t\t &mult_val))\n \t       /* Equivalent expression is a giv. */\n-\t       || ((regnote = find_reg_note (p, REG_EQUAL, 0))\n+\t       || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t\t   && (benefit = general_induction_var (XEXP (regnote, 0),\n \t\t\t\t\t\t\t&src_reg,\n \t\t\t\t\t\t\t&add_val, &mult_val))))\n@@ -3438,7 +3442,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      rtx temp;\n \n \t      /* If this is a library call, increase benefit.  */\n-\t      if (find_reg_note (p, REG_RETVAL, 0))\n+\t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tbenefit += libcall_benefit (p);\n \n \t      /* Skip the consecutive insns, if there are any.  */\n@@ -3449,15 +3453,15 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t     Do this at start of loop, since INSN is guaranteed to\n \t\t     be an insn here.  */\n \t\t  if (GET_CODE (p) != NOTE\n-\t\t      && (temp = find_reg_note (p, REG_LIBCALL, 0)))\n+\t\t      && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n \t\t    p = XEXP (temp, 0);\n \n \t\t  do p = NEXT_INSN (p);\n \t\t  while (GET_CODE (p) == NOTE);\n \t\t}\n \n \t      record_giv (v, p, src_reg, dest_reg, mult_val, add_val, benefit,\n-\t\t\t  DEST_REG, not_every_iteration, 0, loop_start,\n+\t\t\t  DEST_REG, not_every_iteration, NULL_PTR, loop_start,\n \t\t\t  loop_end);\n \n \t    }\n@@ -4681,8 +4685,7 @@ basic_induction_var (x, dest_reg, inc_val, mult_val)\n     case MINUS:\n       if (XEXP (x, 0) == dest_reg\n  \t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n- \t*inc_val = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t    - INTVAL (XEXP (x, 1)));\n+ \t*inc_val = GEN_INT (- INTVAL (XEXP (x, 1)));\n       else\n  \treturn 0;\n \n@@ -4847,7 +4850,7 @@ simplify_giv_expr (x, benefit)\n      mode, this can't be a giv.  */\n   if (mode != VOIDmode\n       && (GET_MODE_CLASS (mode) != MODE_INT\n-\t  || GET_MODE_BITSIZE (mode) > HOST_BITS_PER_INT))\n+\t  || GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT))\n     return 0;\n \n   switch (GET_CODE (x))\n@@ -4943,9 +4946,7 @@ simplify_giv_expr (x, benefit)\n       return simplify_giv_expr (gen_rtx (PLUS, mode,\n \t\t\t\t\t XEXP (x, 0),\n \t\t\t\t\t gen_rtx (MULT, mode,\n-\t\t\t\t\t\t  XEXP (x, 1),\n-\t\t\t\t\t\t  gen_rtx (CONST_INT,\n-\t\t\t\t\t\t\t   VOIDmode, -1))),\n+\t\t\t\t\t\t  XEXP (x, 1), constm1_rtx)),\n \t\t\t\tbenefit);\n \n     case MULT:\n@@ -4978,7 +4979,7 @@ simplify_giv_expr (x, benefit)\n \n \tcase CONST_INT:\n \t  /* Product of two constants.  */\n-\t  return gen_rtx (CONST_INT, mode, INTVAL (arg0) * INTVAL (arg1));\n+\t  return GEN_INT (INTVAL (arg0) * INTVAL (arg1));\n \n \tcase USE:\n \t  /* invar * invar.  Not giv. */\n@@ -5013,15 +5014,13 @@ simplify_giv_expr (x, benefit)\n \n       return simplify_giv_expr (gen_rtx (MULT, mode,\n \t\t\t\t\t XEXP (x, 0),\n-\t\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t  1 << INTVAL (XEXP (x, 1)))),\n+\t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t\t  << INTVAL (XEXP (x, 1)))),\n \t\t\t\tbenefit);\n \n     case NEG:\n       /* \"-a\" is \"a * (-1)\" */\n-      return simplify_giv_expr (gen_rtx (MULT, mode,\n-\t\t\t\t\t XEXP (x, 0),\n-\t\t\t\t\t gen_rtx (CONST_INT, VOIDmode, -1)),\n+      return simplify_giv_expr (gen_rtx (MULT, mode, XEXP (x, 0), constm1_rtx),\n \t\t\t\tbenefit);\n \n     case NOT:\n@@ -5145,7 +5144,7 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n       code = GET_CODE (p);\n \n       /* If libcall, skip to end of call sequence.  */\n-      if (code == INSN && (temp = find_reg_note (p, REG_LIBCALL, 0)))\n+      if (code == INSN && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n \tp = XEXP (temp, 0);\n \n       if (code == INSN\n@@ -5155,12 +5154,12 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n \t  && ((benefit = general_induction_var (SET_SRC (set), &src_reg,\n \t\t\t\t\t\tadd_val, mult_val))\n \t      /* Giv created by equivalent expression.  */\n-\t      || ((temp = find_reg_note (p, REG_EQUAL, 0))\n+\t      || ((temp = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t\t  && (benefit = general_induction_var (XEXP (temp, 0), &src_reg,\n \t\t\t\t\t\t       add_val, mult_val))))\n \t  && src_reg == v->src_reg)\n \t{\n-\t  if (find_reg_note (p, REG_RETVAL, 0))\n+\t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t    benefit += libcall_benefit (p);\n \n \t  count--;\n@@ -5215,8 +5214,7 @@ express_from (g1, g2)\n       || INTVAL (g2->mult_val) % INTVAL (g1->mult_val) != 0)\n     return 0;\n \n-  mult = gen_rtx (CONST_INT, VOIDmode,\n-\t\t  INTVAL (g2->mult_val) / INTVAL (g1->mult_val));\n+  mult = GEN_INT (INTVAL (g2->mult_val) / INTVAL (g1->mult_val));\n   add = plus_constant (g2->add_val, - INTVAL (g1->add_val) * INTVAL (mult));\n \n   /* Form simplified final result.  */\n@@ -5378,7 +5376,7 @@ product_cheap_p (a, b)\n \n   rtl_obstack = &temp_obstack;\n   start_sequence ();\n-  expand_mult (GET_MODE (a), a, b, 0, 0);\n+  expand_mult (GET_MODE (a), a, b, NULL_RTX, 0);\n   tmp = gen_sequence ();\n   end_sequence ();\n \n@@ -5500,7 +5498,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t{\n \t  /* register always nonnegative, add REG_NOTE to branch */\n \t  REG_NOTES (PREV_INSN (loop_end))\n-\t    = gen_rtx (EXPR_LIST, REG_NONNEG, 0,\n+\t    = gen_rtx (EXPR_LIST, REG_NONNEG, NULL_RTX,\n \t\t       REG_NOTES (PREV_INSN (loop_end)));\n \t  bl->nonneg = 1;\n \n@@ -5525,7 +5523,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t      && INTVAL (bl->biv->add_val) == -1)\n \t    {\n \t      REG_NOTES (PREV_INSN (loop_end))\n-\t\t= gen_rtx (EXPR_LIST, REG_NONNEG, 0,\n+\t\t= gen_rtx (EXPR_LIST, REG_NONNEG, NULL_RTX,\n \t\t\t   REG_NOTES (PREV_INSN (loop_end)));\n \t      bl->nonneg = 1;\n \n@@ -5623,13 +5621,11 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t      /* Save some info needed to produce the new insns.  */\n \t      reg = bl->biv->dest_reg;\n \t      jump_label = XEXP (SET_SRC (PATTERN (PREV_INSN (loop_end))), 1);\n-\t      new_add_val = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t     - INTVAL (bl->biv->add_val));\n+\t      new_add_val = GEN_INT (- INTVAL (bl->biv->add_val));\n \n \t      final_value = XEXP (comparison, 1);\n-\t      start_value = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t     (INTVAL (XEXP (comparison, 1))\n-\t\t\t\t      - INTVAL (bl->biv->add_val)));\n+\t      start_value = GEN_INT (INTVAL (XEXP (comparison, 1))\n+\t\t\t\t     - INTVAL (bl->biv->add_val));\n \n \t      /* Initialize biv to start_value before loop start.\n \t\t The old initializing insn will be deleted as a\n@@ -5666,7 +5662,8 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \n \t      /* Add new compare/branch insn at end of loop.  */\n \t      start_sequence ();\n-\t      emit_cmp_insn (reg, const0_rtx, GE, 0, GET_MODE (reg), 0, 0);\n+\t      emit_cmp_insn (reg, const0_rtx, GE, NULL_RTX,\n+\t\t\t     GET_MODE (reg), 0, 0);\n \t      emit_jump_insn (gen_bge (XEXP (jump_label, 0)));\n \t      tem = gen_sequence ();\n \t      end_sequence ();\n@@ -5682,7 +5679,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t\t  /* Increment of LABEL_NUSES done above. */\n \t\t  /* Register is now always nonnegative,\n \t\t     so add REG_NONNEG note to the branch.  */\n-\t\t  REG_NOTES (tem) = gen_rtx (EXPR_LIST, REG_NONNEG, 0,\n+\t\t  REG_NOTES (tem) = gen_rtx (EXPR_LIST, REG_NONNEG, NULL_RTX,\n \t\t\t\t\t     REG_NOTES (tem));\n \t\t}\n \n@@ -5913,10 +5910,9 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t    && GET_CODE (v->mult_val) == CONST_INT\n \t\t    && GET_CODE (v->add_val) == CONST_INT\n \t\t    && validate_change (insn, &XEXP (x, arg_operand),\n-\t\t\t\t\tgen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t (INTVAL (arg)\n-\t\t\t\t\t\t  * INTVAL (v->mult_val)\n-\t\t\t\t\t\t  + INTVAL (v->add_val))), 0))\n+\t\t\t\t\tGEN_INT (INTVAL (arg)\n+\t\t\t\t\t\t * INTVAL (v->mult_val)\n+\t\t\t\t\t\t + INTVAL (v->add_val)), 0))\n \t\t  return 1;\n \n \t\t/* Otherwise, load it into a register.  */\n@@ -6255,9 +6251,11 @@ get_condition (jump, earliest)\n \t       || (((code == NE\n \t\t     || (code == LT\n \t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t && GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_INT\n+\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n \t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & (1 << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == LT\n \t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n@@ -6268,10 +6266,12 @@ get_condition (jump, earliest)\n \t    x = SET_SRC (set);\n \t  else if (((code == EQ\n \t\t     || (code == GE\n-\t\t\t && GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_INT\n+\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n \t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n \t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & (1 << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == GE\n \t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n@@ -6322,29 +6322,29 @@ get_condition (jump, earliest)\n   /* Canonicalize any ordered comparison with integers involving equality.  */\n   if (GET_CODE (op1) == CONST_INT)\n     {\n-      int const_val = INTVAL (op1);\n-      unsigned uconst_val = (unsigned) const_val;\n+      HOST_WIDE_INT const_val = INTVAL (op1);\n+      unsigned HOST_WIDE_INT uconst_val = const_val;\n \n       switch (code)\n       {\n       case LE:\n \tcode = LT;\n-\top1 = gen_rtx (CONST_INT, VOIDmode, const_val + 1);\n+\top1 = GEN_INT (const_val + 1);\n \tbreak;\n \n       case GE:\n \tcode = GT;\n-\top1 = gen_rtx (CONST_INT, VOIDmode, const_val - 1);\n+\top1 = GEN_INT (const_val - 1);\n \tbreak;\n \n       case LEU:\n \tcode = LTU;\n-\top1 = gen_rtx (CONST_INT, VOIDmode, uconst_val + 1);\n+\top1 = GEN_INT (uconst_val + 1);\n \tbreak;\n \n       case GEU:\n \tcode = GTU;\n-\top1 = gen_rtx (CONST_INT, VOIDmode, uconst_val - 1);\n+\top1 = GEN_INT (uconst_val - 1);\n \tbreak;\n       }\n     }\n@@ -6372,7 +6372,7 @@ rtx\n get_condition_for_loop (x)\n      rtx x;\n {\n-  rtx comparison = get_condition (x, 0);\n+  rtx comparison = get_condition (x, NULL_PTR);\n \n   if (comparison == 0\n       || ! invariant_p (XEXP (comparison, 0))"}]}