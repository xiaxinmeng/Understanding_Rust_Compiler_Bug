{"sha": "e8226879d081098068ec39a204094449e38f3595", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgyMjY4NzlkMDgxMDk4MDY4ZWMzOWEyMDQwOTQ0NDllMzhmMzU5NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-09-27T17:18:25Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-09-27T17:18:25Z"}, "message": "re PR rtl-optimization/12340 (loop unroller + gcse produces wrong code)\n\n\tPR optimization/12340\n\t* loop.h (struct induction): Document the new semantics\n\tof the 'same' field for bivs.\n\t* unroll.c (biv_total_increment): Don't count the same\n\tbiv increment several times.\n\t(loop_iterations) [GENERAL_INDUCT]: Likewise.\n\nFrom-SVN: r71859", "tree": {"sha": "69c65bf4228b0815d726602917430e7ecd31d590", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69c65bf4228b0815d726602917430e7ecd31d590"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8226879d081098068ec39a204094449e38f3595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8226879d081098068ec39a204094449e38f3595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8226879d081098068ec39a204094449e38f3595", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8226879d081098068ec39a204094449e38f3595/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c003e212ead438407d7968c2ada135f90307a8be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c003e212ead438407d7968c2ada135f90307a8be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c003e212ead438407d7968c2ada135f90307a8be"}], "stats": {"total": 452, "additions": 448, "deletions": 4}, "files": [{"sha": "4b65850501d65c5a4fd5a03e796efa6de1b4ad7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8226879d081098068ec39a204094449e38f3595/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8226879d081098068ec39a204094449e38f3595/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8226879d081098068ec39a204094449e38f3595", "patch": "@@ -1,3 +1,12 @@\n+2003-09-27  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR optimization/12340\n+\t* loop.h (struct induction): Document the new semantics\n+\tof the 'same' field for bivs.\n+\t* unroll.c (biv_total_increment): Don't count the same\n+\tbiv increment several times.\n+\t(loop_iterations) [GENERAL_INDUCT]: Likewise.\n+\n 2003-09-27  Graham Stott  <graham.stott@btinternet.com>\n \n \t* unroll.c (loop_interations)[GT]: Add missing break."}, {"sha": "2a7f3ec816e1a60ebd1eb1256e36b4d29cea3375", "filename": "gcc/loop.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8226879d081098068ec39a204094449e38f3595/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8226879d081098068ec39a204094449e38f3595/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=e8226879d081098068ec39a204094449e38f3595", "patch": "@@ -148,9 +148,12 @@ struct induction\n \t\t\t\t   based on the same biv.  For bivs, links\n \t\t\t\t   together all biv entries that refer to the\n \t\t\t\t   same biv register.  */\n-  struct induction *same;\t/* If this giv has been combined with another\n-\t\t\t\t   giv, this points to the base giv.  The base\n-\t\t\t\t   giv will have COMBINED_WITH nonzero.  */\n+  struct induction *same;\t/* For givs, if the giv has been combined with\n+\t\t\t\t   another giv, this points to the base giv.\n+\t\t\t\t   The base giv will have COMBINED_WITH nonzero.\n+\t\t\t\t   For bivs, if the biv has the same LOCATION\n+\t\t\t\t   than another biv, this points to the base\n+\t\t\t\t   biv.  */\n   HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n \t\t\t\t   is split, and a constant is eliminated from\n \t\t\t\t   the address, the -constant is stored here"}, {"sha": "143877566619b9a5f0927ef28de7a452545783e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8226879d081098068ec39a204094449e38f3595/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8226879d081098068ec39a204094449e38f3595/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8226879d081098068ec39a204094449e38f3595", "patch": "@@ -1,3 +1,7 @@\n+2003-09-27  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* g++.dg/opt/unroll1.C: New test.\n+\n 2003-09-26  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/11741"}, {"sha": "6b2196d098779c1939f9220bb9cd2265dd553a6d", "filename": "gcc/testsuite/g++.dg/opt/unroll1.C", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8226879d081098068ec39a204094449e38f3595/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Funroll1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8226879d081098068ec39a204094449e38f3595/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Funroll1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Funroll1.C?ref=e8226879d081098068ec39a204094449e38f3595", "patch": "@@ -0,0 +1,418 @@\n+// PR optimization/12340\n+// Origin: Richard Guenther <richard.guenther@uni-tuebingen.de>\n+// Testcase by Eric Botcazou <ebotcazou@libertysurf.fr>\n+\n+// This used to segfault on x86 because the loop optimizer wrongly\n+// interpreted a double assignment to a biv as a double increment,\n+// which subsequently fooled the unroller.\n+\n+// { dg-do run }\n+// { dg-options \"-O2 -fno-exceptions -funroll-loops\" }\n+\n+inline void* operator new(unsigned int, void* __p) throw() { return __p; }\n+inline void operator delete (void*, void*) throw() { };\n+\n+class Loc;\n+class Interval;\n+\n+template<class DT>\n+class DomainBase\n+{\n+public:\n+  typedef typename DT::Domain_t Domain_t;\n+  typedef typename DT::Storage_t Storage_t;\n+\n+  Domain_t &unwrap() { return *static_cast<Domain_t *>(this); }\n+\n+  const Domain_t &unwrap() const {\n+    return *static_cast<Domain_t *>(const_cast<DomainBase<DT> *>(this));\n+  }\n+\n+protected:\n+  Storage_t domain_m;\n+};\n+\n+template<class DT>\n+class Domain : public DomainBase<DT>\n+{\n+  typedef DomainBase<DT> Base_t;\n+\n+public:\n+  typedef typename DT::Size_t Size_t;\n+  typedef typename DT::Element_t Element_t;\n+  typedef typename Base_t::Domain_t Domain_t;\n+  typedef typename Base_t::Storage_t Storage_t;\n+\n+  Domain_t &operator[](int) { return this->unwrap(); }\n+\n+  const Domain_t &operator[](int) const { return this->unwrap(); }\n+\n+  template<class T>\n+  void setDomain(const T &newdom) {\n+    DT::setDomain(this->domain_m, newdom);\n+  }\n+\n+  Element_t first() const { return DT::first(this->domain_m); }\n+\n+  Size_t length() const { return DT::length(this->domain_m); }\n+\n+  Size_t size() const { return length(); }\n+};\n+\n+template<class T>\n+struct DomainTraits;\n+\n+template<>\n+struct DomainTraits<Interval>\n+{\n+  typedef int Size_t;\n+  typedef int Element_t;\n+  typedef Interval Domain_t;\n+  typedef Interval OneDomain_t;\n+  typedef Loc AskDomain_t;\n+  typedef int Storage_t[2];\n+  enum { dimensions = 1 };\n+  enum { wildcard = false };\n+\n+  static int first(const Storage_t &d) { return d[0]; }\n+\n+  static int length(const Storage_t &d) { return d[1]; }\n+\n+  static OneDomain_t &getDomain(Domain_t &d, int) { return d; }\n+\n+  static const OneDomain_t &getDomain(const Domain_t &d, int) { return d; }\n+\n+  template<class T>\n+  static void setDomain(Storage_t &dom, const T &newdom) {\n+    dom[0] = newdom.first();  \n+    dom[1] = newdom.length();\n+  }\n+\n+  template<class T1, class T2>\n+  static void setDomain(Storage_t &dom, const T1 &begval, const T2 &endval) {\n+    dom[0] = begval;\n+    dom[1] = (endval - begval + 1);\n+  }\n+\n+};\n+\n+class Interval : public Domain<DomainTraits<Interval> >\n+{\n+public:\n+  Interval(const Interval &a) : Domain<DomainTraits<Interval> >() {    \n+    for (int i=0; i < DomainTraits<Interval>::dimensions; ++i)\n+      DomainTraits<Interval>::getDomain(*this, i).setDomain(\n+                                DomainTraits<Interval>::getDomain(a, i));\n+  }\n+\n+  Interval(int a) : Domain<DomainTraits<Interval> >()\n+  {\n+    DomainTraits<Interval>::setDomain(domain_m, 0, a - 1);\n+  }\n+};\n+\n+template<>\n+struct DomainTraits<Loc>\n+{\n+  typedef int Size_t;\n+  typedef int Element_t;\n+  typedef Loc Domain_t;\n+  typedef Loc AskDomain_t;\n+  typedef Loc MultResult_t;\n+  typedef int Storage_t;\n+\n+  static int first(int d) { return d; }\n+\n+  template<class T>\n+  static void setDomain(int &dom, const T &newdom) {\n+    dom = DomainTraits<T>::getFirst(newdom);\n+  }\n+};\n+\n+template<>\n+struct DomainTraits<int>\n+ {\n+  enum { dimensions = 1 };\n+  enum { wildcard = false };\n+\n+  static int getPointDomain(int d, int) { return d; }\n+\n+  static int getFirst(const int &d) { return d; }\n+};\n+\n+class Loc : public Domain<DomainTraits<Loc> >\n+{\n+public:\n+  explicit Loc(const int &a) : Domain<DomainTraits<Loc> >() {\n+    for (int i=0; i < 1; ++i)\n+      (*this)[i].setDomain(DomainTraits<int>::getPointDomain(a, 0));\n+  }\n+};\n+\n+struct ElementProperties\n+{\n+  enum { hasTrivialDefaultConstructor = false };\n+  enum { hasTrivialDestructor = false };\n+\n+  static void construct(double* addr)\n+  {\n+    new (addr) double();\n+  }\n+\n+  static void construct(double* addr, const double& model)\n+  {\n+    new (addr) double(model);\n+  }\n+\n+  static void destruct(double *addr) {}\n+};\n+\n+class RefCounted\n+{\n+public:\n+  RefCounted() : count_m(0) {}\n+\n+  void addReference() { ++count_m; }\n+  bool removeRefAndCheckGarbage()\n+  {\n+    return (--count_m == 0);\n+  }\n+\n+private:\n+  int count_m;\n+};\n+\n+class RefBlockController : public RefCounted\n+{\n+public:\n+  explicit RefBlockController(unsigned int size)\n+    : pBegin_m(0), pEnd_m(0), pEndOfStorage_m(0), dealloc_m(false)\n+  {\n+    reallocateStorage(size, false);\n+\n+    if (!ElementProperties::hasTrivialDefaultConstructor)\n+      {\n+        for (double * pt = begin(); pt != end(); ++pt)\n+          ElementProperties::construct(pt);\n+      }\n+  }\n+  \n+  ~RefBlockController()\n+  {\n+    deleteStorage();\n+  }\n+\n+  double *begin() const\n+  {\n+    return pBegin_m;\n+  }\n+\n+  double *end() const\n+  {\n+    return pEnd_m;\n+  }\n+\n+  bool isMine() const\n+  {\n+    return dealloc_m;\n+  }\n+\n+private:\n+  void deleteStorage()\n+  {\n+    if (isMine() && pBegin_m != 0)\n+      {\n+        if (!ElementProperties::hasTrivialDestructor)\n+          for (double *pt = begin(); pt != end(); ++pt)\n+            ElementProperties::destruct(pt);\n+\n+        char *tmp = reinterpret_cast<char *>(pBegin_m);\n+        delete [] tmp;\n+      }\n+  }\n+\n+  void reallocateStorage(unsigned int newsize, bool copyold = false)\n+  {\n+    double *pBeginNew = 0;\n+    double *pEndNew = 0;\n+    double *pEndOfStorageNew = 0;\n+\n+    if (newsize > 0)\n+      {\n+        int nsize = newsize * sizeof(double);\n+        char *tmp = new char[nsize];\n+        pBeginNew = reinterpret_cast<double *>(tmp);\n+        pEndNew = pBeginNew + newsize;\n+        pEndOfStorageNew = pBeginNew + (nsize / sizeof(double));\n+\n+        if (copyold)\n+          {\n+            double * pOld = begin();\n+            double * pNew = pBeginNew;\n+            while (pOld != end() && pNew != pEndNew)\n+              ElementProperties::construct(pNew++,*pOld++);\n+          }\n+      }\n+\n+    deleteStorage();\n+\n+    pBegin_m = pBeginNew;\n+    pEnd_m = pEndNew;\n+    pEndOfStorage_m = pEndOfStorageNew;\n+    dealloc_m = true;\n+  }\n+\n+  double *pBegin_m;\n+  double *pEnd_m;\n+  double *pEndOfStorage_m;\n+  bool dealloc_m;\n+};\n+\n+class DataBlockController : public RefBlockController\n+{\n+public:\n+  explicit\n+  DataBlockController(unsigned int size)\n+    : RefBlockController(size), dataObjectPtr_m(new char), owned_m(true) {}\n+\n+  ~DataBlockController()\n+  {\n+    if (owned_m) delete dataObjectPtr_m;\n+  }\n+\n+private:\n+  mutable char *dataObjectPtr_m;\n+  bool owned_m;\n+};\n+\n+class RefCountedPtr\n+{\n+public:\n+  RefCountedPtr(DataBlockController * const pT) : ptr_m(pT)\n+    { if (isValid()) ptr_m->addReference(); }\n+\n+  ~RefCountedPtr() { invalidate(); }\n+\n+  DataBlockController* operator->() const { return ptr_m; }\n+  void invalidate();\n+  bool isValid() const { return ptr_m != 0; }\n+\n+private:\n+  friend class RefCountedBlockPtr;\n+  DataBlockController * ptr_m;\n+};\n+\n+inline void RefCountedPtr::invalidate()\n+{\n+  if ( isValid() && ptr_m->removeRefAndCheckGarbage() )\n+    delete ptr_m;\n+  ptr_m = 0;\n+}\n+\n+class RefCountedBlockPtr\n+{\n+public:\n+  explicit RefCountedBlockPtr(unsigned int size)\n+    : offset_m(0),\n+      blockControllerPtr_m(new DataBlockController(size)) {}\n+\n+  int offset() const\n+  {\n+    return offset_m;\n+  }\n+\n+  double *beginPointer() const\n+  {\n+    return blockControllerPtr_m->begin();\n+  }\n+\n+  double *currentPointer() const\n+  {\n+    return beginPointer() + offset();\n+  }\n+\n+protected:\n+  int offset_m;\n+  RefCountedPtr blockControllerPtr_m;\n+};\n+\n+class DataBlockPtr : public RefCountedBlockPtr\n+{\n+public:\n+  explicit DataBlockPtr(unsigned int size) : RefCountedBlockPtr(size) {}\n+};\n+\n+class Node\n+{\n+public:\n+  Node(const Interval &owned, const Interval &allocated)\n+    : domain_m(owned), allocated_m(allocated) {}\n+\n+  const Interval &allocated() const { return allocated_m; }\n+\n+private:\n+  Interval domain_m;\n+  Interval allocated_m;\n+};\n+\n+class DomainLayout\n+{\n+public:\n+  explicit DomainLayout(const Interval &dom) : node_m(0, dom) {}\n+\n+  const Interval &domain() const\n+  {\n+    return node_m.allocated();\n+  }\n+\n+private:\n+  Node node_m;\n+};\n+\n+class BrickBase\n+{\n+public:\n+  explicit BrickBase(const Interval &domain);\n+\n+  int offset(const Loc &dom) const { return off_m + dom[0].first(); }\n+\n+protected:\n+  DomainLayout layout_m;\n+  int firsts_m;\n+  int off_m;\n+};\n+\n+BrickBase::BrickBase(const Interval &dom)\n+  : layout_m(dom)\n+{\n+  firsts_m = layout_m.domain()[0].first();\n+  off_m = -firsts_m;\n+}\n+\n+class Engine : public BrickBase\n+{\n+public:\n+  explicit Engine(const Interval &dom)\n+  : BrickBase(dom), dataBlock_m(dom.size()), data_m(dataBlock_m.currentPointer()) {}\n+\n+  double& operator()(const Loc &loc) const\n+  {\n+    return data_m[this->offset(loc)];\n+  }\n+\n+private:\n+  DataBlockPtr dataBlock_m;\n+  double *data_m;\n+};\n+\n+\n+int main()\n+{\n+  Interval I(10);\n+  Engine A(I);\n+\n+  for (int i = 0; i < 10; i++)\n+    A(Loc(i)) = 2.0 + i - i*i;\n+\n+  return 0;\n+}"}, {"sha": "38659d461cb80f0b3b9cce2e7a07b6c488b1dd00", "filename": "gcc/unroll.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8226879d081098068ec39a204094449e38f3595/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8226879d081098068ec39a204094449e38f3595/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=e8226879d081098068ec39a204094449e38f3595", "patch": "@@ -2436,7 +2436,13 @@ biv_total_increment (const struct iv_class *bl)\n       if (v->always_computable && v->mult_val == const1_rtx\n \t  && ! v->maybe_multiple\n \t  && SCALAR_INT_MODE_P (v->mode))\n-\tresult = fold_rtx_mult_add (result, const1_rtx, v->add_val, v->mode);\n+\t{\n+\t  /* If we have already counted it, skip it.  */\n+\t  if (v->same)\n+\t    continue;\n+\n+\t  result = fold_rtx_mult_add (result, const1_rtx, v->add_val, v->mode);\n+\t}\n       else\n \treturn 0;\n     }\n@@ -3481,6 +3487,10 @@ loop_iterations (struct loop *loop)\n \t\t\treturn 0;\n \t\t    }\n \n+\t\t  /* If we have already counted it, skip it.  */\n+\t\t  if (biv_inc->same)\n+\t\t    continue;\n+\n \t\t  offset -= INTVAL (biv_inc->add_val);\n \t\t}\n \t    }"}]}