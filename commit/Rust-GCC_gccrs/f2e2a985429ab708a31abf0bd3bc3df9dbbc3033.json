{"sha": "f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJlMmE5ODU0MjlhYjcwOGEzMWFiZjBiZDNiYzNkZjlkYmJjMzAzMw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2015-05-21T14:36:04Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2015-05-21T14:36:04Z"}, "message": "tree-vectorizer.h (struct _stmt_vec_info): Rename stride_load_p to strided_p.\n\n\t* tree-vectorizer.h (struct _stmt_vec_info): Rename stride_load_p\n\tto strided_p.\n\t(STMT_VINFO_STRIDE_LOAD_P): Rename to ...\n\t(STMT_VINFO_STRIDED_P): ... this.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Adjust.\n\t(vect_verify_datarefs_alignment): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_analyze_data_ref_access): Likewise.\n\t(vect_analyze_data_refs): Accept strided stores.\n\t* tree-vect-stmts.c (vect_model_store_cost): Count strided stores.\n\t(vect_model_load_cost): Adjust for macro rename.\n\t(vectorizable_mask_load_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_store): Open code strided stores.\n\ntestsuite/\n\t* gcc.dg/vect/vect-strided-store.c: New test.\n\t* gfortran.dg/vect/fast-math-pr37021.f90: Adjust.\n\t* gfortran.dg/vect/fast-math-rnflow-trs2a2.f90: Adjust.\n\nFrom-SVN: r223486", "tree": {"sha": "0e30ba12cbe5abeb6eff428b7c9e77d9e6a0c97a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e30ba12cbe5abeb6eff428b7c9e77d9e6a0c97a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/comments", "author": null, "committer": null, "parents": [{"sha": "1e43cc9461ba4f73939c94f07d2f5b305943eb29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e43cc9461ba4f73939c94f07d2f5b305943eb29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e43cc9461ba4f73939c94f07d2f5b305943eb29"}], "stats": {"total": 285, "additions": 233, "deletions": 52}, "files": [{"sha": "2474aa10ab000ca133d251269022b4d800917cc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -1,3 +1,20 @@\n+2015-05-08  Michael Matz  <matz@suse.de>\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Rename stride_load_p\n+\tto strided_p.\n+\t(STMT_VINFO_STRIDE_LOAD_P): Rename to ...\n+\t(STMT_VINFO_STRIDED_P): ... this.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Adjust.\n+\t(vect_verify_datarefs_alignment): Likewise.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_analyze_data_ref_access): Likewise.\n+\t(vect_analyze_data_refs): Accept strided stores.\n+\t* tree-vect-stmts.c (vect_model_store_cost): Count strided stores.\n+\t(vect_model_load_cost): Adjust for macro rename.\n+\t(vectorizable_mask_load_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_store): Open code strided stores.\n+\n 2015-05-21  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* doc/sourcebuild.texi (7.2.3.9 Other hardware attributes):"}, {"sha": "46a6bb7ad675f2173217180564bdf9f5a430b49f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -1,3 +1,9 @@\n+2015-05-08  Michael Matz  <matz@suse.de>\n+\n+\t* gcc.dg/vect/vect-strided-store.c: New test.\n+\t* gfortran.dg/vect/fast-math-pr37021.f90: Adjust.\n+\t* gfortran.dg/vect/fast-math-rnflow-trs2a2.f90: Adjust.\n+\n 2015-05-21  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* lib/target-supports.exp (check_effective_target_sqrt_insn): New check.\n@@ -51,7 +57,7 @@\n \n 2015-05-20  Alex Velenko  <Alex.Velenko@arm.com>\n \n-        * gcc.target/arm/thumb1-far-jump-2.c (r4): Added int in definition.\n+\t* gcc.target/arm/thumb1-far-jump-2.c (r4): Added int in definition.\n \n 2015-05-20  David Malcolm  <dmalcolm@redhat.com>\n "}, {"sha": "5014bc7cfcd2c12273020f534d518af8469a7598", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-store.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store.c?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noinline))\n+sumit (float * __restrict dest,\n+       float * __restrict src, float * __restrict src2,\n+       int stride, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    dest[i*stride] = src[i] + src2[i];\n+}\n+\n+int main()\n+{\n+  int i, stride;\n+  float src[] = {1, 2, 3, 4, 5, 6, 7, 8};\n+  float dest[64];\n+  check_vect ();\n+  for (stride = 0; stride < 8; stride++)\n+    {\n+      sumit (dest, src, src, stride, 8);\n+      if (!stride && dest[0] != 16)\n+\tabort();\n+      else if (stride)\n+\tfor (i = 0; i < 8; i++)\n+\t  if (2*src[i] != dest[i*stride])\n+\t    abort ();\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d5f5d40765fc532821609fe0fa752e3d5b7fde83", "filename": "gcc/testsuite/gfortran.dg/vect/fast-math-pr37021.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-pr37021.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-pr37021.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-pr37021.f90?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -14,5 +14,5 @@ subroutine to_product_of(self,a,b,a1,a2)\n   end do\n end subroutine\n \n-! { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } }\n+! { dg-final { scan-tree-dump \"vectorized 2 loops\" \"vect\" } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "625be8390dccdd3efc3811d7eca636bcd186fc33", "filename": "gcc/testsuite/gfortran.dg/vect/fast-math-rnflow-trs2a2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-rnflow-trs2a2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-rnflow-trs2a2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-rnflow-trs2a2.f90?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -29,5 +29,5 @@ function trs2a2 (j, k, u, d, m)\n       return\n       end function trs2a2\n \n-! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } }\n+! { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "3b8405f597cb8c534b754991e1b6ead0a23dd41d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -663,9 +663,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   /* Initialize misalignment to unknown.  */\n   SET_DR_MISALIGNMENT (dr, -1);\n \n-  /* Strided loads perform only component accesses, misalignment information\n+  /* Strided accesses perform only component accesses, misalignment information\n      is irrelevant for them.  */\n-  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info)\n+  if (STMT_VINFO_STRIDED_P (stmt_info)\n       && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return true;\n \n@@ -942,9 +942,9 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n           || !STMT_VINFO_VECTORIZABLE (stmt_info))\n         continue;\n \n-      /* Strided loads perform only component accesses, alignment is\n+      /* Strided accesses perform only component accesses, alignment is\n \t irrelevant for them.  */\n-      if (STMT_VINFO_STRIDE_LOAD_P (stmt_info)\n+      if (STMT_VINFO_STRIDED_P (stmt_info)\n \t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \tcontinue;\n \n@@ -1410,9 +1410,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (integer_zerop (DR_STEP (dr)))\n \tcontinue;\n \n-      /* Strided loads perform only component accesses, alignment is\n+      /* Strided accesses perform only component accesses, alignment is\n \t irrelevant for them.  */\n-      if (STMT_VINFO_STRIDE_LOAD_P (stmt_info)\n+      if (STMT_VINFO_STRIDED_P (stmt_info)\n \t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \tcontinue;\n \n@@ -1703,9 +1703,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n \t    continue;\n \n-\t  /* Strided loads perform only component accesses, alignment is\n+\t  /* Strided accesses perform only component accesses, alignment is\n \t     irrelevant for them.  */\n-\t  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info)\n+\t  if (STMT_VINFO_STRIDED_P (stmt_info)\n \t      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t    continue;\n \n@@ -1824,7 +1824,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t  && GROUP_FIRST_ELEMENT (stmt_info) != stmt))\n \t    continue;\n \n-\t  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+\t  if (STMT_VINFO_STRIDED_P (stmt_info))\n \t    {\n \t      /* Strided loads perform only component accesses, alignment is\n \t\t irrelevant for them.  */\n@@ -2346,7 +2346,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   /* Assume this is a DR handled by non-constant strided load case.  */\n   if (TREE_CODE (step) != INTEGER_CST)\n-    return (STMT_VINFO_STRIDE_LOAD_P (stmt_info)\n+    return (STMT_VINFO_STRIDED_P (stmt_info)\n \t    && (!STMT_VINFO_GROUPED_ACCESS (stmt_info)\n \t\t|| vect_analyze_group_access (dr)));\n \n@@ -3758,8 +3758,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       else if (loop_vinfo\n \t       && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n \t{\n-\t  if (nested_in_vect_loop_p (loop, stmt)\n-\t      || !DR_IS_READ (dr))\n+\t  if (nested_in_vect_loop_p (loop, stmt))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -3771,7 +3770,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t}\n \t      return false;\n \t    }\n-\t  STMT_VINFO_STRIDE_LOAD_P (stmt_info) = true;\n+\t  STMT_VINFO_STRIDED_P (stmt_info) = true;\n \t}\n     }\n "}, {"sha": "37a706fa849456b7a5689c0bd366d7e5831749e9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 155, "deletions": 34, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -1014,7 +1014,19 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     }\n \n   /* Costs of the stores.  */\n-  vect_get_store_cost (first_dr, ncopies, &inside_cost, body_cost_vec);\n+  if (STMT_VINFO_STRIDED_P (stmt_info))\n+    {\n+      /* N scalar stores plus extracting the elements.  */\n+      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      inside_cost += record_stmt_cost (body_cost_vec,\n+\t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t       scalar_store, stmt_info, 0, vect_body);\n+      inside_cost += record_stmt_cost (body_cost_vec,\n+\t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t       vec_to_scalar, stmt_info, 0, vect_body);\n+    }\n+  else\n+    vect_get_store_cost (first_dr, ncopies, &inside_cost, body_cost_vec);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1113,7 +1125,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n      access is instead being provided by a load-and-permute operation,\n      include the cost of the permutes.  */\n   if (!load_lanes_p && group_size > 1\n-      && !STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+      && !STMT_VINFO_STRIDED_P (stmt_info))\n     {\n       /* Uses an even and odd extract operations or shuffle operations\n \t for each needed permute.  */\n@@ -1128,7 +1140,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n     }\n \n   /* The loads themselves.  */\n-  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info)\n+  if (STMT_VINFO_STRIDED_P (stmt_info)\n       && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       /* N scalar loads plus gathering them into a vector.  */\n@@ -1143,7 +1155,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t || group_size > 1 || slp_node),\n \t\t\t&inside_cost, &prologue_cost, \n \t\t\tprologue_cost_vec, body_cost_vec, true);\n-  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+  if (STMT_VINFO_STRIDED_P (stmt_info))\n       inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_construct,\n \t\t\t\t       stmt_info, 0, vect_body);\n \n@@ -1823,7 +1835,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+  if (STMT_VINFO_STRIDED_P (stmt_info))\n     return false;\n \n   if (STMT_VINFO_GATHER_P (stmt_info))\n@@ -5016,7 +5028,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree dataref_ptr = NULL_TREE;\n   tree dataref_offset = NULL_TREE;\n   gimple ptr_incr = NULL;\n-  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n   int j;\n   gimple next_stmt, first_stmt = NULL;\n@@ -5103,38 +5115,40 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  negative = \n-    tree_int_cst_compare (loop && nested_in_vect_loop_p (loop, stmt)\n-\t\t\t  ? STMT_VINFO_DR_STEP (stmt_info) : DR_STEP (dr),\n-\t\t\t  size_zero_node) < 0;\n-  if (negative && ncopies > 1)\n+  if (!STMT_VINFO_STRIDED_P (stmt_info))\n     {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"multiple types with negative step.\\n\");\n-      return false;\n-    }\n-\n-  if (negative)\n-    {\n-      gcc_assert (!grouped_store);\n-      alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n-      if (alignment_support_scheme != dr_aligned\n-\t  && alignment_support_scheme != dr_unaligned_supported)\n+      negative = \n+\t  tree_int_cst_compare (loop && nested_in_vect_loop_p (loop, stmt)\n+\t\t\t\t? STMT_VINFO_DR_STEP (stmt_info) : DR_STEP (dr),\n+\t\t\t\tsize_zero_node) < 0;\n+      if (negative && ncopies > 1)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"negative step but alignment required.\\n\");\n+\t\t\t     \"multiple types with negative step.\\n\");\n \t  return false;\n \t}\n-      if (dt != vect_constant_def \n-\t  && dt != vect_external_def\n-\t  && !perm_mask_for_reverse (vectype))\n+      if (negative)\n \t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"negative step and reversing not supported.\\n\");\n-\t  return false;\n+\t  gcc_assert (!grouped_store);\n+\t  alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n+\t  if (alignment_support_scheme != dr_aligned\n+\t      && alignment_support_scheme != dr_unaligned_supported)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"negative step but alignment required.\\n\");\n+\t      return false;\n+\t    }\n+\t  if (dt != vect_constant_def \n+\t      && dt != vect_external_def\n+\t      && !perm_mask_for_reverse (vectype))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"negative step and reversing not supported.\\n\");\n+\t      return false;\n+\t    }\n \t}\n     }\n \n@@ -5233,6 +5247,113 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform store. ncopies = %d\\n\", ncopies);\n \n+  if (STMT_VINFO_STRIDED_P (stmt_info))\n+    {\n+      gimple_stmt_iterator incr_gsi;\n+      bool insert_after;\n+      gimple incr;\n+      tree offvar;\n+      tree ivstep;\n+      tree running_off;\n+      gimple_seq stmts = NULL;\n+      tree stride_base, stride_step, alias_off;\n+      tree vec_oprnd;\n+\n+      gcc_assert (!nested_in_vect_loop_p (loop, stmt));\n+\n+      stride_base\n+\t= fold_build_pointer_plus\n+\t    (unshare_expr (DR_BASE_ADDRESS (dr)),\n+\t     size_binop (PLUS_EXPR,\n+\t\t\t convert_to_ptrofftype (unshare_expr (DR_OFFSET (dr))),\n+\t\t\t convert_to_ptrofftype (DR_INIT(dr))));\n+      stride_step = fold_convert (sizetype, unshare_expr (DR_STEP (dr)));\n+\n+      /* For a store with loop-invariant (but other than power-of-2)\n+         stride (i.e. not a grouped access) like so:\n+\n+\t   for (i = 0; i < n; i += stride)\n+\t     array[i] = ...;\n+\n+\t we generate a new induction variable and new stores from\n+\t the components of the (vectorized) rhs:\n+\n+\t   for (j = 0; ; j += VF*stride)\n+\t     vectemp = ...;\n+\t     tmp1 = vectemp[0];\n+\t     array[j] = tmp1;\n+\t     tmp2 = vectemp[1];\n+\t     array[j + stride] = tmp2;\n+\t     ...\n+         */\n+\n+      ivstep = stride_step;\n+      ivstep = fold_build2 (MULT_EXPR, TREE_TYPE (ivstep), ivstep,\n+\t\t\t    build_int_cst (TREE_TYPE (ivstep),\n+\t\t\t\t\t   ncopies * nunits));\n+\n+      standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n+\n+      create_iv (stride_base, ivstep, NULL,\n+\t\t loop, &incr_gsi, insert_after,\n+\t\t &offvar, NULL);\n+      incr = gsi_stmt (incr_gsi);\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n+\n+      stride_step = force_gimple_operand (stride_step, &stmts, true, NULL_TREE);\n+      if (stmts)\n+\tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+\n+      prev_stmt_info = NULL;\n+      running_off = offvar;\n+      alias_off = build_int_cst (reference_alias_ptr_type (DR_REF (dr)), 0);\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  /* We've set op and dt above, from gimple_assign_rhs1(stmt),\n+\t     and first_stmt == stmt.  */\n+\t  if (j == 0)\n+\t    vec_oprnd = vect_get_vec_def_for_operand (op, first_stmt, NULL);\n+\t  else\n+\t    vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n+\n+\t  for (i = 0; i < nunits; i++)\n+\t    {\n+\t      tree newref, newoff;\n+\t      gimple incr, assign;\n+\t      tree size = TYPE_SIZE (elem_type);\n+\t      /* Extract the i'th component.  */\n+\t      tree pos = fold_build2 (MULT_EXPR, bitsizetype, bitsize_int (i),\n+\t\t\t\t      size);\n+\t      tree elem = fold_build3 (BIT_FIELD_REF, elem_type, vec_oprnd,\n+\t\t\t\t       size, pos);\n+\n+\t      elem = force_gimple_operand_gsi (gsi, elem, true,\n+\t\t\t\t\t       NULL_TREE, true,\n+\t\t\t\t\t       GSI_SAME_STMT);\n+\n+\t      newref = build2 (MEM_REF, TREE_TYPE (vectype),\n+\t\t\t       running_off, alias_off);\n+\n+\t      /* And store it to *running_off.  */\n+\t      assign = gimple_build_assign (newref, elem);\n+\t      vect_finish_stmt_generation (stmt, assign, gsi);\n+\n+\t      newoff = copy_ssa_name (running_off, NULL);\n+\t      incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n+\t\t\t\t\t  running_off, stride_step);\n+\t      vect_finish_stmt_generation (stmt, incr, gsi);\n+\n+\t      running_off = newoff;\n+\t      if (j == 0 && i == i)\n+\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = assign;\n+\t      else\n+\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = assign;\n+\t      prev_stmt_info = vinfo_for_stmt (assign);\n+\t    }\n+\t}\n+      return true;\n+    }\n+\n   dr_chain.create (group_size);\n   oprnds.create (group_size);\n \n@@ -5796,7 +5917,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       if (!slp\n \t  && !PURE_SLP_STMT (stmt_info)\n-\t  && !STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+\t  && !STMT_VINFO_STRIDED_P (stmt_info))\n \t{\n \t  if (vect_load_lanes_supported (vectype, group_size))\n \t    load_lanes_p = true;\n@@ -5851,7 +5972,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  return false;\n \t}\n     }\n-  else if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+  else if (STMT_VINFO_STRIDED_P (stmt_info))\n     {\n       if ((grouped_load\n \t   && (slp || PURE_SLP_STMT (stmt_info)))\n@@ -6099,7 +6220,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n       return true;\n     }\n-  else if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+  else if (STMT_VINFO_STRIDED_P (stmt_info))\n     {\n       gimple_stmt_iterator incr_gsi;\n       bool insert_after;"}, {"sha": "17e590e67defcd6ea9a04e3035678033d80655c0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e2a985429ab708a31abf0bd3bc3df9dbbc3033/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f2e2a985429ab708a31abf0bd3bc3df9dbbc3033", "patch": "@@ -646,7 +646,9 @@ typedef struct _stmt_vec_info {\n \n   /* For loads only, true if this is a gather load.  */\n   bool gather_p;\n-  bool stride_load_p;\n+\n+  /* True if this is an access with loop-invariant stride.  */\n+  bool strided_p;\n \n   /* For both loads and stores.  */\n   bool simd_lane_access_p;\n@@ -664,7 +666,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VECTORIZABLE(S)         (S)->vectorizable\n #define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n #define STMT_VINFO_GATHER_P(S)\t\t   (S)->gather_p\n-#define STMT_VINFO_STRIDE_LOAD_P(S)\t   (S)->stride_load_p\n+#define STMT_VINFO_STRIDED_P(S)\t   \t   (S)->strided_p\n #define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n \n #define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_base_address"}]}