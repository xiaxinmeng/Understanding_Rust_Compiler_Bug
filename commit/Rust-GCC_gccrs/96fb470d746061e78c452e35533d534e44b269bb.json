{"sha": "96fb470d746061e78c452e35533d534e44b269bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZmYjQ3MGQ3NDYwNjFlNzhjNDUyZTM1NTMzZDUzNGU0NGIyNjliYg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T13:11:06Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T13:11:06Z"}, "message": "cse.c (this_insn_cc0, [...]): New global variables, moved out from cse_insn.\n\n\t* cse.c (this_insn_cc0, this_insn_cc0_mode): New global\n\tvariables, moved out from cse_insn.\n\t(prev_insn): Remove this global variable).\n\t(new_basic_block): Don't set it.\n\t(cse_insn): Idem. Also, move code to delete unused CC0-setter\n\tinsns and code to set prev_insn_cc0 and prev_insn_cc0_mode\n\tfrom here...\n\t(cse_extended_basic_block): ...to here.  Do not clear\n\tprev_insn_cc0 until after recording equivalences from jumps.\n\nFrom-SVN: r119984", "tree": {"sha": "4cb0076197443e10c62e2c31883456d84fa49e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cb0076197443e10c62e2c31883456d84fa49e48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96fb470d746061e78c452e35533d534e44b269bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fb470d746061e78c452e35533d534e44b269bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fb470d746061e78c452e35533d534e44b269bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fb470d746061e78c452e35533d534e44b269bb/comments", "author": null, "committer": null, "parents": [{"sha": "c8cf50e4c144c343371347b47d08af7638ccadb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8cf50e4c144c343371347b47d08af7638ccadb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8cf50e4c144c343371347b47d08af7638ccadb7"}], "stats": {"total": 94, "additions": 57, "deletions": 37}, "files": [{"sha": "f837bb4bfa8a964d55cf2e549e25e9cbfa2baad3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fb470d746061e78c452e35533d534e44b269bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fb470d746061e78c452e35533d534e44b269bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96fb470d746061e78c452e35533d534e44b269bb", "patch": "@@ -1,3 +1,15 @@\n+2006-12-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cse.c (this_insn_cc0, this_insn_cc0_mode): New global\n+\tvariables, moved out from cse_insn.\n+\t(prev_insn): Remove this global variable).\n+\t(new_basic_block): Don't set it.\n+\t(cse_insn): Idem. Also, move code to delete unused CC0-setter\n+\tinsns and code to set prev_insn_cc0 and prev_insn_cc0_mode\n+\tfrom here...\n+\t(cse_extended_basic_block): ...to here.  Do not clear\n+\tprev_insn_cc0 until after recording equivalences from jumps.\n+\n 2006-12-16  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (ipa_passes): Clear current_function_decl.\n@@ -376,9 +388,10 @@\n \tare the left hand side, set the element's is_vector_lhs to true.\n \t(instantiate_element): For vector types which were on the left\n \thand size, set DECL_GIMPLE_REG_P to false.\n-\t* tree-nested.c (create_tmp_var_for): Use the renamed DECL_GIMPLE_REG_P.\t* tree-inline.c (declare_return_variable):  Use the renamed\n-\tDECL_GIMPLE_REG_P\n-\tand check for VECTOR_TYPE.\n+\t* tree-nested.c (create_tmp_var_for): Use the renamed\n+\tDECL_GIMPLE_REG_P.\n+\t* tree-inline.c (declare_return_variable):  Use the renamed\n+\tDECL_GIMPLE_REG_P and check for VECTOR_TYPE.\n \t(copy_decl_to_var):  Use the renamed DECL_GIMPLE_REG_P.\n \t(copy_result_decl_to_var): Likewise.\n \t* tree-vect-transform.c (vect_get_new_vect_var): For vector types,"}, {"sha": "fc6ffff11618b584eafbcae0db43e1e7e1e7f588", "filename": "gcc/cse.c", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fb470d746061e78c452e35533d534e44b269bb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fb470d746061e78c452e35533d534e44b269bb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=96fb470d746061e78c452e35533d534e44b269bb", "patch": "@@ -269,17 +269,13 @@ struct change_cc_mode_args\n    table since its use is guaranteed to be the insn immediately following\n    its definition and any other insn is presumed to invalidate it.\n \n-   Instead, we store below the value last assigned to CC0.  If it should\n-   happen to be a constant, it is stored in preference to the actual\n-   assigned value.  In case it is a constant, we store the mode in which\n-   the constant should be interpreted.  */\n+   Instead, we store below the current and last value assigned to CC0.\n+   If it should happen to be a constant, it is stored in preference\n+   to the actual assigned value.  In case it is a constant, we store\n+   the mode in which the constant should be interpreted.  */\n \n-static rtx prev_insn_cc0;\n-static enum machine_mode prev_insn_cc0_mode;\n-\n-/* Previous actual insn.  0 if at first insn of basic block.  */\n-\n-static rtx prev_insn;\n+static rtx this_insn_cc0, prev_insn_cc0;\n+static enum machine_mode this_insn_cc0_mode, prev_insn_cc0_mode;\n #endif\n \n /* Insn being scanned.  */\n@@ -900,7 +896,6 @@ new_basic_block (void)\n     }\n \n #ifdef HAVE_cc0\n-  prev_insn = 0;\n   prev_insn_cc0 = 0;\n #endif\n }\n@@ -4022,8 +4017,8 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n #ifdef HAVE_cc0\n   /* Records what this insn does to set CC0.  */\n-  rtx this_insn_cc0 = 0;\n-  enum machine_mode this_insn_cc0_mode = VOIDmode;\n+  this_insn_cc0 = 0;\n+  this_insn_cc0_mode = VOIDmode;\n #endif\n \n   rtx src_eqv = 0;\n@@ -5644,20 +5639,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n     }\n \n done:;\n-#ifdef HAVE_cc0\n-  /* If the previous insn set CC0 and this insn no longer references CC0,\n-     delete the previous insn.  Here we use the fact that nothing expects CC0\n-     to be valid over an insn, which is true until the final pass.  */\n-  if (prev_insn && NONJUMP_INSN_P (prev_insn)\n-      && (tem = single_set (prev_insn)) != 0\n-      && SET_DEST (tem) == cc0_rtx\n-      && ! reg_mentioned_p (cc0_rtx, x))\n-    delete_insn_and_edges (prev_insn);\n-\n-  prev_insn_cc0 = this_insn_cc0;\n-  prev_insn_cc0_mode = this_insn_cc0_mode;\n-  prev_insn = insn;\n-#endif\n }\n \f\n /* Remove from the hash table all expressions that reference memory.  */\n@@ -6096,19 +6077,39 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t  && for_each_rtx (&PATTERN (insn), check_for_label_ref,\n \t\t\t\t   (void *) insn))\n \t\trecorded_label_ref = 1;\n+\n+#ifdef HAVE_cc0\n+\t      /* If the previous insn set CC0 and this insn no longer\n+\t\t references CC0, delete the previous insn.  Here we use\n+\t\t fact that nothing expects CC0 to be valid over an insn,\n+\t\t which is true until the final pass.  */\n+\t      {\n+\t\trtx prev_insn, tem;\n+\n+\t\tprev_insn = PREV_INSN (insn);\n+\t\tif (prev_insn && NONJUMP_INSN_P (prev_insn)\n+\t\t    && (tem = single_set (prev_insn)) != 0\n+\t\t    && SET_DEST (tem) == cc0_rtx\n+\t\t    && ! reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n+\t\t  delete_insn (prev_insn);\n+\t      }\n+\n+\t      /* If this insn is not the last insn in the basic block,\n+\t\t it will be PREV_INSN(insn) in the next iteration.  If\n+\t\t we recorded any CC0-related information for this insn,\n+\t\t remember it.  */\n+\t      if (insn != BB_END (bb))\n+\t\t{\n+\t\t  prev_insn_cc0 = this_insn_cc0;\n+\t\t  prev_insn_cc0_mode = this_insn_cc0_mode;\n+\t\t}\n+#endif\n \t    }\n \t}\n \n       /* Make sure that libcalls don't span multiple basic blocks.  */\n       gcc_assert (libcall_insn == NULL_RTX);\n \n-#ifdef HAVE_cc0\n-      /* Clear the CC0-tracking related insns, they can't provide\n-\t useful information across basic block boundaries.  */\n-      prev_insn_cc0 = 0;\n-      prev_insn = 0;\n-#endif\n-\n       /* If we changed a conditional jump, we may have terminated\n \t the path we are following.  Check that by verifying that\n \t the edge we would take still exists.  If the edge does\n@@ -6133,6 +6134,12 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t  bool taken = (next_bb == BRANCH_EDGE (bb)->dest);\n \t  record_jump_equiv (insn, taken);\n \t}\n+\n+#ifdef HAVE_cc0\n+      /* Clear the CC0-tracking related insns, they can't provide\n+\t useful information across basic block boundaries.  */\n+      prev_insn_cc0 = 0;\n+#endif\n     }\n \n   gcc_assert (next_qty <= max_qty);"}]}