{"sha": "9206d7362fa9bff2b451bbd92ff906483e46af0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIwNmQ3MzYyZmE5YmZmMmI0NTFiYmQ5MmZmOTA2NDgzZTQ2YWYwZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2003-07-30T07:30:16Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2003-07-30T07:30:16Z"}, "message": "calls.c (load_register_parameters): When shifting reg sized values to the msb, move the value to a reg first.\n\n\t* calls.c (load_register_parameters): When shifting reg sized values\n\tto the msb, move the value to a reg first.\n\nFrom-SVN: r69953", "tree": {"sha": "a5308a80fda752a31d80baba06c127666631c6b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5308a80fda752a31d80baba06c127666631c6b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9206d7362fa9bff2b451bbd92ff906483e46af0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9206d7362fa9bff2b451bbd92ff906483e46af0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9206d7362fa9bff2b451bbd92ff906483e46af0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9206d7362fa9bff2b451bbd92ff906483e46af0e/comments", "author": null, "committer": null, "parents": [{"sha": "9074464c14b99872a7ce360c883c1b0dc20c75be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9074464c14b99872a7ce360c883c1b0dc20c75be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9074464c14b99872a7ce360c883c1b0dc20c75be"}], "stats": {"total": 48, "additions": 26, "deletions": 22}, "files": [{"sha": "7a856a816c03971eb4336b71e04f5e1b62952296", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9206d7362fa9bff2b451bbd92ff906483e46af0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9206d7362fa9bff2b451bbd92ff906483e46af0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9206d7362fa9bff2b451bbd92ff906483e46af0e", "patch": "@@ -1,3 +1,8 @@\n+2003-07-30  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* calls.c (load_register_parameters): When shifting reg sized values\n+\tto the msb, move the value to a reg first.\n+\n 2003-07-29  Geoffrey Keating  <geoffk@apple.com>\n \n \t* cppfiles.c (stack_file): Leave filename as \"\" rather than \"<stdin>\"."}, {"sha": "26937c3775bae0125515d71adba8b473e295671c", "filename": "gcc/calls.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9206d7362fa9bff2b451bbd92ff906483e46af0e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9206d7362fa9bff2b451bbd92ff906483e46af0e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9206d7362fa9bff2b451bbd92ff906483e46af0e", "patch": "@@ -1622,14 +1622,27 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t     has already loaded the register for us.  In all other cases,\n \t     load the register(s) from memory.  */\n \n-\t  else if (nregs == -1\n+\t  else if (nregs == -1)\n+\t    {\n+\t      emit_move_insn (reg, args[i].value);\n #ifdef BLOCK_REG_PADDING\n-\t\t   && !(size < UNITS_PER_WORD\n-\t\t\t&& (args[i].locate.where_pad\n-\t\t\t    == (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t      /* Handle case where we have a value that needs shifting\n+\t\t up to the msb.  eg. a QImode value and we're padding\n+\t\t upward on a BYTES_BIG_ENDIAN machine.  */\n+\t      if (size < UNITS_PER_WORD\n+\t\t  && (args[i].locate.where_pad\n+\t\t      == (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t\t{\n+\t\t  rtx ri = gen_rtx_REG (word_mode, REGNO (reg));\n+\t\t  rtx x;\n+\t\t  int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\t\t  x = expand_binop (word_mode, ashl_optab, ri,\n+\t\t\t\t    GEN_INT (shift), ri, 1, OPTAB_WIDEN);\n+\t\t  if (x != ri)\n+\t\t    emit_move_insn (ri, x);\n+\t\t}\n #endif\n-\t\t   )\n-\t    emit_move_insn (reg, args[i].value);\n+\t    }\n \n \t  /* If we have pre-computed the values to put in the registers in\n \t     the case of non-aligned structures, copy them in now.  */\n@@ -1644,23 +1657,9 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t      rtx mem = validize_mem (args[i].value);\n \n #ifdef BLOCK_REG_PADDING\n-\t      /* Handle case where we have a value that needs shifting\n-\t\t up to the msb.  eg. a QImode value and we're padding\n-\t\t upward on a BYTES_BIG_ENDIAN machine.  */\n-\t      if (nregs == -1)\n-\t\t{\n-\t\t  rtx ri = gen_rtx_REG (word_mode, REGNO (reg));\n-\t\t  rtx x;\n-\t\t  int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n-\t\t  x = expand_binop (word_mode, ashl_optab, mem,\n-\t\t\t\t    GEN_INT (shift), ri, 1, OPTAB_WIDEN);\n-\t\t  if (x != ri)\n-\t\t    emit_move_insn (ri, x);\n-\t\t}\n-\n \t      /* Handle a BLKmode that needs shifting.  */\n-\t      else if (nregs == 1 && size < UNITS_PER_WORD\n-\t\t       && args[i].locate.where_pad == downward)\n+\t      if (nregs == 1 && size < UNITS_PER_WORD\n+\t\t  && args[i].locate.where_pad == downward)\n \t\t{\n \t\t  rtx tem = operand_subword_force (mem, 0, args[i].mode);\n \t\t  rtx ri = gen_rtx_REG (word_mode, REGNO (reg));"}]}