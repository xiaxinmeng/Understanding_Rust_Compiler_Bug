{"sha": "0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRlYjIwZGZkMzkwMTU3YTM4MzUwYjdkM2U0YTg3YmE5YmU2YmNkZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-10T01:19:08Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-10T01:19:08Z"}, "message": "[multiple changes]\n\nTue Nov  9 10:30:08 1999  Tom Tromey  <tromey@cygnus.com>\n\n\t* config/i386/xm-djgpp.h (HAVE_DOS_BASED_FILE_SYSTEM): Renamed\n\tfrom HAVE_DOS_BASED_FILESYSTEM.\n\t* gcc.c (find_a_file): Use HAVE_DOS_BASED_FILE_SYSTEM, not\n\tHAVE_DOS_BASED_FILESYSTEM.\n\t(main): Likewise.\n\t(split_directories): Only special-case DOS file names if\n\tHAVE_DOS_BASED_FILE_SYSTEM is defined.  Use IS_DIR_SEPARATOR\n\tinstead of explicit tests.  Conditionalize on !VMS.\n\t(make_relative_prefix): Use IS_DIR_SEPARATOR instead of explicit\n\ttests.  Conditionalize on !VMS.\n\t(process_command): Only use make_relative_prefix if !VMS.\n\t(free_split_directories): Conditionalize on !VMS.\n\t(DIR_UP): Conditionalize on !VMS.\n\nWed Jun  9 16:57:11 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n\n\t* gcc.c (STANDARD_BINDIR_PREFIX): Provide default.\n\nFri Feb  5 14:22:01 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n\n\t* gcc.c (make_relative_prefix): Handle the HAVE_EXECUTABLE_SUFFIX\n\tcase.\n\nMon Nov  8 14:16:57 1999  Michael Meissner  <meissner@cygnus.com>\n\n\t* invoke.texi (Environment Variables): Document relative path\n\tlookup.\n\t* gcc.c (DIR_UP): If not defined, define as \"..\".\n\t(standard_bindir_prefix): New static, holds target location to\n\tinstall binaries.\n\t(split_directories): New function to split a filename into\n\tcomponent directories.\n\t(free_split_directories): New function, release memory allocated\n\tby split_directories.\n\t(make_relative_prefix): New function, make a relative pathname if\n\tthe compiler is not in the expected location.\n\t(process_command): If GCC_EXEC_PREFIX was not specified, see if we\n\tcan figure out an appropriate prefix from argv[0].\n\t* Makefile.in (DRIVER_DEFINES): Use unlibsubdir in definition of\n\tSTANDARD_STARTFILE_PREFIX and TOOLDIR_BASE_PREFIX.  Define\n\tSTANDARD_BINDIR_PREFIX.\n\nFrom-SVN: r30464", "tree": {"sha": "84d6164ac21cabab9b2c0eb2e76d72d320cd10c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84d6164ac21cabab9b2c0eb2e76d72d320cd10c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/comments", "author": null, "committer": null, "parents": [{"sha": "798f6e6f19cf60d8a94ed426fd75e11d5787042f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798f6e6f19cf60d8a94ed426fd75e11d5787042f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/798f6e6f19cf60d8a94ed426fd75e11d5787042f"}], "stats": {"total": 326, "additions": 320, "deletions": 6}, "files": [{"sha": "6d6796b357972a2030dc083ea60a647d7c1b11ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "patch": "@@ -1,3 +1,47 @@\n+Tue Nov  9 10:30:08 1999  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* config/i386/xm-djgpp.h (HAVE_DOS_BASED_FILE_SYSTEM): Renamed\n+\tfrom HAVE_DOS_BASED_FILESYSTEM.\n+\t* gcc.c (find_a_file): Use HAVE_DOS_BASED_FILE_SYSTEM, not\n+\tHAVE_DOS_BASED_FILESYSTEM.\n+\t(main): Likewise.\n+\t(split_directories): Only special-case DOS file names if\n+\tHAVE_DOS_BASED_FILE_SYSTEM is defined.  Use IS_DIR_SEPARATOR\n+\tinstead of explicit tests.  Conditionalize on !VMS.\n+\t(make_relative_prefix): Use IS_DIR_SEPARATOR instead of explicit\n+\ttests.  Conditionalize on !VMS.\n+\t(process_command): Only use make_relative_prefix if !VMS.\n+\t(free_split_directories): Conditionalize on !VMS.\n+\t(DIR_UP): Conditionalize on !VMS.\n+\n+Wed Jun  9 16:57:11 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n+\n+\t* gcc.c (STANDARD_BINDIR_PREFIX): Provide default.\n+\n+Fri Feb  5 14:22:01 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n+\n+\t* gcc.c (make_relative_prefix): Handle the HAVE_EXECUTABLE_SUFFIX\n+\tcase.\n+\n+Mon Nov  8 14:16:57 1999  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* invoke.texi (Environment Variables): Document relative path\n+\tlookup.\n+\t* gcc.c (DIR_UP): If not defined, define as \"..\".\n+\t(standard_bindir_prefix): New static, holds target location to\n+\tinstall binaries.\n+\t(split_directories): New function to split a filename into\n+\tcomponent directories.\n+\t(free_split_directories): New function, release memory allocated\n+\tby split_directories.\n+\t(make_relative_prefix): New function, make a relative pathname if\n+\tthe compiler is not in the expected location.\n+\t(process_command): If GCC_EXEC_PREFIX was not specified, see if we\n+\tcan figure out an appropriate prefix from argv[0].\n+\t* Makefile.in (DRIVER_DEFINES): Use unlibsubdir in definition of\n+\tSTANDARD_STARTFILE_PREFIX and TOOLDIR_BASE_PREFIX.  Define\n+\tSTANDARD_BINDIR_PREFIX.\n+\n Wed Nov 10 11:47:54 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x-protos.h: New file.  Prototypes for functions defined"}, {"sha": "8516d3b01619d9fbb89931ec67a89df73f534597", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "patch": "@@ -1395,11 +1395,12 @@ c-common.o : c-common.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-lex.h \\\n # Language-independent files.\n \n DRIVER_DEFINES = \\\n-  -DSTANDARD_STARTFILE_PREFIX=\\\"$(libdir)/\\\" \\\n+  -DSTANDARD_STARTFILE_PREFIX=\\\"$(unlibsubdir)/\\\" \\\n   -DSTANDARD_EXEC_PREFIX=\\\"$(libdir)/gcc-lib/\\\" \\\n   -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n   -DDEFAULT_TARGET_MACHINE=\\\"$(target_alias)\\\" \\\n-  -DTOOLDIR_BASE_PREFIX=\\\"$(exec_prefix)/\\\"\n+  -DSTANDARD_BINDIR_PREFIX=\\\"$(bindir)/\\\" \\\n+  -DTOOLDIR_BASE_PREFIX=\\\"$(unlibsubdir)/../\\\"\n gcc.o: gcc.c $(CONFIG_H) system.h intl.h multilib.h \\\n     Makefile $(lang_specs_files) prefix.h gcc.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\"}, {"sha": "9597ad5597351bc61d5c4f26bc6e07514e518c3e", "filename": "gcc/config/i386/xm-djgpp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2Fconfig%2Fi386%2Fxm-djgpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2Fconfig%2Fi386%2Fxm-djgpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-djgpp.h?ref=0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "patch": "@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #define DIR_SEPARATOR_2 '\\\\'\n \n /* Allow test for DOS drive names.  */\n-#define HAVE_DOS_BASED_FILESYSTEM\n+#define HAVE_DOS_BASED_FILE_SYSTEM\n \n #define LIBSTDCXX \"-lstdcxx\"\n "}, {"sha": "f4787cc4ff0ef703aa12da2bf801108de8da12ce", "filename": "gcc/gcc.c", "status": "modified", "additions": 269, "deletions": 3, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "patch": "@@ -74,6 +74,14 @@ extern int getrusage PROTO ((int, struct rusage *));\n #define DIR_SEPARATOR '/'\n #endif\n \n+#ifndef VMS\n+/* FIXME: the location independence code for VMS is hairier than this,\n+   and hasn't been written.  */\n+#ifndef DIR_UP\n+#define DIR_UP \"..\"\n+#endif /* DIR_UP */\n+#endif /* VMS */\n+\n /* Define IS_DIR_SEPARATOR.  */\n #ifndef DIR_SEPARATOR_2\n # define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n@@ -199,6 +207,11 @@ extern char *version_string;\n struct path_prefix;\n \n static void init_spec\t\tPROTO((void));\n+#ifndef VMS\n+static char **split_directories\tPROTO((const char *, int *));\n+static void free_split_directories PROTO((char **));\n+static char *make_relative_prefix PROTO((const char *, const char *, const char *));\n+#endif /* VMS */\n static void read_specs\t\tPROTO((const char *, int));\n static void set_spec\t\tPROTO((const char *, const char *));\n static struct compiler *lookup_compiler PROTO((const char *, size_t, const char *));\n@@ -1399,6 +1412,11 @@ static const char *standard_startfile_prefix_2 = \"/usr/lib/\";\n static const char *tooldir_base_prefix = TOOLDIR_BASE_PREFIX;\n static const char *tooldir_prefix;\n \n+#ifndef STANDARD_BINDIR_PREFIX\n+#define STANDARD_BINDIR_PREFIX \"/usr/local/bin\"\n+#endif\n+static char *standard_bindir_prefix = STANDARD_BINDIR_PREFIX;\n+\n /* Subdirectory to use for locating libraries.  Set by\n    set_multilib_dir based on the compilation options.  */\n \n@@ -1952,6 +1970,242 @@ putenv_from_prefixes (paths, env_var)\n   putenv (build_search_list (paths, env_var, 1));\n }\n \f\n+#ifndef VMS\n+\n+/* FIXME: the location independence code for VMS is hairier than this,\n+   and hasn't been written.  */\n+\n+/* Split a filename into component directories.  */\n+\n+static char **\n+split_directories (name, ptr_num_dirs)\n+     const char *name;\n+     int *ptr_num_dirs;\n+{\n+  int num_dirs = 0;\n+  char **dirs;\n+  const char *p, *q;\n+  int ch;\n+\n+  /* Count the number of directories.  Special case MSDOS disk names as part\n+     of the initial directory.  */\n+  p = name;\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+  if (name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n+    {\n+      p += 3;\n+      num_dirs++;\n+    }\n+#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n+\n+  while ((ch = *p++) != '\\0')\n+    {\n+      if (IS_DIR_SEPARATOR (ch))\n+\t{\n+\t  num_dirs++;\n+\t  while (IS_DIR_SEPARATOR (*p))\n+\t    p++;\n+\t}\n+    }\n+\n+  dirs = (char **) xmalloc (sizeof (char *) * (num_dirs + 2));\n+\n+  /* Now copy the directory parts.  */\n+  num_dirs = 0;\n+  p = name;\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+  if (name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n+    {\n+      dirs[num_dirs++] = save_string (p, 3);\n+      p += 3;\n+    }\n+#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n+\n+  q = p;\n+  while ((ch = *p++) != '\\0')\n+    {\n+      if (IS_DIR_SEPARATOR (ch))\n+\t{\n+\t  while (IS_DIR_SEPARATOR (*p))\n+\t    p++;\n+\n+\t  dirs[num_dirs++] = save_string (q, p - q);\n+\t  q = p;\n+\t}\n+    }\n+\n+  if (p - 1 - q > 0)\n+    dirs[num_dirs++] = save_string (q, p - 1 - q);\n+\n+  dirs[num_dirs] = NULL_PTR;\n+  if (ptr_num_dirs)\n+    *ptr_num_dirs = num_dirs;\n+\n+  return dirs;\n+}\n+\n+/* Release storage held by split directories.  */\n+\n+static void\n+free_split_directories (dirs)\n+     char **dirs;\n+{\n+  int i = 0;\n+\n+  while (dirs[i] != NULL_PTR)\n+    free (dirs[i++]);\n+\n+  free ((char *)dirs);\n+}\n+\n+/* Given three strings PROGNAME, BIN_PREFIX, PREFIX, return a string that gets\n+   to PREFIX starting with the directory portion of PROGNAME and a relative\n+   pathname of the difference between BIN_PREFIX and PREFIX.\n+\n+   For example, if BIN_PREFIX is /alpha/beta/gamma/gcc/delta, PREFIX is\n+   /alpha/beta/gamma/omega/, and PROGNAME is /red/green/blue/gcc, then this\n+   function will return /reg/green/blue/../omega.\n+\n+   If no relative prefix can be found, return NULL.  */\n+\n+static char *\n+make_relative_prefix (progname, bin_prefix, prefix)\n+     const char *progname;\n+     const char *bin_prefix;\n+     const char *prefix;\n+{\n+  char **prog_dirs, **bin_dirs, **prefix_dirs;\n+  int prog_num, bin_num, prefix_num, std_loc_p;\n+  int i, n, common;\n+\n+  prog_dirs = split_directories (progname, &prog_num);\n+  bin_dirs = split_directories (bin_prefix, &bin_num);\n+\n+  /* If there is no full pathname, try to find the program by checking in each\n+     of the directories specified in the PATH environment variable.  */\n+  if (prog_num == 1)\n+    {\n+      char *temp;\n+\n+      GET_ENV_PATH_LIST (temp, \"PATH\");\n+      if (temp)\n+\t{\n+\t  char *startp, *endp;\n+\t  char *nstore = (char *) alloca (strlen (temp) + strlen (progname) + 1);\n+\n+\t  startp = endp = temp;\n+\t  while (1)\n+\t    {\n+\t      if (*endp == PATH_SEPARATOR || *endp == 0)\n+\t\t{\n+\t\t  if (endp == startp)\n+\t\t    {\n+\t\t      nstore[0] = '.';\n+\t\t      nstore[1] = DIR_SEPARATOR;\n+\t\t      nstore[2] = '\\0';\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      strncpy (nstore, startp, endp-startp);\n+\t\t      if (! IS_DIR_SEPARATOR (endp[-1]))\n+\t\t\t{\n+\t\t\t  nstore[endp-startp] = DIR_SEPARATOR;\n+\t\t\t  nstore[endp-startp+1] = 0;\n+\t\t\t}\n+\t\t      else\n+\t\t\tnstore[endp-startp] = 0;\n+\t\t    }\n+\t\t  strcat (nstore, progname);\n+\t\t  if (! access (nstore, X_OK)\n+#ifdef HAVE_EXECUTABLE_SUFFIX\n+                      || ! access (strcat (nstore, EXECUTABLE_SUFFIX), X_OK)\n+#endif\n+\t\t      )\n+\t\t    {\n+\t\t      free_split_directories (prog_dirs);\n+\t\t      progname = nstore;\n+\t\t      prog_dirs = split_directories (progname, &prog_num);\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  if (*endp == 0)\n+\t\t    break;\n+\t\t  endp = startp = endp + 1;\n+\t\t}\n+\t      else\n+\t\tendp++;\n+\t    }\n+\t}\n+    }\n+\n+  /* Remove the program name from comparison of directory names.  */\n+  prog_num--;\n+\n+  /* Determine if the compiler is installed in the standard location, and if\n+     so, we don't need to specify relative directories.  Also, if argv[0]\n+     doesn't contain any directory specifiers, there is not much we can do.  */\n+  std_loc_p = 0;\n+  if (prog_num == bin_num)\n+    {\n+      for (i = 0; i < bin_num; i++)\n+\t{\n+\t  if (strcmp (prog_dirs[i], bin_dirs[i]) != 0)\n+\t    break;\n+\t}\n+\n+      if (prog_num <= 0 || i == bin_num)\n+\t{\n+\t  std_loc_p = 1;\n+\t  free_split_directories (prog_dirs);\n+\t  free_split_directories (bin_dirs);\n+\t  prog_dirs = bin_dirs = (char **)0;\n+\t  return NULL_PTR;\n+\t}\n+    }\n+\n+  prefix_dirs = split_directories (prefix, &prefix_num);\n+\n+  /* Find how many directories are in common between bin_prefix & prefix */\n+  n = (prefix_num < bin_num) ? prefix_num : bin_num;\n+  for (common = 0; common < n; common++)\n+    {\n+      if (strcmp (bin_dirs[common], prefix_dirs[common]) != 0)\n+\tbreak;\n+    }\n+\n+  /* If there are no common directories, there can be no relative prefix.  */\n+  if (common == 0)\n+    {\n+      free_split_directories (prog_dirs);\n+      free_split_directories (bin_dirs);\n+      free_split_directories (prefix_dirs);\n+      return NULL_PTR;\n+    }\n+\n+  /* Build up the pathnames in argv[0].  */\n+  for (i = 0; i < prog_num; i++)\n+    obstack_grow (&obstack, prog_dirs[i], strlen (prog_dirs[i]));\n+\n+  /* Now build up the ..'s.  */\n+  for (i = common; i < n; i++)\n+    {\n+      obstack_grow (&obstack, DIR_UP, sizeof (DIR_UP)-1);\n+      obstack_1grow (&obstack, DIR_SEPARATOR);\n+    }\n+\n+  /* Put in directories to move over to prefix.  */\n+  for (i = common; i < prefix_num; i++)\n+    obstack_grow (&obstack, prefix_dirs[i], strlen (prefix_dirs[i]));\n+\n+  free_split_directories (prog_dirs);\n+  free_split_directories (bin_dirs);\n+  free_split_directories (prefix_dirs);\n+\n+  obstack_1grow (&obstack, '\\0');\n+  return obstack_finish (&obstack);\n+}\n+#endif /* VMS */\n+\f\n /* Check whether NAME can be accessed in MODE.  This is like access,\n    except that it never considers directories to be executable.  */\n \n@@ -2005,7 +2259,7 @@ find_a_file (pprefix, name, mode)\n   /* Determine the filename to execute (special case for absolute paths).  */\n \n   if (IS_DIR_SEPARATOR (*name)\n-#ifdef HAVE_DOS_BASED_FILESYSTEM\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n       /* Check for disk name on MS-DOS-based systems.  */\n       || (name[0] && name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n #endif\n@@ -2639,7 +2893,19 @@ process_command (argc, argv)\n \t}\n     }\n \n-  /* Set up the default search paths.  */\n+  /* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,\n+     see if we can create it from the pathname specified in argv[0].  */\n+\n+#ifndef VMS\n+  /* FIXME: make_relative_prefix doesn't yet work for VMS.  */\n+  if (!gcc_exec_prefix)\n+    {\n+      gcc_exec_prefix = make_relative_prefix (argv[0], standard_bindir_prefix,\n+\t\t\t\t\t      standard_exec_prefix);\n+      if (gcc_exec_prefix)\n+\tputenv (concat (\"GCC_EXEC_PREFIX=\", gcc_exec_prefix, NULL_PTR));\n+    }\n+#endif\n \n   if (gcc_exec_prefix)\n     {\n@@ -4906,7 +5172,7 @@ main (argc, argv)\n \t standard_startfile_prefix on that as well.  */\n       if (IS_DIR_SEPARATOR (*standard_startfile_prefix)\n \t    || *standard_startfile_prefix == '$'\n-#ifdef HAVE_DOS_BASED_FILESYSTEM\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n   \t    /* Check for disk name on MS-DOS-based systems.  */\n           || (standard_startfile_prefix[1] == ':'\n \t      && (IS_DIR_SEPARATOR (standard_startfile_prefix[2])))"}, {"sha": "c53f53fe4aac11624ba93214a2cff519387d62af", "filename": "gcc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0deb20dfd390157a38350b7d3e4a87ba9be6bcdd/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=0deb20dfd390157a38350b7d3e4a87ba9be6bcdd", "patch": "@@ -7084,6 +7084,9 @@ names of the subprograms executed by the compiler.  No slash is added\n when this prefix is combined with the name of a subprogram, but you can\n specify a prefix that ends with a slash if you wish.\n \n+If @code{GCC_EXEC_PREFIX} is not set, GNU CC will attempt to figure out\n+an appropriate prefix to use based on the pathname it was invoked with.\n+\n If GCC cannot find the subprogram using the specified prefix, it\n tries looking in the usual places for the subprogram.\n "}]}