{"sha": "4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY1OGMwZDExOGExOGY1N2VhOWZhMWZmMGQ4NTg2NjYwYmRiZjUxOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-11-10T22:59:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-11-10T22:59:40Z"}, "message": "rs6000.md (bswaphi2_reg): On ISA 3.0 systems, enable generating XXBRH if the value is in a vector register.\n\n[gcc]\n2017-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.md (bswaphi2_reg): On ISA 3.0 systems,\n\tenable generating XXBRH if the value is in a vector register.\n\t(bswapsi2_reg): On ISA 3.0 systems, enable generating XXBRW if the\n\tvalue is in a vector register.\n\t(bswapdi2_reg): On ISA 3.0 systems, always use XXBRD to do\n\tregister to register bswap64's instead of doing the GPR sequence\n\tused on previous machines.\n\t(bswapdi2_xxbrd): New insn.\n\t(bswapdi2_reg): Disallow on ISA 3.0.\n\t(register to register bswap64 splitter): Do not split the insn on\n\tISA 3.0 systems that use XXBRD.\n\n[gcc/testsuite]\n2017-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p9-xxbr-3.c: New test.\n\nFrom-SVN: r254643", "tree": {"sha": "2aae5451435da35b41f82c6d93a284fab36d5a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aae5451435da35b41f82c6d93a284fab36d5a4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/comments", "author": null, "committer": null, "parents": [{"sha": "d72b0a3f3b5b650c3ef01859508b619955151d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72b0a3f3b5b650c3ef01859508b619955151d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d72b0a3f3b5b650c3ef01859508b619955151d9b"}], "stats": {"total": 166, "additions": 152, "deletions": 14}, "files": [{"sha": "9dcaca43251afed30c1de537fa8bbb7e23e2c9f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "patch": "@@ -1,3 +1,17 @@\n+2017-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.md (bswaphi2_reg): On ISA 3.0 systems,\n+\tenable generating XXBRH if the value is in a vector register.\n+\t(bswapsi2_reg): On ISA 3.0 systems, enable generating XXBRW if the\n+\tvalue is in a vector register.\n+\t(bswapdi2_reg): On ISA 3.0 systems, always use XXBRD to do\n+\tregister to register bswap64's instead of doing the GPR sequence\n+\tused on previous machines.\n+\t(bswapdi2_xxbrd): New insn.\n+\t(bswapdi2_reg): Disallow on ISA 3.0.\n+\t(register to register bswap64 splitter): Do not split the insn on\n+\tISA 3.0 systems that use XXBRD.\n+\n 2017-11-10  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81117"}, {"sha": "9b0f872cee3e7b97df1ffc887624bd8957e90e8c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "patch": "@@ -2432,13 +2432,15 @@\n   [(set_attr \"type\" \"store\")])\n \n (define_insn_and_split \"bswaphi2_reg\"\n-  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=&r\")\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=&r,wo\")\n \t(bswap:HI\n-\t (match_operand:HI 1 \"gpc_reg_operand\" \"r\")))\n-   (clobber (match_scratch:SI 2 \"=&r\"))]\n+\t (match_operand:HI 1 \"gpc_reg_operand\" \"r,wo\")))\n+   (clobber (match_scratch:SI 2 \"=&r,X\"))]\n   \"\"\n-  \"#\"\n-  \"reload_completed\"\n+  \"@\n+   #\n+   xxbrh %x0,%x1\"\n+  \"reload_completed && int_reg_operand (operands[0], HImode)\"\n   [(set (match_dup 3)\n \t(and:SI (lshiftrt:SI (match_dup 4)\n \t\t\t     (const_int 8))\n@@ -2454,18 +2456,20 @@\n   operands[3] = simplify_gen_subreg (SImode, operands[0], HImode, 0);\n   operands[4] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n }\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"*\")])\n+  [(set_attr \"length\" \"12,4\")\n+   (set_attr \"type\" \"*,vecperm\")])\n \n ;; We are always BITS_BIG_ENDIAN, so the bit positions below in\n ;; zero_extract insns do not change for -mlittle.\n (define_insn_and_split \"bswapsi2_reg\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r\")\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,wo\")\n \t(bswap:SI\n-\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n+\t (match_operand:SI 1 \"gpc_reg_operand\" \"r,wo\")))]\n   \"\"\n-  \"#\"\n-  \"reload_completed\"\n+  \"@\n+   #\n+   xxbrw %x0,%x1\"\n+  \"reload_completed && int_reg_operand (operands[0], SImode)\"\n   [(set (match_dup 0)\t\t\t\t\t; DABC\n \t(rotate:SI (match_dup 1)\n \t\t   (const_int 24)))\n@@ -2481,7 +2485,9 @@\n \t\t\t(const_int 255))\n \t\t(and:SI (match_dup 0)\n \t\t\t(const_int -256))))]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"12,4\")\n+   (set_attr \"type\" \"*,vecperm\")])\n \n ;; On systems with LDBRX/STDBRX generate the loads/stores directly, just like\n ;; we do for L{H,W}BRX and ST{H,W}BRX above.  If not, we have to generate more\n@@ -2507,11 +2513,19 @@\n \temit_insn (gen_bswapdi2_load (dest, src));\n       else if (MEM_P (dest))\n \temit_insn (gen_bswapdi2_store (dest, src));\n+      else if (TARGET_P9_VECTOR)\n+\temit_insn (gen_bswapdi2_xxbrd (dest, src));\n       else\n \temit_insn (gen_bswapdi2_reg (dest, src));\n       DONE;\n     }\n \n+  if (TARGET_P9_VECTOR && !MEM_P (src) && !MEM_P (dest))\n+    {\n+      emit_insn (gen_bswapdi2_xxbrd (dest, src));\n+      DONE;\n+    }\n+\n   if (!TARGET_POWERPC64)\n     {\n       /* 32-bit mode needs fewer scratch registers, but 32-bit addressing mode\n@@ -2537,12 +2551,19 @@\n   \"stdbrx %1,%y0\"\n   [(set_attr \"type\" \"store\")])\n \n+(define_insn \"bswapdi2_xxbrd\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=wo\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"wo\")))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xxbrd %x0,%x1\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n (define_insn \"bswapdi2_reg\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r\")\n \t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))\n    (clobber (match_scratch:DI 2 \"=&r\"))\n    (clobber (match_scratch:DI 3 \"=&r\"))]\n-  \"TARGET_POWERPC64 && TARGET_LDBRX\"\n+  \"TARGET_POWERPC64 && TARGET_LDBRX && !TARGET_P9_VECTOR\"\n   \"#\"\n   [(set_attr \"length\" \"36\")])\n \n@@ -2691,7 +2712,7 @@\n \t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n    (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n+  \"TARGET_POWERPC64 && !TARGET_P9_VECTOR && reload_completed\"\n   [(const_int 0)]\n   \"\n {"}, {"sha": "2741168bfd94bc3e52ee1bc519d4eadfe0b865b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "patch": "@@ -1,3 +1,7 @@\n+2017-11-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p9-xxbr-3.c: New test.\n+\n 2017-11-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/force-indirect-call-1.c: Merge scan strings."}, {"sha": "98ad7ebfd876339eb1d2ccd82a1a6452082b9cd5", "filename": "gcc/testsuite/gcc.target/powerpc/p9-xxbr-3.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-xxbr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f58c0d118a18f57ea9fa1ff0d8586660bdbf519/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-xxbr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-xxbr-3.c?ref=4f58c0d118a18f57ea9fa1ff0d8586660bdbf519", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mpower9-vector -O2\" } */\n+\n+/* Verify that the XXBR{H,W} instructions are generated if the value is\n+   forced to be in a vector register, and XXBRD is generated all of the\n+   time for register bswap64's.  */\n+\n+unsigned short\n+do_bswap16_mem (unsigned short *p)\n+{\n+  return __builtin_bswap16 (*p);\t/* LHBRX.  */\n+}\n+\n+unsigned short\n+do_bswap16_reg (unsigned short a)\n+{\n+  return __builtin_bswap16 (a);\t\t/* gpr sequences.  */\n+}\n+\n+void\n+do_bswap16_store (unsigned short *p, unsigned short a)\n+{\n+  *p = __builtin_bswap16 (a);\t\t/* STHBRX.  */\n+}\n+\n+unsigned short\n+do_bswap16_vect (unsigned short a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return __builtin_bswap16 (a);\t\t/* XXBRW.  */\n+}\n+\n+unsigned int\n+do_bswap32_mem (unsigned int *p)\n+{\n+  return __builtin_bswap32 (*p);\t/* LWBRX.  */\n+}\n+\n+unsigned int\n+do_bswap32_reg (unsigned int a)\n+{\n+  return __builtin_bswap32 (a);\t\t/* gpr sequences.  */\n+}\n+\n+void\n+do_bswap32_store (unsigned int *p, unsigned int a)\n+{\n+  *p = __builtin_bswap32 (a);\t\t/* STWBRX.  */\n+}\n+\n+unsigned int\n+do_bswap32_vect (unsigned int a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return __builtin_bswap32 (a);\t\t/* XXBRW.  */\n+}\n+\n+unsigned long\n+do_bswap64_mem (unsigned long *p)\n+{\n+  return __builtin_bswap64 (*p);\t/* LDBRX.  */\n+}\n+\n+unsigned long\n+do_bswap64_reg (unsigned long a)\n+{\n+  return __builtin_bswap64 (a);\t\t/* gpr sequences.  */\n+}\n+\n+void\n+do_bswap64_store (unsigned long *p, unsigned int a)\n+{\n+  *p = __builtin_bswap64 (a);\t\t/* STDBRX.  */\n+}\n+\n+double\n+do_bswap64_double (unsigned long a)\n+{\n+  return (double) __builtin_bswap64 (a);\t/* XXBRD.  */\n+}\n+\n+unsigned long\n+do_bswap64_vect (unsigned long a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\t/* XXBRD.  */\n+  return __builtin_bswap64 (a);\n+}\n+\n+/* Make sure XXBR{H,W,D} is not generated by default.  */\n+/* { dg-final { scan-assembler-times \"xxbrd\"  3  } } */\n+/* { dg-final { scan-assembler-times \"xxbrh\"  1  } } */\n+/* { dg-final { scan-assembler-times \"xxbrw\"  1  } } */\n+/* { dg-final { scan-assembler-times \"ldbrx\"  1  } } */\n+/* { dg-final { scan-assembler-times \"lhbrx\"  1  } } */\n+/* { dg-final { scan-assembler-times \"lwbrx\"  1  } } */\n+/* { dg-final { scan-assembler-times \"stdbrx\" 1  } } */\n+/* { dg-final { scan-assembler-times \"sthbrx\" 1  } } */\n+/* { dg-final { scan-assembler-times \"stwbrx\" 1  } } */"}]}