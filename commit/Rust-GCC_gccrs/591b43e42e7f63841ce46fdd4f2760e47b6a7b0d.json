{"sha": "591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "node_id": "C_kwDOANBUbNoAKDU5MWI0M2U0MmU3ZjYzODQxY2U0NmZkZDRmMjc2MGU0N2I2YTdiMGQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-05T13:43:24Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-05T13:43:24Z"}, "message": "Coercion site type checking in CallExprs must hold onto the argument type\n\nCoercion sites like CallExpr arguments must coerce the arguments for\ntype checking, but we must still insert the type of the actual argument\nfor that mapping not the coerced type. For example we might have:\n\n```rust\nfn dynamic_dispatch(t: &dyn Bar) {\n    t.baz();\n}\n\nfn main() {\n    let a = &Foo(123);\n    dynamic_dispatch(a);\n}\n```\n\nHere the argument 'a' has a type of (&ADT{Foo}) but this is coerceable to\n(&dyn{Bar}) which is fine. The backend needs to be able to detect the\ncoercion from the two types in order to generate the vtable code. This\npatch fixes the type checking such that we store the actual type of\n(&ADT{Foo}) at that argument mapping instead of the coerced one.\n\nAddresses: #700", "tree": {"sha": "ca78a39cfaa6563575ad6567d5cd30484bfcd08a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca78a39cfaa6563575ad6567d5cd30484bfcd08a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cd07341b1057961bebc8c11d70909ccac781113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd07341b1057961bebc8c11d70909ccac781113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cd07341b1057961bebc8c11d70909ccac781113"}], "stats": {"total": 23, "additions": 13, "deletions": 10}, "files": [{"sha": "05e594298dcd310f6915581c4c63e5551b270519", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "patch": "@@ -2454,22 +2454,21 @@ TypeCheckCallExpr::visit (FnType &type)\n \t  return;\n \t}\n \n-      auto resolved_argument_type = argument_expr_tyty;\n-\n       // it might be a varadic function\n       if (i < type.num_params ())\n \t{\n \t  auto fnparam = type.param_at (i);\n-\t  resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n-\t  if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  auto resolved_argument_type\n+\t    = fnparam.second->coerce (argument_expr_tyty);\n+\t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t    {\n \t      rust_error_at (argument->get_locus (),\n \t\t\t     \"Type Resolution failure on parameter\");\n \t      return;\n \t    }\n \t}\n \n-      context->insert_type (argument->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n \n       i++;\n     }\n@@ -2522,14 +2521,14 @@ TypeCheckCallExpr::visit (FnPtr &type)\n \t}\n \n       auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n \t  rust_error_at (argument->get_locus (),\n \t\t\t \"Type Resolution failure on parameter\");\n \t  return;\n \t}\n \n-      context->insert_type (argument->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n \n       i++;\n     }\n@@ -2575,14 +2574,14 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n \t}\n \n       auto resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n \t  rust_error_at (argument->get_locus (),\n \t\t\t \"Type Resolution failure on parameter\");\n \t  return;\n \t}\n \n-      context->insert_type (argument->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n \n       i++;\n     }"}, {"sha": "3ab374a97b43588de4558bf347490d2c4c627206", "filename": "gcc/testsuite/rust/compile/func3.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs?ref=591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "patch": "@@ -3,5 +3,9 @@ fn test(a: i32, b: i32) -> i32 {\n }\n \n fn main() {\n-    let a = test(1, true); // { dg-error \"expected .i32. got .bool.\" }\n+    let a = test(1, true);\n+    // { dg-error \"expected .i32. got .bool.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"Type Resolution failure on parameter\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-3 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-4 }\n }"}]}