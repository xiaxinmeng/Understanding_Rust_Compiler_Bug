{"sha": "b9a2d59104ca641614e4bbaed657a4d09b4e97bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlhMmQ1OTEwNGNhNjQxNjE0ZTRiYmFlZDY1N2E0ZDA5YjRlOTdiZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-19T21:59:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-19T21:59:58Z"}, "message": "({zero_,}extend[qh]i[dsh]i2): Rework TARGET_BYTE_OPS cases.\n\n(mov[hq]i): Likewise.\n(extend[qh]i[hsd]i2x): Add missing cases and fix typo in constraint.\n(reload_{in,out}[qh]i): Disable for TARGET_BYTE_OPS.\n\nFrom-SVN: r14496", "tree": {"sha": "675fb5c24de517a60d3ac7ea9f6ae791371fff66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/675fb5c24de517a60d3ac7ea9f6ae791371fff66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9a2d59104ca641614e4bbaed657a4d09b4e97bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a2d59104ca641614e4bbaed657a4d09b4e97bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a2d59104ca641614e4bbaed657a4d09b4e97bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a2d59104ca641614e4bbaed657a4d09b4e97bf/comments", "author": null, "committer": null, "parents": [{"sha": "e008606e0208a1dde5f1699fbe78b937025fdc56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e008606e0208a1dde5f1699fbe78b937025fdc56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e008606e0208a1dde5f1699fbe78b937025fdc56"}], "stats": {"total": 175, "additions": 114, "deletions": 61}, "files": [{"sha": "df12a611e3dcdb2f74f50c0c03bf662ddca13e6a", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 114, "deletions": 61, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a2d59104ca641614e4bbaed657a4d09b4e97bf/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a2d59104ca641614e4bbaed657a4d09b4e97bf/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=b9a2d59104ca641614e4bbaed657a4d09b4e97bf", "patch": "@@ -811,13 +811,19 @@\n    ldbu %0,%1\"\n   [(set_attr \"type\" \"shift,ld\")])\n \n-(define_insn \"zero_extendqisi2\"\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"! TARGET_BYTE_OPS\"\n   \"zapnot %1,1,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n@@ -827,13 +833,19 @@\n    ldbu %0,%1\"\n   [(set_attr \"type\" \"shift,ld\")])\n \n-(define_insn \"zero_extendqidi2\"\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"! TARGET_BYTE_OPS\"\n   \"zapnot %1,1,%0\"\n   [(set_attr \"type\" \"shift\")])\n   \n+(define_expand \"zero_extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+  \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n@@ -843,13 +855,19 @@\n    ldwu %0,%1\"\n   [(set_attr \"type\" \"shift,ld\")])\n \n-(define_insn \"zero_extendhisi2\"\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"! TARGET_BYTE_OPS\"\n   \"zapnot %1,3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n@@ -859,13 +877,19 @@\n    ldwu %0,%1\"\n   [(set_attr \"type\" \"shift,ld\")])\n \n-(define_insn \"zero_extendhidi2\"\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"zapnot %1,3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_expand \"zero_extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n (define_insn \"zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n@@ -983,17 +1007,24 @@\n \n (define_expand \"extendqihi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:QI 1 \"reg_or_unaligned_mem_operand\" \"\")\n+\t(ashift:DI (match_operand:QI 1 \"some_operand\" \"\")\n \t\t   (const_int 56)))\n    (set (match_operand:HI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n   \"\n {\n-  /* If we have a MEM (must be unaligned), extend to DImode (which we do\n+  if (TARGET_BYTE_OPS)\n+    {\n+      emit_insn (gen_extendqihi2x (operands[0],\n+\t\t\t\t   force_reg (QImode, operands[1])));\n+      DONE;\n+    }\n+ \n+ /* If we have an unaligned MEM, extend to DImode (which we do\n      specially) and then copy to the result.  */\n-  if (GET_CODE (operands[1]) == MEM)\n+  if (unaligned_memory_operand (operands[1], HImode))\n     {\n       rtx temp = gen_reg_rtx (DImode);\n \n@@ -1003,37 +1034,65 @@\n     }\n \n   operands[0] = gen_lowpart (DImode, operands[0]);\n-  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, force_reg (HImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_insn \"extendqidi2x\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"r\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(sign_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"TARGET_BYTE_OPS\"\n   \"sextb %1,%0\"\n-  [(set_attr \"type\" \"shift\")])\t;; not sure what class this belongs to\n+  [(set_attr \"type\" \"shift\")])\n \n (define_insn \"extendhidi2x\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"r\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(sign_extend:DI (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"TARGET_BYTE_OPS\"\n   \"sextw %1,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_insn \"extendqisi2x\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"sextb %1,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"extendhisi2x\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"sextw %1,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"extendqihi2x\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"sextb %1,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n (define_expand \"extendqisi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:QI 1 \"reg_or_unaligned_mem_operand\" \"\")\n+\t(ashift:DI (match_operand:QI 1 \"some_operand\" \"\")\n \t\t   (const_int 56)))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n   \"\n {\n-  /* If we have a MEM (must be unaligned), extend to a DImode form of\n+  if (TARGET_BYTE_OPS)\n+    {\n+      emit_insn (gen_extendqisi2x (operands[0],\n+\t\t\t\t   force_reg (QImode, operands[1])));\n+      DONE;\n+    }\n+\n+  /* If we have an unaligned MEM, extend to a DImode form of\n      the result (which we do specially).  */\n-  if (GET_CODE (operands[1]) == MEM)\n+  if (unaligned_memory_operand (operands[1], QImode))\n     {\n       rtx temp = gen_reg_rtx (DImode);\n \n@@ -1043,13 +1102,13 @@\n     }\n \n   operands[0] = gen_lowpart (DImode, operands[0]);\n-  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, force_reg (QImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_expand \"extendqidi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:QI 1 \"reg_or_unaligned_mem_operand\" \"\")\n+\t(ashift:DI (match_operand:QI 1 \"some_operand\" \"\")\n \t\t   (const_int 56)))\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n@@ -1060,19 +1119,12 @@\n \n   if (TARGET_BYTE_OPS)\n     {\n-      rtx temp = operands[1];\n-\n-      if (GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  temp = gen_reg_rtx (QImode);\n-\t  emit_insn (gen_movqi (temp, operands[1]));\n-\t}\n-\n-      emit_insn (gen_extendqidi2x (operands[0], temp));\n+      emit_insn (gen_extendqidi2x (operands[0],\n+\t\t\t\t   force_reg (QImode, operands[1])));\n       DONE;\n     }\n \n-  if (GET_CODE (operands[1]) == MEM)\n+  if (unaligned_memory_operand (operands[1], QImode))\n     {\n       rtx seq\n \t= gen_unaligned_extendqidi (operands[0],\n@@ -1083,23 +1135,30 @@\n       DONE;\n     }\n \n-  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, force_reg (QImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_expand \"extendhisi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:HI 1 \"reg_or_unaligned_mem_operand\" \"\")\n+\t(ashift:DI (match_operand:HI 1 \"some_operand\" \"\")\n \t\t   (const_int 48)))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 48)))]\n   \"\"\n   \"\n {\n-  /* If we have a MEM (must be unaligned), extend to a DImode form of\n+  if (TARGET_BYTE_OPS)\n+    {\n+      emit_insn (gen_extendhisi2x (operands[0],\n+\t\t\t\t   force_reg (HImode, operands[1])));\n+      DONE;\n+    }\n+\n+  /* If we have an unaligned MEM, extend to a DImode form of\n      the result (which we do specially).  */\n-  if (GET_CODE (operands[1]) == MEM)\n+  if (unaligned_memory_operand (operands[1], HImode))\n     {\n       rtx temp = gen_reg_rtx (DImode);\n \n@@ -1109,13 +1168,13 @@\n     }\n \n   operands[0] = gen_lowpart (DImode, operands[0]);\n-  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, force_reg (HImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_expand \"extendhidi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:HI 1 \"reg_or_unaligned_mem_operand\" \"\")\n+\t(ashift:DI (match_operand:HI 1 \"some_operand\" \"\")\n \t\t   (const_int 48)))\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n@@ -1126,19 +1185,12 @@\n \n   if (TARGET_BYTE_OPS)\n     {\n-      rtx temp = operands[1];\n-\n-      if (GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  temp = gen_reg_rtx (HImode);\n-\t  emit_insn (gen_movhi (temp, operands[1]));\n-\t}\n-\n-      emit_insn (gen_extendhidi2x (operands[0], temp));\n+      emit_insn (gen_extendhidi2x (operands[0],\n+\t\t\t\t   force_reg (HImode, operands[1])));\n       DONE;\n     }\n \n-  if (GET_CODE (operands[1]) == MEM)\n+  if (unaligned_memory_operand (operands[1], HImode))\n     {\n       rtx seq\n \t= gen_unaligned_extendhidi (operands[0],\n@@ -1149,7 +1201,7 @@\n       DONE;\n     }\n \n-  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, force_reg (HImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n@@ -3965,15 +4017,16 @@\n \t  && ! reg_or_0_operand (operands[1], QImode))\n \toperands[1] = force_reg (QImode, operands[1]);\n \n-      if (! CONSTANT_P (operands[1]) || input_operand (operands[1], QImode))\n-\t;\n-      else if (GET_CODE (operands[1]) == CONST_INT)\n+      if (GET_CODE (operands[1]) == CONST_INT\n+\t       && ! input_operand (operands[1], QImode))\n \t{\n-\t  operands[1]\n-\t    = alpha_emit_set_const (operands[0], QImode, INTVAL (operands[1]), 3);\n+\t  operands[1] = alpha_emit_set_const (operands[0], QImode,\n+\t\t\t\t\t      INTVAL (operands[1]), 3);\n+\n \t  if (rtx_equal_p (operands[0], operands[1]))\n \t    DONE;\n \t}\n+\n       goto def;\n     }\n \n@@ -4076,19 +4129,19 @@\n \t  && ! reg_or_0_operand (operands[1], HImode))\n \toperands[1] = force_reg (HImode, operands[1]);\n \n-      if (! CONSTANT_P (operands[1]) || input_operand (operands[1], HImode))\n-\t;\n-      else if (GET_CODE (operands[1]) == CONST_INT)\n+      if (GET_CODE (operands[1]) == CONST_INT\n+\t       && ! input_operand (operands[1], HImode))\n \t{\n-\t  operands[1]\n-\t    = alpha_emit_set_const (operands[0], HImode, INTVAL (operands[1]), 3);\n+\t  operands[1] = alpha_emit_set_const (operands[0], HImode,\n+\t\t\t\t\t      INTVAL (operands[1]), 3);\n+\n \t  if (rtx_equal_p (operands[0], operands[1]))\n \t    DONE;\n \t}\n+\n       goto def;\n     }\n \n-\n   /* If the output is not a register, the input must be.  */\n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (HImode, operands[1]);\n@@ -4184,7 +4237,7 @@\n   [(parallel [(match_operand:QI 0 \"register_operand\" \"=r\")\n \t      (match_operand:QI 1 \"unaligned_memory_operand\" \"m\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"\"\n+  \"! TARGET_BYTE_OPS\"\n   \"\n { extern rtx get_unaligned_address ();\n   rtx addr = get_unaligned_address (operands[1], 0);\n@@ -4206,7 +4259,7 @@\n   [(parallel [(match_operand:HI 0 \"register_operand\" \"=r\")\n \t      (match_operand:HI 1 \"unaligned_memory_operand\" \"m\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"\"\n+  \"! TARGET_BYTE_OPS\"\n   \"\n { extern rtx get_unaligned_address ();\n   rtx addr = get_unaligned_address (operands[1], 0);\n@@ -4228,7 +4281,7 @@\n   [(parallel [(match_operand:QI 0 \"any_memory_operand\" \"=m\")\n \t      (match_operand:QI 1 \"register_operand\" \"r\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"\"\n+  \"! TARGET_BYTE_OPS\"\n   \"\n { extern rtx get_unaligned_address ();\n \n@@ -4267,7 +4320,7 @@\n   [(parallel [(match_operand:HI 0 \"any_memory_operand\" \"=m\")\n \t      (match_operand:HI 1 \"register_operand\" \"r\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"\"\n+  \"! TARGET_BYTE_OPS\"\n   \"\n { extern rtx get_unaligned_address ();\n "}]}