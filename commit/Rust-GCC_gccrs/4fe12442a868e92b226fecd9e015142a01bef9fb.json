{"sha": "4fe12442a868e92b226fecd9e015142a01bef9fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlMTI0NDJhODY4ZTkyYjIyNmZlY2Q5ZTAxNTE0MmEwMWJlZjlmYg==", "commit": {"author": {"name": "Donald Lindsay", "email": "dlindsay@hound.cygnus.com", "date": "2000-05-03T01:22:38Z"}, "committer": {"name": "Don Lindsay", "email": "dlindsay@gcc.gnu.org", "date": "2000-05-03T01:22:38Z"}, "message": "change MIPS varargs ABI in config/mips/mips.c\n\nFrom-SVN: r33621", "tree": {"sha": "d2eeb06d23bbe0dee0f08db5da576abb0aa5a4cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2eeb06d23bbe0dee0f08db5da576abb0aa5a4cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fe12442a868e92b226fecd9e015142a01bef9fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe12442a868e92b226fecd9e015142a01bef9fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe12442a868e92b226fecd9e015142a01bef9fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe12442a868e92b226fecd9e015142a01bef9fb/comments", "author": null, "committer": null, "parents": [{"sha": "f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3"}], "stats": {"total": 470, "additions": 332, "deletions": 138}, "files": [{"sha": "e8262dde66a769847ba9ad0863cf1d78c25b25ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe12442a868e92b226fecd9e015142a01bef9fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe12442a868e92b226fecd9e015142a01bef9fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fe12442a868e92b226fecd9e015142a01bef9fb", "patch": "@@ -1,3 +1,12 @@\n+Tue May  2 18:20:31 2000  Donald Lindsay  <dlindsay@hound.cygnus.com>\n+\n+\t* config/mips/mips.c (mips_build_va_list,mips_va_start,mips_va_arg): new \n+\tABI for varargs, across all MIPS. This is incompatible because the\n+\tva_list (__builtin_va_list) structure is different, so a compilation\n+\tunit passing a va_list and a compilation unit being passed one, should\n+\tboth be compiled with the same ABI. (The old structure had two \n+\tpointers, now it has three.)\n+\n Tue May  2 19:18:43 2000  Jason Eckhardt  <jle@cygnus.com>\n \n         * bb-reorder.c (struct reorder_block_def): Remove members end,"}, {"sha": "9af4afd146d813c2d9eb8d4f37c3f68efa2437a3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 323, "deletions": 138, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe12442a868e92b226fecd9e015142a01bef9fb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe12442a868e92b226fecd9e015142a01bef9fb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4fe12442a868e92b226fecd9e015142a01bef9fb", "patch": "@@ -4138,124 +4138,211 @@ function_arg_partial_nregs (cum, mode, type, named)\n   return 0;\n }\n \f\n-/* Create the va_list data type.  */\n+/* Create the va_list data type.\n+   We keep 3 pointers, and two offsets.\n+   Two pointers are to the overflow area, which starts at the CFA. \n+     One of these is constant, for addressing into the GPR save area below it.\n+     The other is advanced up the stack through the overflow region.\n+   The third pointer is to the GPR save area.  Since the FPR save area\n+     is just below it, we can address FPR slots off this pointer.\n+   We also keep two one-byte offsets, which are to be subtracted from the\n+     constant pointers to yield addresses in the GPR and FPR save areas.\n+     These are downcounted as float or non-float arguments are used, \n+     and when they get to zero, the argument must be obtained from the \n+     overflow region.\n+   If TARGET_SOFT_FLOAT or TARGET_SINGLE_FLOAT, then no FPR save area exists,\n+     and a single pointer is enough.  It's started at the GPR save area,\n+     and is advanced, period.\n+   Note that the GPR save area is not constant size, due to optimization\n+     in the prologue.  Hence, we can't use a design with two pointers\n+     and two offsets, although we could have designed this with two pointers\n+     and three offsets. */\n+\n \n tree\n mips_build_va_list ()\n {\n   if (mips_abi == ABI_EABI && !TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n     {\n-      tree f_fpr, f_rem, f_gpr, record;\n+      tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff, record;\n \n       record = make_node (RECORD_TYPE);\n \n-      f_fpr = build_decl (FIELD_DECL, get_identifier (\"__fp_regs\"),\n+      f_ovfl = build_decl (FIELD_DECL, get_identifier (\"__overflow_argptr\"),\n+\t\t\t  ptr_type_node);\n+      f_gtop = build_decl (FIELD_DECL, get_identifier (\"__gpr_top\"),\n \t\t\t  ptr_type_node);\n-      f_rem = build_decl (FIELD_DECL, get_identifier (\"__fp_left\"),\n-\t\t\t  integer_type_node);\n-      f_gpr = build_decl (FIELD_DECL, get_identifier (\"__gp_regs\"),\n+      f_ftop = build_decl (FIELD_DECL, get_identifier (\"__fpr_top\"),\n \t\t\t  ptr_type_node);\n+      f_goff = build_decl (FIELD_DECL, get_identifier (\"__gpr_offset\"),\n+\t\t\t  unsigned_char_type_node);\n+      f_foff = build_decl (FIELD_DECL, get_identifier (\"__fpr_offset\"),\n+\t\t\t  unsigned_char_type_node);\n \n-      DECL_FIELD_CONTEXT (f_fpr) = record;\n-      DECL_FIELD_CONTEXT (f_rem) = record;\n-      DECL_FIELD_CONTEXT (f_gpr) = record;\n \n-      TYPE_FIELDS (record) = f_fpr;\n-      TREE_CHAIN (f_fpr) = f_rem;\n-      TREE_CHAIN (f_rem) = f_gpr;\n+      DECL_FIELD_CONTEXT (f_ovfl) = record;\n+      DECL_FIELD_CONTEXT (f_gtop) = record;\n+      DECL_FIELD_CONTEXT (f_ftop) = record;\n+      DECL_FIELD_CONTEXT (f_goff) = record;\n+      DECL_FIELD_CONTEXT (f_foff) = record;\n \n-      layout_type (record);\n+      TYPE_FIELDS (record) = f_ovfl;\n+      TREE_CHAIN (f_ovfl) = f_gtop;\n+      TREE_CHAIN (f_gtop) = f_ftop;\n+      TREE_CHAIN (f_ftop) = f_goff;\n+      TREE_CHAIN (f_goff) = f_foff;\n \n+      layout_type (record);\n       return record;\n     }\n   else\n     return ptr_type_node;\n }\n \n-/* Implement va_start.  */\n+/* Implement va_start.   stdarg_p is 0 if implementing\n+   __builtin_varargs_va_start, 1 if implementing __builtin_stdarg_va_start.\n+   Note that this routine isn't called when compiling e.g. \"_vfprintf_r\".\n+     (It doesn't have \"...\", so it inherits the pointers of its caller.) */\n \n void\n mips_va_start (stdarg_p, valist, nextarg)\n      int stdarg_p;\n      tree valist;\n      rtx nextarg;\n {\n-  int arg_words;\n+  int int_arg_words;\n   tree t;\n \n-  arg_words = current_function_args_info.arg_words;\n+  /* Find out how many non-float named formals */\n+  int_arg_words = current_function_args_info.arg_words;\n \n   if (mips_abi == ABI_EABI)\n     {\n+      int gpr_save_area_size;\n+      /* Note UNITS_PER_WORD is 4 bytes or 8, depending on TARGET_64BIT. */\n+      if (int_arg_words < 8 )\n+\t/* Adjust for the prologue's economy measure */\n+\tgpr_save_area_size = (8 - int_arg_words) * UNITS_PER_WORD;\n+      else\n+\tgpr_save_area_size = 0;\n+\n       if (!TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n \t{\n-\t  tree f_fpr, f_rem, f_gpr, fpr, rem, gpr;\n-\t  tree gprv, fprv;\n-\t  int gpro, fpro;\n-\n-  \t  fpro = (8 - current_function_args_info.fp_arg_words);\n-\n+\t  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff; \n+\t  tree ovfl, gtop, ftop, goff, foff; \n+\t  tree gprv;\n+\t  int float_formals, fpr_offset, size_excess, floats_passed_in_regs;\n+\t  int fpr_save_offset;\n+\n+\t  float_formals = current_function_args_info.fp_arg_words;\n+\t  /* If mips2, the number of formals is half the reported # of words */\n+\t  if (!TARGET_64BIT)\n+\t    float_formals /= 2;\n+\t  floats_passed_in_regs = (TARGET_64BIT ? 8 : 4);\n+\n+\t  f_ovfl  = TYPE_FIELDS (va_list_type_node);\n+\t  f_gtop = TREE_CHAIN (f_ovfl);\n+\t  f_ftop = TREE_CHAIN (f_gtop);\n+\t  f_goff = TREE_CHAIN (f_ftop);\n+\t  f_foff = TREE_CHAIN (f_goff);\n+\n+\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl);\n+\t  gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop);\n+\t  ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop);\n+\t  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n+\t  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n+\n+\t  /* Emit code setting a pointer into the overflow (shared-stack) area.\n+\t     If there were more than 8 non-float formals, or more than 8\n+\t     float formals, then this pointer isn't to the base of the area.\n+\t     In that case, it must point to where the first vararg is. */\n+\t  size_excess = 0;\n+\t  if (float_formals > floats_passed_in_regs)\n+\t    size_excess += (float_formals-floats_passed_in_regs) * 8;\n+\t  if (int_arg_words > 8)\n+\t    size_excess += (int_arg_words-8) * UNITS_PER_WORD;\n+\n+\t  /* FIXME: for mips2, the above size_excess can be wrong.  Because the\n+\t     overflow stack holds mixed size items, there can be alignments,\n+\t     so that an 8 byte double following a 4 byte int will be on an\n+\t     8 byte boundary.  This means that the above calculation should\n+\t     take into account the exact sequence of floats and non-floats\n+\t     which make up the excess.  That calculation should be rolled\n+\t     into the code which sets the current_function_args_info struct.  \n+\t     The above then reduces to a fetch from that struct. */\n+\n+\n+\t  t = make_tree (TREE_TYPE (ovfl), virtual_incoming_args_rtx);\n+\t  if (size_excess)\n+\t    t = build (PLUS_EXPR, TREE_TYPE (ovfl), t,\n+\t\tbuild_int_2 (size_excess, 0));\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+ \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+\t  /* Emit code setting a ptr to the base of the overflow area. */\n+\t  t = make_tree (TREE_TYPE (gtop), virtual_incoming_args_rtx);\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n+ \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+\t  /* Emit code setting a pointer to the GPR save area.\n+\t     More precisely, a pointer to off-the-end of the FPR save area.\n+\t     If mips4, this is gpr_save_area_size below the overflow area.\n+\t     If mips2, also round down to an 8-byte boundary, since the FPR\n+\t     save area is 8-byte aligned, and GPR is 4-byte-aligned.\n+\t     Therefore there can be a 4-byte gap between the save areas. */\n+\t  gprv = make_tree (TREE_TYPE (ftop), virtual_incoming_args_rtx);\n+\t  fpr_save_offset = gpr_save_area_size;\n \t  if (!TARGET_64BIT)\n-\t\tfpro /= 2;\n-\n-\t  f_fpr = TYPE_FIELDS (va_list_type_node);\n-\t  f_rem = TREE_CHAIN (f_fpr);\n-\t  f_gpr = TREE_CHAIN (f_rem);\n-\n-\t  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-\t  rem = build (COMPONENT_REF, TREE_TYPE (f_rem), valist, f_rem);\n-\t  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-\n-\t  if (arg_words < 8)\n-\t    gpro = (8 - arg_words) * UNITS_PER_WORD;\n-\t  else\n-\t    gpro = (stdarg_p ? 0 : UNITS_PER_WORD);\n-\n-\t  gprv = make_tree (ptr_type_node, nextarg);\n-\t  if (gpro != 0)\n \t    {\n-\t      gprv = build (PLUS_EXPR, ptr_type_node, gprv,\n-\t\t\t    build_int_2 (-gpro, -1));\n+\t      if (fpr_save_offset & 7)\n+\t        fpr_save_offset += 4;\n \t    }\n-\n-\t  t = build (MODIFY_EXPR, ptr_type_node, gpr, gprv);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  if (fpr_save_offset)\n+\t    gprv = build (PLUS_EXPR, TREE_TYPE (ftop), gprv, \n+\t      \tbuild_int_2 (-fpr_save_offset,-1));\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, gprv);\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-\t  t = build (MODIFY_EXPR, integer_type_node, rem,\n-\t\t     build_int_2 (fpro, 0));\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  /* Emit code initting an offset to the size of the GPR save area */\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (goff), goff,\n+\t      \tbuild_int_2 (gpr_save_area_size,0));\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-\t  if (fpro == 0)\n-\t    fprv = gprv;\n+\t  /* Emit code initting an offset from ftop to the first float\n+\t     vararg.  This varies in size, since any float\n+\t     varargs are put in the FPR save area after the formals.\n+\t     Note it's 8 bytes/formal regardless of TARGET_64BIT.\n+\t     However, mips2 stores 4 GPRs, mips4 stores 8 GPRs.\n+\t     If there are 8 or more float formals, init to zero.\n+\t     (In fact, the formals aren't stored in the bottom of the\n+\t     FPR save area: they are elsewhere, and the size of the FPR\n+\t     save area is economized by the prologue.  But this code doesn't\n+\t     care.  This design is unaffected by that fact.) */\n+\t  if (float_formals >= floats_passed_in_regs)\n+\t    fpr_offset = 0;\n \t  else\n-\t    fprv = fold (build (PLUS_EXPR, ptr_type_node, gprv,\n-\t\t\t\tbuild_int_2 (-(fpro*8), -1)));\n-\n-\t  if (! TARGET_64BIT)\n-\t    fprv = fold (build (BIT_AND_EXPR, ptr_type_node, fprv,\n-\t\t\t\tbuild_int_2 (-8, -1)));\n-\n-\t  t = build (MODIFY_EXPR, ptr_type_node, fpr, fprv);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t    fpr_offset = (floats_passed_in_regs - float_formals) * 8;\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (foff), foff,\n+\t\t     build_int_2 (fpr_offset,0));\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t}\n       else\n \t{\n-\t  int ofs;\n+\t  /* TARGET_SOFT_FLOAT or TARGET_SINGLE_FLOAT */\n \n-\t  if (arg_words >= 8)\n-\t    ofs = (stdarg_p ? 0 : UNITS_PER_WORD);\n-\t  else\n-\t    ofs = (8 - arg_words) * UNITS_PER_WORD;\n+\t  /* Everything is in the GPR save area, or in the overflow\n+\t     area which is contiguous with it. */\n \n-\t  nextarg = plus_constant (nextarg, -ofs);\n+\t  int offset = -gpr_save_area_size;\n+\t  if (gpr_save_area_size == 0)\n+\t    offset = (stdarg_p ? 0 : -UNITS_PER_WORD);\n+\t  nextarg = plus_constant (nextarg, offset);\n \t  std_expand_builtin_va_start (1, valist, nextarg);\n \t}\n     }\n   else\n     {\n+      /* not EABI */\n       int ofs;\n \n       if (stdarg_p)\n@@ -4266,7 +4353,7 @@ mips_va_start (stdarg_p, valist, nextarg)\n \t       _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32\n \t     and both iris5.h and iris6.h define _MIPS_SIM.  */\n \t  if (mips_abi == ABI_N32 || mips_abi == ABI_64)\n-\t    ofs = (arg_words >= 8 ? -UNITS_PER_WORD : 0);\n+ \t    ofs = (int_arg_words >= 8 ? -UNITS_PER_WORD : 0);\n \t  else\n \t    ofs = -UNITS_PER_WORD;\n \t}\n@@ -4291,9 +4378,10 @@ mips_va_arg (valist, type)\n \n   if (mips_abi == ABI_EABI)\n     {\n-      tree gpr;\n       int indirect;\n-      rtx lab_over = NULL_RTX, lab_false, r;\n+      rtx r, lab_over = NULL_RTX, lab_false;\n+      tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff; \n+      tree ovfl, gtop, ftop, goff, foff; \n \n       indirect\n \t= function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n@@ -4302,93 +4390,191 @@ mips_va_arg (valist, type)\n \n       addr_rtx = gen_reg_rtx (Pmode);\n \n-      if (!TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n+      if (TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT)\n \t{\n-\t  tree f_fpr, f_rem, f_gpr, fpr, rem;\n-\n-\t  f_fpr = TYPE_FIELDS (va_list_type_node);\n-\t  f_rem = TREE_CHAIN (f_fpr);\n-\t  f_gpr = TREE_CHAIN (f_rem);\n+\t  /* Case of all args in a merged stack. No need to check bounds,\n+\t     just advance valist along the stack. */\n \n-\t  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-\t  rem = build (COMPONENT_REF, TREE_TYPE (f_rem), valist, f_rem);\n-\t  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-\n-\t  if (TREE_CODE (type) == REAL_TYPE)\n+\t  tree gpr = valist;\n+      \t  if (! indirect\n+\t      && ! TARGET_64BIT\n+\t      && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD)\n \t    {\n-\t      lab_false = gen_label_rtx ();\n-\t      lab_over = gen_label_rtx ();\n-\n-\t      r = expand_expr (rem, NULL_RTX, TYPE_MODE (TREE_TYPE (rem)),\n-\t\t\t       EXPAND_NORMAL);\n-\t      emit_cmp_and_jump_insns (r, const0_rtx, LE, const1_rtx,\n-\t\t\t\t       GET_MODE (r), 1, 1, lab_false);\n-\n-\t      t = build (PLUS_EXPR, TREE_TYPE (rem), rem,\n-\t\t\t build_int_2 (-1, -1));\n-\t      t = build (MODIFY_EXPR, TREE_TYPE (rem), rem, t);\n-\t      TREE_SIDE_EFFECTS (t) = 1;\n+\t      t = build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t     build_int_2 (2*UNITS_PER_WORD - 1, 0));\n+\t      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, \n+\t\t     build_int_2 (-2*UNITS_PER_WORD, -1));\n+\t      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n \t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t    }\n \n-\t      t = build (POSTINCREMENT_EXPR, TREE_TYPE (fpr), fpr,\n-\t\t\t build_int_2 (8, 0));\n-\t      TREE_SIDE_EFFECTS (t) = 1;\n-\t      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-\t      if (r != addr_rtx)\n-\t\temit_move_insn (addr_rtx, r);\n+      \t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr, \n+\t\tsize_int (rsize));\n+      \t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+     \t  if (r != addr_rtx)\n+\t    emit_move_insn (addr_rtx, r);\n \n-\t      /* Ensure that the POSTINCREMENT is emitted before lab_over */\n-\t      emit_queue();\n+      \t  /* flush the POSTINCREMENT */\n+      \t  emit_queue();\n \n-\t      emit_jump (lab_over);\n-\t      emit_barrier ();\n-\t      emit_label (lab_false);\n+      \t  if (indirect)\n+\t    {\n+\t      r = gen_rtx_MEM (Pmode, addr_rtx);\n+\t      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+\t      emit_move_insn (addr_rtx, r);\n \t    }\n-\t}\n-      else\n-\tgpr = valist;\n-\n-      if (! indirect\n-\t  && ! TARGET_64BIT\n-\t  && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD)\n-\t{\n-\t  t = build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t     build_int_2 (2*UNITS_PER_WORD - 1, 0));\n-\t  t = build (BIT_AND_EXPR, TREE_TYPE (t), t, \n-\t\t     build_int_2 (-2*UNITS_PER_WORD, -1));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      \t  else\n+\t    {\n+\t      if (BYTES_BIG_ENDIAN && rsize != size)\n+\t      addr_rtx = plus_constant (addr_rtx, rsize - size);\n+\t    }\n+      \t  return addr_rtx;\n \t}\n \n-      t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr, size_int (rsize));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-      if (r != addr_rtx)\n-\temit_move_insn (addr_rtx, r);\n+      /* Not a simple merged stack.  Need ptrs and indexes left by va_start. */\n+\n+      f_ovfl  = TYPE_FIELDS (va_list_type_node);\n+      f_gtop = TREE_CHAIN (f_ovfl);\n+      f_ftop = TREE_CHAIN (f_gtop);\n+      f_goff = TREE_CHAIN (f_ftop);\n+      f_foff = TREE_CHAIN (f_goff);\n+\n+      ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl);\n+      gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop);\n+      ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop);\n+      goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n+      foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n+\n+      lab_false = gen_label_rtx ();\n+      lab_over = gen_label_rtx ();\n+\n+      if (TREE_CODE (type) == REAL_TYPE)\n+        {\n+\n+\t  /* Emit code to branch if foff == 0. */\n+          r = expand_expr (foff, NULL_RTX, TYPE_MODE (TREE_TYPE (foff)),\n+\t     \tEXPAND_NORMAL);\n+          emit_cmp_and_jump_insns (r, const0_rtx, EQ,\n+\t\tconst1_rtx, GET_MODE (r), 1, 1, lab_false);\n+\n+          /* Emit code for addr_rtx = ftop - foff */\n+          t = build (MINUS_EXPR, TREE_TYPE (ftop), ftop, foff );\n+          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+          if (r != addr_rtx)\n+      \t    emit_move_insn (addr_rtx, r);\n+\n+          /* Emit code for foff-=8. \n+      \t     Advances the offset up FPR save area by one double */\n+          t = build (MINUS_EXPR, TREE_TYPE (foff), foff, build_int_2 (8, 0));\n+          t = build (MODIFY_EXPR, TREE_TYPE (foff), foff, t);\n+          expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+          emit_queue();\n+          emit_jump (lab_over);\n+          emit_barrier ();\n+          emit_label (lab_false);\n+\t      \n+\t  if (!TARGET_64BIT) \n+\t    {\n+\t      /* For mips2, the overflow area contains mixed size items.\n+\t\t If a 4-byte int is followed by an 8-byte float, then\n+\t\t natural alignment causes a 4 byte gap.\n+\t\t So, dynamically adjust ovfl up to a multiple of 8. */\n+\t      t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), ovfl,\n+\t\t\tbuild_int_2 (7, 0));\n+\t      t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+\t      t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+\t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t    }\n \n-      /* Ensure that the above POSTINCREMENT is emitted before lab_over */\n-      emit_queue();\n+          /* Emit code for addr_rtx = the ovfl pointer into overflow area.\n+\t     Regardless of mips2, postincrement the ovfl pointer by 8. */\n+          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl, \n+\t\tsize_int (8));\n+          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+          if (r != addr_rtx)\n+      \t    emit_move_insn (addr_rtx, r);\n+\n+          emit_queue();\n+          emit_label (lab_over);\n+       \t  return addr_rtx;\n+        }\n+      else\n+        {\n+          /* not REAL_TYPE */\n+\t  int step_size;\n \n-      if (lab_over)\n-\temit_label (lab_over);\n+\t  if (! TARGET_64BIT\n+\t      && TREE_CODE (type) == INTEGER_TYPE\n+\t      && TYPE_PRECISION (type) == 64)\n+\t    {\n+\t      /* In mips2, int takes 32 bits of the GPR save area, but \n+\t\t longlong takes an aligned 64 bits.  So, emit code\n+\t\t to zero the low order bits of goff, thus aligning\n+\t\t the later calculation of (gtop-goff) upwards. */\n+\t       t = build (BIT_AND_EXPR, TREE_TYPE (goff), goff,\n+\t\t\tbuild_int_2 (-8, -1));\n+\t       t = build (MODIFY_EXPR, TREE_TYPE (goff), goff, t);\n+\t       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t    }\n \n-      if (indirect)\n-\t{\n-\t  r = gen_rtx_MEM (Pmode, addr_rtx);\n-\t  MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n-\t  emit_move_insn (addr_rtx, r);\n-\t}\n-      else\n-\t{\n-\t  if (BYTES_BIG_ENDIAN && rsize != size)\n-\t    addr_rtx = plus_constant (addr_rtx, rsize - size);\n+\t  /* Emit code to branch if goff == 0. */\n+          r = expand_expr (goff, NULL_RTX, TYPE_MODE (TREE_TYPE (goff)),\n+\t     \tEXPAND_NORMAL);\n+          emit_cmp_and_jump_insns (r, const0_rtx, EQ,\n+\t\tconst1_rtx, GET_MODE (r), 1, 1, lab_false);\n+\n+          /* Emit code for addr_rtx = gtop - goff. */\n+          t = build (MINUS_EXPR, TREE_TYPE (gtop), gtop, goff);\n+          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+          if (r != addr_rtx)\n+      \t    emit_move_insn (addr_rtx, r);\n+\n+\t  /* Note that mips2 int is 32 bit, but mips2 longlong is 64. */\n+\t  if (! TARGET_64BIT && TYPE_PRECISION (type) == 64)\n+\t    step_size = 8;\n+\t  else\n+\t    step_size = UNITS_PER_WORD;\n+\n+          /* Emit code for goff = goff - step_size.\n+      \t     Advances the offset up GPR save area over the item. */\n+          t = build (MINUS_EXPR, TREE_TYPE (goff), goff, \n+\t\tbuild_int_2 (step_size, 0));\n+          t = build (MODIFY_EXPR, TREE_TYPE (goff), goff, t);\n+          expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+          emit_queue();\n+          emit_jump (lab_over);\n+          emit_barrier ();\n+          emit_label (lab_false);\n+\t      \n+          /* Emit code for addr_rtx -> overflow area, postinc by step_size */\n+          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl, \n+\t    \tsize_int (step_size));\n+          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+          if (r != addr_rtx)\n+    \t    emit_move_insn (addr_rtx, r);\n+\n+          emit_queue();\n+          emit_label (lab_over);\n+\n+          if (indirect)\n+   \t    {\n+       \t      r = gen_rtx_MEM (Pmode, addr_rtx);\n+\t      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+\t      emit_move_insn (addr_rtx, r);\n+\t    }\n+      \t  else\n+\t    {\n+\t      if (BYTES_BIG_ENDIAN && rsize != size)\n+\t      addr_rtx = plus_constant (addr_rtx, rsize - size);\n+\t    }\n+      \t  return addr_rtx;\n \t}\n-\n-      return addr_rtx;\n     }\n   else\n     {\n+      /* Not EABI. */\n       int align;\n \n       /* ??? The original va-mips.h did always align, despite the fact \n@@ -4406,7 +4592,6 @@ mips_va_arg (valist, type)\n \t\t build_int_2 (align - 1, 0));\n       t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n       t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Everything past the alignment is standard.  */"}]}