{"sha": "8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNiNjViMzcyNWYwYzMxYTNlYTVkNWI4ZGUzN2VhY2JhNTU0NjJmMw==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2014-08-21T09:32:21Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2014-08-21T09:32:21Z"}, "message": "re PR tree-optimization/62112 (Optimize out malloc when block is unused or write-only)\n\n2014-08-21  Marc Glisse  <marc.glisse@inria.fr>\n\n\tPR tree-optimization/62112\ngcc/\n\t* gimple-iterator.c (gsi_replace): Return whether EH cleanup is needed.\n\t* gimple-iterator.h (gsi_replace): Return bool.\n\t* tree-ssa-alias.c (ref_may_alias_global_p_1): New helper, code\n\tmoved from ref_may_alias_global_p.\n\t(ref_may_alias_global_p, refs_may_alias_p, ref_maybe_used_by_stmt_p):\n\tNew overloads.\n\t(ref_maybe_used_by_call_p): Take ao_ref* instead of tree.\n\t(stmt_kills_ref_p_1): Rename...\n\t(stmt_kills_ref_p): ... to this.\n\t* tree-ssa-alias.h (ref_may_alias_global_p, ref_maybe_used_by_stmt_p,\n\tstmt_kills_ref_p): Declare.\n\t* tree-ssa-dse.c (dse_possible_dead_store_p): New argument, use it.\n\tMove the self-assignment case...\n\t(dse_optimize_stmt): ... here. Handle builtin calls. Remove dead code.\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/pr62112-1.c: New file.\n\t* gcc.dg/tree-ssa/pr62112-2.c: Likewise.\n\t* gcc.c-torture/execute/pr35472.c: Add noclone attribute.\n\t* gcc.c-torture/execute/20071219-1.c: Likewise.\n\nFrom-SVN: r214262", "tree": {"sha": "773cf046c0dfd55437a213c2c0d6c24b378ad71e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/773cf046c0dfd55437a213c2c0d6c24b378ad71e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31879c2cc7b5d8f302b5020de41b9439ef764b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31879c2cc7b5d8f302b5020de41b9439ef764b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31879c2cc7b5d8f302b5020de41b9439ef764b65"}], "stats": {"total": 254, "additions": 191, "deletions": 63}, "files": [{"sha": "5d9fc45c06fa27f3650cc9eba48b985805167034", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -1,3 +1,21 @@\n+2014-08-21  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/62112\n+\t* gimple-iterator.c (gsi_replace): Return whether EH cleanup is needed.\n+\t* gimple-iterator.h (gsi_replace): Return bool.\n+\t* tree-ssa-alias.c (ref_may_alias_global_p_1): New helper, code\n+\tmoved from ref_may_alias_global_p.\n+\t(ref_may_alias_global_p, refs_may_alias_p, ref_maybe_used_by_stmt_p):\n+\tNew overloads.\n+\t(ref_maybe_used_by_call_p): Take ao_ref* instead of tree.\n+\t(stmt_kills_ref_p_1): Rename...\n+\t(stmt_kills_ref_p): ... to this.\n+\t* tree-ssa-alias.h (ref_may_alias_global_p, ref_maybe_used_by_stmt_p,\n+\tstmt_kills_ref_p): Declare.\n+\t* tree-ssa-dse.c (dse_possible_dead_store_p): New argument, use it.\n+\tMove the self-assignment case...\n+\t(dse_optimize_stmt): ... here. Handle builtin calls. Remove dead code.\n+\n 2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* rtl.h (try_split): Strengthen return type from rtx to rtx_insn *."}, {"sha": "7077dcec0a888e5e909df90b373d0b0f7bd4404b", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -429,15 +429,17 @@ gsi_split_seq_before (gimple_stmt_iterator *i, gimple_seq *pnew_seq)\n /* Replace the statement pointed-to by GSI to STMT.  If UPDATE_EH_INFO\n    is true, the exception handling information of the original\n    statement is moved to the new statement.  Assignments must only be\n-   replaced with assignments to the same LHS.  */\n+   replaced with assignments to the same LHS.  Returns whether EH edge\n+   cleanup is required.  */\n \n-void\n+bool\n gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n {\n   gimple orig_stmt = gsi_stmt (*gsi);\n+  bool require_eh_edge_purge = false;\n \n   if (stmt == orig_stmt)\n-    return;\n+    return false;\n \n   gcc_assert (!gimple_has_lhs (orig_stmt) || !gimple_has_lhs (stmt)\n \t      || gimple_get_lhs (orig_stmt) == gimple_get_lhs (stmt));\n@@ -448,7 +450,7 @@ gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n   /* Preserve EH region information from the original statement, if\n      requested by the caller.  */\n   if (update_eh_info)\n-    maybe_clean_or_replace_eh_stmt (orig_stmt, stmt);\n+    require_eh_edge_purge = maybe_clean_or_replace_eh_stmt (orig_stmt, stmt);\n \n   gimple_duplicate_stmt_histograms (cfun, stmt, cfun, orig_stmt);\n \n@@ -460,6 +462,7 @@ gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n   gsi_set_stmt (gsi, stmt);\n   gimple_set_modified (stmt, true);\n   update_modified_stmt (stmt);\n+  return require_eh_edge_purge;\n }\n \n "}, {"sha": "b117b4b78d5fdc6252198b563c5756a6684d06af", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -58,7 +58,7 @@ extern void gsi_insert_seq_after (gimple_stmt_iterator *, gimple_seq,\n extern gimple_seq gsi_split_seq_after (gimple_stmt_iterator);\n extern void gsi_set_stmt (gimple_stmt_iterator *, gimple);\n extern void gsi_split_seq_before (gimple_stmt_iterator *, gimple_seq *);\n-extern void gsi_replace (gimple_stmt_iterator *, gimple, bool);\n+extern bool gsi_replace (gimple_stmt_iterator *, gimple, bool);\n extern void gsi_replace_with_seq (gimple_stmt_iterator *, gimple_seq, bool);\n extern void gsi_insert_before_without_update (gimple_stmt_iterator *, gimple,\n \t\t\t\t\t      enum gsi_iterator_update);"}, {"sha": "681733b38601106e90fb184bd6825105ff632fcb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -1,3 +1,11 @@\n+2014-08-21  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/62112\n+\t* gcc.dg/tree-ssa/pr62112-1.c: New file.\n+\t* gcc.dg/tree-ssa/pr62112-2.c: Likewise.\n+\t* gcc.c-torture/execute/pr35472.c: Add noclone attribute.\n+\t* gcc.c-torture/execute/20071219-1.c: Likewise.\n+\n 2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* testsuite/gcc.target/powerpc/builtins-1.c: New test."}, {"sha": "aabf976e111995c076cbbfb69406b6dc357b0812", "filename": "gcc/testsuite/gcc.c-torture/execute/20071219-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20071219-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20071219-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20071219-1.c?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -10,7 +10,7 @@ struct S\n \n struct S *p;\n \n-void __attribute__((noinline))\n+void __attribute__((noinline,noclone))\n foo (struct S *x, int set)\n {\n   int i;\n@@ -22,7 +22,7 @@ foo (struct S *x, int set)\n   p = x;\n }\n \n-void __attribute__((noinline))\n+void __attribute__((noinline,noclone))\n test1 (void)\n {\n   struct S a;\n@@ -35,7 +35,7 @@ test1 (void)\n   foo (&b, 0);\n }\n \n-void __attribute__((noinline))\n+void __attribute__((noinline,noclone))\n test2 (void)\n {\n   struct S a;\n@@ -48,7 +48,7 @@ test2 (void)\n   foo (&b, 0);\n }\n \n-void __attribute__((noinline))\n+void __attribute__((noinline,noclone))\n test3 (void)\n {\n   struct S a;"}, {"sha": "6981dd812a8ce0e6891fd890b17ad256ef28b359", "filename": "gcc/testsuite/gcc.c-torture/execute/pr35472.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr35472.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr35472.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr35472.c?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -2,7 +2,7 @@ extern void abort (void);\n extern void *memset (void *s, int c, __SIZE_TYPE__ n);\n struct S { int i[16]; };\n struct S *p;\n-void __attribute__((noinline))\n+void __attribute__((noinline,noclone))\n foo(struct S *a, struct S *b) { a->i[0] = -1; p = b; }\n void test (void)\n {"}, {"sha": "ea3f29b3a6f0cb158f27c84010698e85655496a1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr62112-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr62112-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr62112-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr62112-1.c?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-dse1-details\" } */\n+\n+void f(){\n+  char*p=__builtin_malloc(42);\n+  __builtin_memset(p,3,10);\n+  __builtin_memset(p,7,33);\n+}\n+char*g;\n+void h(){\n+  char*p=__builtin_malloc(42);\n+  g=__builtin_memset(p,3,10);\n+  __builtin_free(p);\n+}\n+char*i(){\n+  char*p=__builtin_malloc(42);\n+  __builtin_memset(p,3,10);\n+  __builtin_memset(p,7,33);\n+  return p;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead call\" 4 \"dse1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dse1\" } } */"}, {"sha": "c5bc9222896f3c5905951fb4689a87485536e32b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr62112-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr62112-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr62112-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr62112-2.c?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-dse1-details\" } */\n+\n+char*g;\n+char* f(){\n+  char*p=__builtin_malloc(42);\n+  __builtin_memset(p,3,33);\n+  __builtin_memset(p,7,10);\n+  return p;\n+}\n+void h(){\n+  char*p=__builtin_malloc(42);\n+  g=__builtin_memset(p,3,10);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Deleted dead\" \"dse1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dse1\" } } */"}, {"sha": "442112adb63b5141dc96bc881a6b5b85b2ac2aa1", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -330,12 +330,11 @@ ptr_deref_may_alias_ref_p_1 (tree ptr, ao_ref *ref)\n   return true;\n }\n \n-/* Return true whether REF may refer to global memory.  */\n+/* Returns whether reference REF to BASE may refer to global memory.  */\n \n-bool\n-ref_may_alias_global_p (tree ref)\n+static bool\n+ref_may_alias_global_p_1 (tree base)\n {\n-  tree base = get_base_address (ref);\n   if (DECL_P (base))\n     return is_global_var (base);\n   else if (TREE_CODE (base) == MEM_REF\n@@ -344,6 +343,20 @@ ref_may_alias_global_p (tree ref)\n   return true;\n }\n \n+bool\n+ref_may_alias_global_p (ao_ref *ref)\n+{\n+  tree base = ao_ref_base (ref);\n+  return ref_may_alias_global_p_1 (base);\n+}\n+\n+bool\n+ref_may_alias_global_p (tree ref)\n+{\n+  tree base = get_base_address (ref);\n+  return ref_may_alias_global_p_1 (base);\n+}\n+\n /* Return true whether STMT may clobber global memory.  */\n \n bool\n@@ -1413,6 +1426,14 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n #endif\n }\n \n+static bool\n+refs_may_alias_p (tree ref1, ao_ref *ref2)\n+{\n+  ao_ref r1;\n+  ao_ref_init (&r1, ref1);\n+  return refs_may_alias_p_1 (&r1, ref2, true);\n+}\n+\n bool\n refs_may_alias_p (tree ref1, tree ref2)\n {\n@@ -1769,12 +1790,10 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n }\n \n static bool\n-ref_maybe_used_by_call_p (gimple call, tree ref)\n+ref_maybe_used_by_call_p (gimple call, ao_ref *ref)\n {\n-  ao_ref r;\n   bool res;\n-  ao_ref_init (&r, ref);\n-  res = ref_maybe_used_by_call_p_1 (call, &r);\n+  res = ref_maybe_used_by_call_p_1 (call, ref);\n   if (res)\n     ++alias_stats.ref_maybe_used_by_call_p_may_alias;\n   else\n@@ -1787,7 +1806,7 @@ ref_maybe_used_by_call_p (gimple call, tree ref)\n    true, otherwise return false.  */\n \n bool\n-ref_maybe_used_by_stmt_p (gimple stmt, tree ref)\n+ref_maybe_used_by_stmt_p (gimple stmt, ao_ref *ref)\n {\n   if (is_gimple_assign (stmt))\n     {\n@@ -1810,14 +1829,13 @@ ref_maybe_used_by_stmt_p (gimple stmt, tree ref)\n   else if (gimple_code (stmt) == GIMPLE_RETURN)\n     {\n       tree retval = gimple_return_retval (stmt);\n-      tree base;\n       if (retval\n \t  && TREE_CODE (retval) != SSA_NAME\n \t  && !is_gimple_min_invariant (retval)\n \t  && refs_may_alias_p (retval, ref))\n \treturn true;\n       /* If ref escapes the function then the return acts as a use.  */\n-      base = get_base_address (ref);\n+      tree base = ao_ref_base (ref);\n       if (!base)\n \t;\n       else if (DECL_P (base))\n@@ -1831,6 +1849,14 @@ ref_maybe_used_by_stmt_p (gimple stmt, tree ref)\n   return true;\n }\n \n+bool\n+ref_maybe_used_by_stmt_p (gimple stmt, tree ref)\n+{\n+  ao_ref r;\n+  ao_ref_init (&r, ref);\n+  return ref_maybe_used_by_stmt_p (stmt, &r);\n+}\n+\n /* If the call in statement CALL may clobber the memory reference REF\n    return true, otherwise return false.  */\n \n@@ -2169,8 +2195,8 @@ stmt_may_clobber_ref_p (gimple stmt, tree ref)\n /* If STMT kills the memory reference REF return true, otherwise\n    return false.  */\n \n-static bool\n-stmt_kills_ref_p_1 (gimple stmt, ao_ref *ref)\n+bool\n+stmt_kills_ref_p (gimple stmt, ao_ref *ref)\n {\n   if (!ao_ref_base (ref))\n     return false;\n@@ -2357,7 +2383,7 @@ stmt_kills_ref_p (gimple stmt, tree ref)\n {\n   ao_ref r;\n   ao_ref_init (&r, ref);\n-  return stmt_kills_ref_p_1 (stmt, &r);\n+  return stmt_kills_ref_p (stmt, &r);\n }\n \n "}, {"sha": "436381a9519d447ec204a3bb0a8e76c1623b4b13", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -101,17 +101,20 @@ extern alias_set_type ao_ref_alias_set (ao_ref *);\n extern bool ptr_deref_may_alias_global_p (tree);\n extern bool ptr_derefs_may_alias_p (tree, tree);\n extern bool ref_may_alias_global_p (tree);\n+extern bool ref_may_alias_global_p (ao_ref *);\n extern bool refs_may_alias_p (tree, tree);\n extern bool refs_may_alias_p_1 (ao_ref *, ao_ref *, bool);\n extern bool refs_anti_dependent_p (tree, tree);\n extern bool refs_output_dependent_p (tree, tree);\n extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n+extern bool ref_maybe_used_by_stmt_p (gimple, ao_ref *);\n extern bool stmt_may_clobber_global_p (gimple);\n extern bool stmt_may_clobber_ref_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p_1 (gimple, ao_ref *);\n extern bool call_may_clobber_ref_p (gimple, tree);\n extern bool call_may_clobber_ref_p_1 (gimple, ao_ref *);\n extern bool stmt_kills_ref_p (gimple, tree);\n+extern bool stmt_kills_ref_p (gimple, ao_ref *);\n extern tree get_continuation_for_phi (gimple, ao_ref *,\n \t\t\t\t      unsigned int *, bitmap *, bool,\n \t\t\t\t      void *(*)(ao_ref *, tree, void *, bool),"}, {"sha": "6e6204ab90174747eee210752fc92030beb15217", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 69, "deletions": 39, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cb65b3725f0c31a3ea5d5b8de37eacba55462f3/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=8cb65b3725f0c31a3ea5d5b8de37eacba55462f3", "patch": "@@ -82,25 +82,18 @@ static bitmap need_eh_cleanup;\n \n \n /* A helper of dse_optimize_stmt.\n-   Given a GIMPLE_ASSIGN in STMT, find a candidate statement *USE_STMT that\n-   may prove STMT to be dead.\n+   Given a GIMPLE_ASSIGN in STMT that writes to REF, find a candidate\n+   statement *USE_STMT that may prove STMT to be dead.\n    Return TRUE if the above conditions are met, otherwise FALSE.  */\n \n static bool\n-dse_possible_dead_store_p (gimple stmt, gimple *use_stmt)\n+dse_possible_dead_store_p (ao_ref *ref, gimple stmt, gimple *use_stmt)\n {\n   gimple temp;\n   unsigned cnt = 0;\n \n   *use_stmt = NULL;\n \n-  /* Self-assignments are zombies.  */\n-  if (operand_equal_p (gimple_assign_rhs1 (stmt), gimple_assign_lhs (stmt), 0))\n-    {\n-      *use_stmt = stmt;\n-      return true;\n-    }\n-\n   /* Find the first dominated statement that clobbers (part of) the\n      memory stmt stores to with no intermediate statement that may use\n      part of the memory stmt stores.  That is, find a store that may\n@@ -164,8 +157,7 @@ dse_possible_dead_store_p (gimple stmt, gimple *use_stmt)\n \t\ttemp = use_stmt;\n \t    }\n \t  /* If the statement is a use the store is not dead.  */\n-\t  else if (ref_maybe_used_by_stmt_p (use_stmt,\n-\t\t\t\t\t     gimple_assign_lhs (stmt)))\n+\t  else if (ref_maybe_used_by_stmt_p (use_stmt, ref))\n \t    {\n \t      fail = true;\n \t      BREAK_FROM_IMM_USE_STMT (ui);\n@@ -191,15 +183,15 @@ dse_possible_dead_store_p (gimple stmt, gimple *use_stmt)\n \t just pretend the stmt makes itself dead.  Otherwise fail.  */\n       if (!temp)\n \t{\n-\t  if (stmt_may_clobber_global_p (stmt))\n+\t  if (ref_may_alias_global_p (ref))\n \t    return false;\n \n \t  temp = stmt;\n \t  break;\n \t}\n     }\n   /* Continue walking until we reach a kill.  */\n-  while (!stmt_kills_ref_p (temp, gimple_assign_lhs (stmt)));\n+  while (!stmt_kills_ref_p (temp, ref));\n \n   *use_stmt = temp;\n \n@@ -228,23 +220,78 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n   if (!gimple_vdef (stmt))\n     return;\n \n-  /* We know we have virtual definitions.  If this is a GIMPLE_ASSIGN\n-     that's not also a function call, then record it into our table.  */\n-  if (is_gimple_call (stmt) && gimple_call_fndecl (stmt))\n-    return;\n-\n   /* Don't return early on *this_2(D) ={v} {CLOBBER}.  */\n   if (gimple_has_volatile_ops (stmt)\n       && (!gimple_clobber_p (stmt)\n \t  || TREE_CODE (gimple_assign_lhs (stmt)) != MEM_REF))\n     return;\n \n+  /* We know we have virtual definitions.  We can handle assignments and\n+     some builtin calls.  */\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    {\n+      switch (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)))\n+\t{\n+\t  case BUILT_IN_MEMCPY:\n+\t  case BUILT_IN_MEMMOVE:\n+\t  case BUILT_IN_MEMSET:\n+\t    {\n+\t      gimple use_stmt;\n+\t      ao_ref ref;\n+\t      tree size = NULL_TREE;\n+\t      if (gimple_call_num_args (stmt) == 3)\n+\t\tsize = gimple_call_arg (stmt, 2);\n+\t      tree ptr = gimple_call_arg (stmt, 0);\n+\t      ao_ref_init_from_ptr_and_size (&ref, ptr, size);\n+\t      if (!dse_possible_dead_store_p (&ref, stmt, &use_stmt))\n+\t\treturn;\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"  Deleted dead call '\");\n+\t\t  print_gimple_stmt (dump_file, gsi_stmt (*gsi), dump_flags, 0);\n+\t\t  fprintf (dump_file, \"'\\n\");\n+\t\t}\n+\n+\t      tree lhs = gimple_call_lhs (stmt);\n+\t      if (lhs)\n+\t\t{\n+\t\t  gimple new_stmt = gimple_build_assign (lhs, ptr);\n+\t\t  unlink_stmt_vdef (stmt);\n+\t\t  if (gsi_replace (gsi, new_stmt, true))\n+\t\t    bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Then we need to fix the operand of the consuming stmt.  */\n+\t\t  unlink_stmt_vdef (stmt);\n+\n+\t\t  /* Remove the dead store.  */\n+\t\t  if (gsi_remove (gsi, true))\n+\t\t    bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);\n+\t\t}\n+\t      break;\n+\t    }\n+\t  default:\n+\t    return;\n+\t}\n+    }\n+\n   if (is_gimple_assign (stmt))\n     {\n       gimple use_stmt;\n \n-      if (!dse_possible_dead_store_p (stmt, &use_stmt))\n-\treturn;\n+      /* Self-assignments are zombies.  */\n+      if (operand_equal_p (gimple_assign_rhs1 (stmt),\n+\t\t\t   gimple_assign_lhs (stmt), 0))\n+\tuse_stmt = stmt;\n+      else\n+\t{\n+\t  ao_ref ref;\n+\t  ao_ref_init (&ref, gimple_assign_lhs (stmt));\n+  \t  if (!dse_possible_dead_store_p (&ref, stmt, &use_stmt))\n+\t    return;\n+\t}\n \n       /* Now we know that use_stmt kills the LHS of stmt.  */\n \n@@ -254,23 +301,6 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  && !gimple_clobber_p (use_stmt))\n \treturn;\n \n-      basic_block bb;\n-\n-      /* If use_stmt is or might be a nop assignment, e.g. for\n-\t   struct { ... } S a, b, *p; ...\n-\t   b = a; b = b;\n-\t or\n-\t   b = a; b = *p; where p might be &b,\n-\t or\n-           *p = a; *p = b; where p might be &b,\n-\t or\n-           *p = *u; *p = *v; where p might be v, then USE_STMT\n-         acts as a use as well as definition, so store in STMT\n-         is not dead.  */\n-      if (stmt != use_stmt\n-\t  && ref_maybe_used_by_stmt_p (use_stmt, gimple_assign_lhs (stmt)))\n-\treturn;\n-\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"  Deleted dead store '\");\n@@ -282,7 +312,7 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n       unlink_stmt_vdef (stmt);\n \n       /* Remove the dead store.  */\n-      bb = gimple_bb (stmt);\n+      basic_block bb = gimple_bb (stmt);\n       if (gsi_remove (gsi, true))\n \tbitmap_set_bit (need_eh_cleanup, bb->index);\n "}]}