{"sha": "887b24d276910aea7ce6da32083527f6a0de20f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg3YjI0ZDI3NjkxMGFlYTdjZTZkYTMyMDgzNTI3ZjZhMGRlMjBmNg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-06-27T23:08:37Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-06-27T23:08:37Z"}, "message": "Update to SGI STL 3.3\n\n\n2000-06-27  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\tUpdate to SGI STL 3.3\n\t* ext/hash_map, ext/hash_set, ext/slist, ext/stl_bvector.h,\n\text/stl_rope.h, ext/ropeimpl.h: Update.\n\t* bits/std_bitset.h, bits/std_map, bits/std_memory.h,\n\tbits/stl_algo.h, bits/stl_algobase.h, bits/stl_alloc.h,\n\tbits/stl_config.h, bits/stl_construct.h, bits/stl_deque.h,\n\tbits/stl_function.h, bits/stl_heap.h, bits/stl_iterator.h,\n\tbits/stl_iterator_base.h, bits/stl_list.h, bits/stl_map.h,\n\tbits/stl_multimap.h, bits/stl_multiset.h, bits/stl_numeric.h,\n\tbits/stl_queue.h, bits/stl_set.h, bits/stl_stack.h,\n\tbits/stl_string_fwd.h, bits/stl_threads.h, bits/stl_three.h,\n\tbits/stl_uninitialized.h, bits/stl_vectory.h: Update.\n\n\t* src/Makefile.am (headers): Add new files.\n\t* src/Makefile.in: Regenerate.\n\t* src/stl-inst.cc (std): Add instantiation for __sink_unused_warning.\n\t* bits/concept_checks.h: New file.\n\t* bits/container_concepts.h: New file.\n\t* bits/sequence_concepts.h: New file.\n\nFrom-SVN: r34748", "tree": {"sha": "4b23a1296d9f1e8dcac204e5073628176646acd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b23a1296d9f1e8dcac204e5073628176646acd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/887b24d276910aea7ce6da32083527f6a0de20f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887b24d276910aea7ce6da32083527f6a0de20f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/887b24d276910aea7ce6da32083527f6a0de20f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887b24d276910aea7ce6da32083527f6a0de20f6/comments", "author": null, "committer": null, "parents": [{"sha": "d845dc520b111af7fff19324ff64b46ff846010b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d845dc520b111af7fff19324ff64b46ff846010b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d845dc520b111af7fff19324ff64b46ff846010b"}], "stats": {"total": 1259, "additions": 1259, "deletions": 0}, "files": [{"sha": "36df2833286b038800f79c42f89d51db99cc843a", "filename": "libstdc++-v3/bits/concept_checks.h", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/887b24d276910aea7ce6da32083527f6a0de20f6/libstdc%2B%2B-v3%2Fbits%2Fconcept_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/887b24d276910aea7ce6da32083527f6a0de20f6/libstdc%2B%2B-v3%2Fbits%2Fconcept_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fconcept_checks.h?ref=887b24d276910aea7ce6da32083527f6a0de20f6", "patch": "@@ -0,0 +1,811 @@\n+/*\n+ * Copyright (c) 1999\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __CONCEPT_CHECKS_H\n+#define __CONCEPT_CHECKS_H\n+\n+/*\n+  Use these macro like assertions, but they assert properties\n+  on types (usually template arguments). In technical terms they\n+  verify whether a type \"models\" a \"concept\".\n+\n+  This set of requirements and the terminology used here is derived\n+  from the book \"Generic Programming and the STL\" by Matt Austern\n+  (Addison Wesley). For further information please consult that\n+  book. The requirements also are intended to match the ANSI/ISO C++\n+  standard.\n+\n+  This file covers the basic concepts and the iterator concepts.\n+  There are several other files that provide the requirements\n+  for the STL containers:\n+    container_concepts.h\n+    sequence_concepts.h\n+    assoc_container_concepts.h\n+\n+  Jeremy Siek, 1999\n+\n+  TO DO:\n+    - some issues with regards to concept classification and mutability\n+      including AssociativeContianer -> ForwardContainer\n+      and SortedAssociativeContainer -> ReversibleContainer\n+    - HashedAssociativeContainer\n+    - Allocator\n+    - Function Object Concepts\n+\n+  */\n+\n+#ifndef __STL_USE_CONCEPT_CHECKS\n+\n+// Some compilers lack the features that are necessary for concept checks.\n+// On those compilers we define the concept check macros to do nothing.\n+#define __STL_REQUIRES(__type_var, __concept) do {} while(0)\n+#define __STL_CLASS_REQUIRES(__type_var, __concept) \\\n+  static int  __##__type_var##_##__concept\n+#define __STL_CONVERTIBLE(__type_x, __type_y) do {} while(0)\n+#define __STL_REQUIRES_SAME_TYPE(__type_x, __type_y) do {} while(0)\n+#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y) \\\n+  static int  __##__type_x##__type_y##_require_same_type\n+#define __STL_GENERATOR_CHECK(__func, __ret) do {} while(0)\n+#define __STL_CLASS_GENERATOR_CHECK(__func, __ret) \\\n+  static int  __##__func##__ret##_generator_check\n+#define __STL_UNARY_FUNCTION_CHECK(__func, __ret, __arg) do {} while(0)\n+#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \\\n+  static int  __##__func##__ret##__arg##_unary_function_check\n+#define __STL_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+  do {} while(0)\n+#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+  static int  __##__func##__ret##__first##__second##_binary_function_check\n+#define __STL_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+  do {} while(0)\n+#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+  static int __##__opname##__ret##__first##__second##_require_binary_op\n+\n+#else /* __STL_USE_CONCEPT_CHECKS */\n+\n+// This macro tests whether the template argument \"__type_var\"\n+// satisfies the requirements of \"__concept\".  Here is a list of concepts\n+// that we know how to check:\n+//       _Allocator\n+//       _Assignable\n+//       _DefaultConstructible\n+//       _EqualityComparable\n+//       _LessThanComparable\n+//       _TrivialIterator\n+//       _InputIterator\n+//       _OutputIterator\n+//       _ForwardIterator\n+//       _BidirectionalIterator\n+//       _RandomAccessIterator\n+//       _Mutable_TrivialIterator\n+//       _Mutable_ForwardIterator\n+//       _Mutable_BidirectionalIterator\n+//       _Mutable_RandomAccessIterator\n+\n+#define __STL_REQUIRES(__type_var, __concept) \\\n+do { \\\n+  void (*__x)( __type_var ) = __concept##_concept_specification< __type_var >\\\n+    ::__concept##_requirement_violation; __x = __x; } while (0)\n+\n+// Use this to check whether type X is convertible to type Y\n+#define __STL_CONVERTIBLE(__type_x, __type_y) \\\n+do { \\\n+  void (*__x)( __type_x , __type_y ) = _STL_CONVERT_ERROR< __type_x , \\\n+  __type_y >::__type_X_is_not_convertible_to_type_Y; \\\n+  __x = __x; } while (0)\n+\n+// Use this to test whether two template arguments are the same type\n+#define __STL_REQUIRES_SAME_TYPE(__type_x, __type_y) \\\n+do { \\\n+  void (*__x)( __type_x , __type_y ) = _STL_SAME_TYPE_ERROR< __type_x, \\\n+    __type_y  >::__type_X_not_same_as_type_Y; \\\n+  __x = __x; } while (0)\n+\n+\n+// function object checks\n+#define __STL_GENERATOR_CHECK(__func, __ret) \\\n+do { \\\n+  __ret (*__x)( __func&) = \\\n+     _STL_GENERATOR_ERROR< \\\n+  __func, __ret>::__generator_requirement_violation; \\\n+  __x = __x; } while (0)\n+\n+\n+#define __STL_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \\\n+do { \\\n+  __ret (*__x)( __func&, const __arg& ) = \\\n+     _STL_UNARY_FUNCTION_ERROR< \\\n+  __func, __ret, __arg>::__unary_function_requirement_violation; \\\n+  __x = __x; } while (0)\n+\n+\n+#define __STL_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+do { \\\n+  __ret (*__x)( __func&, const __first&, const __second& ) = \\\n+     _STL_BINARY_FUNCTION_ERROR< \\\n+  __func, __ret, __first, __second>::__binary_function_requirement_violation; \\\n+  __x = __x; } while (0)\n+\n+\n+#define __STL_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+    do { \\\n+  __ret (*__x)( __first&, __second& ) = _STL_BINARY##__opname##_ERROR< \\\n+    __ret, __first, __second>::__binary_operator_requirement_violation; \\\n+  __ret (*__y)( const __first&, const __second& ) = \\\n+    _STL_BINARY##__opname##_ERROR< __ret, __first, __second>:: \\\n+      __const_binary_operator_requirement_violation; \\\n+  __y = __y; __x = __x; } while (0)\n+\n+\n+#ifdef __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE\n+\n+#define __STL_CLASS_REQUIRES(__type_var, __concept)\n+#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y)\n+#define __STL_CLASS_GENERATOR_CHECK(__func, __ret)\n+#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg)\n+#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second)\n+#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second)\n+\n+#else\n+\n+// Use this macro inside of template classes, where you would\n+// like to place requirements on the template arguments to the class\n+// Warning: do not pass pointers and such (e.g. T*) in as the __type_var,\n+// since the type_var is used to construct identifiers. Instead typedef\n+// the pointer type, then use the typedef name for the __type_var.\n+#define __STL_CLASS_REQUIRES(__type_var, __concept) \\\n+  typedef void (* __func##__type_var##__concept)( __type_var ); \\\n+  template <__func##__type_var##__concept _Tp1> \\\n+  struct __dummy_struct_##__type_var##__concept { }; \\\n+  static __dummy_struct_##__type_var##__concept< \\\n+    __concept##_concept_specification< \\\n+      __type_var>::__concept##_requirement_violation>  \\\n+  __dummy_ptr_##__type_var##__concept\n+\n+\n+#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y) \\\n+  typedef void (* __func_##__type_x##__type_y##same_type)( __type_x, \\\n+                                                            __type_y ); \\\n+  template < __func_##__type_x##__type_y##same_type _Tp1> \\\n+  struct __dummy_struct_##__type_x##__type_y##_same_type { }; \\\n+  static __dummy_struct_##__type_x##__type_y##_same_type< \\\n+    _STL_SAME_TYPE_ERROR<__type_x, __type_y>::__type_X_not_same_as_type_Y>  \\\n+  __dummy_ptr_##__type_x##__type_y##_same_type\n+\n+\n+#define __STL_CLASS_GENERATOR_CHECK(__func, __ret) \\\n+  typedef __ret (* __f_##__func##__ret##_generator)( __func& ); \\\n+  template <__f_##__func##__ret##_generator _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##_generator { }; \\\n+  static __dummy_struct_##__func##__ret##_generator< \\\n+    _STL_GENERATOR_ERROR< \\\n+      __func, __ret>::__generator_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##_generator\n+\n+\n+#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \\\n+  typedef __ret (* __f_##__func##__ret##__arg##_unary_check)( __func&, \\\n+                                                         const __arg& ); \\\n+  template <__f_##__func##__ret##__arg##_unary_check _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##__arg##_unary_check { }; \\\n+  static __dummy_struct_##__func##__ret##__arg##_unary_check< \\\n+    _STL_UNARY_FUNCTION_ERROR< \\\n+      __func, __ret, __arg>::__unary_function_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##__arg##_unary_check\n+\n+\n+#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+  typedef __ret (* __f_##__func##__ret##__first##__second##_binary_check)( __func&, const __first&,\\\n+                                                    const __second& ); \\\n+  template <__f_##__func##__ret##__first##__second##_binary_check _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##__first##__second##_binary_check { }; \\\n+  static __dummy_struct_##__func##__ret##__first##__second##_binary_check< \\\n+    _STL_BINARY_FUNCTION_ERROR<__func, __ret, __first, __second>:: \\\n+  __binary_function_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##__first##__second##_binary_check\n+\n+\n+#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+  typedef __ret (* __f_##__func##__ret##__first##__second##_binary_op)(const __first&, \\\n+                                                    const __second& ); \\\n+  template <__f_##__func##__ret##__first##__second##_binary_op _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##__first##__second##_binary_op { }; \\\n+  static __dummy_struct_##__func##__ret##__first##__second##_binary_op< \\\n+    _STL_BINARY##__opname##_ERROR<__ret, __first, __second>:: \\\n+  __binary_operator_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##__first##__second##_binary_op\n+\n+#endif\n+\n+/* helper class for finding non-const version of a type. Need to have\n+   something to assign to etc. when testing constant iterators. */\n+\n+template <class _Tp>\n+struct _Mutable_trait {\n+  typedef _Tp _Type;\n+};\n+template <class _Tp>\n+struct _Mutable_trait<const _Tp> {\n+  typedef _Tp _Type;\n+};\n+\n+\n+/* helper function for avoiding compiler warnings about unused variables */\n+template <class _Type>\n+void __sink_unused_warning(_Type) { }\n+\n+template <class _TypeX, class _TypeY>\n+struct _STL_CONVERT_ERROR {\n+  static void\n+  __type_X_is_not_convertible_to_type_Y(_TypeX __x, _TypeY) {\n+    _TypeY __y = __x;\n+    __sink_unused_warning(__y);\n+  }\n+};\n+\n+\n+template <class _Type> struct __check_equal { };\n+\n+template <class _TypeX, class _TypeY>\n+struct _STL_SAME_TYPE_ERROR {\n+  static void\n+  __type_X_not_same_as_type_Y(_TypeX , _TypeY ) { \n+    __check_equal<_TypeX> t1 = __check_equal<_TypeY>();\n+  }\n+};\n+\n+\n+// Some Functon Object Checks\n+\n+template <class _Func, class _Ret>\n+struct _STL_GENERATOR_ERROR {\n+  static _Ret __generator_requirement_violation(_Func& __f) {\n+    return __f();\n+  }\n+};\n+\n+template <class _Func>\n+struct _STL_GENERATOR_ERROR<_Func, void> {\n+  static void __generator_requirement_violation(_Func& __f) {\n+    __f();\n+  }\n+};\n+\n+\n+template <class _Func, class _Ret, class _Arg>\n+struct _STL_UNARY_FUNCTION_ERROR {\n+  static _Ret\n+  __unary_function_requirement_violation(_Func& __f,\n+                                          const _Arg& __arg) {\n+    return __f(__arg);\n+  }\n+};\n+\n+template <class _Func, class _Arg>\n+struct _STL_UNARY_FUNCTION_ERROR<_Func, void, _Arg> {\n+  static void\n+  __unary_function_requirement_violation(_Func& __f,\n+                                          const _Arg& __arg) {\n+    __f(__arg);\n+  }\n+};\n+\n+template <class _Func, class _Ret, class _First, class _Second>\n+struct _STL_BINARY_FUNCTION_ERROR {\n+  static _Ret\n+  __binary_function_requirement_violation(_Func& __f,\n+                                          const _First& __first, \n+                                          const _Second& __second) {\n+    return __f(__first, __second);\n+  }\n+};\n+\n+template <class _Func, class _First, class _Second>\n+struct _STL_BINARY_FUNCTION_ERROR<_Func, void, _First, _Second> {\n+  static void\n+  __binary_function_requirement_violation(_Func& __f,\n+                                          const _First& __first, \n+                                          const _Second& __second) {\n+    __f(__first, __second);\n+  }\n+};\n+\n+\n+#define __STL_DEFINE_BINARY_OP_CHECK(_OP, _NAME) \\\n+template <class _Ret, class _First, class _Second> \\\n+struct _STL_BINARY##_NAME##_ERROR { \\\n+  static _Ret \\\n+  __const_binary_operator_requirement_violation(const _First& __first,  \\\n+                                                const _Second& __second) { \\\n+    return __first _OP __second; \\\n+  } \\\n+  static _Ret \\\n+  __binary_operator_requirement_violation(_First& __first,  \\\n+                                          _Second& __second) { \\\n+    return __first _OP __second; \\\n+  } \\\n+}\n+\n+__STL_DEFINE_BINARY_OP_CHECK(==, _OP_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(!=, _OP_NOT_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(<, _OP_LESS_THAN);\n+__STL_DEFINE_BINARY_OP_CHECK(<=, _OP_LESS_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(>, _OP_GREATER_THAN);\n+__STL_DEFINE_BINARY_OP_CHECK(>=, _OP_GREATER_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(+, _OP_PLUS);\n+__STL_DEFINE_BINARY_OP_CHECK(*, _OP_TIMES);\n+__STL_DEFINE_BINARY_OP_CHECK(/, _OP_DIVIDE);\n+__STL_DEFINE_BINARY_OP_CHECK(-, _OP_SUBTRACT);\n+__STL_DEFINE_BINARY_OP_CHECK(%, _OP_MOD);\n+// ...\n+\n+// TODO, add unary operators (prefix and postfix)\n+\n+/*\n+  The presence of this class is just to trick EDG into displaying\n+  these error messages before any other errors. Without the\n+  classes, the errors in the functions get reported after\n+  other class errors deep inside the library. The name\n+  choice just makes for an eye catching error message :)\n+ */\n+struct _STL_ERROR {\n+\n+  template <class _Type>\n+  static _Type\n+  __default_constructor_requirement_violation(_Type) {\n+    return _Type();\n+  }\n+  template <class _Type>\n+  static _Type\n+  __assignment_operator_requirement_violation(_Type __a) {\n+    __a = __a;\n+    return __a;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __copy_constructor_requirement_violation(_Type __a) {\n+    _Type __c(__a);\n+    return __c;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __const_parameter_required_for_copy_constructor(_Type /* __a */, \n+                                                  const _Type& __b) {\n+    _Type __c(__b);\n+    return __c;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __const_parameter_required_for_assignment_operator(_Type __a, \n+                                                     const _Type& __b) {\n+    __a = __b;\n+    return __a;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __less_than_comparable_requirement_violation(_Type __a, _Type __b) {\n+    if (__a < __b || __a > __b || __a <= __b || __a >= __b) return __a;\n+    return __b;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __equality_comparable_requirement_violation(_Type __a, _Type __b) {\n+    if (__a == __b || __a != __b) return __a;\n+    return __b;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __dereference_operator_requirement_violation(_Iterator __i) {\n+    __sink_unused_warning(*__i);\n+  }\n+  template <class _Iterator>\n+  static void\n+  __dereference_operator_and_assignment_requirement_violation(_Iterator __i) {\n+    *__i = *__i;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __preincrement_operator_requirement_violation(_Iterator __i) {\n+    ++__i;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __postincrement_operator_requirement_violation(_Iterator __i) {\n+    __i++;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __predecrement_operator_requirement_violation(_Iterator __i) {\n+    --__i;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __postdecrement_operator_requirement_violation(_Iterator __i) {\n+    __i--;\n+  }\n+  template <class _Iterator, class _Type>\n+  static void\n+  __postincrement_operator_and_assignment_requirement_violation(_Iterator __i,\n+                                                                _Type __t) {\n+    *__i++ = __t;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_addition_assignment_requirement_violation(_Iterator __i, \n+                                                       _Distance __n) {\n+    __i += __n;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_addition_requirement_violation(_Iterator __i, _Distance __n) {\n+    __i = __i + __n;\n+    __i = __n + __i;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_subtraction_assignment_requirement_violation(_Iterator __i,\n+                                                          _Distance __n) {\n+    __i -= __n;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_subtraction_requirement_violation(_Iterator __i, _Distance __n) {\n+    __i = __i - __n;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Distance\n+  __difference_operator_requirement_violation(_Iterator __i, _Iterator __j,\n+                                              _Distance __n) {\n+    __n = __i - __j;\n+    return __n;\n+  }\n+  template <class _Exp, class _Type, class _Distance>\n+  static _Type\n+  __element_access_operator_requirement_violation(_Exp __x, _Type*,\n+                                                  _Distance __n) {\n+    return __x[__n];\n+  }\n+  template <class _Exp, class _Type, class _Distance>\n+  static void\n+  __element_assignment_operator_requirement_violation(_Exp __x,\n+                                                      _Type* __t,\n+                                                      _Distance __n) {\n+    __x[__n] = *__t;\n+  }\n+\n+}; /* _STL_ERROR */\n+\n+/* Associated Type Requirements */\n+\n+__STL_BEGIN_NAMESPACE\n+template <class _Iterator> struct iterator_traits;\n+__STL_END_NAMESPACE\n+\n+template <class _Iter> \n+struct __value_type_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::value_type value_type;\n+};\n+\n+template <class _Iter> \n+struct __difference_type_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::difference_type\n+          difference_type;\n+};\n+\n+template <class _Iter> \n+struct __reference_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::reference reference;\n+};\n+\n+template <class _Iter> \n+struct __pointer_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::pointer pointer;\n+};\n+\n+template <class _Iter> \n+struct __iterator_category_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::iterator_category \n+          iterator_category;\n+};\n+\n+/* Assignable Requirements */\n+\n+\n+template <class _Type>\n+struct _Assignable_concept_specification {\n+  static void _Assignable_requirement_violation(_Type __a) {\n+    _STL_ERROR::__assignment_operator_requirement_violation(__a);\n+    _STL_ERROR::__copy_constructor_requirement_violation(__a);\n+    _STL_ERROR::__const_parameter_required_for_copy_constructor(__a,__a);\n+    _STL_ERROR::__const_parameter_required_for_assignment_operator(__a,__a);\n+  }\n+};\n+\n+/* DefaultConstructible Requirements */\n+\n+\n+template <class _Type>\n+struct _DefaultConstructible_concept_specification {\n+  static void _DefaultConstructible_requirement_violation(_Type __a) {\n+    _STL_ERROR::__default_constructor_requirement_violation(__a);\n+  }\n+};\n+\n+/* EqualityComparable Requirements */\n+\n+template <class _Type>\n+struct _EqualityComparable_concept_specification {\n+  static void _EqualityComparable_requirement_violation(_Type __a) {\n+    _STL_ERROR::__equality_comparable_requirement_violation(__a, __a);\n+  }\n+};\n+\n+/* LessThanComparable Requirements */\n+template <class _Type>\n+struct _LessThanComparable_concept_specification {\n+  static void _LessThanComparable_requirement_violation(_Type __a) {\n+    _STL_ERROR::__less_than_comparable_requirement_violation(__a, __a);\n+  }\n+};\n+\n+/* TrivialIterator Requirements */\n+\n+template <class _TrivialIterator>\n+struct _TrivialIterator_concept_specification {\n+static void\n+_TrivialIterator_requirement_violation(_TrivialIterator __i) {\n+  typedef typename\n+    __value_type_type_definition_requirement_violation<_TrivialIterator>::\n+    value_type __T;\n+  // Refinement of Assignable\n+  _Assignable_concept_specification<_TrivialIterator>::\n+    _Assignable_requirement_violation(__i);\n+  // Refinement of DefaultConstructible\n+  _DefaultConstructible_concept_specification<_TrivialIterator>::\n+    _DefaultConstructible_requirement_violation(__i);\n+  // Refinement of EqualityComparable\n+  _EqualityComparable_concept_specification<_TrivialIterator>::\n+    _EqualityComparable_requirement_violation(__i);\n+  // Valid Expressions\n+  _STL_ERROR::__dereference_operator_requirement_violation(__i);\n+}\n+};\n+\n+template <class _TrivialIterator>\n+struct _Mutable_TrivialIterator_concept_specification {\n+static void\n+_Mutable_TrivialIterator_requirement_violation(_TrivialIterator __i) {\n+  _TrivialIterator_concept_specification<_TrivialIterator>::\n+    _TrivialIterator_requirement_violation(__i);\n+  // Valid Expressions\n+  _STL_ERROR::__dereference_operator_and_assignment_requirement_violation(__i);\n+}\n+};\n+\n+/* InputIterator Requirements */\n+\n+template <class _InputIterator>\n+struct _InputIterator_concept_specification {\n+static void\n+_InputIterator_requirement_violation(_InputIterator __i) {\n+  // Refinement of TrivialIterator\n+  _TrivialIterator_concept_specification<_InputIterator>::\n+    _TrivialIterator_requirement_violation(__i);\n+  // Associated Types\n+  __difference_type_type_definition_requirement_violation<_InputIterator>();\n+  __reference_type_definition_requirement_violation<_InputIterator>();\n+  __pointer_type_definition_requirement_violation<_InputIterator>();\n+  __iterator_category_type_definition_requirement_violation<_InputIterator>();\n+  // Valid Expressions\n+  _STL_ERROR::__preincrement_operator_requirement_violation(__i);\n+  _STL_ERROR::__postincrement_operator_requirement_violation(__i);\n+}\n+};\n+\n+/* OutputIterator Requirements */\n+\n+template <class _OutputIterator>\n+struct _OutputIterator_concept_specification {\n+static void\n+_OutputIterator_requirement_violation(_OutputIterator __i) {\n+  // Refinement of Assignable\n+  _Assignable_concept_specification<_OutputIterator>::\n+    _Assignable_requirement_violation(__i);\n+  // Associated Types\n+  __iterator_category_type_definition_requirement_violation<_OutputIterator>();\n+  // Valid Expressions\n+  _STL_ERROR::__dereference_operator_requirement_violation(__i);\n+  _STL_ERROR::__preincrement_operator_requirement_violation(__i);\n+  _STL_ERROR::__postincrement_operator_requirement_violation(__i);\n+  _STL_ERROR::\n+    __postincrement_operator_and_assignment_requirement_violation(__i, *__i);\n+}\n+};\n+\n+/* ForwardIterator Requirements */\n+\n+template <class _ForwardIterator>\n+struct _ForwardIterator_concept_specification {\n+static void\n+_ForwardIterator_requirement_violation(_ForwardIterator __i) {\n+  // Refinement of InputIterator\n+  _InputIterator_concept_specification<_ForwardIterator>::\n+    _InputIterator_requirement_violation(__i);\n+}\n+};\n+\n+template <class _ForwardIterator>\n+struct _Mutable_ForwardIterator_concept_specification {\n+static void\n+_Mutable_ForwardIterator_requirement_violation(_ForwardIterator __i) {\n+  _ForwardIterator_concept_specification<_ForwardIterator>::\n+    _ForwardIterator_requirement_violation(__i);\n+  // Refinement of OutputIterator\n+  _OutputIterator_concept_specification<_ForwardIterator>::\n+    _OutputIterator_requirement_violation(__i);\n+}\n+};\n+\n+/* BidirectionalIterator Requirements */\n+\n+template <class _BidirectionalIterator>\n+struct _BidirectionalIterator_concept_specification {\n+static void\n+_BidirectionalIterator_requirement_violation(_BidirectionalIterator __i) {\n+  // Refinement of ForwardIterator\n+  _ForwardIterator_concept_specification<_BidirectionalIterator>::\n+    _ForwardIterator_requirement_violation(__i);\n+  // Valid Expressions\n+  _STL_ERROR::__predecrement_operator_requirement_violation(__i);\n+  _STL_ERROR::__postdecrement_operator_requirement_violation(__i);\n+}\n+};\n+\n+template <class _BidirectionalIterator>\n+struct _Mutable_BidirectionalIterator_concept_specification {\n+static void\n+_Mutable_BidirectionalIterator_requirement_violation(\n+       _BidirectionalIterator __i)\n+{\n+  _BidirectionalIterator_concept_specification<_BidirectionalIterator>::\n+    _BidirectionalIterator_requirement_violation(__i);\n+  // Refinement of mutable_ForwardIterator\n+  _Mutable_ForwardIterator_concept_specification<_BidirectionalIterator>::\n+    _Mutable_ForwardIterator_requirement_violation(__i);\n+  typedef typename\n+    __value_type_type_definition_requirement_violation<\n+    _BidirectionalIterator>::value_type __T;\n+  typename _Mutable_trait<__T>::_Type* __tmp_ptr = 0;\n+  // Valid Expressions\n+  _STL_ERROR::\n+    __postincrement_operator_and_assignment_requirement_violation(__i,\n+                                                                  *__tmp_ptr);\n+}\n+};\n+\n+/* RandomAccessIterator Requirements */\n+\n+template <class _RandAccIter>\n+struct _RandomAccessIterator_concept_specification {\n+static void\n+_RandomAccessIterator_requirement_violation(_RandAccIter __i) {\n+  // Refinement of BidirectionalIterator\n+  _BidirectionalIterator_concept_specification<_RandAccIter>::\n+    _BidirectionalIterator_requirement_violation(__i);\n+  // Refinement of LessThanComparable\n+  _LessThanComparable_concept_specification<_RandAccIter>::\n+    _LessThanComparable_requirement_violation(__i);\n+  typedef typename \n+        __value_type_type_definition_requirement_violation<_RandAccIter>\n+        ::value_type\n+    value_type;\n+  typedef typename\n+        __difference_type_type_definition_requirement_violation<_RandAccIter>\n+        ::difference_type \n+    _Dist;\n+  typedef typename _Mutable_trait<_Dist>::_Type _MutDist;\n+\n+  // Valid Expressions\n+  _STL_ERROR::__iterator_addition_assignment_requirement_violation(__i,\n+                                                                   _MutDist());\n+  _STL_ERROR::__iterator_addition_requirement_violation(__i,\n+                                                        _MutDist());\n+  _STL_ERROR::\n+    __iterator_subtraction_assignment_requirement_violation(__i,\n+                                                            _MutDist());\n+  _STL_ERROR::__iterator_subtraction_requirement_violation(__i,\n+                                                           _MutDist());\n+  _STL_ERROR::__difference_operator_requirement_violation(__i, __i,\n+                                                          _MutDist());\n+  typename _Mutable_trait<value_type>::_Type* __dummy_ptr = 0;\n+  _STL_ERROR::__element_access_operator_requirement_violation(__i,\n+                                                              __dummy_ptr,\n+                                                              _MutDist());\n+}\n+};\n+\n+template <class _RandAccIter>\n+struct _Mutable_RandomAccessIterator_concept_specification {\n+static void\n+_Mutable_RandomAccessIterator_requirement_violation(_RandAccIter __i)\n+{\n+  _RandomAccessIterator_concept_specification<_RandAccIter>::\n+    _RandomAccessIterator_requirement_violation(__i);\n+  // Refinement of mutable_BidirectionalIterator\n+  _Mutable_BidirectionalIterator_concept_specification<_RandAccIter>::\n+    _Mutable_BidirectionalIterator_requirement_violation(__i);\n+  typedef typename\n+        __value_type_type_definition_requirement_violation<_RandAccIter>\n+        ::value_type\n+    value_type;\n+  typedef typename\n+        __difference_type_type_definition_requirement_violation<_RandAccIter>\n+        ::difference_type\n+    _Dist;\n+\n+  typename _Mutable_trait<value_type>::_Type* __tmp_ptr = 0;\n+  // Valid Expressions\n+  _STL_ERROR::__element_assignment_operator_requirement_violation(__i,\n+                  __tmp_ptr, _Dist());\n+}\n+};\n+\n+#define __STL_TYPEDEF_REQUIREMENT(__REQUIREMENT) \\\n+template <class Type> \\\n+struct __##__REQUIREMENT##__typedef_requirement_violation { \\\n+  typedef typename Type::__REQUIREMENT __REQUIREMENT; \\\n+}\n+\n+__STL_TYPEDEF_REQUIREMENT(value_type);\n+__STL_TYPEDEF_REQUIREMENT(difference_type);\n+__STL_TYPEDEF_REQUIREMENT(size_type);\n+__STL_TYPEDEF_REQUIREMENT(reference);\n+__STL_TYPEDEF_REQUIREMENT(const_reference);\n+__STL_TYPEDEF_REQUIREMENT(pointer);\n+__STL_TYPEDEF_REQUIREMENT(const_pointer);\n+\n+\n+template <class _Alloc>\n+struct _Allocator_concept_specification {\n+static void\n+_Allocator_requirement_violation(_Alloc __a) {\n+  // Refinement of DefaultConstructible\n+  _DefaultConstructible_concept_specification<_Alloc>::\n+    _DefaultConstructible_requirement_violation(__a);\n+  // Refinement of EqualityComparable\n+  _EqualityComparable_concept_specification<_Alloc>::\n+    _EqualityComparable_requirement_violation(__a);\n+  // Associated Types\n+  __value_type__typedef_requirement_violation<_Alloc>();\n+  __difference_type__typedef_requirement_violation<_Alloc>();\n+  __size_type__typedef_requirement_violation<_Alloc>();\n+  __reference__typedef_requirement_violation<_Alloc>();\n+  __const_reference__typedef_requirement_violation<_Alloc>();\n+  __pointer__typedef_requirement_violation<_Alloc>();\n+  __const_pointer__typedef_requirement_violation<_Alloc>();\n+  typedef typename _Alloc::value_type _Tp;\n+  //__STL_REQUIRES_SAME_TYPE(typename _Alloc::__STL_TEMPLATE rebind<_Tp>::other,\n+  //                         _Alloc);\n+}\n+};\n+\n+#endif /* __STL_USE_CONCEPT_CHECKS */\n+\n+#endif /* __CONCEPT_CHECKS_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "99aec1c4b62b5b580a0e6027d4ed3a81fb280dba", "filename": "libstdc++-v3/bits/container_concepts.h", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/887b24d276910aea7ce6da32083527f6a0de20f6/libstdc%2B%2B-v3%2Fbits%2Fcontainer_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/887b24d276910aea7ce6da32083527f6a0de20f6/libstdc%2B%2B-v3%2Fbits%2Fcontainer_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fcontainer_concepts.h?ref=887b24d276910aea7ce6da32083527f6a0de20f6", "patch": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 1999\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __STL_CONTAINER_CONCEPTS_H\n+#define __STL_CONTAINER_CONCEPTS_H\n+\n+\n+#include <bits/concept_checks.h>\n+\n+#ifdef __STL_USE_CONCEPT_CHECKS\n+\n+\n+// This file covers the following concepts:\n+//       _Container\n+//       _ForwardContainer\n+//       _ReversibleContainer\n+//       _const_ReversibleContainer\n+//       _RandomAccessContainer\n+//\n+\n+struct _ERROR_IN_STL_CONTAINER {\n+\n+  /* Container expresssions */\n+\n+  template <class _Container>\n+  static void\n+  __begin_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.begin();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_begin_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.begin();\n+  }\n+  template <class _Container>\n+  static void\n+  __end_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.end();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_end_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.end();\n+  }\n+\n+  template <class _Container>\n+  static void\n+  __rbegin_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.rbegin();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_rbegin_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.rbegin();\n+  }\n+  template <class _Container>\n+  static void\n+  __rend_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.rend();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_rend_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.rend();\n+  }\n+  template <class _Container>\n+  static void\n+  __size_function_must_be_const(const _Container& __c) {\n+    __c.size();\n+  }\n+  template <class _Container>\n+  static void\n+  __size_function_requirement_violation(_Container& __c) {\n+    __c.size();\n+    __size_function_must_be_const(__c);\n+  }\n+  template <class _Container>\n+  static void\n+  __max_size_function_must_be_const(const _Container& __c) {\n+    __c.max_size();\n+  }\n+  template <class _Container>\n+  static void\n+  __max_size_function_requirement_violation(_Container& __c) {\n+    __c.max_size();\n+    __max_size_function_must_be_const(__c);\n+  }\n+  template <class _Container>\n+  static void\n+  __empty_function_must_be_const(const _Container& __c) {\n+    __c.empty();\n+  }\n+  template <class _Container>\n+  static void\n+  __empty_function_requirement_violation(_Container& __c) {\n+    __c.empty();\n+    __empty_function_must_be_const(__c);\n+  }\n+  template <class _Container>\n+  static void\n+  __swap_function_requirement_violation(_Container& __c) {\n+    __c.swap(__c);\n+  }\n+\n+};\n+\n+\n+__STL_TYPEDEF_REQUIREMENT(iterator);\n+__STL_TYPEDEF_REQUIREMENT(const_iterator);\n+\n+/* Containers */\n+\n+template <class _Container>\n+struct _Container_concept_specification {\n+static void\n+_Container_requirement_violation(_Container __c) {\n+  // Refinement of Assignable\n+  _Assignable_concept_specification<_Container>::_Assignable_requirement_violation(__c);\n+  // Associated Types\n+  __value_type__typedef_requirement_violation<_Container>();\n+  __difference_type__typedef_requirement_violation<_Container>();\n+  __size_type__typedef_requirement_violation<_Container>();\n+  __reference__typedef_requirement_violation<_Container>();\n+  __const_reference__typedef_requirement_violation<_Container>();\n+  __pointer__typedef_requirement_violation<_Container>();\n+  __const_pointer__typedef_requirement_violation<_Container>();\n+  __iterator__typedef_requirement_violation<_Container>();\n+  __const_iterator__typedef_requirement_violation<_Container>();\n+  // Valid Expressions\n+  _ERROR_IN_STL_CONTAINER::__const_begin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__const_end_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__begin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__end_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__size_function_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__max_size_function_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__empty_function_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__swap_function_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _Container::iterator iter;\n+  typedef typename _Container::const_iterator const_iter;\n+  _InputIterator_concept_specification<const_iter>::_InputIterator_requirement_violation(const_iter());\n+  _InputIterator_concept_specification<iter>::_InputIterator_requirement_violation(iter());\n+}\n+};\n+\n+template <class _ForwardContainer>\n+struct _ForwardContainer_concept_specification {\n+static void\n+_ForwardContainer_requirement_violation(_ForwardContainer __c) {\n+  // Refinement of Container\n+  _Container_concept_specification<_ForwardContainer>::_Container_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _ForwardContainer::iterator iter;\n+  typedef typename _ForwardContainer::const_iterator const_iter;\n+  _ForwardIterator_concept_specification<const_iter>::_ForwardIterator_requirement_violation(const_iter());\n+  _Mutable_ForwardIterator_concept_specification<iter>::_Mutable_ForwardIterator_requirement_violation(iter());\n+}\n+};\n+\n+\n+__STL_TYPEDEF_REQUIREMENT(reverse_iterator);\n+__STL_TYPEDEF_REQUIREMENT(const_reverse_iterator);\n+\n+template <class _ReversibleContainer>\n+struct _ReversibleContainer_concept_specification {\n+static void\n+_ReversibleContainer_requirement_violation(_ReversibleContainer __c) {\n+  // Refinement of ForwardContainer\n+  _ForwardContainer_concept_specification<_ReversibleContainer>::_ForwardContainer_requirement_violation(__c);\n+  // Associated types\n+  __reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  __const_reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  // Valid Expressions\n+  _ERROR_IN_STL_CONTAINER::__const_rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__const_rend_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rend_iterator_accessor_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _ReversibleContainer::iterator iter;\n+  typedef typename _ReversibleContainer::const_iterator const_iter;\n+  _BidirectionalIterator_concept_specification<const_iter>::_BidirectionalIterator_requirement_violation(const_iter());\n+  _Mutable_BidirectionalIterator_concept_specification<iter>::_Mutable_BidirectionalIterator_requirement_violation(iter());\n+}\n+};\n+\n+template <class _ReversibleContainer>\n+struct _const_ReversibleContainer_concept_specification {\n+static void\n+_const_ReversibleContainer_requirement_violation(_ReversibleContainer __c) {\n+  // Refinement of Container (JGS, not ForwardContainer)\n+  _Container_concept_specification<_ReversibleContainer>::_Container_requirement_violation(__c);\n+  // Associated types\n+  __reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  __const_reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  // Valid Expressions\n+  _ERROR_IN_STL_CONTAINER::__const_rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__const_rend_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rend_iterator_accessor_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _ReversibleContainer::iterator iter;\n+  typedef typename _ReversibleContainer::const_iterator const_iter;\n+  \n+  _BidirectionalIterator_concept_specification<const_iter>::_BidirectionalIterator_requirement_violation(const_iter());\n+}\n+};\n+\n+\n+template <class _RandomAccessContainer>\n+struct _RandomAccessContainer_concept_specification {\n+static void\n+_RandomAccessContainer_requirement_violation(_RandomAccessContainer __c) {\n+  // Refinement of ReversibleContainer\n+  _ReversibleContainer_concept_specification<_RandomAccessContainer>::_ReversibleContainer_requirement_violation(__c);\n+  // Valid Expressions\n+  typedef typename _RandomAccessContainer::value_type __T;\n+  typedef typename _RandomAccessContainer::difference_type _Dist;\n+  typedef typename _Mutable_trait<__T>::_Type Type;\n+  typedef Type* _TypePtr;\n+  typedef typename _Mutable_trait<_Dist>::_Type Dist;\n+  _STL_ERROR::__element_access_operator_requirement_violation(__c,\n+\t\t\t\t\t\t\t      _TypePtr(), \n+\t\t\t\t\t\t\t      Dist());\n+  // Requirements on Iterators\n+  typedef typename _RandomAccessContainer::iterator iter;\n+  typedef typename _RandomAccessContainer::const_iterator const_iter;\n+  _RandomAccessIterator_concept_specification<const_iter>::_RandomAccessIterator_requirement_violation(const_iter());\n+  _Mutable_RandomAccessIterator_concept_specification<iter>::_Mutable_RandomAccessIterator_requirement_violation(iter());\n+}\n+};\n+\n+#endif /* if __STL_USE_CONCEPT_CHECKS */\n+\n+#endif /* __STL_CONTAINER_CONCEPTS_H */"}, {"sha": "af582fb33452a2ecd7b4ae1782d9720d51f43404", "filename": "libstdc++-v3/bits/sequence_concepts.h", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/887b24d276910aea7ce6da32083527f6a0de20f6/libstdc%2B%2B-v3%2Fbits%2Fsequence_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/887b24d276910aea7ce6da32083527f6a0de20f6/libstdc%2B%2B-v3%2Fbits%2Fsequence_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fsequence_concepts.h?ref=887b24d276910aea7ce6da32083527f6a0de20f6", "patch": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 1999\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef STL_SEQUENCE_CONCEPTS_H\n+#define STL_SEQUENCE_CONCEPTS_H\n+\n+#include <bits/container_concepts.h>\n+\n+#ifdef __STL_USE_CONCEPT_CHECKS\n+\n+// This file covers the following concepts:\n+//       _Sequence\n+//       _FrontInsertionSequence\n+//       _BackInsertionSequence\n+\n+struct _ERROR_IN_STL_SEQ {\n+\n+  template <class _XX>\n+  static void\n+  __fill_constructor_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::difference_type __n = typename _XX::difference_type();\n+    _XX __x(__n, __t);\n+    __sink_unused_warning(__x);\n+  }\n+  template <class _XX>\n+  static void\n+  __fill_default_constructor_requirement_violation(_XX& __s) {\n+    _STL_ERROR::__default_constructor_requirement_violation(*__s.begin());\n+    typename _XX::difference_type __n = typename _XX::difference_type();\n+    _XX __x(__n);\n+    __sink_unused_warning(__x);\n+  }  \n+  template <class _XX>\n+  static void\n+  __range_constructor_requirement_violation(_XX& __s) {\n+    _XX __x(__s.begin(), __s.end());\n+    __sink_unused_warning(__x);\n+  }\n+  template <class _XX>\n+  static void\n+  __insert_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    __p = __s.insert(__p, __t);\n+  }\n+  template <class _XX>\n+  static void\n+  __fill_insert_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    typename _XX::difference_type __n = typename _XX::difference_type();\n+    __s.insert(__p, __n, __t);\n+  }\n+  template <class _XX>\n+  static void\n+  __range_insert_function_requirement_violation(_XX& __s) {\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    typename _XX::iterator __i = typename _XX::iterator();\n+    typename _XX::iterator __j = typename _XX::iterator();\n+    __s.insert(__p, __i, __j);\n+  }\n+  template <class _XX>\n+  static void\n+  __insert_element_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    std::pair<typename _XX::iterator, bool> __r;\n+    __r = __s.insert(__t);\n+    __sink_unused_warning(__r);\n+  }\n+  template <class _XX>\n+  static void\n+  __unconditional_insert_element_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::iterator __p;\n+    __p = __s.insert(__t);\n+    __sink_unused_warning(__p);\n+  }\n+  template <class _XX>\n+  static void\n+  __erase_function_requirement_violation(_XX& __s) {\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    __p = __s.erase(__p);\n+  }\n+  template <class _XX>\n+  static void\n+  __range_erase_function_requirement_violation(_XX& __s) {\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    typename _XX::iterator __q = typename _XX::iterator();\n+    __p = __s.erase(__p, __q);\n+  }\n+  template <class _XX>\n+  static void\n+  __const_front_function_requirement_violation(const _XX& __s) {\n+    typename _XX::const_reference __t = __s.front();\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __front_function_requirement_violation(_XX& __s) {\n+    typename _XX::reference __t = __s.front();\n+    __const_front_function_requirement_violation(__s);\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __const_back_function_requirement_violation(const _XX& __s) {\n+    typename _XX::const_reference __t = __s.back();\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __back_function_requirement_violation(_XX& __s) {\n+    typename _XX::reference __t = __s.back();\n+    __const_back_function_requirement_violation(__s);\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __push_front_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    __s.push_front(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __pop_front_function_requirement_violation(_XX& __s) {\n+    __s.pop_front();\n+  }\n+  template <class _XX>\n+  static void\n+  __push_back_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    __s.push_back(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __pop_back_function_requirement_violation(_XX& __s) {\n+    __s.pop_back();\n+  }\n+\n+};\n+\n+/* Sequence Containers */\n+\n+template <class _Sequence>\n+struct _Sequence_concept_specification {\n+static void\n+_Sequence_requirement_violation(_Sequence __s) {\n+  // Refinement of ForwardContainer\n+  _ForwardContainer_concept_specification<_Sequence>::_ForwardContainer_requirement_violation(__s);\n+  // Refinement of DefaultConstructible\n+  _DefaultConstructible_concept_specification<_Sequence>::_DefaultConstructible_requirement_violation(__s);\n+  // Valid Expressions\n+  _ERROR_IN_STL_SEQ::__fill_constructor_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__fill_default_constructor_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__range_constructor_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__insert_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__fill_insert_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__range_insert_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__erase_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__range_erase_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__front_function_requirement_violation(__s);\n+}\n+};\n+\n+template <class _FrontInsertionSequence>\n+struct _FrontInsertionSequence_concept_specification {\n+static void\n+_FrontInsertionSequence_requirement_violation(_FrontInsertionSequence __s) {\n+  // Refinement of Sequence\n+  _Sequence_concept_specification<_FrontInsertionSequence>::_Sequence_requirement_violation(__s);\n+  // Valid Expressions\n+  _ERROR_IN_STL_SEQ::__push_front_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__pop_front_function_requirement_violation(__s);\n+}\n+};\n+\n+template <class _BackInsertionSequence>\n+struct _BackInsertionSequence_concept_specification {\n+static void\n+_BackInsertionSequence_requirement_violation(_BackInsertionSequence __s) {\n+  // Refinement of Sequence\n+  _Sequence_concept_specification<_BackInsertionSequence>::_Sequence_requirement_violation(__s);\n+  // Valid Expressions\n+  _ERROR_IN_STL_SEQ::__back_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__push_back_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__pop_back_function_requirement_violation(__s);\n+}\n+};\n+\n+#endif /* if __STL_USE_CONCEPT_CHECKS */\n+\n+\n+#endif /* STL_SEQUENCE_CONCEPTS_H */"}]}