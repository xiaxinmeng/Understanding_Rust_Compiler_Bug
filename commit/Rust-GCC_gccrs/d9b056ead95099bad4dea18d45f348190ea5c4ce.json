{"sha": "d9b056ead95099bad4dea18d45f348190ea5c4ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDliMDU2ZWFkOTUwOTliYWQ0ZGVhMThkNDVmMzQ4MTkwZWE1YzRjZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T12:02:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T12:02:01Z"}, "message": "[multiple changes]\n\n2011-08-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* bindgen.adb (Gen_Finalize_Library_Ada): Factor out code to generate\n\tthe header of the finalization routine.\n\tIf the unit has no finalizer but is a body whose spec has one, then\n\tgenerate the decrement of the elaboration entity only.\n\tIf the unit has a finalizer and is a spec, then do not generate the\n\tdecrement of the elaboration entity.\n\t(Gen_Finalize_Library_C): Likewise.\n\n2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Alignment_Of): New subsidiary routine.\n\t(Bounds_Size_Expression): Removed.\n\t(Double_Alignment_Of): New subsidiary routine.\n\t(Make_Finalize_Address_Stmts): New local variable Index_Typ. Account\n\tfor a hole in the dope vector of unconstrained arrays due to different\n\tindex and element alignments.\n\n2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Allocator): diagnose task allocator that will\n\traise program_error because body has not been seen yet.\n\n2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Analyze_With_Clause): Protect against child unit with\n\tan unresolved name.\n\n2011-08-04  Vincent Celier  <celier@adacore.com>\n\n\t* makeutl.adb (Do_Complete): Check absolute paths in canonical forms\n\n2011-08-04  Yannick Moy  <moy@adacore.com>\n\n\t* alfa.adb, alfa.ads (Unique_Defining_Entity): move function from here\n\t* sem_util.adb, sem_util.ads (Unique_Defining_Entity): ...to here\n\n2011-08-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Package_Instantiation): Do not omit body for\n\tinstantiation in RCI.\n\n2011-08-04  Emmanuel Briot  <briot@adacore.com>\n\n\t* make.adb: Share more code with gprbuild\n\nFrom-SVN: r177361", "tree": {"sha": "6f92f864c0116522b5ab5e59fa7501acb70447e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f92f864c0116522b5ab5e59fa7501acb70447e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9b056ead95099bad4dea18d45f348190ea5c4ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b056ead95099bad4dea18d45f348190ea5c4ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b056ead95099bad4dea18d45f348190ea5c4ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b056ead95099bad4dea18d45f348190ea5c4ce/comments", "author": null, "committer": null, "parents": [{"sha": "f5fc5b9d7b80431e1f62b9409291893209fb2d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5fc5b9d7b80431e1f62b9409291893209fb2d1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5fc5b9d7b80431e1f62b9409291893209fb2d1b"}], "stats": {"total": 734, "additions": 462, "deletions": 272}, "files": [{"sha": "f24846bd44de022f037eaf2fb7cacb6c8e1e2137", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -1,3 +1,50 @@\n+2011-08-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* bindgen.adb (Gen_Finalize_Library_Ada): Factor out code to generate\n+\tthe header of the finalization routine.\n+\tIf the unit has no finalizer but is a body whose spec has one, then\n+\tgenerate the decrement of the elaboration entity only.\n+\tIf the unit has a finalizer and is a spec, then do not generate the\n+\tdecrement of the elaboration entity.\n+\t(Gen_Finalize_Library_C): Likewise.\n+\n+2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Alignment_Of): New subsidiary routine.\n+\t(Bounds_Size_Expression): Removed.\n+\t(Double_Alignment_Of): New subsidiary routine.\n+\t(Make_Finalize_Address_Stmts): New local variable Index_Typ. Account\n+\tfor a hole in the dope vector of unconstrained arrays due to different\n+\tindex and element alignments.\n+\n+2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Allocator): diagnose task allocator that will\n+\traise program_error because body has not been seen yet.\n+\n+2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Analyze_With_Clause): Protect against child unit with\n+\tan unresolved name.\n+\n+2011-08-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* makeutl.adb (Do_Complete): Check absolute paths in canonical forms\n+\n+2011-08-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* alfa.adb, alfa.ads (Unique_Defining_Entity): move function from here\n+\t* sem_util.adb, sem_util.ads (Unique_Defining_Entity): ...to here\n+\n+2011-08-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Package_Instantiation): Do not omit body for\n+\tinstantiation in RCI.\n+\n+2011-08-04  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* make.adb: Share more code with gprbuild\n+\n 2011-08-04  Emmanuel Briot  <briot@adacore.com>\n \n \t* projects.texi: Added documentation for the IDE'Gnat project file"}, {"sha": "6fd1d8f8aae85706286cfeab8ded7ed380dc0fdb", "filename": "gcc/ada/alfa.adb", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Falfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Falfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -23,11 +23,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;    use Atree;\n with Output;   use Output;\n with Put_ALFA;\n-with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n \n package body ALFA is\n \n@@ -203,26 +200,4 @@ package body ALFA is\n       Debug_Put_ALFA;\n    end palfa;\n \n-   ----------------------------\n-   -- Unique_Defining_Entity --\n-   ----------------------------\n-\n-   function Unique_Defining_Entity (N : Node_Id) return Entity_Id is\n-   begin\n-      case Nkind (N) is\n-         when N_Package_Body =>\n-            return Corresponding_Spec (N);\n-\n-         when N_Subprogram_Body =>\n-            if Acts_As_Spec (N) then\n-               return Defining_Entity (N);\n-            else\n-               return Corresponding_Spec (N);\n-            end if;\n-\n-         when others =>\n-            return Defining_Entity (N);\n-      end case;\n-   end Unique_Defining_Entity;\n-\n end ALFA;"}, {"sha": "71220e46bda21186a38833ce0fa220c68c2b28d1", "filename": "gcc/ada/alfa.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Falfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Falfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.ads?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -319,10 +319,6 @@ package ALFA is\n    procedure Initialize_ALFA_Tables;\n    --  Reset tables for a new compilation\n \n-   function Unique_Defining_Entity (N : Node_Id) return Entity_Id;\n-   --  Return the entity which represents declaration N, so that matching\n-   --  declaration and body have the same entity.\n-\n    procedure dalfa;\n    --  Debug routine to dump internal ALFA tables. This is a raw format dump\n    --  showing exactly what the tables contain."}, {"sha": "41256aebc66d8e81de5e9f268657c9e6ad6a23be", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 136, "deletions": 61, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -1662,38 +1662,84 @@ package body Bindgen is\n       Uspec : Unit_Record;\n       Unum  : Unit_Id;\n \n+      procedure Gen_Header;\n+      --  Generate the header of the finalization routine\n+\n+      procedure Gen_Header is\n+      begin\n+         WBI (\"   procedure finalize_library is\");\n+\n+         --  The following flag is used to check for library-level\n+         --  exceptions raised during finalization. The symbol comes\n+         --  from System.Soft_Links. VM targets use regular Ada to\n+         --  reference the entity.\n+\n+         if VM_Target = No_VM then\n+            WBI (\"      LE_Set : Boolean;\");\n+\n+            Set_String (\"      pragma Import (Ada, LE_Set, \");\n+            Set_String (\"\"\"__gnat_library_exception_set\"\");\");\n+            Write_Statement_Buffer;\n+         end if;\n+\n+         WBI (\"   begin\");\n+      end Gen_Header;\n+\n    begin\n       for E in reverse Elab_Order.First .. Elab_Order.Last loop\n          Unum := Elab_Order.Table (E);\n          U    := Units.Table (Unum);\n \n+         --  Dealing with package bodies is a little complicated. In such\n+         --  cases we must retrieve the package spec since it contains the\n+         --  spec of the body finalizer.\n+\n+         if U.Utype = Is_Body then\n+            Unum  := Unum + 1;\n+            Uspec := Units.Table (Unum);\n+         else\n+            Uspec := U;\n+         end if;\n+\n+         Get_Name_String (Uspec.Uname);\n+\n          --  We are only interested in non-generic packages\n \n-         if U.Unit_Kind = 'p'\n-           and then U.Has_Finalizer\n-           and then not U.Is_Generic\n-           and then not U.SAL_Interface\n-           and then not U.No_Elab\n-         then\n-            if not Lib_Final_Built then\n-               Lib_Final_Built := True;\n+         if U.Unit_Kind /= 'p' or else U.Is_Generic then\n+            null;\n \n-               WBI (\"   procedure finalize_library is\");\n+         --  That aren't an interface to a stand alone library\n \n-               --  The following flag is used to check for library-level\n-               --  exceptions raised during finalization. The symbol comes\n-               --  from System.Soft_Links. VM targets use regular Ada to\n-               --  reference the entity.\n+         elsif U.SAL_Interface then\n+            null;\n \n-               if VM_Target = No_VM then\n-                  WBI (\"      LE_Set : Boolean;\");\n+         --  Case of no finalization\n \n-                  Set_String (\"      pragma Import (Ada, LE_Set, \");\n-                  Set_String (\"\"\"__gnat_library_exception_set\"\");\");\n-                  Write_Statement_Buffer;\n+         elsif not U.Has_Finalizer then\n+\n+            --  The only case in which we have to do something is if this\n+            --  is a body, with a separate spec, where the separate spec\n+            --  has a finalizer. In that case, this is where we decrement\n+            --  the elaboration entity.\n+\n+            if U.Utype = Is_Body and then Uspec.Has_Finalizer then\n+               if not Lib_Final_Built then\n+                  Gen_Header;\n+                  Lib_Final_Built := True;\n                end if;\n \n-               WBI (\"   begin\");\n+               Set_String (\"      E\");\n+               Set_Unit_Number (Unum);\n+               Set_String (\" := E\");\n+               Set_Unit_Number (Unum);\n+               Set_String (\" - 1;\");\n+               Write_Statement_Buffer;\n+            end if;\n+\n+         else\n+            if not Lib_Final_Built then\n+               Gen_Header;\n+               Lib_Final_Built := True;\n             end if;\n \n             --  Generate:\n@@ -1732,19 +1778,6 @@ package body Bindgen is\n             Set_Int (Count);\n             Set_String (\", \"\"\");\n \n-            --  Dealing with package bodies is a little complicated. In such\n-            --  cases we must retrieve the package spec since it contains the\n-            --  spec of the body finalizer.\n-\n-            if U.Utype = Is_Body then\n-               Unum  := Unum + 1;\n-               Uspec := Units.Table (Unum);\n-            else\n-               Uspec := U;\n-            end if;\n-\n-            Get_Name_String (Uspec.Uname);\n-\n             --  Perform name construction\n \n             --  .NET   xx.yy_pkg.xx__yy__finalize\n@@ -1798,13 +1831,19 @@ package body Bindgen is\n             --       F<Count>;\n             --    end;\n \n+            --  The uname_E decrement is skipped if this is a separate spec,\n+            --  since it will be done when we process the body.\n+\n             WBI (\"      begin\");\n-            Set_String (\"         E\");\n-            Set_Unit_Number (Unum);\n-            Set_String (\" := E\");\n-            Set_Unit_Number (Unum);\n-            Set_String (\" - 1;\");\n-            Write_Statement_Buffer;\n+\n+            if U.Utype /= Is_Spec then\n+               Set_String (\"         E\");\n+               Set_Unit_Number (Unum);\n+               Set_String (\" := E\");\n+               Set_Unit_Number (Unum);\n+               Set_String (\" - 1;\");\n+               Write_Statement_Buffer;\n+            end if;\n \n             if Interface_Library_Unit or not Bind_Main_Program then\n                Set_String (\"         if E\");\n@@ -1884,37 +1923,68 @@ package body Bindgen is\n       Uspec : Unit_Record;\n       Unum  : Unit_Id;\n \n+      procedure Gen_Header;\n+      --  Generate the header of the finalization routine\n+\n+      procedure Gen_Header is\n+      begin\n+         WBI (\"static void finalize_library(void) {\");\n+      end Gen_Header;\n+\n    begin\n       for E in reverse Elab_Order.First .. Elab_Order.Last loop\n          Unum := Elab_Order.Table (E);\n          U    := Units.Table (Unum);\n \n+         --  Dealing with package bodies is a little complicated. In such\n+         --  cases we must retrieve the package spec since it contains the\n+         --  spec of the body finalizer.\n+\n+         if U.Utype = Is_Body then\n+            Unum  := Unum + 1;\n+            Uspec := Units.Table (Unum);\n+         else\n+            Uspec := U;\n+         end if;\n+\n+         Get_Name_String (Uspec.Uname);\n+\n          --  We are only interested in non-generic packages\n \n-         if U.Unit_Kind = 'p'\n-           and then U.Has_Finalizer\n-           and then not U.Is_Generic\n-           and then not U.SAL_Interface\n-           and then not U.No_Elab\n-         then\n-            if not Lib_Final_Built then\n-               Lib_Final_Built := True;\n+         if U.Unit_Kind /= 'p' or else U.Is_Generic then\n+            null;\n \n-               WBI (\"static void finalize_library(void) {\");\n-            end if;\n+         --  That aren't an interface to a stand alone library\n \n-            --  Dealing with package bodies is a little complicated. In such\n-            --  cases we must retrieve the package spec since it contains the\n-            --  spec of the body finalizer.\n+         elsif U.SAL_Interface then\n+            null;\n \n-            if U.Utype = Is_Body then\n-               Unum  := Unum + 1;\n-               Uspec := Units.Table (Unum);\n-            else\n-               Uspec := U;\n+         --  Case of no finalization\n+\n+         elsif not U.Has_Finalizer then\n+\n+            --  The only case in which we have to do something is if this\n+            --  is a body, with a separate spec, where the separate spec\n+            --  has a finalizer. In that case, this is where we decrement\n+            --  the elaboration entity.\n+\n+            if U.Utype = Is_Body and then Uspec.Has_Finalizer then\n+               if not Lib_Final_Built then\n+                  Gen_Header;\n+                  Lib_Final_Built := True;\n+               end if;\n+\n+               Set_String (\"   \");\n+               Set_Unit_Name;\n+               Set_String (\"_E--;\");\n+               Write_Statement_Buffer;\n             end if;\n \n-            Get_Name_String (Uspec.Uname);\n+         else\n+            if not Lib_Final_Built then\n+               Gen_Header;\n+               Lib_Final_Built := True;\n+            end if;\n \n             --  If binding a library or if there is a non-Ada main subprogram\n             --  then we generate:\n@@ -1928,10 +1998,15 @@ package body Bindgen is\n             --    uname_E--;\n             --    uname__finalize_[spec|body] ();\n \n-            Set_String (\"   \");\n-            Set_Unit_Name;\n-            Set_String (\"_E--;\");\n-            Write_Statement_Buffer;\n+            --  The uname_E decrement is skipped if this is a separate spec,\n+            --  since it will be done when we process the body.\n+\n+            if U.Utype /= Is_Spec then\n+               Set_String (\"   \");\n+               Set_Unit_Name;\n+               Set_String (\"_E--;\");\n+               Write_Statement_Buffer;\n+            end if;\n \n             if Interface_Library_Unit or not Bind_Main_Program then\n                Set_String (\"   if (\");"}, {"sha": "3891b030d4ee6be94d5bcc724fc8284bb1ffb535", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 70, "deletions": 33, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -6865,6 +6865,42 @@ package body Exp_Ch7 is\n       Desg_Typ : Entity_Id;\n       Obj_Expr : Node_Id;\n \n+      function Alignment_Of (Some_Typ : Entity_Id) return Node_Id;\n+      --  Subsidiary routine, generate the following attribute reference:\n+      --\n+      --    Some_Typ'Alignment\n+\n+      function Double_Alignment_Of (Some_Typ : Entity_Id) return Node_Id;\n+      --  Subsidiary routine, generate the following expression:\n+      --\n+      --    2 * Some_Typ'Alignment\n+\n+      ------------------\n+      -- Alignment_Of --\n+      ------------------\n+\n+      function Alignment_Of (Some_Typ : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Reference_To (Some_Typ, Loc),\n+             Attribute_Name => Name_Alignment);\n+      end Alignment_Of;\n+\n+      -------------------------\n+      -- Double_Alignment_Of --\n+      -------------------------\n+\n+      function Double_Alignment_Of (Some_Typ : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Op_Multiply (Loc,\n+             Left_Opnd  => Make_Integer_Literal (Loc, 2),\n+             Right_Opnd => Alignment_Of (Some_Typ));\n+      end Double_Alignment_Of;\n+\n+   --  Start of processing for Make_Finalize_Address_Stmts\n+\n    begin\n       if Is_Array_Type (Typ) then\n          if Is_Constrained (First_Subtype (Typ)) then\n@@ -6931,7 +6967,7 @@ package body Exp_Ch7 is\n \n       --  Unconstrained arrays require special processing in order to retrieve\n       --  the elements. To achieve this, we have to skip the dope vector which\n-      --  lays infront of the elements and then use a thin pointer to perform\n+      --  lays in front of the elements and then use a thin pointer to perform\n       --  the address-to-access conversion.\n \n       if Is_Array_Type (Typ)\n@@ -6942,30 +6978,7 @@ package body Exp_Ch7 is\n             Dope_Id   : Entity_Id;\n             For_First : Boolean := True;\n             Index     : Node_Id;\n-\n-            function Bounds_Size_Expression (Typ : Entity_Id) return Node_Id;\n-            --  Given the type of an array index, create the following\n-            --  expression:\n-            --\n-            --    2 * Esize (Typ) / Storage_Unit\n-\n-            ----------------------------\n-            -- Bounds_Size_Expression --\n-            ----------------------------\n-\n-            function Bounds_Size_Expression (Typ : Entity_Id) return Node_Id is\n-            begin\n-               return\n-                 Make_Op_Multiply (Loc,\n-                   Left_Opnd  => Make_Integer_Literal (Loc, 2),\n-                   Right_Opnd =>\n-                     Make_Op_Divide (Loc,\n-                       Left_Opnd  => Make_Integer_Literal (Loc, Esize (Typ)),\n-                       Right_Opnd =>\n-                         Make_Integer_Literal (Loc, System_Storage_Unit)));\n-            end Bounds_Size_Expression;\n-\n-         --  Start of processing for arrays\n+            Index_Typ : Entity_Id;\n \n          begin\n             --  Ensure that Ptr_Typ a thin pointer, generate:\n@@ -6980,32 +6993,56 @@ package body Exp_Ch7 is\n                   Make_Integer_Literal (Loc, System_Address_Size)));\n \n             --  For unconstrained arrays, create the expression which computes\n-            --  the size of the dope vector. Note that in the end, all values\n-            --  will be constant folded.\n+            --  the size of the dope vector.\n \n             Index := First_Index (Typ);\n             while Present (Index) loop\n+               Index_Typ := Etype (Index);\n \n-               --  Generate:\n-               --    2 * Esize (Index_Typ) / Storage_Unit\n+               --  Each bound has two values and a potential hole added to\n+               --  compensate for alignment differences.\n \n                if For_First then\n                   For_First := False;\n-                  Dope_Expr := Bounds_Size_Expression (Etype (Index));\n \n-               --  Generate:\n-               --    Dope_Expr + 2 * Esize (Index_Typ) / Storage_Unit\n+                  --  Generate:\n+                  --    2 * Index_Typ'Alignment\n+\n+                  Dope_Expr := Double_Alignment_Of (Index_Typ);\n \n                else\n+                  --  Generate:\n+                  --    Dope_Expr + 2 * Index_Typ'Alignment\n+\n                   Dope_Expr :=\n                     Make_Op_Add (Loc,\n                       Left_Opnd  => Dope_Expr,\n-                      Right_Opnd => Bounds_Size_Expression (Etype (Index)));\n+                      Right_Opnd => Double_Alignment_Of (Index_Typ));\n                end if;\n \n                Next_Index (Index);\n             end loop;\n \n+            --  Round the cumulative alignment to the next higher multiple of\n+            --  the array alignment. Generate:\n+\n+            --    ((Dope_Expr + Typ'Alignment - 1) / Typ'Alignment)\n+            --        * Typ'Alignment\n+\n+            Dope_Expr :=\n+              Make_Op_Multiply (Loc,\n+                Left_Opnd  =>\n+                  Make_Op_Divide (Loc,\n+                    Left_Opnd  =>\n+                      Make_Op_Add (Loc,\n+                        Left_Opnd  => Dope_Expr,\n+                        Right_Opnd =>\n+                          Make_Op_Subtract (Loc,\n+                            Left_Opnd  => Alignment_Of (Typ),\n+                            Right_Opnd => Make_Integer_Literal (Loc, 1))),\n+                    Right_Opnd => Alignment_Of (Typ)),\n+                Right_Opnd => Alignment_Of (Typ));\n+\n             --  Generate:\n             --    Dnn : Storage_Offset := Dope_Expr;\n "}, {"sha": "c0129c332c727a9fb51170b872676a071764a63b", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 144, "deletions": 133, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -4142,141 +4142,152 @@ package body Make is\n       -----------------\n \n       procedure Check_Mains is\n-         Real_Main_Project : Project_Id := No_Project;\n-         --  The project of the first main\n-\n-         Proj              : Project_Id := No_Project;\n-         --  The project of the current main\n-\n-         Real_Path         : String_Access;\n-\n       begin\n-         Mains.Reset;\n-\n-         --  Check each main\n-\n-         loop\n-            declare\n-               Main      : constant String := Mains.Next_Main;\n-               --  The name specified on the command line may include directory\n-               --  information.\n-\n-               File_Name : constant String := Base_Name (Main);\n-               --  The simple file name of the current main\n-\n-               Lang : Language_Ptr;\n-\n-            begin\n-               exit when Main = \"\";\n-\n-               --  Get the project of the current main\n-\n-               Proj := Prj.Env.Project_Of\n-                         (File_Name, Main_Project, Project_Tree);\n-\n-               --  Fail if the current main is not a source of a project\n-\n-               if Proj = No_Project then\n-                  Make_Failed\n-                    (\"\"\"\" & Main & \"\"\" is not a source of any project\");\n-\n-               else\n-                  --  If there is directory information, check that the source\n-                  --  exists and, if it does, that the path is the actual path\n-                  --  of a source of a project.\n-\n-                  if Main /= File_Name then\n-                     Lang := Get_Language_From_Name (Main_Project, \"ada\");\n-\n-                     Real_Path :=\n-                       Locate_Regular_File\n-                         (Main & Get_Name_String\n-                              (Lang.Config.Naming_Data.Body_Suffix),\n-                          \"\");\n-                     if Real_Path = null then\n-                        Real_Path :=\n-                          Locate_Regular_File\n-                            (Main & Get_Name_String\n-                                 (Lang.Config.Naming_Data.Spec_Suffix),\n-                             \"\");\n-                     end if;\n-\n-                     if Real_Path = null then\n-                        Real_Path := Locate_Regular_File (Main, \"\");\n-                     end if;\n-\n-                     --  Fail if the file cannot be found\n-\n-                     if Real_Path = null then\n-                        Make_Failed (\"file \"\"\" & Main & \"\"\" does not exist\");\n-                     end if;\n-\n-                     declare\n-                        Project_Path : constant String :=\n-                                         Prj.Env.File_Name_Of_Library_Unit_Body\n-                                           (Name              => File_Name,\n-                                            Project           => Main_Project,\n-                                            In_Tree           => Project_Tree,\n-                                            Main_Project_Only => False,\n-                                            Full_Path         => True);\n-                        Normed_Path  : constant String :=\n-                                         Normalize_Pathname\n-                                           (Real_Path.all,\n-                                            Case_Sensitive => False);\n-                        Proj_Path    : constant String :=\n-                                         Normalize_Pathname\n-                                           (Project_Path,\n-                                            Case_Sensitive => False);\n-\n-                     begin\n-                        Free (Real_Path);\n-\n-                        --  Fail if it is not the correct path\n-\n-                        if Normed_Path /= Proj_Path then\n-                           if Verbose_Mode then\n-                              Set_Standard_Error;\n-                              Write_Str (Normed_Path);\n-                              Write_Str (\" /= \");\n-                              Write_Line (Proj_Path);\n-                           end if;\n-\n-                           Make_Failed\n-                             (\"\"\"\" & Main &\n-                              \"\"\" is not a source of any project\");\n-                        end if;\n-                     end;\n-                  end if;\n-\n-                  if not Unique_Compile then\n-\n-                     --  Record the project, if it is the first main\n-\n-                     if Real_Main_Project = No_Project then\n-                        Real_Main_Project := Proj;\n-\n-                     elsif Proj /= Real_Main_Project then\n-\n-                        --  Fail, as the current main is not a source of the\n-                        --  same project as the first main.\n-\n-                        Make_Failed\n-                          (\"\"\"\" & Main &\n-                           \"\"\" is not a source of project \" &\n-                           Get_Name_String (Real_Main_Project.Name));\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               --  If -u and -U are not used, we may have mains that are\n-               --  sources of a project that is not the one specified with\n-               --  switch -P.\n+         if Mains.Number_Of_Mains (Project_Tree) = 0\n+           and then not Unique_Compile\n+         then\n+            Mains.Fill_From_Project (Main_Project, Project_Tree);\n+         end if;\n \n-               if not Unique_Compile then\n-                  Main_Project := Real_Main_Project;\n-               end if;\n-            end;\n-         end loop;\n+         Mains.Complete_Mains\n+           (Root_Environment.Flags, Main_Project, Project_Tree);\n+--\n+--\n+--           Real_Main_Project : Project_Id := No_Project;\n+--           --  The project of the first main\n+--\n+--           Proj              : Project_Id := No_Project;\n+--           --  The project of the current main\n+--\n+--           Real_Path         : String_Access;\n+--\n+--        begin\n+--           Mains.Reset;\n+--\n+--           --  Check each main\n+--\n+--           loop\n+--              declare\n+--                 Main      : constant String := Mains.Next_Main;\n+--            --  The name specified on the command line may include directory\n+--                 --  information.\n+--\n+--                 File_Name : constant String := Base_Name (Main);\n+--                 --  The simple file name of the current main\n+--\n+--                 Lang : Language_Ptr;\n+--\n+--              begin\n+--                 exit when Main = \"\";\n+--\n+--                 --  Get the project of the current main\n+--\n+--                 Proj := Prj.Env.Project_Of\n+--                           (File_Name, Main_Project, Project_Tree);\n+--\n+--                 --  Fail if the current main is not a source of a project\n+--\n+--                 if Proj = No_Project then\n+--                    Make_Failed\n+--                      (\"\"\"\" & Main & \"\"\" is not a source of any project\");\n+--\n+--                 else\n+--                --  If there is directory information, check that the source\n+--                --  exists and, if it does, that the path is the actual path\n+--                    --  of a source of a project.\n+--\n+--                    if Main /= File_Name then\n+--                       Lang := Get_Language_From_Name (Main_Project, \"ada\");\n+--\n+--                       Real_Path :=\n+--                         Locate_Regular_File\n+--                           (Main & Get_Name_String\n+--                                (Lang.Config.Naming_Data.Body_Suffix),\n+--                            \"\");\n+--                       if Real_Path = null then\n+--                          Real_Path :=\n+--                            Locate_Regular_File\n+--                              (Main & Get_Name_String\n+--                                   (Lang.Config.Naming_Data.Spec_Suffix),\n+--                               \"\");\n+--                       end if;\n+--\n+--                       if Real_Path = null then\n+--                          Real_Path := Locate_Regular_File (Main, \"\");\n+--                       end if;\n+--\n+--                       --  Fail if the file cannot be found\n+--\n+--                       if Real_Path = null then\n+--                        Make_Failed (\"file \"\"\" & Main & \"\"\" does not exist\");\n+--                       end if;\n+--\n+--                       declare\n+--                          Project_Path : constant String :=\n+--                                      Prj.Env.File_Name_Of_Library_Unit_Body\n+--                                           (Name              => File_Name,\n+--                                          Project           => Main_Project,\n+--                                          In_Tree           => Project_Tree,\n+--                                              Main_Project_Only => False,\n+--                                              Full_Path         => True);\n+--                          Normed_Path  : constant String :=\n+--                                           Normalize_Pathname\n+--                                             (Real_Path.all,\n+--                                              Case_Sensitive => False);\n+--                          Proj_Path    : constant String :=\n+--                                           Normalize_Pathname\n+--                                             (Project_Path,\n+--                                              Case_Sensitive => False);\n+--\n+--                       begin\n+--                          Free (Real_Path);\n+--\n+--                          --  Fail if it is not the correct path\n+--\n+--                          if Normed_Path /= Proj_Path then\n+--                             if Verbose_Mode then\n+--                                Set_Standard_Error;\n+--                                Write_Str (Normed_Path);\n+--                                Write_Str (\" /= \");\n+--                                Write_Line (Proj_Path);\n+--                             end if;\n+--\n+--                             Make_Failed\n+--                               (\"\"\"\" & Main &\n+--                                \"\"\" is not a source of any project\");\n+--                          end if;\n+--                       end;\n+--                    end if;\n+--\n+--                    if not Unique_Compile then\n+--\n+--                       --  Record the project, if it is the first main\n+--\n+--                       if Real_Main_Project = No_Project then\n+--                          Real_Main_Project := Proj;\n+--\n+--                       elsif Proj /= Real_Main_Project then\n+--\n+--                        --  Fail, as the current main is not a source of the\n+--                          --  same project as the first main.\n+--\n+--                          Make_Failed\n+--                            (\"\"\"\" & Main &\n+--                             \"\"\" is not a source of project \" &\n+--                             Get_Name_String (Real_Main_Project.Name));\n+--                       end if;\n+--                    end if;\n+--                 end if;\n+--\n+--                 --  If -u and -U are not used, we may have mains that are\n+--                 --  sources of a project that is not the one specified with\n+--                 --  switch -P.\n+--\n+--                 if not Unique_Compile then\n+--                    Main_Project := Real_Main_Project;\n+--                 end if;\n+--              end;\n+--           end loop;\n       end Check_Mains;\n \n    --  Start of processing for Gnatmake"}, {"sha": "17aba0472210fc03d59ae474235de52e96ee5e0d", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -1347,7 +1347,7 @@ package body Makeutl is\n             then\n                --  Traverse in reverse order, since in the case of multi-unit\n                --  files we will be adding extra files at the end, and there's\n-               --  no need to process them in tun.\n+               --  no need to process them in turn.\n \n                for J in reverse Names.First .. Names.Last loop\n                   declare\n@@ -1457,7 +1457,7 @@ package body Makeutl is\n \n                         else\n                            if Is_Absolute then\n-                              if File_Name_Type (Source.Path.Display_Name) /=\n+                              if File_Name_Type (Source.Path.Name) /=\n                                 File.File\n                               then\n                                  Debug_Output"}, {"sha": "0fcf6695c7b26a9d87b86f149379a79e606eaa3e", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -2602,8 +2602,16 @@ package body Sem_Ch10 is\n             Par_Name := Entity (Pref);\n          end if;\n \n-         Set_Entity_With_Style_Check (Pref, Par_Name);\n-         Generate_Reference (Par_Name, Pref);\n+         --  Guard against missing or misspelled child units.\n+\n+         if Present (Par_Name) then\n+            Set_Entity_With_Style_Check (Pref, Par_Name);\n+            Generate_Reference (Par_Name, Pref);\n+\n+         else\n+            Set_Name (N, Make_Null (Sloc (N)));\n+            return;\n+         end if;\n       end if;\n \n       --  If the withed unit is System, and a system extension pragma is"}, {"sha": "de9f5781fc9f36af09c6f39a532361d96cce6886", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -3379,18 +3379,18 @@ package body Sem_Ch12 is\n             end if;\n          end;\n \n-         --  If we are generating calling stubs, we never need a body for an\n-         --  instantiation from source in the visible part, because in that\n-         --  case we'll be generating stubs for any subprogram in the instance.\n-         --  However normal processing occurs for instantiations in generated\n-         --  code or in the private part, since in those cases we do not\n-         --  generate stubs.\n-\n-         if Distribution_Stub_Mode = Generate_Caller_Stub_Body\n-              and then Comes_From_Source (N)\n-         then\n-            Needs_Body := False;\n-         end if;\n+         --  Note that we generate the instance body even when generating\n+         --  calling stubs for an RCI unit: it may be required e.g. if it\n+         --  provides stream attributes for some type used in the profile of a\n+         --  remote subprogram. If the instantiation is within the visible part\n+         --  of the RCI, then calling stubs for any relevant subprogram will\n+         --  be inserted immediately after the subprogram declaration, and\n+         --  will take precedence over the subsequent (original) body. (The\n+         --  stub and original body will be complete homographs, but this is\n+         --  permitted in an instance).\n+\n+         --  Could we do better and remove the original subprogram body in that\n+         --  case???\n \n          if Needs_Body then\n "}, {"sha": "e512ff0fb36e41e21a537046eee7140e7448f748", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -4342,6 +4342,21 @@ package body Sem_Res is\n             Set_Is_Static_Coextension  (N, False);\n          end if;\n       end if;\n+\n+      --  Report a simple error:  if the designated object is a local task,\n+      --  its body has not been seen yet, and its activation will fail\n+      --  an elaboration check.\n+\n+      if Is_Task_Type (Designated_Type (Typ))\n+        and then Scope (Base_Type (Designated_Type (Typ))) = Current_Scope\n+        and then Is_Compilation_Unit (Current_Scope)\n+        and then Ekind (Current_Scope) = E_Package\n+        and then not In_Package_Body (Current_Scope)\n+      then\n+         Error_Msg_N\n+           (\"cannot activate task before body seen?\", N);\n+         Error_Msg_N (\"\\Program_Error will be raised at run time\", N);\n+      end if;\n    end Resolve_Allocator;\n \n    ---------------------------"}, {"sha": "4bfb83a3b05098251612fc5179644d6231ae8521", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -12179,6 +12179,28 @@ package body Sem_Util is\n       return Scope_Depth (Enclosing_Dynamic_Scope (Btyp));\n    end Type_Access_Level;\n \n+   ----------------------------\n+   -- Unique_Defining_Entity --\n+   ----------------------------\n+\n+   function Unique_Defining_Entity (N : Node_Id) return Entity_Id is\n+   begin\n+      case Nkind (N) is\n+         when N_Package_Body =>\n+            return Corresponding_Spec (N);\n+\n+         when N_Subprogram_Body =>\n+            if Acts_As_Spec (N) then\n+               return Defining_Entity (N);\n+            else\n+               return Corresponding_Spec (N);\n+            end if;\n+\n+         when others =>\n+            return Defining_Entity (N);\n+      end case;\n+   end Unique_Defining_Entity;\n+\n    --------------------------\n    -- Unit_Declaration_Node --\n    --------------------------"}, {"sha": "a16544d9274d18ad81e93c46f722ae5f9f3676ca", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b056ead95099bad4dea18d45f348190ea5c4ce/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d9b056ead95099bad4dea18d45f348190ea5c4ce", "patch": "@@ -1368,6 +1368,10 @@ package Sem_Util is\n    function Type_Access_Level (Typ : Entity_Id) return Uint;\n    --  Return the accessibility level of Typ\n \n+   function Unique_Defining_Entity (N : Node_Id) return Entity_Id;\n+   --  Return the entity which represents declaration N, so that matching\n+   --  declaration and body have the same entity.\n+\n    function Unit_Declaration_Node (Unit_Id : Entity_Id) return Node_Id;\n    --  Unit_Id is the simple name of a program unit, this function returns the\n    --  corresponding xxx_Declaration node for the entity. Also applies to the"}]}