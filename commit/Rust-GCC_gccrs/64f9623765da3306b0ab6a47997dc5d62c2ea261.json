{"sha": "64f9623765da3306b0ab6a47997dc5d62c2ea261", "node_id": "C_kwDOANBUbNoAKDY0Zjk2MjM3NjVkYTMzMDZiMGFiNmE0Nzk5N2RjNWQ2MmMyZWEyNjE", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-10-18T07:51:36Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-10-18T08:29:30Z"}, "message": "Fortran: Fix Bind(C) Array-Descriptor Conversion\n\ngfortran uses internally a different array descriptor (\"gfc\") as\nFortran 2018 alias TS291113 defines for C interoperability via\nISO_Fortran_binding.h (\"CFI\").  Hence, when calling a C function\nfrom Fortran, it has to be converted in the callee - and if a\nBIND(C) procedure is written in Fortran, the CFI argument has\nto be converted to gfc in order work with the rest of the FE\ncode and the library calls.\n\nBefore this patch, part was handled in the FE generated code and\nother parts in libgfortran.  With this patch, all code is generated\nand CFI is defined as proper type - visible in the debugger and to\nthe middle end - avoiding both alias issues and missed optimization\nissues.\n\nThis patch also fixes issues like: intent(out) deallocation in\nthe bind(C) callee, using the CFI descriptor also for allocatable\nand pointer scalars and for len=* character strings.\nFor 'select rank', it also optimizes the code + avoid accessing\nuninitialized memory if the dummy argument is allocatable/a pointer.\nIt additionally rejects passing a descriptorless type(*) to an\nassumed-rank dummy argument. [F2018:C711]\n\n\tPR fortran/102086\n\tPR fortran/92189\n\tPR fortran/92621\n\tPR fortran/101308\n\tPR fortran/101309\n\tPR fortran/101635\n\tPR fortran/92482\n\ngcc/fortran/ChangeLog:\n\n\t* decl.c (gfc_verify_c_interop_param): Remove 'sorry' for\n\tscalar allocatable/pointer and len=*.\n\t* expr.c (is_CFI_desc): Return true for for those.\n\t* gfortran.h (CFI_type_kind_shift, CFI_type_mask,\n\tCFI_type_from_type_kind, CFI_VERSION, CFI_MAX_RANK,\n\tCFI_attribute_pointer, CFI_attribute_allocatable,\n\tCFI_attribute_other, CFI_type_Integer, CFI_type_Logical,\n\tCFI_type_Real, CFI_type_Complex, CFI_type_Character,\n\tCFI_type_ucs4_char, CFI_type_struct, CFI_type_cptr,\n\tCFI_type_cfunptr, CFI_type_other): New #define.\n\t* trans-array.c (CFI_FIELD_BASE_ADDR, CFI_FIELD_ELEM_LEN,\n\tCFI_FIELD_VERSION, CFI_FIELD_RANK, CFI_FIELD_ATTRIBUTE,\n\tCFI_FIELD_TYPE, CFI_FIELD_DIM, CFI_DIM_FIELD_LOWER_BOUND,\n\tCFI_DIM_FIELD_EXTENT, CFI_DIM_FIELD_SM,\n\tgfc_get_cfi_descriptor_field, gfc_get_cfi_desc_base_addr,\n\tgfc_get_cfi_desc_elem_len, gfc_get_cfi_desc_version,\n\tgfc_get_cfi_desc_rank, gfc_get_cfi_desc_type,\n\tgfc_get_cfi_desc_attribute, gfc_get_cfi_dim_item,\n\tgfc_get_cfi_dim_lbound, gfc_get_cfi_dim_extent, gfc_get_cfi_dim_sm):\n\tNew define/functions to access the CFI array descriptor.\n\t(gfc_conv_descriptor_type): New function for the GFC descriptor.\n\t(gfc_get_array_span): Handle expr of CFI descriptors and\n\tassumed-type descriptors.\n\t(gfc_trans_array_bounds): Remove 'static'.\n\t(gfc_conv_expr_descriptor): For assumed type, use the dtype of\n\tthe actual argument.\n\t(structure_alloc_comps): Remove ' ' inside tabs.\n\t* trans-array.h (gfc_trans_array_bounds, gfc_conv_descriptor_type,\n\tgfc_get_cfi_desc_base_addr, gfc_get_cfi_desc_elem_len,\n\tgfc_get_cfi_desc_version, gfc_get_cfi_desc_rank,\n\tgfc_get_cfi_desc_type, gfc_get_cfi_desc_attribute,\n\tgfc_get_cfi_dim_lbound, gfc_get_cfi_dim_extent, gfc_get_cfi_dim_sm):\n\tNew prototypes.\n\t* trans-decl.c (gfor_fndecl_cfi_to_gfc, gfor_fndecl_gfc_to_cfi):\n\tRemove global vars.\n\t(gfc_build_builtin_function_decls): Remove their initialization.\n\t(gfc_get_symbol_decl, create_function_arglist,\n\tgfc_trans_deferred_vars): Update for CFI.\n\t(convert_CFI_desc): Remove and replace by ...\n\t(gfc_conv_cfi_to_gfc): ... this function\n\t(gfc_generate_function_code): Call it; create local GFC var for CFI.\n\t* trans-expr.c (gfc_maybe_dereference_var): Handle CFI.\n\t(gfc_conv_subref_array_arg): Handle the if-noncontigous-only copy in\n\twhen the result should be a descriptor.\n\t(gfc_conv_gfc_desc_to_cfi_desc): Completely rewritten.\n\t(gfc_conv_procedure_call): CFI fixes.\n\t* trans-openmp.c (gfc_omp_is_optional_argument,\n\tgfc_omp_check_optional_argument): Handle optional\n\tCFI.\n\t* trans-stmt.c (gfc_trans_select_rank_cases): Cleanup, avoid invalid\n\tcode for allocatable/pointer dummies, which cannot be assumed size.\n\t* trans-types.c (gfc_cfi_descriptor_base): New global var.\n\t(gfc_get_dtype_rank_type): Skip rank init for rank < 0.\n\t(gfc_sym_type): Handle CFI dummies.\n\t(gfc_get_function_type): Update call.\n\t(gfc_get_cfi_dim_type, gfc_get_cfi_type): New.\n\t* trans-types.h (gfc_sym_type): Update prototype.\n\t(gfc_get_cfi_type): New prototype.\n\t* trans.c (gfc_trans_runtime_check): Make conditions more consistent\n\tto avoid '<logical> AND_THEN <long int>' in conditions.\n\t* trans.h (gfor_fndecl_cfi_to_gfc, gfor_fndecl_gfc_to_cfi): Remove\n\tglobal-var declaration.\n\nlibgfortran/ChangeLog:\n\n\t* ISO_Fortran_binding.h (CFI_type_cfunptr): Make unique type again.\n\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc,\n\tgfc_desc_to_cfi_desc): Add comment that those are no longer called\n\tby new code.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.fortran/optional-bind-c.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/ISO_Fortran_binding_4.f90: Extend testcase.\n\t* gfortran.dg/PR100914.f90: Remove xfail.\n\t* gfortran.dg/PR100915.c: Expect CFI_type_cfunptr.\n\t* gfortran.dg/PR100915.f90: Handle CFI_type_cfunptr != CFI_type_cptr.\n\t* gfortran.dg/PR93963.f90: Extend select-rank tests.\n\t* gfortran.dg/bind-c-intent-out.f90: Change to dg-do run,\n\tupdate scan-dump.\n\t* gfortran.dg/bind_c_array_params_2.f90: Update/extend scan-dump.\n\t* gfortran.dg/bind_c_char_10.f90: Update scan-dump.\n\t* gfortran.dg/bind_c_char_8.f90: Remove dg-error \"sorry\".\n\t* gfortran.dg/c-interop/allocatable-dummy.f90: Remove xfail.\n\t* gfortran.dg/c-interop/c1255-1.f90: Likewise.\n\t* gfortran.dg/c-interop/c407c-1.f90: Update dg-error.\n\t* gfortran.dg/c-interop/cf-descriptor-5.f90: Remove xfail.\n\t* gfortran.dg/c-interop/cf-out-descriptor-3.f90: Likewise.\n\t* gfortran.dg/c-interop/cf-out-descriptor-4.f90: Likewise.\n\t* gfortran.dg/c-interop/cf-out-descriptor-5.f90: Likewise.\n\t* gfortran.dg/c-interop/contiguous-2.f90: Likewise.\n\t* gfortran.dg/c-interop/contiguous-3.f90: Likewise.\n\t* gfortran.dg/c-interop/deferred-character-1.f90: Likewise.\n\t* gfortran.dg/c-interop/deferred-character-2.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-descriptor-3.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-descriptor-5.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-descriptor-6.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-out-descriptor-3.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-out-descriptor-4.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-out-descriptor-5.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-out-descriptor-6.f90: Likewise.\n\t* gfortran.dg/c-interop/ff-descriptor-5.f90: Likewise.\n\t* gfortran.dg/c-interop/ff-descriptor-6.f90: Likewise.\n\t* gfortran.dg/c-interop/fc-descriptor-7.f90: Remove xfail + extend.\n\t* gfortran.dg/c-interop/fc-descriptor-7-c.c: Update for changes.\n\t* gfortran.dg/c-interop/shape.f90: Add implicit none.\n\t* gfortran.dg/c-interop/typecodes-array-char-c.c: Add kind=4 char.\n\t* gfortran.dg/c-interop/typecodes-array-char.f90: Likewise.\n\t* gfortran.dg/c-interop/typecodes-array-float128.f90: Remove xfail.\n\t* gfortran.dg/c-interop/typecodes-scalar-basic.f90: Likewise.\n\t* gfortran.dg/c-interop/typecodes-scalar-float128.f90: Likewise.\n\t* gfortran.dg/c-interop/typecodes-scalar-int128.f90: Likewise.\n\t* gfortran.dg/c-interop/typecodes-scalar-longdouble.f90: Likewise.\n\t* gfortran.dg/iso_c_binding_char_1.f90: Remove dg-error \"sorry\".\n\t* gfortran.dg/pr93792.f90: Turn XFAIL into PASS.\n\t* gfortran.dg/ISO_Fortran_binding_19.f90: New test.\n\t* gfortran.dg/assumed_type_12.f90: New test.\n\t* gfortran.dg/assumed_type_13.c: New test.\n\t* gfortran.dg/assumed_type_13.f90: New test.\n\t* gfortran.dg/bind-c-char-descr.f90: New test.\n\t* gfortran.dg/bind-c-contiguous-1.c: New test.\n\t* gfortran.dg/bind-c-contiguous-1.f90: New test.\n\t* gfortran.dg/bind-c-contiguous-2.f90: New test.\n\t* gfortran.dg/bind-c-contiguous-3.c: New test.\n\t* gfortran.dg/bind-c-contiguous-3.f90: New test.\n\t* gfortran.dg/bind-c-contiguous-4.c: New test.\n\t* gfortran.dg/bind-c-contiguous-4.f90: New test.\n\t* gfortran.dg/bind-c-contiguous-5.c: New test.\n\t* gfortran.dg/bind-c-contiguous-5.f90: New test.", "tree": {"sha": "c1fac57eed942194a0c3e53b01b9b9e63b8b8e6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1fac57eed942194a0c3e53b01b9b9e63b8b8e6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64f9623765da3306b0ab6a47997dc5d62c2ea261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f9623765da3306b0ab6a47997dc5d62c2ea261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64f9623765da3306b0ab6a47997dc5d62c2ea261", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f9623765da3306b0ab6a47997dc5d62c2ea261/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b1b2a186d94b31a522395e9d02c9cec1b928cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b1b2a186d94b31a522395e9d02c9cec1b928cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b1b2a186d94b31a522395e9d02c9cec1b928cb"}], "stats": {"total": 9630, "additions": 9149, "deletions": 481}, "files": [{"sha": "6784b07ae9e37d83a2ed7603f860843d29889881", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1605,15 +1605,6 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t\t\t\t\t    sym->name, &sym->declared_at,\n \t\t\t\t\t    sym->ns->proc_name->name))\n \t\t    retval = false;\n-\t\t  else if (!sym->attr.dimension)\n-\t\t    {\n-\t\t      /* FIXME: Use CFI array descriptor for scalars.  */\n-\t\t      gfc_error (\"Sorry, deferred-length scalar character dummy \"\n-\t\t\t\t \"argument %qs at %L of procedure %qs with \"\n-\t\t\t\t \"BIND(C) not yet supported\", sym->name,\n-\t\t\t\t &sym->declared_at, sym->ns->proc_name->name);\n-\t\t      retval = false;\n-\t\t    }\n \t\t}\n \t      else if (sym->attr.value\n \t\t       && (!cl || !cl->length\n@@ -1636,20 +1627,6 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t\t\t\t      \"attribute\", sym->name, &sym->declared_at,\n \t\t\t\t      sym->ns->proc_name->name))\n \t\t    retval = false;\n-\t\t  else if (!sym->attr.dimension\n-\t\t\t   || sym->as->type == AS_ASSUMED_SIZE\n-\t\t\t   || sym->as->type == AS_EXPLICIT)\n-\t\t    {\n-\t\t      /* FIXME: Valid - should use the CFI array descriptor, but\n-\t\t\t not yet handled for scalars and assumed-/explicit-size\n-\t\t\t arrays.  */\n-\t\t      gfc_error (\"Sorry, character dummy argument %qs at %L \"\n-\t\t\t\t \"with assumed length is not yet supported for \"\n-\t\t\t\t \"procedure %qs with BIND(C) attribute\",\n-\t\t\t\t sym->name, &sym->declared_at,\n-\t\t\t\t sym->ns->proc_name->name);\n-\t\t      retval = false;\n-\t\t    }\n \t\t}\n \t      else if (cl->length->expr_type != EXPR_CONSTANT\n \t\t       || mpz_cmp_si (cl->length->value.integer, 1) != 0)"}, {"sha": "66f24c63823e10bb9ed3214793bfcd33f83efc19", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1110,11 +1110,13 @@ is_CFI_desc (gfc_symbol *sym, gfc_expr *e)\n \n   if (sym && sym->attr.dummy\n       && sym->ns->proc_name->attr.is_bind_c\n-      && sym->attr.dimension\n       && (sym->attr.pointer\n \t  || sym->attr.allocatable\n-\t  || sym->as->type == AS_ASSUMED_SHAPE\n-\t  || sym->as->type == AS_ASSUMED_RANK))\n+\t  || (sym->attr.dimension\n+\t      && (sym->as->type == AS_ASSUMED_SHAPE\n+\t\t  || sym->as->type == AS_ASSUMED_RANK))\n+\t  || (sym->ts.type == BT_CHARACTER\n+\t      && (!sym->ts.u.cl || !sym->ts.u.cl->length))))\n     return true;\n \n return false;"}, {"sha": "66192c07d8c8b215725307287555fc75f2b74f5b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -105,6 +105,40 @@ typedef struct\n }\n mstring;\n \n+/* ISO_Fortran_binding.h\n+   CAUTION: This has to be kept in sync with libgfortran.  */\n+\n+#define CFI_type_kind_shift 8\n+#define CFI_type_mask 0xFF\n+#define CFI_type_from_type_kind(t, k) (t + (k << CFI_type_kind_shift))\n+\n+/* Constants, defined as macros. */\n+#define CFI_VERSION 1\n+#define CFI_MAX_RANK 15\n+\n+/* Attributes. */\n+#define CFI_attribute_pointer 0\n+#define CFI_attribute_allocatable 1\n+#define CFI_attribute_other 2\n+\n+#define CFI_type_mask 0xFF\n+#define CFI_type_kind_shift 8\n+\n+/* Intrinsic types. Their kind number defines their storage size. */\n+#define CFI_type_Integer 1\n+#define CFI_type_Logical 2\n+#define CFI_type_Real 3\n+#define CFI_type_Complex 4\n+#define CFI_type_Character 5\n+\n+/* Combined type (for more, see ISO_Fortran_binding.h).  */\n+#define CFI_type_ucs4_char (CFI_type_Character + (4 << CFI_type_kind_shift))\n+\n+/* Types with no kind. */\n+#define CFI_type_struct 6\n+#define CFI_type_cptr 7\n+#define CFI_type_cfunptr 8\n+#define CFI_type_other -1\n \n \n /*************************** Enums *****************************/"}, {"sha": "f8c087e3ac5a081700ecfdd8ed2e8bc9964f40a8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 143, "deletions": 3, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -103,6 +103,111 @@ gfc_array_dataptr_type (tree desc)\n   return (GFC_TYPE_ARRAY_DATAPTR_TYPE (TREE_TYPE (desc)));\n }\n \n+/* Build expressions to access members of the CFI descriptor.  */\n+#define CFI_FIELD_BASE_ADDR 0\n+#define CFI_FIELD_ELEM_LEN 1\n+#define CFI_FIELD_VERSION 2\n+#define CFI_FIELD_RANK 3\n+#define CFI_FIELD_ATTRIBUTE 4\n+#define CFI_FIELD_TYPE 5\n+#define CFI_FIELD_DIM 6\n+\n+#define CFI_DIM_FIELD_LOWER_BOUND 0\n+#define CFI_DIM_FIELD_EXTENT 1\n+#define CFI_DIM_FIELD_SM 2\n+\n+static tree\n+gfc_get_cfi_descriptor_field (tree desc, unsigned field_idx)\n+{\n+  tree type = TREE_TYPE (desc);\n+  gcc_assert (TREE_CODE (type) == RECORD_TYPE\n+\t      && TYPE_FIELDS (type)\n+\t      && (strcmp (\"base_addr\",\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_FIELDS (type))))\n+\t\t  == 0));\n+  tree field = gfc_advance_chain (TYPE_FIELDS (type), field_idx);\n+  gcc_assert (field != NULL_TREE);\n+\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  desc, field, NULL_TREE);\n+}\n+\n+tree\n+gfc_get_cfi_desc_base_addr (tree desc)\n+{\n+  return gfc_get_cfi_descriptor_field (desc, CFI_FIELD_BASE_ADDR);\n+}\n+\n+tree\n+gfc_get_cfi_desc_elem_len (tree desc)\n+{\n+  return gfc_get_cfi_descriptor_field (desc, CFI_FIELD_ELEM_LEN);\n+}\n+\n+tree\n+gfc_get_cfi_desc_version (tree desc)\n+{\n+  return gfc_get_cfi_descriptor_field (desc, CFI_FIELD_VERSION);\n+}\n+\n+tree\n+gfc_get_cfi_desc_rank (tree desc)\n+{\n+  return gfc_get_cfi_descriptor_field (desc, CFI_FIELD_RANK);\n+}\n+\n+tree\n+gfc_get_cfi_desc_type (tree desc)\n+{\n+  return gfc_get_cfi_descriptor_field (desc, CFI_FIELD_TYPE);\n+}\n+\n+tree\n+gfc_get_cfi_desc_attribute (tree desc)\n+{\n+  return gfc_get_cfi_descriptor_field (desc, CFI_FIELD_ATTRIBUTE);\n+}\n+\n+static tree\n+gfc_get_cfi_dim_item (tree desc, tree idx, unsigned field_idx)\n+{\n+  tree tmp = gfc_get_cfi_descriptor_field (desc, CFI_FIELD_DIM);\n+  tmp = gfc_build_array_ref (tmp, idx, NULL);\n+  tree field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)), field_idx);\n+  gcc_assert (field != NULL_TREE);\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  tmp, field, NULL_TREE);\n+}\n+\n+tree\n+gfc_get_cfi_dim_lbound (tree desc, tree idx)\n+{\n+  return gfc_get_cfi_dim_item (desc, idx, CFI_DIM_FIELD_LOWER_BOUND);\n+}\n+\n+tree\n+gfc_get_cfi_dim_extent (tree desc, tree idx)\n+{\n+  return gfc_get_cfi_dim_item (desc, idx, CFI_DIM_FIELD_EXTENT);\n+}\n+\n+tree\n+gfc_get_cfi_dim_sm (tree desc, tree idx)\n+{\n+  return gfc_get_cfi_dim_item (desc, idx, CFI_DIM_FIELD_SM);\n+}\n+\n+#undef CFI_FIELD_BASE_ADDR\n+#undef CFI_FIELD_ELEM_LEN\n+#undef CFI_FIELD_VERSION\n+#undef CFI_FIELD_RANK\n+#undef CFI_FIELD_ATTRIBUTE\n+#undef CFI_FIELD_TYPE\n+#undef CFI_FIELD_DIM\n+\n+#undef CFI_DIM_FIELD_LOWER_BOUND\n+#undef CFI_DIM_FIELD_EXTENT\n+#undef CFI_DIM_FIELD_SM\n \n /* Build expressions to access the members of an array descriptor.\n    It's surprisingly easy to mess up here, so never access\n@@ -288,6 +393,20 @@ gfc_conv_descriptor_attribute (tree desc)\n \t\t\t  dtype, tmp, NULL_TREE);\n }\n \n+tree\n+gfc_conv_descriptor_type (tree desc)\n+{\n+  tree tmp;\n+  tree dtype;\n+\n+  dtype = gfc_conv_descriptor_dtype (desc);\n+  tmp = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (dtype)), GFC_DTYPE_TYPE);\n+  gcc_assert (tmp!= NULL_TREE\n+\t      && TREE_TYPE (tmp) == signed_char_type_node);\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t  dtype, tmp, NULL_TREE);\n+}\n+\n tree\n gfc_get_descriptor_dimension (tree desc)\n {\n@@ -825,14 +944,26 @@ gfc_get_array_span (tree desc, gfc_expr *expr)\n {\n   tree tmp;\n \n-  if (is_pointer_array (desc) || get_CFI_desc (NULL, expr, &desc, NULL))\n+  if (is_pointer_array (desc)\n+      || (get_CFI_desc (NULL, expr, &desc, NULL)\n+\t  && (POINTER_TYPE_P (TREE_TYPE (desc))\n+\t      ? GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (desc)))\n+\t      : GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))))\n     {\n       if (POINTER_TYPE_P (TREE_TYPE (desc)))\n \tdesc = build_fold_indirect_ref_loc (input_location, desc);\n \n       /* This will have the span field set.  */\n       tmp = gfc_conv_descriptor_span_get (desc);\n     }\n+  else if (expr->ts.type == BT_ASSUMED)\n+    {\n+      if (DECL_LANG_SPECIFIC (desc) && GFC_DECL_SAVED_DESCRIPTOR (desc))\n+\tdesc = GFC_DECL_SAVED_DESCRIPTOR (desc);\n+      if (POINTER_TYPE_P (TREE_TYPE (desc)))\n+\tdesc = build_fold_indirect_ref_loc (input_location, desc);\n+      tmp = gfc_conv_descriptor_span_get (desc);\n+    }\n   else if (TREE_CODE (desc) == COMPONENT_REF\n \t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n \t   && GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (desc, 0))))\n@@ -6286,7 +6417,7 @@ gfc_trans_array_cobounds (tree type, stmtblock_t * pblock,\n /* Generate code to evaluate non-constant array bounds.  Sets *poffset and\n    returns the size (in elements) of the array.  */\n \n-static tree\n+tree\n gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n                         stmtblock_t * pblock)\n {\n@@ -7755,6 +7886,15 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       tmp = gfc_conv_descriptor_dtype (parm);\n       if (se->unlimited_polymorphic)\n \tdtype = gfc_get_dtype (TREE_TYPE (desc), &loop.dimen);\n+      else if (expr->ts.type == BT_ASSUMED)\n+\t{\n+\t  tree tmp2 = desc;\n+\t  if (DECL_LANG_SPECIFIC (tmp2) && GFC_DECL_SAVED_DESCRIPTOR (tmp2))\n+\t    tmp2 = GFC_DECL_SAVED_DESCRIPTOR (tmp2);\n+\t  if (POINTER_TYPE_P (TREE_TYPE (tmp2)))\n+\t    tmp2 = build_fold_indirect_ref_loc (input_location, tmp2);\n+\t  dtype = gfc_conv_descriptor_dtype (tmp2);\n+\t}\n       else\n \tdtype = gfc_get_dtype (parmtype);\n       gfc_add_modify (&loop.pre, tmp, dtype);\n@@ -9006,7 +9146,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  DECL_ARTIFICIAL (cdesc) = 1;\n \n \t  gfc_add_modify (&tmpblock, gfc_conv_descriptor_dtype (cdesc),\n-\t  \t\t  gfc_get_dtype_rank_type (1, tmp));\n+\t\t\t  gfc_get_dtype_rank_type (1, tmp));\n \t  gfc_conv_descriptor_lbound_set (&tmpblock, cdesc,\n \t\t\t\t\t  gfc_index_zero_node,\n \t\t\t\t\t  gfc_index_one_node);"}, {"sha": "1d3dc4819eb3f95132c0b851296bc96a6acecda4", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -160,7 +160,8 @@ tree gfc_conv_array_stride (tree, int);\n tree gfc_conv_array_lbound (tree, int);\n tree gfc_conv_array_ubound (tree, int);\n \n-/* Set cobounds of an array.  */\n+/* Set (co)bounds of an array.  */\n+tree gfc_trans_array_bounds (tree, gfc_symbol *, tree *, stmtblock_t *);\n void gfc_trans_array_cobounds (tree, stmtblock_t *, const gfc_symbol *);\n \n /* Build expressions for accessing components of an array descriptor.  */\n@@ -175,6 +176,7 @@ tree gfc_conv_descriptor_dtype (tree);\n tree gfc_conv_descriptor_rank (tree);\n tree gfc_conv_descriptor_elem_len (tree);\n tree gfc_conv_descriptor_attribute (tree);\n+tree gfc_conv_descriptor_type (tree);\n tree gfc_get_descriptor_dimension (tree);\n tree gfc_conv_descriptor_stride_get (tree, tree);\n tree gfc_conv_descriptor_lbound_get (tree, tree);\n@@ -188,6 +190,18 @@ void gfc_conv_descriptor_stride_set (stmtblock_t *, tree, tree, tree);\n void gfc_conv_descriptor_lbound_set (stmtblock_t *, tree, tree, tree);\n void gfc_conv_descriptor_ubound_set (stmtblock_t *, tree, tree, tree);\n \n+/* CFI descriptor.  */\n+tree gfc_get_cfi_desc_base_addr (tree);\n+tree gfc_get_cfi_desc_elem_len (tree);\n+tree gfc_get_cfi_desc_version (tree);\n+tree gfc_get_cfi_desc_rank (tree);\n+tree gfc_get_cfi_desc_type (tree);\n+tree gfc_get_cfi_desc_attribute (tree);\n+tree gfc_get_cfi_dim_lbound (tree, tree);\n+tree gfc_get_cfi_dim_extent (tree, tree);\n+tree gfc_get_cfi_dim_sm (tree, tree);\n+\n+\n /* Shift lower bound of descriptor, updating ubound and offset.  */\n void gfc_conv_shift_descriptor_lbound (stmtblock_t*, tree, int, tree);\n "}, {"sha": "de624c82fcf166cac25d1179f3f5b7309d9ba1df", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 885, "deletions": 143, "changes": 1028, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -117,8 +117,6 @@ tree gfor_fndecl_fdate;\n tree gfor_fndecl_ttynam;\n tree gfor_fndecl_in_pack;\n tree gfor_fndecl_in_unpack;\n-tree gfor_fndecl_cfi_to_gfc;\n-tree gfor_fndecl_gfc_to_cfi;\n tree gfor_fndecl_associated;\n tree gfor_fndecl_system_clock4;\n tree gfor_fndecl_system_clock8;\n@@ -1548,6 +1546,14 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t      || (sym->module && sym->attr.if_source != IFSRC_DECL\n \t\t  && sym->backend_decl));\n \n+  if (sym->attr.dummy && sym->ns->proc_name->attr.is_bind_c\n+      && is_CFI_desc (sym, NULL))\n+    {\n+      gcc_assert (sym->backend_decl && (sym->ts.type != BT_CHARACTER\n+\t\t\t\t\t|| sym->ts.u.cl->backend_decl));\n+      return sym->backend_decl;\n+    }\n+\n   if (sym->ns && sym->ns->proc_name && sym->ns->proc_name->attr.function)\n     byref = gfc_return_by_reference (sym->ns->proc_name);\n   else\n@@ -1595,9 +1601,6 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       sym->ts.u.cl->backend_decl = build_fold_indirect_ref (sym->ts.u.cl->backend_decl);\n     }\n \n-  if (is_CFI_desc (sym, NULL))\n-    gfc_defer_symbol_init (sym);\n-\n   fun_or_res = byref && (sym->attr.result\n \t\t\t || (sym->attr.function && sym->ts.deferred));\n   if ((sym->attr.dummy && ! sym->attr.function) || fun_or_res)\n@@ -2759,9 +2762,19 @@ create_function_arglist (gfc_symbol * sym)\n       if (f->sym->attr.volatile_)\n \ttype = build_qualified_type (type, TYPE_QUAL_VOLATILE);\n \n-      /* Build the argument declaration.  */\n-      parm = build_decl (input_location,\n-\t\t\t PARM_DECL, gfc_sym_identifier (f->sym), type);\n+      /* Build the argument declaration. For C descriptors, we use a\n+\t '_'-prefixed name for the parm_decl and inside the proc the\n+\t sym->name. */\n+      tree parm_name;\n+      if (sym->attr.is_bind_c && is_CFI_desc (f->sym, NULL))\n+\t{\n+\t  strcpy (&name[1], f->sym->name);\n+\t  name[0] = '_';\n+\t  parm_name = get_identifier (name);\n+\t}\n+      else\n+\tparm_name = gfc_sym_identifier (f->sym);\n+      parm = build_decl (input_location, PARM_DECL, parm_name, type);\n \n       if (f->sym->attr.volatile_)\n \t{\n@@ -3832,19 +3845,6 @@ gfc_build_builtin_function_decls (void)\n \tget_identifier (PREFIX(\"internal_unpack\")), \". w R \",\n \tvoid_type_node, 2, pvoid_type_node, pvoid_type_node);\n \n-  /* These two builtins write into what the first argument points to and\n-     read from what the second argument points to, but we can't use R\n-     for that, because the directly pointed structure contains a pointer\n-     which is copied into the descriptor pointed by the first argument,\n-     effectively escaping that way.  See PR92123.  */\n-  gfor_fndecl_cfi_to_gfc = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"cfi_desc_to_gfc_desc\")), \". w . \",\n-\tvoid_type_node, 2, pvoid_type_node, ppvoid_type_node);\n-\n-  gfor_fndecl_gfc_to_cfi = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"gfc_desc_to_cfi_desc\")), \". w . \",\n-\tvoid_type_node, 2, ppvoid_type_node, pvoid_type_node);\n-\n   gfor_fndecl_associated = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"associated\")), \". R R \",\n \tinteger_type_node, 2, ppvoid_type_node, ppvoid_type_node);\n@@ -4462,115 +4462,6 @@ gfc_null_and_pass_deferred_len (gfc_symbol *sym, stmtblock_t *init,\n }\n \n \n-/* Convert CFI descriptor dummies into gfc types and back again.  */\n-static void\n-convert_CFI_desc (gfc_wrapped_block * block, gfc_symbol *sym)\n-{\n-  tree gfc_desc;\n-  tree gfc_desc_ptr;\n-  tree CFI_desc;\n-  tree CFI_desc_ptr;\n-  tree dummy_ptr;\n-  tree tmp;\n-  tree present;\n-  tree incoming;\n-  tree outgoing;\n-  stmtblock_t outer_block;\n-  stmtblock_t tmpblock;\n-\n-  /* dummy_ptr will be the pointer to the passed array descriptor,\n-     while CFI_desc is the descriptor itself.  */\n-  if (DECL_LANG_SPECIFIC (sym->backend_decl))\n-    CFI_desc = GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl);\n-  else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (sym->backend_decl))))\n-    CFI_desc = sym->backend_decl;\n-  else\n-    CFI_desc = NULL;\n-\n-  dummy_ptr = CFI_desc;\n-\n-  if (CFI_desc)\n-    {\n-      CFI_desc = build_fold_indirect_ref_loc (input_location, CFI_desc);\n-\n-      /* The compiler will have given CFI_desc the correct gfortran\n-\t type. Use this new variable to store the converted\n-\t descriptor.  */\n-      gfc_desc = gfc_create_var (TREE_TYPE (CFI_desc), \"gfc_desc\");\n-      tmp = build_pointer_type (TREE_TYPE (gfc_desc));\n-      gfc_desc_ptr = gfc_create_var (tmp, \"gfc_desc_ptr\");\n-      CFI_desc_ptr = gfc_create_var (pvoid_type_node, \"CFI_desc_ptr\");\n-\n-      /* Fix the condition for the presence of the argument.  */\n-      gfc_init_block (&outer_block);\n-      present = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t logical_type_node, dummy_ptr,\n-\t\t\t\t build_int_cst (TREE_TYPE (dummy_ptr), 0));\n-\n-      gfc_init_block (&tmpblock);\n-      /* Pointer to the gfc descriptor.  */\n-      gfc_add_modify (&tmpblock, gfc_desc_ptr,\n-\t\t      gfc_build_addr_expr (NULL, gfc_desc));\n-      /* Store the pointer to the CFI descriptor.  */\n-      gfc_add_modify (&tmpblock, CFI_desc_ptr,\n-\t\t      fold_convert (pvoid_type_node, dummy_ptr));\n-      tmp = gfc_build_addr_expr (ppvoid_type_node, CFI_desc_ptr);\n-      /* Convert the CFI descriptor.  */\n-      incoming = build_call_expr_loc (input_location,\n-\t\t\tgfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);\n-      gfc_add_expr_to_block (&tmpblock, incoming);\n-      /* Set the dummy pointer to point to the gfc_descriptor.  */\n-      gfc_add_modify (&tmpblock, dummy_ptr,\n-\t\t      fold_convert (TREE_TYPE (dummy_ptr), gfc_desc_ptr));\n-\n-      /* The hidden string length is not passed to bind(C) procedures so set\n-\t it from the descriptor element length.  */\n-      if (sym->ts.type == BT_CHARACTER\n-\t  && sym->ts.u.cl->backend_decl\n-\t  && VAR_P (sym->ts.u.cl->backend_decl))\n-\t{\n-\t  tmp = build_fold_indirect_ref_loc (input_location, dummy_ptr);\n-\t  tmp = gfc_conv_descriptor_elem_len (tmp);\n-\t  gfc_add_modify (&tmpblock, sym->ts.u.cl->backend_decl,\n-\t\t\t  fold_convert (TREE_TYPE (sym->ts.u.cl->backend_decl),\n-\t\t\t\t        tmp));\n-\t}\n-\n-      /* Check that the argument is present before executing the above.  */\n-      incoming = build3_v (COND_EXPR, present,\n-\t\t\t   gfc_finish_block (&tmpblock),\n-\t\t\t   build_empty_stmt (input_location));\n-      gfc_add_expr_to_block (&outer_block, incoming);\n-      incoming = gfc_finish_block (&outer_block);\n-\n-      /* Convert the gfc descriptor back to the CFI type before going\n-\t out of scope, if the CFI type was present at entry.  */\n-      outgoing = NULL_TREE;\n-      if ((sym->attr.pointer || sym->attr.allocatable)\n-\t  && !sym->attr.value\n-\t  && sym->attr.intent != INTENT_IN)\n-\t{\n-\t  gfc_init_block (&outer_block);\n-\t  gfc_init_block (&tmpblock);\n-\n-\t  tmp = gfc_build_addr_expr (ppvoid_type_node, CFI_desc_ptr);\n-\t  outgoing = build_call_expr_loc (input_location,\n-\t\t\t\t\t  gfor_fndecl_gfc_to_cfi, 2,\n-\t\t\t\t\t  tmp, gfc_desc_ptr);\n-\t  gfc_add_expr_to_block (&tmpblock, outgoing);\n-\n-\t  outgoing = build3_v (COND_EXPR, present,\n-\t\t\t       gfc_finish_block (&tmpblock),\n-\t\t\t       build_empty_stmt (input_location));\n-\t  gfc_add_expr_to_block (&outer_block, outgoing);\n-\t  outgoing = gfc_finish_block (&outer_block);\n-\t}\n-\n-      /* Add the lot to the procedure init and finally blocks.  */\n-      gfc_add_init_cleanup (block, incoming, outgoing);\n-    }\n-}\n-\n /* Get the result expression for a procedure.  */\n \n static tree\n@@ -5147,13 +5038,6 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t}\n       else if (!(UNLIMITED_POLY(sym)) && !is_pdt_type)\n \tgcc_unreachable ();\n-\n-      /* Assumed shape and assumed rank arrays are passed to BIND(C) procedures\n-\t as ISO Fortran Interop descriptors. These have to be converted to\n-\t gfortran descriptors and back again.  This has to be done here so that\n-\t the conversion occurs at the start of the init block.  */\n-      if (is_CFI_desc (sym, NULL))\n-\tconvert_CFI_desc (block, sym);\n     }\n \n   gfc_init_block (&tmpblock);\n@@ -6777,6 +6661,788 @@ finish_oacc_declare (gfc_namespace *ns, gfc_symbol *sym, bool block)\n   return;\n }\n \n+static void\n+gfc_conv_cfi_to_gfc (stmtblock_t *init, stmtblock_t *finally,\n+\t\t     tree cfi_desc, tree gfc_desc, gfc_symbol *sym)\n+{\n+  stmtblock_t block;\n+  gfc_init_block (&block);\n+  tree cfi = build_fold_indirect_ref_loc (input_location, cfi_desc);\n+  tree rank, idx, etype, tmp, tmp2, size_var = NULL_TREE;\n+  bool do_copy_inout = false;\n+\n+  /* When allocatable + intent out, free the cfi descriptor.  */\n+  if (sym->attr.allocatable && sym->attr.intent == INTENT_OUT)\n+    {\n+      tmp = gfc_get_cfi_desc_base_addr (cfi);\n+      tree call = builtin_decl_explicit (BUILT_IN_FREE);\n+      call = build_call_expr_loc (input_location, call, 1, tmp);\n+      gfc_add_expr_to_block (&block, fold_convert (void_type_node, call));\n+      gfc_add_modify (&block, tmp,\n+\t\t      fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+    }\n+\n+  /* -fcheck=bound: Do version, rank, attribute, type and is-NULL checks.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+    {\n+      char *msg;\n+      tree tmp3;\n+      msg = xasprintf (\"Unexpected version %%d (expected %d) in CFI descriptor \"\n+\t\t       \"passed to dummy argument %s\", CFI_VERSION, sym->name);\n+      tmp2 = gfc_get_cfi_desc_version (cfi);\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp2,\n+\t\t\t     build_int_cst (TREE_TYPE (tmp2), CFI_VERSION));\n+      gfc_trans_runtime_check (true, false, tmp, &block, &sym->declared_at,\n+\t\t\t       msg, tmp2);\n+      free (msg);\n+\n+      /* Rank check; however, for character(len=*), assumed/explicit-size arrays\n+\t are permitted to differ in rank according to the Fortran rules.  */\n+      if (sym->as && sym->as->type != AS_ASSUMED_SIZE\n+\t  && sym->as->type != AS_EXPLICIT)\n+\t{\n+\t  if (sym->as->rank != -1)\n+\t    msg = xasprintf (\"Invalid rank %%d (expected %d) in CFI descriptor \"\n+\t\t\t     \"passed to dummy argument %s\", sym->as->rank,\n+\t\t\t     sym->name);\n+\t  else\n+\t    msg = xasprintf (\"Invalid rank %%d (expected 0..%d) in CFI \"\n+\t\t\t     \"descriptor passed to dummy argument %s\",\n+\t\t\t     CFI_MAX_RANK, sym->name);\n+\n+\t  tmp3 = tmp2 = tmp = gfc_get_cfi_desc_rank (cfi);\n+\t  if (sym->as->rank != -1)\n+\t    tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   tmp, build_int_cst (signed_char_type_node,\n+\t\t\t\t\t\t       sym->as->rank));\n+\t  else\n+\t    {\n+\t      tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t     tmp, build_zero_cst (TREE_TYPE (tmp)));\n+\t      tmp2 = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t      boolean_type_node, tmp2,\n+\t\t\t\t      build_int_cst (TREE_TYPE (tmp2),\n+\t\t\t\t\t\t     CFI_MAX_RANK));\n+\t      tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t     boolean_type_node, tmp, tmp2);\n+\t    }\n+\t  gfc_trans_runtime_check (true, false, tmp, &block, &sym->declared_at,\n+\t\t\t\t   msg, tmp3);\n+\t  free (msg);\n+\t}\n+\n+      tmp3 = tmp = gfc_get_cfi_desc_attribute (cfi);\n+      if (sym->attr.allocatable || sym->attr.pointer)\n+\t{\n+\t  int attr = (sym->attr.pointer ? CFI_attribute_pointer\n+\t\t\t\t\t: CFI_attribute_allocatable);\n+\t  msg = xasprintf (\"Invalid attribute %%d (expected %d) in CFI \"\n+\t\t\t   \"descriptor passed to dummy argument %s with %s \"\n+\t\t\t   \"attribute\", attr, sym->name,\n+\t\t\t   sym->attr.pointer ? \"pointer\" : \"allocatable\");\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t tmp, build_int_cst (TREE_TYPE (tmp), attr));\n+\t}\n+      else\n+\t{\n+\t  int amin = MIN (CFI_attribute_pointer,\n+\t\t\t  MIN (CFI_attribute_allocatable, CFI_attribute_other));\n+\t  int amax = MAX (CFI_attribute_pointer,\n+\t\t\t  MAX (CFI_attribute_allocatable, CFI_attribute_other));\n+\t  msg = xasprintf (\"Invalid attribute %%d (expected %d..%d) in CFI \"\n+\t\t\t   \"descriptor passed to nonallocatable, nonpointer \"\n+\t\t\t   \"dummy argument %s\", amin, amax, sym->name);\n+\t  tmp2 = tmp;\n+\t  tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, tmp,\n+\t\t\t     build_int_cst (TREE_TYPE (tmp), amin));\n+\t  tmp2 = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, tmp2,\n+\t\t\t     build_int_cst (TREE_TYPE (tmp2), amax));\n+\t  tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t boolean_type_node, tmp, tmp2);\n+\t  gfc_trans_runtime_check (true, false, tmp, &block, &sym->declared_at,\n+\t\t\t\t   msg, tmp3);\n+\t  free (msg);\n+\t  msg = xasprintf (\"Invalid unallocatated/unassociated CFI \"\n+\t\t\t   \"descriptor passed to nonallocatable, nonpointer \"\n+\t\t\t   \"dummy argument %s\", sym->name);\n+\t  tmp3 = tmp = gfc_get_cfi_desc_base_addr (cfi),\n+\t  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t tmp, null_pointer_node);\n+\t}\n+      gfc_trans_runtime_check (true, false, tmp, &block, &sym->declared_at,\n+\t\t\t       msg, tmp3);\n+      free (msg);\n+\n+      if (sym->ts.type != BT_ASSUMED)\n+\t{\n+\t  int type = CFI_type_other;\n+\t  if (sym->ts.f90_type == BT_VOID)\n+\t    {\n+\t      type = (sym->ts.u.derived->intmod_sym_id == ISOCBINDING_FUNPTR\n+\t\t      ? CFI_type_cfunptr : CFI_type_cptr);\n+\t    }\n+\t  else\n+\t    switch (sym->ts.type)\n+\t      {\n+\t\tcase BT_INTEGER:\n+\t\tcase BT_LOGICAL:\n+\t\tcase BT_REAL:\n+\t\tcase BT_COMPLEX:\n+\t\t  type = CFI_type_from_type_kind (sym->ts.type, sym->ts.kind);\n+\t\t  break;\n+\t\tcase BT_CHARACTER:\n+\t\t  type = CFI_type_from_type_kind (CFI_type_Character,\n+\t\t\t\t\t\t  sym->ts.kind);\n+\t\t  break;\n+\t\tcase BT_DERIVED:\n+\t\t  type = CFI_type_struct;\n+\t\t  break;\n+\t\tcase BT_VOID:\n+\t\t  type = (sym->ts.u.derived->intmod_sym_id == ISOCBINDING_FUNPTR\n+\t\t\t? CFI_type_cfunptr : CFI_type_cptr);\n+\t\t  break;\n+\t\tcase BT_ASSUMED:\n+\t\tcase BT_CLASS:\n+\t\tcase BT_PROCEDURE:\n+\t\tcase BT_HOLLERITH:\n+\t\tcase BT_UNION:\n+\t\tcase BT_BOZ:\n+\t\tcase BT_UNKNOWN:\n+\t\t  gcc_unreachable ();\n+\t    }\n+\t  msg = xasprintf (\"Unexpected type %%d (expected %d) in CFI descriptor\"\n+\t\t\t   \" passed to dummy argument %s\", type, sym->name);\n+\t  tmp2 = tmp = gfc_get_cfi_desc_type (cfi);\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t tmp, build_int_cst (TREE_TYPE (tmp), type));\n+\t  gfc_trans_runtime_check (true, false, tmp, &block, &sym->declared_at,\n+\t\t\t       msg, tmp2);\n+\t  free (msg);\n+\t}\n+    }\n+\n+  if (!sym->attr.referenced)\n+    goto done;\n+\n+  /* Set string length for len=* and len=:, otherwise, it is already set.  */\n+  if (sym->ts.type == BT_CHARACTER && !sym->ts.u.cl->length)\n+    {\n+      tmp = fold_convert (gfc_array_index_type,\n+\t\t\t  gfc_get_cfi_desc_elem_len (cfi));\n+      if (sym->ts.kind != 1)\n+\ttmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t       gfc_array_index_type, tmp,\n+\t\t\t       build_int_cst (gfc_charlen_type_node,\n+\t\t\t\t\t      sym->ts.kind));\n+      gfc_add_modify (&block, sym->ts.u.cl->backend_decl, tmp);\n+    }\n+\n+  /* gfc->data = cfi->base_addr - or for scalars: gfc = cfi->base_addr.\n+     assumed-size/explicit-size arrays end up here for character(len=*)\n+     only. */\n+  if (!sym->attr.dimension || !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+    {\n+      tmp = gfc_get_cfi_desc_base_addr (cfi);\n+      gfc_add_modify (&block, gfc_desc,\n+\t\t      fold_convert (TREE_TYPE (gfc_desc), tmp));\n+      if (!sym->attr.dimension)\n+\tgoto done;\n+    }\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+    {\n+      /* gfc->dtype = ... (from declaration, not from cfi).  */\n+      etype = gfc_get_element_type (TREE_TYPE (gfc_desc));\n+      gfc_add_modify (&block, gfc_conv_descriptor_dtype (gfc_desc),\n+\t\t      gfc_get_dtype_rank_type (sym->as->rank, etype));\n+      /* gfc->data = cfi->base_addr. */\n+      gfc_conv_descriptor_data_set (&block, gfc_desc,\n+\t\t\t\t    gfc_get_cfi_desc_base_addr (cfi));\n+    }\n+\n+  if (sym->ts.type == BT_ASSUMED)\n+    {\n+      /* For type(*), take elem_len + dtype.type from the actual argument.  */\n+      gfc_add_modify (&block, gfc_conv_descriptor_elem_len (gfc_desc),\n+\t\t      gfc_get_cfi_desc_elem_len (cfi));\n+      tree cond;\n+      tree ctype = gfc_get_cfi_desc_type (cfi);\n+      ctype = fold_build2_loc (input_location, BIT_AND_EXPR, TREE_TYPE (ctype),\n+\t\t\t       ctype, build_int_cst (TREE_TYPE (ctype),\n+\t\t\t\t\t\t     CFI_type_mask));\n+      tree type = gfc_conv_descriptor_type (gfc_desc);\n+\n+      /* if (CFI_type_cptr) BT_VOID else BT_UNKNOWN  */\n+      /* Note: BT_VOID is could also be CFI_type_funcptr, but assume c_ptr. */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (ctype), CFI_type_cptr));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, type,\n+\t\t\t     build_int_cst (TREE_TYPE (type), BT_VOID));\n+      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t      type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_UNKNOWN));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (CFI_type_struct) BT_DERIVED else  < tmp2 >  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (ctype),\n+\t\t\t\t\t     CFI_type_struct));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, type,\n+\t\t\t     build_int_cst (TREE_TYPE (type), BT_DERIVED));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (CFI_type_Character) BT_CHARACTER else  < tmp2 >  */\n+      /* Note: this is kind=1, CFI_type_ucs4_char is handled in the 'else if'\n+\t before (see below, as generated bottom up).  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (ctype),\n+\t\t\t      CFI_type_Character));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, type,\n+\t\t\t     build_int_cst (TREE_TYPE (type), BT_CHARACTER));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (CFI_type_ucs4_char) BT_CHARACTER else  < tmp2 >  */\n+      /* Note: gfc->elem_len = cfi->elem_len/4.  */\n+      /* However, assuming that CFI_type_ucs4_char cannot be recovered, leave\n+\t gfc->elem_len == cfi->elem_len, which helps with operations which use\n+\t sizeof() in Fortran and cfi->elem_len in C.  */\n+      tmp = gfc_get_cfi_desc_type (cfi);\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, tmp,\n+\t\t\t      build_int_cst (TREE_TYPE (tmp),\n+\t\t\t\t\t     CFI_type_ucs4_char));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, type,\n+\t\t\t     build_int_cst (TREE_TYPE (type), BT_CHARACTER));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (CFI_type_Complex) BT_COMPLEX + cfi->elem_len/2 else  < tmp2 >  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (ctype),\n+\t\t\t      CFI_type_Complex));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, type,\n+\t\t\t     build_int_cst (TREE_TYPE (type), BT_COMPLEX));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (CFI_type_Integer || CFI_type_Logical || CFI_type_Real)\n+\t   ctype else  <tmp2>  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (ctype),\n+\t\t\t\t\t     CFI_type_Integer));\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (ctype),\n+\t\t\t\t\t     CFI_type_Logical));\n+      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t      cond, tmp);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (ctype),\n+\t\t\t\t\t     CFI_type_Real));\n+      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t      cond, tmp);\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t     type, fold_convert (TREE_TYPE (type), ctype));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      gfc_add_expr_to_block (&block, tmp2);\n+    }\n+\n+  if (sym->as->rank < 0)\n+    {\n+      /* Set gfc->dtype.rank, if assumed-rank.  */\n+      rank = gfc_get_cfi_desc_rank (cfi);\n+      gfc_add_modify (&block, gfc_conv_descriptor_rank (gfc_desc), rank);\n+    }\n+  else if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+    /* In that case, the CFI rank and the declared rank can differ.  */\n+    rank = gfc_get_cfi_desc_rank (cfi);\n+  else\n+    rank = build_int_cst (signed_char_type_node, sym->as->rank);\n+\n+  /* With bind(C), the standard requires that both Fortran callers and callees\n+     handle noncontiguous arrays passed to an dummy with 'contiguous' attribute\n+     and with character(len=*) + assumed-size/explicit-size arrays.\n+     cf. Fortran 2018, 18.3.6, paragraph 5 (and for the caller: para. 6). */\n+  if ((sym->ts.type == BT_CHARACTER && !sym->ts.u.cl->length\n+       && (sym->as->type == AS_ASSUMED_SIZE || sym->as->type == AS_EXPLICIT))\n+      || sym->attr.contiguous)\n+    {\n+      do_copy_inout = true;\n+      gcc_assert (!sym->attr.pointer);\n+      stmtblock_t block2;\n+      tree data;\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+\tdata = gfc_conv_descriptor_data_get (gfc_desc);\n+      else if (!POINTER_TYPE_P (TREE_TYPE (gfc_desc)))\n+\tdata = gfc_build_addr_expr (NULL, gfc_desc);\n+      else\n+\tdata = gfc_desc;\n+\n+      /* Is copy-in/out needed? */\n+      /* do_copyin = rank != 0 && !assumed-size */\n+      tree cond_var = gfc_create_var (boolean_type_node, \"do_copyin\");\n+      tree cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   rank, build_zero_cst (TREE_TYPE (rank)));\n+      /* dim[rank-1].extent != -1 -> assumed size*/\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (rank),\n+\t\t\t     rank, build_int_cst (TREE_TYPE (rank), 1));\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      gfc_get_cfi_dim_extent (cfi, tmp),\n+\t\t\t      build_int_cst (gfc_array_index_type, -1));\n+      cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t      boolean_type_node, cond, tmp);\n+      gfc_add_modify (&block, cond_var, cond);\n+      /* if (do_copyin) do_copyin = ... || ... || ... */\n+      gfc_init_block (&block2);\n+      /* dim[0].sm != elem_len */\n+      tmp = fold_convert (gfc_array_index_type,\n+\t\t\t  gfc_get_cfi_desc_elem_len (cfi));\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      gfc_get_cfi_dim_sm (cfi, gfc_index_zero_node),\n+\t\t\t      tmp);\n+      gfc_add_modify (&block2, cond_var, cond);\n+\n+      /* for (i = 1; i < rank; ++i)\n+\t   cond &&= dim[i].sm != (dv->dim[i - 1].sm * dv->dim[i - 1].extent) */\n+      idx = gfc_create_var (TREE_TYPE (rank), \"idx\");\n+      stmtblock_t loop_body;\n+      gfc_init_block (&loop_body);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (idx),\n+\t\t\t     idx, build_int_cst (TREE_TYPE (idx), 1));\n+      tree tmp2 = gfc_get_cfi_dim_sm (cfi, tmp);\n+      tmp = gfc_get_cfi_dim_extent (cfi, tmp);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (tmp),\n+\t\t\t     tmp2, tmp);\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     gfc_get_cfi_dim_sm (cfi, idx), tmp);\n+      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t      cond_var, cond);\n+      gfc_add_modify (&loop_body, cond_var, cond);\n+      gfc_simple_for_loop (&block2, idx, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t  rank, LT_EXPR, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t  gfc_finish_block (&loop_body));\n+      tmp = build3_v (COND_EXPR, cond_var, gfc_finish_block (&block2),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      /* Copy-in body.  */\n+      gfc_init_block (&block2);\n+      /* size = dim[0].extent; for (i = 1; i < rank; ++i) size *= dim[i].extent */\n+      size_var = gfc_create_var (size_type_node, \"size\");\n+      tmp = fold_convert (size_type_node,\n+\t\t\t  gfc_get_cfi_dim_extent (cfi, gfc_index_zero_node));\n+      gfc_add_modify (&block2, size_var, tmp);\n+\n+      gfc_init_block (&loop_body);\n+      tmp = fold_convert (size_type_node,\n+\t\t\t  gfc_get_cfi_dim_extent (cfi, idx));\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t     size_var, fold_convert (size_type_node, tmp));\n+      gfc_add_modify (&loop_body, size_var, tmp);\n+      gfc_simple_for_loop (&block2, idx, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t  rank, LT_EXPR, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t  gfc_finish_block (&loop_body));\n+      /* data = malloc (size * elem_len) */\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t     size_var, gfc_get_cfi_desc_elem_len (cfi));\n+      tree call = builtin_decl_explicit (BUILT_IN_MALLOC);\n+      call = build_call_expr_loc (input_location, call, 1, tmp);\n+      gfc_add_modify (&block2, data, fold_convert (TREE_TYPE (data), call));\n+\n+      /* Copy the data:\n+\t for (idx = 0; idx < size; ++idx)\n+\t   {\n+\t     shift = 0;\n+\t     tmpidx = idx\n+\t     for (dim = 0; dim < rank; ++dim)\n+\t\t{\n+\t\t  shift += (tmpidx % extent[d]) * sm[d]\n+\t\t  tmpidx = tmpidx / extend[d]\n+\t\t}\n+\t     memcpy (lhs + idx*elem_len, rhs + shift, elem_len)\n+\t   } .*/\n+      idx = gfc_create_var (size_type_node, \"arrayidx\");\n+      gfc_init_block (&loop_body);\n+      tree shift = gfc_create_var (size_type_node, \"shift\");\n+      tree tmpidx = gfc_create_var (size_type_node, \"tmpidx\");\n+      gfc_add_modify (&loop_body, shift, build_zero_cst (TREE_TYPE (shift)));\n+      gfc_add_modify (&loop_body, tmpidx, idx);\n+      stmtblock_t inner_loop;\n+      gfc_init_block (&inner_loop);\n+      tree dim = gfc_create_var (TREE_TYPE (rank), \"dim\");\n+      /* shift += (tmpidx % extent[d]) * sm[d] */\n+      tmp = fold_build2_loc (input_location, TRUNC_MOD_EXPR,\n+\t\t\t     size_type_node, tmpidx,\n+\t\t\t     fold_convert (size_type_node,\n+\t\t\t\t\t   gfc_get_cfi_dim_extent (cfi, dim)));\n+      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t     size_type_node, tmp,\n+\t\t\t     fold_convert (size_type_node,\n+\t\t\t\t\t   gfc_get_cfi_dim_sm (cfi, dim)));\n+      gfc_add_modify (&inner_loop, shift,\n+\t\t      fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t       size_type_node, shift, tmp));\n+      /* tmpidx = tmpidx / extend[d] */\n+      tmp = fold_convert (size_type_node, gfc_get_cfi_dim_extent (cfi, dim));\n+      gfc_add_modify (&inner_loop, tmpidx,\n+\t\t      fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t\t       size_type_node, tmpidx, tmp));\n+      gfc_simple_for_loop (&loop_body, dim, build_zero_cst (TREE_TYPE (rank)),\n+\t\t\t   rank, LT_EXPR, build_int_cst (TREE_TYPE (dim), 1),\n+\t\t\t   gfc_finish_block (&inner_loop));\n+      /* Assign.  */\n+      tmp = fold_convert (pchar_type_node, gfc_get_cfi_desc_base_addr (cfi));\n+      tmp = fold_build2 (POINTER_PLUS_EXPR, pchar_type_node, tmp, shift);\n+      tree lhs;\n+      /* memcpy (lhs + idx*elem_len, rhs + shift, elem_len)  */\n+      tree elem_len;\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+\telem_len = gfc_conv_descriptor_elem_len (gfc_desc);\n+      else\n+\telem_len = gfc_get_cfi_desc_elem_len (cfi);\n+      lhs = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t     elem_len, idx);\n+      lhs = fold_build2_loc (input_location, POINTER_PLUS_EXPR, pchar_type_node,\n+\t\t\t     fold_convert (pchar_type_node, data), lhs);\n+      tmp = fold_convert (pvoid_type_node, tmp);\n+      lhs = fold_convert (pvoid_type_node, lhs);\n+      call = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+      call = build_call_expr_loc (input_location, call, 3, lhs, tmp, elem_len);\n+      gfc_add_expr_to_block (&loop_body, fold_convert (void_type_node, call));\n+      gfc_simple_for_loop (&block2, idx, build_zero_cst (TREE_TYPE (idx)),\n+\t\t\t   size_var, LT_EXPR, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t   gfc_finish_block (&loop_body));\n+      /* if (cond) { block2 }  */\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t     data, fold_convert (TREE_TYPE (data),\n+\t\t\t\t\t\t null_pointer_node));\n+      tmp = build3_v (COND_EXPR, cond_var, gfc_finish_block (&block2),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n+  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+    {\n+      tree offset, type;\n+      type = TREE_TYPE (gfc_desc);\n+      gfc_trans_array_bounds (type, sym, &offset, &block);\n+      if (VAR_P (GFC_TYPE_ARRAY_OFFSET (type)))\n+\tgfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+      goto done;\n+    }\n+\n+  /* If cfi->data != NULL. */\n+  stmtblock_t block2;\n+  gfc_init_block (&block2);\n+\n+  /* if do_copy_inout:  gfc->dspan = gfc->dtype.elem_len\n+     We use gfc instead of cfi on the RHS as this might be a constant.  */\n+  tmp = fold_convert (gfc_array_index_type,\n+\t\t      gfc_conv_descriptor_elem_len (gfc_desc));\n+  if (!do_copy_inout)\n+    {\n+      /* gfc->dspan = ((cfi->dim[0].sm % gfc->elem_len)\n+\t\t       ? cfi->dim[0].sm : gfc->elem_len).  */\n+      tree cond;\n+      tree tmp2 = gfc_get_cfi_dim_sm (cfi, gfc_rank_cst[0]);\n+      cond = fold_build2_loc (input_location, TRUNC_MOD_EXPR,\n+\t\t\t      gfc_array_index_type, tmp2, tmp);\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      cond, gfc_index_zero_node);\n+      tmp = build3_loc (input_location, COND_EXPR, gfc_array_index_type, cond,\n+\t\t\ttmp2, tmp);\n+    }\n+  gfc_conv_descriptor_span_set (&block2, gfc_desc, tmp);\n+\n+  /* Calculate offset + set lbound, ubound and stride.  */\n+  gfc_conv_descriptor_offset_set (&block2, gfc_desc, gfc_index_zero_node);\n+  if (sym->as->rank > 0 && !sym->attr.pointer && !sym->attr.allocatable)\n+    for (int i = 0; i < sym->as->rank; ++i)\n+      {\n+\tgfc_se se;\n+\tgfc_init_se (&se, NULL );\n+\tif (sym->as->lower[i])\n+\t  {\n+\t    gfc_conv_expr (&se, sym->as->lower[i]);\n+\t    tmp = se.expr;\n+\t  }\n+\telse\n+\t  tmp = gfc_index_one_node;\n+\tgfc_add_block_to_block (&block2, &se.pre);\n+\tgfc_conv_descriptor_lbound_set (&block2, gfc_desc, gfc_rank_cst[i],\n+\t\t\t\t\ttmp);\n+\tgfc_add_block_to_block (&block2, &se.post);\n+      }\n+\n+  /* Loop: for (i = 0; i < rank; ++i).  */\n+  idx = gfc_create_var (TREE_TYPE (rank), \"idx\");\n+\n+  /* Loop body.  */\n+  stmtblock_t loop_body;\n+  gfc_init_block (&loop_body);\n+  /* gfc->dim[i].lbound = ... */\n+  if (sym->attr.pointer || sym->attr.allocatable)\n+    {\n+      tmp = gfc_get_cfi_dim_lbound (cfi, idx);\n+      gfc_conv_descriptor_lbound_set (&loop_body, gfc_desc, idx, tmp);\n+    }\n+  else if (sym->as->rank < 0)\n+    gfc_conv_descriptor_lbound_set (&loop_body, gfc_desc, idx,\n+\t\t\t\t    gfc_index_one_node);\n+\n+  /* gfc->dim[i].ubound = gfc->dim[i].lbound + cfi->dim[i].extent - 1. */\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_lbound_get (gfc_desc, idx),\n+\t\t\t     gfc_index_one_node);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_get_cfi_dim_extent (cfi, idx), tmp);\n+  gfc_conv_descriptor_ubound_set (&loop_body, gfc_desc, idx, tmp);\n+\n+  if (do_copy_inout)\n+    {\n+      /* gfc->dim[i].stride\n+\t   = idx == 0 ? 1 : gfc->dim[i-1].stride * cfi->dim[i-1].extent */\n+      tree cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t   idx, build_zero_cst (TREE_TYPE (idx)));\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (idx),\n+\t\t\t     idx, build_int_cst (TREE_TYPE (idx), 1));\n+      tree tmp2 = gfc_get_cfi_dim_extent (cfi, tmp);\n+      tmp = gfc_conv_descriptor_stride_get (gfc_desc, tmp);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (tmp2),\n+\t\t\t     tmp2, tmp);\n+      tmp = build3_loc (input_location, COND_EXPR, gfc_array_index_type, cond,\n+\t\t\tgfc_index_one_node, tmp);\n+    }\n+  else\n+    {\n+      /* gfc->dim[i].stride = cfi->dim[i].sm / cfi>elem_len */\n+      tmp = gfc_get_cfi_dim_sm (cfi, idx);\n+      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t     fold_convert (gfc_array_index_type,\n+\t\t\t\t\t   gfc_get_cfi_desc_elem_len (cfi)));\n+     }\n+  gfc_conv_descriptor_stride_set (&loop_body, gfc_desc, idx, tmp);\n+  /* gfc->offset -= gfc->dim[i].stride * gfc->dim[i].lbound. */\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_stride_get (gfc_desc, idx),\n+\t\t\t     gfc_conv_descriptor_lbound_get (gfc_desc, idx));\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_offset_get (gfc_desc), tmp);\n+  gfc_conv_descriptor_offset_set (&loop_body, gfc_desc, tmp);\n+\n+  /* Generate loop.  */\n+  gfc_simple_for_loop (&block2, idx, build_zero_cst (TREE_TYPE (idx)),\n+\t\t       rank, LT_EXPR, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t       gfc_finish_block (&loop_body));\n+  if (sym->attr.allocatable || sym->attr.pointer)\n+    {\n+      tmp = gfc_get_cfi_desc_base_addr (cfi),\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     tmp, null_pointer_node);\n+      tmp = build3_v (COND_EXPR, tmp, gfc_finish_block (&block2),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+  else\n+    gfc_add_block_to_block (&block, &block2);\n+\n+done:\n+  /* If optional arg: 'if (arg) { block } else { local_arg = NULL; }'.  */\n+  if (sym->attr.optional)\n+    {\n+      tree present = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t      boolean_type_node, cfi_desc,\n+\t\t\t\t      null_pointer_node);\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t     sym->backend_decl,\n+\t\t\t     fold_convert (TREE_TYPE (sym->backend_decl),\n+\t\t\t\t\t   null_pointer_node));\n+      tmp = build3_v (COND_EXPR, present, gfc_finish_block (&block), tmp);\n+      gfc_add_expr_to_block (init, tmp);\n+    }\n+  else\n+    gfc_add_block_to_block (init, &block);\n+\n+  if (!sym->attr.referenced)\n+    return;\n+\n+  /* If pointer not changed, nothing to be done (except copy out)  */\n+  if (!do_copy_inout && ((!sym->attr.pointer && !sym->attr.allocatable)\n+\t\t\t || sym->attr.intent == INTENT_IN))\n+    return;\n+\n+  gfc_init_block (&block);\n+\n+  /* For bind(C), Fortran does not permit mixing 'pointer' with 'contiguous' (or\n+     len=*). Thus, when copy out is needed, the bounds ofthe descriptor remain\n+     unchanged.  */\n+  if (do_copy_inout)\n+    {\n+      tree data, call;\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+\tdata = gfc_conv_descriptor_data_get (gfc_desc);\n+      else if (!POINTER_TYPE_P (TREE_TYPE (gfc_desc)))\n+\tdata = gfc_build_addr_expr (NULL, gfc_desc);\n+      else\n+\tdata = gfc_desc;\n+      gfc_init_block (&block2);\n+      if (sym->attr.intent != INTENT_IN)\n+\t{\n+\t /* First, create the inner copy-out loop.\n+\t  for (idx = 0; idx < size; ++idx)\n+\t   {\n+\t     shift = 0;\n+\t     tmpidx = idx\n+\t     for (dim = 0; dim < rank; ++dim)\n+\t\t{\n+\t\t  shift += (tmpidx % extent[d]) * sm[d]\n+\t\t  tmpidx = tmpidx / extend[d]\n+\t\t}\n+\t     memcpy (lhs + shift, rhs + idx*elem_len, elem_len)\n+\t   } .*/\n+\t  stmtblock_t loop_body;\n+\t  idx = gfc_create_var (size_type_node, \"arrayidx\");\n+\t  gfc_init_block (&loop_body);\n+\t  tree shift = gfc_create_var (size_type_node, \"shift\");\n+\t  tree tmpidx = gfc_create_var (size_type_node, \"tmpidx\");\n+\t  gfc_add_modify (&loop_body, shift,\n+\t\t\t  build_zero_cst (TREE_TYPE (shift)));\n+\t  gfc_add_modify (&loop_body, tmpidx, idx);\n+\t  stmtblock_t inner_loop;\n+\t  gfc_init_block (&inner_loop);\n+\t  tree dim = gfc_create_var (TREE_TYPE (rank), \"dim\");\n+\t  /* shift += (tmpidx % extent[d]) * sm[d] */\n+\t  tmp = fold_convert (size_type_node,\n+\t\t\t      gfc_get_cfi_dim_extent (cfi, dim));\n+\t  tmp = fold_build2_loc (input_location, TRUNC_MOD_EXPR,\n+\t\t\t\t size_type_node, tmpidx, tmp);\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t size_type_node, tmp,\n+\t\t\t\t fold_convert (size_type_node,\n+\t\t\t\t\t       gfc_get_cfi_dim_sm (cfi, dim)));\n+\t  gfc_add_modify (&inner_loop, shift,\n+\t\t      fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t       size_type_node, shift, tmp));\n+\t  /* tmpidx = tmpidx / extend[d] */\n+\t  tmp = fold_convert (size_type_node,\n+\t\t\t      gfc_get_cfi_dim_extent (cfi, dim));\n+\t  gfc_add_modify (&inner_loop, tmpidx,\n+\t\t\t  fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t\t\t   size_type_node, tmpidx, tmp));\n+\t  gfc_simple_for_loop (&loop_body, dim,\n+\t\t\t       build_zero_cst (TREE_TYPE (rank)), rank, LT_EXPR,\n+\t\t\t       build_int_cst (TREE_TYPE (dim), 1),\n+\t\t\t       gfc_finish_block (&inner_loop));\n+\t  /* Assign.  */\n+\t  tree rhs;\n+\t  tmp = fold_convert (pchar_type_node,\n+\t\t\t      gfc_get_cfi_desc_base_addr (cfi));\n+\t  tmp = fold_build2 (POINTER_PLUS_EXPR, pchar_type_node, tmp, shift);\n+\t  /* memcpy (lhs + shift, rhs + idx*elem_len, elem_len) */\n+\t  tree elem_len;\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_desc)))\n+\t    elem_len = gfc_conv_descriptor_elem_len (gfc_desc);\n+\t  else\n+\t    elem_len = gfc_get_cfi_desc_elem_len (cfi);\n+\t  rhs = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t\t elem_len, idx);\n+\t  rhs = fold_build2_loc (input_location, POINTER_PLUS_EXPR,\n+\t\t\t\t pchar_type_node,\n+\t\t\t\t fold_convert (pchar_type_node, data), rhs);\n+\t  tmp = fold_convert (pvoid_type_node, tmp);\n+\t  rhs = fold_convert (pvoid_type_node, rhs);\n+\t  call = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+\t  call = build_call_expr_loc (input_location, call, 3, tmp, rhs,\n+\t\t\t\t      elem_len);\n+\t  gfc_add_expr_to_block (&loop_body,\n+\t\t\t\t fold_convert (void_type_node, call));\n+\t  gfc_simple_for_loop (&block2, idx, build_zero_cst (TREE_TYPE (idx)),\n+\t\t\t       size_var, LT_EXPR,\n+\t\t\t       build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t       gfc_finish_block (&loop_body));\n+\t}\n+      call = builtin_decl_explicit (BUILT_IN_FREE);\n+      call = build_call_expr_loc (input_location, call, 1, data);\n+      gfc_add_expr_to_block (&block2, call);\n+\n+      /* if (cfi->base_addr != gfc->data) { copy out; free(var) }; return  */\n+      tree tmp2 = gfc_get_cfi_desc_base_addr (cfi);\n+      tmp2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      tmp2, fold_convert (TREE_TYPE (tmp2), data));\n+      tmp = build3_v (COND_EXPR, tmp2, gfc_finish_block (&block2),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n+      goto done_finally;\n+    }\n+\n+  /* Update pointer + array data data on exit.  */\n+  tmp = gfc_get_cfi_desc_base_addr (cfi);\n+  tmp2 = (!sym->attr.dimension\n+\t       ? gfc_desc : gfc_conv_descriptor_data_get (gfc_desc));\n+  gfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp), tmp2));\n+\n+  /* Set string length for len=:, only.  */\n+  if (sym->ts.type == BT_CHARACTER && !sym->ts.u.cl->length)\n+    {\n+      tmp = sym->ts.u.cl->backend_decl;\n+      if (sym->ts.kind != 1)\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       gfc_array_index_type,\n+\t\t\t       sym->ts.u.cl->backend_decl, tmp);\n+      tmp2 = gfc_get_cfi_desc_elem_len (cfi);\n+      gfc_add_modify (&block, tmp2, fold_convert (TREE_TYPE (tmp2), tmp));\n+    }\n+\n+  if (!sym->attr.dimension)\n+    goto done_finally;\n+\n+  gfc_init_block (&block2);\n+\n+  /* Loop: for (i = 0; i < rank; ++i).  */\n+  idx = gfc_create_var (TREE_TYPE (rank), \"idx\");\n+\n+  /* Loop body.  */\n+  gfc_init_block (&loop_body);\n+  /* cfi->dim[i].lower_bound = gfc->dim[i].lbound */\n+  gfc_add_modify (&loop_body, gfc_get_cfi_dim_lbound (cfi, idx),\n+\t\t  gfc_conv_descriptor_lbound_get (gfc_desc, idx));\n+  /* cfi->dim[i].extent = gfc->dim[i].ubound - gfc->dim[i].lbound + 1.  */\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_ubound_get (gfc_desc, idx),\n+\t\t\t     gfc_conv_descriptor_lbound_get (gfc_desc, idx));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type, tmp,\n+\t\t\t gfc_index_one_node);\n+  gfc_add_modify (&loop_body, gfc_get_cfi_dim_extent (cfi, idx), tmp);\n+  /* d->dim[n].sm = gfc->dim[i].stride  * gfc->span); */\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_stride_get (gfc_desc, idx),\n+\t\t\t     gfc_conv_descriptor_span_get (gfc_desc));\n+  gfc_add_modify (&loop_body, gfc_get_cfi_dim_sm (cfi, idx), tmp);\n+\n+  /* Generate loop.  */\n+  gfc_simple_for_loop (&block2, idx, build_zero_cst (TREE_TYPE (idx)),\n+\t\t       rank, LT_EXPR, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t       gfc_finish_block (&loop_body));\n+  /* if (gfc->data != NULL) { block2 }.  */\n+  tmp = gfc_get_cfi_desc_base_addr (cfi),\n+  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t tmp, null_pointer_node);\n+  tmp = build3_v (COND_EXPR, tmp, gfc_finish_block (&block2),\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+done_finally:\n+  /* If optional arg: 'if (arg) { block } else { local_arg = NULL; }'.  */\n+  if (sym->attr.optional)\n+    {\n+      tree present = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t      boolean_type_node, cfi_desc,\n+\t\t\t\t      null_pointer_node);\n+      tmp = build3_v (COND_EXPR, present, gfc_finish_block (&block),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (finally, tmp);\n+     }\n+   else\n+     gfc_add_block_to_block (finally, &block);\n+}\n \n /* Generate code for a function.  */\n \n@@ -6788,7 +7454,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   tree decl;\n   tree tmp;\n   tree fpstate = NULL_TREE;\n-  stmtblock_t init, cleanup;\n+  stmtblock_t init, cleanup, outer_block;\n   stmtblock_t body;\n   gfc_wrapped_block try_block;\n   tree recurcheckvar = NULL_TREE;\n@@ -6822,6 +7488,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n   trans_function_start (sym);\n \n   gfc_init_block (&init);\n+  gfc_init_block (&cleanup);\n+  gfc_init_block (&outer_block);\n \n   if (ns->entries && ns->proc_name->ts.type == BT_CHARACTER)\n     {\n@@ -6845,6 +7513,81 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t|| ns->parent == NULL)\n     parent_fake_result_decl = NULL_TREE;\n \n+  /* For BIND(C):\n+     - deallocate intent-out allocatable dummy arguments.\n+     - Create GFC variable which will later be populated by convert_CFI_desc  */\n+  if (sym->attr.is_bind_c)\n+    for (gfc_formal_arglist *formal = gfc_sym_get_dummy_args (sym);\n+\t formal; formal = formal->next)\n+      {\n+\tgfc_symbol *fsym = formal->sym;\n+\tif (!is_CFI_desc (fsym, NULL))\n+\t  continue;\n+\tif (!fsym->attr.referenced)\n+\t  {\n+\t    gfc_conv_cfi_to_gfc (&init, &cleanup, fsym->backend_decl,\n+\t\t\t\t NULL_TREE, fsym);\n+\t    continue;\n+\t  }\n+\t/* Let's now create a local GFI descriptor. Afterwards:\n+\t   desc is the local descriptor,\n+\t   desc_p is a pointer to it\n+\t     and stored in sym->backend_decl\n+\t   GFC_DECL_SAVED_DESCRIPTOR (desc_p) contains the CFI descriptor\n+\t     -> PARM_DECL and before sym->backend_decl.\n+\t   For scalars, decl == decl_p is a pointer variable.  */\n+\ttree desc_p, desc;\n+\tlocation_t loc = gfc_get_location (&sym->declared_at);\n+\tif (fsym->ts.type == BT_CHARACTER && !fsym->ts.u.cl->length)\n+\t  fsym->ts.u.cl->backend_decl = gfc_create_var (gfc_array_index_type,\n+\t\t\t\t\t\t\tfsym->name);\n+\telse if (fsym->ts.type == BT_CHARACTER && !fsym->ts.u.cl->backend_decl)\n+\t  {\n+\t    gfc_se se;\n+\t    gfc_init_se (&se, NULL );\n+\t    gfc_conv_expr (&se, fsym->ts.u.cl->length);\n+\t    gfc_add_block_to_block (&init, &se.pre);\n+\t    fsym->ts.u.cl->backend_decl = se.expr;\n+\t    gcc_assert(se.post.head == NULL_TREE);\n+\t  }\n+\t/* Nullify, otherwise gfc_sym_type will return the CFI type.  */\n+\ttree tmp = fsym->backend_decl;\n+\tfsym->backend_decl = NULL;\n+\ttree type = gfc_sym_type (fsym);\n+\tgcc_assert (POINTER_TYPE_P (type));\n+\tif (POINTER_TYPE_P (TREE_TYPE (type)))\n+\t  /* For instance, allocatable scalars.  */\n+\t  type = TREE_TYPE (type);\n+\tif (TREE_CODE (type) == REFERENCE_TYPE)\n+\t  type = build_pointer_type (TREE_TYPE (type));\n+\tdesc_p = build_decl (loc, VAR_DECL, get_identifier (fsym->name), type);\n+\tif (!fsym->attr.dimension)\n+\t  desc = desc_p;\n+\telse if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (desc_p))))\n+\t  {\n+\t    /* Character(len=*) explict-size/assumed-size array. */\n+\t    desc = desc_p;\n+\t    gfc_build_qualified_array (desc, fsym);\n+\t  }\n+\telse\n+\t  {\n+\t    tree size = size_in_bytes (TREE_TYPE (TREE_TYPE (desc_p)));\n+\t    tree call = builtin_decl_explicit (BUILT_IN_ALLOCA);\n+\t    call = build_call_expr_loc (input_location, call, 1, size);\n+\t    gfc_add_modify (&outer_block, desc_p,\n+\t\t\t    fold_convert (TREE_TYPE(desc_p), call));\n+\t    desc = build_fold_indirect_ref_loc (input_location, desc_p);\n+\t  }\n+\tpushdecl (desc_p);\n+\tif (fsym->attr.optional)\n+\t  {\n+\t    gfc_allocate_lang_decl (desc_p);\n+\t    GFC_DECL_OPTIONAL_ARGUMENT (desc_p) = 1;\n+\t  }\n+\tfsym->backend_decl = desc_p;\n+\tgfc_conv_cfi_to_gfc (&init, &cleanup, tmp, desc, fsym);\n+      }\n+\n   gfc_generate_contained_functions (ns);\n \n   has_coarray_vars = false;\n@@ -6968,7 +7711,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t      /* Arrays are not initialized using the default initializer of\n \t\t their elements.  Therefore only check if a default\n \t\t initializer is available when the result is scalar.  */\n-              init_exp = rsym->as ? NULL\n+\t      init_exp = rsym->as ? NULL\n                                   : gfc_generate_initializer (&rsym->ts, true);\n \t      if (init_exp)\n \t\t{\n@@ -7000,8 +7743,6 @@ gfc_generate_function_code (gfc_namespace * ns)\n \tgfc_add_expr_to_block (&body, gfc_generate_return ());\n     }\n \n-  gfc_init_block (&cleanup);\n-\n   /* Reset recursion-check variable.  */\n   if (recurcheckvar != NULL_TREE)\n     {\n@@ -7015,8 +7756,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   /* Finish the function body and add init and cleanup code.  */\n   tmp = gfc_finish_block (&body);\n-  gfc_start_wrapped_block (&try_block, tmp);\n   /* Add code to create and cleanup arrays.  */\n+  gfc_start_wrapped_block (&try_block, tmp);\n   gfc_trans_deferred_vars (sym, &try_block);\n   gfc_add_init_cleanup (&try_block, gfc_finish_block (&init),\n \t\t\tgfc_finish_block (&cleanup));\n@@ -7034,7 +7775,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n     }\n   saved_function_decls = NULL_TREE;\n \n-  DECL_SAVED_TREE (fndecl) = gfc_finish_wrapped_block (&try_block);\n+  gfc_add_expr_to_block (&outer_block, gfc_finish_wrapped_block (&try_block));\n+  DECL_SAVED_TREE (fndecl) = gfc_finish_block (&outer_block);\n   decl = getdecls ();\n \n   /* Finish off this function and send it for code generation.  */"}, {"sha": "013893730651b94a3d65c027ccd5601533a3ab1a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 472, "deletions": 153, "changes": 625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -2866,6 +2866,9 @@ tree\n gfc_maybe_dereference_var (gfc_symbol *sym, tree var, bool descriptor_only_p,\n \t\t\t   bool is_classarray)\n {\n+  if (is_CFI_desc (sym, NULL))\n+    return build_fold_indirect_ref_loc (input_location, var);\n+\n   /* Characters are entirely different from other types, they are treated\n      separately.  */\n   if (sym->ts.type == BT_CHARACTER)\n@@ -4922,7 +4925,7 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n \n       if (fsym && proc_name)\n \tmsg = xasprintf (\"An array temporary was created for argument \"\n-\t\t\t     \"'%s' of procedure '%s'\", fsym->name, proc_name);\n+\t\t\t \"'%s' of procedure '%s'\", fsym->name, proc_name);\n       else\n \tmsg = xasprintf (\"An array temporary was created\");\n \n@@ -5220,6 +5223,8 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n       tree post_cond;\n \n       type = TREE_TYPE (parmse->expr);\n+      if (POINTER_TYPE_P (type) && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type)))\n+\ttype = TREE_TYPE (type);\n       pointer = gfc_create_var (type, \"arg_ptr\");\n \n       if (check_contiguous)\n@@ -5263,17 +5268,25 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n \t  gfc_add_block_to_block (&se->pre, &(&array_se)->pre);\n \t  gfc_add_block_to_block (&se->pre, &(&array_se)->post);\n \n-\t  /* if_stmt = { pointer = &a[0]; } .  */\n+\t  /* if_stmt = { descriptor ? pointer = a : pointer = &a[0]; } .  */\n \t  gfc_init_block (&if_block);\n-\t  tmp = gfc_conv_array_data (array_se.expr);\n-\t  tmp = fold_convert (type, tmp);\n-\t  gfc_add_modify (&if_block, pointer, tmp);\n+\t  if (GFC_DESCRIPTOR_TYPE_P (type))\n+\t    gfc_add_modify (&if_block, pointer, array_se.expr);\n+\t  else\n+\t    {\n+\t      tmp = gfc_conv_array_data (array_se.expr);\n+\t      tmp = fold_convert (type, tmp);\n+\t      gfc_add_modify (&if_block, pointer, tmp);\n+\t    }\n \t  if_stmt = gfc_finish_block (&if_block);\n \n \t  /* else_stmt = { parmse->pre(); pointer = parmse->expr; } .  */\n \t  gfc_init_block (&else_block);\n \t  gfc_add_block_to_block (&else_block, &parmse->pre);\n-\t  gfc_add_modify (&else_block, pointer, parmse->expr);\n+\t  tmp = (GFC_DESCRIPTOR_TYPE_P (type)\n+\t\t ? build_fold_indirect_ref_loc (input_location, parmse->expr)\n+\t\t : parmse->expr);\n+\t  gfc_add_modify (&else_block, pointer, tmp);\n \t  else_stmt = gfc_finish_block (&else_block);\n \n \t  /* And put the above into an if statement.  */\n@@ -5300,7 +5313,11 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n \n \t  /* else_stmt = { pointer = NULL; } .  */\n \t  gfc_init_block (&else_block);\n-\t  gfc_add_modify (&else_block, pointer, build_int_cst (type, 0));\n+\t  if (GFC_DESCRIPTOR_TYPE_P (type))\n+\t    gfc_conv_descriptor_data_set (&else_block, pointer,\n+\t\t\t\t\t  null_pointer_node);\n+\t  else\n+\t    gfc_add_modify (&else_block, pointer, build_int_cst (type, 0));\n \t  else_stmt = gfc_finish_block (&else_block);\n \n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n@@ -5344,6 +5361,24 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, post_cond,\n \t\t\t     post_stmts, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&se->post, tmp);\n+      if (GFC_DESCRIPTOR_TYPE_P (type))\n+\t{\n+\t  type = TREE_TYPE (parmse->expr);\n+\t  if (POINTER_TYPE_P (type))\n+\t    {\n+\t      pointer = gfc_build_addr_expr (type, pointer);\n+\t      if (pass_optional)\n+\t\t{\n+\t\t  tmp = gfc_likely (present_var, PRED_FORTRAN_ABSENT_DUMMY);\n+\t\t  pointer = fold_build3_loc (input_location, COND_EXPR, type,\n+\t\t\t\t\t     tmp, pointer,\n+\t\t\t\t\t     fold_convert (type,\n+\t\t\t\t\t\t\t   null_pointer_node));\n+\t\t}\n+\t    }\n+\t  else\n+\t    gcc_assert (!pass_optional);\n+\t}\n       se->expr = pointer;\n     }\n \n@@ -5484,168 +5519,457 @@ set_dtype_for_unallocated (gfc_se *parmse, gfc_expr *e)\n static void\n gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n {\n-  tree tmp;\n-  tree cfi_desc_ptr;\n-  tree gfc_desc_ptr;\n-  tree type;\n-  tree cond;\n-  tree desc_attr;\n-  int attribute;\n-  int cfi_attribute;\n-  symbol_attribute attr = gfc_expr_attr (e);\n+  stmtblock_t block, block2;\n+  tree cfi, gfc, tmp, tmp2;\n+  tree present = NULL;\n+  tree gfc_strlen = NULL;\n+  tree rank;\n+  gfc_se se;\n+\n+  if (fsym->attr.optional\n+      && e->expr_type == EXPR_VARIABLE\n+      && e->symtree->n.sym->attr.optional)\n+    present = gfc_conv_expr_present (e->symtree->n.sym);\n+\n+  gfc_init_block (&block);\n \n-  /* If this is a full array or a scalar, the allocatable and pointer\n-     attributes can be passed. Otherwise it is 'CFI_attribute_other'*/\n-  attribute = 2;\n-  if (!e->rank || gfc_get_full_arrayspec_from_expr (e))\n+  /* Convert original argument to a tree. */\n+  gfc_init_se (&se, NULL);\n+  if (e->rank == 0)\n     {\n-      if (attr.pointer)\n-\tattribute = 0;\n-      else if (attr.allocatable)\n-\tattribute = 1;\n+      se.want_pointer = 1;\n+      gfc_conv_expr (&se, e);\n+      gfc = se.expr;\n+      /* gfc_conv_constant ignores se.want_poiner, e.g. for string_cst.  */\n+      if (!POINTER_TYPE_P (TREE_TYPE (gfc)))\n+\tgfc = gfc_build_addr_expr (NULL, gfc);\n+    }\n+  else\n+    {\n+      /* If the actual argument can be noncontiguous, copy-in/out is required,\n+\t if the dummy has either the CONTIGUOUS attribute or is an assumed-\n+\t length assumed-length/assumed-size CHARACTER array.  */\n+      se.force_no_tmp = 1;\n+      if ((fsym->attr.contiguous\n+\t   || (fsym->ts.type == BT_CHARACTER && !fsym->ts.u.cl->length\n+\t       && (fsym->as->type == AS_ASSUMED_SIZE\n+\t\t   || fsym->as->type == AS_EXPLICIT)))\n+\t  && !gfc_is_simply_contiguous (e, false, true))\n+\t{\n+\t  bool optional = fsym->attr.optional;\n+\t  fsym->attr.optional = 0;\n+\t  gfc_conv_subref_array_arg (&se, e, false, fsym->attr.intent,\n+\t\t\t\t     fsym->attr.pointer, fsym,\n+\t\t\t\t     fsym->ns->proc_name->name, NULL,\n+\t\t\t\t     /* check_contiguous= */ true);\n+\t  fsym->attr.optional = optional;\n+\t}\n+      else\n+\tgfc_conv_expr_descriptor (&se, e);\n+      gfc = se.expr;\n+      /* For dt(:)%var the elem_len*stride != sm, hence, GFC uses\n+\t elem_len = sizeof(dt) and base_addr = dt(lb) instead.\n+\t gfc_get_dataptr_offset fixes the base_addr; for elem_len, see below.\n+\t While sm is fine as it uses span*stride and not elem_len.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (gfc)))\n+\tgfc = build_fold_indirect_ref_loc (input_location, gfc);\n+      else if (is_subref_array (e) && e->ts.type != BT_CHARACTER)\n+\t gfc_get_dataptr_offset (&se.pre, gfc, gfc, NULL, true, e);\n+    }\n+  if (e->ts.type == BT_CHARACTER)\n+    {\n+      if (se.string_length)\n+\tgfc_strlen = se.string_length;\n+      else if (e->ts.u.cl->backend_decl)\n+\tgfc_strlen = e->ts.u.cl->backend_decl;\n+      else\n+\tgcc_unreachable ();\n     }\n+  gfc_add_block_to_block (&block, &se.pre);\n+\n+  /* Create array decriptor and set version, rank, attribute, type. */\n+  cfi = gfc_create_var (gfc_get_cfi_type (e->rank < 0\n+\t\t\t\t\t  ? GFC_MAX_DIMENSIONS : e->rank,\n+\t\t\t\t\t  false), \"cfi\");\n+  /* Convert to CFI_cdesc_t, which has dim[] to avoid TBAA issues,*/\n+  if (fsym->attr.dimension && fsym->as->type == AS_ASSUMED_RANK)\n+    {\n+      tmp = gfc_get_cfi_type (-1, !fsym->attr.pointer && !fsym->attr.target);\n+      tmp = build_pointer_type (tmp);\n+      parmse->expr = cfi = gfc_build_addr_expr (tmp, cfi);\n+      cfi = build_fold_indirect_ref_loc (input_location, cfi);\n+    }\n+  else\n+    parmse->expr = gfc_build_addr_expr (NULL, cfi);\n+\n+  tmp = gfc_get_cfi_desc_version (cfi);\n+  gfc_add_modify (&block, tmp,\n+\t\t  build_int_cst (TREE_TYPE (tmp), CFI_VERSION));\n+  if (e->rank < 0)\n+    rank = fold_convert (signed_char_type_node, gfc_conv_descriptor_rank (gfc));\n+  else\n+    rank = build_int_cst (signed_char_type_node, e->rank);\n+  tmp = gfc_get_cfi_desc_rank (cfi);\n+  gfc_add_modify (&block, tmp, rank);\n+  int itype = CFI_type_other;\n+  if (e->ts.f90_type == BT_VOID)\n+    itype = (e->ts.u.derived->intmod_sym_id == ISOCBINDING_FUNPTR\n+\t     ? CFI_type_cfunptr : CFI_type_cptr);\n+  else\n+    switch (e->ts.type)\n+      {\n+\tcase BT_INTEGER:\n+\tcase BT_LOGICAL:\n+\tcase BT_REAL:\n+\tcase BT_COMPLEX:\n+\t  itype = CFI_type_from_type_kind (e->ts.type, e->ts.kind);\n+\t  break;\n+\tcase BT_CHARACTER:\n+\t  itype = CFI_type_from_type_kind (CFI_type_Character, e->ts.kind);\n+\t  break;\n+\tcase BT_DERIVED:\n+\t  itype = CFI_type_struct;\n+\t  break;\n+\tcase BT_VOID:\n+\t  itype = (e->ts.u.derived->intmod_sym_id == ISOCBINDING_FUNPTR\n+\t\t   ? CFI_type_cfunptr : CFI_type_cptr);\n+\t  break;\n+\tcase BT_ASSUMED:\n+\t  itype = CFI_type_other;  // FIXME: Or CFI_type_cptr ?\n+\t  break;\n+\tcase BT_CLASS:\n+\tcase BT_PROCEDURE:\n+\tcase BT_HOLLERITH:\n+\tcase BT_UNION:\n+\tcase BT_BOZ:\n+\tcase BT_UNKNOWN:\n+\t  // FIXME: Really unreachable? Or reachable for type(*) ? If so, CFI_type_other?\n+\t  gcc_unreachable ();\n+      }\n+\n+  tmp = gfc_get_cfi_desc_type (cfi);\n+  gfc_add_modify (&block, tmp,\n+\t\t  build_int_cst (TREE_TYPE (tmp), itype));\n \n+  int attr = CFI_attribute_other;\n   if (fsym->attr.pointer)\n-    cfi_attribute = 0;\n+    attr = CFI_attribute_pointer;\n   else if (fsym->attr.allocatable)\n-    cfi_attribute = 1;\n-  else\n-    cfi_attribute = 2;\n+    attr = CFI_attribute_allocatable;\n+  tmp = gfc_get_cfi_desc_attribute (cfi);\n+  gfc_add_modify (&block, tmp,\n+\t\t  build_int_cst (TREE_TYPE (tmp), attr));\n \n-  if (e->rank != 0)\n+  if (e->rank == 0)\n     {\n-      parmse->force_no_tmp = 1;\n-      if (fsym->attr.contiguous\n-\t  && !gfc_is_simply_contiguous (e, false, true))\n-\tgfc_conv_subref_array_arg (parmse, e, false, fsym->attr.intent,\n-\t\t\t\t   fsym->attr.pointer);\n-      else\n-\tgfc_conv_expr_descriptor (parmse, e);\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (parmse->expr)))\n-\tparmse->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t    parmse->expr);\n-      bool is_artificial = (INDIRECT_REF_P (parmse->expr)\n-\t\t\t    ? DECL_ARTIFICIAL (TREE_OPERAND (parmse->expr, 0))\n-\t\t\t    : DECL_ARTIFICIAL (parmse->expr));\n-\n-      /* Unallocated allocatable arrays and unassociated pointer arrays\n-\t need their dtype setting if they are argument associated with\n-\t assumed rank dummies.  */\n-      if (fsym && fsym->as\n-\t  && (gfc_expr_attr (e).pointer\n-\t      || gfc_expr_attr (e).allocatable))\n-\tset_dtype_for_unallocated (parmse, e);\n-\n-      /* All the temporary descriptors are marked as DECL_ARTIFICIAL. If\n-\t the expression type is different from the descriptor type, then\n-\t the offset must be found (eg. to a component ref or substring)\n-\t and the dtype updated.  Assumed type entities are only allowed\n-\t to be dummies in Fortran. They therefore lack the decl specific\n-\t appendiges and so must be treated differently from other fortran\n-\t entities passed to CFI descriptors in the interface decl.  */\n-      type = e->ts.type != BT_ASSUMED ? gfc_typenode_for_spec (&e->ts) :\n-\t\t\t\t\tNULL_TREE;\n-\n-      if (type && is_artificial\n-\t  && type != gfc_get_element_type (TREE_TYPE (parmse->expr)))\n-\t{\n-\t  /* Obtain the offset to the data.  */\n-\t  gfc_get_dataptr_offset (&parmse->pre, parmse->expr, parmse->expr,\n-\t\t\t\t  gfc_index_zero_node, true, e);\n-\n-\t  /* Update the dtype.  */\n-\t  gfc_add_modify (&parmse->pre,\n-\t\t\t  gfc_conv_descriptor_dtype (parmse->expr),\n-\t\t\t  gfc_get_dtype_rank_type (e->rank, type));\n-\t}\n-      else if (type == NULL_TREE\n-\t       || (!is_subref_array (e) && !is_artificial))\n-\t{\n-\t  /* Make sure that the span is set for expressions where it\n-\t     might not have been done already.  */\n-\t  tmp = gfc_conv_descriptor_elem_len (parmse->expr);\n-\t  tmp = fold_convert (gfc_array_index_type, tmp);\n-\t  gfc_conv_descriptor_span_set (&parmse->pre, parmse->expr, tmp);\n-\t}\n+      tmp = gfc_get_cfi_desc_base_addr (cfi);\n+      gfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp), gfc));\n     }\n   else\n     {\n-      gfc_conv_expr (parmse, e);\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (parmse->expr)))\n-\tparmse->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t    parmse->expr);\n+      tmp = gfc_get_cfi_desc_base_addr (cfi);\n+      tmp2 = gfc_conv_descriptor_data_get (gfc);\n+      gfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp), tmp2));\n+    }\n \n-      parmse->expr = gfc_conv_scalar_to_descriptor (parmse,\n-\t\t\t\t\t\t    parmse->expr, attr);\n+  /* Set elem_len if known - must be before the next if block.\n+     Note that allocatable implies 'len=:'.  */\n+  if (e->ts.type != BT_ASSUMED && e->ts.type != BT_CHARACTER )\n+    {\n+      /* Length is known at compile time; use use 'block' for it.  */\n+      tmp = size_in_bytes (gfc_typenode_for_spec (&e->ts));\n+      tmp2 = gfc_get_cfi_desc_elem_len (cfi);\n+      gfc_add_modify (&block, tmp2, fold_convert (TREE_TYPE (tmp2), tmp));\n     }\n \n-  /* Set the CFI attribute field through a temporary value for the\n-     gfc attribute.  */\n-  desc_attr = gfc_conv_descriptor_attribute (parmse->expr);\n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t void_type_node, desc_attr,\n-\t\t\t build_int_cst (TREE_TYPE (desc_attr), cfi_attribute));\n-  gfc_add_expr_to_block (&parmse->pre, tmp);\n+  /* When allocatable + intent out, free the cfi descriptor.  */\n+  if (fsym->attr.allocatable && fsym->attr.intent == INTENT_OUT)\n+    {\n+      tmp = gfc_get_cfi_desc_base_addr (cfi);\n+      tree call = builtin_decl_explicit (BUILT_IN_FREE);\n+      call = build_call_expr_loc (input_location, call, 1, tmp);\n+      gfc_add_expr_to_block (&block, fold_convert (void_type_node, call));\n+      gfc_add_modify (&block, tmp,\n+\t\t      fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+      goto done;\n+    }\n \n-  /* Now pass the gfc_descriptor by reference.  */\n-  parmse->expr = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n+  /* If not unallocated/unassociated. */\n+  gfc_init_block (&block2);\n \n-  /* Variables to point to the gfc and CFI descriptors; cfi = NULL implies\n-     that the CFI descriptor is allocated by the gfor_fndecl_gfc_to_cfi call.  */\n-  gfc_desc_ptr = parmse->expr;\n-  cfi_desc_ptr = gfc_create_var (pvoid_type_node, \"cfi\");\n-  gfc_add_modify (&parmse->pre, cfi_desc_ptr, null_pointer_node);\n+  /* Set elem_len, which may be only known at run time. */\n+  if (e->ts.type == BT_CHARACTER)\n+    {\n+      gcc_assert (gfc_strlen);\n+      tmp = gfc_strlen;\n+      if (e->ts.kind != 1)\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       gfc_charlen_type_node, tmp,\n+\t\t\t       build_int_cst (gfc_charlen_type_node,\n+\t\t\t\t\t      e->ts.kind));\n+      tmp2 = gfc_get_cfi_desc_elem_len (cfi);\n+      gfc_add_modify (&block2, tmp2, fold_convert (TREE_TYPE (tmp2), tmp));\n+    }\n+  else if (e->ts.type == BT_ASSUMED)\n+    {\n+      tmp = gfc_conv_descriptor_elem_len (gfc);\n+      tmp2 = gfc_get_cfi_desc_elem_len (cfi);\n+      gfc_add_modify (&block2, tmp2, fold_convert (TREE_TYPE (tmp2), tmp));\n+    }\n \n-  /* Allocate the CFI descriptor itself and fill the fields.  */\n-  tmp = gfc_build_addr_expr (NULL_TREE, cfi_desc_ptr);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     gfor_fndecl_gfc_to_cfi, 2, tmp, gfc_desc_ptr);\n-  gfc_add_expr_to_block (&parmse->pre, tmp);\n+  if (e->ts.type == BT_ASSUMED)\n+    {\n+      /* Note: type(*) implies assumed-shape/assumed-rank if fsym requires\n+\t an CFI descriptor.  Use the type in the descritor as it provide\n+\t mode information. (Quality of implementation feature.)  */\n+      tree cond;\n+      tree ctype = gfc_get_cfi_desc_type (cfi);\n+      tree type = fold_convert (TREE_TYPE (ctype),\n+\t\t\t\tgfc_conv_descriptor_type (gfc));\n+      tree kind = fold_convert (TREE_TYPE (ctype),\n+\t\t\t\tgfc_conv_descriptor_elem_len (gfc));\n+      kind = fold_build2_loc (input_location, LSHIFT_EXPR, TREE_TYPE (type),\n+\t\t\t      kind, build_int_cst (TREE_TYPE (type),\n+\t\t\t\t\t\t   CFI_type_kind_shift));\n+\n+      /* if (BT_VOID) CFI_type_cptr else CFI_type_other  */\n+      /* Note: BT_VOID is could also be CFI_type_funcptr, but assume c_ptr. */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_VOID));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, ctype,\n+\t\t\t     build_int_cst (TREE_TYPE (type), CFI_type_cptr));\n+      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t      ctype,\n+\t\t\t      build_int_cst (TREE_TYPE (type), CFI_type_other));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (BT_DERIVED) CFI_type_struct else  < tmp2 >  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_DERIVED));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, ctype,\n+\t\t\t     build_int_cst (TREE_TYPE (type), CFI_type_struct));\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (BT_CHARACTER) CFI_type_Character + kind=1 else  < tmp2 >  */\n+      /* Note: could also be kind=4, with cfi->elem_len = gfc->elem_len*4.  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_CHARACTER));\n+      tmp = build_int_cst (TREE_TYPE (type),\n+\t\t\t   CFI_type_from_type_kind (CFI_type_Character, 1));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t     ctype, tmp);\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (BT_COMPLEX) CFI_type_Complex + kind/2 else  < tmp2 >  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_COMPLEX));\n+      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, TREE_TYPE (type),\n+\t\t\t     kind, build_int_cst (TREE_TYPE (type), 2));\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (type), tmp,\n+\t\t\t     build_int_cst (TREE_TYPE (type),\n+\t\t\t\t\t    CFI_type_Complex));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t     ctype, tmp);\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      /* if (BT_INTEGER || BT_LOGICAL || BT_REAL) type + kind else  <tmp2>  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_INTEGER));\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_LOGICAL));\n+      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t      cond, tmp);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, type,\n+\t\t\t      build_int_cst (TREE_TYPE (type), BT_REAL));\n+      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t      cond, tmp);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (type),\n+\t\t\t     type, kind);\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t     ctype, tmp);\n+      tmp2 = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t      tmp, tmp2);\n+      gfc_add_expr_to_block (&block2, tmp2);\n+    }\n \n-  /* Now set the gfc descriptor attribute.  */\n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t void_type_node, desc_attr,\n-\t\t\t build_int_cst (TREE_TYPE (desc_attr), attribute));\n-  gfc_add_expr_to_block (&parmse->pre, tmp);\n+  if (e->rank != 0)\n+    {\n+      /* Loop: for (i = 0; i < rank; ++i).  */\n+      tree idx = gfc_create_var (TREE_TYPE (rank), \"idx\");\n+      /* Loop body.  */\n+      stmtblock_t loop_body;\n+      gfc_init_block (&loop_body);\n+      /* cfi->dim[i].lower_bound = (allocatable/pointer)\n+\t\t\t\t   ? gfc->dim[i].lbound : 0 */\n+      if (fsym->attr.pointer || fsym->attr.allocatable)\n+\ttmp = gfc_conv_descriptor_lbound_get (gfc, idx);\n+      else\n+\ttmp = gfc_index_zero_node;\n+      gfc_add_modify (&loop_body, gfc_get_cfi_dim_lbound (cfi, idx), tmp);\n+      /* cfi->dim[i].extent = gfc->dim[i].ubound - gfc->dim[i].lbound + 1.  */\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_ubound_get (gfc, idx),\n+\t\t\t     gfc_conv_descriptor_lbound_get (gfc, idx));\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+      gfc_add_modify (&loop_body, gfc_get_cfi_dim_extent (cfi, idx), tmp);\n+      /* d->dim[n].sm = gfc->dim[i].stride  * gfc->span); */\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_stride_get (gfc, idx),\n+\t\t\t     gfc_conv_descriptor_span_get (gfc));\n+      gfc_add_modify (&loop_body, gfc_get_cfi_dim_sm (cfi, idx), tmp);\n \n-  /* The CFI descriptor is passed to the bind_C procedure.  */\n-  parmse->expr = cfi_desc_ptr;\n+      /* Generate loop.  */\n+      gfc_simple_for_loop (&block2, idx, build_int_cst (TREE_TYPE (idx), 0),\n+\t\t\t   rank, LT_EXPR, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t   gfc_finish_block (&loop_body));\n \n-  /* Free the CFI descriptor.  */\n-  tmp = gfc_call_free (cfi_desc_ptr);\n-  gfc_prepend_expr_to_block (&parmse->post, tmp);\n+      if (e->expr_type == EXPR_VARIABLE\n+\t  && e->ref\n+\t  && e->ref->u.ar.type == AR_FULL\n+\t  && e->symtree->n.sym->attr.dummy\n+\t  && e->symtree->n.sym->as\n+\t  && e->symtree->n.sym->as->type == AS_ASSUMED_SIZE)\n+\t{\n+\t  tmp = gfc_get_cfi_dim_extent (cfi, gfc_rank_cst[e->rank-1]),\n+\t  gfc_add_modify (&block2, tmp, build_int_cst (TREE_TYPE (tmp), -1));\n+\t}\n+    }\n \n-  /* Transfer values back to gfc descriptor.  */\n-  if (cfi_attribute != 2  /* CFI_attribute_other.  */\n-      && !fsym->attr.value\n-      && fsym->attr.intent != INTENT_IN)\n+  if (fsym->attr.allocatable || fsym->attr.pointer)\n     {\n-      tmp = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n-      tmp = build_call_expr_loc (input_location,\n-\t\t\t\t gfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);\n-      gfc_prepend_expr_to_block (&parmse->post, tmp);\n+      tmp = gfc_get_cfi_desc_base_addr (cfi),\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     tmp, null_pointer_node);\n+      tmp = build3_v (COND_EXPR, tmp, gfc_finish_block (&block2),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n     }\n+  else\n+    gfc_add_block_to_block (&block, &block2);\n \n-  /* Deal with an optional dummy being passed to an optional formal arg\n-     by finishing the pre and post blocks and making their execution\n-     conditional on the dummy being present.  */\n-  if (fsym->attr.optional && e->expr_type == EXPR_VARIABLE\n-      && e->symtree->n.sym->attr.optional)\n+\n+done:\n+  if (present)\n     {\n-      cond = gfc_conv_expr_present (e->symtree->n.sym);\n-      tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n-\t\t\t cfi_desc_ptr,\n-\t\t\t build_int_cst (pvoid_type_node, 0));\n-      tmp = build3_v (COND_EXPR, cond,\n-\t\t      gfc_finish_block (&parmse->pre), tmp);\n+      parmse->expr = build3_loc (input_location, COND_EXPR,\n+\t\t\t\t TREE_TYPE (parmse->expr),\n+\t\t\t\t present, parmse->expr, null_pointer_node);\n+      tmp = build3_v (COND_EXPR, present, gfc_finish_block (&block),\n+\t\t      build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&parmse->pre, tmp);\n-      tmp = build3_v (COND_EXPR, cond,\n-\t\t      gfc_finish_block (&parmse->post),\n+    }\n+  else\n+    gfc_add_block_to_block (&parmse->pre, &block);\n+\n+  gfc_init_block (&block);\n+\n+  if ((!fsym->attr.allocatable && !fsym->attr.pointer)\n+      || fsym->attr.intent == INTENT_IN)\n+    goto post_call;\n+\n+  gfc_init_block (&block2);\n+  if (e->rank == 0)\n+    {\n+      tmp = gfc_get_cfi_desc_base_addr (cfi);\n+      gfc_add_modify (&block, gfc, fold_convert (TREE_TYPE (gfc), tmp));\n+    }\n+  else\n+    {\n+      tmp = gfc_get_cfi_desc_base_addr (cfi);\n+      gfc_conv_descriptor_data_set (&block, gfc, tmp);\n+\n+      if (fsym->attr.allocatable)\n+\t{\n+\t  /* gfc->span = cfi->elem_len.  */\n+\t  tmp = fold_convert (gfc_array_index_type,\n+\t\t\t      gfc_get_cfi_dim_sm (cfi, gfc_rank_cst[0]));\n+\t}\n+      else\n+\t{\n+\t  /* gfc->span = ((cfi->dim[0].sm % cfi->elem_len)\n+\t\t\t  ? cfi->dim[0].sm : cfi->elem_len).  */\n+\t  tmp = gfc_get_cfi_dim_sm (cfi, gfc_rank_cst[0]);\n+\t  tmp2 = fold_convert (gfc_array_index_type,\n+\t\t\t       gfc_get_cfi_desc_elem_len (cfi));\n+\t  tmp = fold_build2_loc (input_location, TRUNC_MOD_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp, tmp2);\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     tmp, gfc_index_zero_node);\n+\t  tmp = build3_loc (input_location, COND_EXPR, gfc_array_index_type, tmp,\n+\t\t\t    gfc_get_cfi_dim_sm (cfi, gfc_rank_cst[0]), tmp2);\n+\t}\n+      gfc_conv_descriptor_span_set (&block2, gfc, tmp);\n+\n+      /* Calculate offset + set lbound, ubound and stride.  */\n+      gfc_conv_descriptor_offset_set (&block2, gfc, gfc_index_zero_node);\n+      /* Loop: for (i = 0; i < rank; ++i).  */\n+      tree idx = gfc_create_var (TREE_TYPE (rank), \"idx\");\n+      /* Loop body.  */\n+      stmtblock_t loop_body;\n+      gfc_init_block (&loop_body);\n+      /* gfc->dim[i].lbound = ... */\n+      tmp = gfc_get_cfi_dim_lbound (cfi, idx);\n+      gfc_conv_descriptor_lbound_set (&loop_body, gfc, idx, tmp);\n+\n+      /* gfc->dim[i].ubound = gfc->dim[i].lbound + cfi->dim[i].extent - 1. */\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_lbound_get (gfc, idx),\n+\t\t\t     gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_get_cfi_dim_extent (cfi, idx), tmp);\n+      gfc_conv_descriptor_ubound_set (&loop_body, gfc, idx, tmp);\n+\n+      /* gfc->dim[i].stride = cfi->dim[i].sm / cfi>elem_len */\n+      tmp = gfc_get_cfi_dim_sm (cfi, idx);\n+      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t     fold_convert (gfc_array_index_type,\n+\t\t\t\t\t   gfc_get_cfi_desc_elem_len (cfi)));\n+      gfc_conv_descriptor_stride_set (&loop_body, gfc, idx, tmp);\n+\n+      /* gfc->offset -= gfc->dim[i].stride * gfc->dim[i].lbound. */\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_stride_get (gfc, idx),\n+\t\t\t     gfc_conv_descriptor_lbound_get (gfc, idx));\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_offset_get (gfc), tmp);\n+      gfc_conv_descriptor_offset_set (&loop_body, gfc, tmp);\n+      /* Generate loop.  */\n+      gfc_simple_for_loop (&block2, idx, build_int_cst (TREE_TYPE (idx), 0),\n+\t\t\t   rank, LT_EXPR, build_int_cst (TREE_TYPE (idx), 1),\n+\t\t\t   gfc_finish_block (&loop_body));\n+    }\n+\n+  if (e->ts.type == BT_CHARACTER && !e->ts.u.cl->length)\n+    {\n+      tmp = fold_convert (gfc_charlen_type_node,\n+\t\t\t  gfc_get_cfi_desc_elem_len (cfi));\n+      if (e->ts.kind != 1)\n+\ttmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t       gfc_charlen_type_node, tmp,\n+\t\t\t       build_int_cst (gfc_charlen_type_node,\n+\t\t\t\t\t      e->ts.kind));\n+      gfc_add_modify (&block2, gfc_strlen, tmp);\n+    }\n+\n+  tmp = gfc_get_cfi_desc_base_addr (cfi),\n+  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t tmp, null_pointer_node);\n+  tmp = build3_v (COND_EXPR, tmp, gfc_finish_block (&block2),\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+post_call:\n+  gfc_add_block_to_block (&block, &se.post);\n+  if (present && block.head)\n+    {\n+      tmp = build3_v (COND_EXPR, present, gfc_finish_block (&block),\n \t\t      build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&parmse->post, tmp);\n     }\n+  else if (block.head)\n+    gfc_add_block_to_block (&parmse->post, &block);\n }\n \n \n@@ -5764,17 +6088,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n        arg = arg->next, formal = formal ? formal->next : NULL, ++argc)\n     {\n       bool finalized = false;\n-      bool assumed_length_string = false;\n       tree derived_array = NULL_TREE;\n \n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n       parm_kind = MISSING;\n \n-      if (fsym && fsym->ts.type == BT_CHARACTER\n-\t  && (!fsym->ts.u.cl || !fsym->ts.u.cl->length))\n-\tassumed_length_string = true;\n-\n       /* If the procedure requires an explicit interface, the actual\n \t argument is passed according to the corresponding formal\n \t argument.  If the corresponding formal argument is a POINTER,\n@@ -6005,9 +6324,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    parmse.expr = convert (type, tmp);\n \t\t}\n \n-\t      else if (sym->attr.is_bind_c && e\n-\t\t       && (is_CFI_desc (fsym, NULL)\n-\t\t\t   || assumed_length_string))\n+\t      else if (sym->attr.is_bind_c && e && is_CFI_desc (fsym, NULL))\n \t\t/* Implement F2018, 18.3.6, list item (5), bullet point 2.  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n \n@@ -6217,7 +6534,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  if (fsym && fsym->attr.intent == INTENT_OUT\n \t\t      && (fsym->attr.allocatable\n \t\t\t  || (fsym->ts.type == BT_CLASS\n-\t\t\t      && CLASS_DATA (fsym)->attr.allocatable)))\n+\t\t\t      && CLASS_DATA (fsym)->attr.allocatable))\n+\t\t      && !is_CFI_desc (fsym, NULL))\n \t\t    {\n \t\t      stmtblock_t block;\n \t\t      tree ptr;\n@@ -6474,8 +6792,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    ref->u.ar.type = AR_SECTION;\n \t\t}\n \n-\t      if (sym->attr.is_bind_c && e\n-\t\t  && (is_CFI_desc (fsym, NULL) || assumed_length_string))\n+\t      if (sym->attr.is_bind_c && e && is_CFI_desc (fsym, NULL))\n \t\t/* Implement F2018, 18.3.6, list item (5), bullet point 2.  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n \n@@ -6535,9 +6852,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t\t  sym->name, NULL);\n \n \t      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is\n-\t\t allocated on entry, it must be deallocated.  */\n+\t\t allocated on entry, it must be deallocated.\n+\t\t CFI descriptors are handled elsewhere.  */\n \t      if (fsym && fsym->attr.allocatable\n-\t\t  && fsym->attr.intent == INTENT_OUT)\n+\t\t  && fsym->attr.intent == INTENT_OUT\n+\t\t  && !is_CFI_desc (fsym, NULL))\n \t\t{\n \t\t  if (fsym->ts.type == BT_DERIVED\n \t\t      && fsym->ts.u.derived->attr.alloc_comp)"}, {"sha": "4f1b346295939def138a17d9812a8f698bde5646", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -72,7 +72,8 @@ gfc_omp_is_allocatable_or_ptr (const_tree decl)\n static bool\n gfc_omp_is_optional_argument (const_tree decl)\n {\n-  return (TREE_CODE (decl) == PARM_DECL\n+  /* Note: VAR_DECL can occur with BIND(C) and array descriptors.  */\n+  return ((TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == VAR_DECL)\n \t  && DECL_LANG_SPECIFIC (decl)\n \t  && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n \t  && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl)))\n@@ -105,8 +106,9 @@ gfc_omp_check_optional_argument (tree decl, bool for_present_check)\n \t  || GFC_ARRAY_TYPE_P (TREE_TYPE (decl))))\n     decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n \n+  /* Note: With BIND(C), array descriptors are converted to a VAR_DECL.  */\n   if (decl == NULL_TREE\n-      || TREE_CODE (decl) != PARM_DECL\n+      || (TREE_CODE (decl) != PARM_DECL && TREE_CODE (decl) != VAR_DECL)\n       || !DECL_LANG_SPECIFIC (decl)\n       || !GFC_DECL_OPTIONAL_ARGUMENT (decl))\n     return NULL_TREE;"}, {"sha": "c66a3bee83e66e2640a2f63d48aadf39381b9e3d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -3670,10 +3670,7 @@ gfc_trans_select_rank_cases (gfc_code * code)\n   tree tmp;\n   tree cond;\n   tree low;\n-  tree sexpr;\n   tree rank;\n-  tree rank_minus_one;\n-  tree minus_one;\n   gfc_se se;\n   gfc_se cse;\n   stmtblock_t block;\n@@ -3687,24 +3684,25 @@ gfc_trans_select_rank_cases (gfc_code * code)\n   gfc_conv_expr_descriptor (&se, code->expr1);\n   rank = gfc_conv_descriptor_rank (se.expr);\n   rank = gfc_evaluate_now (rank, &block);\n-  minus_one = build_int_cst (TREE_TYPE (rank), -1);\n-  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t gfc_array_index_type,\n-\t\t\t fold_convert (gfc_array_index_type, rank),\n-\t\t\t build_int_cst (gfc_array_index_type, 1));\n-  rank_minus_one = gfc_evaluate_now (tmp, &block);\n-  tmp = gfc_conv_descriptor_ubound_get (se.expr, rank_minus_one);\n-  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n-\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp), -1));\n-  tmp = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t TREE_TYPE (rank), cond,\n-\t\t\t rank, minus_one);\n-  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n-\t\t\t  rank, build_int_cst (TREE_TYPE (rank), 0));\n-  sexpr = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t   TREE_TYPE (rank), cond,\n-\t\t\t   rank, tmp);\n-  sexpr = gfc_evaluate_now (sexpr, &block);\n+  symbol_attribute attr = gfc_expr_attr (code->expr1);\n+  if (!attr.pointer || !attr.allocatable)\n+    {\n+      /* Special case for assumed-rank ('rank(*)', internally -1):\n+\t rank = (rank == 0 || ubound[rank-1] != -1) ? rank : -1.  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n+\t\t\t      rank, build_int_cst (TREE_TYPE (rank), 0));\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     fold_convert (gfc_array_index_type, rank),\n+\t\t\t     gfc_index_one_node);\n+      tmp = gfc_conv_descriptor_ubound_get (se.expr, tmp);\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n+\t\t\t     tmp, build_int_cst (TREE_TYPE (tmp), -1));\n+      cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t      logical_type_node, cond, tmp);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, TREE_TYPE (rank),\n+\t\t\t     cond, rank, build_int_cst (TREE_TYPE (rank), -1));\n+      rank = gfc_evaluate_now (tmp, &block);\n+    }\n   TREE_USED (code->exit_label) = 0;\n \n repeat:\n@@ -3748,8 +3746,8 @@ gfc_trans_select_rank_cases (gfc_code * code)\n       if (low != NULL_TREE)\n \t{\n \t  cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t  TREE_TYPE (sexpr), sexpr,\n-\t\t\t\t  fold_convert (TREE_TYPE (sexpr), low));\n+\t\t\t\t  TREE_TYPE (rank), rank,\n+\t\t\t\t  fold_convert (TREE_TYPE (rank), low));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t cond, tmp,\n \t\t\t\t build_empty_stmt (input_location));"}, {"sha": "50fceebc941612824ddc6c3316c6dadaca89942a", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -77,6 +77,7 @@ static GTY(()) tree gfc_desc_dim_type;\n static GTY(()) tree gfc_max_array_element_size;\n static GTY(()) tree gfc_array_descriptor_base[2 * (GFC_MAX_DIMENSIONS+1)];\n static GTY(()) tree gfc_array_descriptor_base_caf[2 * (GFC_MAX_DIMENSIONS+1)];\n+static GTY(()) tree gfc_cfi_descriptor_base[2 * (CFI_MAX_RANK + 2)];\n \n /* Arrays for all integral and real kinds.  We'll fill this in at runtime\n    after the target has a chance to process command-line options.  */\n@@ -1575,8 +1576,9 @@ gfc_get_dtype_rank_type (int rank, tree etype)\n \n   field = gfc_advance_chain (TYPE_FIELDS (dtype_type_node),\n \t\t\t     GFC_DTYPE_RANK);\n-  CONSTRUCTOR_APPEND_ELT (v, field,\n-\t\t\t  build_int_cst (TREE_TYPE (field), rank));\n+  if (rank >= 0)\n+    CONSTRUCTOR_APPEND_ELT (v, field,\n+\t\t\t    build_int_cst (TREE_TYPE (field), rank));\n \n   field = gfc_advance_chain (TYPE_FIELDS (dtype_type_node),\n \t\t\t     GFC_DTYPE_TYPE);\n@@ -2244,7 +2246,7 @@ gfc_nonrestricted_type (tree t)\n    especially for character and array types.  */\n \n tree\n-gfc_sym_type (gfc_symbol * sym)\n+gfc_sym_type (gfc_symbol * sym, bool is_bind_c)\n {\n   tree type;\n   int byref;\n@@ -2299,7 +2301,11 @@ gfc_sym_type (gfc_symbol * sym)\n   if (!restricted)\n     type = gfc_nonrestricted_type (type);\n \n-  if (sym->attr.dimension || sym->attr.codimension)\n+  /* Dummy argument to a bind(C) procedure.  */\n+  if (is_bind_c && is_CFI_desc (sym, NULL))\n+    type = gfc_get_cfi_type (sym->attr.dimension ? sym->as->rank : 0,\n+\t\t\t     /* restricted = */ false);\n+  else if (sym->attr.dimension || sym->attr.codimension)\n     {\n       if (gfc_is_nodesc_array (sym))\n         {\n@@ -3132,7 +3138,7 @@ gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args,\n \t      type = build_pointer_type (type);\n \t    }\n \t  else\n-\t    type = gfc_sym_type (arg);\n+\t    type = gfc_sym_type (arg, sym->attr.is_bind_c);\n \n \t  /* Parameter Passing Convention\n \n@@ -3723,4 +3729,95 @@ gfc_get_caf_reference_type ()\n   return reference_type;\n }\n \n+static tree\n+gfc_get_cfi_dim_type ()\n+{\n+  static tree CFI_dim_t = NULL;\n+\n+  if (CFI_dim_t)\n+    return CFI_dim_t;\n+\n+  CFI_dim_t = make_node (RECORD_TYPE);\n+  TYPE_NAME (CFI_dim_t) = get_identifier (\"CFI_dim_t\");\n+  TYPE_NAMELESS (CFI_dim_t) = 1;\n+  tree field;\n+  tree *chain = NULL;\n+  field = gfc_add_field_to_struct_1 (CFI_dim_t, get_identifier (\"lower_bound\"),\n+\t\t\t\t     gfc_array_index_type, &chain);\n+  suppress_warning (field);\n+  field = gfc_add_field_to_struct_1 (CFI_dim_t, get_identifier (\"extent\"),\n+\t\t\t\t     gfc_array_index_type, &chain);\n+  suppress_warning (field);\n+  field = gfc_add_field_to_struct_1 (CFI_dim_t, get_identifier (\"sm\"),\n+\t\t\t\t     gfc_array_index_type, &chain);\n+  suppress_warning (field);\n+  gfc_finish_type (CFI_dim_t);\n+  TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (CFI_dim_t)) = 1;\n+  return CFI_dim_t;\n+}\n+\n+\n+/* Return the CFI type; use dimen == -1 for dim[] (only for pointers);\n+   otherwise dim[dimen] is used.  */\n+\n+tree\n+gfc_get_cfi_type (int dimen, bool restricted)\n+{\n+  gcc_assert (dimen >= -1 && dimen <= CFI_MAX_RANK);\n+\n+  int idx = 2*(dimen + 1) + restricted;\n+\n+  if (gfc_cfi_descriptor_base[idx])\n+    return gfc_cfi_descriptor_base[idx];\n+\n+  /* Build the type node.  */\n+  tree CFI_cdesc_t = make_node (RECORD_TYPE);\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  if (dimen != -1)\n+    sprintf (name, \"CFI_cdesc_t\" GFC_RANK_PRINTF_FORMAT, dimen);\n+  TYPE_NAME (CFI_cdesc_t) = get_identifier (dimen < 0 ? \"CFI_cdesc_t\" : name);\n+  TYPE_NAMELESS (CFI_cdesc_t) = 1;\n+\n+  tree field;\n+  tree *chain = NULL;\n+  field = gfc_add_field_to_struct_1 (CFI_cdesc_t, get_identifier (\"base_addr\"),\n+\t\t\t\t     (restricted ? prvoid_type_node\n+\t\t\t\t\t\t : ptr_type_node), &chain);\n+  suppress_warning (field);\n+  field = gfc_add_field_to_struct_1 (CFI_cdesc_t, get_identifier (\"elem_len\"),\n+\t\t\t\t     size_type_node, &chain);\n+  suppress_warning (field);\n+  field = gfc_add_field_to_struct_1 (CFI_cdesc_t, get_identifier (\"version\"),\n+\t\t\t\t     integer_type_node, &chain);\n+  suppress_warning (field);\n+  field = gfc_add_field_to_struct_1 (CFI_cdesc_t, get_identifier (\"rank\"),\n+\t\t\t\t     signed_char_type_node, &chain);\n+  suppress_warning (field);\n+  field = gfc_add_field_to_struct_1 (CFI_cdesc_t, get_identifier (\"attribute\"),\n+\t\t\t\t     signed_char_type_node, &chain);\n+  suppress_warning (field);\n+  field = gfc_add_field_to_struct_1 (CFI_cdesc_t, get_identifier (\"type\"),\n+\t\t\t\t     get_typenode_from_name (INT16_TYPE),\n+\t\t\t\t     &chain);\n+  suppress_warning (field);\n+\n+  if (dimen != 0)\n+    {\n+      tree range = NULL_TREE;\n+      if (dimen > 0)\n+\trange = gfc_rank_cst[dimen - 1];\n+      range = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n+\t\t\t\trange);\n+      tree CFI_dim_t = build_array_type (gfc_get_cfi_dim_type (), range);\n+      field = gfc_add_field_to_struct_1 (CFI_cdesc_t, get_identifier (\"dim\"),\n+\t\t\t\t\t CFI_dim_t, &chain);\n+      suppress_warning (field);\n+    }\n+\n+  TYPE_TYPELESS_STORAGE (CFI_cdesc_t) = 1;\n+  gfc_finish_type (CFI_cdesc_t);\n+  gfc_cfi_descriptor_base[idx] = CFI_cdesc_t;\n+  return CFI_cdesc_t;\n+}\n+\n #include \"gt-fortran-trans-types.h\""}, {"sha": "15d206b9443b7744531e48d26185c74fa710f98a", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -84,7 +84,8 @@ tree gfc_get_character_type (int, gfc_charlen *);\n tree gfc_get_character_type_len (int, tree);\n tree gfc_get_character_type_len_for_eltype (tree, tree);\n \n-tree gfc_sym_type (gfc_symbol *);\n+tree gfc_sym_type (gfc_symbol *, bool is_bind_c_arg = false);\n+tree gfc_get_cfi_type (int dimen, bool restricted);\n tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);\n int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);\n "}, {"sha": "22f267645e8fb59ad17efc9a577c5abde245b4d5", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -608,9 +608,9 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n \n   if (once)\n     {\n-       tmpvar = gfc_create_var (logical_type_node, \"print_warning\");\n+       tmpvar = gfc_create_var (boolean_type_node, \"print_warning\");\n        TREE_STATIC (tmpvar) = 1;\n-       DECL_INITIAL (tmpvar) = logical_true_node;\n+       DECL_INITIAL (tmpvar) = boolean_true_node;\n        gfc_add_expr_to_block (pblock, tmpvar);\n     }\n \n@@ -631,7 +631,7 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n   va_end (ap);\n \n   if (once)\n-    gfc_add_modify (&block, tmpvar, logical_false_node);\n+    gfc_add_modify (&block, tmpvar, boolean_false_node);\n \n   body = gfc_finish_block (&block);\n \n@@ -643,9 +643,8 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n     {\n       if (once)\n \tcond = fold_build2_loc (gfc_get_location (where), TRUTH_AND_EXPR,\n-\t\t\t\tlong_integer_type_node, tmpvar, cond);\n-      else\n-\tcond = fold_convert (long_integer_type_node, cond);\n+\t\t\t\tboolean_type_node, tmpvar,\n+\t\t\t\tfold_convert (boolean_type_node, cond));\n \n       tmp = fold_build3_loc (gfc_get_location (where), COND_EXPR, void_type_node,\n \t\t\t     cond, body,"}, {"sha": "7ec4ca53a2c69d5884bedecf93c86ddb5f47dbf7", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -857,8 +857,6 @@ extern GTY(()) tree gfor_fndecl_ctime;\n extern GTY(()) tree gfor_fndecl_fdate;\n extern GTY(()) tree gfor_fndecl_in_pack;\n extern GTY(()) tree gfor_fndecl_in_unpack;\n-extern GTY(()) tree gfor_fndecl_cfi_to_gfc;\n-extern GTY(()) tree gfor_fndecl_gfc_to_cfi;\n extern GTY(()) tree gfor_fndecl_associated;\n extern GTY(()) tree gfor_fndecl_system_clock4;\n extern GTY(()) tree gfor_fndecl_system_clock8;"}, {"sha": "8cc1601d047ca89bec9d77f6e9734df52fbfcd34", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_19.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_19.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! This testcase failed before with optimization as\n+! allocatef's CFI descriptor argument 'x' failed with -fstrict-alias due to\n+! internally alising with the GFC descriptor\n+!\n+\n+program testit\n+  use iso_c_binding\n+  implicit none (external, type)\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+  type(m), allocatable :: a(:)\n+\n+  call testf (a)\n+\n+contains\n+  subroutine allocatef (x) bind (c)\n+    type(m), allocatable :: x(:)\n+    allocate (x(5:15))\n+  end subroutine\n+\n+  subroutine testf (y)\n+    type(m), allocatable, target :: y(:)\n+    call allocatef (y)\n+    if (.not. allocated (y))  stop 1\n+  end subroutine\n+end program"}, {"sha": "c596e47cfdd2682c591d4c92d1529bab17f2408a", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_4.f90", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -19,23 +19,37 @@ subroutine ctg(x) BIND(C)\n \n   subroutine substr(str) BIND(C)\n     character(*) :: str(:)\n-    if (str(2) .ne. \"ghi\") stop 2\n+    if (str(1) .ne. \"bcd\") stop 2\n+    if (str(2) .ne. \"ghi\") stop 3\n     str = ['uvw','xyz']\n   end subroutine\n \n+  subroutine substr4(str4) BIND(C)\n+    character(*, kind=4) :: str4(:)\n+    print *, str4(1)\n+    print *, str4(2)\n+    if (str4(1) .ne. 4_\"bcd\") stop 4\n+    if (str4(2) .ne. 4_\"ghi\") stop 5\n+    str4 = [4_'uvw', 4_'xyz']\n+  end subroutine\n+\n end module\n \n program p\n   use mod_ctg\n   implicit none\n   real :: x(6)\n-  character(5) :: str(2) = ['abcde','fghij']\n+  character(5)         :: str(2)  = ['abcde', 'fghij']\n+  character(5, kind=4) :: str4(2) = [4_'abcde', 4_'fghij']\n   integer :: i\n \n   x = [ (real(i), i=1, size(x)) ]\n   call ctg(x(2::2))\n   if (any (abs (x - [1.,20.,3.,40.,5.,60.]) > 1.e-6)) stop 3\n \n-  call substr(str(:)(2:4))\n-  if (any (str .ne. ['auvwe','fxyzj'])) stop 4\n+  !call substr(str(:)(2:4))\n+  !if (any (str .ne. ['auvwe','fxyzj'])) stop 4\n+\n+  call substr4(str4(:)(2:4))\n+  if (any (str4 .ne. [4_'auvwe', 4_'fxyzj'])) stop 4\n end program"}, {"sha": "8588157e59c007b4131ef7028c118bd65ed4f45a", "filename": "gcc/testsuite/gfortran.dg/PR100914.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100914.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! Fails on x86 targets where sizeof(long double) == 16.\n-! { dg-do run { xfail { { x86_64*-*-* i?86*-*-* } && longdouble128 } } }\n+! { dg-do run }\n ! { dg-additional-sources PR100914.c }\n ! { dg-require-effective-target fortran_real_c_float128 }\n ! { dg-additional-options \"-Wno-pedantic\" }"}, {"sha": "4eaf82a5d27f842ec12fd579090dbbf199c9c3d4", "filename": "gcc/testsuite/gfortran.dg/PR100915.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -67,7 +67,7 @@ check_fn (const CFI_cdesc_t *restrict auxp, const CFI_type_t type, const signed\n   /*  */\n   assert (auxp->type==type);\n   ityp = _CFI_decode_type(auxp->type);\n-  assert (ityp == CFI_type_cptr);\n+  assert (ityp == CFI_type_cfunptr);\n   iknd = _CFI_decode_kind(auxp->type);\n   assert (_CFI_decode_type(type)==ityp);\n   assert (kind==iknd);"}, {"sha": "64a2a88fe2da652b2471dd61b387849857371488", "filename": "gcc/testsuite/gfortran.dg/PR100915.f90", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100915.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -14,7 +14,7 @@ module isof_m\n   private\n   \n   public :: &\n-    CFI_type_cptr\n+    CFI_type_cptr, CFI_type_cfunptr\n   \n   public ::      &\n     check_fn_as, &\n@@ -33,6 +33,7 @@ module isof_m\n \n   ! Intrinsic types. Their kind number defines their storage size. */\n   integer(kind=c_signed_char), parameter :: CFI_type_cptr   = 7\n+  integer(kind=c_signed_char), parameter :: CFI_type_cfunptr   = 8\n \n   interface\n     subroutine check_fn_as(a, t, k, e, n) &\n@@ -99,7 +100,7 @@ module iso_check_m\n     c_funptr, c_funloc, c_associated\n \n   use :: isof_m, only:  &\n-    CFI_type_cptr\n+    CFI_type_cptr, CFI_type_cfunptr\n   \n   use :: isof_m, only: &\n     check_fn_as,       &\n@@ -155,7 +156,7 @@ subroutine f_check_c_funptr_as(a)\n     !\n     k = 0\n     e = storage_size(a)/b\n-    t = cfi_encode_type(CFI_type_cptr, k)\n+    t = cfi_encode_type(CFI_type_cfunptr, k)\n     ! Assumes 64-bit target.\n     ! if(e/=8) stop 5\n     do i = 1, n\n@@ -176,7 +177,7 @@ subroutine c_check_c_funptr_as(a) bind(c)\n     !\n     k = 0\n     e = storage_size(a)/b\n-    t = cfi_encode_type(CFI_type_cptr, k)\n+    t = cfi_encode_type(CFI_type_cfunptr, k)\n     ! Assumes 64-bit target.\n     ! if(e/=8) stop 8\n     do i = 1, n\n@@ -198,7 +199,7 @@ subroutine f_check_c_funptr_ar(a)\n     !\n     k = 0\n     e = storage_size(a)/b\n-    t = cfi_encode_type(CFI_type_cptr, k)\n+    t = cfi_encode_type(CFI_type_cfunptr, k)\n     ! Assumes 64-bit target.\n     ! if(e/=8) stop 11\n     select rank(a)\n@@ -229,7 +230,7 @@ subroutine c_check_c_funptr_ar(a) bind(c)\n     !\n     k = 0\n     e = storage_size(a)/b\n-    t = cfi_encode_type(CFI_type_cptr, k)\n+    t = cfi_encode_type(CFI_type_cfunptr, k)\n     ! Assumes 64-bit target.\n     ! if(e/=8) stop 16\n     select rank(a)"}, {"sha": "66c937974ac1c2ff844158557eefb00088bd6fea", "filename": "gcc/testsuite/gfortran.dg/PR93963.f90", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93963.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93963.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93963.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -3,6 +3,8 @@\n ! Test the fix for PR93963\n !\n \n+module m\n+contains\n function rank_p(this) result(rnk) bind(c)\n   use, intrinsic :: iso_c_binding, only: c_int\n \n@@ -97,27 +99,60 @@ function rank_a(this) result(rnk) bind(c)\n   return\n end function rank_a\n \n-program selr_p\n-\n+function rank_o(this) result(rnk) bind(c)\n   use, intrinsic :: iso_c_binding, only: c_int\n \n   implicit none\n+  \n+  integer(kind=c_int), intent(in) :: this(..)\n+  integer(kind=c_int)             :: rnk\n \n-  interface\n-    function rank_p(this) result(rnk) bind(c)\n-      use, intrinsic :: iso_c_binding, only: c_int\n-      integer(kind=c_int), pointer, intent(in) :: this(..)\n-      integer(kind=c_int)                      :: rnk\n-    end function rank_p\n-  end interface\n-\n-  interface\n-    function rank_a(this) result(rnk) bind(c)\n-      use, intrinsic :: iso_c_binding, only: c_int\n-      integer(kind=c_int), allocatable, intent(in) :: this(..)\n-      integer(kind=c_int)                          :: rnk\n-    end function rank_a\n-  end interface\n+  select rank(this)\n+  rank(0)\n+    rnk = 0\n+  rank(1)\n+    rnk = 1\n+  rank(2)\n+    rnk = 2\n+  rank(3)\n+    rnk = 3\n+  rank(4)\n+    rnk = 4\n+  rank(5)\n+    rnk = 5\n+  rank(6)\n+    rnk = 6\n+  rank(7)\n+    rnk = 7\n+  rank(8)\n+    rnk = 8\n+  rank(9)\n+    rnk = 9\n+  rank(10)\n+    rnk = 10\n+  rank(11)\n+    rnk = 11\n+  rank(12)\n+    rnk = 12\n+  rank(13)\n+    rnk = 13\n+  rank(14)\n+    rnk = 14\n+  rank(15)\n+    rnk = 15\n+  rank default\n+    rnk = -1000\n+  end select\n+  return\n+end function rank_o\n+\n+end module m\n+\n+program selr_p\n+  use m\n+  use, intrinsic :: iso_c_binding, only: c_int\n+\n+  implicit none\n \n   integer(kind=c_int), parameter :: siz = 7\n   integer(kind=c_int), parameter :: rnk = 1\n@@ -139,12 +174,19 @@ end function rank_a\n   irnk = rank_p(intp)\n   if (irnk /= rnk)        stop 5\n   if (irnk /= rank(intp)) stop 6\n+  irnk = rank_o(intp)\n+  if (irnk /= rnk)        stop 7\n+  if (irnk /= rank(intp)) stop 8\n   deallocate(intp)\n   nullify(intp)\n   !\n   allocate(inta(siz))\n-  if (irnk /= rnk)        stop 7\n-  if (irnk /= rank(inta)) stop 8\n+  irnk = rank_a(inta)\n+  if (irnk /= rnk)        stop 9\n+  if (irnk /= rank(inta)) stop 10\n+  irnk = rank_o(inta)\n+  if (irnk /= rnk)        stop 11\n+  if (irnk /= rank(inta)) stop 12\n   deallocate(inta)\n \n end program selr_p"}, {"sha": "ce6d0bc5a93d8ff5647370c504911f35c504451d", "filename": "gcc/testsuite/gfortran.dg/assumed_type_12.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_12.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,34 @@\n+! PR fortran/102086\n+\n+implicit none (type, external)\n+contains\n+subroutine as(a)\n+  type(*) :: a(:,:)\n+end\n+subroutine ar(b)\n+  type(*) :: b(..)\n+end\n+subroutine bar(x,y)\n+  type(*) :: x\n+  type(*) :: y(3,*)\n+  call as(x)  ! { dg-error \"Rank mismatch in argument 'a' at .1. \\\\(rank-2 and scalar\\\\)\" }\n+  call ar(x)  ! { dg-error \"Assumed-type actual argument at .1. corresponding to assumed-rank dummy argument 'b' must be assumed-shape or assumed-rank\" }\n+  call ar(y)  ! { dg-error \"Assumed-type actual argument at .1. corresponding to assumed-rank dummy argument 'b' must be assumed-shape or assumed-rank\" }\n+  call as(y(1,3))  ! { dg-error \"Assumed-type variable y at .1. shall not have a subobject reference\" }\n+  call ar(y(1,3))  ! { dg-error \"Assumed-type variable y at .1. shall not have a subobject reference\" }\n+  call as(y(1:1,3:3))  ! { dg-error \"Assumed-type variable y at .1. shall not have a subobject reference\" }\n+  call ar(y(1:1,3:3))  ! { dg-error \"Assumed-type variable y at .1. shall not have a subobject reference\" }\n+end\n+\n+subroutine okayish(x,y,z)\n+  type(*) :: x(:)\n+  type(*) :: y(:,:)\n+  type(*) :: z(..)\n+  call as(x) ! { dg-error \"Rank mismatch in argument 'a' at .1. \\\\(rank-2 and rank-1\\\\)\" }\n+  call as(y) \n+  call as(z) ! { dg-error \"The assumed-rank array at .1. requires that the dummy argument 'a' has assumed-rank\" }\n+  call ar(x)\n+  call ar(y)\n+  call ar(z)\n+end\n+end"}, {"sha": "d602d35b4a48f77be3f30e21770725713e4463b9", "filename": "gcc/testsuite/gfortran.dg/assumed_type_13.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_13.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,26 @@\n+#include <ISO_Fortran_binding.h>\n+\n+void\n+test_c (CFI_cdesc_t *x, size_t n, int num)\n+{\n+  if (!x->base_addr)\n+    __builtin_abort ();\n+  if (x->version != CFI_VERSION)\n+    __builtin_abort ();\n+  if (x->rank != 1)\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  if (x->dim[0].lower_bound != 0)\n+    __builtin_abort ();\n+  if (x->dim[0].extent != 3)\n+    __builtin_abort ();\n+\n+  if (x->elem_len != n || x->dim[0].sm != n)\n+    __builtin_abort ();\n+\n+  if (num == 1 && x->type != CFI_type_int16_t)\n+    __builtin_abort ();\n+  if (num == 2 && x->type != CFI_type_double_Complex)\n+    __builtin_abort ();\n+}"}, {"sha": "da167aee0fa7ea336f911292d163b247837a6c5c", "filename": "gcc/testsuite/gfortran.dg/assumed_type_13.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_13.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-additional-sources assumed_type_13.c }\n+\n+use iso_c_binding, only: c_size_t, c_int\n+implicit none (type, external)\n+\n+interface\n+  subroutine test_c (x, n, num) bind (C)\n+    import :: c_size_t, c_int\n+    integer(c_size_t), value :: n\n+    integer(c_int), value :: num\n+    type(*) :: x(:)\n+  end subroutine test_c\n+end interface\n+\n+complex(8) :: b(3)\n+\n+call test_c ([1_2, 2_2, 3_2], sizeof(1_2), num=1)\n+call test_c (b, sizeof(b(1)), num=2)\n+call outer_bc ([1_2, 2_2, 3_2], sizeof(1_2), num=1)\n+call outer_bc (b, sizeof(b(1)), num=2)\n+call outer_f ([1_2, 2_2, 3_2], sizeof(1_2), num=1)\n+call outer_f (b, sizeof(b(1)), num=2)\n+\n+contains\n+\n+subroutine outer_bc (x, n, num) bind(C)\n+  integer(c_size_t), value :: n\n+  integer(c_int), value :: num\n+  type(*) :: x(:)\n+  !  print *,sizeof(x)/size(x), n\n+  if (sizeof(x)/size(x) /=  n) error stop 1\n+  call inner_bc (x, n, num)\n+  call inner_f (x, n, num)\n+  call test_c (x, n, num)\n+end\n+\n+subroutine outer_f (x, n, num)\n+  integer(c_size_t), value :: n\n+  integer(c_int), value :: num\n+  type(*) :: x(:)\n+  !  print *,sizeof(x)/size(x), n\n+  if (sizeof(x)/size(x) /=  n) error stop 1\n+  call inner_f (x, n, num)\n+  call inner_bc (x, n, num)\n+  call test_c (x, n, num)\n+end\n+\n+subroutine inner_bc(x, n, num) bind(C)\n+  integer(c_size_t), value :: n\n+  integer(c_int), value :: num\n+  type(*) :: x(:)\n+  !  print *,sizeof(x)/size(x), n\n+  if (sizeof(x)/size(x) /=  n) error stop 2\n+  call test_c (x, n, num)\n+end\n+\n+subroutine inner_f(x, n, num)\n+  integer(c_size_t), value :: n\n+  integer(c_int), value :: num\n+  type(*) :: x(:)\n+  !  print *,sizeof(x)/size(x), n\n+  if (sizeof(x)/size(x) /=  n) error stop 3\n+  call test_c (x, n, num)\n+end\n+end "}, {"sha": "3b01ad3b63d76be877bf1049e32cc0a0436daa3f", "filename": "gcc/testsuite/gfortran.dg/bind-c-char-descr.f90", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-char-descr.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-char-descr.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-char-descr.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,104 @@\n+! PR fortran/92482\n+!\n+! Contributed by Jos\u00e9 Rui Faustino de Sousa \n+!\n+! Note the xfail issue below for 'strg_print_2(\"abc\")\n+\n+program strp_p\n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_char\n+    \n+  implicit none\n+\n+  integer, parameter :: l = 3\n+\n+  character(len=l, kind=c_char),  target :: str\n+  character(len=:, kind=c_char), pointer :: strp_1\n+  character(len=l, kind=c_char), pointer :: strp_2\n+\n+  str = \"abc\"\n+  nullify(strp_1, strp_2)\n+  strp_1 => str\n+  strp_2 => str\n+  if (len(str) /= 3 .or. str /= \"abc\") stop 1\n+  if (len(strp_1) /= 3 .or. strp_1 /= \"abc\") stop 2\n+  if (len(strp_2) /= 3 .or. strp_2 /= \"abc\") stop 3\n+  call strg_print_0(\"abc\") ! Error (10.0.0) or segmentation fault (9.1.0)\n+  call strg_print_0(str) ! Error (10.0.0) or segmentation fault (9.1.0)\n+  call strg_print_0(strp_1) ! Error (10.0.0) or segmentation fault (9.1.0)\n+  call strg_print_0(strp_2) ! Error (10.0.0) or segmentation fault (9.1.0)\n+  call strg_print_1(strp_1) ! Not yet supported\n+\n+  call strg_print_2(\"abc\", xfail=.true.)\n+  call strg_print_2(str)\n+  call strg_print_2(strp_1)\n+  call strg_print_2(strp_2)\n+\n+  call strg_print_2_c(\"abc\")\n+  call strg_print_2_c(str)\n+  call strg_print_2_c(strp_1)\n+  call strg_print_2_c(strp_2)\n+\n+contains\n+\n+  subroutine strg_print_0(this) bind(c) ! Error (10.0.0 20191106) or warning (9.1.0) issued with bind(c)\n+    character(len=*, kind=c_char), target, intent(in) :: this\n+\n+    if (len (this) /= 3) stop 10\n+    if (this /= \"abc\") stop 11\n+  end subroutine strg_print_0\n+  \n+  subroutine strg_print_1(this) bind(c) ! Not yet supported with bind(c)\n+    character(len=:, kind=c_char), pointer, intent(in) :: this\n+    character(len=:), pointer :: strn\n+\n+    if (.not. associated (this)) stop 20\n+    if (len (this) /= 3) stop 21\n+    if (this /= \"abc\") stop 22\n+     strn => this\n+     if (.not. associated (strn)) stop 23\n+     if(associated(strn))then\n+       if (len (this) /= 3) stop 24\n+       if (this /= \"abc\") stop 25\n+     end if\n+   end subroutine strg_print_1\n+  \n+  subroutine strg_print_2(this, xfail)\n+    use, intrinsic :: iso_c_binding, only: &\n+      c_loc, c_f_pointer\n+    \n+    type(*), target, intent(in) :: this(..)\n+    logical, optional, value :: xfail\n+    character(len=l), pointer :: strn\n+\n+    call c_f_pointer(c_loc(this), strn)\n+    if (.not. associated (strn)) stop 30\n+    if(associated(strn))then\n+      if (len (strn) /= 3) stop 31\n+      if (strn /= \"abc\") then\n+        if (present (xfail)) then\n+          print *, 'INVALID STRING - EXPECTED \"abc\" / PR47225'\n+        else\n+          stop 32\n+        end if\n+      end if\n+    end if\n+  end subroutine strg_print_2\n+\n+  subroutine strg_print_2_c(this) bind(c)\n+    use, intrinsic :: iso_c_binding, only: &\n+      c_loc, c_f_pointer\n+    \n+    type(*), target, intent(in) :: this(..)\n+    character(len=l), pointer :: strn\n+\n+    call c_f_pointer(c_loc(this), strn)\n+    if (.not. associated (strn)) stop 40\n+    if(associated(strn))then\n+      if (len (strn) /= 3) stop 41\n+      if (strn /= \"abc\") stop 42\n+    end if\n+  end subroutine strg_print_2_c\n+\n+end program strp_p"}, {"sha": "06bbd6f261d872f453d280493287f130067b639e", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-1.c", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-1.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,345 @@\n+#include <ISO_Fortran_binding.h>\n+#include <stdbool.h>\n+#include <string.h>\n+\n+struct loc_t {\n+  intptr_t x, y, z;\n+};\n+\n+typedef struct loc_t (*ftn_fn) (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_size_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_size_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_expl_size_f (CFI_cdesc_t *,CFI_cdesc_t *, CFI_cdesc_t *,  int, int);\n+struct loc_t char_expl_size_in_f (CFI_cdesc_t *,CFI_cdesc_t *, CFI_cdesc_t *,  int, int);\n+struct loc_t char_assumed_rank_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_cont_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_cont_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_cont_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_cont_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+\n+static void\n+basic_check(CFI_cdesc_t *x, bool is_cont)\n+{\n+  if (!x->base_addr)\n+    __builtin_abort ();\n+  if (x->elem_len != 3*sizeof(char))\n+    __builtin_abort ();\n+  if (x->version != CFI_VERSION)\n+    __builtin_abort ();\n+  if (x->rank != 1)\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  if (x->type != CFI_type_char)\n+    __builtin_abort ();\n+  if (x->dim[0].lower_bound != 0)\n+    __builtin_abort ();\n+  if (x->dim[0].extent != 3)\n+    __builtin_abort ();\n+  if (CFI_is_contiguous (x) != (x->elem_len == x->dim[0].sm))\n+    __builtin_abort ();\n+  if (is_cont != CFI_is_contiguous (x))\n+    __builtin_abort ();\n+}\n+\n+static void\n+print_str (void *p, size_t len)\n+{\n+  __builtin_printf (\"DEBUG: >\");\n+  for (size_t i = 0; i < len; ++i)\n+    __builtin_printf (\"%c\", ((const char*) p)[i]);\n+  __builtin_printf (\"<\\n\");\n+}\n+\n+static void\n+check_str (CFI_cdesc_t *x, const char *str, const CFI_index_t subscripts[])\n+{\n+  /* Avoid checking for '\\0'.  */\n+  if (strncmp ((const char*) CFI_address (x, subscripts), str, strlen(str)) != 0)\n+    __builtin_abort ();\n+}\n+\n+static void\n+set_str (CFI_cdesc_t *x, const char *str, const CFI_index_t subscripts[])\n+{\n+  char *p = CFI_address (x, subscripts);\n+  size_t len = strlen (str);\n+  if (x->elem_len != len)\n+    __builtin_abort ();\n+  for (size_t i = 0; i < len; ++i)\n+    p[i] = str[i];\n+}\n+\n+static struct loc_t\n+do_call (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t int k, int num, bool intent_in, ftn_fn fn, bool is_cont, bool fort_cont)\n+{\n+  const CFI_index_t zero[1] = { 0 };\n+  const CFI_index_t one[1] = { 1 };\n+  const CFI_index_t two[1] = { 2 };\n+  struct loc_t addr1, addr2;\n+  if (k != 3)\n+    __builtin_abort ();\n+  basic_check (x, is_cont || num == 2);\n+  basic_check (y, is_cont || num == 2);\n+  basic_check (z, is_cont || num == 2);\n+  if (!is_cont && num == 1)\n+    {\n+      check_str (x, \"abc\", zero);\n+      check_str (x, \"ghi\", one);\n+      check_str (x, \"nop\", two);\n+      check_str (y, \"abc\", zero);\n+      check_str (y, \"ghi\", one);\n+      check_str (y, \"nop\", two);\n+      check_str (z, \"abc\", zero);\n+      check_str (z, \"ghi\", one);\n+      check_str (z, \"nop\", two);\n+    }\n+  else if (num == 1)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (num == 2)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else\n+    __builtin_abort ();\n+  addr1.x = (intptr_t) x->base_addr;\n+  addr1.y = (intptr_t) y->base_addr;\n+  addr1.z = (intptr_t) z->base_addr;\n+  addr2 = fn (x, y, z, 3, num);\n+  if (!CFI_is_contiguous (x) && fort_cont)\n+    {\n+      /* Check for callee copy in/copy out.  */\n+      if (addr1.x == addr2.x || addr1.x != (intptr_t) x->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.y == addr2.y || addr1.y != (intptr_t) y->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.z == addr2.z || addr1.z != (intptr_t) z->base_addr)\n+\t__builtin_abort ();\n+    }\n+  else\n+    {\n+      if (addr1.x != addr2.x || addr1.x != (intptr_t) x->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.y != addr2.y || addr1.y != (intptr_t) y->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.z != addr2.z || addr1.z != (intptr_t) z->base_addr)\n+\t__builtin_abort ();\n+    }\n+  // intent_in\n+  if (intent_in && !is_cont && num == 1)\n+    {\n+      check_str (x, \"abc\", zero);\n+      check_str (x, \"ghi\", one);\n+      check_str (x, \"nop\", two);\n+      check_str (y, \"abc\", zero);\n+      check_str (y, \"ghi\", one);\n+      check_str (y, \"nop\", two);\n+      check_str (z, \"abc\", zero);\n+      check_str (z, \"ghi\", one);\n+      check_str (z, \"nop\", two);\n+    }\n+  else if (intent_in && num == 1)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (intent_in && num == 2)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (intent_in)\n+    __builtin_abort ();\n+  if (intent_in)\n+    {\n+      if (is_cont && num == 1)\n+        {\n+\t  /* Copy in - set the value to check that no copy out is done. */\n+\t  memcpy ((char*) x->base_addr, \"123456789\", 9);\n+\t  memcpy ((char*) y->base_addr, \"123456789\", 9);\n+\t  memcpy ((char*) z->base_addr, \"123456789\", 9);\n+        }\n+      return addr1;\n+    }\n+  // !intent_in\n+  if (!is_cont && num == 1)\n+    {\n+      check_str (x, \"ABC\", zero);\n+      check_str (x, \"DEF\", one);\n+      check_str (x, \"GHI\", two);\n+      check_str (y, \"ABC\", zero);\n+      check_str (y, \"DEF\", one);\n+      check_str (y, \"GHI\", two);\n+      check_str (z, \"ABC\", zero);\n+      check_str (z, \"DEF\", one);\n+      check_str (z, \"GHI\", two);\n+    }\n+  else\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"ABCDEFGHI\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"ABCDEFGHI\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"ABCDEFGHI\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  return addr1;\n+}\n+\n+struct loc_t\n+char_assumed_size_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_size_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_size_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\tint k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_size_in_f, true, false);\n+}\n+\n+struct loc_t\n+char_expl_size_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_expl_size_f, true, false);\n+}\n+\n+struct loc_t\n+char_expl_size_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_expl_size_in_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_rank_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_rank_in_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_cont_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_rank_cont_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_cont_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_rank_cont_in_f, true, false);\n+}\n+\n+static void\n+reset_var (CFI_cdesc_t *x, int num)\n+{\n+  const CFI_index_t zero[1] = { 0 };\n+  const CFI_index_t one[1] = { 1 };\n+  const CFI_index_t two[1] = { 2 };\n+\n+  if (num == 1)\n+    {\n+      set_str (x, \"abc\", zero);\n+      set_str (x, \"ghi\", one);\n+      set_str (x, \"nop\", two);\n+    }\n+  else if (num == 2)\n+    {\n+      set_str (x, \"def\", zero);\n+      set_str (x, \"ghi\", one);\n+      set_str (x, \"jlm\", two);\n+    }\n+  else\n+    __builtin_abort ();\n+}\n+\n+static void\n+reset_vars (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z, int num)\n+{\n+  reset_var (x, num);\n+  reset_var (y, num);\n+  reset_var (z, num);\n+}\n+\n+struct loc_t\n+char_assumed_shape_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  /* Make use of having a noncontiguous argument to check that the callee\n+     handles noncontiguous variables.  */\n+  do_call (x, y, z, k, num, false, char_assumed_size_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_size_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_expl_size_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_expl_size_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_assumed_rank_cont_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_rank_cont_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_assumed_shape_cont_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_shape_cont_in_f, false, true);\n+  /* Actual func call. */\n+  reset_vars (x, y, z, num);\n+  return do_call (x, y, z, k, num, false, char_assumed_shape_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_shape_in_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_cont_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_shape_cont_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_cont_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_shape_cont_in_f, true, false);\n+}"}, {"sha": "77dd3a251d27791ab1edc01f79582aa30b8c6988", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-1.f90", "status": "added", "additions": 1574, "deletions": 0, "changes": 1574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-1.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,1574 @@\n+! { dg-do run }\n+! { dg-additional-sources bind-c-contiguous-1.c }\n+! { dg-additional-options \"-fcheck=all\" }\n+! { dg-prune-output \"command-line option '-fcheck=.*' is valid for Fortran but not for C\" }\n+\n+! Fortran demands that with bind(C), the callee ensure that for\n+! * 'contiguous'\n+! * len=* with explicit/assumed-size arrays\n+! noncontiguous actual arguments are handled.\n+! (in without bind(C) in gfortran, caller handles the copy in/out\n+\n+! Additionally, for a bind(C) callee, a Fortran-written caller\n+! has to ensure the same (for contiguous + len=* to explicit-/assumed-size arrays)\n+\n+module m\n+  use iso_c_binding, only: c_intptr_t, c_bool, c_loc, c_int\n+  implicit none (type, external)\n+\n+  type, bind(C) :: loc_t\n+    integer(c_intptr_t) :: x, y, z\n+  end type loc_t\n+\n+interface\n+  type(loc_t) function char_assumed_size_c (xx, yy, zz, n, num) bind(C)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  end function\n+\n+  type(loc_t) function char_assumed_size_in_c (xx, yy, zz, n, num) bind(C)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*), intent(in) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  end function\n+\n+  type(loc_t) function char_expl_size_c (xx, yy, zz, n, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*) :: xx(n), yy(n:n+3), zz(6:6, 3:n, 3:n+3)\n+  end function\n+\n+  type(loc_t) function char_expl_size_in_c (xx, yy, zz, n, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*), intent(in) :: xx(n), yy(n:n+3), zz(6:6, 3:n, 3:n+3)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*) :: xx(..)\n+    character(len=3) :: yy(..)\n+    character(len=k) :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), intent(in) :: xx(..)\n+    character(len=3), intent(in) :: yy(..)\n+    character(len=k), intent(in) :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_cont_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous :: xx(..)\n+    character(len=3), contiguous :: yy(..)\n+    character(len=k), contiguous :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_cont_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous, intent(in) :: xx(..)\n+    character(len=3), contiguous, intent(in) :: yy(..)\n+    character(len=k), contiguous, intent(in) :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*) :: xx(:)\n+    character(len=3) :: yy(5:)\n+    character(len=k) :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), intent(in) :: xx(:)\n+    character(len=3), intent(in) :: yy(5:)\n+    character(len=k), intent(in) :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_cont_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous :: xx(:)\n+    character(len=3), contiguous :: yy(5:)\n+    character(len=k), contiguous :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_cont_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous, intent(in) :: xx(:)\n+    character(len=3), contiguous, intent(in) :: yy(5:)\n+    character(len=k), contiguous, intent(in) :: zz(-k:)\n+  end function\n+end interface\n+\n+contains\n+\n+type(loc_t) function char_assumed_size_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(3) = \"ABC\"\n+  yy(4) = \"DEF\"\n+  yy(5) = \"GHI\"\n+  zz(6,n,3) = \"ABC\"\n+  zz(6,n,4) = \"DEF\"\n+  zz(6,n,5) = \"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_assumed_size_in_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  intent(in) :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }  if (num == 1) then\n+end\n+\n+type(loc_t) function char_expl_size_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*) :: xx(n), yy(n:n+2), zz(6:6, 3:n, 3:n+2)\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (3 /= size(xx,dim=1)) error stop 1\n+  if (3 /= size(yy,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (3 /= size(zz,dim=3)) error stop 1\n+  if (3 /= ubound(xx,dim=1)) error stop 1\n+  if (5 /= ubound(yy,dim=1)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (5 /= ubound(zz,dim=3)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(3) = \"ABC\"\n+  yy(4) = \"DEF\"\n+  yy(5) = \"GHI\"\n+  zz(6,n,3) = \"ABC\"\n+  zz(6,n,4) = \"DEF\"\n+  zz(6,n,5) = \"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_expl_size_in_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*) :: xx(n), yy(n:n+2), zz(6:6, 3:n, 3:n+2)\n+  intent(in) :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (3 /= size(xx,dim=1)) error stop 1\n+  if (3 /= size(yy,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (3 /= size(zz,dim=3)) error stop 1\n+  if (3 /= ubound(xx,dim=1)) error stop 1\n+  if (5 /= ubound(yy,dim=1)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (5 /= ubound(zz,dim=3)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+\n+type(loc_t) function char_assumed_rank_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(..)\n+  character(len=3) :: yy(..)\n+  character(len=k) :: zz(..)\n+  if (3 /= len(xx)) error stop 40\n+  if (3 /= len(yy)) error stop 40\n+  if (3 /= len(zz)) error stop 40\n+  if (3 /= size(xx)) error stop 41\n+  if (3 /= size(yy)) error stop 41\n+  if (3 /= size(zz)) error stop 41\n+  if (1 /= rank(xx)) error stop 49\n+  if (1 /= rank(yy)) error stop 49\n+  if (1 /= rank(zz)) error stop 49\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 49\n+    if (is_contiguous (yy)) error stop 49\n+    if (is_contiguous (zz)) error stop 49\n+  else if (num == 2) then\n+    if (.not. is_contiguous (xx)) error stop 49\n+    if (.not. is_contiguous (yy)) error stop 49\n+    if (.not. is_contiguous (zz)) error stop 49\n+  else\n+    error stop 48\n+  end if\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 42\n+      if (xx(2) /= \"ghi\") error stop 43\n+      if (xx(3) /= \"nop\") error stop 44\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 45\n+      if (xx(2) /= \"ghi\") error stop 46\n+      if (xx(3) /= \"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    xx(1) = \"ABC\"\n+    xx(2) = \"DEF\"\n+    xx(3) = \"GHI\"\n+    res%x = get_loc (xx)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 42\n+      if (yy(2) /= \"ghi\") error stop 43\n+      if (yy(3) /= \"nop\") error stop 44\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 45\n+      if (yy(2) /= \"ghi\") error stop 46\n+      if (yy(3) /= \"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    yy(1) = \"ABC\"\n+    yy(2) = \"DEF\"\n+    yy(3) = \"GHI\"\n+    res%y = get_loc (yy)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 42\n+      if (zz(2) /= \"ghi\") error stop 43\n+      if (zz(3) /= \"nop\") error stop 44\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 45\n+      if (zz(2) /= \"ghi\") error stop 46\n+      if (zz(3) /= \"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    zz(1) = \"ABC\"\n+    zz(2) = \"DEF\"\n+    zz(3) = \"GHI\"\n+    res%z = get_loc (zz)\n+  rank default\n+    error stop 99\n+  end select\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+type(loc_t) function char_assumed_rank_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(..)\n+  character(len=3) :: yy(..)\n+  character(len=k) :: zz(..)\n+  intent(in) :: xx, yy, zz\n+  if (3 /= size(yy)) error stop 50\n+  if (3 /= len(yy)) error stop 51\n+  if (1 /= rank(yy)) error stop 59\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 59\n+    if (is_contiguous (yy)) error stop 59\n+    if (is_contiguous (zz)) error stop 59\n+  else if (num == 2) then\n+    if (.not. is_contiguous (xx)) error stop 59\n+    if (.not. is_contiguous (yy)) error stop 59\n+    if (.not. is_contiguous (zz)) error stop 59\n+  else\n+    error stop 48\n+  end if\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 52\n+      if (xx(2) /= \"ghi\") error stop 53\n+      if (xx(3) /= \"nop\") error stop 54\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 55\n+      if (xx(2) /= \"ghi\") error stop 56\n+      if (xx(3) /= \"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%x = get_loc(xx)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 52\n+      if (yy(2) /= \"ghi\") error stop 53\n+      if (yy(3) /= \"nop\") error stop 54\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 55\n+      if (yy(2) /= \"ghi\") error stop 56\n+      if (yy(3) /= \"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%y = get_loc(yy)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 52\n+      if (zz(2) /= \"ghi\") error stop 53\n+      if (zz(3) /= \"nop\") error stop 54\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 55\n+      if (zz(2) /= \"ghi\") error stop 56\n+      if (zz(3) /= \"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%z = get_loc(zz)\n+  rank default\n+    error stop 99\n+  end select\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+\n+\n+type(loc_t) function char_assumed_rank_cont_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(..)\n+  character(len=3) :: yy(..)\n+  character(len=k) :: zz(..)\n+  contiguous :: xx, yy, zz\n+  if (3 /= len(xx)) error stop 60\n+  if (3 /= len(yy)) error stop 60\n+  if (3 /= len(zz)) error stop 60\n+  if (3 /= size(xx)) error stop 61\n+  if (3 /= size(yy)) error stop 61\n+  if (3 /= size(zz)) error stop 61\n+  if (1 /= rank(xx)) error stop 69\n+  if (1 /= rank(yy)) error stop 69\n+  if (1 /= rank(zz)) error stop 69\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 62\n+      if (xx(2) /= \"ghi\") error stop 63\n+      if (xx(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 65\n+      if (xx(2) /= \"ghi\") error stop 66\n+      if (xx(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    xx(1) = \"ABC\"\n+    xx(2) = \"DEF\"\n+    xx(3) = \"GHI\"\n+    res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 62\n+      if (yy(2) /= \"ghi\") error stop 63\n+      if (yy(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 65\n+      if (yy(2) /= \"ghi\") error stop 66\n+      if (yy(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    yy(1) = \"ABC\"\n+    yy(2) = \"DEF\"\n+    yy(3) = \"GHI\"\n+    res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 62\n+      if (zz(2) /= \"ghi\") error stop 63\n+      if (zz(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 65\n+      if (zz(2) /= \"ghi\") error stop 66\n+      if (zz(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    zz(1) = \"ABC\"\n+    zz(2) = \"DEF\"\n+    zz(3) = \"GHI\"\n+    res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+type(loc_t) function char_assumed_rank_cont_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(..)\n+  character(len=3) :: yy(..)\n+  character(len=k) :: zz(..)\n+  intent(in) :: xx, yy, zz\n+  contiguous :: xx, yy, zz\n+  if (3 /= size(xx)) error stop 30\n+  if (3 /= size(yy)) error stop 30\n+  if (3 /= size(zz)) error stop 30\n+  if (3 /= len(xx)) error stop 31\n+  if (3 /= len(yy)) error stop 31\n+  if (3 /= len(zz)) error stop 31\n+  if (1 /= rank(xx)) error stop 69\n+  if (1 /= rank(yy)) error stop 69\n+  if (1 /= rank(zz)) error stop 69\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 62\n+      if (xx(2) /= \"ghi\") error stop 63\n+      if (xx(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 65\n+      if (xx(2) /= \"ghi\") error stop 66\n+      if (xx(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 62\n+      if (yy(2) /= \"ghi\") error stop 63\n+      if (yy(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 65\n+      if (yy(2) /= \"ghi\") error stop 66\n+      if (yy(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 62\n+      if (zz(2) /= \"ghi\") error stop 63\n+      if (zz(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 65\n+      if (zz(2) /= \"ghi\") error stop 66\n+      if (zz(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+type(loc_t) function char_assumed_shape_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(:)\n+  character(len=3) :: yy(5:)\n+  character(len=k) :: zz(-k:)\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 70\n+  if (3 /= len(yy)) error stop 70\n+  if (3 /= len(zz)) error stop 70\n+  if (3 /= size(xx)) error stop 71\n+  if (3 /= size(yy)) error stop 71\n+  if (3 /= size(zz)) error stop 71\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 79\n+    if (is_contiguous (yy)) error stop 79\n+    if (is_contiguous (zz)) error stop 79\n+    if (xx(1) /= \"abc\") error stop 72\n+    if (xx(2) /= \"ghi\") error stop 73\n+    if (xx(3) /= \"nop\") error stop 74\n+    if (yy(5) /= \"abc\") error stop 72\n+    if (yy(6) /= \"ghi\") error stop 73\n+    if (yy(7) /= \"nop\") error stop 74\n+    if (zz(-k) /= \"abc\") error stop 72\n+    if (zz(-k+1) /= \"ghi\") error stop 73\n+    if (zz(-k+2) /= \"nop\") error stop 74\n+  else if (num == 2) then\n+    if (.not.is_contiguous (xx)) error stop 79\n+    if (.not.is_contiguous (yy)) error stop 79\n+    if (.not.is_contiguous (zz)) error stop 79\n+    if (xx(1) /= \"def\") error stop 72\n+    if (xx(2) /= \"ghi\") error stop 73\n+    if (xx(3) /= \"jlm\") error stop 74\n+    if (yy(5) /= \"def\") error stop 72\n+    if (yy(6) /= \"ghi\") error stop 73\n+    if (yy(7) /= \"jlm\") error stop 74\n+    if (zz(-k) /= \"def\") error stop 72\n+    if (zz(-k+1) /= \"ghi\") error stop 73\n+    if (zz(-k+2) /= \"jlm\") error stop 74\n+  else\n+    error stop 78\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(5) = \"ABC\"\n+  yy(6) = \"DEF\"\n+  yy(7) = \"GHI\"\n+  zz(-k) = \"ABC\"\n+  zz(-k+1) = \"DEF\"\n+  zz(-k+2) = \"GHI\"\n+  res%x = get_loc(xx)\n+  res%y = get_loc(yy)\n+  res%z = get_loc(zz)\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+type(loc_t) function char_assumed_shape_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(:)\n+  character(len=3) :: yy(5:)\n+  character(len=k) :: zz(-k:)\n+  intent(in) :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= size(xx)) error stop 80\n+  if (3 /= size(yy)) error stop 80\n+  if (3 /= size(zz)) error stop 80\n+  if (3 /= len(xx)) error stop 81\n+  if (3 /= len(yy)) error stop 81\n+  if (3 /= len(zz)) error stop 81\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 89\n+    if (is_contiguous (yy)) error stop 89\n+    if (is_contiguous (zz)) error stop 89\n+    if (xx(1) /= \"abc\") error stop 82\n+    if (xx(2) /= \"ghi\") error stop 83\n+    if (xx(3) /= \"nop\") error stop 84\n+    if (yy(5) /= \"abc\") error stop 82\n+    if (yy(6) /= \"ghi\") error stop 83\n+    if (yy(7) /= \"nop\") error stop 84\n+    if (zz(-k) /= \"abc\") error stop 82\n+    if (zz(-k+1) /= \"ghi\") error stop 83\n+    if (zz(-k+2) /= \"nop\") error stop 84\n+  else if (num == 2) then\n+    if (.not.is_contiguous (xx)) error stop 89\n+    if (.not.is_contiguous (yy)) error stop 89\n+    if (.not.is_contiguous (zz)) error stop 89\n+    if (xx(1) /= \"def\") error stop 85\n+    if (xx(2) /= \"ghi\") error stop 86\n+    if (xx(3) /= \"jlm\") error stop 87\n+    if (yy(5) /= \"def\") error stop 85\n+    if (yy(6) /= \"ghi\") error stop 86\n+    if (yy(7) /= \"jlm\") error stop 87\n+    if (zz(-k) /= \"def\") error stop 85\n+    if (zz(-k+1) /= \"ghi\") error stop 86\n+    if (zz(-k+2) /= \"jlm\") error stop 87\n+  else\n+    error stop 88\n+  endif\n+  res%x = get_loc(xx)\n+  res%y = get_loc(yy)\n+  res%z = get_loc(zz)\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+\n+\n+type(loc_t) function char_assumed_shape_cont_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(:)\n+  character(len=3) :: yy(5:)\n+  character(len=k) :: zz(-k:)\n+  contiguous :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 90\n+  if (3 /= len(yy)) error stop 90\n+  if (3 /= len(zz)) error stop 90\n+  if (3 /= size(xx)) error stop 91\n+  if (3 /= size(yy)) error stop 91\n+  if (3 /= size(zz)) error stop 91\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 92\n+    if (xx(2) /= \"ghi\") error stop 93\n+    if (xx(3) /= \"nop\") error stop 94\n+    if (yy(5) /= \"abc\") error stop 92\n+    if (yy(6) /= \"ghi\") error stop 93\n+    if (yy(7) /= \"nop\") error stop 94\n+    if (zz(-k) /= \"abc\") error stop 92\n+    if (zz(-k+1) /= \"ghi\") error stop 93\n+    if (zz(-k+2) /= \"nop\") error stop 94\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 92\n+    if (xx(2) /= \"ghi\") error stop 93\n+    if (xx(3) /= \"jlm\") error stop 94\n+    if (yy(5) /= \"def\") error stop 92\n+    if (yy(6) /= \"ghi\") error stop 93\n+    if (yy(7) /= \"jlm\") error stop 94\n+    if (zz(-k) /= \"def\") error stop 92\n+    if (zz(-k+1) /= \"ghi\") error stop 93\n+    if (zz(-k+2) /= \"jlm\") error stop 94\n+  else\n+    error stop 98\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(5) = \"ABC\"\n+  yy(6) = \"DEF\"\n+  yy(7) = \"GHI\"\n+  zz(-k) = \"ABC\"\n+  zz(-k+1) = \"DEF\"\n+  zz(-k+2) = \"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_assumed_shape_cont_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*) :: xx(:)\n+  character(len=3) :: yy(5:)\n+  character(len=k) :: zz(-k:)\n+  intent(in) :: xx, yy, zz\n+  contiguous :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= size(xx)) error stop 100\n+  if (3 /= size(yy)) error stop 100\n+  if (3 /= size(zz)) error stop 100\n+  if (3 /= len(xx)) error stop 101\n+  if (3 /= len(yy)) error stop 101\n+  if (3 /= len(zz)) error stop 101\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 102\n+    if (xx(2) /= \"ghi\") error stop 103\n+    if (xx(3) /= \"nop\") error stop 104\n+    if (yy(5) /= \"abc\") error stop 102\n+    if (yy(6) /= \"ghi\") error stop 103\n+    if (yy(7) /= \"nop\") error stop 104\n+    if (zz(-k) /= \"abc\") error stop 102\n+    if (zz(-k+1) /= \"ghi\") error stop 103\n+    if (zz(-k+2) /= \"nop\") error stop 104\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 105\n+    if (xx(2) /= \"ghi\") error stop 106\n+    if (xx(3) /= \"jlm\") error stop 107\n+    if (yy(5) /= \"def\") error stop 105\n+    if (yy(6) /= \"ghi\") error stop 106\n+    if (yy(7) /= \"jlm\") error stop 107\n+    if (zz(-k) /= \"def\") error stop 105\n+    if (zz(-k+1) /= \"ghi\") error stop 106\n+    if (zz(-k+2) /= \"jlm\") error stop 107\n+  else\n+    error stop 108\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+end module\n+\n+\n+use m\n+implicit none (type, external)\n+character(len=3) :: a(6), a2(6), a3(6), a_init(6)\n+type(loc_t) :: loc3\n+\n+a_init = ['abc', 'def', 'ghi', 'jlm', 'nop', 'qrs']\n+\n+! -- Fortran: assumed size\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_f (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_f (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: explicit shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_f (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_f (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed rank\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed rank contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed shape contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+\n+! --- character - call C directly --\n+\n+! -- C: assumed size\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_c (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_c (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: explicit shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_c (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_c (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed rank\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed rank contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed shape contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+end\n+\n+\n+! { dg-output \"At line 928 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 928 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 928 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 946 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 946 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 946 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 965 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 965 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 965 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 983 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 983 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 983 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1039 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1039 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1039 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1057 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1057 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1057 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1113 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1113 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1113 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1131 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1131 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1131 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1171 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1171 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1171 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1190 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1190 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1190 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1208 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1208 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1208 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1282 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1282 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1282 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1338 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1338 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1338 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1356 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1356 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1356 of file .*bind-c-contiguous-1.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\""}, {"sha": "5b546800e7ff3bd6b19fecee8ff82ae6a7b6ff31", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-2.f90", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-2.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,82 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+integer function f(xx) bind(c) result(ii)\n+  implicit none\n+  integer, contiguous :: xx(..)\n+  ii = rank(xx)\n+end\n+\n+integer function h(yy) bind(c) result(jj)\n+  implicit none\n+  character(len=*), contiguous :: yy(:)\n+  jj = rank(yy)\n+end\n+\n+integer function g(zz) bind(c) result(kk)\n+  implicit none\n+  character(len=*) :: zz(*)\n+  kk = rank(zz)\n+end\n+\n+\n+\n+integer function f2(aa) bind(c) result(ii)\n+  implicit none\n+  integer, contiguous :: aa(..)\n+  intent(in) :: aa\n+  ii = rank(aa)\n+end\n+\n+integer function h2(bb) bind(c) result(jj)\n+  implicit none\n+  character(len=*), contiguous :: bb(:)\n+  intent(in) :: bb\n+  jj = rank(bb)\n+end\n+\n+integer function g2(cc) bind(c) result(kk)\n+  implicit none\n+  character(len=*) :: cc(*)\n+  intent(in) :: cc\n+  kk = rank(cc)\n+end\n+\n+!\n+! Copy-in/out variable:\n+!\n+! { dg-final { scan-tree-dump-times \"xx->data =\\[^;\\]+ __builtin_malloc \\\\(_xx->elem_len \\\\* size.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yy->data =\\[^;\\]+ __builtin_malloc \\\\(_yy->elem_len \\\\* size.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"zz =\\[^;\\]+ __builtin_malloc \\\\(_zz->elem_len \\\\* size.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"aa->data =\\[^;\\]+ __builtin_malloc \\\\(_aa->elem_len \\\\* size.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"bb->data =\\[^;\\]+ __builtin_malloc \\\\(_bb->elem_len \\\\* size.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"cc =\\[^;\\]+ __builtin_malloc \\\\(_cc->elem_len \\\\* size.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(\\[^;\\]+ xx->data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(\\[^;\\]+ yy->data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(zz\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(\\[^;\\]+ aa->data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(\\[^;\\]+ bb->data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(cc\\\\);\" 1 \"original\" } }\n+\n+! Copy in + out\n+\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(\\\\(void \\\\*\\\\) xx->data \\\\+ xx->dtype.elem_len \\\\* arrayidx.\\[0-9\\]+, _xx->base_addr \\\\+ shift.\\[0-9\\]+, xx->dtype.elem_len\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xx->data = \\\\(void \\\\* restrict\\\\) _xx->base_addr;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(\\\\(void \\\\*\\\\) xx->data \\\\+ xx->dtype.elem_len \\\\* arrayidx.\\[0-9\\]+, _xx->base_addr \\\\+ shift.\\[0-9\\]+, xx->dtype.elem_len\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(\\\\(void \\\\*\\\\) yy->data \\\\+ yy->dtype.elem_len \\\\* arrayidx.\\[0-9\\]+, _yy->base_addr \\\\+ shift.\\[0-9\\]+, yy->dtype.elem_len\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yy->data = \\\\(void \\\\* restrict\\\\) _yy->base_addr;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(_yy->base_addr \\\\+ shift.\\[0-9\\]+, \\\\(void \\\\*\\\\) yy->data \\\\+ yy->dtype.elem_len \\\\* arrayidx.\\[0-9\\]+, yy->dtype.elem_len\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"zz = \\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:zz.\\[0-9\\]+\\\\\\] \\\\* restrict\\\\) _zz->base_addr;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(\\\\(void \\\\*\\\\) zz \\\\+ _zz->elem_len \\\\* arrayidx.\\[0-9\\]+, _zz->base_addr \\\\+ shift.\\[0-9\\]+, _zz->elem_len\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(_zz->base_addr \\\\+ shift.\\[0-9\\]+, \\\\(void \\\\*\\\\) zz \\\\+ _zz->elem_len \\\\* arrayidx.\\[0-9\\]+, _zz->elem_len\\\\);\" 1 \"original\" } }\n+\n+! Copy in only\n+\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(\\\\(void \\\\*\\\\) aa->data \\\\+ aa->dtype.elem_len \\\\* arrayidx.\\[0-9\\]+, _aa->base_addr \\\\+ shift.\\[0-9\\]+, aa->dtype.elem_len\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"aa->data = \\\\(void \\\\* restrict\\\\) _aa->base_addr;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(\\\\(void \\\\*\\\\) bb->data \\\\+ bb->dtype.elem_len \\\\* arrayidx.\\[0-9\\]+, _bb->base_addr \\\\+ shift.\\[0-9\\]+, bb->dtype.elem_len\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"bb->data = \\\\(void \\\\* restrict\\\\) _bb->base_addr;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"cc = \\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:cc.\\[0-9\\]+\\\\\\] \\\\* restrict\\\\) _cc->base_addr;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy \\\\(\\\\(void \\\\*\\\\) cc \\\\+ _cc->elem_len \\\\* arrayidx.\\[0-9\\]+, _cc->base_addr \\\\+ shift.\\[0-9\\]+, _cc->elem_len\\\\);\" 1 \"original\" } }"}, {"sha": "506f7532b3d66243345bd395a903cf7325a462ff", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-3.c", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-3.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,180 @@\n+#include <ISO_Fortran_binding.h>\n+\n+intptr_t assumed_rank_alloc_f (CFI_cdesc_t *);\n+intptr_t assumed_rank_pointer_f (CFI_cdesc_t *);\n+intptr_t assumed_rank_f (CFI_cdesc_t *);\n+intptr_t assumed_rank_cont_f (CFI_cdesc_t *);\n+intptr_t assumed_shape_f (CFI_cdesc_t *);\n+intptr_t assumed_shape_cont_f (CFI_cdesc_t *);\n+intptr_t deferred_shape_alloc_f (CFI_cdesc_t *);\n+intptr_t deferred_shape_pointer_f (CFI_cdesc_t *);\n+\n+\n+static void\n+basic_check(CFI_cdesc_t *x)\n+{\n+  if (!x->base_addr)\n+    __builtin_abort ();\n+  if (x->elem_len != sizeof(int32_t))\n+    __builtin_abort ();\n+  if (x->version != CFI_VERSION)\n+    __builtin_abort ();\n+  if (x->rank != 4)\n+    __builtin_abort ();\n+  if (x->type != CFI_type_int32_t)\n+    __builtin_abort ();\n+  if (x->attribute == CFI_attribute_other)\n+    {\n+      if (x->dim[0].lower_bound != 0)\n+\t__builtin_abort ();\n+      if (x->dim[1].lower_bound != 0)\n+\t__builtin_abort ();\n+      if (x->dim[2].lower_bound != 0)\n+\t__builtin_abort ();\n+      if (x->dim[3].lower_bound != 0)\n+\t__builtin_abort ();\n+    }\n+}\n+\n+intptr_t\n+assumed_rank_alloc_c (CFI_cdesc_t *x)\n+{\n+  basic_check (x);\n+  if (!CFI_is_contiguous (x))\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_allocatable)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2 = assumed_rank_alloc_f (x);\n+  if (addr != addr2 || addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr;\n+}\n+\n+intptr_t\n+assumed_rank_pointer_c (CFI_cdesc_t *x)\n+{\n+  basic_check (x);\n+  if (x->attribute != CFI_attribute_pointer)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2 = assumed_rank_pointer_f (x);\n+  if (addr != addr2 || addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr;\n+}\n+\n+\n+intptr_t\n+assumed_rank_c (CFI_cdesc_t *x)\n+{\n+  basic_check (x);\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2 = assumed_rank_f (x);\n+  if (addr != addr2 || addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr;\n+}\n+\n+intptr_t\n+assumed_rank_cont_c (CFI_cdesc_t *x)\n+{\n+  basic_check (x);\n+  if (!CFI_is_contiguous (x))\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2 = assumed_rank_cont_f (x);\n+  if (addr != addr2 || addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr;\n+}\n+\n+intptr_t\n+assumed_shape_c (CFI_cdesc_t *x, int num)\n+{\n+  basic_check (x);\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2;\n+  if (num == 1 || num == 2 || num == 3)\n+    {\n+      if (!CFI_is_contiguous (x))\n+\t__builtin_abort ();\n+    }\n+  else\n+    {\n+      if (CFI_is_contiguous (x))\n+\t__builtin_abort ();\n+    }\n+\n+  if (num == 1 || num == 4)\n+    addr2 = assumed_shape_f (x);\n+  else if (num == 2 || num == 5)\n+    addr2 = assumed_shape_cont_f (x);\n+  else if (num == 3 || num == 6)\n+    addr2 = assumed_rank_cont_f (x);\n+  else\n+    __builtin_abort ();\n+\n+  if (num == 1 || num == 2 || num == 3)\n+    {\n+      if (addr != addr2)\n+\t__builtin_abort ();\n+    }\n+  else\n+    {\n+      if (CFI_is_contiguous (x))\n+\t__builtin_abort ();\n+    }\n+  if (addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr2;\n+}\n+\n+intptr_t\n+assumed_shape_cont_c (CFI_cdesc_t *x)\n+{\n+  basic_check (x);\n+  if (!CFI_is_contiguous (x))\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2 = assumed_shape_cont_f (x);\n+  if (addr != addr2 || addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr;\n+}\n+\n+intptr_t\n+deferred_shape_alloc_c (CFI_cdesc_t *x)\n+{\n+  basic_check (x);\n+  if (!CFI_is_contiguous (x))\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_allocatable)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2 = deferred_shape_alloc_f (x);\n+  if (addr != addr2 || addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr;\n+}\n+\n+intptr_t\n+deferred_shape_pointer_c (CFI_cdesc_t *x)\n+{\n+  basic_check (x);\n+  if (x->attribute != CFI_attribute_pointer)\n+    __builtin_abort ();\n+  intptr_t addr = (intptr_t) x->base_addr;\n+  intptr_t addr2 = deferred_shape_pointer_f (x);\n+  if (addr != addr2 || addr != (intptr_t) x->base_addr)\n+    __builtin_abort ();\n+  return addr;\n+}"}, {"sha": "6e479ffc75aa8fee1a6f3c85f334cbe137d3b94c", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-3.f90", "status": "added", "additions": 656, "deletions": 0, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-3.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,656 @@\n+! { dg-do run }\n+! { dg-additional-sources bind-c-contiguous-3.c }\n+\n+! Test that multi-dim contiguous is properly handled.\n+\n+module m\n+  use iso_c_binding, only: c_intptr_t, c_int\n+  implicit none (type, external)\n+\n+interface\n+  integer(c_intptr_t) function assumed_rank_alloc_c (xx) bind(c)\n+    import :: c_intptr_t\n+    integer, allocatable :: xx(..)\n+  end function\n+  integer(c_intptr_t) function assumed_rank_pointer_c (xx) bind(c)\n+    import :: c_intptr_t\n+    integer, pointer :: xx(..)\n+  end function\n+  integer(c_intptr_t) function assumed_rank_c (xx) bind(c)\n+    import :: c_intptr_t\n+    integer :: xx(..)\n+  end function\n+  integer(c_intptr_t) function assumed_rank_cont_c (xx) bind(c)\n+    import :: c_intptr_t\n+    integer, contiguous :: xx(..)\n+  end function\n+  integer(c_intptr_t) function assumed_shape_c (xx, num) bind(c)\n+    import :: c_intptr_t, c_int\n+    integer :: xx(:,:,:,:)\n+    integer(c_int), value :: num\n+  end function\n+  integer(c_intptr_t) function assumed_shape_cont_c (xx) bind(c)\n+    import :: c_intptr_t\n+    integer, contiguous :: xx(:,:,:,:)\n+  end function\n+  integer(c_intptr_t) function deferred_shape_alloc_c (xx) bind(c)\n+    import :: c_intptr_t\n+    integer, allocatable :: xx(:,:,:,:)\n+  end function\n+  integer(c_intptr_t) function deferred_shape_pointer_c (xx) bind(c)\n+    import :: c_intptr_t\n+    integer, pointer :: xx(:,:,:,:)\n+  end function\n+\n+end interface\n+\n+contains\n+\n+integer function get_n (idx, lbound, extent) result(res)\n+  integer, contiguous :: idx(:), lbound(:), extent(:)\n+  integer :: i\n+  if (size(idx) /= size(lbound) .or. size(idx) /= size(extent)) &\n+    error stop 20\n+  res = idx(1) - lbound(1) + 1\n+  do i = 2, size(idx)\n+    res = res + product(extent(:i-1)) * (idx(i)-lbound(i))\n+  end do\n+end\n+\n+integer(c_intptr_t) function assumed_rank_alloc_f (xx) bind(c) result(res)\n+  integer, allocatable :: xx(..)\n+  integer :: i, j, k, l, lb(4)\n+  select rank (xx)\n+  rank (4)\n+    do l = lbound(xx, dim=4), ubound(xx, dim=4)\n+      do k = lbound(xx, dim=3), ubound(xx, dim=3)\n+        do j = lbound(xx, dim=2), ubound(xx, dim=2)\n+          do i = lbound(xx, dim=1), ubound(xx, dim=1)\n+            xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+          end do\n+        end do\n+      end do\n+    end do\n+    lb = lbound(xx)\n+    res = %loc(xx(lb(1),lb(2),lb(3),lb(4)))  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+integer(c_intptr_t) function assumed_rank_pointer_f (xx) bind(c) result(res)\n+  integer, pointer :: xx(..)\n+  integer :: i, j, k, l, lb(4)\n+  select rank (xx)\n+  rank (4)\n+    do l = lbound(xx, dim=4), ubound(xx, dim=4)\n+      do k = lbound(xx, dim=3), ubound(xx, dim=3)\n+        do j = lbound(xx, dim=2), ubound(xx, dim=2)\n+          do i = lbound(xx, dim=1), ubound(xx, dim=1)\n+            xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+          end do\n+        end do\n+      end do\n+    end do\n+    lb = lbound(xx)\n+    res = %loc(xx(lb(1),lb(2),lb(3),lb(4)))  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+\n+integer(c_intptr_t) function assumed_rank_f (xx) bind(c) result(res)\n+  integer :: xx(..)\n+  integer :: i, j, k, l\n+  select rank (xx)\n+  rank (4)\n+    do l = 1, size(xx, dim=4)\n+      do k = 1, size(xx, dim=3)\n+        do j = 1, size(xx, dim=2)\n+          do i = 1, size(xx, dim=1)\n+            xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+          end do\n+        end do\n+      end do\n+    end do\n+    res = %loc(xx(1,1,1,1))  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+integer(c_intptr_t) function assumed_rank_cont_f (xx) bind(c) result(res)\n+  integer, contiguous :: xx(..)\n+  integer :: i, j, k, l\n+  select rank (xx)\n+  rank (4)\n+    do l = 1, size(xx, dim=4)\n+      do k = 1, size(xx, dim=3)\n+        do j = 1, size(xx, dim=2)\n+          do i = 1, size(xx, dim=1)\n+            xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+          end do\n+        end do\n+      end do\n+    end do\n+    res = %loc(xx(1,1,1,1))  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+integer(c_intptr_t) function assumed_shape_f (xx) bind(c) result(res)\n+  integer :: xx(:,:,:,:)\n+  integer :: i, j, k, l\n+  do l = 1, ubound(xx, dim=4)\n+    do k = 1, ubound(xx, dim=3)\n+      do j = 1, ubound(xx, dim=2)\n+        do i = 1, ubound(xx, dim=1)\n+          xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+        end do\n+      end do\n+    end do\n+  end do\n+  res = %loc(xx(1,1,1,1))  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+integer(c_intptr_t) function assumed_shape2_f (xx, n) bind(c) result(res)\n+  integer, value :: n\n+  integer :: xx(-n:, -n:, -n:, -n:)\n+  integer :: i, j, k, l\n+  do l = -n, ubound(xx, dim=4)\n+    do k = -n, ubound(xx, dim=3)\n+      do j = -n, ubound(xx, dim=2)\n+        do i = -n, ubound(xx, dim=1)\n+          xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+        end do\n+      end do\n+    end do\n+  end do\n+  res = %loc(xx(-n,-n,-n,-n))  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+integer(c_intptr_t) function assumed_shape_cont_f (xx) bind(c) result(res)\n+  integer, contiguous :: xx(:,:,:,:)\n+  integer :: i, j, k, l\n+  do l = 1, ubound(xx, dim=4)\n+    do k = 1, ubound(xx, dim=3)\n+      do j = 1, ubound(xx, dim=2)\n+        do i = 1, ubound(xx, dim=1)\n+          xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+        end do\n+      end do\n+    end do\n+  end do\n+  res = %loc(xx(1,1,1,1))  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+integer(c_intptr_t) function assumed_shape2_cont_f (xx, n) bind(c) result(res)\n+  integer, value :: n\n+  integer, contiguous :: xx(-n:, -n:, -n:, -n:)\n+  integer :: i, j, k, l\n+  do l = -n, ubound(xx, dim=4)\n+    do k = -n, ubound(xx, dim=3)\n+      do j = -n, ubound(xx, dim=2)\n+        do i = -n, ubound(xx, dim=1)\n+          xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+        end do\n+      end do\n+    end do\n+  end do\n+  res = %loc(xx(-n,-n,-n,-n))  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+integer(c_intptr_t) function deferred_shape_alloc_f (xx) bind(c) result(res)\n+  integer, allocatable :: xx(:,:,:,:)\n+  integer :: i, j, k, l, lb(4)\n+  do l = lbound(xx, dim=4), ubound(xx, dim=4)\n+    do k = lbound(xx, dim=3), ubound(xx, dim=3)\n+      do j = lbound(xx, dim=2), ubound(xx, dim=2)\n+        do i = lbound(xx, dim=1), ubound(xx, dim=1)\n+          xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+        end do\n+      end do\n+    end do\n+  end do\n+  lb = lbound(xx)\n+  res = %loc(xx(lb(1),lb(2),lb(3),lb(4)))  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+integer(c_intptr_t) function deferred_shape_pointer_f (xx) bind(c) result(res)\n+  integer, pointer :: xx(:,:,:,:)\n+  integer :: i, j, k, l, lb(4)\n+  do l = lbound(xx, dim=4), ubound(xx, dim=4)\n+    do k = lbound(xx, dim=3), ubound(xx, dim=3)\n+      do j = lbound(xx, dim=2), ubound(xx, dim=2)\n+        do i = lbound(xx, dim=1), ubound(xx, dim=1)\n+          xx(i,j,k,l) = -get_n([i,j,k,l], lbound(xx), shape(xx))\n+        end do\n+      end do\n+    end do\n+  end do\n+  lb = lbound(xx)\n+  res = %loc(xx(lb(1),lb(2),lb(3),lb(4)))  ! { dg-warning \"Legacy Extension\" }\n+end\n+end module\n+\n+\n+use m\n+implicit none (type, external)\n+integer, dimension(10,10,10,10) :: var_init, var\n+target :: var\n+integer, allocatable, dimension(:,:,:,:) :: a1, a2\n+integer, pointer, dimension(:,:,:,:) :: p1, p2\n+integer(c_intptr_t) :: loc4\n+integer :: i, k, j, l, cnt\n+\n+do l = 1, ubound(var_init, dim=4)\n+  do k = 1, ubound(var_init, dim=3)\n+    do j = 1, ubound(var_init, dim=2)\n+      do i = 1, ubound(var_init, dim=1)\n+        var_init(i,j,k,l) = get_n([i,j,k,l], lbound(var_init), shape(var_init))\n+      end do\n+    end do\n+  end do\n+end do\n+\n+! Fortran calls\n+\n+! ----- allocatable + pointer dummies -------\n+\n+allocate(a1, mold=var_init)\n+allocate(p1, mold=var_init)\n+allocate(a2(-5:4,-10:-1,1:10,11:20))\n+allocate(p2(-5:4,-10:-1,1:10,11:20))\n+\n+a1(:,:,:,:) = var_init\n+loc4 = assumed_rank_alloc_f (a1)\n+cnt = size(a1) - check_unmod (a1)\n+call check  (a1, loc4, .true., cnt)\n+call check2 (a1)\n+\n+a2(:,:,:,:) = var_init\n+loc4 = assumed_rank_alloc_f (a2)\n+cnt = size(a2) - check_unmod (a2)\n+call check  (a2, loc4, .true., cnt)\n+call check2 (a2)\n+\n+a1(:,:,:,:) = var_init\n+loc4 = deferred_shape_alloc_f (a1)\n+cnt = size(a1) - check_unmod (a1)\n+call check  (a1, loc4, .true., cnt)\n+call check2 (a1)\n+\n+a2(:,:,:,:) = var_init\n+loc4 = deferred_shape_alloc_f (a2)\n+cnt = size(a2) - check_unmod (a2)\n+call check  (a2, loc4, .true., cnt)\n+call check2 (a2)\n+\n+deallocate(a1, a2)\n+\n+p1(:,:,:,:) = var_init\n+loc4 = assumed_rank_pointer_f (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .true., cnt)\n+call check2 (p1)\n+\n+p2(:,:,:,:) = var_init\n+loc4 = assumed_rank_pointer_f (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .true., cnt)\n+call check2 (p2)\n+\n+p1(:,:,:,:) = var_init\n+loc4 = deferred_shape_pointer_f (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .true., cnt)\n+call check2 (p1)\n+\n+p2(:,:,:,:) = var_init\n+loc4 = deferred_shape_pointer_f (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .true., cnt)\n+call check2 (p2)\n+\n+deallocate(p1, p2)\n+\n+! --- p => var(4:7,::3,::2,:)\n+var = var_init\n+p1 => var(4:7,::3,::2,:)\n+loc4 = assumed_rank_pointer_f (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .false., cnt)\n+call check2 (p1)\n+\n+var = var_init\n+p2(-5:,-10:,1:,11:) => var(4:7,::3,::2,:)\n+loc4 = assumed_rank_pointer_f (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .false., cnt)\n+call check2 (p2)\n+\n+var = var_init\n+p1 => var(4:7,::3,::2,:)\n+loc4 = deferred_shape_pointer_f (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .false., cnt)\n+call check2 (p1)\n+\n+var = var_init\n+p2(-5:,-10:,1:,11:) => var(4:7,::3,::2,:)\n+loc4 = deferred_shape_pointer_f (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .false., cnt)\n+call check2 (p2)\n+\n+\n+\n+! ----- nonallocatable + nonpointer dummies -------\n+\n+var = var_init\n+loc4 = assumed_rank_f (var)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .false., cnt)\n+call check2 (var)\n+\n+var = var_init\n+loc4 = assumed_shape_f (var)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .false., cnt)\n+call check2 (var)\n+\n+var = var_init\n+loc4 = assumed_shape2_f (var, 99)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .false., cnt)\n+call check2 (var)\n+\n+var = var_init\n+loc4 = assumed_rank_cont_f (var)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .true., cnt)\n+call check2 (var)\n+\n+var = var_init\n+loc4 = assumed_shape_cont_f (var)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .true., cnt)\n+call check2 (var)\n+\n+var = var_init\n+loc4 = assumed_shape2_cont_f (var, 99)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .true., cnt)\n+call check2 (var)\n+\n+! --- var(4:7,::3,::2,:)\n+\n+var = var_init\n+loc4 = assumed_rank_f (var(4:7,::3,::2,:))\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .false., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+loc4 = assumed_shape_f (var(4:7,::3,::2,:))\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .false., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+loc4 = assumed_shape2_f (var(4:7,::3,::2,:), 99)\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .false., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+loc4 = assumed_rank_cont_f (var(4:7,::3,::2,:))\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .true., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+loc4 = assumed_shape_cont_f (var(4:7,::3,::2,:))\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .true., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+loc4 = assumed_shape2_cont_f (var(4:7,::3,::2,:), 99)\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .true., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+\n+! C calls\n+\n+! ----- allocatable + pointer dummies -------\n+\n+allocate(a1, mold=var_init)\n+allocate(p1, mold=var_init)\n+allocate(a2(-5:4,-10:-1,1:10,11:20))\n+allocate(p2(-5:4,-10:-1,1:10,11:20))\n+\n+a1(:,:,:,:) = var_init\n+loc4 = assumed_rank_alloc_c (a1)\n+cnt = size(a1) - check_unmod (a1)\n+call check  (a1, loc4, .true., cnt)\n+call check2 (a1)\n+\n+a2(:,:,:,:) = var_init\n+loc4 = assumed_rank_alloc_c (a2)\n+cnt = size(a2) - check_unmod (a2)\n+call check  (a2, loc4, .true., cnt)\n+call check2 (a2)\n+\n+a1(:,:,:,:) = var_init\n+loc4 = deferred_shape_alloc_c (a1)\n+cnt = size(a1) - check_unmod (a1)\n+call check  (a1, loc4, .true., cnt)\n+call check2 (a1)\n+\n+a2(:,:,:,:) = var_init\n+loc4 = deferred_shape_alloc_c (a2)\n+cnt = size(a2) - check_unmod (a2)\n+call check  (a2, loc4, .true., cnt)\n+call check2 (a2)\n+\n+deallocate(a1, a2)\n+\n+p1(:,:,:,:) = var_init\n+loc4 = assumed_rank_pointer_c (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .true., cnt)\n+call check2 (p1)\n+\n+p2(:,:,:,:) = var_init\n+loc4 = assumed_rank_pointer_c (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .true., cnt)\n+call check2 (p2)\n+\n+p1(:,:,:,:) = var_init\n+loc4 = deferred_shape_pointer_c (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .true., cnt)\n+call check2 (p1)\n+\n+p2(:,:,:,:) = var_init\n+loc4 = deferred_shape_pointer_c (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .true., cnt)\n+call check2 (p2)\n+\n+deallocate(p1, p2)\n+\n+! --- p => var(4:7,::3,::2,:)\n+var = var_init\n+p1 => var(4:7,::3,::2,:)\n+loc4 = assumed_rank_pointer_c (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .false., cnt)\n+call check2 (p1)\n+\n+var = var_init\n+p2(-5:,-10:,1:,11:) => var(4:7,::3,::2,:)\n+loc4 = assumed_rank_pointer_c (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .false., cnt)\n+call check2 (p2)\n+\n+var = var_init\n+p1 => var(4:7,::3,::2,:)\n+loc4 = deferred_shape_pointer_c (p1)\n+cnt = size(p1) - check_unmod (p1)\n+call check  (p1, loc4, .false., cnt)\n+call check2 (p1)\n+\n+var = var_init\n+p2(-5:,-10:,1:,11:) => var(4:7,::3,::2,:)\n+loc4 = deferred_shape_pointer_c (p2)\n+cnt = size(p2) - check_unmod (p2)\n+call check  (p2, loc4, .false., cnt)\n+call check2 (p2)\n+\n+\n+! ----- nonallocatable + nonpointer dummies -------\n+\n+var = var_init\n+loc4 = assumed_rank_c (var)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .false., cnt)\n+call check2 (var)\n+\n+var = var_init\n+! calls assumed_shape_f\n+loc4 = assumed_shape_c (var, num=1)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .false., cnt)\n+call check2 (var)\n+\n+var = var_init\n+! calls assumed_shape_cont_f\n+loc4 = assumed_shape_c (var, num=2)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .true., cnt)\n+call check2 (var)\n+\n+var = var_init\n+! calls assumed_rank_cont_f\n+loc4 = assumed_shape_c (var, num=3)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .true., cnt)\n+call check2 (var)\n+\n+var = var_init\n+loc4 = assumed_rank_cont_c (var)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .true., cnt)\n+call check2 (var)\n+\n+var = var_init\n+loc4 = assumed_shape_cont_c (var)\n+cnt = size(var) - check_unmod (var)\n+call check  (var, loc4, .true., cnt)\n+call check2 (var)\n+\n+! --- var(4:7,::3,::2,:)\n+\n+var = var_init\n+loc4 = assumed_rank_c (var(4:7,::3,::2,:))\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .false., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+! calls assumed_shape_f\n+loc4 = assumed_shape_c (var(4:7,::3,::2,:), num=4)\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .false., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+! calls assumed_shape_cont_f\n+loc4 = assumed_shape_c (var(4:7,::3,::2,:), num=5)\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .true., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+! calls assumed_rank_cont_f\n+loc4 = assumed_shape_c (var(4:7,::3,::2,:), num=6)\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .true., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+loc4 = assumed_rank_cont_c (var(4:7,::3,::2,:))\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .true., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+var = var_init\n+loc4 = assumed_shape_cont_c (var(4:7,::3,::2,:))\n+cnt = size(var) - check_unmod (var)\n+call check  (var(4:7,::3,::2,:), loc4, .true., cnt)\n+call check2 (var(4:7,::3,::2,:))\n+\n+\n+contains\n+\n+! Ensure that the rest is still okay\n+! Returns the number of elements >= 0\n+integer function check_unmod (x) result(cnt)\n+  integer, contiguous, intent(in) ::  x(:,:,:,:)\n+  integer :: i, k, j, l\n+  cnt = 0\n+  do l = 1, ubound(x, dim=4)\n+    do k = 1, ubound(x, dim=3)\n+      do j = 1, ubound(x, dim=2)\n+        do i = 1, ubound(x, dim=1)\n+          if (x(i,j,k,l) >= 0) then\n+            cnt = cnt + 1\n+            if (x(i,j,k,l) /= get_n([i,j,k,l], lbound(x), shape(x))) &\n+              error stop 5\n+          endif\n+        end do\n+      end do\n+    end do\n+  end do\n+end\n+\n+subroutine check(x, loc1, cont, cnt)\n+  integer, intent(in) :: x(:,:,:,:)\n+  integer(c_intptr_t), intent(in), optional :: loc1\n+  logical, intent(in), optional :: cont ! dummy has CONTIGUOUS attr\n+  integer, intent(in), optional :: cnt\n+  integer(c_intptr_t) :: loc2\n+  integer :: i, k, j, l\n+  if (present (loc1)) then\n+    loc2 = %loc(x(1,1,1,1))  ! { dg-warning \"Legacy Extension\" }\n+    if (is_contiguous (x) .or. .not.cont) then\n+      if (loc1 /= loc2) error stop 1\n+    else\n+      if (loc1 == loc2) error stop 2\n+    end if\n+    if (cnt /= size(x)) error stop 3\n+  end if\n+  do l = 1, ubound(x, dim=4)\n+    do k = 1, ubound(x, dim=3)\n+      do j = 1, ubound(x, dim=2)\n+        do i = 1, ubound(x, dim=1)\n+          if (x(i,j,k,l) /= -get_n([i,j,k,l], lbound(x), shape(x))) &\n+            error stop 4\n+        end do\n+      end do\n+    end do\n+  end do\n+end\n+\n+subroutine check2(x)\n+  integer, contiguous, intent(in) :: x(:,:,:,:)\n+  call check(x)\n+end subroutine\n+end"}, {"sha": "cee1eb4782f290dfcb4f54334b1d48f7555ff36b", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-4.c", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-4.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,370 @@\n+#include <ISO_Fortran_binding.h>\n+#include <stdbool.h>\n+#include <string.h>\n+\n+struct loc_t {\n+  intptr_t x, y, z;\n+};\n+\n+typedef struct loc_t (*ftn_fn) (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_size_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_size_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_expl_size_f (CFI_cdesc_t *,CFI_cdesc_t *, CFI_cdesc_t *,  int, int);\n+struct loc_t char_expl_size_in_f (CFI_cdesc_t *,CFI_cdesc_t *, CFI_cdesc_t *,  int, int);\n+struct loc_t char_assumed_rank_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_cont_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_cont_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_cont_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_cont_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+\n+static void\n+basic_check(CFI_cdesc_t *x, bool is_cont)\n+{\n+  if (!x->base_addr)\n+    __builtin_abort ();\n+  if (x->elem_len != 3*sizeof(char))\n+    __builtin_abort ();\n+  if (x->version != CFI_VERSION)\n+    __builtin_abort ();\n+  if (x->rank != 1)\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  if (x->type != CFI_type_char)\n+    __builtin_abort ();\n+  if (x->dim[0].lower_bound != 0)\n+    __builtin_abort ();\n+  if (x->dim[0].extent != 3)\n+    __builtin_abort ();\n+  if (CFI_is_contiguous (x) != (x->elem_len == x->dim[0].sm))\n+    __builtin_abort ();\n+  if (is_cont != CFI_is_contiguous (x))\n+    __builtin_abort ();\n+}\n+\n+static void\n+print_str (void *p, size_t len)\n+{\n+  __builtin_printf (\"DEBUG: >\");\n+  for (size_t i = 0; i < len; ++i)\n+    __builtin_printf (\"%c\", ((const char*) p)[i]);\n+  __builtin_printf (\"<\\n\");\n+}\n+\n+static void\n+check_str (CFI_cdesc_t *x, const char *str, const CFI_index_t subscripts[])\n+{\n+  /* Avoid checking for '\\0'.  */\n+  if (strncmp ((const char*) CFI_address (x, subscripts), str, strlen(str)) != 0)\n+    __builtin_abort ();\n+}\n+\n+static void\n+set_str (CFI_cdesc_t *x, const char *str, const CFI_index_t subscripts[])\n+{\n+  char *p = CFI_address (x, subscripts);\n+  size_t len = strlen (str);\n+  if (x->elem_len != len)\n+    __builtin_abort ();\n+  for (size_t i = 0; i < len; ++i)\n+    p[i] = str[i];\n+}\n+\n+static struct loc_t\n+do_call (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t int k, int num, bool intent_in, ftn_fn fn, bool is_cont, bool fort_cont)\n+{\n+  const CFI_index_t zero[1] = { 0 };\n+  const CFI_index_t one[1] = { 1 };\n+  const CFI_index_t two[1] = { 2 };\n+  struct loc_t addr1, addr2;\n+  if (k != 3)\n+    __builtin_abort ();\n+\n+  if (num == 3)\n+    {\n+      if (x != NULL)\n+\t__builtin_abort ();\n+      if (y != NULL)\n+\t__builtin_abort ();\n+      if (z != NULL)\n+\t__builtin_abort ();\n+      addr2 = fn (x, y, z, 3, num);\n+      if (addr2.x != -1 || addr2.y != -1 || addr2.z != -1)\n+\t__builtin_abort ();\n+      return addr2;\n+    }\n+  if (x == NULL)\n+    __builtin_abort ();\n+  if (y == NULL)\n+    __builtin_abort ();\n+  if (z == NULL)\n+    __builtin_abort ();\n+  basic_check (x, is_cont || num == 2);\n+  basic_check (y, is_cont || num == 2);\n+  basic_check (z, is_cont || num == 2);\n+  if (!is_cont && num == 1)\n+    {\n+      check_str (x, \"abc\", zero);\n+      check_str (x, \"ghi\", one);\n+      check_str (x, \"nop\", two);\n+      check_str (y, \"abc\", zero);\n+      check_str (y, \"ghi\", one);\n+      check_str (y, \"nop\", two);\n+      check_str (z, \"abc\", zero);\n+      check_str (z, \"ghi\", one);\n+      check_str (z, \"nop\", two);\n+    }\n+  else if (num == 1)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (num == 2)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else\n+    __builtin_abort ();\n+  addr1.x = (intptr_t) x->base_addr;\n+  addr1.y = (intptr_t) y->base_addr;\n+  addr1.z = (intptr_t) z->base_addr;\n+  addr2 = fn (x, y, z, 3, num);\n+  if (!CFI_is_contiguous (x) && fort_cont)\n+    {\n+      /* Check for callee copy in/copy out.  */\n+      if (addr1.x == addr2.x || addr1.x != (intptr_t) x->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.y == addr2.y || addr1.y != (intptr_t) y->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.z == addr2.z || addr1.z != (intptr_t) z->base_addr)\n+\t__builtin_abort ();\n+    }\n+  else\n+    {\n+      if (addr1.x != addr2.x || addr1.x != (intptr_t) x->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.y != addr2.y || addr1.y != (intptr_t) y->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.z != addr2.z || addr1.z != (intptr_t) z->base_addr)\n+\t__builtin_abort ();\n+    }\n+  // intent_in\n+  if (intent_in && !is_cont && num == 1)\n+    {\n+      check_str (x, \"abc\", zero);\n+      check_str (x, \"ghi\", one);\n+      check_str (x, \"nop\", two);\n+      check_str (y, \"abc\", zero);\n+      check_str (y, \"ghi\", one);\n+      check_str (y, \"nop\", two);\n+      check_str (z, \"abc\", zero);\n+      check_str (z, \"ghi\", one);\n+      check_str (z, \"nop\", two);\n+    }\n+  else if (intent_in && num == 1)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"abcghinop\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (intent_in && num == 2)\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"defghijlm\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (intent_in)\n+    __builtin_abort ();\n+  if (intent_in)\n+    {\n+      if (is_cont && num == 1)\n+        {\n+\t  /* Copy in - set the value to check that no copy out is done. */\n+\t  memcpy ((char*) x->base_addr, \"123456789\", 9);\n+\t  memcpy ((char*) y->base_addr, \"123456789\", 9);\n+\t  memcpy ((char*) z->base_addr, \"123456789\", 9);\n+        }\n+      return addr1;\n+    }\n+  // !intent_in\n+  if (!is_cont && num == 1)\n+    {\n+      check_str (x, \"ABC\", zero);\n+      check_str (x, \"DEF\", one);\n+      check_str (x, \"GHI\", two);\n+      check_str (y, \"ABC\", zero);\n+      check_str (y, \"DEF\", one);\n+      check_str (y, \"GHI\", two);\n+      check_str (z, \"ABC\", zero);\n+      check_str (z, \"DEF\", one);\n+      check_str (z, \"GHI\", two);\n+    }\n+  else\n+    {\n+      if (strncmp ((const char*) x->base_addr, \"ABCDEFGHI\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) y->base_addr, \"ABCDEFGHI\", 9) != 0)\n+\t__builtin_abort ();\n+      if (strncmp ((const char*) z->base_addr, \"ABCDEFGHI\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  return addr1;\n+}\n+\n+struct loc_t\n+char_assumed_size_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_size_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_size_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\tint k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_size_in_f, true, false);\n+}\n+\n+struct loc_t\n+char_expl_size_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_expl_size_f, true, false);\n+}\n+\n+struct loc_t\n+char_expl_size_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_expl_size_in_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_rank_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_rank_in_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_cont_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_rank_cont_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_cont_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_rank_cont_in_f, true, false);\n+}\n+\n+static void\n+reset_var (CFI_cdesc_t *x, int num)\n+{\n+  const CFI_index_t zero[1] = { 0 };\n+  const CFI_index_t one[1] = { 1 };\n+  const CFI_index_t two[1] = { 2 };\n+\n+  if (num == 1)\n+    {\n+      set_str (x, \"abc\", zero);\n+      set_str (x, \"ghi\", one);\n+      set_str (x, \"nop\", two);\n+    }\n+  else if (num == 2)\n+    {\n+      set_str (x, \"def\", zero);\n+      set_str (x, \"ghi\", one);\n+      set_str (x, \"jlm\", two);\n+    }\n+  else if (num == 3)\n+    {\n+      if (x != NULL)\n+\t__builtin_abort ();\n+    }\n+  else\n+    __builtin_abort ();\n+}\n+\n+static void\n+reset_vars (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z, int num)\n+{\n+  reset_var (x, num);\n+  reset_var (y, num);\n+  reset_var (z, num);\n+}\n+\n+struct loc_t\n+char_assumed_shape_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  /* Make use of having a noncontiguous argument to check that the callee\n+     handles noncontiguous variables.  */\n+  do_call (x, y, z, k, num, false, char_assumed_size_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_size_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_expl_size_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_expl_size_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_assumed_rank_cont_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_rank_cont_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_assumed_shape_cont_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_shape_cont_in_f, false, true);\n+  /* Actual func call. */\n+  reset_vars (x, y, z, num);\n+  return do_call (x, y, z, k, num, false, char_assumed_shape_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_shape_in_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_cont_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_shape_cont_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_cont_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_shape_cont_in_f, true, false);\n+}"}, {"sha": "ab59b0b3854662d2351ab5a7aaeb36b6e0e3c19e", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-4.f90", "status": "added", "additions": 1720, "deletions": 0, "changes": 1720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-4.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,1720 @@\n+! { dg-do run }\n+! \n+! Same test as bind-c-contiguous-1.* but with OPTIONAL \n+!\n+! { dg-additional-sources bind-c-contiguous-4.c }\n+! { dg-additional-options \"-fcheck=all\" }\n+! { dg-prune-output \"command-line option '-fcheck=.*' is valid for Fortran but not for C\" }\n+\n+! Fortran demands that with bind(C), the callee ensure that for\n+! * 'contiguous'\n+! * len=* with explicit/assumed-size arrays\n+! noncontiguous actual arguments are handled.\n+! (in without bind(C) in gfortran, caller handles the copy in/out\n+\n+! Additionally, for a bind(C) callee, a Fortran-written caller\n+! has to ensure the same (for contiguous + len=* to explicit-/assumed-size arrays)\n+\n+module m\n+  use iso_c_binding, only: c_intptr_t, c_bool, c_loc, c_int\n+  implicit none (type, external)\n+\n+  type, bind(C) :: loc_t\n+    integer(c_intptr_t) :: x, y, z\n+  end type loc_t\n+\n+interface\n+  type(loc_t) function char_assumed_size_c (xx, yy, zz, n, num) bind(C)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*), optional :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  end function\n+\n+  type(loc_t) function char_assumed_size_in_c (xx, yy, zz, n, num) bind(C)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*), intent(in), optional :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  end function\n+\n+  type(loc_t) function char_expl_size_c (xx, yy, zz, n, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*), optional :: xx(n), yy(n:n+3), zz(6:6, 3:n, 3:n+3)\n+  end function\n+\n+  type(loc_t) function char_expl_size_in_c (xx, yy, zz, n, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(len=*), intent(in), optional :: xx(n), yy(n:n+3), zz(6:6, 3:n, 3:n+3)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), optional :: xx(..)\n+    character(len=3), optional :: yy(..)\n+    character(len=k), optional :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), intent(in), optional :: xx(..)\n+    character(len=3), intent(in), optional :: yy(..)\n+    character(len=k), intent(in), optional :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_cont_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous, optional :: xx(..)\n+    character(len=3), contiguous, optional :: yy(..)\n+    character(len=k), contiguous, optional :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_cont_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous, intent(in), optional :: xx(..)\n+    character(len=3), contiguous, intent(in), optional :: yy(..)\n+    character(len=k), contiguous, intent(in), optional :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), optional :: xx(:)\n+    character(len=3), optional :: yy(5:)\n+    character(len=k), optional :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), intent(in), optional :: xx(:)\n+    character(len=3), intent(in), optional :: yy(5:)\n+    character(len=k), intent(in), optional :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_cont_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous, optional :: xx(:)\n+    character(len=3), contiguous, optional :: yy(5:)\n+    character(len=k), contiguous, optional :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_cont_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(len=*), contiguous, intent(in), optional :: xx(:)\n+    character(len=3), contiguous, intent(in), optional :: yy(5:)\n+    character(len=k), contiguous, intent(in), optional :: zz(-k:)\n+  end function\n+end interface\n+\n+contains\n+\n+type(loc_t) function char_assumed_size_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*), optional :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(3) = \"ABC\"\n+  yy(4) = \"DEF\"\n+  yy(5) = \"GHI\"\n+  zz(6,n,3) = \"ABC\"\n+  zz(6,n,4) = \"DEF\"\n+  zz(6,n,5) = \"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_assumed_size_in_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*), optional :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  intent(in) :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }  if (num == 1) then\n+end\n+\n+type(loc_t) function char_expl_size_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*), optional :: xx(n), yy(n:n+2), zz(6:6, 3:n, 3:n+2)\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (3 /= size(xx,dim=1)) error stop 1\n+  if (3 /= size(yy,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (3 /= size(zz,dim=3)) error stop 1\n+  if (3 /= ubound(xx,dim=1)) error stop 1\n+  if (5 /= ubound(yy,dim=1)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (5 /= ubound(zz,dim=3)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(3) = \"ABC\"\n+  yy(4) = \"DEF\"\n+  yy(5) = \"GHI\"\n+  zz(6,n,3) = \"ABC\"\n+  zz(6,n,4) = \"DEF\"\n+  zz(6,n,5) = \"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_expl_size_in_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(len=*), optional :: xx(n), yy(n:n+2), zz(6:6, 3:n, 3:n+2)\n+  intent(in) :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (3 /= size(xx,dim=1)) error stop 1\n+  if (3 /= size(yy,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (3 /= size(zz,dim=3)) error stop 1\n+  if (3 /= ubound(xx,dim=1)) error stop 1\n+  if (5 /= ubound(yy,dim=1)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (5 /= ubound(zz,dim=3)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"nop\") error stop 4\n+    if (yy(3) /= \"abc\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"nop\") error stop 4\n+    if (zz(6,n,3) /= \"abc\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 2\n+    if (xx(2) /= \"ghi\") error stop 3\n+    if (xx(3) /= \"jlm\") error stop 4\n+    if (yy(3) /= \"def\") error stop 2\n+    if (yy(4) /= \"ghi\") error stop 3\n+    if (yy(5) /= \"jlm\") error stop 4\n+    if (zz(6,n,3) /= \"def\") error stop 2\n+    if (zz(6,n,4) /= \"ghi\") error stop 3\n+    if (zz(6,n,5) /= \"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+\n+type(loc_t) function char_assumed_rank_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(..)\n+  character(len=3), optional :: yy(..)\n+  character(len=k), optional :: zz(..)\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  if (3 /= len(xx)) error stop 40\n+  if (3 /= len(yy)) error stop 40\n+  if (3 /= len(zz)) error stop 40\n+  if (3 /= size(xx)) error stop 41\n+  if (3 /= size(yy)) error stop 41\n+  if (3 /= size(zz)) error stop 41\n+  if (1 /= rank(xx)) error stop 49\n+  if (1 /= rank(yy)) error stop 49\n+  if (1 /= rank(zz)) error stop 49\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 49\n+    if (is_contiguous (yy)) error stop 49\n+    if (is_contiguous (zz)) error stop 49\n+  else if (num == 2) then\n+    if (.not. is_contiguous (xx)) error stop 49\n+    if (.not. is_contiguous (yy)) error stop 49\n+    if (.not. is_contiguous (zz)) error stop 49\n+  else\n+    error stop 48\n+  end if\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 42\n+      if (xx(2) /= \"ghi\") error stop 43\n+      if (xx(3) /= \"nop\") error stop 44\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 45\n+      if (xx(2) /= \"ghi\") error stop 46\n+      if (xx(3) /= \"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    xx(1) = \"ABC\"\n+    xx(2) = \"DEF\"\n+    xx(3) = \"GHI\"\n+    res%x = get_loc (xx)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 42\n+      if (yy(2) /= \"ghi\") error stop 43\n+      if (yy(3) /= \"nop\") error stop 44\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 45\n+      if (yy(2) /= \"ghi\") error stop 46\n+      if (yy(3) /= \"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    yy(1) = \"ABC\"\n+    yy(2) = \"DEF\"\n+    yy(3) = \"GHI\"\n+    res%y = get_loc (yy)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 42\n+      if (zz(2) /= \"ghi\") error stop 43\n+      if (zz(3) /= \"nop\") error stop 44\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 45\n+      if (zz(2) /= \"ghi\") error stop 46\n+      if (zz(3) /= \"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    zz(1) = \"ABC\"\n+    zz(2) = \"DEF\"\n+    zz(3) = \"GHI\"\n+    res%z = get_loc (zz)\n+  rank default\n+    error stop 99\n+  end select\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+type(loc_t) function char_assumed_rank_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(..)\n+  character(len=3), optional :: yy(..)\n+  character(len=k), optional :: zz(..)\n+  intent(in) :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  if (3 /= size(yy)) error stop 50\n+  if (3 /= len(yy)) error stop 51\n+  if (1 /= rank(yy)) error stop 59\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 59\n+    if (is_contiguous (yy)) error stop 59\n+    if (is_contiguous (zz)) error stop 59\n+  else if (num == 2) then\n+    if (.not. is_contiguous (xx)) error stop 59\n+    if (.not. is_contiguous (yy)) error stop 59\n+    if (.not. is_contiguous (zz)) error stop 59\n+  else\n+    error stop 48\n+  end if\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 52\n+      if (xx(2) /= \"ghi\") error stop 53\n+      if (xx(3) /= \"nop\") error stop 54\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 55\n+      if (xx(2) /= \"ghi\") error stop 56\n+      if (xx(3) /= \"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%x = get_loc(xx)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 52\n+      if (yy(2) /= \"ghi\") error stop 53\n+      if (yy(3) /= \"nop\") error stop 54\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 55\n+      if (yy(2) /= \"ghi\") error stop 56\n+      if (yy(3) /= \"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%y = get_loc(yy)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 52\n+      if (zz(2) /= \"ghi\") error stop 53\n+      if (zz(3) /= \"nop\") error stop 54\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 55\n+      if (zz(2) /= \"ghi\") error stop 56\n+      if (zz(3) /= \"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%z = get_loc(zz)\n+  rank default\n+    error stop 99\n+  end select\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+\n+\n+type(loc_t) function char_assumed_rank_cont_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(..)\n+  character(len=3), optional :: yy(..)\n+  character(len=k), optional :: zz(..)\n+  contiguous :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  if (3 /= len(xx)) error stop 60\n+  if (3 /= len(yy)) error stop 60\n+  if (3 /= len(zz)) error stop 60\n+  if (3 /= size(xx)) error stop 61\n+  if (3 /= size(yy)) error stop 61\n+  if (3 /= size(zz)) error stop 61\n+  if (1 /= rank(xx)) error stop 69\n+  if (1 /= rank(yy)) error stop 69\n+  if (1 /= rank(zz)) error stop 69\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 62\n+      if (xx(2) /= \"ghi\") error stop 63\n+      if (xx(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 65\n+      if (xx(2) /= \"ghi\") error stop 66\n+      if (xx(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    xx(1) = \"ABC\"\n+    xx(2) = \"DEF\"\n+    xx(3) = \"GHI\"\n+    res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 62\n+      if (yy(2) /= \"ghi\") error stop 63\n+      if (yy(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 65\n+      if (yy(2) /= \"ghi\") error stop 66\n+      if (yy(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    yy(1) = \"ABC\"\n+    yy(2) = \"DEF\"\n+    yy(3) = \"GHI\"\n+    res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 62\n+      if (zz(2) /= \"ghi\") error stop 63\n+      if (zz(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 65\n+      if (zz(2) /= \"ghi\") error stop 66\n+      if (zz(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    zz(1) = \"ABC\"\n+    zz(2) = \"DEF\"\n+    zz(3) = \"GHI\"\n+    res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+type(loc_t) function char_assumed_rank_cont_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(..)\n+  character(len=3), optional :: yy(..)\n+  character(len=k), optional :: zz(..)\n+  intent(in) :: xx, yy, zz\n+  contiguous :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  if (3 /= size(xx)) error stop 30\n+  if (3 /= size(yy)) error stop 30\n+  if (3 /= size(zz)) error stop 30\n+  if (3 /= len(xx)) error stop 31\n+  if (3 /= len(yy)) error stop 31\n+  if (3 /= len(zz)) error stop 31\n+  if (1 /= rank(xx)) error stop 69\n+  if (1 /= rank(yy)) error stop 69\n+  if (1 /= rank(zz)) error stop 69\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= \"abc\") error stop 62\n+      if (xx(2) /= \"ghi\") error stop 63\n+      if (xx(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (xx(1) /= \"def\") error stop 65\n+      if (xx(2) /= \"ghi\") error stop 66\n+      if (xx(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= \"abc\") error stop 62\n+      if (yy(2) /= \"ghi\") error stop 63\n+      if (yy(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (yy(1) /= \"def\") error stop 65\n+      if (yy(2) /= \"ghi\") error stop 66\n+      if (yy(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= \"abc\") error stop 62\n+      if (zz(2) /= \"ghi\") error stop 63\n+      if (zz(3) /= \"nop\") error stop 64\n+    else if (num == 2) then\n+      if (zz(1) /= \"def\") error stop 65\n+      if (zz(2) /= \"ghi\") error stop 66\n+      if (zz(3) /= \"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+type(loc_t) function char_assumed_shape_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(:)\n+  character(len=3), optional :: yy(5:)\n+  character(len=k), optional :: zz(-k:)\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 70\n+  if (3 /= len(yy)) error stop 70\n+  if (3 /= len(zz)) error stop 70\n+  if (3 /= size(xx)) error stop 71\n+  if (3 /= size(yy)) error stop 71\n+  if (3 /= size(zz)) error stop 71\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 79\n+    if (is_contiguous (yy)) error stop 79\n+    if (is_contiguous (zz)) error stop 79\n+    if (xx(1) /= \"abc\") error stop 72\n+    if (xx(2) /= \"ghi\") error stop 73\n+    if (xx(3) /= \"nop\") error stop 74\n+    if (yy(5) /= \"abc\") error stop 72\n+    if (yy(6) /= \"ghi\") error stop 73\n+    if (yy(7) /= \"nop\") error stop 74\n+    if (zz(-k) /= \"abc\") error stop 72\n+    if (zz(-k+1) /= \"ghi\") error stop 73\n+    if (zz(-k+2) /= \"nop\") error stop 74\n+  else if (num == 2) then\n+    if (.not.is_contiguous (xx)) error stop 79\n+    if (.not.is_contiguous (yy)) error stop 79\n+    if (.not.is_contiguous (zz)) error stop 79\n+    if (xx(1) /= \"def\") error stop 72\n+    if (xx(2) /= \"ghi\") error stop 73\n+    if (xx(3) /= \"jlm\") error stop 74\n+    if (yy(5) /= \"def\") error stop 72\n+    if (yy(6) /= \"ghi\") error stop 73\n+    if (yy(7) /= \"jlm\") error stop 74\n+    if (zz(-k) /= \"def\") error stop 72\n+    if (zz(-k+1) /= \"ghi\") error stop 73\n+    if (zz(-k+2) /= \"jlm\") error stop 74\n+  else\n+    error stop 78\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(5) = \"ABC\"\n+  yy(6) = \"DEF\"\n+  yy(7) = \"GHI\"\n+  zz(-k) = \"ABC\"\n+  zz(-k+1) = \"DEF\"\n+  zz(-k+2) = \"GHI\"\n+  res%x = get_loc(xx)\n+  res%y = get_loc(yy)\n+  res%z = get_loc(zz)\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+type(loc_t) function char_assumed_shape_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(:)\n+  character(len=3), optional :: yy(5:)\n+  character(len=k), optional :: zz(-k:)\n+  intent(in) :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= size(xx)) error stop 80\n+  if (3 /= size(yy)) error stop 80\n+  if (3 /= size(zz)) error stop 80\n+  if (3 /= len(xx)) error stop 81\n+  if (3 /= len(yy)) error stop 81\n+  if (3 /= len(zz)) error stop 81\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 89\n+    if (is_contiguous (yy)) error stop 89\n+    if (is_contiguous (zz)) error stop 89\n+    if (xx(1) /= \"abc\") error stop 82\n+    if (xx(2) /= \"ghi\") error stop 83\n+    if (xx(3) /= \"nop\") error stop 84\n+    if (yy(5) /= \"abc\") error stop 82\n+    if (yy(6) /= \"ghi\") error stop 83\n+    if (yy(7) /= \"nop\") error stop 84\n+    if (zz(-k) /= \"abc\") error stop 82\n+    if (zz(-k+1) /= \"ghi\") error stop 83\n+    if (zz(-k+2) /= \"nop\") error stop 84\n+  else if (num == 2) then\n+    if (.not.is_contiguous (xx)) error stop 89\n+    if (.not.is_contiguous (yy)) error stop 89\n+    if (.not.is_contiguous (zz)) error stop 89\n+    if (xx(1) /= \"def\") error stop 85\n+    if (xx(2) /= \"ghi\") error stop 86\n+    if (xx(3) /= \"jlm\") error stop 87\n+    if (yy(5) /= \"def\") error stop 85\n+    if (yy(6) /= \"ghi\") error stop 86\n+    if (yy(7) /= \"jlm\") error stop 87\n+    if (zz(-k) /= \"def\") error stop 85\n+    if (zz(-k+1) /= \"ghi\") error stop 86\n+    if (zz(-k+2) /= \"jlm\") error stop 87\n+  else\n+    error stop 88\n+  endif\n+  res%x = get_loc(xx)\n+  res%y = get_loc(yy)\n+  res%z = get_loc(zz)\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+\n+\n+type(loc_t) function char_assumed_shape_cont_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(:)\n+  character(len=3), optional :: yy(5:)\n+  character(len=k), optional :: zz(-k:)\n+  contiguous :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 90\n+  if (3 /= len(yy)) error stop 90\n+  if (3 /= len(zz)) error stop 90\n+  if (3 /= size(xx)) error stop 91\n+  if (3 /= size(yy)) error stop 91\n+  if (3 /= size(zz)) error stop 91\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 92\n+    if (xx(2) /= \"ghi\") error stop 93\n+    if (xx(3) /= \"nop\") error stop 94\n+    if (yy(5) /= \"abc\") error stop 92\n+    if (yy(6) /= \"ghi\") error stop 93\n+    if (yy(7) /= \"nop\") error stop 94\n+    if (zz(-k) /= \"abc\") error stop 92\n+    if (zz(-k+1) /= \"ghi\") error stop 93\n+    if (zz(-k+2) /= \"nop\") error stop 94\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 92\n+    if (xx(2) /= \"ghi\") error stop 93\n+    if (xx(3) /= \"jlm\") error stop 94\n+    if (yy(5) /= \"def\") error stop 92\n+    if (yy(6) /= \"ghi\") error stop 93\n+    if (yy(7) /= \"jlm\") error stop 94\n+    if (zz(-k) /= \"def\") error stop 92\n+    if (zz(-k+1) /= \"ghi\") error stop 93\n+    if (zz(-k+2) /= \"jlm\") error stop 94\n+  else\n+    error stop 98\n+  endif\n+  xx(1) = \"ABC\"\n+  xx(2) = \"DEF\"\n+  xx(3) = \"GHI\"\n+  yy(5) = \"ABC\"\n+  yy(6) = \"DEF\"\n+  yy(7) = \"GHI\"\n+  zz(-k) = \"ABC\"\n+  zz(-k+1) = \"DEF\"\n+  zz(-k+2) = \"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_assumed_shape_cont_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(len=*), optional :: xx(:)\n+  character(len=3), optional :: yy(5:)\n+  character(len=k), optional :: zz(-k:)\n+  intent(in) :: xx, yy, zz\n+  contiguous :: xx, yy, zz\n+  if (num == 3) then\n+    if (present (xx) .or. present (yy) .or. present (zz)) error stop 1\n+    res%x = -1; res%y = -1; res%z = -1\n+    return\n+  end if\n+  if (.not.present (xx) .or. .not.present (yy) .or. .not.present (zz)) error stop 1\n+  print *, xx(1:3)\n+  if (3 /= size(xx)) error stop 100\n+  if (3 /= size(yy)) error stop 100\n+  if (3 /= size(zz)) error stop 100\n+  if (3 /= len(xx)) error stop 101\n+  if (3 /= len(yy)) error stop 101\n+  if (3 /= len(zz)) error stop 101\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (xx(1) /= \"abc\") error stop 102\n+    if (xx(2) /= \"ghi\") error stop 103\n+    if (xx(3) /= \"nop\") error stop 104\n+    if (yy(5) /= \"abc\") error stop 102\n+    if (yy(6) /= \"ghi\") error stop 103\n+    if (yy(7) /= \"nop\") error stop 104\n+    if (zz(-k) /= \"abc\") error stop 102\n+    if (zz(-k+1) /= \"ghi\") error stop 103\n+    if (zz(-k+2) /= \"nop\") error stop 104\n+  else if (num == 2) then\n+    if (xx(1) /= \"def\") error stop 105\n+    if (xx(2) /= \"ghi\") error stop 106\n+    if (xx(3) /= \"jlm\") error stop 107\n+    if (yy(5) /= \"def\") error stop 105\n+    if (yy(6) /= \"ghi\") error stop 106\n+    if (yy(7) /= \"jlm\") error stop 107\n+    if (zz(-k) /= \"def\") error stop 105\n+    if (zz(-k+1) /= \"ghi\") error stop 106\n+    if (zz(-k+2) /= \"jlm\") error stop 107\n+  else\n+    error stop 108\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+end module\n+\n+\n+use m\n+implicit none (type, external)\n+character(len=3) :: a(6), a2(6), a3(6), a_init(6)\n+type(loc_t) :: loc3\n+\n+a_init = ['abc', 'def', 'ghi', 'jlm', 'nop', 'qrs']\n+\n+! -- Fortran: assumed size\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_f (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_size_f (n=size(a(2:4)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_f (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_size_in_f (n=size(a(2:4)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- Fortran: explicit shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_f (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_expl_size_f (n=size(a(2:4)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_f (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_expl_size_in_f (n=size(a(::2)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- Fortran: assumed rank\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_rank_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_rank_in_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- Fortran: assumed rank contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_rank_cont_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_rank_cont_in_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- Fortran: assumed shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_shape_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_shape_in_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- Fortran: assumed shape contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_shape_cont_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_shape_cont_in_f (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+\n+! --- character - call C directly --\n+\n+! -- C: assumed size\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_c (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_size_c (n=size(a(2:4)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_c (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_size_in_c (n=size(a(2:4)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- C: explicit shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_c (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_expl_size_c (n=size(a(::2)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_c (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_expl_size_in_c (n=size(a(::2)), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- C: assumed rank\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_rank_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_rank_in_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- C: assumed rank contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_rank_cont_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_rank_cont_in_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- C: assumed shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_shape_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_shape_in_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+! -- C: assumed shape contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a2 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+if (any (a3 /= ['ABC', 'def', 'DEF', 'jlm', 'GHI', 'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a2 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+if (any (a3 /= ['abc', 'ABC', 'DEF', 'GHI', 'nop', 'qrs'])) error stop 54\n+\n+loc3 = char_assumed_shape_cont_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+loc3 = char_assumed_shape_cont_in_c (k=len(a), num=3)\n+if (loc3%x /= -1 .or. loc3%y /= -1 .or. loc3%z /= -1) error stop 2\n+end\n+\n+! { dg-output \"At line 1003 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1003 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1003 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1024 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1024 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1024 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1046 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1046 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1046 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1067 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1067 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1067 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1132 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1132 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1132 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1218 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1218 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1218 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1239 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1239 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1239 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1285 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1285 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1285 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1307 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1307 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1307 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1328 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1328 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1328 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1393 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1393 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1393 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1414 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1414 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1414 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1479 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1479 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1479 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1500 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1500 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1500 of file .*bind-c-contiguous-4.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\""}, {"sha": "48c03d4e02e91ddfaf71d73ab0de7253e4177399", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-5.c", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-5.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,345 @@\n+#include <ISO_Fortran_binding.h>\n+#include <stdbool.h>\n+#include <string.h>\n+\n+struct loc_t {\n+  intptr_t x, y, z;\n+};\n+\n+typedef struct loc_t (*ftn_fn) (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_size_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_size_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_expl_size_f (CFI_cdesc_t *,CFI_cdesc_t *, CFI_cdesc_t *,  int, int);\n+struct loc_t char_expl_size_in_f (CFI_cdesc_t *,CFI_cdesc_t *, CFI_cdesc_t *,  int, int);\n+struct loc_t char_assumed_rank_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_cont_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_rank_cont_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_cont_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+struct loc_t char_assumed_shape_cont_in_f (CFI_cdesc_t *, CFI_cdesc_t *, CFI_cdesc_t *, int, int);\n+\n+static void\n+basic_check(CFI_cdesc_t *x, bool is_cont)\n+{\n+  if (!x->base_addr)\n+    __builtin_abort ();\n+  if (x->elem_len != 3*(4*sizeof(char))) /* ucs4_char */\n+    __builtin_abort ();\n+  if (x->version != CFI_VERSION)\n+    __builtin_abort ();\n+  if (x->rank != 1)\n+    __builtin_abort ();\n+  if (x->attribute != CFI_attribute_other)\n+    __builtin_abort ();\n+  if (x->type != CFI_type_ucs4_char)\n+    __builtin_abort ();\n+  if (x->dim[0].lower_bound != 0)\n+    __builtin_abort ();\n+  if (x->dim[0].extent != 3)\n+    __builtin_abort ();\n+  if (CFI_is_contiguous (x) != (x->elem_len == x->dim[0].sm))\n+    __builtin_abort ();\n+  if (is_cont != CFI_is_contiguous (x))\n+    __builtin_abort ();\n+}\n+\n+static void\n+print_str (void *p, size_t len)\n+{\n+  __builtin_printf (\"DEBUG: >\");\n+  /* Use ' ' for '\\0' */\n+  for (size_t i = 0; i < len*4; ++i)\n+    __builtin_printf (\"%c\", ((const char*) p)[i] ? ((const char*) p)[i] : ' ');\n+  __builtin_printf (\"<\\n\");\n+}\n+\n+static void\n+check_str (CFI_cdesc_t *x, const char *str, size_t n, const CFI_index_t subscripts[])\n+{\n+  /* Avoid checking for '\\0'.  */\n+  if (memcmp ((const char*) CFI_address (x, subscripts), str, n) != 0)\n+    __builtin_abort ();\n+}\n+\n+static void\n+set_str (CFI_cdesc_t *x, const char *str, size_t n, const CFI_index_t subscripts[])\n+{\n+  char *p = CFI_address (x, subscripts);\n+  if (x->elem_len != n)\n+    __builtin_abort ();\n+  for (size_t i = 0; i < n; ++i)\n+    p[i] = str[i];\n+}\n+\n+static struct loc_t\n+do_call (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t int k, int num, bool intent_in, ftn_fn fn, bool is_cont, bool fort_cont)\n+{\n+  const CFI_index_t zero[1] = { 0 };\n+  const CFI_index_t one[1] = { 1 };\n+  const CFI_index_t two[1] = { 2 };\n+  struct loc_t addr1, addr2;\n+  if (k != 3)\n+    __builtin_abort ();\n+  basic_check (x, is_cont || num == 2);\n+  basic_check (y, is_cont || num == 2);\n+  basic_check (z, is_cont || num == 2);\n+  if (!is_cont && num == 1)\n+    {\n+      check_str (x, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0\", 3*4, zero);\n+      check_str (x, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      check_str (x, \"n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 3*4, two);\n+      check_str (y, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0\", 3*4, zero);\n+      check_str (y, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      check_str (y, \"n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 3*4, two);\n+      check_str (z, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0\", 3*4, zero);\n+      check_str (z, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      check_str (z, \"n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 3*4, two);\n+    }\n+  else if (num == 1)\n+    {\n+      if (memcmp ((const char*) x->base_addr, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) y->base_addr, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) z->base_addr, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (num == 2)\n+    {\n+      if (memcmp ((const char*) x->base_addr, \"d\\0\\0\\0e\\0\\0\\0f\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0j\\0\\0\\0l\\0\\0\\0m\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) y->base_addr, \"d\\0\\0\\0e\\0\\0\\0f\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0j\\0\\0\\0l\\0\\0\\0m\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) z->base_addr, \"d\\0\\0\\0e\\0\\0\\0f\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0j\\0\\0\\0l\\0\\0\\0m\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+    }\n+  else\n+    __builtin_abort ();\n+  addr1.x = (intptr_t) x->base_addr;\n+  addr1.y = (intptr_t) y->base_addr;\n+  addr1.z = (intptr_t) z->base_addr;\n+  addr2 = fn (x, y, z, 3, num);\n+  if (!CFI_is_contiguous (x) && fort_cont)\n+    {\n+      /* Check for callee copy in/copy out.  */\n+      if (addr1.x == addr2.x || addr1.x != (intptr_t) x->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.y == addr2.y || addr1.y != (intptr_t) y->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.z == addr2.z || addr1.z != (intptr_t) z->base_addr)\n+\t__builtin_abort ();\n+    }\n+  else\n+    {\n+      if (addr1.x != addr2.x || addr1.x != (intptr_t) x->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.y != addr2.y || addr1.y != (intptr_t) y->base_addr)\n+\t__builtin_abort ();\n+      if (addr1.z != addr2.z || addr1.z != (intptr_t) z->base_addr)\n+\t__builtin_abort ();\n+    }\n+  // intent_in\n+  if (intent_in && !is_cont && num == 1)\n+    {\n+      check_str (x, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0\", 3*4, zero);\n+      check_str (x, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      check_str (x, \"n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 3*4, two);\n+      check_str (y, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0\", 3*4, zero);\n+      check_str (y, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      check_str (y, \"n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 3*4, two);\n+      check_str (z, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0\", 3*4, zero);\n+      check_str (z, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      check_str (z, \"n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 3*4, two);\n+    }\n+  else if (intent_in && num == 1)\n+    {\n+      if (memcmp ((const char*) x->base_addr, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) y->base_addr, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) z->base_addr, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (intent_in && num == 2)\n+    {\n+      if (memcmp ((const char*) x->base_addr, \"d\\0\\0\\0e\\0\\0\\0f\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0j\\0\\0\\0l\\0\\0\\0m\\0\\0\\0\", 9) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) y->base_addr, \"d\\0\\0\\0e\\0\\0\\0f\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0j\\0\\0\\0l\\0\\0\\0m\\0\\0\\0\", 9) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) z->base_addr, \"d\\0\\0\\0e\\0\\0\\0f\\0\\0\\0g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0j\\0\\0\\0l\\0\\0\\0m\\0\\0\\0\", 9) != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (intent_in)\n+    __builtin_abort ();\n+  if (intent_in)\n+    {\n+      if (is_cont && num == 1)\n+        {\n+\t  /* Copy in - set the value to check that no copy out is done. */\n+\t  memcpy ((char*) x->base_addr, \"1\\0\\0\\0\"\"2\\0\\0\\0\"\"3\\0\\0\\0\"\"4\\0\\0\\0\"\"5\\0\\0\\0\"\"6\\0\\0\\0\"\"7\\0\\0\\0\"\"8\\0\\0\\0\"\"9\\0\\0\\0\", 9*4);\n+\t  memcpy ((char*) y->base_addr, \"1\\0\\0\\0\"\"2\\0\\0\\0\"\"3\\0\\0\\0\"\"4\\0\\0\\0\"\"5\\0\\0\\0\"\"6\\0\\0\\0\"\"7\\0\\0\\0\"\"8\\0\\0\\0\"\"9\\0\\0\\0\", 9*4);\n+\t  memcpy ((char*) z->base_addr, \"1\\0\\0\\0\"\"2\\0\\0\\0\"\"3\\0\\0\\0\"\"4\\0\\0\\0\"\"5\\0\\0\\0\"\"6\\0\\0\\0\"\"7\\0\\0\\0\"\"8\\0\\0\\0\"\"9\\0\\0\\0\", 9*4);\n+        }\n+      return addr1;\n+    }\n+  // !intent_in\n+  if (!is_cont && num == 1)\n+    {\n+      check_str (x, \"A\\0\\0\\0B\\0\\0\\0C\\0\\0\\0\", 3*4, zero);\n+      check_str (x, \"D\\0\\0\\0E\\0\\0\\0F\\0\\0\\0\", 3*4, one);\n+      check_str (x, \"G\\0\\0\\0H\\0\\0\\0I\\0\\0\\0\", 3*4, two);\n+      check_str (y, \"A\\0\\0\\0B\\0\\0\\0C\\0\\0\\0\", 3*4, zero);\n+      check_str (y, \"D\\0\\0\\0E\\0\\0\\0F\\0\\0\\0\", 3*4, one);\n+      check_str (y, \"G\\0\\0\\0H\\0\\0\\0I\\0\\0\\0\", 3*4, two);\n+      check_str (z, \"A\\0\\0\\0B\\0\\0\\0C\\0\\0\\0\", 3*4, zero);\n+      check_str (z, \"D\\0\\0\\0E\\0\\0\\0F\\0\\0\\0\", 3*4, one);\n+      check_str (z, \"G\\0\\0\\0H\\0\\0\\0I\\0\\0\\0\", 3*4, two);\n+    }\n+  else\n+    {\n+      if (memcmp ((const char*) x->base_addr, \"A\\0\\0\\0B\\0\\0\\0C\\0\\0\\0D\\0\\0\\0E\\0\\0\\0F\\0\\0\\0G\\0\\0\\0H\\0\\0\\0I\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) y->base_addr, \"A\\0\\0\\0B\\0\\0\\0C\\0\\0\\0D\\0\\0\\0E\\0\\0\\0F\\0\\0\\0G\\0\\0\\0H\\0\\0\\0I\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+      if (memcmp ((const char*) z->base_addr, \"A\\0\\0\\0B\\0\\0\\0C\\0\\0\\0D\\0\\0\\0E\\0\\0\\0F\\0\\0\\0G\\0\\0\\0H\\0\\0\\0I\\0\\0\\0\", 9*4) != 0)\n+\t__builtin_abort ();\n+    }\n+  return addr1;\n+}\n+\n+struct loc_t\n+char_assumed_size_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_size_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_size_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\tint k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_size_in_f, true, false);\n+}\n+\n+struct loc_t\n+char_expl_size_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_expl_size_f, true, false);\n+}\n+\n+struct loc_t\n+char_expl_size_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_expl_size_in_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_rank_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_rank_in_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_cont_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_rank_cont_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_rank_cont_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_rank_cont_in_f, true, false);\n+}\n+\n+static void\n+reset_var (CFI_cdesc_t *x, int num)\n+{\n+  const CFI_index_t zero[1] = { 0 };\n+  const CFI_index_t one[1] = { 1 };\n+  const CFI_index_t two[1] = { 2 };\n+\n+  if (num == 1)\n+    {\n+      set_str (x, \"a\\0\\0\\0b\\0\\0\\0c\\0\\0\\0\", 3*4, zero);\n+      set_str (x, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      set_str (x, \"n\\0\\0\\0o\\0\\0\\0p\\0\\0\\0\", 3*4, two);\n+    }\n+  else if (num == 2)\n+    {\n+      set_str (x, \"d\\0\\0\\0e\\0\\0\\0f\\0\\0\\0\", 3*4, zero);\n+      set_str (x, \"g\\0\\0\\0h\\0\\0\\0i\\0\\0\\0\", 3*4, one);\n+      set_str (x, \"j\\0\\0\\0l\\0\\0\\0m\\0\\0\\0\", 3*4, two);\n+    }\n+  else\n+    __builtin_abort ();\n+}\n+\n+static void\n+reset_vars (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z, int num)\n+{\n+  reset_var (x, num);\n+  reset_var (y, num);\n+  reset_var (z, num);\n+}\n+\n+struct loc_t\n+char_assumed_shape_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  /* Make use of having a noncontiguous argument to check that the callee\n+     handles noncontiguous variables.  */\n+  do_call (x, y, z, k, num, false, char_assumed_size_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_size_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_expl_size_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_expl_size_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_assumed_rank_cont_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_rank_cont_in_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, false, char_assumed_shape_cont_f, false, true);\n+  reset_vars (x, y, z, num);\n+  do_call (x, y, z, k, num, true, char_assumed_shape_cont_in_f, false, true);\n+  /* Actual func call. */\n+  reset_vars (x, y, z, num);\n+  return do_call (x, y, z, k, num, false, char_assumed_shape_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t     int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_shape_in_f, false, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_cont_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, false, char_assumed_shape_cont_f, true, false);\n+}\n+\n+struct loc_t\n+char_assumed_shape_cont_in_c (CFI_cdesc_t *x, CFI_cdesc_t *y, CFI_cdesc_t *z,\n+\t\t\t  int k, int num)\n+{\n+  return do_call (x, y, z, k, num, true, char_assumed_shape_cont_in_f, true, false);\n+}"}, {"sha": "3eb2732a368c1f8e04c0dbc7adf050d1de610abf", "filename": "gcc/testsuite/gfortran.dg/bind-c-contiguous-5.f90", "status": "added", "additions": 1574, "deletions": 0, "changes": 1574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-contiguous-5.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,1574 @@\n+! { dg-do run }\n+! { dg-additional-sources bind-c-contiguous-5.c }\n+! { dg-additional-options \"-fcheck=all\" }\n+! { dg-prune-output \"command-line option '-fcheck=.*' is valid for Fortran but not for C\" }\n+!  ---- Same as bind-c-contiguous-1.f90 - but with kind=4 characters\n+! Fortran demands that with bind(C), the callee ensure that for\n+! * 'contiguous'\n+! * len=* with explicit/assumed-size arrays\n+! noncontiguous actual arguments are handled.\n+! (in without bind(C) in gfortran, caller handles the copy in/out\n+\n+! Additionally, for a bind(C) callee, a Fortran-written caller\n+! has to ensure the same (for contiguous + len=* to explicit-/assumed-size arrays)\n+\n+module m\n+  use iso_c_binding, only: c_intptr_t, c_bool, c_loc, c_int\n+  implicit none (type, external)\n+\n+  type, bind(C) :: loc_t\n+    integer(c_intptr_t) :: x, y, z\n+  end type loc_t\n+\n+interface\n+  type(loc_t) function char_assumed_size_c (xx, yy, zz, n, num) bind(C)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(kind=4, len=*) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  end function\n+\n+  type(loc_t) function char_assumed_size_in_c (xx, yy, zz, n, num) bind(C)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(kind=4, len=*), intent(in) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  end function\n+\n+  type(loc_t) function char_expl_size_c (xx, yy, zz, n, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(kind=4, len=*) :: xx(n), yy(n:n+3), zz(6:6, 3:n, 3:n+3)\n+  end function\n+\n+  type(loc_t) function char_expl_size_in_c (xx, yy, zz, n, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer(c_int), value :: n, num\n+    character(kind=4, len=*), intent(in) :: xx(n), yy(n:n+3), zz(6:6, 3:n, 3:n+3)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*) :: xx(..)\n+    character(kind=4, len=3) :: yy(..)\n+    character(kind=4, len=k) :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*), intent(in) :: xx(..)\n+    character(kind=4, len=3), intent(in) :: yy(..)\n+    character(kind=4, len=k), intent(in) :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_cont_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*), contiguous :: xx(..)\n+    character(kind=4, len=3), contiguous :: yy(..)\n+    character(kind=4, len=k), contiguous :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_rank_cont_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*), contiguous, intent(in) :: xx(..)\n+    character(kind=4, len=3), contiguous, intent(in) :: yy(..)\n+    character(kind=4, len=k), contiguous, intent(in) :: zz(..)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*) :: xx(:)\n+    character(kind=4, len=3) :: yy(5:)\n+    character(kind=4, len=k) :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*), intent(in) :: xx(:)\n+    character(kind=4, len=3), intent(in) :: yy(5:)\n+    character(kind=4, len=k), intent(in) :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_cont_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*), contiguous :: xx(:)\n+    character(kind=4, len=3), contiguous :: yy(5:)\n+    character(kind=4, len=k), contiguous :: zz(-k:)\n+  end function\n+\n+  type(loc_t) function char_assumed_shape_cont_in_c (xx, yy, zz, k, num) bind(c)\n+    import :: loc_t, c_bool, c_int\n+    integer, value :: k, num\n+    character(kind=4, len=*), contiguous, intent(in) :: xx(:)\n+    character(kind=4, len=3), contiguous, intent(in) :: yy(5:)\n+    character(kind=4, len=k), contiguous, intent(in) :: zz(-k:)\n+  end function\n+end interface\n+\n+contains\n+\n+type(loc_t) function char_assumed_size_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(kind=4, len=*) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= 4_\"abc\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"nop\") error stop 4\n+    if (yy(3) /= 4_\"abc\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"nop\") error stop 4\n+    if (zz(6,n,3) /= 4_\"abc\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= 4_\"def\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"jlm\") error stop 4\n+    if (yy(3) /= 4_\"def\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"jlm\") error stop 4\n+    if (zz(6,n,3) /= 4_\"def\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  xx(1) = 4_\"ABC\"\n+  xx(2) = 4_\"DEF\"\n+  xx(3) = 4_\"GHI\"\n+  yy(3) = 4_\"ABC\"\n+  yy(4) = 4_\"DEF\"\n+  yy(5) = 4_\"GHI\"\n+  zz(6,n,3) = 4_\"ABC\"\n+  zz(6,n,4) = 4_\"DEF\"\n+  zz(6,n,5) = 4_\"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_assumed_size_in_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(kind=4, len=*) :: xx(*), yy(n:*), zz(6:6, 3:n, 3:*)\n+  intent(in) :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= 4_\"abc\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"nop\") error stop 4\n+    if (yy(3) /= 4_\"abc\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"nop\") error stop 4\n+    if (zz(6,n,3) /= 4_\"abc\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= 4_\"def\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"jlm\") error stop 4\n+    if (yy(3) /= 4_\"def\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"jlm\") error stop 4\n+    if (zz(6,n,3) /= 4_\"def\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }  if (num == 1) then\n+end\n+\n+type(loc_t) function char_expl_size_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(kind=4, len=*) :: xx(n), yy(n:n+2), zz(6:6, 3:n, 3:n+2)\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (3 /= size(xx,dim=1)) error stop 1\n+  if (3 /= size(yy,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (3 /= size(zz,dim=3)) error stop 1\n+  if (3 /= ubound(xx,dim=1)) error stop 1\n+  if (5 /= ubound(yy,dim=1)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (5 /= ubound(zz,dim=3)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= 4_\"abc\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"nop\") error stop 4\n+    if (yy(3) /= 4_\"abc\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"nop\") error stop 4\n+    if (zz(6,n,3) /= 4_\"abc\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= 4_\"def\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"jlm\") error stop 4\n+    if (yy(3) /= 4_\"def\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"jlm\") error stop 4\n+    if (zz(6,n,3) /= 4_\"def\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  xx(1) = 4_\"ABC\"\n+  xx(2) = 4_\"DEF\"\n+  xx(3) = 4_\"GHI\"\n+  yy(3) = 4_\"ABC\"\n+  yy(4) = 4_\"DEF\"\n+  yy(5) = 4_\"GHI\"\n+  zz(6,n,3) = 4_\"ABC\"\n+  zz(6,n,4) = 4_\"DEF\"\n+  zz(6,n,5) = 4_\"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_expl_size_in_f (xx, yy, zz, n, num) bind(c) result(res)\n+  integer, value :: num, n\n+  character(kind=4, len=*) :: xx(n), yy(n:n+2), zz(6:6, 3:n, 3:n+2)\n+  intent(in) :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 1\n+  if (3 /= len(yy)) error stop 1\n+  if (3 /= len(zz)) error stop 1\n+  if (1 /= lbound(xx,dim=1)) error stop 1\n+  if (3 /= lbound(yy,dim=1)) error stop 1\n+  if (6 /= lbound(zz,dim=1)) error stop 1\n+  if (3 /= lbound(zz,dim=2)) error stop 1\n+  if (3 /= lbound(zz,dim=3)) error stop 1\n+  if (3 /= size(xx,dim=1)) error stop 1\n+  if (3 /= size(yy,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=1)) error stop 1\n+  if (1 /= size(zz,dim=2)) error stop 1\n+  if (3 /= size(zz,dim=3)) error stop 1\n+  if (3 /= ubound(xx,dim=1)) error stop 1\n+  if (5 /= ubound(yy,dim=1)) error stop 1\n+  if (6 /= ubound(zz,dim=1)) error stop 1\n+  if (3 /= ubound(zz,dim=2)) error stop 1\n+  if (5 /= ubound(zz,dim=3)) error stop 1\n+  if (num == 1) then\n+    if (xx(1) /= 4_\"abc\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"nop\") error stop 4\n+    if (yy(3) /= 4_\"abc\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"nop\") error stop 4\n+    if (zz(6,n,3) /= 4_\"abc\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"nop\") error stop 4\n+  else if (num == 2) then\n+    if (xx(1) /= 4_\"def\") error stop 2\n+    if (xx(2) /= 4_\"ghi\") error stop 3\n+    if (xx(3) /= 4_\"jlm\") error stop 4\n+    if (yy(3) /= 4_\"def\") error stop 2\n+    if (yy(4) /= 4_\"ghi\") error stop 3\n+    if (yy(5) /= 4_\"jlm\") error stop 4\n+    if (zz(6,n,3) /= 4_\"def\") error stop 2\n+    if (zz(6,n,4) /= 4_\"ghi\") error stop 3\n+    if (zz(6,n,5) /= 4_\"jlm\") error stop 4\n+  else\n+    error stop 8\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+\n+type(loc_t) function char_assumed_rank_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(..)\n+  character(kind=4, len=3) :: yy(..)\n+  character(kind=4, len=k) :: zz(..)\n+  if (3 /= len(xx)) error stop 40\n+  if (3 /= len(yy)) error stop 40\n+  if (3 /= len(zz)) error stop 40\n+  if (3 /= size(xx)) error stop 41\n+  if (3 /= size(yy)) error stop 41\n+  if (3 /= size(zz)) error stop 41\n+  if (1 /= rank(xx)) error stop 49\n+  if (1 /= rank(yy)) error stop 49\n+  if (1 /= rank(zz)) error stop 49\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 49\n+    if (is_contiguous (yy)) error stop 49\n+    if (is_contiguous (zz)) error stop 49\n+  else if (num == 2) then\n+    if (.not. is_contiguous (xx)) error stop 49\n+    if (.not. is_contiguous (yy)) error stop 49\n+    if (.not. is_contiguous (zz)) error stop 49\n+  else\n+    error stop 48\n+  end if\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= 4_\"abc\") error stop 42\n+      if (xx(2) /= 4_\"ghi\") error stop 43\n+      if (xx(3) /= 4_\"nop\") error stop 44\n+    else if (num == 2) then\n+      if (xx(1) /= 4_\"def\") error stop 45\n+      if (xx(2) /= 4_\"ghi\") error stop 46\n+      if (xx(3) /= 4_\"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    xx(1) = 4_\"ABC\"\n+    xx(2) = 4_\"DEF\"\n+    xx(3) = 4_\"GHI\"\n+    res%x = get_loc (xx)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= 4_\"abc\") error stop 42\n+      if (yy(2) /= 4_\"ghi\") error stop 43\n+      if (yy(3) /= 4_\"nop\") error stop 44\n+    else if (num == 2) then\n+      if (yy(1) /= 4_\"def\") error stop 45\n+      if (yy(2) /= 4_\"ghi\") error stop 46\n+      if (yy(3) /= 4_\"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    yy(1) = 4_\"ABC\"\n+    yy(2) = 4_\"DEF\"\n+    yy(3) = 4_\"GHI\"\n+    res%y = get_loc (yy)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= 4_\"abc\") error stop 42\n+      if (zz(2) /= 4_\"ghi\") error stop 43\n+      if (zz(3) /= 4_\"nop\") error stop 44\n+    else if (num == 2) then\n+      if (zz(1) /= 4_\"def\") error stop 45\n+      if (zz(2) /= 4_\"ghi\") error stop 46\n+      if (zz(3) /= 4_\"jlm\") error stop 47\n+    else\n+      error stop 48\n+    endif\n+    zz(1) = 4_\"ABC\"\n+    zz(2) = 4_\"DEF\"\n+    zz(3) = 4_\"GHI\"\n+    res%z = get_loc (zz)\n+  rank default\n+    error stop 99\n+  end select\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(kind=4, len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+type(loc_t) function char_assumed_rank_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(..)\n+  character(kind=4, len=3) :: yy(..)\n+  character(kind=4, len=k) :: zz(..)\n+  intent(in) :: xx, yy, zz\n+  if (3 /= size(yy)) error stop 50\n+  if (3 /= len(yy)) error stop 51\n+  if (1 /= rank(yy)) error stop 59\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 59\n+    if (is_contiguous (yy)) error stop 59\n+    if (is_contiguous (zz)) error stop 59\n+  else if (num == 2) then\n+    if (.not. is_contiguous (xx)) error stop 59\n+    if (.not. is_contiguous (yy)) error stop 59\n+    if (.not. is_contiguous (zz)) error stop 59\n+  else\n+    error stop 48\n+  end if\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= 4_\"abc\") error stop 52\n+      if (xx(2) /= 4_\"ghi\") error stop 53\n+      if (xx(3) /= 4_\"nop\") error stop 54\n+    else if (num == 2) then\n+      if (xx(1) /= 4_\"def\") error stop 55\n+      if (xx(2) /= 4_\"ghi\") error stop 56\n+      if (xx(3) /= 4_\"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%x = get_loc(xx)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= 4_\"abc\") error stop 52\n+      if (yy(2) /= 4_\"ghi\") error stop 53\n+      if (yy(3) /= 4_\"nop\") error stop 54\n+    else if (num == 2) then\n+      if (yy(1) /= 4_\"def\") error stop 55\n+      if (yy(2) /= 4_\"ghi\") error stop 56\n+      if (yy(3) /= 4_\"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%y = get_loc(yy)\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= 4_\"abc\") error stop 52\n+      if (zz(2) /= 4_\"ghi\") error stop 53\n+      if (zz(3) /= 4_\"nop\") error stop 54\n+    else if (num == 2) then\n+      if (zz(1) /= 4_\"def\") error stop 55\n+      if (zz(2) /= 4_\"ghi\") error stop 56\n+      if (zz(3) /= 4_\"jlm\") error stop 57\n+    else\n+      error stop 58\n+    endif\n+    res%z = get_loc(zz)\n+  rank default\n+    error stop 99\n+  end select\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(kind=4, len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+\n+\n+type(loc_t) function char_assumed_rank_cont_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(..)\n+  character(kind=4, len=3) :: yy(..)\n+  character(kind=4, len=k) :: zz(..)\n+  contiguous :: xx, yy, zz\n+  if (3 /= len(xx)) error stop 60\n+  if (3 /= len(yy)) error stop 60\n+  if (3 /= len(zz)) error stop 60\n+  if (3 /= size(xx)) error stop 61\n+  if (3 /= size(yy)) error stop 61\n+  if (3 /= size(zz)) error stop 61\n+  if (1 /= rank(xx)) error stop 69\n+  if (1 /= rank(yy)) error stop 69\n+  if (1 /= rank(zz)) error stop 69\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= 4_\"abc\") error stop 62\n+      if (xx(2) /= 4_\"ghi\") error stop 63\n+      if (xx(3) /= 4_\"nop\") error stop 64\n+    else if (num == 2) then\n+      if (xx(1) /= 4_\"def\") error stop 65\n+      if (xx(2) /= 4_\"ghi\") error stop 66\n+      if (xx(3) /= 4_\"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    xx(1) = 4_\"ABC\"\n+    xx(2) = 4_\"DEF\"\n+    xx(3) = 4_\"GHI\"\n+    res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= 4_\"abc\") error stop 62\n+      if (yy(2) /= 4_\"ghi\") error stop 63\n+      if (yy(3) /= 4_\"nop\") error stop 64\n+    else if (num == 2) then\n+      if (yy(1) /= 4_\"def\") error stop 65\n+      if (yy(2) /= 4_\"ghi\") error stop 66\n+      if (yy(3) /= 4_\"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    yy(1) = 4_\"ABC\"\n+    yy(2) = 4_\"DEF\"\n+    yy(3) = 4_\"GHI\"\n+    res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= 4_\"abc\") error stop 62\n+      if (zz(2) /= 4_\"ghi\") error stop 63\n+      if (zz(3) /= 4_\"nop\") error stop 64\n+    else if (num == 2) then\n+      if (zz(1) /= 4_\"def\") error stop 65\n+      if (zz(2) /= 4_\"ghi\") error stop 66\n+      if (zz(3) /= 4_\"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    zz(1) = 4_\"ABC\"\n+    zz(2) = 4_\"DEF\"\n+    zz(3) = 4_\"GHI\"\n+    res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+type(loc_t) function char_assumed_rank_cont_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(..)\n+  character(kind=4, len=3) :: yy(..)\n+  character(kind=4, len=k) :: zz(..)\n+  intent(in) :: xx, yy, zz\n+  contiguous :: xx, yy, zz\n+  if (3 /= size(xx)) error stop 30\n+  if (3 /= size(yy)) error stop 30\n+  if (3 /= size(zz)) error stop 30\n+  if (3 /= len(xx)) error stop 31\n+  if (3 /= len(yy)) error stop 31\n+  if (3 /= len(zz)) error stop 31\n+  if (1 /= rank(xx)) error stop 69\n+  if (1 /= rank(yy)) error stop 69\n+  if (1 /= rank(zz)) error stop 69\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (1 /= lbound(yy, dim=1)) stop 49\n+  if (1 /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (3 /= ubound(yy, dim=1)) stop 49\n+  if (3 /= ubound(zz, dim=1)) stop 49\n+  select rank (xx)\n+  rank (1)\n+    print *, xx(1:3)\n+    if (num == 1) then\n+      if (xx(1) /= 4_\"abc\") error stop 62\n+      if (xx(2) /= 4_\"ghi\") error stop 63\n+      if (xx(3) /= 4_\"nop\") error stop 64\n+    else if (num == 2) then\n+      if (xx(1) /= 4_\"def\") error stop 65\n+      if (xx(2) /= 4_\"ghi\") error stop 66\n+      if (xx(3) /= 4_\"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (yy)\n+  rank (1)\n+    print *, yy(1:3)\n+    if (num == 1) then\n+      if (yy(1) /= 4_\"abc\") error stop 62\n+      if (yy(2) /= 4_\"ghi\") error stop 63\n+      if (yy(3) /= 4_\"nop\") error stop 64\n+    else if (num == 2) then\n+      if (yy(1) /= 4_\"def\") error stop 65\n+      if (yy(2) /= 4_\"ghi\") error stop 66\n+      if (yy(3) /= 4_\"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+  select rank (zz)\n+  rank (1)\n+    print *, zz(1:3)\n+    if (num == 1) then\n+      if (zz(1) /= 4_\"abc\") error stop 62\n+      if (zz(2) /= 4_\"ghi\") error stop 63\n+      if (zz(3) /= 4_\"nop\") error stop 64\n+    else if (num == 2) then\n+      if (zz(1) /= 4_\"def\") error stop 65\n+      if (zz(2) /= 4_\"ghi\") error stop 66\n+      if (zz(3) /= 4_\"jlm\") error stop 67\n+    else\n+      error stop 68\n+    endif\n+    res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+  rank default\n+    error stop 99\n+  end select\n+end\n+\n+type(loc_t) function char_assumed_shape_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(:)\n+  character(kind=4, len=3) :: yy(5:)\n+  character(kind=4, len=k) :: zz(-k:)\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 70\n+  if (3 /= len(yy)) error stop 70\n+  if (3 /= len(zz)) error stop 70\n+  if (3 /= size(xx)) error stop 71\n+  if (3 /= size(yy)) error stop 71\n+  if (3 /= size(zz)) error stop 71\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 79\n+    if (is_contiguous (yy)) error stop 79\n+    if (is_contiguous (zz)) error stop 79\n+    if (xx(1) /= 4_\"abc\") error stop 72\n+    if (xx(2) /= 4_\"ghi\") error stop 73\n+    if (xx(3) /= 4_\"nop\") error stop 74\n+    if (yy(5) /= 4_\"abc\") error stop 72\n+    if (yy(6) /= 4_\"ghi\") error stop 73\n+    if (yy(7) /= 4_\"nop\") error stop 74\n+    if (zz(-k) /= 4_\"abc\") error stop 72\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 73\n+    if (zz(-k+2) /= 4_\"nop\") error stop 74\n+  else if (num == 2) then\n+    if (.not.is_contiguous (xx)) error stop 79\n+    if (.not.is_contiguous (yy)) error stop 79\n+    if (.not.is_contiguous (zz)) error stop 79\n+    if (xx(1) /= 4_\"def\") error stop 72\n+    if (xx(2) /= 4_\"ghi\") error stop 73\n+    if (xx(3) /= 4_\"jlm\") error stop 74\n+    if (yy(5) /= 4_\"def\") error stop 72\n+    if (yy(6) /= 4_\"ghi\") error stop 73\n+    if (yy(7) /= 4_\"jlm\") error stop 74\n+    if (zz(-k) /= 4_\"def\") error stop 72\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 73\n+    if (zz(-k+2) /= 4_\"jlm\") error stop 74\n+  else\n+    error stop 78\n+  endif\n+  xx(1) = 4_\"ABC\"\n+  xx(2) = 4_\"DEF\"\n+  xx(3) = 4_\"GHI\"\n+  yy(5) = 4_\"ABC\"\n+  yy(6) = 4_\"DEF\"\n+  yy(7) = 4_\"GHI\"\n+  zz(-k) = 4_\"ABC\"\n+  zz(-k+1) = 4_\"DEF\"\n+  zz(-k+2) = 4_\"GHI\"\n+  res%x = get_loc(xx)\n+  res%y = get_loc(yy)\n+  res%z = get_loc(zz)\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(kind=4, len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+type(loc_t) function char_assumed_shape_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(:)\n+  character(kind=4, len=3) :: yy(5:)\n+  character(kind=4, len=k) :: zz(-k:)\n+  intent(in) :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= size(xx)) error stop 80\n+  if (3 /= size(yy)) error stop 80\n+  if (3 /= size(zz)) error stop 80\n+  if (3 /= len(xx)) error stop 81\n+  if (3 /= len(yy)) error stop 81\n+  if (3 /= len(zz)) error stop 81\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (is_contiguous (xx)) error stop 89\n+    if (is_contiguous (yy)) error stop 89\n+    if (is_contiguous (zz)) error stop 89\n+    if (xx(1) /= 4_\"abc\") error stop 82\n+    if (xx(2) /= 4_\"ghi\") error stop 83\n+    if (xx(3) /= 4_\"nop\") error stop 84\n+    if (yy(5) /= 4_\"abc\") error stop 82\n+    if (yy(6) /= 4_\"ghi\") error stop 83\n+    if (yy(7) /= 4_\"nop\") error stop 84\n+    if (zz(-k) /= 4_\"abc\") error stop 82\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 83\n+    if (zz(-k+2) /= 4_\"nop\") error stop 84\n+  else if (num == 2) then\n+    if (.not.is_contiguous (xx)) error stop 89\n+    if (.not.is_contiguous (yy)) error stop 89\n+    if (.not.is_contiguous (zz)) error stop 89\n+    if (xx(1) /= 4_\"def\") error stop 85\n+    if (xx(2) /= 4_\"ghi\") error stop 86\n+    if (xx(3) /= 4_\"jlm\") error stop 87\n+    if (yy(5) /= 4_\"def\") error stop 85\n+    if (yy(6) /= 4_\"ghi\") error stop 86\n+    if (yy(7) /= 4_\"jlm\") error stop 87\n+    if (zz(-k) /= 4_\"def\") error stop 85\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 86\n+    if (zz(-k+2) /= 4_\"jlm\") error stop 87\n+  else\n+    error stop 88\n+  endif\n+  res%x = get_loc(xx)\n+  res%y = get_loc(yy)\n+  res%z = get_loc(zz)\n+contains\n+  integer (c_intptr_t) function get_loc (arg)\n+    character(kind=4, len=*), target :: arg(:)\n+    ! %loc does copy in/out if not simply contiguous\n+    ! extra func needed because of 'target' attribute\n+    get_loc = transfer (c_loc(arg), res%x)\n+  end\n+end\n+\n+\n+\n+type(loc_t) function char_assumed_shape_cont_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(:)\n+  character(kind=4, len=3) :: yy(5:)\n+  character(kind=4, len=k) :: zz(-k:)\n+  contiguous :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= len(xx)) error stop 90\n+  if (3 /= len(yy)) error stop 90\n+  if (3 /= len(zz)) error stop 90\n+  if (3 /= size(xx)) error stop 91\n+  if (3 /= size(yy)) error stop 91\n+  if (3 /= size(zz)) error stop 91\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (xx(1) /= 4_\"abc\") error stop 92\n+    if (xx(2) /= 4_\"ghi\") error stop 93\n+    if (xx(3) /= 4_\"nop\") error stop 94\n+    if (yy(5) /= 4_\"abc\") error stop 92\n+    if (yy(6) /= 4_\"ghi\") error stop 93\n+    if (yy(7) /= 4_\"nop\") error stop 94\n+    if (zz(-k) /= 4_\"abc\") error stop 92\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 93\n+    if (zz(-k+2) /= 4_\"nop\") error stop 94\n+  else if (num == 2) then\n+    if (xx(1) /= 4_\"def\") error stop 92\n+    if (xx(2) /= 4_\"ghi\") error stop 93\n+    if (xx(3) /= 4_\"jlm\") error stop 94\n+    if (yy(5) /= 4_\"def\") error stop 92\n+    if (yy(6) /= 4_\"ghi\") error stop 93\n+    if (yy(7) /= 4_\"jlm\") error stop 94\n+    if (zz(-k) /= 4_\"def\") error stop 92\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 93\n+    if (zz(-k+2) /= 4_\"jlm\") error stop 94\n+  else\n+    error stop 98\n+  endif\n+  xx(1) = 4_\"ABC\"\n+  xx(2) = 4_\"DEF\"\n+  xx(3) = 4_\"GHI\"\n+  yy(5) = 4_\"ABC\"\n+  yy(6) = 4_\"DEF\"\n+  yy(7) = 4_\"GHI\"\n+  zz(-k) = 4_\"ABC\"\n+  zz(-k+1) = 4_\"DEF\"\n+  zz(-k+2) = 4_\"GHI\"\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+type(loc_t) function char_assumed_shape_cont_in_f (xx, yy, zz, k, num) bind(c) result(res)\n+  integer, value :: num, k\n+  character(kind=4, len=*) :: xx(:)\n+  character(kind=4, len=3) :: yy(5:)\n+  character(kind=4, len=k) :: zz(-k:)\n+  intent(in) :: xx, yy, zz\n+  contiguous :: xx, yy, zz\n+  print *, xx(1:3)\n+  if (3 /= size(xx)) error stop 100\n+  if (3 /= size(yy)) error stop 100\n+  if (3 /= size(zz)) error stop 100\n+  if (3 /= len(xx)) error stop 101\n+  if (3 /= len(yy)) error stop 101\n+  if (3 /= len(zz)) error stop 101\n+  if (1 /= lbound(xx, dim=1)) stop 49\n+  if (5 /= lbound(yy, dim=1)) stop 49\n+  if (-k /= lbound(zz, dim=1)) stop 49\n+  if (3 /= ubound(xx, dim=1)) stop 49\n+  if (7 /= ubound(yy, dim=1)) stop 49\n+  if (-k+2 /= ubound(zz, dim=1)) stop 49\n+  if (num == 1) then\n+    if (xx(1) /= 4_\"abc\") error stop 102\n+    if (xx(2) /= 4_\"ghi\") error stop 103\n+    if (xx(3) /= 4_\"nop\") error stop 104\n+    if (yy(5) /= 4_\"abc\") error stop 102\n+    if (yy(6) /= 4_\"ghi\") error stop 103\n+    if (yy(7) /= 4_\"nop\") error stop 104\n+    if (zz(-k) /= 4_\"abc\") error stop 102\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 103\n+    if (zz(-k+2) /= 4_\"nop\") error stop 104\n+  else if (num == 2) then\n+    if (xx(1) /= 4_\"def\") error stop 105\n+    if (xx(2) /= 4_\"ghi\") error stop 106\n+    if (xx(3) /= 4_\"jlm\") error stop 107\n+    if (yy(5) /= 4_\"def\") error stop 105\n+    if (yy(6) /= 4_\"ghi\") error stop 106\n+    if (yy(7) /= 4_\"jlm\") error stop 107\n+    if (zz(-k) /= 4_\"def\") error stop 105\n+    if (zz(-k+1) /= 4_\"ghi\") error stop 106\n+    if (zz(-k+2) /= 4_\"jlm\") error stop 107\n+  else\n+    error stop 108\n+  endif\n+  res%x = %loc(xx)  ! { dg-warning \"Legacy Extension\" }\n+  res%y = %loc(yy)  ! { dg-warning \"Legacy Extension\" }\n+  res%z = %loc(zz)  ! { dg-warning \"Legacy Extension\" }\n+end\n+\n+end module\n+\n+\n+use m\n+implicit none (type, external)\n+character(kind=4, len=3) :: a(6), a2(6), a3(6), a_init(6)\n+type(loc_t) :: loc3\n+\n+a_init = [4_'abc', 4_'def', 4_'ghi', 4_'jlm', 4_'nop', 4_'qrs']\n+\n+! -- Fortran: assumed size\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_f (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_f (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: explicit shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_f (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_f (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_f (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed rank\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed rank contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- Fortran: assumed shape contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_f (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_f (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+\n+! --- character - call C directly --\n+\n+! -- C: assumed size\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_c (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_size_in_c (a(2:4), a2(2:4), a3(2:4), size(a(2:4)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: explicit shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_c (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_c (a(::2), a2(::2), a3(::2), size(a(::2)), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_expl_size_in_c (a(2:4), a2(2:4), a3(2:4), size(a(::2)), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed rank\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed rank contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_rank_cont_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed shape\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)\n+if (loc3%x /= %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+\n+! -- C: assumed shape contiguous\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 51  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a2 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+if (any (a3 /= [4_'ABC', 4_'def', 4_'DEF', 4_'jlm', 4_'GHI', 4_'qrs'])) error stop 52\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 53  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a2 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+if (any (a3 /= [4_'abc', 4_'ABC', 4_'DEF', 4_'GHI', 4_'nop', 4_'qrs'])) error stop 54\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_c (a(::2), a2(::2), a3(::2), len(a), num=1)   ! NOTE: run-time copy-in warning\n+if (loc3%x == %loc(a)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y == %loc(a2)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z == %loc(a3)) error stop 55  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 56\n+if (any (a2 /= a_init)) error stop 56\n+if (any (a3 /= a_init)) error stop 56\n+\n+a = a_init; a2 = a_init; a3 = a_init\n+loc3 = char_assumed_shape_cont_in_c (a(2:4), a2(2:4), a3(2:4), len(a), num=2)\n+if (loc3%x /= %loc(a(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%y /= %loc(a2(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (loc3%z /= %loc(a3(2))) error stop 57  ! { dg-warning \"Legacy Extension\" }\n+if (any (a /= a_init)) error stop 58\n+if (any (a2 /= a_init)) error stop 58\n+if (any (a3 /= a_init)) error stop 58\n+end\n+\n+\n+! { dg-output \"At line 928 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 928 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 928 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 946 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 946 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 946 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 965 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 965 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 965 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 983 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 983 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 983 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1039 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1039 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1039 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1057 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1057 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1057 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1113 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1113 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1113 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1131 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1131 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1131 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_in_f'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1153 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1171 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1171 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1171 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1190 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1190 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1190 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1208 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1208 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1208 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_expl_size_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1264 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1282 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1282 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1282 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_rank_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1338 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1338 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1338 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1356 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'xx' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1356 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'yy' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"At line 1356 of file .*bind-c-contiguous-5.f90(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \"Fortran runtime warning: An array temporary was created for argument 'zz' of procedure 'char_assumed_shape_cont_in_c'(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" abcghinop(\\n|\\r\\n|\\r)\" }\"\n+! { dg-output \" defghijlm(\\n|\\r\\n|\\r)\" }\""}, {"sha": "d416fa5ea946a36818a76363f2643bbd64fb90aa", "filename": "gcc/testsuite/gfortran.dg/bind-c-intent-out.f90", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-intent-out.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-intent-out.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-intent-out.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do compile }\n+! { dg-do run }\n ! { dg-options \"-fdump-tree-original\" }\n !\n ! PR fortran/91863\n@@ -28,15 +28,20 @@ subroutine sub(x) bind(c)\n   if (.not.allocated(a)) stop 1\n   if (any(shape(a) /= [3])) stop 2\n   if (lbound(a,1) /= 3 .or. ubound(a,1) /= 5) stop 3\n+  print *, a(0), a(1), a(2), a(3), a(4)\n+  print *, a\n   if (any(a /= [1, 2, 3])) stop 4\n end program p\n \n ! \"cfi\" only appears in context of \"a\" -> bind-C descriptor\n-! the intent(out) implies freeing in the callee (!), hence the \"free\"\n+! the intent(out) implies freeing in the callee (!) (when implemented in Fortran), hence the \"free\"\n+! and also in the caller (when implemented in Fortran)\n ! It is the only 'free' as 'a' is part of the main program and, hence, implicitly has the SAVE attribute.\n ! The  'cfi = 0' appears before the call due to the deallocate and when preparing the C descriptor\n ! As cfi (i.e. the descriptor itself) is allocated in libgomp, it has to be freed after the call.\n \n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 2 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(cfi\\\\.\\[0-9\\]+\\\\);\" 2 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"cfi\\\\.\\[0-9\\]+ = 0B;\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(_x->base_addr\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_x->base_addr = 0B;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(cfi\\\\.\\[0-9\\]+\\\\.base_addr\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"cfi\\\\.\\[0-9\\]+\\\\.base_addr = 0B;\" 1 \"original\" } }"}, {"sha": "8dd7e8fb0887b29c2934c4e906db29d96e0487a3", "filename": "gcc/testsuite/gfortran.dg/bind_c_array_params_2.f90", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -22,4 +22,32 @@ end subroutine test\n ! { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,myBindC\" 1 { target { s390*-*-* } } } }\n ! { dg-final { scan-assembler-times \"bl \\.myBindC\" 1 { target { powerpc-ibm-aix* } } } }\n ! { dg-final { scan-assembler-times \"add_u32\\t\\[sv\\]\\[0-9\\]*, \\[sv\\]\\[0-9\\]*, myBindC@rel32@lo\" 1 { target { amdgcn*-*-* } } } }\n-! { dg-final { scan-tree-dump-times \"gfc_desc_to_cfi_desc \\\\\\(&cfi\\\\.\" 1 \"original\" } }\n+\n+\n+! { dg-final { scan-tree-dump \"parm...span = 4;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...dtype = {.elem_len=4, .rank=2, .type=1};\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...dim\\\\\\[0\\\\\\].lbound = 1;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...dim\\\\\\[0\\\\\\].ubound = 4;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...dim\\\\\\[0\\\\\\].stride = 1;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...dim\\\\\\[1\\\\\\].lbound = 1;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...dim\\\\\\[1\\\\\\].ubound = 4;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...dim\\\\\\[1\\\\\\].stride = 4;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...data = \\\\(void \\\\*\\\\) &aa\\\\\\[0\\\\\\];\" \"original\" } }\n+! { dg-final { scan-tree-dump \"parm...offset = -5;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...version = 1;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...rank = 2;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...type = 1025;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...attribute = 2;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...base_addr = parm.0.data;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...elem_len = 4;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"idx.2 = 0;\" \"original\" } }\n+\n+! { dg-final { scan-tree-dump \"if \\\\(idx.. <= 1\\\\) goto L..;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...dim\\\\\\[idx..\\\\\\].lower_bound = 0;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...dim\\\\\\[idx..\\\\\\].extent = \\\\(parm...dim\\\\\\[idx..\\\\\\].ubound - parm...dim\\\\\\[idx..\\\\\\].lbound\\\\) \\\\+ 1;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...dim\\\\\\[idx..\\\\\\].sm = parm...dim\\\\\\[idx..\\\\\\].stride \\\\* parm...span;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"idx.. = idx.. \\\\+ 1;\" \"original\" } }\n+\n+! { dg-final { scan-tree-dump \"test \\\\(&cfi..\\\\);\" \"original\" } }\n+\n+"}, {"sha": "7c6f4dcc961d0de5a092810325d4f749e9e043fe", "filename": "gcc/testsuite/gfortran.dg/bind_c_char_10.f90", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_10.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -466,15 +466,16 @@ program main\n end\n \n ! All arguments shall use array descriptors\n-! { dg-final { scan-tree-dump-times \"void as1 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict x1\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void as2 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict x2\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void as4 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict xstar\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void as3 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict xn, integer(kind=4) & restrict n)\n-! { dg-final { scan-tree-dump-times \"void ar1 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict x1\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void ar2 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict x2\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void ar3 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict xn, integer(kind=4) & restrict n)\n-! { dg-final { scan-tree-dump-times \"void ar4 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict xstar\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void a5a \\\\(struct array01_character\\\\(kind=1\\\\) & restrict xcolon\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void a5ar \\\\(struct array15_character\\\\(kind=1\\\\) & restrict xcolon\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void a5p \\\\(struct array01_character\\\\(kind=1\\\\) & xcolon\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"void a5pr \\\\(struct array15_character\\\\(kind=1\\\\) & xcolon\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void as1 \\\\(struct CFI_cdesc_t01 & restrict _x1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void as2 \\\\(struct CFI_cdesc_t01 & restrict _x2\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void as3 \\\\(struct CFI_cdesc_t01 & restrict _xn, integer\\\\(kind=4\\\\) & restrict n\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void as4 \\\\(struct CFI_cdesc_t01 & restrict _xstar\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ar1 \\\\(struct CFI_cdesc_t & restrict _x1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ar2 \\\\(struct CFI_cdesc_t & restrict _x2\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ar3 \\\\(struct CFI_cdesc_t & restrict _xn, integer\\\\(kind=4\\\\) & restrict n\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ar4 \\\\(struct CFI_cdesc_t & restrict _xstar\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5ar \\\\(struct CFI_cdesc_t & restrict _xcolon\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5a \\\\(struct CFI_cdesc_t01 & restrict _xcolon\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5pr \\\\(struct CFI_cdesc_t & _xcolon\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5p \\\\(struct CFI_cdesc_t01 & _xcolon\\\\)\" 1 \"original\" } }\n+"}, {"sha": "8e6413d0bf4948228ee3d4122f26394f9db4c696", "filename": "gcc/testsuite/gfortran.dg/bind_c_char_8.f90", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_8.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -28,7 +28,7 @@ subroutine s3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1.\n   character(len=n) :: xn\n end\n \n-subroutine s4 (xstar) bind(C) ! { dg-error \"Sorry, character dummy argument 'xstar' at .1. with assumed length is not yet supported for procedure 's4' with BIND\\\\(C\\\\) attribute\" }\n+subroutine s4 (xstar) bind(C)\n   character(len=*) :: xstar\n end\n \n@@ -85,7 +85,7 @@ subroutine az3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1\n   character(len=n) :: xn(*)\n end\n \n-subroutine az4 (xstar) bind(C)  ! { dg-error \"Sorry, character dummy argument 'xstar' at .1. with assumed length is not yet supported for procedure 'az4' with BIND\\\\(C\\\\) attribute\" }\n+subroutine az4 (xstar) bind(C)\n   character(len=*) :: xstar(*)\n end\n \n@@ -104,7 +104,7 @@ subroutine ae3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1\n   character(len=n) :: xn(9)\n end\n \n-subroutine ae4 (xstar) bind(C) ! { dg-error \"Sorry, character dummy argument 'xstar' at .1. with assumed length is not yet supported for procedure 'ae4' with BIND\\\\(C\\\\) attribute\" }\n+subroutine ae4 (xstar) bind(C)\n   character(len=*) :: xstar(3)\n end\n \n@@ -128,7 +128,7 @@ subroutine s4a (xstar) bind(C) ! { dg-error \"Allocatable character dummy argumen\n   character(len=*), allocatable :: xstar\n end\n \n-subroutine s5a (xcolon) bind(C) ! { dg-error \"Sorry, deferred-length scalar character dummy argument 'xcolon' at .1. of procedure 's5a' with BIND\\\\(C\\\\) not yet supported\" }\n+subroutine s5a (xcolon) bind(C)\n   character(len=:), allocatable :: xcolon\n end\n \n@@ -198,7 +198,7 @@ subroutine s4p (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'x\n   character(len=*), pointer :: xstar\n end\n \n-subroutine s5p (xcolon) bind(C) ! { dg-error \"Sorry, deferred-length scalar character dummy argument 'xcolon' at .1. of procedure 's5p' with BIND\\\\(C\\\\) not yet supported\" }\n+subroutine s5p (xcolon) bind(C)\n   character(len=:), pointer :: xcolon\n end\n "}, {"sha": "1d0cf65ba0c940d8bbc2c90a560799215cf512fa", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocatable-dummy.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,6 +1,6 @@\n ! PR 101308\n ! PR 92621(?)\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"allocatable-dummy-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "fb91107bd9b8564a35b4442cfff72a6edc6d170f", "filename": "gcc/testsuite/gfortran.dg/c-interop/c1255-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-1.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -56,7 +56,7 @@ subroutine s5 (x) bind (c)\n     end subroutine\n \n     ! dummy is assumed length character variable\n-    subroutine s6 (x) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine s6 (x) bind (c)\n       use ISO_C_BINDING\n       implicit none\n       character(len=*) :: x"}, {"sha": "699f75f614265395efb181aef3feea3e032505e5", "filename": "gcc/testsuite/gfortran.dg/c-interop/c407c-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407c-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407c-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407c-1.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -44,7 +44,7 @@ subroutine s2 (x)\n   implicit none\n   type(*) :: x(*)\n \n-  call g (x, 1)  ! { dg-error \"Assumed.type\" }\n+  call g (x, 1)  ! { dg-error \"Assumed-type actual argument at .1. corresponding to assumed-rank dummy argument 'a' must be assumed-shape or assumed-rank\" }\n end subroutine\n \n ! Check that a scalar gives an error."}, {"sha": "b5edf5284173790f3b347708e20b63a27f2a1009", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -7,7 +7,7 @@\n ! in C works and that you can use it to call back into a Fortran function \n ! with an assumed-length dummy that is declared with C binding.\n \n-subroutine ftest (a, n) bind (c, name=\"ftest\")  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+subroutine ftest (a, n) bind (c, name=\"ftest\")\n   use iso_c_binding\n   character(kind=C_CHAR, len=*) :: a\n   integer(C_INT), value :: n"}, {"sha": "d85a78a8a6c51cf5849960e6619e6774e64a6092", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 92621 (?)\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"cf-out-descriptor-3-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "e14c7571ea2dbfc951a24c2098d9dc329900bfdd", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 92621 (?)\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"cf-out-descriptor-4-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "b0dd20ce5f85cb31ca858c91881261042b93f877", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-5.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -6,7 +6,7 @@\n ! This program checks use of an assumed-length character dummy argument\n ! as an intent(out) parameter in subroutines with C binding.\n \n-subroutine ftest (a, n) bind (c, name=\"ftest\")  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+subroutine ftest (a, n) bind (c, name=\"ftest\")\n   use iso_c_binding\n   character(kind=C_CHAR, len=*), intent(out) :: a\n   integer(C_INT), value :: n\n@@ -20,13 +20,13 @@ program testit\n   implicit none\n \n   interface\n-    subroutine ctest (a, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine ctest (a, n) bind (c)\n       use iso_c_binding\n       character(kind=C_CHAR, len=*), intent(out) :: a\n       integer(C_INT), value :: n\n     end subroutine\n \n-    subroutine ftest (a, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine ftest (a, n) bind (c)\n       use iso_c_binding\n       character(kind=C_CHAR, len=*), intent(out) :: a\n       integer(C_INT), value :: n"}, {"sha": "195ec8c183cad9a2a69850af6f0c449fa6153022", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 101304\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"contiguous-2-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "0a295721c5b498020f67e7c3f57c89a50581d163", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 101304\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"contiguous-3-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "3c3c2574101c4c514339a352e852b4ced322b0ea", "filename": "gcc/testsuite/gfortran.dg/c-interop/deferred-character-1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-1.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -16,12 +16,12 @@ module m\n   interface\n \n     ! These are supposed to be OK\n-    subroutine good1 (x, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine good1 (x, n) bind (c)\n       use iso_c_binding\n       character (kind=C_CHAR, len=:), allocatable :: x\n       integer(C_INT), value :: n\n     end subroutine\n-    subroutine good2 (x, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine good2 (x, n) bind (c)\n       use iso_c_binding\n       character (kind=C_CHAR, len=:), pointer :: x\n       integer(C_INT), value :: n"}, {"sha": "356097af2411ba607d4b4404d2d90070fa00c7e9", "filename": "gcc/testsuite/gfortran.dg/c-interop/deferred-character-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-2.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -43,7 +43,7 @@ subroutine frobf (a, p)\n       p = 'bar'\n     end subroutine\n \n-    subroutine frobc (a, p) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine frobc (a, p) bind (c)\n       use iso_c_binding\n       character (kind=C_CHAR, len=:), allocatable :: a\n       character (kind=C_CHAR, len=:), pointer :: p"}, {"sha": "c65cb7a3944c2793388ce31fd6350602517fc118", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 101308\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"fc-descriptor-3-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "eda65b431db5a6770c7f76d8b1314961122f48ad", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -11,7 +11,7 @@ program testit\n   implicit none\n \n   interface\n-    subroutine ctest (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine ctest (a) bind (c)\n       use iso_c_binding\n       character(len=*,kind=C_CHAR) :: a\n     end subroutine"}, {"sha": "1d6d006853dd20ca9a971fc6934161829d42d737", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! Reported as pr94070.\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"fc-descriptor-6-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "035de03636abe1e5932b53cd91eab21fe869741f", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-7-c.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7-c.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -3,14 +3,18 @@\n #include <ISO_Fortran_binding.h>\n #include \"dump-descriptors.h\"\n \n-extern void ctest (CFI_cdesc_t *a);\n+extern void ctest (CFI_cdesc_t *, _Bool);\n \n void\n-ctest (CFI_cdesc_t *a)\n+ctest (CFI_cdesc_t *a, _Bool is_cont)\n {\n+  CFI_index_t subscripts[2];\n   /* Dump the descriptor contents to test that we can access the fields\n      correctly, etc.  */\n+\n+#if DEBUG\n   dump_CFI_cdesc_t (a);\n+#endif\n \n   /* We expect to get an array of shape (5,10) that may not be\n      contiguous.  */\n@@ -33,14 +37,17 @@ ctest (CFI_cdesc_t *a)\n   if (a->dim[1].extent != 10)\n     abort ();\n \n-  /* There shall be an ordering of the dimensions such that the absolute\n-     value of the sm member of the first dimension is not less than the \n-     elem_len member of the C descriptor and the absolute value of the sm \n-     member of each subsequent dimension is not less than the absolute \n-     value of the sm member of the previous dimension multiplied\n-     by the extent of the previous dimension.  */\n-  if (abs (a->dim[0].sm) < a->elem_len)\n+  if (is_cont != CFI_is_contiguous (a))\n     abort ();\n-  if (abs (a->dim[1].sm) < abs (a->dim[0].sm) * a->dim[0].extent)\n+\n+  if (abs (a->dim[0].sm) < a->elem_len)\n     abort ();\n+\n+  for (int j = 0; j < 5; ++j)\n+    for (int i = 0; i < 10; ++i)\n+      {\n+\tsubscripts[0] = j; subscripts[1] = i;\n+\tif (*(int *) CFI_address (a, subscripts) != (i+1) + 100*(j+1))\n+\t  abort ();\n+      }\n }"}, {"sha": "40f2e33a4c9876057485e061e7bc1efc42f2120b", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-7.f90", "status": "modified", "additions": 122, "deletions": 12, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 101309\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"fc-descriptor-7-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !\n@@ -8,30 +8,140 @@\n \n program testit\n   use iso_c_binding\n-  implicit none\n+  implicit none (type, external)\n \n   interface\n-    subroutine ctest (a) bind (c)\n+    subroutine ctest (a, is_cont) bind (c)\n       use iso_c_binding\n-      integer(C_INT), intent (in) :: a(:,:)\n+      integer(C_INT) :: a(:,:)\n+      logical(C_Bool), value :: is_cont\n+    end subroutine\n+    subroutine ctest_cont (a, is_cont) bind (c, name=\"ctest\")\n+      use iso_c_binding\n+      integer(C_INT), contiguous :: a(:,:)\n+      logical(C_Bool), value :: is_cont\n+    end subroutine\n+\n+    subroutine ctest_ar (a, is_cont) bind (c, name=\"ctest\")\n+      use iso_c_binding\n+      integer(C_INT) :: a(..)\n+      logical(C_Bool), value :: is_cont\n+    end subroutine\n+    subroutine ctest_ar_cont (a, is_cont) bind (c, name=\"ctest\")\n+      use iso_c_binding\n+      integer(C_INT), contiguous :: a(..)\n+      logical(C_Bool), value :: is_cont\n     end subroutine\n   end interface\n \n+  integer :: i , j\n   integer(C_INT), target :: aa(10,5)\n   integer(C_INT), target :: bb(10,10)\n \n+  ! Original array\n+  do j = 1, 5\n+    do i = 1, 10\n+      aa(i,j) = i + 100*j\n+    end do\n+  end do\n+\n+  ! Transposed array\n+  do j = 2, 10, 2 \n+    do i = 1, 10\n+      bb(j, i) = i + 100*((j-2)/2 + 1)\n+    end do\n+  end do\n+ \n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+\n   ! Test both calling the C function directly, and via another function\n-  ! that takes an assumed-shape argument.\n-  call ctest (transpose (aa))\n-  call ftest (transpose (aa))\n-  call ctest (bb(2:10:2, :))\n-  call ftest (bb(2:10:2, :))\n+  ! that takes an assumed-shape/assumed-rank argument.\n+\n+  call ftest (transpose (aa), is_cont=.true._c_bool) ! Implementation choice: copy in; hence, contiguous\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+\n+  call ctest (transpose (aa), is_cont=.false._c_bool)  ! Implementation choice: noncontigous / sm inversed\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+  call ctest_cont (transpose (aa), is_cont=.true._c_bool)\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+  call ctest_ar (transpose (aa), is_cont=.false._c_bool)  ! Implementation choice: noncontigous / sm inversed\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+  call ctest_ar_cont (transpose (aa), is_cont=.true._c_bool)\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+\n+\n+  call ftest (bb(2:10:2, :), is_cont=.false._c_bool)\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+\n+  call ctest (bb(2:10:2, :), is_cont=.false._c_bool)\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+  call ctest_cont (bb(2:10:2, :), is_cont=.true._c_bool)\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+  call ctest_ar (bb(2:10:2, :), is_cont=.false._c_bool)\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n+  call ctest_ar_cont (bb(2:10:2, :), is_cont=.true._c_bool)\n+  if (any (transpose (aa) /= bb(2:10:2, :))) error stop 1\n \n contains\n-  subroutine ftest (a)\n+  subroutine ftest (a, is_cont)\n     use iso_c_binding\n-    integer(C_INT), intent(in) :: a(:,:)\n-    call ctest (a)\n+    integer(C_INT) :: a(:,:)\n+    logical(c_bool), value, intent(in) :: is_cont\n+    if (is_cont .NEQV. is_contiguous (a)) error stop 2\n+    if (any (shape (a) /= [5, 10])) error stop 3\n+    do j = 1, 5\n+      do i = 1, 10\n+        if (a(j, i) /= i + 100*j) error stop 4\n+        if (a(j, i) /= aa(i,j)) error stop \n+      end do\n+    end do\n+    call ctest (a, is_cont)\n+    call ctest_cont (a, is_cont=.true._c_bool)\n+    call ctest_ar (a, is_cont)\n+    call ctest_ar_cont (a, is_cont=.true._c_bool)\n   end subroutine\n \n+  subroutine ftest_ar (a, is_cont)\n+    use iso_c_binding\n+    integer(C_INT) :: a(..)\n+    logical(c_bool), value, intent(in) :: is_cont\n+    if (is_cont .NEQV. is_contiguous (a)) error stop 2\n+    if (any (shape (a) /= [5, 10])) error stop 3\n+    select rank (a)\n+    rank(2)\n+      do j = 1, 5\n+        do i = 1, 10\n+          if (a(j, i) /= i + 100*j) error stop 4\n+          if (a(j, i) /= aa(i,j)) error stop \n+        end do\n+      end do\n+      call ctest (a, is_cont)\n+      call ctest_cont (a, is_cont=.true._c_bool)\n+      call ftest_ar_con (a, is_cont=.true._c_bool)\n+    end select\n+    call ctest_ar (a, is_cont)\n+    ! call ctest_ar_cont (a, is_cont=.true._c_bool)  ! TODO/FIXME: ICE, cf. PR fortran/102729\n+    ! call ftest_ar_con (a, is_cont=.true._c_bool)   ! TODO/FIXME: ICE, cf. PR fortran/102729\n+  end subroutine\n+\n+  subroutine ftest_ar_con (a, is_cont)\n+    use iso_c_binding\n+    integer(C_INT), contiguous :: a(..)\n+    logical(c_bool), value, intent(in) :: is_cont\n+    if (is_cont .NEQV. is_contiguous (a)) error stop 2\n+    if (any (shape (a) /= [5, 10])) error stop 3\n+    select rank (a)\n+    rank(2)\n+      do j = 1, 5\n+        do i = 1, 10\n+          if (a(j, i) /= i + 100*j) error stop 4\n+          if (a(j, i) /= aa(i,j)) error stop \n+        end do\n+      end do\n+      call ctest (a, is_cont)\n+      call ctest_cont (a, is_cont=.true._c_bool)\n+    end select\n+    call ctest_ar (a, is_cont)\n+    call ctest_ar_cont (a, is_cont=.true._c_bool)\n+  end subroutine\n end program"}, {"sha": "00a083e269e2f1dc61cc6089789f348be6b81dca", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 101308\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"fc-out-descriptor-3-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "a26d49552006858704063921bc3b7963c7e237ea", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! PR 92621 (?)\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"fc-out-descriptor-4-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "63fc08f8bb0260776a47625556bf47c3a19f4d27", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -10,7 +10,7 @@ program testit\n   implicit none\n \n   interface\n-    subroutine ctest (a) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    subroutine ctest (a) bind (c)\n       use iso_c_binding\n       character(len=*,kind=C_CHAR), intent(out) :: a\n     end subroutine\n@@ -26,7 +26,7 @@ subroutine ctest (a) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n   call ftest (aa)\n \n contains\n-  subroutine ftest (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+  subroutine ftest (a) bind (c)\n     use iso_c_binding\n     character(len=*,kind=C_CHAR), intent(out) :: a\n     call ctest (a)"}, {"sha": "da226158a35c8b4c5723884cda20d36e530e330a", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! Reported as pr94070.\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"fc-out-descriptor-6-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "e6d17a401cdf1a64f4c7172e1e1c06f40f55be0f", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-5.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -17,7 +17,7 @@ program testit\n \n   ! C binding version\n \n-  subroutine checkc (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+  subroutine checkc (a) bind (c)\n     use iso_c_binding\n     character(len=*,kind=C_CHAR) :: a\n \n@@ -37,7 +37,7 @@ subroutine checkf (a)\n   end subroutine\n \n   ! C binding version\n-  subroutine testc (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+  subroutine testc (a) bind (c)\n     use iso_c_binding\n     character(len=*,kind=C_CHAR) :: a\n "}, {"sha": "090bb153fdb8f027cd7a2261dc2b9ba5d6569b14", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-6.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,5 +1,5 @@\n ! Reported as pr94070.\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n !\n ! This program checks that passing assumed-size arrays to\n ! and from Fortran functions with C binding works."}, {"sha": "d05de25d146f0c5a2959ec7fd2a714768e4ff3ca", "filename": "gcc/testsuite/gfortran.dg/c-interop/shape.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -15,7 +15,7 @@\n ! subroutine with an assumed-rank dummy.\n \n program test \n-\n+  implicit none\n   ! Define some arrays for testing.\n   integer, target :: x1(5)\n   integer :: y1(0:9)\n@@ -51,7 +51,7 @@ subroutine testit (a)\n     r = rank(a)\n \n     block\n-      integer :: s(r)\n+      integer :: s(r), i\n       s = shape(a)\n       do i = 1, r\n         if (s(i) .ne. size(a,i)) stop 101"}, {"sha": "ca2f49dc5318cd52165f4417d6b5c150708ba9c3", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-char-c.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char-c.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -33,3 +33,9 @@ ctest_1 (CFI_cdesc_t *arg_char, CFI_cdesc_t *arg_ucs4)\n   check (arg_ucs4, 4, CFI_type_ucs4_char);\n }\n \n+void\n+ctest_5 (CFI_cdesc_t *arg_char, CFI_cdesc_t *arg_ucs4)\n+{\n+  check (arg_char, 5*1, CFI_type_char);\n+  check (arg_ucs4, 5*4, CFI_type_ucs4_char);\n+}"}, {"sha": "71f84d0f37a34349b7d40b9e843ac784cb3fcf4c", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-char.f90", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -27,11 +27,21 @@ subroutine ctest_1 (arg_cchar, arg_ucs4) bind (c)\n       character(kind=ucs4) :: arg_ucs4(:)\n     end subroutine\n \n+    subroutine ctest_5 (arg_cchar, arg_ucs4) bind (c)\n+      use iso_c_binding\n+      integer, parameter :: ucs4  = selected_char_kind ('ISO_10646')\n+      character(kind=C_CHAR,len=*) :: arg_cchar(:)\n+      character(kind=ucs4,len=*) :: arg_ucs4(:)\n+    end subroutine\n+\n   end interface\n \n   character(kind=C_CHAR) :: var_cchar(4)\n   character(kind=ucs4) :: var_ucs4(4)\n+  character(kind=C_CHAR,len=5) :: var_cchar_5(4)\n+  character(kind=ucs4,len=5) :: var_ucs4_5(4)\n \n   call ctest_1 (var_cchar, var_ucs4)\n+  call ctest_5 (var_cchar_5, var_ucs4_5)\n \n end program"}, {"sha": "66737b2b7ce91bd807d4cab241a3a5789786bb34", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-float128.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -2,7 +2,7 @@\n ! PR 100914\n ! PR 100917\n ! Fails on x86 targets where sizeof(long double) == 16 (PR100917).\n-! { dg-do run { xfail { { x86_64*-*-* i?86*-*-* } && longdouble128 } } }\n+! { dg-do run }\n ! { dg-require-effective-target fortran_real_c_float128 }\n ! { dg-additional-sources \"typecodes-array-float128-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }"}, {"sha": "b586b1fd7ad088b7f2776e443ccb3abee1113111", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-basic.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,7 +1,7 @@\n ! PR 101305\n ! PR 100917\n ! xfailed due to PR 101308\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"typecodes-scalar-basic-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "c2275c4face8f9e42298ed0a5a11061a94b3628b", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-float128.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,7 +1,7 @@\n ! xfailed due to PR 101308\n ! PR 101305\n ! PR 100914\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-require-effective-target fortran_real_c_float128 }\n ! { dg-additional-sources \"typecodes-scalar-float128-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }"}, {"sha": "157c4ca1f6550f2d4bbb8ff31441a728d8c693dc", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-int128.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,6 +1,6 @@\n ! PR 101305\n ! xfailed due to PR 101308\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-require-effective-target fortran_integer_16 }\n ! { dg-additional-sources \"typecodes-scalar-int128-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }"}, {"sha": "ddc54f4d6728412d983d73b189641c3673403bea", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-longdouble.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -1,7 +1,7 @@\n ! xfailed due to PR 101308\n ! PR 101305\n ! PR 100917\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"typecodes-scalar-longdouble-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "2a4a618fa50043a2f3ac9d6f05c51d5a86823335", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_char_1.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -4,8 +4,7 @@\n !\n ! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>\n !\n-subroutine bar(c,d) BIND(C) ! { dg-error \"character dummy argument 'c' at .1. with assumed length is not yet supported for procedure 'bar' with BIND\\\\(C\\\\) attribute\" }\n-                            ! { dg-error \"Character dummy argument 'd' at .1. must be of constant length of one or assumed length, unless it has assumed shape or assumed rank, as procedure 'bar' has the BIND\\\\(C\\\\) attribute\" \"\" { target *-*-* } .-1 }\n+subroutine bar(c,d) BIND(C) ! { dg-error \"Character dummy argument 'd' at .1. must be of constant length of one or assumed length, unless it has assumed shape or assumed rank, as procedure 'bar' has the BIND\\\\(C\\\\) attribute\" }\n   character (len=*) c\n   character (len=2) d\n end"}, {"sha": "c7939af9df3df9da0273296cf8fe892e7e19e93f", "filename": "gcc/testsuite/gfortran.dg/pr93792.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr93792.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr93792.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr93792.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -14,4 +14,4 @@ program p\n ! { dg-error \"Parameterized type 't' does not have a component\"  \" \" { target *-*-* } 5 }\n ! { dg-error \"BOZ literal constant at .1. cannot appear\"  \" \" { target *-*-* } 6 }\n ! { dg-error \"Cannot open module file\"  \" \" { target *-*-* } 10 }\n-! { dg-excess-errors \"compilation terminated\" }\n+! { dg-prune-output \"compilation terminated\" }"}, {"sha": "6abac8f9e3a41d77e8a103137110c2301b999cc0", "filename": "libgfortran/ISO_Fortran_binding.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/libgfortran%2FISO_Fortran_binding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/libgfortran%2FISO_Fortran_binding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FISO_Fortran_binding.h?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -152,14 +152,10 @@ extern int CFI_setpointer (CFI_cdesc_t *, CFI_cdesc_t *, const CFI_index_t []);\n #define CFI_type_Complex 4\n #define CFI_type_Character 5\n \n-/* Types with no kind.  FIXME: GFC descriptors currently use BT_VOID for\n-   both C_PTR and C_FUNPTR, so we have no choice but to make them\n-   identical here too.  That can potentially break on targets where\n-   function and data pointers have different sizes/representations.\n-   See PR 100915.  */\n+/* Types with no kind.  */\n #define CFI_type_struct 6\n #define CFI_type_cptr 7\n-#define CFI_type_cfunptr CFI_type_cptr\n+#define CFI_type_cfunptr 8\n #define CFI_type_other -1\n \n /* Types with kind parameter."}, {"sha": "a247725a237a471e03be8983c841dad40d4d7e5a", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -34,6 +34,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n extern void cfi_desc_to_gfc_desc (gfc_array_void *, CFI_cdesc_t **);\n export_proto(cfi_desc_to_gfc_desc);\n \n+/* NOTE: Since GCC 12, the FE generates code to do the conversion\n+   directly without calling this function.  */\n void\n cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n {\n@@ -122,6 +124,8 @@ cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n extern void gfc_desc_to_cfi_desc (CFI_cdesc_t **, const gfc_array_void *);\n export_proto(gfc_desc_to_cfi_desc);\n \n+/* NOTE: Since GCC 12, the FE generates code to do the conversion\n+   directly without calling this function.  */\n void\n gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n {"}, {"sha": "6ad6eadbcd2104a979ceba766bc3f8d1afc94ccb", "filename": "libgomp/testsuite/libgomp.fortran/optional-bind-c.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f9623765da3306b0ab6a47997dc5d62c2ea261/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-bind-c.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f9623765da3306b0ab6a47997dc5d62c2ea261/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-bind-c.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-bind-c.f90?ref=64f9623765da3306b0ab6a47997dc5d62c2ea261", "patch": "@@ -0,0 +1,18 @@\n+! With bind(C), the C (CFI) array descriptor is converted to\n+! a Fortran array descriptor - thus, internally a PARM_DECL is\n+! converted to a VAR_DECL - check that the optional check still works\n+\n+module m\n+contains\n+subroutine foo(x, y)  bind(C)\n+  integer, optional :: x,y(:)\n+  !$omp target map(tofrom:x)\n+     if (present (x)) x = 5\n+     if (present (y)) y(1) = 5\n+  !$omp end target\n+end\n+end\n+\n+use m\n+call foo()\n+end"}]}