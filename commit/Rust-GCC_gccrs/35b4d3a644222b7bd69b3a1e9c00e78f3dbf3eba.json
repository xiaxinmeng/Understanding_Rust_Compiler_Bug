{"sha": "35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViNGQzYTY0NDIyMmI3YmQ2OWIzYTFlOWMwMGU3OGYzZGJmM2ViYQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-07-09T20:33:48Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-07-09T20:33:48Z"}, "message": "PR middle-end/77357 - strlen of constant strings not folded\n\ngcc/ChangeLog:\n\n\tPR middle-end/77357\n\tPR middle-end/86428\n\t* builtins.c (c_strlen): Avoid out-of-bounds warnings when\n\taccessing implicitly initialized array elements.\n\t* expr.c (string_constant): Handle string initializers of\n\tcharacter arrays within aggregates.\n\t* gimple-fold.c (fold_array_ctor_reference): Add argument.\n\tStore element offset.  As a special case, handle zero size.\n\t(fold_nonarray_ctor_reference): Same.\n\t(fold_ctor_reference): Add argument.  Store subobject offset.\n\t* gimple-fold.h (fold_ctor_reference): Add argument.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/77357\n\t* gcc.dg/strlenopt-49.c: New test.\n\t* gcc.dg/strlenopt-50.c: New test.\n\t* gcc.dg/strlenopt-51.c: New test.\n\t* gcc.dg/strlenopt-52.c: New test.\n\nFrom-SVN: r262522", "tree": {"sha": "a540d226c0eeee38bd5ea06483ae688c1e0c070e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a540d226c0eeee38bd5ea06483ae688c1e0c070e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aad2444d346d4ae504a938de8708341dd1889aed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aad2444d346d4ae504a938de8708341dd1889aed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aad2444d346d4ae504a938de8708341dd1889aed"}], "stats": {"total": 1028, "additions": 885, "deletions": 143}, "files": [{"sha": "dda22d8e180ace281c24687ce3f158519a4fd791", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -1,3 +1,17 @@\n+2018-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77357\n+\tPR middle-end/86428\n+\t* builtins.c (c_strlen): Avoid out-of-bounds warnings when\n+\taccessing implicitly initialized array elements.\n+\t* expr.c (string_constant): Handle string initializers of\n+\tcharacter arrays within aggregates.\n+\t* gimple-fold.c (fold_array_ctor_reference): Add argument.\n+\tStore element offset.  As a special case, handle zero size.\n+\t(fold_nonarray_ctor_reference): Same.\n+\t(fold_ctor_reference): Add argument.  Store subobject offset.\n+\t* gimple-fold.h (fold_ctor_reference): Add argument.\n+\n 2018-07-09  Paul Koning  <ni1d@arrl.net>\n \n \t* config/pdp11/pdp11.c (pdp11_addr_cost): New function."}, {"sha": "820d6c262b09e47092daeb4cb0389c34fd6b5b56", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -602,8 +602,15 @@ c_strlen (tree src, int only_value)\n     = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (src))));\n \n   /* Set MAXELTS to sizeof (SRC) / sizeof (*SRC) - 1, the maximum possible\n-     length of SRC.  */\n-  unsigned maxelts = TREE_STRING_LENGTH (src) / eltsize - 1;\n+     length of SRC.  Prefer TYPE_SIZE() to TREE_STRING_LENGTH() if possible\n+     in case the latter is less than the size of the array.  */\n+  HOST_WIDE_INT maxelts = TREE_STRING_LENGTH (src);\n+  tree type = TREE_TYPE (src);\n+  if (tree size = TYPE_SIZE_UNIT (type))\n+    if (tree_fits_shwi_p (size))\n+      maxelts = tree_to_uhwi (size);\n+\n+  maxelts = maxelts / eltsize - 1;\n \n   /* PTR can point to the byte representation of any string type, including\n      char* and wchar_t*.  */\n@@ -629,7 +636,6 @@ c_strlen (tree src, int only_value)\n \t what he gets.  Subtract the offset from the length of the string,\n \t and return that.  This would perhaps not be valid if we were dealing\n \t with named arrays in addition to literal string constants.  */\n-\n       return size_diffop_loc (loc, size_int (maxelts * eltsize), byteoff);\n     }\n "}, {"sha": "797b1f5d794a2849b3bc3a18b0af1f732430a2fd", "filename": "gcc/expr.c", "status": "modified", "additions": 112, "deletions": 81, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -54,11 +54,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"reload.h\"\n #include \"langhooks.h\"\n #include \"common/common-target.h\"\n+#include \"tree-dfa.h\"\n #include \"tree-ssa-live.h\"\n #include \"tree-outof-ssa.h\"\n #include \"tree-ssa-address.h\"\n #include \"builtins.h\"\n #include \"ccmp.h\"\n+#include \"gimple-fold.h\"\n #include \"rtx-vector-builder.h\"\n \n \n@@ -11267,61 +11269,45 @@ is_aligning_offset (const_tree offset, const_tree exp)\n }\n \f\n /* Return the tree node if an ARG corresponds to a string constant or zero\n-   if it doesn't.  If we return nonzero, set *PTR_OFFSET to the offset\n-   in bytes within the string that ARG is accessing.  The type of the\n-   offset will be `sizetype'.  */\n+   if it doesn't.  If we return nonzero, set *PTR_OFFSET to the (possibly\n+   non-constant) offset in bytes within the string that ARG is accessing.\n+   The type of the offset is sizetype.  */\n \n tree\n string_constant (tree arg, tree *ptr_offset)\n {\n-  tree array, offset, lower_bound;\n+  tree array;\n   STRIP_NOPS (arg);\n \n+  /* Non-constant index into the character array in an ARRAY_REF\n+     expression or null.  */\n+  tree varidx = NULL_TREE;\n+\n+  poly_int64 base_off = 0;\n+\n   if (TREE_CODE (arg) == ADDR_EXPR)\n     {\n-      if (TREE_CODE (TREE_OPERAND (arg, 0)) == STRING_CST)\n-\t{\n-\t  *ptr_offset = size_zero_node;\n-\t  return TREE_OPERAND (arg, 0);\n-\t}\n-      else if (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL)\n-\t{\n-\t  array = TREE_OPERAND (arg, 0);\n-\t  offset = size_zero_node;\n-\t}\n-      else if (TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF)\n+      arg = TREE_OPERAND (arg, 0);\n+      tree ref = arg;\n+      if (TREE_CODE (arg) == ARRAY_REF)\n \t{\n-\t  array = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t  offset = TREE_OPERAND (TREE_OPERAND (arg, 0), 1);\n-\t  if (TREE_CODE (array) != STRING_CST && !VAR_P (array))\n-\t    return 0;\n-\n-\t  /* Check if the array has a nonzero lower bound.  */\n-\t  lower_bound = array_ref_low_bound (TREE_OPERAND (arg, 0));\n-\t  if (!integer_zerop (lower_bound))\n+\t  tree idx = TREE_OPERAND (arg, 1);\n+\t  if (TREE_CODE (idx) != INTEGER_CST)\n \t    {\n-\t      /* If the offset and base aren't both constants, return 0.  */\n-\t      if (TREE_CODE (lower_bound) != INTEGER_CST)\n-\t        return 0;\n-\t      if (TREE_CODE (offset) != INTEGER_CST)\n-\t\treturn 0;\n-\t      /* Adjust offset by the lower bound.  */\n-\t      offset = size_diffop (fold_convert (sizetype, offset),\n-\t\t\t\t    fold_convert (sizetype, lower_bound));\n+\t      /* Extract the variable index to prevent\n+\t\t get_addr_base_and_unit_offset() from failing due to\n+\t\t it.  Use it later to compute the non-constant offset\n+\t\t into the string and return it to the caller.  */\n+\t      varidx = idx;\n+\t      ref = TREE_OPERAND (arg, 0);\n \t    }\n \t}\n-      else if (TREE_CODE (TREE_OPERAND (arg, 0)) == MEM_REF)\n-\t{\n-\t  array = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t  offset = TREE_OPERAND (TREE_OPERAND (arg, 0), 1);\n-\t  if (TREE_CODE (array) != ADDR_EXPR)\n-\t    return 0;\n-\t  array = TREE_OPERAND (array, 0);\n-\t  if (TREE_CODE (array) != STRING_CST && !VAR_P (array))\n-\t    return 0;\n-\t}\n-      else\n-\treturn 0;\n+      array = get_addr_base_and_unit_offset (ref, &base_off);\n+      if (!array\n+\t  || (TREE_CODE (array) != VAR_DECL\n+\t      && TREE_CODE (array) != CONST_DECL\n+\t      && TREE_CODE (array) != STRING_CST))\n+\treturn NULL_TREE;\n     }\n   else if (TREE_CODE (arg) == PLUS_EXPR || TREE_CODE (arg) == POINTER_PLUS_EXPR)\n     {\n@@ -11331,62 +11317,107 @@ string_constant (tree arg, tree *ptr_offset)\n       STRIP_NOPS (arg0);\n       STRIP_NOPS (arg1);\n \n-      if (TREE_CODE (arg0) == ADDR_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (arg0, 0)) == STRING_CST\n-\t      || TREE_CODE (TREE_OPERAND (arg0, 0)) == VAR_DECL))\n+      if (TREE_CODE (arg0) == ADDR_EXPR)\n+\t;   /* Do nothing.  */\n+      else if (TREE_CODE (arg1) == ADDR_EXPR)\n+\tstd::swap (arg0, arg1);\n+      else\n+\treturn NULL_TREE;\n+\n+      tree offset;\n+      if (tree str = string_constant (arg0, &offset))\n \t{\n-\t  array = TREE_OPERAND (arg0, 0);\n-\t  offset = arg1;\n+\t  tree type = TREE_TYPE (arg1);\n+\t  *ptr_offset = fold_build2 (PLUS_EXPR, type, offset, arg1);\n+\t  return str;\n \t}\n-      else if (TREE_CODE (arg1) == ADDR_EXPR\n-\t       && (TREE_CODE (TREE_OPERAND (arg1, 0)) == STRING_CST\n-\t\t   || TREE_CODE (TREE_OPERAND (arg1, 0)) == VAR_DECL))\n+      return NULL_TREE;\n+    }\n+  else if (DECL_P (arg))\n+    array = arg;\n+  else\n+    return NULL_TREE;\n+\n+  tree offset = wide_int_to_tree (sizetype, base_off);\n+  if (varidx)\n+    {\n+      if (tree eltsize = TYPE_SIZE_UNIT (TREE_TYPE (array)))\n \t{\n-\t  array = TREE_OPERAND (arg1, 0);\n-\t  offset = arg0;\n+\t  /* Add the scaled variable index to the constant offset.  */\n+\t  tree eltoff = fold_build2 (MULT_EXPR, TREE_TYPE (offset),\n+\t\t\t\t     fold_convert (sizetype, varidx),\n+\t\t\t\t     eltsize);\n+\t  offset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset), offset, eltoff);\n \t}\n       else\n-\treturn 0;\n+\treturn NULL_TREE;\n     }\n-  else\n-    return 0;\n \n   if (TREE_CODE (array) == STRING_CST)\n     {\n       *ptr_offset = fold_convert (sizetype, offset);\n       return array;\n     }\n-  else if (VAR_P (array) || TREE_CODE (array) == CONST_DECL)\n-    {\n-      int length;\n-      tree init = ctor_for_folding (array);\n \n-      /* Variables initialized to string literals can be handled too.  */\n-      if (init == error_mark_node\n-\t  || !init\n-\t  || TREE_CODE (init) != STRING_CST)\n-\treturn 0;\n+  if (!VAR_P (array) && TREE_CODE (array) != CONST_DECL)\n+    return NULL_TREE;\n \n-      /* Avoid const char foo[4] = \"abcde\";  */\n-      if (DECL_SIZE_UNIT (array) == NULL_TREE\n-\t  || TREE_CODE (DECL_SIZE_UNIT (array)) != INTEGER_CST\n-\t  || (length = TREE_STRING_LENGTH (init)) <= 0\n-\t  || compare_tree_int (DECL_SIZE_UNIT (array), length) < 0)\n-\treturn 0;\n+  tree init = ctor_for_folding (array);\n \n-      /* If variable is bigger than the string literal, OFFSET must be constant\n-\t and inside of the bounds of the string literal.  */\n-      offset = fold_convert (sizetype, offset);\n-      if (compare_tree_int (DECL_SIZE_UNIT (array), length) > 0\n-\t  && (! tree_fits_uhwi_p (offset)\n-\t      || compare_tree_int (offset, length) >= 0))\n-\treturn 0;\n+  /* Handle variables initialized with string literals.  */\n+  if (!init || init == error_mark_node)\n+    return NULL_TREE;\n+  if (TREE_CODE (init) == CONSTRUCTOR)\n+    {\n+      if (TREE_CODE (arg) != ARRAY_REF\n+\t  && TREE_CODE (arg) == COMPONENT_REF\n+\t  && TREE_CODE (arg) == MEM_REF)\n+\treturn NULL_TREE;\n+\n+      /* Convert the 64-bit constant offset to a wider type to avoid\n+\t overflow.  */\n+      offset_int wioff;\n+      if (!base_off.is_constant (&wioff))\n+\treturn NULL_TREE;\n \n-      *ptr_offset = offset;\n-      return init;\n+      wioff *= BITS_PER_UNIT;\n+      if (!wi::fits_uhwi_p (wioff))\n+\treturn NULL_TREE;\n+\n+      base_off = wioff.to_uhwi ();\n+      unsigned HOST_WIDE_INT fieldoff = 0;\n+      init = fold_ctor_reference (NULL_TREE, init, base_off, 0, array,\n+\t\t\t\t  &fieldoff);\n+      HOST_WIDE_INT cstoff;\n+      if (init && base_off.is_constant (&cstoff))\n+\t{\n+\t  cstoff = (cstoff - fieldoff) / BITS_PER_UNIT;\n+\t  offset = build_int_cst (sizetype, cstoff);\n+\t}\n     }\n \n-  return 0;\n+  if (!init || TREE_CODE (init) != STRING_CST)\n+    return NULL_TREE;\n+\n+  tree array_size = DECL_SIZE_UNIT (array);\n+  if (!array_size || TREE_CODE (array_size) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  /* Avoid returning a string that doesn't fit in the array\n+     it is stored in, like\n+     const char a[4] = \"abcde\";\n+     but do handle those that fit even if they have excess\n+     initializers, such as in\n+     const char a[4] = \"abc\\000\\000\";\n+     The excess elements contribute to TREE_STRING_LENGTH()\n+     but not to strlen().  */\n+  unsigned HOST_WIDE_INT length\n+    = strnlen (TREE_STRING_POINTER (init), TREE_STRING_LENGTH (init));\n+  if (compare_tree_int (array_size, length + 1) < 0)\n+    return NULL_TREE;\n+\n+  *ptr_offset = offset;\n+  return init;\n }\n \f\n /* Generate code to calculate OPS, and exploded expression"}, {"sha": "97c435fa5e0dcf4345b10ea214ffc244cd6e2b7d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -14546,14 +14546,19 @@ fold_build_pointer_plus_hwi_loc (location_t loc, tree ptr, HOST_WIDE_INT off)\n \t\t\t  ptr, size_int (off));\n }\n \n-/* Return a char pointer for a C string if it is a string constant\n-   or sum of string constant and integer constant.  We only support\n-   string constants properly terminated with '\\0' character.\n-   If STRLEN is a valid pointer, length (including terminating character)\n-   of returned string is stored to the argument.  */\n+/* Return a pointer P to a NUL-terminated string representing the sequence\n+   of constant characters referred to by SRC (or a subsequence of such\n+   characters within it if SRC is a reference to a string plus some\n+   constant offset).  If STRLEN is non-null, store stgrlen(P) in *STRLEN.\n+   If STRSIZE is non-null, store in *STRSIZE the size of the array\n+   the string is stored in; in that case, even though P points to a NUL\n+   terminated string, SRC need not refer to one.  This can happen when\n+   SRC refers to a constant character array initialized to all non-NUL\n+   values, as in the C declaration: char a[4] = \"1234\";  */\n \n const char *\n-c_getstr (tree src, unsigned HOST_WIDE_INT *strlen)\n+c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */,\n+\t  unsigned HOST_WIDE_INT *strsize /* = NULL */)\n {\n   tree offset_node;\n \n@@ -14573,18 +14578,47 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strlen)\n \toffset = tree_to_uhwi (offset_node);\n     }\n \n+  /* STRING_LENGTH is the size of the string literal, including any\n+     embedded NULs.  STRING_SIZE is the size of the array the string\n+     literal is stored in.  */\n   unsigned HOST_WIDE_INT string_length = TREE_STRING_LENGTH (src);\n+  unsigned HOST_WIDE_INT string_size = string_length;\n+  tree type = TREE_TYPE (src);\n+  if (tree size = TYPE_SIZE_UNIT (type))\n+    if (tree_fits_shwi_p (size))\n+      string_size = tree_to_uhwi (size);\n+\n+  if (strlen)\n+    {\n+      /* Compute and store the length of the substring at OFFSET.\n+\t All offsets past the initial length refer to null strings.  */\n+      if (offset <= string_length)\n+\t*strlen = string_length - offset;\n+      else\n+\t*strlen = 0;\n+    }\n+\n   const char *string = TREE_STRING_POINTER (src);\n \n-  /* Support only properly null-terminated strings.  */\n   if (string_length == 0\n-      || string[string_length - 1] != '\\0'\n-      || offset >= string_length)\n+      || offset >= string_size)\n     return NULL;\n \n-  if (strlen)\n-    *strlen = string_length - offset;\n-  return string + offset;\n+  if (strsize)\n+    {\n+      /* Support even constant character arrays that aren't proper\n+\t NUL-terminated strings.  */\n+      *strsize = string_size;\n+    }\n+  else if (string[string_length - 1] != '\\0')\n+    {\n+      /* Support only properly NUL-terminated strings but handle\n+\t consecutive strings within the same array, such as the six\n+\t substrings in \"1\\0002\\0003\".  */\n+      return NULL;\n+    }\n+\n+  return offset <= string_length ? string + offset : \"\";\n }\n \n /* Given a tree T, compute which bits in T may be nonzero.  */"}, {"sha": "4613a62e1f604c9f481889eaa68367717afde200", "filename": "gcc/fold-const.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -183,7 +183,8 @@ extern bool expr_not_equal_to (tree t, const wide_int &);\n extern tree const_unop (enum tree_code, tree, tree);\n extern tree const_binop (enum tree_code, tree, tree, tree);\n extern bool negate_mathfn_p (combined_fn);\n-extern const char *c_getstr (tree, unsigned HOST_WIDE_INT *strlen = NULL);\n+extern const char *c_getstr (tree, unsigned HOST_WIDE_INT * = NULL,\n+\t\t\t     unsigned HOST_WIDE_INT * = NULL);\n extern wide_int tree_nonzero_bits (const_tree);\n \n /* Return OFF converted to a pointer offset type suitable as offset for"}, {"sha": "a6b42834d3291b0fea10f4ca7a2a58ff8336d3bb", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 106, "deletions": 39, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -6476,14 +6476,19 @@ get_base_constructor (tree base, poly_int64_pod *bit_offset,\n     }\n }\n \n-/* CTOR is CONSTRUCTOR of an array type.  Fold reference of type TYPE and size\n-   SIZE to the memory at bit OFFSET.  */\n+/* CTOR is CONSTRUCTOR of an array type.  Fold a reference of SIZE bits\n+   to the memory at bit OFFSET.     When non-null, TYPE is the expected\n+   type of the reference; otherwise the type of the referenced element\n+   is used instead. When SIZE is zero, attempt to fold a reference to\n+   the entire element which OFFSET refers to.  Increment *SUBOFF by\n+   the bit offset of the accessed element.  */\n \n static tree\n fold_array_ctor_reference (tree type, tree ctor,\n \t\t\t   unsigned HOST_WIDE_INT offset,\n \t\t\t   unsigned HOST_WIDE_INT size,\n-\t\t\t   tree from_decl)\n+\t\t\t   tree from_decl,\n+\t\t\t   unsigned HOST_WIDE_INT *suboff)\n {\n   offset_int low_bound;\n   offset_int elt_size;\n@@ -6508,12 +6513,13 @@ fold_array_ctor_reference (tree type, tree ctor,\n     return NULL_TREE;\n   elt_size = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ctor))));\n \n-  /* We can handle only constantly sized accesses that are known to not\n-     be larger than size of array element.  */\n-  if (!TYPE_SIZE_UNIT (type)\n-      || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST\n-      || elt_size < wi::to_offset (TYPE_SIZE_UNIT (type))\n-      || elt_size == 0)\n+  /* When TYPE is non-null, verify that it specifies a constant-sized\n+     accessed not larger than size of array element.  */\n+  if (type\n+      && (!TYPE_SIZE_UNIT (type)\n+\t  || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST\n+\t  || elt_size < wi::to_offset (TYPE_SIZE_UNIT (type))\n+\t  || elt_size == 0))\n     return NULL_TREE;\n \n   /* Compute the array index we look for.  */\n@@ -6529,21 +6535,42 @@ fold_array_ctor_reference (tree type, tree ctor,\n   if (inner_offset + size > elt_size.to_uhwi () * BITS_PER_UNIT)\n     return NULL_TREE;\n   if (tree val = get_array_ctor_element_at_index (ctor, access_index))\n-    return fold_ctor_reference (type, val, inner_offset, size, from_decl);\n+    {\n+      if (!size && TREE_CODE (val) != CONSTRUCTOR)\n+\t{\n+\t  /* For the final reference to the entire accessed element\n+\t     (SIZE is zero), reset INNER_OFFSET, disegard TYPE (which\n+\t     may be null) in favor of the type of the element, and set\n+\t     SIZE to the size of the accessed element.  */\n+\t  inner_offset = 0;\n+\t  type = TREE_TYPE (val);\n+\t  size = elt_size.to_uhwi () * BITS_PER_UNIT;\n+\t}\n+\n+      *suboff += (access_index * elt_size * BITS_PER_UNIT).to_uhwi ();\n+      return fold_ctor_reference (type, val, inner_offset, size, from_decl,\n+\t\t\t\t  suboff);\n+    }\n \n-  /* When memory is not explicitely mentioned in constructor,\n-     it is 0 (or out of range).  */\n-  return build_zero_cst (type);\n+  /* Memory not explicitly mentioned in constructor is 0 (or\n+     the reference is out of range).  */\n+  return type ? build_zero_cst (type) : NULL_TREE;\n }\n \n-/* CTOR is CONSTRUCTOR of an aggregate or vector.\n-   Fold reference of type TYPE and size SIZE to the memory at bit OFFSET.  */\n+/* CTOR is CONSTRUCTOR of an aggregate or vector.  Fold a reference\n+   of SIZE bits to the memory at bit OFFSET.   When non-null, TYPE\n+   is the expected type of the reference; otherwise the type of\n+   the referenced member is used instead.  When SIZE is zero,\n+   attempt to fold a reference to the entire member which OFFSET\n+   refers to; in this case.  Increment *SUBOFF by the bit offset\n+   of the accessed member.  */\n \n static tree\n fold_nonarray_ctor_reference (tree type, tree ctor,\n \t\t\t      unsigned HOST_WIDE_INT offset,\n \t\t\t      unsigned HOST_WIDE_INT size,\n-\t\t\t      tree from_decl)\n+\t\t\t      tree from_decl,\n+\t\t\t      unsigned HOST_WIDE_INT *suboff)\n {\n   unsigned HOST_WIDE_INT cnt;\n   tree cfield, cval;\n@@ -6554,8 +6581,13 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n       tree byte_offset = DECL_FIELD_OFFSET (cfield);\n       tree field_offset = DECL_FIELD_BIT_OFFSET (cfield);\n       tree field_size = DECL_SIZE (cfield);\n-      offset_int bitoffset;\n-      offset_int bitoffset_end, access_end;\n+\n+      if (!field_size)\n+\t{\n+\t  /* Determine the size of the flexible array member from\n+\t     the size of the initializer provided for it.  */\n+\t  field_size = TYPE_SIZE (TREE_TYPE (cval));\n+\t}\n \n       /* Variable sized objects in static constructors makes no sense,\n \t but field_size can be NULL for flexible array members.  */\n@@ -6566,50 +6598,82 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n \t\t      : TREE_CODE (TREE_TYPE (cfield)) == ARRAY_TYPE));\n \n       /* Compute bit offset of the field.  */\n-      bitoffset = (wi::to_offset (field_offset)\n-\t\t   + (wi::to_offset (byte_offset) << LOG2_BITS_PER_UNIT));\n+      offset_int bitoffset\n+\t= (wi::to_offset (field_offset)\n+\t   + (wi::to_offset (byte_offset) << LOG2_BITS_PER_UNIT));\n       /* Compute bit offset where the field ends.  */\n+      offset_int bitoffset_end;\n       if (field_size != NULL_TREE)\n \tbitoffset_end = bitoffset + wi::to_offset (field_size);\n       else\n \tbitoffset_end = 0;\n \n-      access_end = offset_int (offset) + size;\n+      /* Compute the bit offset of the end of the desired access.\n+\t As a special case, if the size of the desired access is\n+\t zero, assume the access is to the entire field (and let\n+\t the caller make any necessary adjustments by storing\n+\t the actual bounds of the field in FIELDBOUNDS).  */\n+      offset_int access_end = offset_int (offset);\n+      if (size)\n+\taccess_end += size;\n+      else\n+\taccess_end = bitoffset_end;\n \n-      /* Is there any overlap between [OFFSET, OFFSET+SIZE) and\n-\t [BITOFFSET, BITOFFSET_END)?  */\n+      /* Is there any overlap between the desired access at\n+\t [OFFSET, OFFSET+SIZE) and the offset of the field within\n+\t the object at [BITOFFSET, BITOFFSET_END)?  */\n       if (wi::cmps (access_end, bitoffset) > 0\n \t  && (field_size == NULL_TREE\n \t      || wi::lts_p (offset, bitoffset_end)))\n \t{\n-\t  offset_int inner_offset = offset_int (offset) - bitoffset;\n-\t  /* We do have overlap.  Now see if field is large enough to\n-\t     cover the access.  Give up for accesses spanning multiple\n-\t     fields.  */\n+\t  *suboff += bitoffset.to_uhwi ();\n+\n+\t  if (!size && TREE_CODE (cval) != CONSTRUCTOR)\n+\t    {\n+\t      /* For the final reference to the entire accessed member\n+\t\t (SIZE is zero), reset OFFSET, disegard TYPE (which may\n+\t\t be null) in favor of the type of the member, and set\n+\t\t SIZE to the size of the accessed member.  */\n+\t      offset = bitoffset.to_uhwi ();\n+\t      type = TREE_TYPE (cval);\n+\t      size = (bitoffset_end - bitoffset).to_uhwi ();\n+\t    }\n+\n+\t  /* We do have overlap.  Now see if the field is large enough\n+\t     to cover the access.  Give up for accesses that extend\n+\t     beyond the end of the object or that span multiple fields.  */\n \t  if (wi::cmps (access_end, bitoffset_end) > 0)\n \t    return NULL_TREE;\n \t  if (offset < bitoffset)\n \t    return NULL_TREE;\n+\n+\t  offset_int inner_offset = offset_int (offset) - bitoffset;\n \t  return fold_ctor_reference (type, cval,\n \t\t\t\t      inner_offset.to_uhwi (), size,\n-\t\t\t\t      from_decl);\n+\t\t\t\t      from_decl, suboff);\n \t}\n     }\n-  /* When memory is not explicitely mentioned in constructor, it is 0.  */\n-  return build_zero_cst (type);\n+  /* Memory not explicitly mentioned in constructor is 0.  */\n+  return type ? build_zero_cst (type) : NULL_TREE;\n }\n \n-/* CTOR is value initializing memory, fold reference of type TYPE and\n-   size POLY_SIZE to the memory at bit POLY_OFFSET.  */\n+/* CTOR is value initializing memory.  Fold a reference of TYPE and\n+   bit size POLY_SIZE to the memory at bit POLY_OFFSET.  When SIZE\n+   is zero, attempt to fold a reference to the entire subobject\n+   which OFFSET refers to.  This is used when folding accesses to\n+   string members of aggregates.  When non-null, set *SUBOFF to\n+   the bit offset of the accessed subobject.  */\n \n tree\n-fold_ctor_reference (tree type, tree ctor, poly_uint64 poly_offset,\n-\t\t     poly_uint64 poly_size, tree from_decl)\n+fold_ctor_reference (tree type, tree ctor, const poly_uint64 &poly_offset,\n+\t\t     const poly_uint64 &poly_size, tree from_decl,\n+\t\t     unsigned HOST_WIDE_INT *suboff /* = NULL */)\n {\n   tree ret;\n \n   /* We found the field with exact match.  */\n-  if (useless_type_conversion_p (type, TREE_TYPE (ctor))\n+  if (type\n+      && useless_type_conversion_p (type, TREE_TYPE (ctor))\n       && known_eq (poly_offset, 0U))\n     return canonicalize_constructor_val (unshare_expr (ctor), from_decl);\n \n@@ -6650,14 +6714,17 @@ fold_ctor_reference (tree type, tree ctor, poly_uint64 poly_offset,\n     }\n   if (TREE_CODE (ctor) == CONSTRUCTOR)\n     {\n+      unsigned HOST_WIDE_INT dummy = 0;\n+      if (!suboff)\n+\tsuboff = &dummy;\n \n       if (TREE_CODE (TREE_TYPE (ctor)) == ARRAY_TYPE\n \t  || TREE_CODE (TREE_TYPE (ctor)) == VECTOR_TYPE)\n \treturn fold_array_ctor_reference (type, ctor, offset, size,\n-\t\t\t\t\t  from_decl);\n-      else\n-\treturn fold_nonarray_ctor_reference (type, ctor, offset, size,\n-\t\t\t\t\t     from_decl);\n+\t\t\t\t\t  from_decl, suboff);\n+\n+      return fold_nonarray_ctor_reference (type, ctor, offset, size,\n+\t\t\t\t\t   from_decl, suboff);\n     }\n \n   return NULL_TREE;"}, {"sha": "04e9bfa0851bb6dfc2e5fcab0468ac73048fe5a3", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -45,7 +45,9 @@ extern tree follow_all_ssa_edges (tree);\n extern tree gimple_fold_stmt_to_constant_1 (gimple *, tree (*) (tree),\n \t\t\t\t\t    tree (*) (tree) = no_follow_ssa_edges);\n extern tree gimple_fold_stmt_to_constant (gimple *, tree (*) (tree));\n-extern tree fold_ctor_reference (tree, tree, poly_uint64, poly_uint64, tree);\n+extern tree fold_ctor_reference (tree, tree, const poly_uint64&,\n+\t\t\t\t const poly_uint64&, tree,\n+\t\t\t\t unsigned HOST_WIDE_INT * = NULL);\n extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n extern tree fold_const_aggregate_ref (tree);\n extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree,"}, {"sha": "48e1f7d2436624ee4cf80610d1e017dbc0496e4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -1,3 +1,12 @@\n+2018-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77357\n+\t* gcc.dg/strlenopt-49.c: New test.\n+\t* gcc.dg/strlenopt-50.c: New test.\n+\t* gcc.dg/strlenopt-51.c: New test.\n+\t* gcc.dg/strlenopt-52.c: New test.\n+\t* gcc.c-torture/execute/builtins/strlen-3.c: Adjust.\n+\n 2018-07-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/86420"}, {"sha": "8d36fa72cd4159abe530b7236717e76fa57933dc", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strlen-3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrlen-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrlen-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrlen-3.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -2,15 +2,17 @@\n \n    Test strlen on const variables initialized to string literals.\n \n-   Written by Jakub Jelinek, 9/14/2004.  */\n+   Written by Jakub Jelinek, 9/14/2004.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n \n extern void abort (void);\n extern __SIZE_TYPE__ strlen (const char *);\n extern char *strcpy (char *, const char *);\n static const char bar[] = \"Hello, World!\";\n static const char baz[] = \"hello, world?\";\n static const char larger[20] = \"short string\";\n-extern int inside_main;\n \n int l1 = 1;\n int x = 6;\n@@ -59,12 +61,10 @@ main_test(void)\n   if (strlen (&larger[10]) != 2)\n     abort ();\n \n-  inside_main = 0;\n-  /* This will result in strlen call, because larger\n-     array is bigger than its initializer.  */\n   if (strlen (larger + (x++ & 7)) != 5)\n     abort ();\n   if (x != 8)\n     abort ();\n-  inside_main = 1;\n }\n+\n+/* { dg-final { scan-tree-dump-not \"strlen\" \"optimized\" } } */"}, {"sha": "2e6ccd32f19e6f03aeb93bc9ca0509195016797a", "filename": "gcc/testsuite/gcc.dg/strlenopt-49.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-49.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-49.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-49.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -0,0 +1,53 @@\n+/* PR tree-optimization/86428 - strlen of const array initialized with\n+   a string of the same length not folded\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall -fdump-tree-gimple\" } */\n+\n+#include \"strlenopt.h\"\n+\n+const char a1[1] = \"\\0\";\n+const char a2[2] = \"1\\0\";\n+const char a3[3] = \"12\\0\";\n+const char a8[8] = \"1234567\\0\";\n+const char a9[9] = \"12345678\\0\";\n+\n+const char ax[9] = \"12345678\\0\\0\\0\\0\";   /* { dg-warning \"initializer-string for array of chars is too long\" } */\n+const char ay[9] = \"\\00012345678\\0\\0\\0\\0\";   /* { dg-warning \"initializer-string for array of chars is too long\" } */\n+\n+\n+int len1 (void)\n+{\n+  size_t len0 = strlen (a1);\n+  return len0;\n+}\n+\n+int len (void)\n+{\n+  size_t len = strlen (a2) + strlen (a3) + strlen (a8) + strlen (a9);\n+  return len;\n+}\n+\n+int lenx (void)\n+{\n+  size_t lenx = strlen (ax);\n+  return lenx;\n+}\n+\n+int leny (void)\n+{\n+  size_t leny = strlen (ay);\n+  return leny;\n+}\n+\n+int cmp88 (void)\n+{\n+  int cmp88 = memcmp (a8, \"1234567\\0\", sizeof a8);\n+  return cmp88;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"len0 = 0;\" 1 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"len = 18;\" 1 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"lenx = 8;\" 1 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"leny = 0;\" 1 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"cmp88 = 0;\" 1 \"gimple\" } } */"}, {"sha": "1d1d36808a946f45c2bda24d779940af0e9ad5f6", "filename": "gcc/testsuite/gcc.dg/strlenopt-50.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-50.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -0,0 +1,116 @@\n+/* PR tree-optimization/86415 - strlen() not folded for substrings\n+   within constant arrays\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-gimple -fdump-tree-ccp\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+#define T(s, n) ELIM (strlen (s) == n)\n+\n+/*                              11111\n+\t     0 1  23 4  567 8  901234  */\n+#define STR \"1\\00012\\000123\\0001234\\0\"\n+\n+const char a[]   = STR;\n+const char b[20] = STR;\n+\n+void test_literal (void)\n+{\n+  /* Verify that strlen() of substrings within a string literal are\n+     correctly folded.  */\n+  T (STR,      1);  T (STR +  1, 0);  T (STR +  2, 2);  T (STR +  3, 1);\n+  T (STR +  4, 0);  T (STR +  5, 3);  T (STR +  6, 2);  T (STR +  7, 1);\n+  T (STR +  8, 0);  T (STR +  9, 4);  T (STR + 10, 3);  T (STR + 11, 2);\n+  T (STR + 12, 1);  T (STR + 13, 0);  T (STR + 14, 0);\n+\n+  T (&(STR[0]),  1);  T (&(STR[ 1]), 0);  T (&(STR[ 2]), 2);\n+  T (&(STR[ 3]), 1);  T (&(STR[ 4]), 0);  T (&(STR[ 5]), 3);\n+  T (&(STR[ 6]), 2);  T (&(STR[ 7]), 1);  T (&(STR[ 8]), 0);\n+  T (&(STR[ 9]), 4);  T (&(STR[10]), 3);  T (&(STR[11]), 2);\n+  T (&(STR[12]), 1);  T (&(STR[13]), 0);  T (&(STR[14]), 0);\n+\n+  T (&(STR[0])  +  1, 0);  T (&(STR[ 1]) +  1, 2);  T (&(STR[ 2]) +  1, 1);\n+  T (&(STR[ 3]) +  1, 0);  T (&(STR[ 4]) +  1, 3);  T (&(STR[ 5]) +  1, 2);\n+  T (&(STR[ 6]) +  1, 1);  T (&(STR[ 7]) +  1, 0);  T (&(STR[ 8]) +  1, 4);\n+  T (&(STR[ 9]) +  1, 3);  T (&(STR[10]) +  1, 2);  T (&(STR[11]) +  1, 1);\n+  T (&(STR[12]) +  1, 0);  T (&(STR[13]) +  1, 0);  T (&(STR[13]) - 13, 1);\n+  T (&(STR[13]) - 12, 0);  T (&(STR[13]) - 11, 2);  T (&(STR[13]) - 10, 1);\n+}\n+\n+void test_array (void)\n+{\n+  /* Verify that strlen() of substrings within a fully initialized\n+     array are correctly folded.  */\n+  T (a,      1);  T (a +  1, 0);  T (a +  2, 2);  T (a +  3, 1);\n+  T (a +  4, 0);  T (a +  5, 3);  T (a +  6, 2);  T (a +  7, 1);\n+  T (a +  8, 0);  T (a +  9, 4);  T (a + 10, 3);  T (a + 11, 2);\n+  T (a + 12, 1);  T (a + 13, 0);  T (a + 14, 0);\n+\n+  /* Verify that strlen() of substrings within a partially initialized\n+     array are also correctly folded, including those referring to\n+     the empty substrings in the implicitly initialized elements.  */\n+  T (b,      1);  T (b +  1, 0);  T (b +  2, 2);  T (b +  3, 1);\n+  T (b +  4, 0);  T (b +  5, 3);  T (b +  6, 2);  T (b +  7, 1);\n+  T (b +  8, 0);  T (b +  9, 4);  T (b + 10, 3);  T (b + 11, 2);\n+  T (b + 12, 1);  T (b + 13, 0);  T (b + 14, 0);  T (b + 15, 0);\n+  T (b + 16, 0);  T (b + 17, 0);  T (b + 18, 0);  T (b + 19, 0);\n+}\n+\n+void test_array_ref_plus (void)\n+{\n+  /* Verify that strlen() of substrings within a fully initialized\n+     array referred to by array indices with offsets are correctly\n+     folded.  */\n+  T (&a[ 0],     1);  T (&a[ 0] + 1, 0);\n+  T (&a[ 1],     0);  T (&a[ 1] + 1, 2);\n+  T (&a[ 2],     2);  T (&a[ 2] + 1, 1);  T (&a[ 2] + 2, 0);\n+  T (&a[ 3],     1);  T (&a[ 3] + 1, 0);\n+  T (&a[ 4],     0);  T (&a[ 4] + 1, 3);\n+  T (&a[ 5],     3);  T (&a[ 5] + 1, 2);\n+  T (&a[ 5] + 2, 1);  T (&a[ 5] + 3, 0);  T (&a[ 5] + 4, 4);\n+  T (&a[ 6],     2);  T (&a[ 6] + 1, 1);  T (&a[ 6] + 2, 0);\n+  T (&a[ 7],     1);  T (&a[ 7] + 1, 0);\n+  T (&a[ 8],     0);  T (&a[ 8] + 1, 4);\n+  T (&a[ 9],     4);  T (&a[ 9] + 1, 3);  T (&a[ 9] + 2, 2);\n+  T (&a[ 9] + 3, 1);  T (&a[ 9] + 4, 0);  T (&a[ 9] + 5, 0);\n+  T (&a[10],     3);  T (&a[10] + 1, 2);  T (&a[10] + 2, 1);\n+  T (&a[10] + 3, 0);  T (&a[10] + 4, 0);\n+  T (&a[11],     2);  T (&a[11] + 1, 1);  T (&a[11] + 2, 0);\n+  T (&a[12],     1);  T (&a[12] + 1, 0);  T (&a[12] + 2, 0);\n+  T (&a[13],     0);  T (&a[13] + 1, 0);\n+  T (&a[14],     0);\n+}\n+\n+void test_array_ref (void)\n+{\n+  T (&a[ 0], 1);  T (&a[ 1], 0);  T (&a[ 2], 2);  T (&a[ 3], 1);\n+  T (&a[ 4], 0);  T (&a[ 5], 3);  T (&a[ 6], 2);  T (&a[ 7], 1);\n+  T (&a[ 8], 0);  T (&a[ 9], 4);  T (&a[10], 3);  T (&a[11], 2);\n+  T (&a[12], 1);  T (&a[13], 0);  T (&a[14], 0);\n+\n+  T (&b[ 0], 1);  T (&b[ 1], 0);  T (&b[ 2], 2);  T (&b[ 3], 1);\n+  T (&b[ 4], 0);  T (&b[ 5], 3);  T (&b[ 6], 2);  T (&b[ 7], 1);\n+  T (&b[ 8], 0);  T (&b[ 9], 4);  T (&b[10], 3);  T (&b[11], 2);\n+  T (&b[12], 1);  T (&b[13], 0);  T (&b[14], 0);  T (&b[15], 0);\n+  T (&b[16], 0);  T (&b[17], 0);  T (&b[18], 0);  T (&b[19], 0);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"ccp1\" } } */"}, {"sha": "cbed11bbf588bf556a1cf78b5fdc3618ee7ddca4", "filename": "gcc/testsuite/gcc.dg/strlenopt-51.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -0,0 +1,121 @@\n+/* PR tree-optimization/77357 - strlen of constant strings not folded\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-gimple -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+/* Macro to emit a call to a function named\n+     call_made_in_{true,false}_branch_on_line_NNN()\n+   for each call that's expected to be retained.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that the expected number of both kinds of calls appears in output\n+   (a pair for each line with the invocation of the KEEP() macro.  */\n+#define KEEP(expr)\t\t\t\t\\\n+  if (expr)\t\t\t\t\t\\\n+    FAIL (made_in_true_branch);\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    FAIL (made_in_false_branch)\n+\n+#define T(s, n) ELIM (strlen (s) == n)\n+\n+\n+struct S\n+{\n+  char a1[1], a2[2], a3[3], a4[4], a5[5], a6[6], a7[7], a8[8], a9[9];\n+};\n+\n+#define S0 \"\"\n+#define S1 \"1\"\n+#define S2 \"12\"\n+#define S3 \"123\"\n+#define S4 \"1234\"\n+#define S5 \"12345\"\n+#define S6 \"123456\"\n+#define S7 \"1234567\"\n+#define S8 \"12345678\"\n+\n+const char a9[][9] = { S0, S1, S2, S3, S4, S5, S6, S7, S8 };\n+\n+void test_elim_a9 (int i)\n+{\n+  ELIM (strlen (&a9[0][i]) > 0);\n+  ELIM (strlen (&a9[1][i]) > 1);\n+  ELIM (strlen (&a9[2][i]) > 2);\n+  ELIM (strlen (&a9[3][i]) > 3);\n+  ELIM (strlen (&a9[4][i]) > 4);\n+  ELIM (strlen (&a9[5][i]) > 5);\n+  ELIM (strlen (&a9[6][i]) > 6);\n+  ELIM (strlen (&a9[7][i]) > 7);\n+  ELIM (strlen (&a9[8][i]) > 8);\n+}\n+\n+const char a9_9[][9][9] = {\n+  { S0, S1, S2, S3, S4, S5, S6, S7, S8 },\n+  { S1, S2, S3, S4, S5, S6, S7, S8, S0 },\n+  { S2, S3, S4, S5, S6, S7, S8, S0, S1 },\n+  { S3, S4, S5, S6, S7, S8, S0, S1, S2 },\n+  { S4, S5, S6, S7, S8, S0, S1, S2, S3 },\n+  { S5, S6, S7, S8, S0, S1, S2, S3, S4 },\n+  { S6, S7, S8, S0, S1, S2, S3, S4, S5 },\n+  { S7, S8, S0, S1, S2, S3, S4, S5, S6 },\n+  { S8, S0, S2, S2, S3, S4, S5, S6, S7 }\n+};\n+\n+void test_elim_a9_9 (int i)\n+{\n+#undef T\n+#define T(I)\t\t\t\t\t\\\n+  ELIM (strlen (&a9_9[I][0][i]) > (0 + I) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][1][i]) > (1 + I) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][2][i]) > (2 + i) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][3][i]) > (3 + I) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][4][i]) > (4 + I) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][5][i]) > (5 + I) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][6][i]) > (6 + I) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][7][i]) > (7 + I) % 9);\t\\\n+  ELIM (strlen (&a9_9[I][8][i]) > (8 + I) % 9)\n+\n+  T (0); T (1); T (2); T (3); T (4); T (5); T (6); T (7); T (8);\n+}\n+\n+#line 1000\n+\n+void test_keep_a9_9 (int i)\n+{\n+#undef T\n+#define T(I)\t\t\t\t\t\\\n+  KEEP (strlen (&a9_9[i][I][0]) > (1 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][1]) > (1 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][2]) > (2 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][3]) > (3 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][4]) > (4 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][5]) > (5 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][6]) > (6 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][7]) > (7 + I) % 9);\t\\\n+  KEEP (strlen (&a9_9[i][I][8]) > (8 + I) % 9)\n+\n+  T (0); T (1); T (2); T (3); T (4); T (5); T (6); T (7); T (8);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 72 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"strlen\" 63 \"optimized\" } }\n+\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 72 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 81 \"optimized\" } } */"}, {"sha": "03e063b435ed4e855b577eab73711ec078672392", "filename": "gcc/testsuite/gcc.dg/strlenopt-52.c", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-52.c?ref=35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "patch": "@@ -0,0 +1,288 @@\n+/* PR tree-optimization/77357 - strlen of constant strings not folded\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-gimple -fdump-tree-ccp\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+#define T(s, n) ELIM (strlen (s) == n)\n+\n+\n+struct S\n+{\n+  char a1[1], a2[2], a3[3], a4[4], a5[5], a6[6], a7[7], a8[8], a9[9];\n+};\n+\n+#define S0 \"\"\n+#define S1 \"1\"\n+#define S2 \"12\"\n+#define S3 \"123\"\n+#define S4 \"1234\"\n+#define S5 \"12345\"\n+#define S6 \"123456\"\n+#define S7 \"1234567\"\n+#define S8 \"12345678\"\n+\n+const char a9[][9] = { S0, S1, S2, S3, S4, S5, S6, S7, S8 };\n+\n+const char a_1_9[1][9] = { S8 };\n+const char a_2_9[2][9] = { S8, S7};\n+\n+const char a9_9[][9][9] = {\n+  { S0, S0, S0, S0, S0, S0, S0, S0, S0 },\n+  { S0, S1, S1, S1, S1, S1, S1, S1, S1 },\n+  { S0, S1, S2, S2, S2, S2, S2, S2, S2 },\n+  { S0, S1, S2, S3, S3, S3, S3, S3, S3 },\n+  { S0, S1, S2, S3, S4, S4, S4, S4, S4 },\n+  { S0, S1, S2, S3, S4, S5, S5, S5, S5 },\n+  { S0, S1, S2, S3, S4, S5, S6, S6, S6 },\n+  { S0, S1, S2, S3, S4, S5, S6, S7, S7 },\n+  { S0, S1, S2, S3, S4, S5, S6, S7, S8 }\n+};\n+\n+const struct S s = { S0, S1, S2, S3, S4, S5, S6, S7, S8 };\n+\n+const struct S sa[9] = {\n+  { S0, S0, S0, S0, S0, S0, S0, S0, S0 },\n+  { S0, S1, S1, S1, S1, S1, S1, S1, S1 },\n+  { S0, S1, S2, S2, S2, S2, S2, S2, S2 },\n+  { S0, S1, S2, S3, S3, S3, S3, S3, S3 },\n+  { S0, S1, S2, S3, S4, S4, S4, S4, S4 },\n+  { S0, S1, S2, S3, S4, S5, S5, S5, S5 },\n+  { S0, S1, S2, S3, S4, S5, S6, S6, S6 },\n+  { S0, S1, S2, S3, S4, S5, S6, S7, S7 },\n+  { S0, S1, S2, S3, S4, S5, S6, S7, S8 }\n+};\n+\n+const struct S sa3_5_7[3][5][7] = {\n+  [1][2][3].a2 = S1, [1][3][5].a3 = S2, [2][4][5].a4 = S3\n+};\n+\n+\n+void test_global_array (void)\n+{\n+  T (a9[0], 0);  T (a9[0] + 0, 0);  T (a9[0] + 0, 0);  T (a9[0] + 0, 0);\n+  T (a9[1], 1);  T (a9[1] + 1, 0);  T (a9[1] + 1, 0);  T (a9[1] + 1, 0);\n+  T (a9[2], 2);\n+  T (a9[2] + 1, 1);\n+  T (a9[2] + 2, 0);\n+  T (a9[2] + 2, 0);\n+\n+  T (a9[3], 3);  T (a9[3] + 1, 2);  T (a9[3] + 2, 1);  T (a9[3] + 3, 0);\n+  T (a9[4], 4);  T (a9[4] + 1, 3);  T (a9[4] + 2, 2);  T (a9[4] + 3, 1);\n+  T (a9[5], 5);  T (a9[5] + 1, 4);  T (a9[5] + 2, 3);  T (a9[5] + 3, 2);\n+  T (a9[6], 6);  T (a9[6] + 1, 5);  T (a9[6] + 2, 4);  T (a9[6] + 3, 3);\n+  T (a9[7], 7);  T (a9[7] + 1, 6);  T (a9[7] + 2, 5);  T (a9[7] + 3, 4);\n+  T (a9[8], 8);  T (a9[8] + 1, 7);  T (a9[8] + 2, 6);  T (a9[8] + 3, 5);\n+\n+  T (a_1_9[0], 8);\n+  T (a_1_9[0] + 1, 7);\n+  T (a_1_9[0] + 7, 1);\n+  T (a_1_9[0] + 8, 0);\n+\n+  T (a_2_9[0], 8);\n+  T (a_2_9[0] + 1, 7);\n+  T (a_2_9[0] + 7, 1);\n+  T (a_2_9[0] + 8, 0);\n+\n+  T (a_2_9[1], 7);\n+  T (a_2_9[1] + 1, 6);\n+  T (a_2_9[1] + 6, 1);\n+  T (a_2_9[1] + 7, 0);\n+  T (a_2_9[1] + 8, 0);\n+}\n+\n+void test_global_array_array (void)\n+{\n+  T (a9_9[0][0], 0);  T (a9_9[1][0], 0);  T (a9_9[2][0], 0);\n+  T (a9_9[0][1], 0);  T (a9_9[1][1], 1);  T (a9_9[2][1], 1);\n+  T (a9_9[0][2], 0);  T (a9_9[1][2], 1);  T (a9_9[2][2], 2);\n+  T (a9_9[0][3], 0);  T (a9_9[1][3], 1);  T (a9_9[2][3], 2);\n+  T (a9_9[0][4], 0);  T (a9_9[1][4], 1);  T (a9_9[2][4], 2);\n+  T (a9_9[0][5], 0);  T (a9_9[1][5], 1);  T (a9_9[2][5], 2);\n+  T (a9_9[0][6], 0);  T (a9_9[1][6], 1);  T (a9_9[2][6], 2);\n+  T (a9_9[0][7], 0);  T (a9_9[1][7], 1);  T (a9_9[2][7], 2);\n+  T (a9_9[0][8], 0);  T (a9_9[1][8], 1);  T (a9_9[2][8], 2);\n+\n+  T (a9_9[3][0], 0);  T (a9_9[4][0], 0);  T (a9_9[5][0], 0);\n+  T (a9_9[3][1], 1);  T (a9_9[4][1], 1);  T (a9_9[5][1], 1);\n+  T (a9_9[3][2], 2);  T (a9_9[4][2], 2);  T (a9_9[5][2], 2);\n+  T (a9_9[3][3], 3);  T (a9_9[4][3], 3);  T (a9_9[5][3], 3);\n+  T (a9_9[3][4], 3);  T (a9_9[4][4], 4);  T (a9_9[5][4], 4);\n+  T (a9_9[3][5], 3);  T (a9_9[4][5], 4);  T (a9_9[5][5], 5);\n+  T (a9_9[3][6], 3);  T (a9_9[4][6], 4);  T (a9_9[5][6], 5);\n+  T (a9_9[3][7], 3);  T (a9_9[4][7], 4);  T (a9_9[5][7], 5);\n+  T (a9_9[3][8], 3);  T (a9_9[4][8], 4);  T (a9_9[5][8], 5);\n+\n+  T (a9_9[6][0], 0);  T (a9_9[7][0], 0);  T (a9_9[8][0], 0);\n+  T (a9_9[6][1], 1);  T (a9_9[7][1], 1);  T (a9_9[8][1], 1);\n+  T (a9_9[6][2], 2);  T (a9_9[7][2], 2);  T (a9_9[8][2], 2);\n+  T (a9_9[6][3], 3);  T (a9_9[7][3], 3);  T (a9_9[8][3], 3);\n+  T (a9_9[6][4], 4);  T (a9_9[7][4], 4);  T (a9_9[8][4], 4);\n+  T (a9_9[6][5], 5);  T (a9_9[7][5], 5);  T (a9_9[8][5], 5);\n+  T (a9_9[6][6], 6);  T (a9_9[7][6], 6);  T (a9_9[8][6], 6);\n+  T (a9_9[6][7], 6);  T (a9_9[7][7], 7);  T (a9_9[8][7], 7);\n+  T (a9_9[6][8], 6);  T (a9_9[7][8], 7);  T (a9_9[8][8], 8);\n+\n+\n+  T (a9_9[0][0] + 1, 0);  T (a9_9[1][0] + 1, 0);  T (a9_9[2][0] + 2, 0);\n+  T (a9_9[0][1] + 2, 0);  T (a9_9[1][1] + 1, 0);  T (a9_9[2][1] + 2, 0);\n+  T (a9_9[0][2] + 3, 0);  T (a9_9[1][2] + 1, 0);  T (a9_9[2][2] + 2, 0);\n+  T (a9_9[0][3] + 4, 0);  T (a9_9[1][3] + 1, 0);  T (a9_9[2][3] + 2, 0);\n+  T (a9_9[0][4] + 5, 0);  T (a9_9[1][4] + 1, 0);  T (a9_9[2][4] + 2, 0);\n+  T (a9_9[0][5] + 6, 0);  T (a9_9[1][5] + 1, 0);  T (a9_9[2][5] + 2, 0);\n+  T (a9_9[0][6] + 7, 0);  T (a9_9[1][6] + 1, 0);  T (a9_9[2][6] + 2, 0);\n+  T (a9_9[0][7] + 8, 0);  T (a9_9[1][7] + 1, 0);  T (a9_9[2][7] + 2, 0);\n+}\n+\n+void test_global_struct (void)\n+{\n+  T (s.a1, 0);\n+  T (s.a2, 1);\n+  T (s.a3, 2);\n+  T (s.a4, 3);\n+  T (s.a5, 4);\n+  T (s.a6, 5);\n+  T (s.a7, 6);\n+  T (s.a8, 7);\n+  T (s.a9, 8);\n+}\n+\n+void test_global_struct_array (void)\n+{\n+  T (sa[0].a1, 0);  T (sa[1].a1, 0);  T (sa[2].a1, 0);  T (sa[3].a1, 0);\n+  T (sa[0].a2, 0);  T (sa[1].a2, 1);  T (sa[2].a2, 1);  T (sa[3].a2, 1);\n+  T (sa[0].a3, 0);  T (sa[1].a3, 1);  T (sa[2].a3, 2);  T (sa[3].a3, 2);\n+  T (sa[0].a4, 0);  T (sa[1].a4, 1);  T (sa[2].a4, 2);  T (sa[3].a4, 3);\n+  T (sa[0].a5, 0);  T (sa[1].a5, 1);  T (sa[2].a5, 2);  T (sa[3].a5, 3);\n+  T (sa[0].a6, 0);  T (sa[1].a6, 1);  T (sa[2].a6, 2);  T (sa[3].a6, 3);\n+  T (sa[0].a7, 0);  T (sa[1].a7, 1);  T (sa[2].a7, 2);  T (sa[3].a7, 3);\n+  T (sa[0].a8, 0);  T (sa[1].a8, 1);  T (sa[2].a8, 2);  T (sa[3].a8, 3);\n+  T (sa[0].a9, 0);  T (sa[1].a9, 1);  T (sa[2].a9, 2);  T (sa[3].a9, 3);\n+\n+  T (sa[4].a1, 0);  T (sa[5].a1, 0);  T (sa[6].a1, 0);  T (sa[7].a1, 0);\n+  T (sa[4].a2, 1);  T (sa[5].a2, 1);  T (sa[6].a2, 1);  T (sa[7].a2, 1);\n+  T (sa[4].a3, 2);  T (sa[5].a3, 2);  T (sa[6].a3, 2);  T (sa[7].a3, 2);\n+  T (sa[4].a4, 3);  T (sa[5].a4, 3);  T (sa[6].a4, 3);  T (sa[7].a4, 3);\n+  T (sa[4].a5, 4);  T (sa[5].a5, 4);  T (sa[6].a5, 4);  T (sa[7].a5, 4);\n+  T (sa[4].a6, 4);  T (sa[5].a6, 5);  T (sa[6].a6, 5);  T (sa[7].a6, 5);\n+  T (sa[4].a7, 4);  T (sa[5].a7, 5);  T (sa[6].a7, 6);  T (sa[7].a7, 6);\n+  T (sa[4].a8, 4);  T (sa[5].a8, 5);  T (sa[6].a8, 6);  T (sa[7].a8, 7);\n+  T (sa[4].a9, 4);  T (sa[5].a9, 5);  T (sa[6].a9, 6);  T (sa[7].a9, 7);\n+\n+  T (sa[8].a1, 0);\n+  T (sa[8].a2, 1);  T (sa[8].a2 + 1, 0);\n+  T (sa[8].a3, 2);  T (sa[8].a3 + 1, 1);  T (sa[8].a3 + 2, 0);\n+  T (sa[8].a4, 3);  T (sa[8].a4 + 1, 2);  T (sa[8].a4 + 2, 1);\n+  T (sa[8].a5, 4);  T (sa[8].a5 + 1, 3);  T (sa[8].a5 + 2, 2);\n+  T (sa[8].a6, 5);  T (sa[8].a6 + 1, 4);  T (sa[8].a6 + 2, 3);\n+  T (sa[8].a7, 6);  T (sa[8].a7 + 1, 5);  T (sa[8].a7 + 2, 4);\n+  T (sa[8].a8, 7);  T (sa[8].a8 + 1, 6);  T (sa[8].a8 + 2, 5);\n+  T (sa[8].a9, 8);  T (sa[8].a9 + 1, 7);  T (sa[8].a9 + 2, 6);\n+\n+\n+  T (sa3_5_7[1][2][3].a2, 1);\n+  T (sa3_5_7[1][3][5].a3, 2);\n+  T (sa3_5_7[2][4][5].a4, 3);\n+\n+  T (sa3_5_7[0][0][0].a1, 0);\n+  T (sa3_5_7[0][0][0].a2, 0);\n+  T (sa3_5_7[0][0][0].a3, 0);\n+  T (sa3_5_7[0][0][0].a4, 0);\n+  T (sa3_5_7[0][0][0].a5, 0);\n+  T (sa3_5_7[0][0][0].a6, 0);\n+  T (sa3_5_7[0][0][0].a7, 0);\n+  T (sa3_5_7[0][0][0].a8, 0);\n+  T (sa3_5_7[0][0][0].a9, 0);\n+\n+  T (sa3_5_7[0][0][1].a1, 0);\n+  T (sa3_5_7[0][0][1].a2, 0);\n+  T (sa3_5_7[0][0][1].a3, 0);\n+  T (sa3_5_7[0][0][1].a4, 0);\n+  T (sa3_5_7[0][0][1].a5, 0);\n+  T (sa3_5_7[0][0][1].a6, 0);\n+  T (sa3_5_7[0][0][1].a7, 0);\n+  T (sa3_5_7[0][0][1].a8, 0);\n+  T (sa3_5_7[0][0][1].a9, 0);\n+\n+  T (sa3_5_7[0][1][0].a1, 0);\n+  T (sa3_5_7[0][1][0].a2, 0);\n+  T (sa3_5_7[0][1][0].a3, 0);\n+  T (sa3_5_7[0][1][0].a4, 0);\n+  T (sa3_5_7[0][1][0].a5, 0);\n+  T (sa3_5_7[0][1][0].a6, 0);\n+  T (sa3_5_7[0][1][0].a7, 0);\n+  T (sa3_5_7[0][1][0].a8, 0);\n+  T (sa3_5_7[0][1][0].a9, 0);\n+\n+  T (sa3_5_7[1][0][0].a1, 0);\n+  T (sa3_5_7[1][0][0].a2, 0);\n+  T (sa3_5_7[1][0][0].a3, 0);\n+  T (sa3_5_7[1][0][0].a4, 0);\n+  T (sa3_5_7[1][0][0].a5, 0);\n+  T (sa3_5_7[1][0][0].a6, 0);\n+  T (sa3_5_7[1][0][0].a7, 0);\n+  T (sa3_5_7[1][0][0].a8, 0);\n+  T (sa3_5_7[1][0][0].a9, 0);\n+}\n+\n+\n+struct SS {\n+  char a9[9][9];\n+  struct S sa9[9];\n+};\n+\n+const struct SS ssa[] = {\n+  [1] = {\n+    .a9 = { [3] = S3, [7] = S7 },\n+    .sa9 = { [5] = { .a5 = S4, .a7 = S6 } }\n+  },\n+  [5] = {\n+    .a9 = { [1] = S8, [5] = S4 },\n+    .sa9 = { [3] = { .a3 = S2, .a6 = S3 } }\n+  }\n+};\n+\n+void test_global_struct_struct_array (void)\n+{\n+  T (ssa[0].a9[0], 0);\n+  T (ssa[0].a9[3], 0);\n+  T (ssa[0].sa9[5].a5, 0);\n+  T (ssa[0].sa9[5].a7, 0);\n+\n+  T (ssa[1].a9[0], 0);\n+\n+  T (ssa[1].a9[3], 3);\n+  T (ssa[1].a9[7], 7);\n+  T (ssa[1].sa9[5].a5, 4);\n+  T (ssa[1].sa9[5].a7, 6);\n+\n+  T (ssa[2].a9[3], 0);\n+  T (ssa[2].a9[7], 0);\n+  T (ssa[2].sa9[5].a5, 0);\n+  T (ssa[2].sa9[5].a7, 0);\n+\n+  T (ssa[5].a9[1], 8);\n+  T (ssa[5].a9[5], 4);\n+  T (ssa[5].sa9[3].a3, 2);\n+  T (ssa[5].sa9[3].a6, 3);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"ccp1\" } } */"}]}