{"sha": "2fdc0399820af12180f26f1241ec185e73aa3180", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZkYzAzOTk4MjBhZjEyMTgwZjI2ZjEyNDFlYzE4NWU3M2FhMzE4MA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-02-10T20:47:33Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-02-10T20:47:33Z"}, "message": "re PR target/64661 ([SH] Allow @(disp,reg) address mode for atomics)\n\ngcc/\n\tPR target/64661\n\t* config/sh/sh-protos.h (TARGET_ATOMIC_ANY, TARGET_ATOMIC_STRICT,\n\tTARGET_ATOMIC_SOFT_GUSA, TARGET_ATOMIC_HARD_LLCS,\n\tTARGET_ATOMIC_SOFT_TCB, TARGET_ATOMIC_SOFT_IMASK): Add parentheses.\n\t* config/sh/constraints.md (Ara, Add): New constraints.\n\t* config/sh/sync.md (atomic_mem_operand_0, atomic_mem_operand_1): New\n\tpredicates.\n\t(atomic_compare_and_swap<mode>, atomic_exchange<mode>): Use\n\tatomic_mem_operand_0.  Don't use force_reg on the memory address.\n\t(atomic_compare_and_swapsi_hard): Use atomic_mem_operand_0 predicate and\n\tSra constraint.  Convert to insn_and_split.  Add workaround for\n\tPR 64974.\n\t(atomic_compare_and_swap<mode>_hard): Copy to\n\tatomic_compare_and_swap<mode>_hard_1.  Convert to insn_and_split.\n\tUse atomic_mem_operand_0 predicate.\n\t(atomic_compare_and_swap<mode>_soft_gusa,\n\tatomic_exchange<mode>_soft_gusa): Use atomic_mem_operand_0 predicate and\n\tAraAdd constraints.\n\t(atomic_compare_and_swap<mode>_soft_tcb,\n\tatomic_compare_and_swap<mode>_soft_imask,\n\tatomic_exchange<mode>_soft_tcb, atomic_exchange<mode>_soft_imask): Use\n\tatomic_mem_operand_0 predicate and SraSdd constraints.\n\t(atomic_exchangesi_hard) Use atomic_mem_operand_0 predicate and Sra\n\tconstraint.\n\t(atomic_exchange<mode>_hard): Copy to atomic_exchange<mode>_hard_1.\n\tConvert to insn_and_split.  Use atomic_mem_operand_0 predicate.\n\t(atomic_fetch_<fetchop_name><mode>, atomic_fetch_nand<mode>,\n\tatomic_<fetchop_name>_fetch<mode>): Use atomic_mem_operand_1.  Don't use\n\tforce_reg on the memory address.\n\t(atomic_fetch_<fetchop_name>si_hard, atomic_fetch_notsi_hard,\n\tatomic_fetch_nandsi_hard, atomic_<fetchop_name>_fetchsi_hard,\n\tatomic_not_fetchsi_hard, atomic_nand_fetchsi_hard): Use\n\tatomic_mem_operand_1 predicate and Sra constraint.\n\t(atomic_fetch_<fetchop_name><mode>_hard): Copy to\n\tatomic_fetch_<fetchop_name><mode>_hard_1.  Convert to insn_and_split.\n\tUse atomic_mem_operand_1 predicate.\n\t(atomic_<fetchop_name><mode>_hard): Copy to\n\tatomic_<fetchop_name><mode>_hard_1.  Convert to insn_and_split.\n\tUse atomic_mem_operand_1 predicate.\n\t(atomic_fetch_nand<mode>_hard): Copy to atomic_fetch_nand<mode>_hard_1.\n\tConvert to insn_and_split.  Use atomic_mem_operand_1 predicate.\n\t(atomic_nand<mode>_hard): Copy to atomic_nand<mode>_hard_1.  Convert to\n\tinsn_and_split.  Use atomic_mem_operand_1 predicate.\n\t(atomic_<fetchop_name>_fetch<mode>_hard): Copy to\n\tatomic_<fetchop_name>_fetch<mode>_hard_1.  Convert to insn_and_split.\n\tUse atomic_mem_operand_1 predicate.\n\t(atomic_nand_fetch<mode>_hard): Copy to atomic_nand_fetch<mode>_hard_1.\n\tConvert to insn_and_split.  Use atomic_mem_operand_1 predicate.\n\t(atomic_fetch_not<mode>_hard, atomic_not_fetch<mode>_hard): Replace mems\n\tin generated insn with original mem operand before emitting the insn.\n\t(atomic_fetch_<fetchop_name><mode>_soft_gusa,\n\tatomic_fetch_not<mode>_soft_gusa, atomic_fetch_nand<mode>_soft_gusa,\n\tatomic_<fetchop_name>_fetch<mode>_soft_gusa,\n\tatomic_not_fetch<mode>_soft_gusa, atomic_nand_fetch<mode>_soft_gusa):\n\tUse atomic_mem_operand_1 predicate and AraAdd constraints.\n\t(atomic_fetch_<fetchop_name><mode>_soft_tcb,\n\tatomic_<fetchop_name><mode>_soft_tcb, atomic_fetch_not<mode>_soft_tcb,\n\tatomic_not<mode>_soft_tcb, atomic_fetch_<fetchop_name><mode>_soft_imask,\n\tatomic_fetch_not<mode>_soft_imask, atomic_fetch_nand<mode>_soft_tcb,\n\tatomic_nand<mode>_soft_tcb, atomic_fetch_nand<mode>_soft_imask,\n\tatomic_<fetchop_name>_fetch<mode>_soft_tcb,\n\tatomic_not_fetch<mode>_soft_tcb,\n\tatomic_<fetchop_name>_fetch<mode>_soft_imask,\n\tatomic_not_fetch<mode>_soft_imask, atomic_nand_fetch<mode>,\n\tatomic_nand_fetch<mode>_soft_tcb, atomic_nand_fetch<mode>_soft_imask):\n\tUse atomic_mem_operand_1 predicate and SraSdd constraints.\n\ngcc/testsuite/\n\tPR target/64661\n\t* gcc.taget/sh/pr64661-0.h: New.\n\t* gcc.taget/sh/pr64661-1.c: New.\n\t* gcc.taget/sh/pr64661-2.c: New.\n\t* gcc.taget/sh/pr64661-3.c: New.\n\t* gcc.taget/sh/pr64661-4.c: New.\n\nFrom-SVN: r220594", "tree": {"sha": "fdb7d5593cabb0444a0ddaf0e749321cb97f31b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb7d5593cabb0444a0ddaf0e749321cb97f31b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fdc0399820af12180f26f1241ec185e73aa3180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fdc0399820af12180f26f1241ec185e73aa3180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fdc0399820af12180f26f1241ec185e73aa3180", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fdc0399820af12180f26f1241ec185e73aa3180/comments", "author": null, "committer": null, "parents": [{"sha": "afa208748d29bb1dceaef49e3149269378d38cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa208748d29bb1dceaef49e3149269378d38cc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa208748d29bb1dceaef49e3149269378d38cc5"}], "stats": {"total": 1085, "additions": 845, "deletions": 240}, "files": [{"sha": "6be8626016f934ed7e7c51124ebdb0c79b145d95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -1,3 +1,72 @@\n+2015-02-10  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/64661\n+\t* config/sh/sh-protos.h (TARGET_ATOMIC_ANY, TARGET_ATOMIC_STRICT,\n+\tTARGET_ATOMIC_SOFT_GUSA, TARGET_ATOMIC_HARD_LLCS,\n+\tTARGET_ATOMIC_SOFT_TCB, TARGET_ATOMIC_SOFT_IMASK): Add parentheses.\n+\t* config/sh/constraints.md (Ara, Add): New constraints.\n+\t* config/sh/sync.md (atomic_mem_operand_0, atomic_mem_operand_1): New\n+\tpredicates.\n+\t(atomic_compare_and_swap<mode>, atomic_exchange<mode>): Use\n+\tatomic_mem_operand_0.  Don't use force_reg on the memory address.\n+\t(atomic_compare_and_swapsi_hard): Use atomic_mem_operand_0 predicate and\n+\tSra constraint.  Convert to insn_and_split.  Add workaround for\n+\tPR 64974.\n+\t(atomic_compare_and_swap<mode>_hard): Copy to\n+\tatomic_compare_and_swap<mode>_hard_1.  Convert to insn_and_split.\n+\tUse atomic_mem_operand_0 predicate.\n+\t(atomic_compare_and_swap<mode>_soft_gusa,\n+\tatomic_exchange<mode>_soft_gusa): Use atomic_mem_operand_0 predicate and\n+\tAraAdd constraints.\n+\t(atomic_compare_and_swap<mode>_soft_tcb,\n+\tatomic_compare_and_swap<mode>_soft_imask,\n+\tatomic_exchange<mode>_soft_tcb, atomic_exchange<mode>_soft_imask): Use\n+\tatomic_mem_operand_0 predicate and SraSdd constraints.\n+\t(atomic_exchangesi_hard) Use atomic_mem_operand_0 predicate and Sra\n+\tconstraint.\n+\t(atomic_exchange<mode>_hard): Copy to atomic_exchange<mode>_hard_1.\n+\tConvert to insn_and_split.  Use atomic_mem_operand_0 predicate.\n+\t(atomic_fetch_<fetchop_name><mode>, atomic_fetch_nand<mode>,\n+\tatomic_<fetchop_name>_fetch<mode>): Use atomic_mem_operand_1.  Don't use\n+\tforce_reg on the memory address.\n+\t(atomic_fetch_<fetchop_name>si_hard, atomic_fetch_notsi_hard,\n+\tatomic_fetch_nandsi_hard, atomic_<fetchop_name>_fetchsi_hard,\n+\tatomic_not_fetchsi_hard, atomic_nand_fetchsi_hard): Use\n+\tatomic_mem_operand_1 predicate and Sra constraint.\n+\t(atomic_fetch_<fetchop_name><mode>_hard): Copy to\n+\tatomic_fetch_<fetchop_name><mode>_hard_1.  Convert to insn_and_split.\n+\tUse atomic_mem_operand_1 predicate.\n+\t(atomic_<fetchop_name><mode>_hard): Copy to\n+\tatomic_<fetchop_name><mode>_hard_1.  Convert to insn_and_split.\n+\tUse atomic_mem_operand_1 predicate.\n+\t(atomic_fetch_nand<mode>_hard): Copy to atomic_fetch_nand<mode>_hard_1.\n+\tConvert to insn_and_split.  Use atomic_mem_operand_1 predicate.\n+\t(atomic_nand<mode>_hard): Copy to atomic_nand<mode>_hard_1.  Convert to\n+\tinsn_and_split.  Use atomic_mem_operand_1 predicate.\n+\t(atomic_<fetchop_name>_fetch<mode>_hard): Copy to\n+\tatomic_<fetchop_name>_fetch<mode>_hard_1.  Convert to insn_and_split.\n+\tUse atomic_mem_operand_1 predicate.\n+\t(atomic_nand_fetch<mode>_hard): Copy to atomic_nand_fetch<mode>_hard_1.\n+\tConvert to insn_and_split.  Use atomic_mem_operand_1 predicate.\n+\t(atomic_fetch_not<mode>_hard, atomic_not_fetch<mode>_hard): Replace mems\n+\tin generated insn with original mem operand before emitting the insn.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_gusa,\n+\tatomic_fetch_not<mode>_soft_gusa, atomic_fetch_nand<mode>_soft_gusa,\n+\tatomic_<fetchop_name>_fetch<mode>_soft_gusa,\n+\tatomic_not_fetch<mode>_soft_gusa, atomic_nand_fetch<mode>_soft_gusa):\n+\tUse atomic_mem_operand_1 predicate and AraAdd constraints.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_tcb,\n+\tatomic_<fetchop_name><mode>_soft_tcb, atomic_fetch_not<mode>_soft_tcb,\n+\tatomic_not<mode>_soft_tcb, atomic_fetch_<fetchop_name><mode>_soft_imask,\n+\tatomic_fetch_not<mode>_soft_imask, atomic_fetch_nand<mode>_soft_tcb,\n+\tatomic_nand<mode>_soft_tcb, atomic_fetch_nand<mode>_soft_imask,\n+\tatomic_<fetchop_name>_fetch<mode>_soft_tcb,\n+\tatomic_not_fetch<mode>_soft_tcb,\n+\tatomic_<fetchop_name>_fetch<mode>_soft_imask,\n+\tatomic_not_fetch<mode>_soft_imask, atomic_nand_fetch<mode>,\n+\tatomic_nand_fetch<mode>_soft_tcb, atomic_nand_fetch<mode>_soft_imask):\n+\tUse atomic_mem_operand_1 predicate and SraSdd constraints.\n+\n 2015-02-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.md (reload_out<mode>_aligned): Make operands 2"}, {"sha": "0ac5db5173c562f5458d5a392764397c24319f99", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -18,6 +18,9 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;; Overview of uppercase letter constraints:\n+;; Axx: atomic memory operand constraints\n+;;  Ara: Same as Sra but disallows r15\n+;;  Add: Same as Sdd but disallows r15\n ;; Bxx: miscellaneous constraints\n ;;  Bsc: SCRATCH - for the scratch register in movsi_ie in the\n ;;       fldi0 / fldi0 cases\n@@ -322,3 +325,19 @@\n   (and (match_test \"MEM_P (op)\")\n        (match_test \"REG_P (XEXP (op, 0))\")))\n \n+(define_memory_constraint \"Ara\"\n+  \"A memory reference that uses simple register addressing suitable for\n+   gusa atomic operations.\"\n+  (and (match_code \"mem\")\n+       (match_code \"reg\" \"0\")\n+       (match_test \"REGNO (XEXP (op, 0)) != SP_REG\")))\n+\n+(define_memory_constraint \"Add\"\n+  \"A memory reference that uses displacement addressing suitable for\n+   gusa atomic operations.\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_MODE (op) == SImode\")\n+       (match_code \"plus\" \"0\")\n+       (match_code \"reg\" \"00\")\n+       (match_code \"const_int\" \"01\")\n+       (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) != SP_REG\")))"}, {"sha": "1d8ba1d10fe20bb72823987c347205a3effc456e", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -68,25 +68,25 @@ extern const sh_atomic_model& selected_atomic_model (void);\n \n /* Shortcuts to check the currently selected atomic model.  */\n #define TARGET_ATOMIC_ANY \\\n-  selected_atomic_model ().type != sh_atomic_model::none\n+  (selected_atomic_model ().type != sh_atomic_model::none)\n \n #define TARGET_ATOMIC_STRICT \\\n-  selected_atomic_model ().strict\n+  (selected_atomic_model ().strict)\n \n #define TARGET_ATOMIC_SOFT_GUSA \\\n-  selected_atomic_model ().type == sh_atomic_model::soft_gusa\n+  (selected_atomic_model ().type == sh_atomic_model::soft_gusa)\n \n #define TARGET_ATOMIC_HARD_LLCS \\\n-  selected_atomic_model ().type == sh_atomic_model::hard_llcs\n+  (selected_atomic_model ().type == sh_atomic_model::hard_llcs)\n \n #define TARGET_ATOMIC_SOFT_TCB \\\n-  selected_atomic_model ().type == sh_atomic_model::soft_tcb\n+  (selected_atomic_model ().type == sh_atomic_model::soft_tcb)\n \n #define TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX \\\n   GEN_INT (selected_atomic_model ().tcb_gbr_offset)\n \n #define TARGET_ATOMIC_SOFT_IMASK \\\n-  selected_atomic_model ().type == sh_atomic_model::soft_imask\n+  (selected_atomic_model ().type == sh_atomic_model::soft_imask)\n \n #ifdef RTX_CODE\n extern rtx sh_fsca_sf2int (void);"}, {"sha": "6e890a737a990b595b9daef5e3e8a39759dece34", "filename": "gcc/config/sh/sync.md", "status": "modified", "additions": 535, "deletions": 234, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -209,35 +209,46 @@\n \t\t      (match_test \"TARGET_ATOMIC_ANY && TARGET_SH4A\n \t\t\t\t   && !TARGET_ATOMIC_STRICT\"))))))\n \n+;; Displacement addressing can be used for all SImode atomic patterns, except\n+;; llcs.\n+(define_predicate \"atomic_mem_operand_0\"\n+  (and (match_code \"mem\")\n+       (ior (match_operand 0 \"simple_mem_operand\")\n+\t    (and (match_test \"mode == SImode\")\n+\t\t (and (match_test \"!TARGET_ATOMIC_HARD_LLCS\")\n+\t\t      (match_test \"!TARGET_SH4A || TARGET_ATOMIC_STRICT\"))\n+\t\t (match_operand 0 \"displacement_mem_operand\")\n+\t\t (match_operand 0 \"short_displacement_mem_operand\")))))\n+\n (define_expand \"atomic_compare_and_swap<mode>\"\n   [(match_operand:SI 0 \"arith_reg_dest\")\t\t;; bool success output\n    (match_operand:QIHISI 1 \"arith_reg_dest\")\t\t;; oldval output\n-   (match_operand:QIHISI 2 \"memory_operand\")\t\t;; memory\n+   (match_operand:QIHISI 2 \"atomic_mem_operand_0\")\t;; memory\n    (match_operand:QIHISI 3 \"atomic_arith_operand_0\")\t;; expected input\n    (match_operand:QIHISI 4 \"atomic_arith_operand_0\")\t;; newval input\n    (match_operand:SI 5 \"const_int_operand\")\t\t;; is_weak\n    (match_operand:SI 6 \"const_int_operand\")\t\t;; success model\n    (match_operand:SI 7 \"const_int_operand\")]\t\t;; failure model\n   \"TARGET_ATOMIC_ANY\"\n {\n-  rtx addr = force_reg (Pmode, XEXP (operands[2], 0));\n+  rtx mem = operands[2];\n   rtx old_val = gen_lowpart (SImode, operands[1]);\n   rtx exp_val = operands[3];\n   rtx new_val = operands[4];\n   rtx atomic_insn;\n \n   if (TARGET_ATOMIC_HARD_LLCS\n       || (TARGET_SH4A && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n-    atomic_insn = gen_atomic_compare_and_swap<mode>_hard (old_val, addr,\n+    atomic_insn = gen_atomic_compare_and_swap<mode>_hard (old_val, mem,\n \t\t\t\t\t\t\t  exp_val, new_val);\n   else if (TARGET_ATOMIC_SOFT_GUSA)\n-    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_gusa (old_val, addr,\n+    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_gusa (old_val, mem,\n \t\t      exp_val, new_val);\n   else if (TARGET_ATOMIC_SOFT_TCB)\n-    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_tcb (old_val, addr,\n+    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_tcb (old_val, mem,\n \t\t      exp_val, new_val, TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n   else if (TARGET_ATOMIC_SOFT_IMASK)\n-    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_imask (old_val, addr,\n+    atomic_insn = gen_atomic_compare_and_swap<mode>_soft_imask (old_val, mem,\n \t\t      exp_val, new_val);\n   else\n     FAIL;\n@@ -254,33 +265,81 @@\n   DONE;\n })\n \n-(define_insn \"atomic_compare_and_swapsi_hard\"\n+(define_insn_and_split \"atomic_compare_and_swapsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(unspec_volatile:SI\n-\t  [(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  [(match_operand:SI 1 \"atomic_mem_operand_0\" \"=Sra\")\n \t   (match_operand:SI 2 \"arith_operand\" \"rI08\")\n \t   (match_operand:SI 3 \"arith_operand\" \"rI08\")]\n \t  UNSPECV_CMPXCHG_1))\n-   (set (mem:SI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_2))\n    (set (reg:SI T_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n    (clobber (reg:SI R0_REG))]\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,r0\"\t\t\"\\n\"\n \t \"\tcmp/eq\t%2,r0\"\t\t\"\\n\"\n \t \"\tbf{.|/}s\t0f\"\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n \t \"\tmov\t%3,r0\"\t\t\"\\n\"\n-\t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\"\t\t\"\\n\"\n \t \"0:\";\n+}\n+  \"&& can_create_pseudo_p () && !satisfies_constraint_I08 (operands[2])\"\n+  [(const_int 0)]\n+{\n+  /* FIXME: Sometimes the 'expected value' operand is not propagated as\n+     immediate value.  See PR 64974.  */\n+  set_of_reg op2 = sh_find_set_of_reg (operands[2], curr_insn,\n+\t\t\t\t       prev_nonnote_insn_bb);\n+  if (op2.set_src != NULL && satisfies_constraint_I08 (op2.set_src))\n+    {\n+      rtx* r = &XVECEXP (XEXP (XVECEXP (PATTERN (curr_insn), 0, 0), 1), 0, 1);\n+      validate_change (curr_insn, r, op2.set_src, false);\n+      DONE;\n+    }\n+  else\n+    FAIL;\n }\n   [(set_attr \"length\" \"14\")])\n \n-(define_insn \"atomic_compare_and_swap<mode>_hard\"\n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n+(define_insn_and_split \"atomic_compare_and_swap<mode>_hard\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(unspec_volatile:SI\n+\t  [(match_operand:QIHI 1 \"atomic_mem_operand_0\")\n+\t   (match_operand:QIHI 2 \"arith_reg_operand\")\n+\t   (match_operand:QIHI 3 \"arith_reg_operand\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (match_dup 1)\n+\t(unspec_volatile:QIHI [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (reg:SI T_REG)\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  rtx i = gen_atomic_compare_and_swap<mode>_hard_1 (\n+\t\toperands[0], XEXP (operands[1], 0), operands[2], operands[3]);\n+\n+  /* Replace the new mems in the new insn with the old mem to preserve\n+     aliasing info.  */\n+  XVECEXP (XEXP (XVECEXP (i, 0, 0), 1), 0, 0) = operands[1];\n+  XEXP (XVECEXP (i, 0, 1), 0) = operands[1];\n+  emit_insn (i);\n+})\n+\n+(define_insn \"atomic_compare_and_swap<mode>_hard_1\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(unspec_volatile:SI\n \t  [(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -319,11 +378,11 @@\n (define_insn \"atomic_compare_and_swap<mode>_soft_gusa\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&u\")\n \t(unspec_volatile:SI\n-\t  [(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\"))\n+\t  [(match_operand:QIHISI 1 \"atomic_mem_operand_0\" \"=AraAdd\")\n \t   (match_operand:QIHISI 2 \"arith_reg_operand\" \"u\")\n \t   (match_operand:QIHISI 3 \"arith_reg_operand\" \"u\")]\n \t  UNSPECV_CMPXCHG_1))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n    (set (reg:SI T_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n@@ -337,22 +396,22 @@\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tcmp/eq\t%0,%4\"\t\t\t\"\\n\"\n \t \"\tbf\t1f\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%3,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   [(set_attr \"length\" \"20\")])\n \n (define_insn \"atomic_compare_and_swap<mode>_soft_tcb\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(unspec_volatile:SI\n-\t  [(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  [(match_operand:QIHISI 1 \"atomic_mem_operand_0\" \"=SraSdd\")\n \t   (match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")\n \t   (match_operand:QIHISI 3 \"arith_reg_operand\" \"r\")]\n \t  UNSPECV_CMPXCHG_1))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n    (set (reg:SI T_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n@@ -367,23 +426,23 @@\n \t \"\t<i124extend_insn>\t%2,%5\"\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O4,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tcmp/eq\t%0,%5\"\t\t\t\"\\n\"\n \t \"\tbf\t1f\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%3,%1\"\t\t\"\\n\"\n \t \"1:\tmov.l\tr0,@(%O4,gbr)\";\n }\n   [(set_attr \"length\" \"22\")])\n \n (define_insn \"atomic_compare_and_swap<mode>_soft_imask\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&z\")\n \t(unspec_volatile:SI\n-\t  [(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  [(match_operand:QIHISI 1 \"atomic_mem_operand_0\" \"=SraSdd\")\n \t   (match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")\n \t   (match_operand:QIHISI 3 \"arith_reg_operand\" \"r\")]\n \t  UNSPECV_CMPXCHG_1))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n    (set (reg:SI T_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n@@ -402,10 +461,10 @@\n \t   \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n \t   \"\tshlr\t%5\"\t\t\t\"\\n\"\n \t   \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t   \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t   \"\tcmp/eq\t%4,%0\"\t\t\t\"\\n\"\n \t   \"\tbf\t1f\"\t\t\t\"\\n\"\n-\t   \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t%3,%1\"\t\t\"\\n\"\n \t   \"1:\trotcl\t%5\"\t\t\t\"\\n\"\n \t   \"\tldc\t%5,sr\";\n   else\n@@ -414,11 +473,11 @@\n \t   \"\tmov\t%0,%5\"\t\t\t\"\\n\"\n \t   \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n \t   \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t   \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t   \"\tcmp/eq\t%4,%0\"\t\t\t\"\\n\"\n \t   \"\tbst\t#0,%5\"\t\t\t\"\\n\"\n \t   \"\tbf\t1f\"\t\t\t\"\\n\"\n-\t   \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t   \"\tmov.<bwl>\t%3,%1\"\t\t\"\\n\"\n \t   \"1:\tldc\t%5,sr\";\n }\n   [(set (attr \"length\") (if_then_else (match_test \"!TARGET_SH2A\")\n@@ -430,25 +489,25 @@\n \n (define_expand \"atomic_exchange<mode>\"\n   [(match_operand:QIHISI 0 \"arith_reg_dest\")\t\t;; oldval output\n-   (match_operand:QIHISI 1 \"memory_operand\")\t\t;; memory\n+   (match_operand:QIHISI 1 \"atomic_mem_operand_0\")\t;; memory\n    (match_operand:QIHISI 2 \"atomic_arith_operand_0\")\t;; newval input\n    (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n   \"TARGET_ATOMIC_ANY\"\n {\n-  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx mem = operands[1];\n   rtx val = operands[2];\n   rtx atomic_insn;\n \n   if (TARGET_ATOMIC_HARD_LLCS\n       || (TARGET_SH4A && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n-    atomic_insn = gen_atomic_exchange<mode>_hard (operands[0], addr, val);\n+    atomic_insn = gen_atomic_exchange<mode>_hard (operands[0], mem, val);\n   else if (TARGET_ATOMIC_SOFT_GUSA)\n-    atomic_insn = gen_atomic_exchange<mode>_soft_gusa (operands[0], addr, val);\n+    atomic_insn = gen_atomic_exchange<mode>_soft_gusa (operands[0], mem, val);\n   else if (TARGET_ATOMIC_SOFT_TCB)\n-    atomic_insn = gen_atomic_exchange<mode>_soft_tcb (operands[0], addr, val,\n+    atomic_insn = gen_atomic_exchange<mode>_soft_tcb (operands[0], mem, val,\n \t\t      TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n   else if (TARGET_ATOMIC_SOFT_IMASK)\n-    atomic_insn = gen_atomic_exchange<mode>_soft_imask (operands[0], addr, val);\n+    atomic_insn = gen_atomic_exchange<mode>_soft_imask (operands[0], mem, val);\n   else\n     FAIL;\n \n@@ -465,24 +524,52 @@\n \n (define_insn \"atomic_exchangesi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:SI (match_dup 1))\n+\t(match_operand:SI 1 \"atomic_mem_operand_0\" \"=Sra\"))\n+   (set (match_dup 1)\n \t(unspec:SI\n \t  [(match_operand:SI 2 \"arith_operand\" \"rI08\")] UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))\n    (clobber (reg:SI R0_REG))]\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n \t \"\tmov\t%2,r0\"\t\t\"\\n\"\n-\t \"\tmovco.l r0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l r0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n   [(set_attr \"length\" \"10\")])\n \n-(define_insn \"atomic_exchange<mode>_hard\"\n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n+(define_insn_and_split \"atomic_exchange<mode>_hard\"\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\")\n+\t(match_operand:QIHI 1 \"atomic_mem_operand_0\"))\n+   (set (match_dup 1)\n+\t(unspec:QIHI\n+\t  [(match_operand:QIHI 2 \"arith_reg_operand\")] UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  rtx i = gen_atomic_exchange<mode>_hard_1 (operands[0], XEXP (operands[1], 0),\n+\t\t\t\t\t    operands[2]);\n+\n+  /* Replace the new mems in the new insn with the old mem to preserve\n+     aliasing info.  */\n+  XEXP (XVECEXP (i, 0, 0), 1) = operands[1];\n+  XEXP (XVECEXP (i, 0, 1), 0) = operands[1];\n+  emit_insn (i);\n+})\n+\n+(define_insn \"atomic_exchange<mode>_hard_1\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n@@ -511,8 +598,8 @@\n \n (define_insn \"atomic_exchange<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_0\" \"=AraAdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(match_operand:QIHISI 2 \"arith_reg_operand\" \"u\")] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n@@ -523,16 +610,16 @@\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%2,@%1\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%2,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   [(set_attr \"length\" \"14\")])\n \n (define_insn \"atomic_exchange<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_0\" \"=SraSdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n@@ -544,17 +631,17 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%2,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%2,%1\"\t\t\"\\n\"\n \t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n }\n   [(set_attr \"length\" \"16\")])\n \n (define_insn \"atomic_exchange<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&z\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_0\" \"=SraSdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")] UNSPEC_ATOMIC))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n@@ -564,8 +651,8 @@\n \t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n \t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n \t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%2,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%2,%1\"\t\t\"\\n\"\n \t \"\tldc\t%3,sr\";\n }\n   [(set_attr \"length\" \"14\")])\n@@ -610,9 +697,32 @@\n (define_code_attr fetchop_constraint_1_imask\n   [(plus \"rI08\") (minus \"r\") (ior \"rK08\") (xor \"rK08\") (and \"rK08\")])\n \n+;; Displacement addressing mode (incl. GBR relative) can be used by tcb and\n+;; imask atomic patterns in any mode, since all the patterns use R0 as the\n+;; register operand for memory loads/stores.  gusa and llcs patterns can only\n+;; use displacement addressing for SImode.\n+(define_predicate \"atomic_mem_operand_1\"\n+  (and (match_code \"mem\")\n+       (ior (match_operand 0 \"simple_mem_operand\")\n+\t    (and (match_test \"mode == SImode\")\n+\t\t (match_test \"TARGET_ATOMIC_SOFT_GUSA\n+\t\t\t      && (!TARGET_SH4A || TARGET_ATOMIC_STRICT)\")\n+\t\t (match_operand 0 \"displacement_mem_operand\")\n+\t\t (match_operand 0 \"short_displacement_mem_operand\"))\n+\t    (and (ior (match_test \"(TARGET_ATOMIC_SOFT_TCB\n+\t\t\t\t    || TARGET_ATOMIC_SOFT_IMASK)\n+\t\t\t\t   && (!TARGET_SH4A || TARGET_ATOMIC_STRICT)\")\n+\t\t      (match_test \"(TARGET_ATOMIC_SOFT_TCB\n+\t\t\t\t    || TARGET_ATOMIC_SOFT_IMASK)\n+\t\t\t\t   && TARGET_SH4A && !TARGET_ATOMIC_STRICT\n+\t\t\t\t   && mode != SImode\"))\n+\t\t (ior (and (match_operand 0 \"displacement_mem_operand\")\n+\t\t\t   (match_operand 0 \"short_displacement_mem_operand\"))\n+\t\t      (match_operand 0 \"gbr_address_mem\"))))))\n+\n (define_expand \"atomic_fetch_<fetchop_name><mode>\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n-\t(match_operand:QIHISI 1 \"memory_operand\"))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\"))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI (match_dup 1)\n@@ -621,22 +731,22 @@\n    (match_operand:SI 3 \"const_int_operand\")]\n   \"TARGET_ATOMIC_ANY\"\n {\n-  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx mem = operands[1];\n   rtx atomic_insn;\n \n   if (TARGET_ATOMIC_HARD_LLCS\n       || (TARGET_SH4A && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n-    atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_hard (operands[0], addr,\n+    atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_hard (operands[0], mem,\n \t\t\t\t\t\t\t      operands[2]);\n   else if (TARGET_ATOMIC_SOFT_GUSA)\n     atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft_gusa (operands[0],\n-\t\t      addr, operands[2]);\n+\t\t      mem, operands[2]);\n   else if (TARGET_ATOMIC_SOFT_TCB)\n     atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft_tcb (operands[0],\n-\t\t      addr, operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+\t\t      mem, operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n   else if (TARGET_ATOMIC_SOFT_IMASK)\n     atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft_imask (operands[0],\n-\t\t      addr, operands[2]);\n+\t\t      mem, operands[2]);\n   else\n     FAIL;\n \n@@ -653,10 +763,10 @@\n \n (define_insn_and_split \"atomic_fetch_<fetchop_name>si_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:SI (match_dup 1))\n+\t(match_operand:SI 1 \"atomic_mem_operand_1\" \"=Sra\"))\n+   (set (match_dup 1)\n \t(unspec:SI\n-\t  [(FETCHOP:SI (mem:SI (match_dup 1))\n+\t  [(FETCHOP:SI (match_dup 1)\n \t\t       (match_operand:SI 2 \"<fetchop_predicate_1>\"\n \t\t\t\t\t   \"<fetchop_constraint_1_llcs>\"))]\n \t  UNSPEC_ATOMIC))\n@@ -665,10 +775,10 @@\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,r0\"\t\"\\n\"\n-\t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -683,18 +793,18 @@\n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn_and_split \"atomic_fetch_notsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:SI (match_dup 1))\n-\t(unspec:SI [(not:SI (mem:SI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(match_operand:SI 1 \"atomic_mem_operand_1\" \"=Sra\"))\n+   (set (match_dup 1)\n+\t(unspec:SI [(not:SI (match_dup 1))] UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))\n    (clobber (reg:SI R0_REG))]\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\"\\n\"\n-\t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -705,7 +815,44 @@\n }\n   [(set_attr \"length\" \"10\")])\n \n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n (define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_hard\"\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\")\n+\t(match_operand:QIHI 1 \"atomic_mem_operand_1\"))\n+   (set (match_dup 1)\n+\t(unspec:QIHI\n+\t  [(FETCHOP:QIHI (match_dup 1)\n+\t\t\t (match_operand:QIHI 2 \"<fetchop_predicate_1>\"))]\n+\t  UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  if (optimize\n+      && sh_reg_dead_or_unused_after_insn (curr_insn, REGNO (operands[0])))\n+    emit_insn (gen_atomic_<fetchop_name><mode>_hard (operands[1], operands[2]));\n+  else\n+    {\n+      rtx i = gen_atomic_fetch_<fetchop_name><mode>_hard_1 (\n+\t\t\toperands[0], XEXP (operands[1], 0), operands[2]);\n+\n+      /* Replace the new mems in the new insn with the old mem to preserve\n+\t aliasing info.  */\n+      XEXP (XVECEXP (i, 0, 0), 1) = operands[1];\n+      XEXP (XVECEXP (i, 0, 1), 0) = operands[1];\n+      XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 1), 1), 0, 0), 0) = operands[1];\n+      emit_insn (i);\n+    }\n+})\n+\n+(define_insn \"atomic_fetch_<fetchop_name><mode>_hard_1\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n@@ -735,15 +882,36 @@\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n-  \"&& can_create_pseudo_p () && optimize\n-   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(set_attr \"length\" \"28\")])\n+\n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n+(define_insn_and_split \"atomic_<fetchop_name><mode>_hard\"\n+  [(set (match_operand:QIHI 0 \"atomic_mem_operand_1\")\n+\t(unspec:QIHI\n+\t  [(FETCHOP:QIHI (match_dup 0)\n+\t\t\t (match_operand:QIHI 1 \"<fetchop_predicate_1>\"))]\n+\t  UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n   [(const_int 0)]\n {\n-  emit_insn (gen_atomic_<fetchop_name><mode>_hard (operands[1], operands[2]));\n-}\n-  [(set_attr \"length\" \"28\")])\n+  rtx i = gen_atomic_<fetchop_name><mode>_hard_1 (XEXP (operands[0], 0),\n+\t\t\t\t\t\t  operands[1]);\n+  /* Replace the new mems in the new insn with the old mem to preserve\n+     aliasing info.  */\n+  XEXP (XVECEXP (i, 0, 0), 0) = operands[0];\n+  XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 0), 1), 0, 0), 0) = operands[0];\n+  emit_insn (i);\n+})\n \n-(define_insn \"atomic_<fetchop_name><mode>_hard\"\n+(define_insn \"atomic_<fetchop_name><mode>_hard_1\"\n   [(set (mem:QIHI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n \t(unspec:QIHI\n \t  [(FETCHOP:QIHI (mem:QIHI (match_dup 0))\n@@ -802,7 +970,14 @@\n    && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n   [(const_int 0)]\n {\n-  emit_insn (gen_atomic_not<mode>_hard (operands[1]));\n+  rtx i = gen_atomic_not<mode>_hard (operands[1]);\n+\n+  /* Replace the new mems in the new insn with the old mem to preserve\n+     aliasing info.  */\n+  rtx m = XEXP (XVECEXP (PATTERN (curr_insn), 0, 0), 1);\n+  XEXP (XVECEXP (i, 0, 0), 0) = m;\n+  XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 0), 1), 0, 0), 0) = m;\n+  emit_insn (i);\n }\n   [(set_attr \"length\" \"26\")])\n \n@@ -833,11 +1008,11 @@\n \n (define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=AraAdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI\n-\t\t(mem:QIHISI (match_dup 1))\n+\t\t(match_dup 1)\n \t\t(match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n \t\t\t\t\t\"<fetchop_constraint_1_gusa>\"))]\n \t  UNSPEC_ATOMIC))\n@@ -850,10 +1025,10 @@\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,%3\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%3,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -868,9 +1043,9 @@\n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn_and_split \"atomic_fetch_not<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n-   (set (mem:QIHISI (match_dup 1))\n-\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=AraAdd\"))\n+   (set (match_dup 1)\n+\t(unspec:QIHISI [(not:QIHISI (match_dup 1))] UNSPEC_ATOMIC))\n    (clobber (match_scratch:QIHISI 2 \"=&u\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n@@ -880,9 +1055,9 @@\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tnot\t%0,%2\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%2,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%2,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -896,11 +1071,11 @@\n \n (define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI\n-\t\t(mem:QIHISI (match_dup 1))\n+\t\t(match_dup 1)\n \t\t(match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n \t\t\t\t\t\"<fetchop_constraint_1_tcb>\"))]\n \t  UNSPEC_ATOMIC))\n@@ -913,10 +1088,10 @@\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n }\n@@ -930,10 +1105,10 @@\n   [(set_attr \"length\" \"20\")])\n \n (define_insn \"atomic_<fetchop_name><mode>_soft_tcb\"\n-  [(set (mem:QIHISI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+  [(set (match_operand:QIHISI 0 \"atomic_mem_operand_1\" \"=SraSdd\")\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI\n-\t\t(mem:QIHISI (match_dup 0))\n+\t\t(match_dup 0)\n \t\t(match_operand:QIHISI 1 \"<fetchop_predicate_1>\"\n \t\t\t\t\t\"<fetchop_constraint_1_tcb>\"))]\n \t  UNSPEC_ATOMIC))\n@@ -946,9 +1121,9 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%0,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%0,r0\"\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%1,r0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%0\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\";\n }\n@@ -957,9 +1132,9 @@\n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn_and_split \"atomic_fetch_not<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n-\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\"))\n+   (set (match_dup 1)\n+\t(unspec:QIHISI [(not:QIHISI (match_dup 1))] UNSPEC_ATOMIC))\n    (use (match_operand:SI 2 \"gbr_displacement\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n@@ -969,10 +1144,10 @@\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\";\n }\n@@ -985,8 +1160,8 @@\n   [(set_attr \"length\" \"20\")])\n \n (define_insn \"atomic_not<mode>_soft_tcb\"\n-  [(set (mem:QIHISI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n-\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 0)))] UNSPEC_ATOMIC))\n+  [(set (match_operand:QIHISI 0 \"atomic_mem_operand_1\" \"=SraSdd\")\n+\t(unspec:QIHISI [(not:QIHISI (match_dup 0))] UNSPEC_ATOMIC))\n    (use (match_operand:SI 1 \"gbr_displacement\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n@@ -996,21 +1171,21 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O1,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%0,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%0,r0\"\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%0\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O1,gbr)\";\n }\n   [(set_attr \"length\" \"18\")])\n \n (define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI\n-\t\t(mem:QIHISI (match_dup 1))\n+\t\t(match_dup 1)\n \t\t(match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n \t\t\t\t\t\"<fetchop_constraint_1_imask>\"))]\n \t  UNSPEC_ATOMIC))\n@@ -1022,10 +1197,10 @@\n \t \"\tmov\tr0,%3\"\t\t\t\"\\n\"\n \t \"\tor\t#0xF0,r0\"\t\t\"\\n\"\n \t \"\tldc\tr0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"\tldc\t%3,sr\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -1040,9 +1215,9 @@\n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn_and_split \"atomic_fetch_not<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n-\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\"))\n+   (set (match_dup 1)\n+\t(unspec:QIHISI [(not:QIHISI (match_dup 1))] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (match_scratch:QIHISI 2 \"=&r\"))]\n   \"TARGET_ATOMIC_SOFT_IMASK\"\n@@ -1051,10 +1226,10 @@\n \t \"\tmov\tr0,%2\"\t\t\t\"\\n\"\n \t \"\tor\t#0xF0,r0\"\t\t\"\\n\"\n \t \"\tldc\tr0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"\tldc\t%2,sr\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -1068,7 +1243,7 @@\n \n (define_expand \"atomic_fetch_nand<mode>\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n-\t(match_operand:QIHISI 1 \"memory_operand\"))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\"))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(not:QIHISI (and:QIHISI (match_dup 1)\n@@ -1077,21 +1252,21 @@\n    (match_operand:SI 3 \"const_int_operand\")]\n   \"TARGET_ATOMIC_ANY\"\n {\n-  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx mem = operands[1];\n   rtx atomic_insn;\n \n   if (TARGET_ATOMIC_HARD_LLCS\n       || (TARGET_SH4A && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n-    atomic_insn = gen_atomic_fetch_nand<mode>_hard (operands[0], addr,\n+    atomic_insn = gen_atomic_fetch_nand<mode>_hard (operands[0], mem,\n \t\t\t\t\t\t    operands[2]);\n   else if (TARGET_ATOMIC_SOFT_GUSA)\n-    atomic_insn = gen_atomic_fetch_nand<mode>_soft_gusa (operands[0], addr,\n+    atomic_insn = gen_atomic_fetch_nand<mode>_soft_gusa (operands[0], mem,\n \t\t\t\t\t\t\t operands[2]);\n   else if (TARGET_ATOMIC_SOFT_TCB)\n-    atomic_insn = gen_atomic_fetch_nand<mode>_soft_tcb (operands[0], addr,\n+    atomic_insn = gen_atomic_fetch_nand<mode>_soft_tcb (operands[0], mem,\n \t\t      operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n   else if (TARGET_ATOMIC_SOFT_IMASK)\n-    atomic_insn = gen_atomic_fetch_nand<mode>_soft_imask (operands[0], addr,\n+    atomic_insn = gen_atomic_fetch_nand<mode>_soft_imask (operands[0], mem,\n \t\t\t\t\t\t\t  operands[2]);\n   else\n     FAIL;\n@@ -1109,22 +1284,22 @@\n \n (define_insn_and_split \"atomic_fetch_nandsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:SI (match_dup 1))\n+\t(match_operand:SI 1 \"atomic_mem_operand_1\" \"=Sra\"))\n+   (set (match_dup 1)\n \t(unspec:SI\n-\t  [(not:SI (and:SI (mem:SI (match_dup 1))\n+\t  [(not:SI (and:SI (match_dup 1)\n \t\t   (match_operand:SI 2 \"logical_operand\" \"rK08\")))]\n \t  UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))\n    (clobber (reg:SI R0_REG))]\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\"\\n\"\n \t \"\tand\t%2,r0\"\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\"\\n\"\n-\t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -1136,7 +1311,45 @@\n }\n   [(set_attr \"length\" \"12\")])\n \n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n (define_insn_and_split \"atomic_fetch_nand<mode>_hard\"\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\")\n+\t(match_operand:QIHI 1 \"atomic_mem_operand_1\"))\n+   (set (match_dup 1)\n+\t(unspec:QIHI\n+\t  [(not:QIHI (and:QIHI (match_dup 1)\n+\t\t     (match_operand:QIHI 2 \"logical_operand\" \"rK08\")))]\n+\t  UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  if (optimize\n+      && sh_reg_dead_or_unused_after_insn (curr_insn, REGNO (operands[0])))\n+    emit_insn (gen_atomic_nand<mode>_hard (operands[1], operands[2]));\n+  else\n+    {\n+      rtx i = gen_atomic_fetch_nand<mode>_hard_1 (\n+\t\t\toperands[0], XEXP (operands[1], 0), operands[2]);\n+\n+      /* Replace the new mems in the new insn with the old mem to preserve\n+\t aliasing info.  */\n+      XEXP (XVECEXP (i, 0, 0), 1) = operands[1];\n+      XEXP (XVECEXP (i, 0, 1), 0) = operands[1];\n+      XEXP (XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 1), 1), 0, 0), 0),\n+\t    0) = operands[1];\n+      emit_insn (i);\n+    }\n+})\n+\n+(define_insn \"atomic_fetch_nand<mode>_hard_1\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n@@ -1166,15 +1379,36 @@\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n-  \"&& can_create_pseudo_p () && optimize\n-   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(set_attr \"length\" \"30\")])\n+\n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n+(define_insn_and_split \"atomic_nand<mode>_hard\"\n+  [(set (match_operand:QIHI 0 \"atomic_mem_operand_1\")\n+\t(unspec:QIHI\n+\t  [(not:QIHI (and:QIHI (match_dup 0)\n+\t\t\t       (match_operand:QIHI 1 \"logical_operand\")))]\n+\t  UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n   [(const_int 0)]\n {\n-  emit_insn (gen_atomic_nand<mode>_hard (operands[1], operands[2]));\n-}\n-  [(set_attr \"length\" \"30\")])\n+  rtx i = gen_atomic_nand<mode>_hard_1 (XEXP (operands[0], 0), operands[1]);\n \n-(define_insn \"atomic_nand<mode>_hard\"\n+  /* Replace the new mems in the new insn with the old mem to preserve\n+     aliasing info.  */\n+  XEXP (XVECEXP (i, 0, 0), 0) = operands[0];\n+  XEXP (XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 0), 1), 0, 0), 0), 0) = operands[0];\n+  emit_insn (i);\n+})\n+\n+(define_insn \"atomic_nand<mode>_hard_1\"\n   [(set (mem:QIHI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n \t(unspec:QIHI\n \t  [(not:QIHI (and:QIHI (mem:QIHI (match_dup 0))\n@@ -1205,11 +1439,11 @@\n \n (define_insn_and_split \"atomic_fetch_nand<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=AraAdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(not:QIHISI\n-\t     (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t     (and:QIHISI (match_dup 1)\n \t\t\t (match_operand:QIHISI 2 \"arith_reg_operand\" \"u\")))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:QIHISI 3 \"=&u\"))\n@@ -1221,11 +1455,11 @@\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tmov\t%2,%3\"\t\t\t\"\\n\"\n \t \"\tand\t%0,%3\"\t\t\t\"\\n\"\n \t \"\tnot\t%3,%3\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%3,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -1239,11 +1473,11 @@\n \n (define_insn_and_split \"atomic_fetch_nand<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(not:QIHISI\n-\t     (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t     (and:QIHISI (match_dup 1)\n \t\t\t (match_operand:QIHISI 2 \"logical_operand\" \"rK08\")))]\n \t  UNSPEC_ATOMIC))\n    (use (match_operand:SI 3 \"gbr_displacement\"))\n@@ -1255,11 +1489,11 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n }\n@@ -1273,10 +1507,10 @@\n   [(set_attr \"length\" \"22\")])\n \n (define_insn \"atomic_nand<mode>_soft_tcb\"\n-  [(set (mem:QIHISI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+  [(set (match_operand:QIHISI 0 \"atomic_mem_operand_1\" \"=SraSdd\")\n \t(unspec:QIHISI\n \t  [(not:QIHISI\n-\t     (and:QIHISI (mem:QIHISI (match_dup 0))\n+\t     (and:QIHISI (match_dup 0)\n \t\t\t (match_operand:QIHISI 1 \"logical_operand\" \"rK08\")))]\n \t  UNSPEC_ATOMIC))\n    (use (match_operand:SI 2 \"gbr_displacement\"))\n@@ -1288,22 +1522,22 @@\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%0,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%0,r0\"\t\t\"\\n\"\n \t \"\tand\t%1,r0\"\t\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%0\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\";\n }\n   [(set_attr \"length\" \"20\")])\n \n (define_insn_and_split \"atomic_fetch_nand<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (set (mem:QIHISI (match_dup 1))\n+\t(match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\"))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(not:QIHISI\n-\t     (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t     (and:QIHISI (match_dup 1)\n \t\t\t (match_operand:QIHISI 2 \"logical_operand\" \"rK08\")))]\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n@@ -1314,11 +1548,11 @@\n \t \"\tmov\tr0,%3\"\t\t\t\"\\n\"\n \t \"\tor\t#0xF0,r0\"\t\t\"\\n\"\n \t \"\tldc\tr0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"\tldc\t%3,sr\";\n }\n   \"&& can_create_pseudo_p () && optimize\n@@ -1336,7 +1570,7 @@\n (define_expand \"atomic_<fetchop_name>_fetch<mode>\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n \t(FETCHOP:QIHISI\n-\t  (match_operand:QIHISI 1 \"memory_operand\")\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\")\n \t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\")))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n@@ -1345,22 +1579,22 @@\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n   \"TARGET_ATOMIC_ANY\"\n {\n-  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx mem = operands[1];\n   rtx atomic_insn;\n \n   if (TARGET_ATOMIC_HARD_LLCS\n       || (TARGET_SH4A && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n-    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_hard (operands[0], addr,\n+    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_hard (operands[0], mem,\n \t\t\t\t\t\t\t      operands[2]);\n   else if (TARGET_ATOMIC_SOFT_GUSA)\n     atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft_gusa (operands[0],\n-\t\t      addr, operands[2]);\n+\t\t      mem, operands[2]);\n   else if (TARGET_ATOMIC_SOFT_TCB)\n     atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft_tcb (operands[0],\n-\t\t      addr, operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n+\t\t      mem, operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n   else if (TARGET_ATOMIC_SOFT_IMASK)\n     atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft_imask (operands[0],\n-\t\t      addr, operands[2]);\n+\t\t      mem, operands[2]);\n   else\n     FAIL;\n \n@@ -1378,42 +1612,77 @@\n (define_insn \"atomic_<fetchop_name>_fetchsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&z\")\n \t(FETCHOP:SI\n-\t  (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:SI 1 \"atomic_mem_operand_1\" \"=Sra\")\n \t  (match_operand:SI 2 \"<fetchop_predicate_1>\"\n \t\t\t      \"<fetchop_constraint_1_llcs>\")))\n-   (set (mem:SI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:SI\n-\t  [(FETCHOP:SI (mem:SI (match_dup 1)) (match_dup 2))]\n+\t  [(FETCHOP:SI (match_dup 1) (match_dup 2))]\n \t  UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))]\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,%0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,%0\"\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,%0\"\t\"\\n\"\n-\t \"\tmovco.l\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l\t%0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n   [(set_attr \"length\" \"8\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn \"atomic_not_fetchsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&z\")\n-\t(not:SI (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n-   (set (mem:SI (match_dup 1))\n-\t(unspec:SI [(not:SI (mem:SI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(not:SI (match_operand:SI 1 \"atomic_mem_operand_1\" \"=Sra\")))\n+   (set (match_dup 1)\n+\t(unspec:SI [(not:SI (match_dup 1))] UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))]\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,%0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,%0\"\t\t\"\\n\"\n \t \"\tnot\t%0,%0\"\t\t\"\\n\"\n-\t \"\tmovco.l\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l\t%0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n   [(set_attr \"length\" \"8\")])\n \n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n (define_insn_and_split \"atomic_<fetchop_name>_fetch<mode>_hard\"\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n+\t(FETCHOP:QIHI (match_operand:QIHI 1 \"atomic_mem_operand_1\")\n+\t\t      (match_operand:QIHI 2 \"<fetchop_predicate_1>\")))\n+   (set (match_dup 1) (unspec:QIHI [(FETCHOP:QIHI (match_dup 1) (match_dup 2))]\n+\t\t\t\t   UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  if (optimize\n+      && sh_reg_dead_or_unused_after_insn (curr_insn, REGNO (operands[0])))\n+    emit_insn (gen_atomic_<fetchop_name><mode>_hard (operands[1], operands[2]));\n+  else\n+    {\n+      rtx i = gen_atomic_<fetchop_name>_fetch<mode>_hard_1 (\n+\t\t\toperands[0], XEXP (operands[1], 0), operands[2]);\n+\n+      /* Replace the new mems in the new insn with the old mem to preserve\n+\t aliasing info.  */\n+      XEXP (XEXP (XVECEXP (i, 0, 0), 1), 0) = operands[1];\n+      XEXP (XVECEXP (i, 0, 1), 0) = operands[1];\n+      XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 1), 1), 0, 0), 0) = operands[1];\n+      emit_insn (i);\n+    }\n+})\n+\n+(define_insn \"atomic_<fetchop_name>_fetch<mode>_hard_1\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(FETCHOP:QIHI\n \t  (mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -1443,12 +1712,6 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n-}\n-  \"&& can_create_pseudo_p () && optimize\n-   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n-  [(const_int 0)]\n-{\n-  emit_insn (gen_atomic_<fetchop_name><mode>_hard (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"28\")])\n \n@@ -1483,19 +1746,26 @@\n    && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n   [(const_int 0)]\n {\n-  emit_insn (gen_atomic_not<mode>_hard (operands[1]));\n+  rtx i = gen_atomic_not<mode>_hard (operands[1]);\n+\n+  /* Replace the new mems in the new insn with the old mem to preserve\n+     aliasing info.  */\n+  rtx m = XEXP (XEXP (XVECEXP (PATTERN (curr_insn), 0, 0), 1), 0);\n+  XEXP (XVECEXP (i, 0, 0), 0) = m;\n+  XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 0), 1), 0, 0), 0) = m;\n+  emit_insn (i);\n }\n   [(set_attr \"length\" \"28\")])\n \n (define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n \t(FETCHOP:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\"))\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=AraAdd\")\n \t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n \t\t\t\t  \"<fetchop_constraint_1_gusa>\")))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n-\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n+\t  [(FETCHOP:QIHISI (match_dup 1) (match_dup 2))]\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n@@ -1505,19 +1775,19 @@\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,%0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   [(set_attr \"length\" \"16\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn \"atomic_not_fetch<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n-\t(not:QIHISI (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\"))))\n-   (set (mem:QIHISI (match_dup 1))\n-\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(not:QIHISI (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=AraAdd\")))\n+   (set (match_dup 1)\n+\t(unspec:QIHISI [(not:QIHISI (match_dup 1))] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_ATOMIC_SOFT_GUSA\"\n@@ -1526,22 +1796,22 @@\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tnot\t%0,%0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n+\t \"\tnot\t%0,%0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   [(set_attr \"length\" \"16\")])\n \n (define_insn_and_split \"atomic_<fetchop_name>_fetch<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(FETCHOP:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\")\n \t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n \t\t\t\t  \"<fetchop_constraint_1_tcb>\")))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n-\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n+\t  [(FETCHOP:QIHISI (match_dup 1) (match_dup 2))]\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))\n@@ -1552,9 +1822,9 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n@@ -1571,9 +1841,9 @@\n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn_and_split \"atomic_not_fetch<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n-\t(not:QIHISI (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n-   (set (mem:QIHISI (match_dup 1))\n-\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(not:QIHISI (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\")))\n+   (set (match_dup 1)\n+\t(unspec:QIHISI [(not:QIHISI (match_dup 1))] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))\n    (use (match_operand:SI 2 \"gbr_displacement\"))]\n@@ -1583,9 +1853,9 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n-\t \"\tnot\tr0,r0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\";\n@@ -1601,12 +1871,12 @@\n (define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&z\")\n \t(FETCHOP:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\")\n \t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n \t\t\t\t  \"<fetchop_constraint_1_imask>\")))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n-\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n+\t  [(FETCHOP:QIHISI (match_dup 1) (match_dup 2))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n   \"TARGET_ATOMIC_SOFT_IMASK\"\n@@ -1615,37 +1885,37 @@\n \t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n \t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n \t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\t<fetchop_name>\t%2,%0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,%1\"\t\t\"\\n\"\n \t \"\tldc\t%3,sr\";\n }\n   [(set_attr \"length\" \"16\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n (define_insn \"atomic_not_fetch<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&z\")\n-\t(not:QIHISI (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n-   (set (mem:QIHISI (match_dup 1))\n-\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 1)))] UNSPEC_ATOMIC))\n+\t(not:QIHISI (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\")))\n+   (set (match_dup 1)\n+\t(unspec:QIHISI [(not:QIHISI (match_dup 1))] UNSPEC_ATOMIC))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n   \"TARGET_ATOMIC_SOFT_IMASK\"\n {\n   return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n \t \"\tmov\t%0,%2\"\t\t\t\"\\n\"\n \t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n \t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tnot\t%0,%0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n+\t \"\tnot\t%0,%0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,%1\"\t\t\"\\n\"\n \t \"\tldc\t%2,sr\";\n }\n   [(set_attr \"length\" \"16\")])\n \n (define_expand \"atomic_nand_fetch<mode>\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n \t(not:QIHISI (and:QIHISI\n-\t  (match_operand:QIHISI 1 \"memory_operand\")\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\")\n \t  (match_operand:QIHISI 2 \"atomic_logical_operand_1\"))))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n@@ -1654,21 +1924,21 @@\n    (match_operand:SI 3 \"const_int_operand\")]\n   \"TARGET_ATOMIC_ANY\"\n {\n-  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx mem = operands[1];\n   rtx atomic_insn;\n \n   if (TARGET_ATOMIC_HARD_LLCS\n       || (TARGET_SH4A && <MODE>mode == SImode && !TARGET_ATOMIC_STRICT))\n-    atomic_insn = gen_atomic_nand_fetch<mode>_hard (operands[0], addr,\n+    atomic_insn = gen_atomic_nand_fetch<mode>_hard (operands[0], mem,\n \t\t\t\t\t\t    operands[2]);\n   else if (TARGET_ATOMIC_SOFT_GUSA)\n-    atomic_insn = gen_atomic_nand_fetch<mode>_soft_gusa (operands[0], addr,\n+    atomic_insn = gen_atomic_nand_fetch<mode>_soft_gusa (operands[0], mem,\n \t\t\t\t\t\t\t operands[2]);\n   else if (TARGET_ATOMIC_SOFT_TCB)\n-    atomic_insn = gen_atomic_nand_fetch<mode>_soft_tcb (operands[0], addr,\n+    atomic_insn = gen_atomic_nand_fetch<mode>_soft_tcb (operands[0], mem,\n \t\t      operands[2], TARGET_ATOMIC_SOFT_TCB_GBR_OFFSET_RTX);\n   else if (TARGET_ATOMIC_SOFT_IMASK)\n-    atomic_insn = gen_atomic_nand_fetch<mode>_soft_imask (operands[0], addr,\n+    atomic_insn = gen_atomic_nand_fetch<mode>_soft_imask (operands[0], mem,\n \t\t\t\t\t\t\t  operands[2]);\n   else\n     FAIL;\n@@ -1686,25 +1956,62 @@\n \n (define_insn \"atomic_nand_fetchsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&z\")\n-\t(not:SI (and:SI (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t(not:SI (and:SI (match_operand:SI 1 \"atomic_mem_operand_1\" \"=Sra\")\n \t\t\t(match_operand:SI 2 \"logical_operand\" \"rK08\"))))\n-   (set (mem:SI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:SI\n-\t  [(not:SI (and:SI (mem:SI (match_dup 1)) (match_dup 2)))]\n+\t  [(not:SI (and:SI (match_dup 1) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))]\n   \"TARGET_ATOMIC_HARD_LLCS\n    || (TARGET_SH4A && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)\"\n {\n-  return \"\\r0:\tmovli.l\t@%1,%0\"\t\t\"\\n\"\n+  return \"\\r0:\tmovli.l\t%1,%0\"\t\t\"\\n\"\n \t \"\tand\t%2,%0\"\t\t\"\\n\"\n \t \"\tnot\t%0,%0\"\t\t\"\\n\"\n-\t \"\tmovco.l\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmovco.l\t%0,%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n }\n   [(set_attr \"length\" \"10\")])\n \n+;; The QIHImode llcs patterns modify the address register of the memory\n+;; operand.  In order to express that, we have to open code the memory\n+;; operand.  Initially the insn is expanded like every other atomic insn\n+;; using the memory operand.  In split1 the insn is converted and the\n+;; memory operand's address register is exposed.\n (define_insn_and_split \"atomic_nand_fetch<mode>_hard\"\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n+\t(not:QIHI (and:QIHI (match_operand:QIHI 1 \"atomic_mem_operand_1\")\n+\t\t\t    (match_operand:QIHI 2 \"logical_operand\"))))\n+   (set (match_dup 1)\n+\t(unspec:QIHI [(not:QIHI (and:QIHI (match_dup 1) (match_dup 2)))]\n+\t\t     UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ATOMIC_HARD_LLCS && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  if (optimize\n+      && sh_reg_dead_or_unused_after_insn (curr_insn, REGNO (operands[0])))\n+    emit_insn (gen_atomic_nand<mode>_hard (operands[1], operands[2]));\n+  else\n+    {\n+      rtx i = gen_atomic_nand_fetch<mode>_hard_1 (\n+\t\t\toperands[0], XEXP (operands[1], 0), operands[2]);\n+      \n+      /* Replace the new mems in the new insn with the old mem to preserve\n+\t aliasing info.  */\n+      XEXP (XEXP (XEXP (XVECEXP (i, 0, 0), 1), 0), 0) = operands[1];\n+      XEXP (XVECEXP (i, 0, 1), 0) = operands[1];\n+      XEXP (XEXP (XVECEXP (XEXP (XVECEXP (i, 0, 1), 1), 0, 0), 0),\n+\t    0) = operands[1];\n+      emit_insn (i);\n+    }\n+})\n+\n+(define_insn \"atomic_nand_fetch<mode>_hard_1\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHI\n \t  (and:QIHI (mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -1733,23 +2040,17 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n-}\n-  \"&& can_create_pseudo_p () && optimize\n-   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n-  [(const_int 0)]\n-{\n-  emit_insn (gen_atomic_nand<mode>_hard (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"28\")])\n \n (define_insn \"atomic_nand_fetch<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n \t(not:QIHISI (and:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\"))\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=AraAdd\")\n \t  (match_operand:QIHISI 2 \"arith_reg_operand\" \"u\"))))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n-\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]\n+\t  [(not:QIHISI (and:QIHISI (match_dup 1) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n@@ -1759,22 +2060,22 @@\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tand\t%2,%0\"\t\t\t\"\\n\"\n \t \"\tnot\t%0,%0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n }\n   [(set_attr \"length\" \"18\")])\n \n (define_insn_and_split \"atomic_nand_fetch<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHISI (and:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\")\n \t  (match_operand:QIHISI 2 \"logical_operand\" \"rK08\"))))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n-\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]\n+\t  [(not:QIHISI (and:QIHISI (match_dup 1) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))\n@@ -1785,11 +2086,11 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t%1,r0\"\t\t\"\\n\"\n \t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n \t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n }\n@@ -1805,11 +2106,11 @@\n (define_insn \"atomic_nand_fetch<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&z\")\n \t(not:QIHISI (and:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 1 \"atomic_mem_operand_1\" \"=SraSdd\")\n \t  (match_operand:QIHISI 2 \"logical_operand\" \"rK08\"))))\n-   (set (mem:QIHISI (match_dup 1))\n+   (set (match_dup 1)\n \t(unspec:QIHISI\n-\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]\n+\t  [(not:QIHISI (and:QIHISI (match_dup 1) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n   \"TARGET_ATOMIC_SOFT_IMASK\"\n@@ -1818,10 +2119,10 @@\n \t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n \t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n \t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%1,%0\"\t\t\"\\n\"\n \t \"\tand\t%2,%0\"\t\t\t\"\\n\"\n \t \"\tnot\t%0,%0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t%0,%1\"\t\t\"\\n\"\n \t \"\tldc\t%3,sr\";\n }\n   [(set_attr \"length\" \"18\")])"}, {"sha": "d7881d584ebe53267978edb3afaa50fce5e90a30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -1,3 +1,12 @@\n+2015-02-10  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/64661\n+\t* gcc.taget/sh/pr64661-0.h: New.\n+\t* gcc.taget/sh/pr64661-1.c: New.\n+\t* gcc.taget/sh/pr64661-2.c: New.\n+\t* gcc.taget/sh/pr64661-3.c: New.\n+\t* gcc.taget/sh/pr64661-4.c: New.\n+\n 2015-02-10  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/64995"}, {"sha": "3f1d901f24e495c1e112ae4fdca0888cc8c3285e", "filename": "gcc/testsuite/gcc.target/sh/pr64661-0.h", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-0.h?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -0,0 +1,171 @@\n+/* Check that addressing modes for atomics are generated as expected.  */\n+\n+#define concat_1(x, y) x ## y\n+#define concat(x, y) concat_1 (x, y)\n+#define makefuncname(name) concat (concat (test_, __LINE__), name)\n+\n+#define emitfuncs(name,val,off)\\\n+  char makefuncname (_0) (char* mem)\\\n+  {\\\n+    return name (mem + off, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  char makefuncname (_1) (void)\\\n+  {\\\n+    char* mem = (char*)__builtin_thread_pointer ();\\\n+    return name (mem + off, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  short makefuncname (_2) (short* mem)\\\n+  {\\\n+    return name (mem + off, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  short makefuncname (_3) (void)\\\n+  {\\\n+    short* mem = (short*)__builtin_thread_pointer ();\\\n+    return name (mem + off, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  int makefuncname (_4) (int* mem)\\\n+  {\\\n+    return name (mem + off, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  int makefuncname (_5) (void)\\\n+  {\\\n+    int* mem = (int*)__builtin_thread_pointer ();\\\n+    return name (mem + off, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+\n+emitfuncs (__atomic_add_fetch, 1, 0)\n+emitfuncs (__atomic_add_fetch, 1, 4)\n+\n+emitfuncs (__atomic_fetch_add, 1, 0)\n+emitfuncs (__atomic_fetch_add, 1, 4)\n+\n+emitfuncs (__atomic_sub_fetch, 1, 0)\n+emitfuncs (__atomic_sub_fetch, 1, 4)\n+emitfuncs (__atomic_fetch_sub, 1, 0)\n+emitfuncs (__atomic_fetch_sub, 1, 4)\n+\n+emitfuncs (__atomic_and_fetch, 1, 0)\n+emitfuncs (__atomic_and_fetch, 1, 4)\n+emitfuncs (__atomic_fetch_and, 1, 0)\n+emitfuncs (__atomic_fetch_and, 1, 4)\n+\n+emitfuncs (__atomic_or_fetch, 1, 0)\n+emitfuncs (__atomic_or_fetch, 1, 4)\n+emitfuncs (__atomic_fetch_or, 1, 0)\n+emitfuncs (__atomic_fetch_or, 1, 4)\n+\n+emitfuncs (__atomic_xor_fetch, 1, 0)\n+emitfuncs (__atomic_xor_fetch, 1, 4)\n+emitfuncs (__atomic_fetch_xor, 1, 0)\n+emitfuncs (__atomic_fetch_xor, 1, 4)\n+\n+emitfuncs (__atomic_nand_fetch, 1, 0)\n+emitfuncs (__atomic_nand_fetch, 1, 4)\n+emitfuncs (__atomic_fetch_nand, 1, 0)\n+emitfuncs (__atomic_fetch_nand, 1, 4)\n+\n+emitfuncs (__atomic_xor_fetch, -1, 0)\n+emitfuncs (__atomic_xor_fetch, -1, 4)\n+emitfuncs (__atomic_fetch_xor, -1, 0)\n+emitfuncs (__atomic_fetch_xor, -1, 4)\n+\n+emitfuncs (__atomic_nand_fetch, -1, 0)\n+emitfuncs (__atomic_nand_fetch, -1, 4)\n+emitfuncs (__atomic_fetch_nand, -1, 0)\n+emitfuncs (__atomic_fetch_nand, -1, 4)\n+\n+#undef emitfuncs\n+#define emitfuncs(off)\\\n+  char makefuncname (_6) (char* mem)\\\n+  {\\\n+    char expected = 1;\\\n+    char desired = 5;\\\n+    return __atomic_compare_exchange (mem + off, &expected, &desired, 0,\\\n+\t\t\t\t      __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\\\n+  }\\\n+  char makefuncname (_7) (void)\\\n+  {\\\n+    char* mem = (char*)__builtin_thread_pointer ();\\\n+    char expected = 1;\\\n+    char desired = 5;\\\n+    return __atomic_compare_exchange (mem + off, &expected, &desired, 0,\\\n+\t\t\t\t      __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\\\n+  }\\\n+  short makefuncname (_8) (short* mem)\\\n+  {\\\n+    short expected = 1;\\\n+    short desired = 5;\\\n+    return __atomic_compare_exchange (mem + off, &expected, &desired, 0,\\\n+\t\t\t\t      __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\\\n+  }\\\n+  short makefuncname (_9) (void)\\\n+  {\\\n+    short* mem = (short*)__builtin_thread_pointer ();\\\n+    short expected = 1;\\\n+    short desired = 5;\\\n+    return __atomic_compare_exchange (mem + off, &expected, &desired, 0,\\\n+\t\t\t\t      __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\\\n+  }\\\n+  int makefuncname (_10) (int* mem)\\\n+  {\\\n+    int expected = 1;\\\n+    int desired = 5;\\\n+    return __atomic_compare_exchange (mem + off, &expected, &desired, 0,\\\n+\t\t\t\t      __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\\\n+  }\\\n+  int makefuncname (_11) (void)\\\n+  {\\\n+    int* mem = (int*)__builtin_thread_pointer ();\\\n+    int expected = 1;\\\n+    int desired = 5;\\\n+    return __atomic_compare_exchange (mem + off, &expected, &desired, 0,\\\n+\t\t\t\t      __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\\\n+  }\\\n+  char makefuncname (_12) (char* mem)\\\n+  {\\\n+    char newval = 5;\\\n+    char prevval;\\\n+    __atomic_exchange (mem + off, &newval, &prevval, __ATOMIC_ACQ_REL);\\\n+    return prevval;\\\n+  }\\\n+  char makefuncname (_13) (void)\\\n+  {\\\n+    char* mem = (char*)__builtin_thread_pointer ();\\\n+    char newval = 5;\\\n+    char prevval;\\\n+    __atomic_exchange (mem + off, &newval, &prevval, __ATOMIC_ACQ_REL);\\\n+    return prevval;\\\n+  }\\\n+  short makefuncname (_14) (short* mem)\\\n+  {\\\n+    short newval = 5;\\\n+    short prevval;\\\n+    __atomic_exchange (mem + off, &newval, &prevval, __ATOMIC_ACQ_REL);\\\n+    return prevval;\\\n+  }\\\n+  short makefuncname (_15) (void)\\\n+  {\\\n+    short* mem = (short*)__builtin_thread_pointer ();\\\n+    short newval = 5;\\\n+    short prevval;\\\n+    __atomic_exchange (mem + off, &newval, &prevval, __ATOMIC_ACQ_REL);\\\n+    return prevval;\\\n+  }\\\n+  int makefuncname (_16) (int* mem)\\\n+  {\\\n+    int newval = 5;\\\n+    int prevval;\\\n+    __atomic_exchange (mem + off, &newval, &prevval, __ATOMIC_ACQ_REL);\\\n+    return prevval;\\\n+  }\\\n+  int makefuncname (_17) (void)\\\n+  {\\\n+    int* mem = (int*)__builtin_thread_pointer ();\\\n+    int newval = 5;\\\n+    int prevval;\\\n+    __atomic_exchange (mem + off, &newval, &prevval, __ATOMIC_ACQ_REL);\\\n+    return prevval;\\\n+  }\\\n+\n+emitfuncs (0)\n+emitfuncs (4)"}, {"sha": "dab0c5037d23d195617cec3725af5b49e3d12d84", "filename": "gcc/testsuite/gcc.target/sh/pr64661-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-1.c?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -0,0 +1,6 @@\n+/* Check that addressing modes for atomics are generated as expected.  */\n+/* { dg-do compile { target { atomic_model_soft_gusa_available } } }  */\n+/* { dg-options \"-O2 -matomic-model=soft-gusa,strict\" }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(16,r\\[0-9\\]\\\\)\" 72 } }  */\n+\n+#include \"pr64661-0.h\""}, {"sha": "75aa8a29d6b16ce516e31dce87fa4ca7a5943d07", "filename": "gcc/testsuite/gcc.target/sh/pr64661-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-2.c?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -0,0 +1,11 @@\n+/* Check that addressing modes for atomics are generated as expected.  */\n+/* { dg-do compile { target { atomic_model_soft_tcb_available } } }  */\n+/* { dg-options \"-O2 -matomic-model=soft-tcb,gbr-offset=128,strict\" }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(16,r\\[0-9\\]\\\\)\" 44 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(8,r\\[0-9\\]\\\\)\" 36 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(4,r\\[0-9\\]\\\\)\" 36 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(16,gbr\\\\)\" 28 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(8,gbr\\\\)\" 28 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(4,gbr\\\\)\" 28 } }  */\n+\n+#include \"pr64661-0.h\""}, {"sha": "058a6834e5f816a0e5e9b396ae7d3d5fc2cb2c42", "filename": "gcc/testsuite/gcc.target/sh/pr64661-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-3.c?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -0,0 +1,11 @@\n+/* Check that addressing modes for atomics are generated as expected.  */\n+/* { dg-do compile { target { atomic_model_soft_imask_available } } }  */\n+/* { dg-options \"-O2 -matomic-model=soft-imask,strict -mno-usermode\" }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(16,r\\[0-9\\]\\\\)\" 44 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(8,r\\[0-9\\]\\\\)\" 36 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(4,r\\[0-9\\]\\\\)\" 36 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(16,gbr\\\\)\" 28 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(8,gbr\\\\)\" 28 } }  */\n+/* { dg-final { scan-assembler-times \"@\\\\(4,gbr\\\\)\" 28 } }  */\n+\n+#include \"pr64661-0.h\""}, {"sha": "9f0e036d0f75f34a591ec0528c4d2063f35892f0", "filename": "gcc/testsuite/gcc.target/sh/pr64661-4.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fdc0399820af12180f26f1241ec185e73aa3180/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64661-4.c?ref=2fdc0399820af12180f26f1241ec185e73aa3180", "patch": "@@ -0,0 +1,8 @@\n+/* Check that addressing modes for atomics are generated as expected.\n+   The LLCS patterns are limited to simple register addresses, so there's not\n+   much to check here.  */\n+/* { dg-do compile { target { atomic_model_hard_llcs_available } } }  */\n+/* { dg-options \"-dp -O2 -matomic-model=hard-llcs,strict\" }  */\n+/* { dg-final { scan-assembler-times \"hard_1\" 112 } }  */\n+\n+#include \"pr64661-0.h\""}]}