{"sha": "bad177e848787258070415dbe002b2c6fba1c511", "node_id": "C_kwDOANBUbNoAKGJhZDE3N2U4NDg3ODcyNTgwNzA0MTVkYmUwMDJiMmM2ZmJhMWM1MTE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-09T08:51:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-09T08:51:37Z"}, "message": "range-op-float: Fix up reverse binary operations [PR109008]\n\nThe following testcase is reduced from miscompilation of scipy package.\nIf we have say lhs = [1., 1.] - [1., 1.] and want to compute the range\nof lhs from it, we correctly determine it is [0., 0.] (if computations\nare exact, we generally don't try to round them further in\nfrange_arithmetic).  In the testcase it is about a reverse operation,\n[1., 1.] = op1 + [1., 1.] and we want to compute range of op1 from that.\nRight now we just perform the inverse operation (there are some corner\ncases about NaN and infinities handling) and so arrive to range\n[0., 0.] as well, and because it is a singleton, optimize return eps;\nto return 0.  That is incorrect though, for the reverse ops we need to\ntake into account also rounding, the right exact range is\n[-0x1.0p-54, 0x1.0p-53] in this case when rounding to nearest, i.e.\nall numbers which added to 1. with round to nearest still produce 1.\n\nThe problem isn't solely on singleton ranges, and isn't solely on\nresults around zero.  We basically need to consider also values\nwhere the result is up to 0.5ulp away from the lhs range boundaries\nin each direction.\n\nThe following patch fixes it by extending the lhs range for the\nreverse operations by 1ulp in each direction.  The PR contains\na pseudo-random test generator I've used to generate 300000 tests\nof + and - and then used the same test with * and / instead of + and -\ntogether with a hack to print the discovered ranges by the patch in\na form that another test could then verify the range is conservatively\ncorrect and how far it is from a minimal range.\n\nI believe the results are good enough for now, though plan to look\nincrementally into trying to do something better on the -XXX_MAX or\nXXX_MAX boundaries (where I think frange_nextafter will use -inf or +inf)\nand also try to increase the range just by 0.5ulp rather than 1ulp\nif !flag_rounding_math.  But dunno if either of those will be doable\nand will pass the testing, so I think it is worth committing this fix\nfirst.\n\n2023-03-09  Jakub Jelinek  <jakub@redhat.com>\n\t    Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/109008\n\t* range-op-float.cc (float_widen_lhs_range): New function.\n\t(foperator_plus::op1_range, foperator_minus::op1_range,\n\tfoperator_minus::op2_range, foperator_mult::op1_range,\n\tfoperator_div::op1_range, foperator_div::op2_range): Use it.\n\n\t* gcc.c-torture/execute/ieee/pr109008.c: New test.", "tree": {"sha": "61b2e6fb54cd1cc63bfea47e1ea0ea51cee5f943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61b2e6fb54cd1cc63bfea47e1ea0ea51cee5f943"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bad177e848787258070415dbe002b2c6fba1c511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad177e848787258070415dbe002b2c6fba1c511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad177e848787258070415dbe002b2c6fba1c511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad177e848787258070415dbe002b2c6fba1c511/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "288bc7b5d17511d1791899e4b2e3bf3489eb06dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/288bc7b5d17511d1791899e4b2e3bf3489eb06dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/288bc7b5d17511d1791899e4b2e3bf3489eb06dd"}], "stats": {"total": 99, "additions": 75, "deletions": 24}, "files": [{"sha": "63b7ad1a008d21bab6eedb0cbe3aa9716a4302ae", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad177e848787258070415dbe002b2c6fba1c511/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad177e848787258070415dbe002b2c6fba1c511/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=bad177e848787258070415dbe002b2c6fba1c511", "patch": "@@ -2199,6 +2199,33 @@ zero_to_inf_range (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, int signbit_known)\n     }\n }\n \n+/* Extend the LHS range by 1ulp in each direction.  For op1_range\n+   or op2_range of binary operations just computing the inverse\n+   operation on ranges isn't sufficient.  Consider e.g.\n+   [1., 1.] = op1 + [1., 1.].  op1's range is not [0., 0.], but\n+   [-0x1.0p-54, 0x1.0p-53] (when not -frounding-math), any value for\n+   which adding 1. to it results in 1. after rounding to nearest.\n+   So, for op1_range/op2_range extend the lhs range by 1ulp in each\n+   direction.  See PR109008 for more details.  */\n+\n+static frange\n+float_widen_lhs_range (tree type, const frange &lhs)\n+{\n+  frange ret = lhs;\n+  if (lhs.known_isnan ())\n+    return ret;\n+  REAL_VALUE_TYPE lb = lhs.lower_bound ();\n+  REAL_VALUE_TYPE ub = lhs.upper_bound ();\n+  if (real_isfinite (&lb))\n+    frange_nextafter (TYPE_MODE (type), lb, dconstninf);\n+  if (real_isfinite (&ub))\n+    frange_nextafter (TYPE_MODE (type), ub, dconstinf);\n+  ret.set (type, lb, ub);\n+  ret.clear_nan ();\n+  ret.union_ (lhs);\n+  return ret;\n+}\n+\n class foperator_plus : public range_operator_float\n {\n   using range_operator_float::op1_range;\n@@ -2214,8 +2241,9 @@ class foperator_plus : public range_operator_float\n     range_op_handler minus (MINUS_EXPR, type);\n     if (!minus)\n       return false;\n-    return float_binary_op_range_finish (minus.fold_range (r, type, lhs, op2),\n-\t\t\t\t\t r, type, lhs);\n+    frange wlhs = float_widen_lhs_range (type, lhs);\n+    return float_binary_op_range_finish (minus.fold_range (r, type, wlhs, op2),\n+\t\t\t\t\t r, type, wlhs);\n   }\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n@@ -2260,9 +2288,10 @@ class foperator_minus : public range_operator_float\n   {\n     if (lhs.undefined_p ())\n       return false;\n-    return float_binary_op_range_finish (fop_plus.fold_range (r, type, lhs,\n+    frange wlhs = float_widen_lhs_range (type, lhs);\n+    return float_binary_op_range_finish (fop_plus.fold_range (r, type, wlhs,\n \t\t\t\t\t\t\t      op2),\n-\t\t\t\t\t r, type, lhs);\n+\t\t\t\t\t r, type, wlhs);\n   }\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n@@ -2271,8 +2300,9 @@ class foperator_minus : public range_operator_float\n   {\n     if (lhs.undefined_p ())\n       return false;\n-    return float_binary_op_range_finish (fold_range (r, type, op1, lhs),\n-\t\t\t\t\t r, type, lhs);\n+    frange wlhs = float_widen_lhs_range (type, lhs);\n+    return float_binary_op_range_finish (fold_range (r, type, op1, wlhs),\n+\t\t\t\t\t r, type, wlhs);\n   }\n private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n@@ -2338,13 +2368,14 @@ class foperator_mult : public foperator_mult_div_base\n     range_op_handler rdiv (RDIV_EXPR, type);\n     if (!rdiv)\n       return false;\n-    bool ret = rdiv.fold_range (r, type, lhs, op2);\n+    frange wlhs = float_widen_lhs_range (type, lhs);\n+    bool ret = rdiv.fold_range (r, type, wlhs, op2);\n     if (ret == false)\n       return false;\n-    if (lhs.known_isnan () || op2.known_isnan () || op2.undefined_p ())\n-      return float_binary_op_range_finish (ret, r, type, lhs);\n-    const REAL_VALUE_TYPE &lhs_lb = lhs.lower_bound ();\n-    const REAL_VALUE_TYPE &lhs_ub = lhs.upper_bound ();\n+    if (wlhs.known_isnan () || op2.known_isnan () || op2.undefined_p ())\n+      return float_binary_op_range_finish (ret, r, type, wlhs);\n+    const REAL_VALUE_TYPE &lhs_lb = wlhs.lower_bound ();\n+    const REAL_VALUE_TYPE &lhs_ub = wlhs.upper_bound ();\n     const REAL_VALUE_TYPE &op2_lb = op2.lower_bound ();\n     const REAL_VALUE_TYPE &op2_ub = op2.upper_bound ();\n     if ((contains_zero_p (lhs_lb, lhs_ub) && contains_zero_p (op2_lb, op2_ub))\n@@ -2363,7 +2394,7 @@ class foperator_mult : public foperator_mult_div_base\n     // or if lhs must be zero and op2 doesn't include zero, it would be\n     // UNDEFINED, while rdiv.fold_range computes a zero or singleton INF\n     // range.  Those are supersets of UNDEFINED, so let's keep that way.\n-    return float_binary_op_range_finish (ret, r, type, lhs);\n+    return float_binary_op_range_finish (ret, r, type, wlhs);\n   }\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n@@ -2490,13 +2521,14 @@ class foperator_div : public foperator_mult_div_base\n   {\n     if (lhs.undefined_p ())\n       return false;\n-    bool ret = fop_mult.fold_range (r, type, lhs, op2);\n+    frange wlhs = float_widen_lhs_range (type, lhs);\n+    bool ret = fop_mult.fold_range (r, type, wlhs, op2);\n     if (!ret)\n       return ret;\n-    if (lhs.known_isnan () || op2.known_isnan () || op2.undefined_p ())\n-      return float_binary_op_range_finish (ret, r, type, lhs);\n-    const REAL_VALUE_TYPE &lhs_lb = lhs.lower_bound ();\n-    const REAL_VALUE_TYPE &lhs_ub = lhs.upper_bound ();\n+    if (wlhs.known_isnan () || op2.known_isnan () || op2.undefined_p ())\n+      return float_binary_op_range_finish (ret, r, type, wlhs);\n+    const REAL_VALUE_TYPE &lhs_lb = wlhs.lower_bound ();\n+    const REAL_VALUE_TYPE &lhs_ub = wlhs.upper_bound ();\n     const REAL_VALUE_TYPE &op2_lb = op2.lower_bound ();\n     const REAL_VALUE_TYPE &op2_ub = op2.upper_bound ();\n     if ((contains_zero_p (lhs_lb, lhs_ub)\n@@ -2512,7 +2544,7 @@ class foperator_div : public foperator_mult_div_base\n \tzero_to_inf_range (lb, ub, signbit_known);\n \tr.set (type, lb, ub);\n       }\n-    return float_binary_op_range_finish (ret, r, type, lhs);\n+    return float_binary_op_range_finish (ret, r, type, wlhs);\n   }\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n@@ -2521,13 +2553,14 @@ class foperator_div : public foperator_mult_div_base\n   {\n     if (lhs.undefined_p ())\n       return false;\n-    bool ret = fold_range (r, type, op1, lhs);\n+    frange wlhs = float_widen_lhs_range (type, lhs);\n+    bool ret = fold_range (r, type, op1, wlhs);\n     if (!ret)\n       return ret;\n-    if (lhs.known_isnan () || op1.known_isnan () || op1.undefined_p ())\n-      return float_binary_op_range_finish (ret, r, type, lhs, true);\n-    const REAL_VALUE_TYPE &lhs_lb = lhs.lower_bound ();\n-    const REAL_VALUE_TYPE &lhs_ub = lhs.upper_bound ();\n+    if (wlhs.known_isnan () || op1.known_isnan () || op1.undefined_p ())\n+      return float_binary_op_range_finish (ret, r, type, wlhs, true);\n+    const REAL_VALUE_TYPE &lhs_lb = wlhs.lower_bound ();\n+    const REAL_VALUE_TYPE &lhs_ub = wlhs.upper_bound ();\n     const REAL_VALUE_TYPE &op1_lb = op1.lower_bound ();\n     const REAL_VALUE_TYPE &op1_ub = op1.upper_bound ();\n     if ((contains_zero_p (lhs_lb, lhs_ub) && contains_zero_p (op1_lb, op1_ub))\n@@ -2542,7 +2575,7 @@ class foperator_div : public foperator_mult_div_base\n \tzero_to_inf_range (lb, ub, signbit_known);\n \tr.set (type, lb, ub);\n       }\n-    return float_binary_op_range_finish (ret, r, type, lhs, true);\n+    return float_binary_op_range_finish (ret, r, type, wlhs, true);\n   }\n private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,"}, {"sha": "610aed4cac01f71b7f2a74eaa6470c0ccb5c1498", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/pr109008.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad177e848787258070415dbe002b2c6fba1c511/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fpr109008.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad177e848787258070415dbe002b2c6fba1c511/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fpr109008.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fpr109008.c?ref=bad177e848787258070415dbe002b2c6fba1c511", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/109008 */\n+\n+__attribute__((noipa)) double\n+foo (double eps)\n+{\n+  double d = 1. + eps;\n+  if (d == 1.)\n+    return eps;\n+  return 0.0;\n+}\n+\n+int\n+main ()\n+{\n+  if (foo (__DBL_EPSILON__ / 8.0) == 0.0)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}