{"sha": "f80326884cf82c1804385664197afa44ad468d97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgwMzI2ODg0Y2Y4MmMxODA0Mzg1NjY0MTk3YWZhNDRhZDQ2OGQ5Nw==", "commit": {"author": {"name": "Michael Matz", "email": "matzmich@cs.tu-berlin.de", "date": "2000-11-14T09:58:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-14T09:58:40Z"}, "message": "Michael Matz  <matzmich@cs.tu-berlin.de>\n\n        * dominance.c: New file.\n        * Makefile.in (OBJS): Add dominance.o.\n\n        * flow.c (compute_flow_dominators): Remove.\n        (compute_immediate_dominators): Remove.\n        (compute_immediate_postdominators): Remove.\n        * basic-block.h: Remove their prototypes.\n        (calculate_dominance_info): Add prototype.\n\n        * dce.c (eliminate_dead_code): Change calls to above functions.\n        Don't compute dominators but only immediate dominators.\n        * flow.c (flow_loops_find): Change callers.\n        * gcse.c (compute_code_hoist_data): Likewise.\n        * haifa-sched.c (schedule_insns): Likewise.\n        * ifcvt.c (if_convert): Likewise.\n        * ssa.c (convert_to_ssa): Likewise, and only compute immediate\n        dominators.\n\nFrom-SVN: r37449", "tree": {"sha": "0ae1829906b698b59a80644fab4750674494c842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ae1829906b698b59a80644fab4750674494c842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f80326884cf82c1804385664197afa44ad468d97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80326884cf82c1804385664197afa44ad468d97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f80326884cf82c1804385664197afa44ad468d97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80326884cf82c1804385664197afa44ad468d97/comments", "author": null, "committer": null, "parents": [{"sha": "6f1225504f3c4124fd4ab85edd0db620b14264ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1225504f3c4124fd4ab85edd0db620b14264ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1225504f3c4124fd4ab85edd0db620b14264ac"}], "stats": {"total": 932, "additions": 663, "deletions": 269}, "files": [{"sha": "ace6a8929f598df90876e94b03602c60c304afc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -1,3 +1,23 @@\n+2000-11-14  Michael Matz  <matzmich@cs.tu-berlin.de>\n+\n+\t* dominance.c: New file.\n+\t* Makefile.in (OBJS): Add dominance.o.\n+\n+\t* flow.c (compute_flow_dominators): Remove.\n+\t(compute_immediate_dominators): Remove.\n+\t(compute_immediate_postdominators): Remove.\n+\t* basic-block.h: Remove their prototypes.\n+\t(calculate_dominance_info): Add prototype.\n+\n+\t* dce.c (eliminate_dead_code): Change calls to above functions.\n+\tDon't compute dominators but only immediate dominators.\n+\t* flow.c (flow_loops_find): Change callers.\n+\t* gcse.c (compute_code_hoist_data): Likewise.\n+\t* haifa-sched.c (schedule_insns): Likewise.\n+\t* ifcvt.c (if_convert): Likewise.\n+\t* ssa.c (convert_to_ssa): Likewise, and only compute immediate\n+\tdominators.\n+\n 2000-11-14  Richard Henderson  <rth@redhat.com>\n \n \t* stmt.c (warn_if_unused_value): Don't warn if the expression"}, {"sha": "ff820d85f53c0dc693f4616dcd88d85b2ce2347e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -735,7 +735,7 @@ OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o  \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o\t      \\\n  mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t      \\\n  lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o\t\t      \\\n- sibcall.o conflict.o timevar.o ifcvt.o dependence.o dce.o\n+ sibcall.o conflict.o timevar.o ifcvt.o dominance.o dependence.o dce.o\n \n BACKEND = toplev.o libbackend.a\n \n@@ -1403,6 +1403,8 @@ unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    insn-flags.h function.h except.h $(EXPR_H) ssa.h $(GGC_H)\n+dominance.o : dominance.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h \\\n+   $(BASIC_BLOCK_H)\n combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h function.h \\\n    insn-config.h insn-flags.h insn-codes.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h"}, {"sha": "f3ed1a990a3e2fa06d80e2c2cb38a8b4b3efad54", "filename": "gcc/basic-block.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -458,10 +458,6 @@ void verify_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));\n int find_edge_index\t\t\tPARAMS ((struct edge_list *, \n \t\t\t\t\t\t basic_block, basic_block));\n \n-extern void compute_flow_dominators\tPARAMS ((sbitmap *, sbitmap *));\n-extern void compute_immediate_dominators\tPARAMS ((int *, sbitmap *));\n-extern void compute_immediate_postdominators\tPARAMS ((int *, sbitmap *));\n-\n \n enum update_life_extent\n {\n@@ -565,4 +561,15 @@ extern conflict_graph conflict_graph_compute\n                                         PARAMS ((regset,\n \t\t\t\t\t\t partition));\n \n+/* In dominance.c */\n+\n+enum cdi_direction\n+{\n+  CDI_DOMINATORS,\n+  CDI_POST_DOMINATORS\n+};\n+\n+extern void calculate_dominance_info\tPARAMS ((int *, sbitmap *,\n+\t\t\t\t\t\t enum cdi_direction));\n+\n #endif /* _BASIC_BLOCK_H */"}, {"sha": "3a83d7a7026b969e676122fb03384a6d36489832", "filename": "gcc/dce.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -485,7 +485,6 @@ eliminate_dead_code ()\n   /* Map element (b,e) is nonzero if the block is control dependent on\n      edge.  \"cdbte\" abbreviates control dependent block to edge.  */\n   control_dependent_block_to_edge_map cdbte;\n-  sbitmap *postdominators;\n  /* Element I is the immediate postdominator of block I.  */\n   int *pdom;\n   struct edge_list *el;\n@@ -504,17 +503,14 @@ eliminate_dead_code ()\n   compute_bb_for_insn (max_insn_uid);\n \n   /* Compute control dependence.  */\n-  postdominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  compute_flow_dominators (NULL, postdominators);\n   pdom = (int *) xmalloc (n_basic_blocks * sizeof (int));\n   for (i = 0; i < n_basic_blocks; ++i)\n     pdom[i] = INVALID_BLOCK;\n-  compute_immediate_postdominators (pdom, postdominators);\n+  calculate_dominance_info (pdom, NULL, CDI_POST_DOMINATORS);\n   /* Assume there is a path from each node to the exit block.  */\n   for (i = 0; i < n_basic_blocks; ++i)\n     if (pdom[i] == INVALID_BLOCK)\n       pdom[i] = EXIT_BLOCK;\n-  sbitmap_vector_free (postdominators);\n   el = create_edge_list();\n   find_all_control_dependences (el, pdom, cdbte);\n "}, {"sha": "66ff11e2bae00ad3482fed915224c84c16afd1e9", "filename": "gcc/dominance.c", "status": "added", "additions": 622, "deletions": 0, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -0,0 +1,622 @@\n+/* Calculate (post)dominators in slightly super-linear time.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Michael Matz (matz@ifh.de).\n+  \n+   This file is part of GNU CC.\n+ \n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* This file implements the well known algorithm from Lengauer and Tarjan\n+   to compute the dominators in a control flow graph.  A basic block D is said\n+   to dominate another block X, when all paths from the entry node of the CFG\n+   to X go also over D.  The dominance relation is a transitive reflexive\n+   relation and its minimal transitive reduction is a tree, called the\n+   dominator tree.  So for each block X besides the entry block exists a\n+   block I(X), called the immediate dominator of X, which is the parent of X\n+   in the dominator tree.\n+\n+   The algorithm computes this dominator tree implicitely by computing for\n+   each block its immediate dominator.  We use tree balancing and path\n+   compression, so its the O(e*a(e,v)) variant, where a(e,v) is the very\n+   slowly growing functional inverse of the Ackerman function.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+\n+\n+/* We name our nodes with integers, beginning with 1.  Zero is reserved for\n+   'undefined' or 'end of list'.  The name of each node is given by the dfs\n+   number of the corresponding basic block.  Please note, that we include the\n+   artificial ENTRY_BLOCK (or EXIT_BLOCK in the post-dom case) in our lists to\n+   support multiple entry points.  As it has no real basic block index we use\n+   'n_basic_blocks' for that.  Its dfs number is of course 1.  */\n+\n+/* Type of Basic Block aka. TBB */\n+typedef unsigned int TBB;\n+\n+/* We work in a poor-mans object oriented fashion, and carry an instance of\n+   this structure through all our 'methods'.  It holds various arrays\n+   reflecting the (sub)structure of the flowgraph.  Most of them are of type\n+   TBB and are also indexed by TBB.  */\n+\n+struct dom_info\n+{\n+  /* The parent of a node in the DFS tree.  */\n+  TBB *dfs_parent;\n+  /* For a node x key[x] is roughly the node nearest to the root from which\n+     exists a way to x only over nodes behind x.  Such a node is also called\n+     semidominator.  */\n+  TBB *key;\n+  /* The value in path_min[x] is the node y on the path from x to the root of\n+     the tree x is in with the smallest key[y].  */\n+  TBB *path_min;\n+  /* bucket[x] points to the first node of the set of nodes having x as key.  */\n+  TBB *bucket;\n+  /* And next_bucket[x] points to the next node.  */\n+  TBB *next_bucket;\n+  /* After the algorithm is done, dom[x] contains the immediate dominator\n+     of x.  */\n+  TBB *dom;\n+\n+  /* The following few fields implement the structures needed for disjoint\n+     sets.  */\n+  /* set_chain[x] is the next node on the path from x to the representant\n+     of the set containing x.  If set_chain[x]==0 then x is a root.  */\n+  TBB *set_chain;\n+  /* set_size[x] is the number of elements in the set named by x.  */\n+  unsigned int *set_size;\n+  /* set_child[x] is used for balancing the tree representing a set.  It can\n+     be understood as the next sibling of x.  */\n+  TBB *set_child;\n+\n+  /* If b is the number of a basic block (BB->index), dfs_order[b] is the\n+     number of that node in DFS order counted from 1.  This is an index\n+     into most of the other arrays in this structure.  */\n+  TBB *dfs_order;\n+  /* If x is the DFS-index of a node which correspondends with an basic block,\n+     dfs_to_bb[x] is that basic block.  Note, that in our structure there are\n+     more nodes that basic blocks, so only dfs_to_bb[dfs_order[bb->index]]==bb\n+     is true for every basic block bb, but not the opposite.  */\n+  basic_block *dfs_to_bb;\n+\n+  /* This is the next free DFS number when creating the DFS tree or forest. */\n+  unsigned int dfsnum;\n+  /* The number of nodes in the DFS tree (==dfsnum-1).  */\n+  unsigned int nodes;\n+};\n+\n+static void init_dom_info\t\tPARAMS ((struct dom_info *));\n+static void free_dom_info\t\tPARAMS ((struct dom_info *));\n+static void calc_dfs_tree_nonrec\tPARAMS ((struct dom_info *,\n+\t\t\t\t\t\t basic_block,\n+\t\t\t\t\t\t enum cdi_direction));\n+static void calc_dfs_tree\t\tPARAMS ((struct dom_info *,\n+\t\t\t\t\t\t enum cdi_direction));\n+static void compress\t\t\tPARAMS ((struct dom_info *, TBB));\n+static TBB eval\t\t\t\tPARAMS ((struct dom_info *, TBB));\n+static void link_roots\t\t\tPARAMS ((struct dom_info *, TBB, TBB));\n+static void calc_idoms\t\t\tPARAMS ((struct dom_info *,\n+\t\t\t\t\t\t enum cdi_direction));\n+static void idoms_to_doms\t\tPARAMS ((struct dom_info *,\n+\t\t\t\t\t\t sbitmap *));\n+\n+/* Helper macro for allocating and initializing an array,\n+   for aesthetic reasons.  */\n+#define init_ar(var, type, num, content)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    unsigned int i = 1;    /* Catch content == i.  */\t\t\\\n+    if (! (content))\t\t\t\t\t\t\\\n+      (var) = (type *) xcalloc ((num), sizeof (type));\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        (var) = (type *) xmalloc ((num) * sizeof (type));\t\\\n+\tfor (i = 0; i < num; i++)\t\t\t\t\\\n+\t  (var)[i] = (content);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Allocate all needed memory in a pessimistic fashion (so we round up).\n+   This initialises the contents of DI, which already must be allocated.  */\n+\n+static void\n+init_dom_info (di)\n+     struct dom_info *di;\n+{\n+  /* We need memory for n_basic_blocks nodes and the ENTRY_BLOCK or\n+     EXIT_BLOCK.  */\n+  unsigned int num = n_basic_blocks + 1 + 1;\n+  init_ar (di->dfs_parent, TBB, num, 0);\n+  init_ar (di->path_min, TBB, num, i);\n+  init_ar (di->key, TBB, num, i);\n+  init_ar (di->dom, TBB, num, 0);\n+\n+  init_ar (di->bucket, TBB, num, 0);\n+  init_ar (di->next_bucket, TBB, num, 0);\n+\n+  init_ar (di->set_chain, TBB, num, 0);\n+  init_ar (di->set_size, unsigned int, num, 1);\n+  init_ar (di->set_child, TBB, num, 0);\n+\n+  init_ar (di->dfs_order, TBB, (unsigned int) n_basic_blocks + 1, 0);\n+  init_ar (di->dfs_to_bb, basic_block, num, 0);\n+\n+  di->dfsnum = 1;\n+  di->nodes = 0;\n+}\n+\n+#undef init_ar\n+\n+/* Free all allocated memory in DI, but not DI itself.  */\n+\n+static void\n+free_dom_info (di)\n+     struct dom_info *di;\n+{\n+  free (di->dfs_parent);\n+  free (di->path_min);\n+  free (di->key);\n+  free (di->dom);\n+  free (di->bucket);\n+  free (di->next_bucket);\n+  free (di->set_chain);\n+  free (di->set_size);\n+  free (di->set_child);\n+  free (di->dfs_order);\n+  free (di->dfs_to_bb);\n+}\n+\n+/* The nonrecursive variant of creating a DFS tree.  DI is our working\n+   structure, BB the starting basic block for this tree and REVERSE\n+   is true, if predecessors should be visited instead of successors of a\n+   node.  After this is done all nodes reachable from BB were visited, have\n+   assigned their dfs number and are linked together to form a tree.  */\n+\n+static void\n+calc_dfs_tree_nonrec (di, bb, reverse)\n+     struct dom_info *di;\n+     basic_block bb;\n+     enum cdi_direction reverse;\n+{\n+  /* We never call this with bb==EXIT_BLOCK_PTR (ENTRY_BLOCK_PTR if REVERSE). */\n+  /* We call this _only_ if bb is not already visited.  */\n+  edge e;\n+  TBB child_i, my_i = 0;\n+  edge *stack;\n+  int sp;\n+  /* Start block (ENTRY_BLOCK_PTR for forward problem, EXIT_BLOCK for backward\n+     problem).  */\n+  basic_block en_block;\n+  /* Ending block.  */\n+  basic_block ex_block;\n+\n+  stack = (edge *) xmalloc ((n_basic_blocks + 3) * sizeof (edge));\n+  sp = 0;\n+\n+  /* Initialize our border blocks, and the first edge.  */\n+  if (reverse)\n+    {\n+      e = bb->pred;\n+      en_block = EXIT_BLOCK_PTR;\n+      ex_block = ENTRY_BLOCK_PTR;\n+    }\n+  else\n+    {\n+      e = bb->succ;\n+      en_block = ENTRY_BLOCK_PTR;\n+      ex_block = EXIT_BLOCK_PTR;\n+    }\n+\n+  /* When the stack is empty we break out of this loop.  */\n+  while (1)\n+    {\n+      basic_block bn;\n+\n+      /* This loop traverses edges e in depth first manner, and fills the\n+         stack.  */\n+      while (e)\n+\t{\n+\t  edge e_next;\n+\n+\t  /* Deduce from E the current and the next block (BB and BN), and the\n+\t     next edge.  */\n+\t  if (reverse)\n+\t    {\n+\t      bn = e->src;\n+\n+\t      /* If the next node BN is either already visited or a border\n+\t         block the current edge is useless, and simply overwritten\n+\t         with the next edge out of the current node.  */\n+\t      if (di->dfs_order[bn->index] || bn == ex_block)\n+\t\t{\n+\t\t  e = e->pred_next;\n+\t\t  continue;\n+\t\t}\n+\t      bb = e->dest;\n+\t      e_next = bn->pred;\n+\t    }\n+\t  else\n+\t    {\n+\t      bn = e->dest;\n+\t      if (di->dfs_order[bn->index] || bn == ex_block)\n+\t\t{\n+\t\t  e = e->succ_next;\n+\t\t  continue;\n+\t\t}\n+\t      bb = e->src;\n+\t      e_next = bn->succ;\n+\t    }\n+\n+\t  if (bn == en_block)\n+\t    abort ();\n+\n+\t  /* Fill the DFS tree info calculatable _before_ recursing.  */\n+\t  if (bb != en_block)\n+\t    my_i = di->dfs_order[bb->index];\n+\t  else\n+\t    my_i = di->dfs_order[n_basic_blocks];\n+\t  child_i = di->dfs_order[bn->index] = di->dfsnum++;\n+\t  di->dfs_to_bb[child_i] = bn;\n+\t  di->dfs_parent[child_i] = my_i;\n+\n+\t  /* Save the current point in the CFG on the stack, and recurse.  */\n+\t  stack[sp++] = e;\n+\t  e = e_next;\n+\t}\n+\n+      if (!sp)\n+\tbreak;\n+      e = stack[--sp];\n+\n+      /* OK.  The edge-list was exhausted, meaning normally we would\n+         end the recursion.  After returning from the recursive call,\n+         there were (may be) other statements which were run after a\n+         child node was completely considered by DFS.  Here is the\n+         point to do it in the non-recursive variant.\n+         E.g. The block just completed is in e->dest for forward DFS,\n+         the block not yet completed (the parent of the one above)\n+         in e->src.  This could be used e.g. for computing the number of\n+         descendants or the tree depth.  */\n+      if (reverse)\n+\te = e->pred_next;\n+      else\n+\te = e->succ_next;\n+    }\n+  free (stack);\n+}\n+\n+/* The main entry for calculating the DFS tree or forest.  DI is our working\n+   structure and REVERSE is true, if we are interested in the reverse flow\n+   graph.  In that case the result is not necessarily a tree but a forest,\n+   because there may be nodes from which the EXIT_BLOCK is unreachable.  */\n+\n+static void\n+calc_dfs_tree (di, reverse)\n+     struct dom_info *di;\n+     enum cdi_direction reverse;\n+{\n+  /* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */\n+  basic_block begin = reverse ? EXIT_BLOCK_PTR : ENTRY_BLOCK_PTR;\n+  di->dfs_order[n_basic_blocks] = di->dfsnum;\n+  di->dfs_to_bb[di->dfsnum] = begin;\n+  di->dfsnum++;\n+\n+  calc_dfs_tree_nonrec (di, begin, reverse);\n+\n+  if (reverse)\n+    {\n+      /* In the post-dom case we may have nodes without a path to EXIT_BLOCK.\n+         They are reverse-unreachable.  In the dom-case we disallow such\n+         nodes, but in post-dom we have to deal with them, so we simply\n+         include them in the DFS tree which actually becomes a forest.  */\n+      int i;\n+      for (i = n_basic_blocks - 1; i >= 0; i--)\n+\t{\n+\t  basic_block b = BASIC_BLOCK (i);\n+\t  if (di->dfs_order[b->index])\n+\t    continue;\n+\t  di->dfs_order[b->index] = di->dfsnum;\n+\t  di->dfs_to_bb[di->dfsnum] = b;\n+\t  di->dfsnum++;\n+\t  calc_dfs_tree_nonrec (di, b, reverse);\n+\t}\n+    }\n+\n+  di->nodes = di->dfsnum - 1;\n+\n+  /* This aborts e.g. when there is _no_ path from ENTRY to EXIT at all.  */\n+  if (di->nodes != (unsigned int) n_basic_blocks + 1)\n+    abort ();\n+}\n+\n+/* Compress the path from V to the root of its set and update path_min at the\n+   same time.  After compress(di, V) set_chain[V] is the root of the set V is\n+   in and path_min[V] is the node with the smallest key[] value on the path\n+   from V to that root.  */\n+\n+static void\n+compress (di, v)\n+     struct dom_info *di;\n+     TBB v;\n+{\n+  /* Btw. It's not worth to unrecurse compress() as the depth is usually not\n+     greater than 5 even for huge graphs (I've not seen call depth > 4).\n+     Also performance wise compress() ranges _far_ behind eval().  */\n+  TBB parent = di->set_chain[v];\n+  if (di->set_chain[parent])\n+    {\n+      compress (di, parent);\n+      if (di->key[di->path_min[parent]] < di->key[di->path_min[v]])\n+\tdi->path_min[v] = di->path_min[parent];\n+      di->set_chain[v] = di->set_chain[parent];\n+    }\n+}\n+\n+/* Compress the path from V to the set root of V if needed (when the root has\n+   changed since the last call).  Returns the node with the smallest key[]\n+   value on the path from V to the root.  */\n+\n+static inline TBB\n+eval (di, v)\n+     struct dom_info *di;\n+     TBB v;\n+{\n+  /* The representant of the set V is in, also called root (as the set\n+     representation is a tree).  */\n+  TBB rep = di->set_chain[v];\n+\n+  /* V itself is the root.  */\n+  if (!rep)\n+    return di->path_min[v];\n+\n+  /* Compress only if necessary.  */\n+  if (di->set_chain[rep])\n+    {\n+      compress (di, v);\n+      rep = di->set_chain[v];\n+    }\n+\n+  if (di->key[di->path_min[rep]] >= di->key[di->path_min[v]])\n+    return di->path_min[v];\n+  else\n+    return di->path_min[rep];\n+}\n+\n+/* This essentially merges the two sets of V and W, giving a single set with\n+   the new root V.  The internal representation of these disjoint sets is a\n+   balanced tree.  Currently link(V,W) is only used with V being the parent\n+   of W.  */\n+\n+static void\n+link_roots (di, v, w)\n+     struct dom_info *di;\n+     TBB v, w;\n+{\n+  TBB s = w;\n+\n+  /* Rebalance the tree.  */\n+  while (di->key[di->path_min[w]] < di->key[di->path_min[di->set_child[s]]])\n+    {\n+      if (di->set_size[s] + di->set_size[di->set_child[di->set_child[s]]]\n+\t  >= 2 * di->set_size[di->set_child[s]])\n+\t{\n+\t  di->set_chain[di->set_child[s]] = s;\n+\t  di->set_child[s] = di->set_child[di->set_child[s]];\n+\t}\n+      else\n+\t{\n+\t  di->set_size[di->set_child[s]] = di->set_size[s];\n+\t  s = di->set_chain[s] = di->set_child[s];\n+\t}\n+    }\n+\n+  di->path_min[s] = di->path_min[w];\n+  di->set_size[v] += di->set_size[w];\n+  if (di->set_size[v] < 2 * di->set_size[w])\n+    {\n+      TBB tmp = s;\n+      s = di->set_child[v];\n+      di->set_child[v] = tmp;\n+    }\n+\n+  /* Merge all subtrees.  */\n+  while (s)\n+    {\n+      di->set_chain[s] = v;\n+      s = di->set_child[s];\n+    }\n+}\n+\n+/* This calculates the immediate dominators (or post-dominators if REVERSE is\n+   true).  DI is our working structure and should hold the DFS forest.\n+   On return the immediate dominator to node V is in di->dom[V].  */\n+\n+static void\n+calc_idoms (di, reverse)\n+     struct dom_info *di;\n+     enum cdi_direction reverse;\n+{\n+  TBB v, w, k, par;\n+  basic_block en_block;\n+  if (reverse)\n+    en_block = EXIT_BLOCK_PTR;\n+  else\n+    en_block = ENTRY_BLOCK_PTR;\n+\n+  /* Go backwards in DFS order, to first look at the leafs.  */\n+  v = di->nodes;\n+  while (v > 1)\n+    {\n+      basic_block bb = di->dfs_to_bb[v];\n+      edge e, e_next;\n+\n+      par = di->dfs_parent[v];\n+      k = v;\n+      if (reverse)\n+\te = bb->succ;\n+      else\n+\te = bb->pred;\n+\n+      /* Search all direct predecessors for the smallest node with a path\n+         to them.  That way we have the smallest node with also a path to\n+         us only over nodes behind us.  In effect we search for our\n+         semidominator.  */\n+      for (; e; e = e_next)\n+\t{\n+\t  TBB k1;\n+\t  basic_block b;\n+\n+\t  if (reverse)\n+\t    {\n+\t      b = e->dest;\n+\t      e_next = e->succ_next;\n+\t    }\n+\t  else\n+\t    {\n+\t      b = e->src;\n+\t      e_next = e->pred_next;\n+\t    }\n+\t  if (b == en_block)\n+\t    k1 = di->dfs_order[n_basic_blocks];\n+\t  else\n+\t    k1 = di->dfs_order[b->index];\n+\n+\t  /* Call eval() only if really needed.  If k1 is above V in DFS tree,\n+\t     then we know, that eval(k1) == k1 and key[k1] == k1.  */\n+\t  if (k1 > v)\n+\t    k1 = di->key[eval (di, k1)];\n+\t  if (k1 < k)\n+\t    k = k1;\n+\t}\n+\n+      di->key[v] = k;\n+      link_roots (di, par, v);\n+      di->next_bucket[v] = di->bucket[k];\n+      di->bucket[k] = v;\n+\n+      /* Transform semidominators into dominators.  */\n+      for (w = di->bucket[par]; w; w = di->next_bucket[w])\n+\t{\n+\t  k = eval (di, w);\n+\t  if (di->key[k] < di->key[w])\n+\t    di->dom[w] = k;\n+\t  else\n+\t    di->dom[w] = par;\n+\t}\n+      /* We don't need to cleanup next_bucket[].  */\n+      di->bucket[par] = 0;\n+      v--;\n+    }\n+\n+  /* Explicitely define the dominators.  */\n+  di->dom[1] = 0;\n+  for (v = 2; v <= di->nodes; v++)\n+    if (di->dom[v] != di->key[v])\n+      di->dom[v] = di->dom[di->dom[v]];\n+}\n+\n+/* Convert the information about immediate dominators (in DI) to sets of all\n+   dominators (in DOMINATORS).  */\n+\n+static void\n+idoms_to_doms (di, dominators)\n+     struct dom_info *di;\n+     sbitmap *dominators;\n+{\n+  TBB i, e_index;\n+  int bb, bb_idom;\n+  sbitmap_vector_zero (dominators, n_basic_blocks);\n+  /* We have to be careful, to not include the ENTRY_BLOCK or EXIT_BLOCK\n+     in the list of (post)-doms, so remember that in e_index.  */\n+  e_index = di->dfs_order[n_basic_blocks];\n+\n+  for (i = 1; i <= di->nodes; i++)\n+    {\n+      if (i == e_index)\n+\tcontinue;\n+      bb = di->dfs_to_bb[i]->index;\n+\n+      if (di->dom[i] && (di->dom[i] != e_index))\n+\t{\n+\t  bb_idom = di->dfs_to_bb[di->dom[i]]->index;\n+\t  sbitmap_copy (dominators[bb], dominators[bb_idom]);\n+\t}\n+      else\n+\t{\n+\t  /* It has no immediate dom or only ENTRY_BLOCK or EXIT_BLOCK.\n+\t     If it is a child of ENTRY_BLOCK that's OK, and it's only\n+\t     dominated by itself; if it's _not_ a child of ENTRY_BLOCK, it\n+\t     means, it is unreachable.  That case has been disallowed in the\n+\t     building of the DFS tree, so we are save here.  For the reverse\n+\t     flow graph it means, it has no children, so, to be compatible\n+\t     with the old code, we set the post_dominators to all one.  */\n+\t  if (!di->dom[i])\n+\t    {\n+\t      sbitmap_ones (dominators[bb]);\n+\t    }\n+\t}\n+      SET_BIT (dominators[bb], bb);\n+    }\n+}\n+\n+/* The main entry point into this module.  IDOM is an integer array with room\n+   for n_basic_blocks integers, DOMS is a preallocated sbitmap array having\n+   room for n_basic_blocks^2 bits, and POST is true if the caller wants to\n+   know post-dominators.\n+\n+   On return IDOM[i] will be the BB->index of the immediate (post) dominator\n+   of basic block i, and DOMS[i] will have set bit j if basic block j is a\n+   (post)dominator for block i.\n+\n+   Either IDOM or DOMS may be NULL (meaning the caller is not interested in\n+   immediate resp. all dominators).  */\n+\n+void\n+calculate_dominance_info (idom, doms, reverse)\n+     int *idom;\n+     sbitmap *doms;\n+     enum cdi_direction reverse;\n+{\n+  struct dom_info di;\n+\n+  if (!doms && !idom)\n+    return;\n+  init_dom_info (&di);\n+  calc_dfs_tree (&di, reverse);\n+  calc_idoms (&di, reverse);\n+\n+  if (idom)\n+    {\n+      int i;\n+      for (i = 0; i < n_basic_blocks; i++)\n+\t{\n+\t  basic_block b = BASIC_BLOCK (i);\n+\t  TBB d = di.dom[di.dfs_order[b->index]];\n+\n+\t  /* The old code didn't modify array elements of nodes having only\n+\t     itself as dominator (d==0) or only ENTRY_BLOCK (resp. EXIT_BLOCK)\n+\t     (d==1).  */\n+\t  if (d > 1)\n+\t    idom[i] = di.dfs_to_bb[d]->index;\n+\t}\n+    }\n+  if (doms)\n+    idoms_to_doms (&di, doms);\n+\n+  free_dom_info (&di);\n+}"}, {"sha": "23f3236e0aa38d157c15fe2ecd3eed9e32d8a594", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 245, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -6247,250 +6247,6 @@ print_rtl_with_bb (outf, rtx_first)\n     }\n }\n \n-/* Compute dominator relationships using new flow graph structures.  */\n-\n-void\n-compute_flow_dominators (dominators, post_dominators)\n-     sbitmap *dominators;\n-     sbitmap *post_dominators;\n-{\n-  int bb;\n-  sbitmap *temp_bitmap;\n-  edge e;\n-  basic_block *worklist, *workend, *qin, *qout;\n-  int qlen;\n-\n-  /* Allocate a worklist array/queue.  Entries are only added to the\n-     list if they were not already on the list.  So the size is\n-     bounded by the number of basic blocks.  */\n-  worklist = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n-  workend = &worklist[n_basic_blocks];\n-\n-  temp_bitmap = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  sbitmap_vector_zero (temp_bitmap, n_basic_blocks);\n-\n-  if (dominators)\n-    {\n-      /* The optimistic setting of dominators requires us to put every\n-\t block on the work list initially.  */\n-      qin = qout = worklist;\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t{\n-\t  *qin++ = BASIC_BLOCK (bb);\n-\t  BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n-\t}\n-      qlen = n_basic_blocks;\n-      qin = worklist;\n-\n-      /* We want a maximal solution, so initially assume everything dominates\n-\t everything else.  */\n-      sbitmap_vector_ones (dominators, n_basic_blocks);\n-\n-      /* Mark successors of the entry block so we can identify them below.  */\n-      for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-\te->dest->aux = ENTRY_BLOCK_PTR;\n-\n-      /* Iterate until the worklist is empty.  */\n-      while (qlen)\n-\t{\n-\t  /* Take the first entry off the worklist.  */\n-\t  basic_block b = *qout++;\n-\t  if (qout >= workend)\n-\t    qout = worklist;\n-\t  qlen--;\n-\n-\t  bb = b->index;\n-\n-\t  /* Compute the intersection of the dominators of all the\n-\t     predecessor blocks.\n-\n-\t     If one of the predecessor blocks is the ENTRY block, then the\n-\t     intersection of the dominators of the predecessor blocks is\n-\t     defined as the null set.  We can identify such blocks by the\n-\t     special value in the AUX field in the block structure.  */\n-\t  if (b->aux == ENTRY_BLOCK_PTR)\n-\t    {\n-\t      /* Do not clear the aux field for blocks which are\n-\t\t successors of the ENTRY block.  That way we never add\n-\t\t them to the worklist again.\n-\n-\t\t The intersect of dominators of the preds of this block is\n-\t\t defined as the null set.  */\n-\t      sbitmap_zero (temp_bitmap[bb]);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Clear the aux field of this block so it can be added to\n-\t\t the worklist again if necessary.  */\n-\t      b->aux = NULL;\n-\t      sbitmap_intersection_of_preds (temp_bitmap[bb], dominators, bb);\n-\t    }\n-\n-\t  /* Make sure each block always dominates itself.  */\n-\t  SET_BIT (temp_bitmap[bb], bb);\n-\n-\t  /* If the out state of this block changed, then we need to\n-\t     add the successors of this block to the worklist if they\n-\t     are not already on the worklist.  */\n-\t  if (sbitmap_a_and_b (dominators[bb], dominators[bb], temp_bitmap[bb]))\n-\t    {\n-\t      for (e = b->succ; e; e = e->succ_next)\n-\t\t{\n-\t\t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n-\t\t    {\n-\t\t      *qin++ = e->dest;\n-\t\t      if (qin >= workend)\n-\t\t\tqin = worklist;\n-\t\t      qlen++;\n-\n-\t\t      e->dest->aux = e;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (post_dominators)\n-    {\n-      /* The optimistic setting of dominators requires us to put every\n-\t block on the work list initially.  */\n-      qin = qout = worklist;\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t{\n-\t  *qin++ = BASIC_BLOCK (bb);\n-\t  BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n-\t}\n-      qlen = n_basic_blocks;\n-      qin = worklist;\n-\n-      /* We want a maximal solution, so initially assume everything post\n-\t dominates everything else.  */\n-      sbitmap_vector_ones (post_dominators, n_basic_blocks);\n-\n-      /* Mark predecessors of the exit block so we can identify them below.  */\n-      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n-\te->src->aux = EXIT_BLOCK_PTR;\n-\n-      /* Iterate until the worklist is empty.  */\n-      while (qlen)\n-\t{\n-\t  /* Take the first entry off the worklist.  */\n-\t  basic_block b = *qout++;\n-\t  if (qout >= workend)\n-\t    qout = worklist;\n-\t  qlen--;\n-\n-\t  bb = b->index;\n-\n-\t  /* Compute the intersection of the post dominators of all the\n-\t     successor blocks.\n-\n-\t     If one of the successor blocks is the EXIT block, then the\n-\t     intersection of the dominators of the successor blocks is\n-\t     defined as the null set.  We can identify such blocks by the\n-\t     special value in the AUX field in the block structure.  */\n-\t  if (b->aux == EXIT_BLOCK_PTR)\n-\t    {\n-\t      /* Do not clear the aux field for blocks which are\n-\t\t predecessors of the EXIT block.  That way we we never\n-\t\t add them to the worklist again.\n-\n-\t\t The intersect of dominators of the succs of this block is\n-\t\t defined as the null set.  */\n-\t      sbitmap_zero (temp_bitmap[bb]);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Clear the aux field of this block so it can be added to\n-\t\t the worklist again if necessary.  */\n-\t      b->aux = NULL;\n-\t      sbitmap_intersection_of_succs (temp_bitmap[bb],\n-\t\t\t\t\t     post_dominators, bb);\n-\t    }\n-\n-\t  /* Make sure each block always post dominates itself.  */\n-\t  SET_BIT (temp_bitmap[bb], bb);\n-\n-\t  /* If the out state of this block changed, then we need to\n-\t     add the successors of this block to the worklist if they\n-\t     are not already on the worklist.  */\n-\t  if (sbitmap_a_and_b (post_dominators[bb],\n-\t\t\t       post_dominators[bb],\n-\t\t\t       temp_bitmap[bb]))\n-\t    {\n-\t      for (e = b->pred; e; e = e->pred_next)\n-\t\t{\n-\t\t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n-\t\t    {\n-\t\t      *qin++ = e->src;\n-\t\t      if (qin >= workend)\n-\t\t\tqin = worklist;\n-\t\t      qlen++;\n-\n-\t\t      e->src->aux = e;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  free (worklist);\n-  free (temp_bitmap);\n-}\n-\n-/* Given DOMINATORS, compute the immediate dominators into IDOM.  If a\n-   block dominates only itself, its entry remains as INVALID_BLOCK.  */\n-\n-void\n-compute_immediate_dominators (idom, dominators)\n-     int *idom;\n-     sbitmap *dominators;\n-{\n-  sbitmap *tmp;\n-  int b;\n-\n-  tmp = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-\n-  /* Begin with tmp(n) = dom(n) - { n }.  */\n-  for (b = n_basic_blocks; --b >= 0;)\n-    {\n-      sbitmap_copy (tmp[b], dominators[b]);\n-      RESET_BIT (tmp[b], b);\n-    }\n-\n-  /* Subtract out all of our dominator's dominators.  */\n-  for (b = n_basic_blocks; --b >= 0;)\n-    {\n-      sbitmap tmp_b = tmp[b];\n-      int s;\n-\n-      for (s = n_basic_blocks; --s >= 0;)\n-\tif (TEST_BIT (tmp_b, s))\n-\t  sbitmap_difference (tmp_b, tmp_b, tmp[s]);\n-    }\n-\n-  /* Find the one bit set in the bitmap and put it in the output array.  */\n-  for (b = n_basic_blocks; --b >= 0;)\n-    {\n-      int t;\n-      EXECUTE_IF_SET_IN_SBITMAP (tmp[b], 0, t, { idom[b] = t; });\n-    }\n-\n-  sbitmap_vector_free (tmp);\n-}\n-\n-/* Given POSTDOMINATORS, compute the immediate postdominators into\n-   IDOM.  If a block is only dominated by itself, its entry remains as\n-   INVALID_BLOCK.  */\n-\n-void\n-compute_immediate_postdominators (idom, postdominators)\n-     int *idom;\n-     sbitmap *postdominators;\n-{\n-  compute_immediate_dominators (idom, postdominators);\n-}\n-\n /* Recompute register set/reference counts immediately prior to register\n    allocation.\n \n@@ -8151,7 +7907,7 @@ flow_loops_find (loops, flags)\n \n   /* Compute the dominators.  */\n   dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  compute_flow_dominators (dom, NULL);\n+  calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n \n   /* Count the number of loop edges (back edges).  This should be the\n      same as the number of natural loops.  */"}, {"sha": "ac87c937b1bfb048f8dc44f40d146b59c48cb846", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -5292,7 +5292,7 @@ compute_code_hoist_data ()\n   compute_local_properties (transp, comp, antloc, 0);\n   compute_transpout ();\n   compute_code_hoist_vbeinout ();\n-  compute_flow_dominators (dominators, NULL);\n+  calculate_dominance_info (NULL, dominators, CDI_DOMINATORS);\n   if (gcse_file)\n     fprintf (gcse_file, \"\\n\");\n }"}, {"sha": "01f08b5d8117c8263471c94f122c77ca7d4a3342", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -7001,10 +7001,8 @@ schedule_insns (dump_file)\n \t     so may even be beneficial.  */\n \t  edge_list = create_edge_list ();\n \n-\t  /* Compute the dominators and post dominators.  We don't\n-\t     currently use post dominators, but we should for\n-\t     speculative motion analysis.  */\n-\t  compute_flow_dominators (dom, NULL);\n+\t  /* Compute the dominators and post dominators.  */\n+\t  calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n \n \t  /* build_control_flow will return nonzero if it detects unreachable\n \t     blocks or any other irregularity with the cfg which prevents"}, {"sha": "6ad1d35ee824169143dd91734d380d7b6b370cac", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -2104,7 +2104,7 @@ if_convert (life_data_ok)\n   if (HAVE_conditional_execution || life_data_ok)\n     {\n       post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-      compute_flow_dominators (NULL, post_dominators);\n+      calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n     }\n \n   /* Record initial block numbers.  */"}, {"sha": "3dabc626a14007d5329dd41b1bea5984e0acf8e3", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80326884cf82c1804385664197afa44ad468d97/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=f80326884cf82c1804385664197afa44ad468d97", "patch": "@@ -1148,7 +1148,6 @@ convert_to_ssa ()\n   sbitmap *evals;\n \n   /* Dominator bitmaps.  */\n-  sbitmap *dominators;\n   sbitmap *dfs;\n   sbitmap *idfs;\n \n@@ -1164,15 +1163,9 @@ convert_to_ssa ()\n   /* Need global_live_at_{start,end} up to date.  */\n   life_analysis (get_insns (), NULL, PROP_KILL_DEAD_CODE | PROP_SCAN_DEAD_CODE);\n \n-  /* Compute dominators.  */\n-  dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  compute_flow_dominators (dominators, NULL);\n-\n   idom = (int *) alloca (n_basic_blocks * sizeof (int));\n   memset ((void *)idom, -1, (size_t)n_basic_blocks * sizeof (int));\n-  compute_immediate_dominators (idom, dominators);\n-\n-  sbitmap_vector_free (dominators);\n+  calculate_dominance_info (idom, NULL, CDI_DOMINATORS);\n \n   if (rtl_dump_file)\n     {"}]}