{"sha": "063ee226edb855777a839a78036711e3e0f114e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYzZWUyMjZlZGI4NTU3NzdhODM5YTc4MDM2NzExZTNlMGYxMTRlNw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-04-16T17:25:07Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-04-16T17:25:07Z"}, "message": "JIS0201.h: New file, generated from Unicode table.\n\nh\n\t* gnu/gcj/convert/JIS0201.h:  New file, generated from Unicode table.\n\t* gnu/gcj/convert/Input_JavaSrc.java: New BytesToUnicode class.\n\t* gnu/gcj/convert/Input_SJIS.java: New BytesToUnicode class.\n\t* gnu/gcj/convert/Output_EUCJIS.java:  New UnicodeToBytes class.\n\t* gnu/gcj/convert/Output_SJIS.java:  New UnicodeToBytes class.\n\t* gnu/gcj/convert/natInput_EUCJIS.cc:  New file.\n\t* gnu/gcj/convert/natInput_SJIS.cc:  New file.\n\t* gnu/gcj/convert/natOutput_EUCJIS.cc:  New file.\n\t* gnu/gcj/convert/natOutput_SJIS.cc:  New file.\n\t* gnu/gcj/convert/make-trie.c:  New file: functions to make a trie.\n\t* gnu/gcj/convert/gen-from-JIS.c:  Invoke make-trie for output.\n\t* gnu/gcj/convert/Unicode_to_JIS.cc:  New generated trie table.\n\nFrom-SVN: r26500", "tree": {"sha": "e1468e4657852943cd24e760bfff9013489db098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1468e4657852943cd24e760bfff9013489db098"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/063ee226edb855777a839a78036711e3e0f114e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/063ee226edb855777a839a78036711e3e0f114e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/063ee226edb855777a839a78036711e3e0f114e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/063ee226edb855777a839a78036711e3e0f114e7/comments", "author": null, "committer": null, "parents": [{"sha": "a858c97cd4fd482c7ec5a631cf9250d2c03ca2ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a858c97cd4fd482c7ec5a631cf9250d2c03ca2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a858c97cd4fd482c7ec5a631cf9250d2c03ca2ff"}], "stats": {"total": 176, "additions": 176, "deletions": 0}, "files": [{"sha": "49c85fbe83b60622a0bfb9728f79093a59cc4702", "filename": "libjava/gnu/gcj/convert/make-trie.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063ee226edb855777a839a78036711e3e0f114e7/libjava%2Fgnu%2Fgcj%2Fconvert%2Fmake-trie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063ee226edb855777a839a78036711e3e0f114e7/libjava%2Fgnu%2Fgcj%2Fconvert%2Fmake-trie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2Fmake-trie.c?ref=063ee226edb855777a839a78036711e3e0f114e7", "patch": "@@ -0,0 +1,176 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+typedef struct trie_node\n+{\n+  int key;\n+  int level;\n+  int position;\n+  union\n+  {\n+    int value;\n+    struct trie_node *node;\n+  } u[16];\n+} trie_node;\n+\n+trie_node *\n+make_node ()\n+{\n+  trie_node *node = (trie_node *) malloc (sizeof(trie_node));\n+  if (node == NULL)\n+    abort();\n+  return node;\n+}\n+\n+trie_node *\n+make_leaf_node ()\n+{\n+  trie_node *node = make_node ();\n+  int i = 16;\n+  while (--i >= 0)\n+    node->u[i].value = -1;\n+  return node;\n+}\n+\n+trie_node *\n+make_branch_node ()\n+{\n+  trie_node *node = make_node ();\n+  int i = 16;\n+  while (--i >= 0)\n+    node->u[i].node = NULL;\n+  return node;\n+}\n+\n+\n+trie_node *table = NULL;\n+\n+void\n+enter (int key, int value)\n+{\n+  trie_node **ptr = &table;\n+  int shift = 12;\n+  for (; shift > 0;  shift -= 4)\n+    {\n+      if (*ptr == NULL)\n+\t{\n+\t  *ptr = make_branch_node ();\n+\t  (*ptr)->key = key & (0xFFFF << (shift + 4));\n+\t  (*ptr)->level = shift / 4;\n+\t}\n+      ptr = &(*ptr)->u[(key >> shift) & 0xF].node;\n+    }\n+  if (*ptr == NULL)\n+    {\n+      *ptr = make_leaf_node ();\n+      (*ptr)->key = key & 0xFFF0;\n+      (*ptr)->level = 0;\n+    }\n+  if ((*ptr)->u[key & 0xF].value != -1\n+      && (*ptr)->u[key & 0xF].value != value)\n+    fprintf(stderr, \"duplicate value for key: %d, %d!\\n\", key, value);\n+  (*ptr)->u[key & 0xF].value = value;\n+}\n+\n+int assigned = 0;\n+\n+void\n+assign (trie_node *node, int level)\n+{\n+  int i;\n+  if (node == NULL)\n+    return;\n+  if (node->level != level)\n+    abort();\n+  node->position = assigned;\n+  assigned++;\n+  if (level == 0)\n+    return;\n+  for (i = 0;  i < 16;  i++)\n+    {\n+      assign (node->u[i].node, level-1);\n+    }\n+}\n+\n+int next_node_index_toprint = 0;\n+\n+void\n+print (trie_node *node, int index, int level, FILE *out)\n+{\n+  int i;\n+  if (node->key != index || node->level != level)\n+    abort();\n+  if (level == 0) /* leaf node */\n+    {\n+      for (i = 0;  i < 16;  i++)\n+\t{\n+\t  int node_index = index | (i << (level * 4));\n+\t  if (node_index < next_node_index_toprint)\n+\t    abort();\n+\t  if (node->u[i].value == -1)\n+\t    fprintf (out, \" /* key: 0x%x */ 0xffff,\\n\", node_index);\n+\t  else\n+\t    fprintf (out, \" /* key: 0x%x */ 0x%x,\\n\",\n+\t\t     node_index, node->u[i].value);\n+\t  next_node_index_toprint = node_index + 1;\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 0;  i < 16;  i++)\n+\t{\n+\t  int node_index = index | (i << (level * 4));\n+\t  fprintf (out, \" /* branch: 0x%0*x%.*s */ \",\n+\t\t  4 - level, node_index  >> ( 4 * level),\n+\t\t  level, \"XXXX\");\n+\t  if (node->u[i].node == NULL)\n+\t    fprintf (out, \"0,\\n\");\n+\t  else\n+\t    fprintf (out, \"%d,\\n\", 16 * node->u[i].node->position);\n+\t}\n+\n+      for (i = 0;  i < 16;  i++)\n+\t{\n+\t  int node_index = index | (i << (level * 4));\n+\t  if (node->u[i].node != NULL)\n+\t    print (node->u[i].node, node_index, level-1, out);\n+\t}\n+    }\n+}\n+\n+void\n+print_table (char *name, FILE *out)\n+{\n+  assign (table, 3);\n+\n+  fprintf(out, \"/* This file is automatically generated. */\\n\");\n+  fprintf(out, \"unsigned short %s[] = {\\n\", name);\n+  print (table, 0x0000, 3, out);\n+  fprintf(out, \"};\\n\");\n+}\n+\n+#if 0\n+int\n+main (int argc, char **argv)\n+{\n+  int count = 0;\n+  for (;;)\n+    {\n+      int key, value;\n+      int i = scanf (\" 0x%x 0x%x\", &key, &value);\n+      if (i < 2)\n+\tbreak;\n+      count++;\n+      enter (key, value);\n+    }\n+  return 0;\n+}\n+#endif"}]}