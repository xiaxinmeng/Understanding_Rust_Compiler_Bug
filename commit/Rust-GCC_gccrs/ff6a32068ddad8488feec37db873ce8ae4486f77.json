{"sha": "ff6a32068ddad8488feec37db873ce8ae4486f77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2YTMyMDY4ZGRhZDg0ODhmZWVjMzdkYjg3M2NlOGFlNDQ4NmY3Nw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-07-27T00:20:03Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-07-27T00:20:03Z"}, "message": "tree-dfa.c (add_referenced_var): Register initializers of global variables.\n\n2004-07-26  Eric Christopher  <echristo@redhat.com>\n\n\t* tree-dfa.c (add_referenced_var): Register initializers of global\n\tvariables.\n\n2004-07-26  Eric Christopher  <echristo@redhat.com>\n\n\t* gcc.c-torture/compile/20040726-2.c: New test.\n\nFrom-SVN: r85214", "tree": {"sha": "9a02867216571663e8a78b4717752c799bbfd856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a02867216571663e8a78b4717752c799bbfd856"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6a32068ddad8488feec37db873ce8ae4486f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6a32068ddad8488feec37db873ce8ae4486f77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6a32068ddad8488feec37db873ce8ae4486f77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6a32068ddad8488feec37db873ce8ae4486f77/comments", "author": null, "committer": null, "parents": [{"sha": "764c35da02fb91d14cea74fcf2eda6851059b5d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764c35da02fb91d14cea74fcf2eda6851059b5d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/764c35da02fb91d14cea74fcf2eda6851059b5d7"}], "stats": {"total": 97, "additions": 68, "deletions": 29}, "files": [{"sha": "97043d71db5a09c69504ac46d7af9f87b7d6faa6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff6a32068ddad8488feec37db873ce8ae4486f77", "patch": "@@ -1,5 +1,10 @@\n-2004-07-22  Paolo Bonzini  <bonzini@gnu.org>\n-                                                                                \n+2004-07-26  Eric Christopher  <echristo@redhat.com>\n+\n+\t* tree-dfa.c (add_referenced_var): Register initializers of global\n+\tvariables.\n+\n+2004-07-26  Paolo Bonzini  <bonzini@gnu.org>\n+\n         * config/i386/i386.c (function_arg): Always treat 8-\n         and 16-byte wide vectors the same, even if MMX/SSE\n         are disabled.\n@@ -23,11 +28,11 @@\n \tunadjusted_alignment unsigned.\n \t(expand_call): Make preferred_stack_boundary and\n \tpreferred_unit_stack_boundary variables unsigned.\n-\t* function.c (assign_stack_local_1): Make alignment unsigned. \n-\t* function.h (struct function): Make stack_alignment_needed, \n+\t* function.c (assign_stack_local_1): Make alignment unsigned.\n+\t* function.h (struct function): Make stack_alignment_needed,\n \tpreferred_stack_boundary unsigned.\n \t* config/i386/i386.c (ix86_preferred_stack_boundary): Make unsigned.\n-\t(ix86_compute_frame_layout): Make stack_alignment_needed, \n+\t(ix86_compute_frame_layout): Make stack_alignment_needed,\n \tpreferred_alignment variables unsigned.\n \t* config/i386/i386.h (ix86_preferred_stack_boundary): Make unsigned.\n "}, {"sha": "3091bb17bb16e7f7cc099ff98abf6f6861b2e97d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff6a32068ddad8488feec37db873ce8ae4486f77", "patch": "@@ -1,3 +1,7 @@\n+2004-07-26  Eric Christopher  <echristo@redhat.com>\n+\n+\t* gcc.c-torture/compile/20040726-2.c: New test.\n+\n 2004-07-26  Andrew Pinski  <apinski@apple.com>\n \n \t* g++.dg/rtti/tinfo1.C: Xfail."}, {"sha": "ce60095fd8bb9fcee9b8a6e6641c66de26358c21", "filename": "gcc/testsuite/gcc.c-torture/compile/20040726-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040726-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040726-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040726-2.c?ref=ff6a32068ddad8488feec37db873ce8ae4486f77", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* From a failure after the global ccp pass.  */\n+typedef struct\n+{\n+  char n[129];\n+} A;\n+\n+const A C = {\n+  0,\n+  0\n+};\n+\n+extern const A *const B;\n+\n+void bar(const char *);\n+\n+void foo ()\n+{\n+  bar (B->n);\n+}\n+\n+const A *const B = &C;"}, {"sha": "9e9ee3248263f3874585a1df0d4714599b7fe7bc", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6a32068ddad8488feec37db873ce8ae4486f77/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=ff6a32068ddad8488feec37db873ce8ae4486f77", "patch": "@@ -139,8 +139,8 @@ struct tree_opt_pass pass_referenced_vars =\n };\n \n \n-/* Compute immediate uses.  \n-   \n+/* Compute immediate uses.\n+\n    CALC_FOR is an optional function pointer which indicates whether\n       immediate uses information should be calculated for a given SSA\n       variable.  If NULL, then information is computed for all\n@@ -253,7 +253,7 @@ compute_immediate_uses_for_phi (tree phi, bool (*calc_for)(tree))\n       tree arg = PHI_ARG_DEF (phi, i);\n \n       if (TREE_CODE (arg) == SSA_NAME && (!calc_for || calc_for (arg)))\n-\t{ \n+\t{\n \t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (PHI_ARG_DEF (phi, i));\n \t  if (!IS_EMPTY_STMT (imm_rdef_stmt))\n \t    add_immediate_use (imm_rdef_stmt, phi);\n@@ -351,7 +351,7 @@ add_immediate_use (tree stmt, tree use_stmt)\n \n \n /* If the immediate use of USE points to OLD, then redirect it to NEW.  */\n- \n+\n static void\n redirect_immediate_use (tree use, tree old, tree new)\n {\n@@ -388,7 +388,7 @@ redirect_immediate_uses (tree old, tree new)\n \n   /* Look at USE_OPS or VUSE_OPS according to FLAGS.  */\n   for (i = 0; i < NUM_USES (uses); i++)\n-    redirect_immediate_use (USE_OP (uses, i), old, new); \n+    redirect_immediate_use (USE_OP (uses, i), old, new);\n \n   for (i = 0; i < NUM_VUSES (vuses); i++)\n     redirect_immediate_use (VUSE_OP (vuses, i), old, new);\n@@ -505,7 +505,7 @@ dump_referenced_vars (FILE *file)\n {\n   size_t i;\n \n-  fprintf (file, \"\\nReferenced variables in %s: %u\\n\\n\", \n+  fprintf (file, \"\\nReferenced variables in %s: %u\\n\\n\",\n \t   get_name (current_function_decl), (unsigned) num_referenced_vars);\n \n   for (i = 0; i < num_referenced_vars; i++)\n@@ -533,7 +533,7 @@ void\n dump_variable (FILE *file, tree var)\n {\n   var_ann_t ann;\n-  \n+\n   if (TREE_CODE (var) == SSA_NAME)\n     {\n       if (POINTER_TYPE_P (TREE_TYPE (var)))\n@@ -691,7 +691,7 @@ dump_dfa_stats (FILE *file)\n \n   size = num_referenced_vars * sizeof (tree);\n   total += size;\n-  fprintf (file, fmt_str_1, \"Referenced variables\", num_referenced_vars, \n+  fprintf (file, fmt_str_1, \"Referenced variables\", num_referenced_vars,\n \t   SCALE (size), LABEL (size));\n \n   size = dfa_stats.num_stmt_anns * sizeof (struct stmt_ann_d);\n@@ -723,7 +723,7 @@ dump_dfa_stats (FILE *file)\n   total += size;\n   fprintf (file, fmt_str_1, \"V_MAY_DEF operands\", dfa_stats.num_v_may_defs,\n \t   SCALE (size), LABEL (size));\n-\t   \n+\n   size = dfa_stats.num_v_must_defs * sizeof (tree *);\n   total += size;\n   fprintf (file, fmt_str_1, \"V_MUST_DEF operands\", dfa_stats.num_v_must_defs,\n@@ -822,10 +822,10 @@ collect_dfa_stats_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t    dfa_stats_p->num_stmt_anns++;\n \t    dfa_stats_p->num_defs += NUM_DEFS (DEF_OPS (ann));\n \t    dfa_stats_p->num_uses += NUM_USES (USE_OPS (ann));\n-\t    dfa_stats_p->num_v_may_defs += \n+\t    dfa_stats_p->num_v_may_defs +=\n \t                 NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann));\n \t    dfa_stats_p->num_vuses += NUM_VUSES (VUSE_OPS (ann));\n-\t    dfa_stats_p->num_v_must_defs += \n+\t    dfa_stats_p->num_v_must_defs +=\n \t                 NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann));\n \t    break;\n \t  }\n@@ -903,6 +903,14 @@ add_referenced_var (tree var, struct walk_state *walk_state)\n       /* Global and static variables are call-clobbered, always.  */\n       if (needs_to_live_in_memory (var))\n \tmark_call_clobbered (var);\n+\n+      /* If an initialized global variable then register the initializer\n+\t as well.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (var))\n+\t  && TREE_READONLY (var)\n+\t  && DECL_INITIAL (var)\n+\t  && TREE_CODE (DECL_INITIAL (var)) == ADDR_EXPR)\n+      \twalk_tree (&DECL_INITIAL (var), find_vars_r, walk_state, 0);\n     }\n }\n \n@@ -920,7 +928,7 @@ get_virtual_var (tree var)\n   while (TREE_CODE (var) == REALPART_EXPR || TREE_CODE (var) == IMAGPART_EXPR\n \t || handled_component_p (var))\n     var = TREE_OPERAND (var, 0);\n-    \n+\n #ifdef ENABLE_CHECKING\n   /* Treating GIMPLE registers as virtual variables makes no sense.\n      Also complain if we couldn't extract a _DECL out of the original\n@@ -945,42 +953,42 @@ add_referenced_tmp_var (tree var)\n   add_referenced_var (var, NULL);\n }\n \n-/* Return true if V_MAY_DEFS_AFTER contains fewer entries than \n-   V_MAY_DEFS_BEFORE. Note that this assumes that both varrays \n+/* Return true if V_MAY_DEFS_AFTER contains fewer entries than\n+   V_MAY_DEFS_BEFORE. Note that this assumes that both varrays\n    are V_MAY_DEF operands for the same statement.  */\n \n static inline bool\n-v_may_defs_disappeared_p (v_may_def_optype v_may_defs_before, \n+v_may_defs_disappeared_p (v_may_def_optype v_may_defs_before,\n                           v_may_def_optype v_may_defs_after)\n {\n   /* If there was nothing before, nothing could've disappeared.  */\n   if (v_may_defs_before == NULL)\n     return false;\n-     \n+\n   /* All/some of them gone.  */\n   if (v_may_defs_after == NULL\n-      || NUM_V_MAY_DEFS (v_may_defs_before) > \n+      || NUM_V_MAY_DEFS (v_may_defs_before) >\n          NUM_V_MAY_DEFS (v_may_defs_after))\n     return true;\n \n   return false;\n }\n \n-/* Return true if V_MUST_DEFS_AFTER contains fewer entries than \n-   V_MUST_DEFS_BEFORE. Note that this assumes that both varrays \n+/* Return true if V_MUST_DEFS_AFTER contains fewer entries than\n+   V_MUST_DEFS_BEFORE. Note that this assumes that both varrays\n    are V_MUST_DEF operands for the same statement.  */\n \n static inline bool\n-v_must_defs_disappeared_p (v_must_def_optype v_must_defs_before, \n+v_must_defs_disappeared_p (v_must_def_optype v_must_defs_before,\n                            v_must_def_optype v_must_defs_after)\n {\n   /* If there was nothing before, nothing could've disappeared.  */\n   if (v_must_defs_before == NULL)\n     return false;\n-     \n+\n   /* All/some of them gone.  */\n   if (v_must_defs_after == NULL\n-      || NUM_V_MUST_DEFS (v_must_defs_before) > \n+      || NUM_V_MUST_DEFS (v_must_defs_before) >\n          NUM_V_MUST_DEFS (v_must_defs_after))\n     return true;\n \n@@ -1093,7 +1101,7 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n \t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t}\n     }\n-    \n+\n   v_must_defs_after = v_must_defs = V_MUST_DEF_OPS (ann);\n   for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n     {\n@@ -1103,7 +1111,7 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n \t  found_exposed_symbol = true;\n \t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t}\n-    }  \n+    }\n \n   /* If we found any newly exposed symbols, or if there are fewer VDEF\n      operands in the statement, add the variables we had set in"}]}