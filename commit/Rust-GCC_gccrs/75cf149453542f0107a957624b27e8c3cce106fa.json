{"sha": "75cf149453542f0107a957624b27e8c3cce106fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVjZjE0OTQ1MzU0MmYwMTA3YTk1NzYyNGIyN2U4YzNjY2UxMDZmYQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2014-10-10T12:28:45Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2014-10-10T12:28:45Z"}, "message": "[AArch64] Implement workaround for ARM Cortex-A53 erratum 835769\n\n\t* config/aarch64/aarch64.h (FINAL_PRESCAN_INSN): Define.\n\t(ADJUST_INSN_LENGTH): Define.\n\t* config/aarch64/aarch64.opt (mfix-cortex-a53-835769): New option.\n\t* config/aarch64/aarch64.c (is_mem_p): New function.\n\t(is_memory_op): Likewise.\n\t(aarch64_prev_real_insn): Likewise.\n\t(is_madd_op): Likewise.\n\t(dep_between_memop_and_curr): Likewise.\n\t(aarch64_madd_needs_nop): Likewise.\n\t(aarch64_final_prescan_insn): Likewise.\n\t* doc/invoke.texi (AArch64 Options): Document -mfix-cortex-a53-835769\n\tand -mno-fix-cortex-a53-835769 options.\n\nFrom-SVN: r216075", "tree": {"sha": "ffcfff25f5f96b8c613f337c9da709e167e9e127", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffcfff25f5f96b8c613f337c9da709e167e9e127"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75cf149453542f0107a957624b27e8c3cce106fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cf149453542f0107a957624b27e8c3cce106fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75cf149453542f0107a957624b27e8c3cce106fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cf149453542f0107a957624b27e8c3cce106fa/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9696ffb6e8e8fbb59b0cc925e218e92c2d71be0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9696ffb6e8e8fbb59b0cc925e218e92c2d71be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9696ffb6e8e8fbb59b0cc925e218e92c2d71be0"}], "stats": {"total": 162, "additions": 162, "deletions": 0}, "files": [{"sha": "87991acb90592f588d71162a2b7523169ee8df74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75cf149453542f0107a957624b27e8c3cce106fa", "patch": "@@ -1,3 +1,19 @@\n+2014-10-10  Kyrylo Tkachov<kyrylo.tkachov@arm.com>\n+            Ramana Radhakrishnan<ramana.radhakrishnan@arm.com>\n+\n+\t* config/aarch64/aarch64.h (FINAL_PRESCAN_INSN): Define.\n+\t(ADJUST_INSN_LENGTH): Define.\n+\t* config/aarch64/aarch64.opt (mfix-cortex-a53-835769): New option.\n+\t* config/aarch64/aarch64.c (is_mem_p): New function.\n+\t(is_memory_op): Likewise.\n+\t(aarch64_prev_real_insn): Likewise.\n+\t(is_madd_op): Likewise.\n+\t(dep_between_memop_and_curr): Likewise.\n+\t(aarch64_madd_needs_nop): Likewise.\n+\t(aarch64_final_prescan_insn): Likewise.\n+\t* doc/invoke.texi (AArch64 Options): Document -mfix-cortex-a53-835769\n+\tand -mno-fix-cortex-a53-835769 options.\n+\n 2014-10-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/63464"}, {"sha": "c57a467c32712cfa703261e1be3b8f77f06d4392", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=75cf149453542f0107a957624b27e8c3cce106fa", "patch": "@@ -308,6 +308,8 @@ aarch64_builtin_vectorized_function (tree fndecl,\n \n extern void aarch64_split_combinev16qi (rtx operands[3]);\n extern void aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n+extern bool aarch64_madd_needs_nop (rtx_insn *);\n+extern void aarch64_final_prescan_insn (rtx_insn *);\n extern bool\n aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n void aarch64_atomic_assign_expand_fenv (tree *, tree *, tree *);"}, {"sha": "76a2480582a53ef0b465c1da8d7a20f9a2f51402", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=75cf149453542f0107a957624b27e8c3cce106fa", "patch": "@@ -7586,6 +7586,128 @@ aarch64_mangle_type (const_tree type)\n   return NULL;\n }\n \n+static int\n+is_mem_p (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  return MEM_P (*x);\n+}\n+\n+static bool\n+is_memory_op (rtx_insn *mem_insn)\n+{\n+   rtx pattern = PATTERN (mem_insn);\n+   return for_each_rtx (&pattern, is_mem_p, NULL);\n+}\n+\n+/* Find the first rtx_insn before insn that will generate an assembly\n+   instruction.  */\n+\n+static rtx_insn *\n+aarch64_prev_real_insn (rtx_insn *insn)\n+{\n+  if (!insn)\n+    return NULL;\n+\n+  do\n+    {\n+      insn = prev_real_insn (insn);\n+    }\n+  while (insn && recog_memoized (insn) < 0);\n+\n+  return insn;\n+}\n+\n+static bool\n+is_madd_op (enum attr_type t1)\n+{\n+  unsigned int i;\n+  /* A number of these may be AArch32 only.  */\n+  enum attr_type mlatypes[] = {\n+    TYPE_MLA, TYPE_MLAS, TYPE_SMLAD, TYPE_SMLADX, TYPE_SMLAL, TYPE_SMLALD,\n+    TYPE_SMLALS, TYPE_SMLALXY, TYPE_SMLAWX, TYPE_SMLAWY, TYPE_SMLAXY,\n+    TYPE_SMMLA, TYPE_UMLAL, TYPE_UMLALS,TYPE_SMLSD, TYPE_SMLSDX, TYPE_SMLSLD\n+  };\n+\n+  for (i = 0; i < sizeof (mlatypes) / sizeof (enum attr_type); i++)\n+    {\n+      if (t1 == mlatypes[i])\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Check if there is a register dependency between a load and the insn\n+   for which we hold recog_data.  */\n+\n+static bool\n+dep_between_memop_and_curr (rtx memop)\n+{\n+  rtx load_reg;\n+  int opno;\n+\n+  if (!memop)\n+    return false;\n+\n+  if (!REG_P (SET_DEST (memop)))\n+    return false;\n+\n+  load_reg = SET_DEST (memop);\n+  for (opno = 0; opno < recog_data.n_operands; opno++)\n+    {\n+      rtx operand = recog_data.operand[opno];\n+      if (REG_P (operand)\n+          && reg_overlap_mentioned_p (load_reg, operand))\n+        return true;\n+\n+    }\n+  return false;\n+}\n+\n+bool\n+aarch64_madd_needs_nop (rtx_insn* insn)\n+{\n+  enum attr_type attr_type;\n+  rtx_insn *prev;\n+  rtx body;\n+\n+  if (!aarch64_fix_a53_err835769)\n+    return false;\n+\n+  if (recog_memoized (insn) < 0)\n+    return false;\n+\n+  attr_type = get_attr_type (insn);\n+  if (!is_madd_op (attr_type))\n+    return false;\n+\n+  prev = aarch64_prev_real_insn (insn);\n+  if (!prev)\n+    return false;\n+\n+  body = single_set (prev);\n+\n+  /* If the previous insn is a memory op and there is no dependency between\n+     it and the madd, emit a nop between them.  If we know the previous insn is\n+     a memory op but body is NULL, emit the nop to be safe, it's probably a\n+     load/store pair insn.  */\n+  if (is_memory_op (prev)\n+      && GET_MODE (recog_data.operand[0]) == DImode\n+      && (!dep_between_memop_and_curr (body)))\n+    return true;\n+\n+  return false;\n+\n+}\n+\n+void\n+aarch64_final_prescan_insn (rtx_insn *insn)\n+{\n+  if (aarch64_madd_needs_nop (insn))\n+    fprintf (asm_out_file, \"\\tnop // between mem op and mult-accumulate\\n\");\n+}\n+\n+\n /* Return the equivalent letter for size.  */\n static char\n sizetochar (int size)"}, {"sha": "e9e5fd838fc8ce9d11bbff5287091813ec733401", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=75cf149453542f0107a957624b27e8c3cce106fa", "patch": "@@ -486,6 +486,15 @@ enum target_cpus\n   (TARGET_CPU_generic | (AARCH64_CPU_DEFAULT_FLAGS << 6))\n #endif\n \n+/* If inserting NOP before a mult-accumulate insn remember to adjust the\n+   length so that conditional branching code is updated appropriately.  */\n+#define ADJUST_INSN_LENGTH(insn, length)\t\\\n+  if (aarch64_madd_needs_nop (insn))\t\t\\\n+    length += 4;\n+\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\\\n+    aarch64_final_prescan_insn (INSN);\t\t\t\\\n+\n /* The processor for which instructions should be scheduled.  */\n extern enum aarch64_processor aarch64_tune;\n "}, {"sha": "77deb2e7d364208024404e82bbda30cdc1b32ed1", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=75cf149453542f0107a957624b27e8c3cce106fa", "patch": "@@ -67,6 +67,10 @@ mgeneral-regs-only\n Target Report RejectNegative Mask(GENERAL_REGS_ONLY)\n Generate code which uses only the general registers\n \n+mfix-cortex-a53-835769\n+Target Report Var(aarch64_fix_a53_err835769) Init(0)\n+Workaround for ARM Cortex-A53 Erratum number 835769\n+\n mlittle-endian\n Target Report RejectNegative InverseMask(BIG_END)\n Assume target CPU is configured as little endian"}, {"sha": "f1ba77bdabe2c6719ecfa343a2f273c4fa1da494", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cf149453542f0107a957624b27e8c3cce106fa/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=75cf149453542f0107a957624b27e8c3cce106fa", "patch": "@@ -489,6 +489,7 @@ Objective-C and Objective-C++ Dialects}.\n -mstrict-align @gol\n -momit-leaf-frame-pointer  -mno-omit-leaf-frame-pointer @gol\n -mtls-dialect=desc  -mtls-dialect=traditional @gol\n+-mfix-cortex-a53-835769  -mno-fix-cortex-a53-835769 @gol\n -march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}}\n \n @emph{Adapteva Epiphany Options}\n@@ -11757,6 +11758,14 @@ of TLS variables.  This is the default.\n Use traditional TLS as the thread-local storage mechanism for dynamic accesses\n of TLS variables.\n \n+@item -mfix-cortex-a53-835769\n+@itemx -mno-fix-cortex-a53-835769\n+@opindex -mfix-cortex-a53-835769\n+@opindex -mno-fix-cortex-a53-835769\n+Enable or disable the workaround for the ARM Cortex-A53 erratum number 835769.\n+This will involve inserting a NOP instruction between memory instructions and\n+64-bit integer multiply-accumulate instructions.\n+\n @item -march=@var{name}\n @opindex march\n Specify the name of the target architecture, optionally suffixed by one or"}]}