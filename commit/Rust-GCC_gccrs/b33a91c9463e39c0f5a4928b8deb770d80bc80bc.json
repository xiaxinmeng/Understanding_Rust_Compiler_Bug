{"sha": "b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMzYTkxYzk0NjNlMzljMGY1YTQ5MjhiOGRlYjc3MGQ4MGJjODBiYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-04T14:27:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-04T14:27:50Z"}, "message": "df.h (df_rd_bb_info, [...]): Embedd bitmap_head into the structure.\n\n\n\t* df.h (df_rd_bb_info, df_md_bb_info, df_lr_bb_info, df_live_bb_info,\n\tdf_byte_lr_bb_info): Embedd bitmap_head into the structure.\n\t(DF_LIVE_IN, DF_LIVE_OUT, DF_LR_IN, DF_LR_OUT, DF_BYTE_LR_IN,\n\tDF_BYTE_LR_OUT): Update for embedded bitmaps.\n\t* fwprop.c (single_def_use_enter_block): Likewise.\n\t* ddg.c (create_ddg_dep_from_intra_loop_link,\n\tadd_cross_iteration_register_deps, build_inter_loop_deps): Likewise.\n\t* loop-iv.c (latch_dominating_def): Likewise.\n\t* df-problems.c (df_rd_free_bb_info, df_rd_alloc,\n\tdf_rd_bb_local_compute_process_def, df_rd_bb_local_compute_process_def,\n\tdf_rd_init_solution, df_rd_init_solution, df_rd_transfer_function,\n\tdf_rd_transfer_function, df_rd_top_dump,\n\tdf_rd_bottom_dump): Update.\n\t(df_lr_free_bb_info, df_lr_alloc, df_lr_reset, df_lr_bb_local_compute,\n\tdf_lr_bb_local_compute, df_lr_bb_local_compute, df_lr_bb_local_compute,\n\tdf_lr_bb_local_compute, df_lr_local_compute, df_lr_init, df_lr_init,\n\tdf_lr_confluence_0, df_lr_free, df_lr_top_dump, df_lr_bottom_dump,\n\tdf_lr_verify_solution_start, df_lr_verify_solution_end,\n\tdf_lr_verify_transfer_functions, df_lr_verify_transfer_functions,\n\tdf_live_free_bb_info, df_live_alloc, df_live_reset,\n\tdf_live_bb_local_compute, df_live_init, df_live_transfer_function,\n\tdf_live_finalize, df_live_free, df_live_top_dump, df_live_bottom_dump,\n\tdf_live_verify_solution_start, df_live_verify_solution_end,\n\tdf_live_verify_transfer_functions, df_chain_create_bb,\n\tdf_byte_lr_free_bb_info, df_byte_lr_alloc, df_byte_lr_reset,\n\tdf_byte_lr_bb_local_compute, df_byte_lr_bb_local_compute,\n\tdf_byte_lr_bb_local_compute, df_byte_lr_bb_local_compute,\n\tdf_byte_lr_bb_local_compute, df_byte_lr_local_compute, df_byte_lr_init,\n\tdf_byte_lr_confluence_0, df_byte_lr_confluence_n,\n\tdf_byte_lr_transfer_function, df_byte_lr_top_dump,\n\tdf_byte_lr_bottom_dump, df_create_unused_note,\n\tdf_note_bb_compute, df_md_free_bb_info, df_md_alloc,\n\tdf_md_bb_local_compute_process_def, df_md_local_compute, df_md_reset,\n\tdf_md_transfer_function, df_md_init, df_md_confluence_0,\n\tdf_md_confluence_n,\n\tdf_md_top_dump, df_md_bottom_dump): Update.  (struct df_lr_problem_data):\n\tEmbedd bitmap headers.\n\nFrom-SVN: r160268", "tree": {"sha": "bdb9afd977a6f5b50e25f2193ab85b83b8d7701e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdb9afd977a6f5b50e25f2193ab85b83b8d7701e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/comments", "author": null, "committer": null, "parents": [{"sha": "fb340c3c7f23b51e71c54a92b9f6d5c7e00d6044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb340c3c7f23b51e71c54a92b9f6d5c7e00d6044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb340c3c7f23b51e71c54a92b9f6d5c7e00d6044"}], "stats": {"total": 590, "additions": 315, "deletions": 275}, "files": [{"sha": "3a646165ef27d9ea36ee99a7a093d8e6e0bf7fd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "patch": "@@ -1,3 +1,43 @@\n+2010-06-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* df.h (df_rd_bb_info, df_md_bb_info, df_lr_bb_info, df_live_bb_info,\n+\tdf_byte_lr_bb_info): Embedd bitmap_head into the structure.\n+\t(DF_LIVE_IN, DF_LIVE_OUT, DF_LR_IN, DF_LR_OUT, DF_BYTE_LR_IN,\n+\tDF_BYTE_LR_OUT): Update for embedded bitmaps.\n+\t* fwprop.c (single_def_use_enter_block): Likewise.\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link,\n+\tadd_cross_iteration_register_deps, build_inter_loop_deps): Likewise.\n+\t* loop-iv.c (latch_dominating_def): Likewise.\n+\t* df-problems.c (df_rd_free_bb_info, df_rd_alloc,\n+\tdf_rd_bb_local_compute_process_def, df_rd_bb_local_compute_process_def,\n+\tdf_rd_init_solution, df_rd_init_solution, df_rd_transfer_function,\n+\tdf_rd_transfer_function, df_rd_top_dump,\n+\tdf_rd_bottom_dump): Update.\n+\t(df_lr_free_bb_info, df_lr_alloc, df_lr_reset, df_lr_bb_local_compute,\n+\tdf_lr_bb_local_compute, df_lr_bb_local_compute, df_lr_bb_local_compute,\n+\tdf_lr_bb_local_compute, df_lr_local_compute, df_lr_init, df_lr_init,\n+\tdf_lr_confluence_0, df_lr_free, df_lr_top_dump, df_lr_bottom_dump,\n+\tdf_lr_verify_solution_start, df_lr_verify_solution_end,\n+\tdf_lr_verify_transfer_functions, df_lr_verify_transfer_functions,\n+\tdf_live_free_bb_info, df_live_alloc, df_live_reset,\n+\tdf_live_bb_local_compute, df_live_init, df_live_transfer_function,\n+\tdf_live_finalize, df_live_free, df_live_top_dump, df_live_bottom_dump,\n+\tdf_live_verify_solution_start, df_live_verify_solution_end,\n+\tdf_live_verify_transfer_functions, df_chain_create_bb,\n+\tdf_byte_lr_free_bb_info, df_byte_lr_alloc, df_byte_lr_reset,\n+\tdf_byte_lr_bb_local_compute, df_byte_lr_bb_local_compute,\n+\tdf_byte_lr_bb_local_compute, df_byte_lr_bb_local_compute,\n+\tdf_byte_lr_bb_local_compute, df_byte_lr_local_compute, df_byte_lr_init,\n+\tdf_byte_lr_confluence_0, df_byte_lr_confluence_n,\n+\tdf_byte_lr_transfer_function, df_byte_lr_top_dump,\n+\tdf_byte_lr_bottom_dump, df_create_unused_note,\n+\tdf_note_bb_compute, df_md_free_bb_info, df_md_alloc,\n+\tdf_md_bb_local_compute_process_def, df_md_local_compute, df_md_reset,\n+\tdf_md_transfer_function, df_md_init, df_md_confluence_0,\n+\tdf_md_confluence_n,\n+\tdf_md_top_dump, df_md_bottom_dump): Update.  (struct df_lr_problem_data):\n+\tEmbedd bitmap headers.\n+\n 2010-06-04  Jan Hubicka  <jh@suse.cz>\n \n \t* dce.c (dce_process_block): Do not re-scan already marked instructions."}, {"sha": "72e12de03ca5fca2b9d3b6505a87f8da0424e91e", "filename": "gcc/ddg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "patch": "@@ -192,7 +192,7 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n           first_def = df_bb_regno_first_def_find (g->bb, regno);\n           gcc_assert (first_def);\n \n-          if (bitmap_bit_p (bb_info->gen, DF_REF_ID (first_def)))\n+          if (bitmap_bit_p (&bb_info->gen, DF_REF_ID (first_def)))\n             return;\n         }\n     }\n@@ -263,7 +263,7 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n \n #ifdef ENABLE_CHECKING\n   if (DF_REF_ID (last_def) != DF_REF_ID (first_def))\n-    gcc_assert (!bitmap_bit_p (bb_info->gen, DF_REF_ID (first_def)));\n+    gcc_assert (!bitmap_bit_p (&bb_info->gen, DF_REF_ID (first_def)));\n #endif\n \n   /* Create inter-loop true dependences and anti dependences.  */\n@@ -338,7 +338,7 @@ build_inter_loop_deps (ddg_ptr g)\n   rd_bb_info = DF_RD_BB_INFO (g->bb);\n \n   /* Find inter-loop register output, true and anti deps.  */\n-  EXECUTE_IF_SET_IN_BITMAP (rd_bb_info->gen, 0, rd_num, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (&rd_bb_info->gen, 0, rd_num, bi)\n   {\n     df_ref rd = DF_DEFS_GET (rd_num);\n "}, {"sha": "89f1733c2c4818bba4b1df9d804a20b9a3326f0b", "filename": "gcc/df-problems.c", "status": "modified", "additions": 238, "deletions": 238, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "patch": "@@ -223,11 +223,11 @@ df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n   struct df_rd_bb_info *bb_info = (struct df_rd_bb_info *) vbb_info;\n   if (bb_info)\n     {\n-      BITMAP_FREE (bb_info->kill);\n-      BITMAP_FREE (bb_info->sparse_kill);\n-      BITMAP_FREE (bb_info->gen);\n-      BITMAP_FREE (bb_info->in);\n-      BITMAP_FREE (bb_info->out);\n+      bitmap_clear (&bb_info->kill);\n+      bitmap_clear (&bb_info->sparse_kill);\n+      bitmap_clear (&bb_info->gen);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n       pool_free (df_rd->block_pool, bb_info);\n     }\n }\n@@ -276,19 +276,19 @@ df_rd_alloc (bitmap all_blocks)\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n       if (bb_info)\n \t{\n-\t  bitmap_clear (bb_info->kill);\n-\t  bitmap_clear (bb_info->sparse_kill);\n-\t  bitmap_clear (bb_info->gen);\n+\t  bitmap_clear (&bb_info->kill);\n+\t  bitmap_clear (&bb_info->sparse_kill);\n+\t  bitmap_clear (&bb_info->gen);\n \t}\n       else\n \t{\n \t  bb_info = (struct df_rd_bb_info *) pool_alloc (df_rd->block_pool);\n \t  df_rd_set_bb_info (bb_index, bb_info);\n-\t  bb_info->kill = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n-\t  bb_info->sparse_kill = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n-\t  bb_info->gen = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n-\t  bb_info->in = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n-\t  bb_info->out = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n+\t  bitmap_initialize (&bb_info->kill, &problem_data->rd_bitmaps);\n+\t  bitmap_initialize (&bb_info->sparse_kill, &problem_data->rd_bitmaps);\n+\t  bitmap_initialize (&bb_info->gen, &problem_data->rd_bitmaps);\n+\t  bitmap_initialize (&bb_info->in, &problem_data->rd_bitmaps);\n+\t  bitmap_initialize (&bb_info->out, &problem_data->rd_bitmaps);\n \t}\n     }\n   df_rd->optional_p = true;\n@@ -382,13 +382,13 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t    {\n \t\t      if (n_defs > DF_SPARSE_THRESHOLD)\n \t\t\t{\n-\t\t\t  bitmap_set_bit (bb_info->sparse_kill, regno);\n-\t\t\t  bitmap_clear_range(bb_info->gen, begin, n_defs);\n+\t\t\t  bitmap_set_bit (&bb_info->sparse_kill, regno);\n+\t\t\t  bitmap_clear_range(&bb_info->gen, begin, n_defs);\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  bitmap_set_range (bb_info->kill, begin, n_defs);\n-\t\t\t  bitmap_clear_range (bb_info->gen, begin, n_defs);\n+\t\t\t  bitmap_set_range (&bb_info->kill, begin, n_defs);\n+\t\t\t  bitmap_clear_range (&bb_info->gen, begin, n_defs);\n \t\t\t}\n \t\t    }\n \n@@ -397,7 +397,7 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t     the gen set.  */\n \t\t  if (!(DF_REF_FLAGS (def)\n \t\t\t& (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n-\t\t    bitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n+\t\t    bitmap_set_bit (&bb_info->gen, DF_REF_ID (def));\n \t\t}\n \t    }\n \t}\n@@ -504,8 +504,8 @@ df_rd_init_solution (bitmap all_blocks)\n     {\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n \n-      bitmap_copy (bb_info->out, bb_info->gen);\n-      bitmap_clear (bb_info->in);\n+      bitmap_copy (&bb_info->out, &bb_info->gen);\n+      bitmap_clear (&bb_info->in);\n     }\n }\n \n@@ -514,8 +514,8 @@ df_rd_init_solution (bitmap all_blocks)\n static void\n df_rd_confluence_n (edge e)\n {\n-  bitmap op1 = df_rd_get_bb_info (e->dest->index)->in;\n-  bitmap op2 = df_rd_get_bb_info (e->src->index)->out;\n+  bitmap op1 = &df_rd_get_bb_info (e->dest->index)->in;\n+  bitmap op2 = &df_rd_get_bb_info (e->src->index)->out;\n \n   if (e->flags & EDGE_FAKE)\n     return;\n@@ -555,11 +555,11 @@ df_rd_transfer_function (int bb_index)\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   unsigned int regno;\n   bitmap_iterator bi;\n-  bitmap in = bb_info->in;\n-  bitmap out = bb_info->out;\n-  bitmap gen = bb_info->gen;\n-  bitmap kill = bb_info->kill;\n-  bitmap sparse_kill = bb_info->sparse_kill;\n+  bitmap in = &bb_info->in;\n+  bitmap out = &bb_info->out;\n+  bitmap gen = &bb_info->gen;\n+  bitmap kill = &bb_info->kill;\n+  bitmap sparse_kill = &bb_info->sparse_kill;\n \n   if (bitmap_empty_p (sparse_kill))\n     return  bitmap_ior_and_compl (out, gen, in, kill);\n@@ -586,11 +586,11 @@ df_rd_transfer_function (int bb_index)\n       changed = !bitmap_equal_p (tmp, out);\n       if (changed)\n \t{\n-\t  BITMAP_FREE (out);\n-\t  bb_info->out = tmp;\n+\t  bitmap_clear (out);\n+\t  bb_info->out = *tmp;\n \t}\n       else\n-\t  BITMAP_FREE (tmp);\n+\t  bitmap_clear (tmp);\n       return changed;\n     }\n }\n@@ -653,15 +653,15 @@ static void\n df_rd_top_dump (basic_block bb, FILE *file)\n {\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->in)\n+  if (!bb_info)\n     return;\n \n-  fprintf (file, \";; rd  in  \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->in));\n-  dump_bitmap (file, bb_info->in);\n-  fprintf (file, \";; rd  gen \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->gen));\n-  dump_bitmap (file, bb_info->gen);\n-  fprintf (file, \";; rd  kill\\t(%d)\\n\", (int) bitmap_count_bits (bb_info->kill));\n-  dump_bitmap (file, bb_info->kill);\n+  fprintf (file, \";; rd  in  \\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->in));\n+  dump_bitmap (file, &bb_info->in);\n+  fprintf (file, \";; rd  gen \\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->gen));\n+  dump_bitmap (file, &bb_info->gen);\n+  fprintf (file, \";; rd  kill\\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->kill));\n+  dump_bitmap (file, &bb_info->kill);\n }\n \n \n@@ -671,11 +671,11 @@ static void\n df_rd_bottom_dump (basic_block bb, FILE *file)\n {\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->out)\n+  if (!bb_info)\n     return;\n \n-  fprintf (file, \";; rd  out \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->out));\n-  dump_bitmap (file, bb_info->out);\n+  fprintf (file, \";; rd  out \\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->out));\n+  dump_bitmap (file, &bb_info->out);\n }\n \n /* All of the information associated with every instance of the problem.  */\n@@ -731,8 +731,8 @@ df_rd_add_problem (void)\n /* Private data used to verify the solution for this problem.  */\n struct df_lr_problem_data\n {\n-  bitmap *in;\n-  bitmap *out;\n+  bitmap_head *in;\n+  bitmap_head *out;\n };\n \n \n@@ -757,10 +757,10 @@ df_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n   struct df_lr_bb_info *bb_info = (struct df_lr_bb_info *) vbb_info;\n   if (bb_info)\n     {\n-      BITMAP_FREE (bb_info->use);\n-      BITMAP_FREE (bb_info->def);\n-      BITMAP_FREE (bb_info->in);\n-      BITMAP_FREE (bb_info->out);\n+      bitmap_clear (&bb_info->use);\n+      bitmap_clear (&bb_info->def);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n       pool_free (df_lr->block_pool, bb_info);\n     }\n }\n@@ -786,17 +786,17 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n       struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n       if (bb_info)\n \t{\n-\t  bitmap_clear (bb_info->def);\n-\t  bitmap_clear (bb_info->use);\n+\t  bitmap_clear (&bb_info->def);\n+\t  bitmap_clear (&bb_info->use);\n \t}\n       else\n \t{\n \t  bb_info = (struct df_lr_bb_info *) pool_alloc (df_lr->block_pool);\n \t  df_lr_set_bb_info (bb_index, bb_info);\n-\t  bb_info->use = BITMAP_ALLOC (NULL);\n-\t  bb_info->def = BITMAP_ALLOC (NULL);\n-\t  bb_info->in = BITMAP_ALLOC (NULL);\n-\t  bb_info->out = BITMAP_ALLOC (NULL);\n+\t  bitmap_initialize (&bb_info->use, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->def, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->in, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->out, &bitmap_default_obstack);\n \t}\n     }\n \n@@ -816,8 +816,8 @@ df_lr_reset (bitmap all_blocks)\n     {\n       struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n-      bitmap_clear (bb_info->in);\n-      bitmap_clear (bb_info->out);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n     }\n }\n \n@@ -840,8 +840,8 @@ df_lr_bb_local_compute (unsigned int bb_index)\n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  bitmap_set_bit (bb_info->def, dregno);\n-\t  bitmap_clear_bit (bb_info->use, dregno);\n+\t  bitmap_set_bit (&bb_info->def, dregno);\n+\t  bitmap_clear_bit (&bb_info->use, dregno);\n \t}\n     }\n \n@@ -851,7 +851,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n       df_ref use = *use_rec;\n       /* Add use to set of uses in this BB.  */\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n-\tbitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n+\tbitmap_set_bit (&bb_info->use, DF_REF_REGNO (use));\n     }\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n@@ -869,16 +869,16 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n \t    {\n \t      unsigned int dregno = DF_REF_REGNO (def);\n-\t      bitmap_set_bit (bb_info->def, dregno);\n-\t      bitmap_clear_bit (bb_info->use, dregno);\n+\t      bitmap_set_bit (&bb_info->def, dregno);\n+\t      bitmap_clear_bit (&bb_info->use, dregno);\n \t    }\n \t}\n \n       for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t{\n \t  df_ref use = *use_rec;\n \t  /* Add use to set of uses in this BB.  */\n-\t  bitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n+\t  bitmap_set_bit (&bb_info->use, DF_REF_REGNO (use));\n \t}\n     }\n \n@@ -891,8 +891,8 @@ df_lr_bb_local_compute (unsigned int bb_index)\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  bitmap_set_bit (bb_info->def, dregno);\n-\t  bitmap_clear_bit (bb_info->use, dregno);\n+\t  bitmap_set_bit (&bb_info->def, dregno);\n+\t  bitmap_clear_bit (&bb_info->use, dregno);\n \t}\n     }\n \n@@ -959,7 +959,7 @@ df_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t  /* The exit block is special for this problem and its bits are\n \t     computed from thin air.  */\n \t  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (EXIT_BLOCK);\n-\t  bitmap_copy (bb_info->use, df->exit_block_uses);\n+\t  bitmap_copy (&bb_info->use, df->exit_block_uses);\n \t}\n       else\n \tdf_lr_bb_local_compute (bb_index);\n@@ -980,8 +980,8 @@ df_lr_init (bitmap all_blocks)\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n-      bitmap_copy (bb_info->in, bb_info->use);\n-      bitmap_clear (bb_info->out);\n+      bitmap_copy (&bb_info->in, &bb_info->use);\n+      bitmap_clear (&bb_info->out);\n     }\n }\n \n@@ -992,7 +992,7 @@ df_lr_init (bitmap all_blocks)\n static void\n df_lr_confluence_0 (basic_block bb)\n {\n-  bitmap op1 = df_lr_get_bb_info (bb->index)->out;\n+  bitmap op1 = &df_lr_get_bb_info (bb->index)->out;\n   if (bb != EXIT_BLOCK_PTR)\n     bitmap_copy (op1, df->hardware_regs_used);\n }\n@@ -1003,8 +1003,8 @@ df_lr_confluence_0 (basic_block bb)\n static void\n df_lr_confluence_n (edge e)\n {\n-  bitmap op1 = df_lr_get_bb_info (e->src->index)->out;\n-  bitmap op2 = df_lr_get_bb_info (e->dest->index)->in;\n+  bitmap op1 = &df_lr_get_bb_info (e->src->index)->out;\n+  bitmap op2 = &df_lr_get_bb_info (e->dest->index)->in;\n \n   /* Call-clobbered registers die across exception and call edges.  */\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n@@ -1024,10 +1024,10 @@ static bool\n df_lr_transfer_function (int bb_index)\n {\n   struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n-  bitmap in = bb_info->in;\n-  bitmap out = bb_info->out;\n-  bitmap use = bb_info->use;\n-  bitmap def = bb_info->def;\n+  bitmap in = &bb_info->in;\n+  bitmap out = &bb_info->out;\n+  bitmap use = &bb_info->use;\n+  bitmap def = &bb_info->def;\n \n   return bitmap_ior_and_compl (in, use, out, def);\n }\n@@ -1080,10 +1080,10 @@ df_lr_free (void)\n \t  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (i);\n \t  if (bb_info)\n \t    {\n-\t      BITMAP_FREE (bb_info->use);\n-\t      BITMAP_FREE (bb_info->def);\n-\t      BITMAP_FREE (bb_info->in);\n-\t      BITMAP_FREE (bb_info->out);\n+\t      bitmap_clear (&bb_info->use);\n+\t      bitmap_clear (&bb_info->def);\n+\t      bitmap_clear (&bb_info->in);\n+\t      bitmap_clear (&bb_info->out);\n \t    }\n \t}\n       free_alloc_pool (df_lr->block_pool);\n@@ -1104,21 +1104,21 @@ df_lr_top_dump (basic_block bb, FILE *file)\n {\n   struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n   struct df_lr_problem_data *problem_data;\n-  if (!bb_info || !bb_info->in)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; lr  in  \\t\");\n-  df_print_regset (file, bb_info->in);\n+  df_print_regset (file, &bb_info->in);\n   if (df_lr->problem_data)\n     {\n       problem_data = (struct df_lr_problem_data *)df_lr->problem_data;\n       fprintf (file, \";;  old in  \\t\");\n-      df_print_regset (file, problem_data->in[bb->index]);\n+      df_print_regset (file, &problem_data->in[bb->index]);\n     }\n   fprintf (file, \";; lr  use \\t\");\n-  df_print_regset (file, bb_info->use);\n+  df_print_regset (file, &bb_info->use);\n   fprintf (file, \";; lr  def \\t\");\n-  df_print_regset (file, bb_info->def);\n+  df_print_regset (file, &bb_info->def);\n }\n \n \n@@ -1129,16 +1129,16 @@ df_lr_bottom_dump (basic_block bb, FILE *file)\n {\n   struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n   struct df_lr_problem_data *problem_data;\n-  if (!bb_info || !bb_info->out)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; lr  out \\t\");\n-  df_print_regset (file, bb_info->out);\n+  df_print_regset (file, &bb_info->out);\n   if (df_lr->problem_data)\n     {\n       problem_data = (struct df_lr_problem_data *)df_lr->problem_data;\n       fprintf (file, \";;  old out  \\t\");\n-      df_print_regset (file, problem_data->out[bb->index]);\n+      df_print_regset (file, &problem_data->out[bb->index]);\n     }\n }\n \n@@ -1162,15 +1162,15 @@ df_lr_verify_solution_start (void)\n \n   problem_data = XNEW (struct df_lr_problem_data);\n   df_lr->problem_data = problem_data;\n-  problem_data->in = XNEWVEC (bitmap, last_basic_block);\n-  problem_data->out = XNEWVEC (bitmap, last_basic_block);\n+  problem_data->in = XNEWVEC (bitmap_head, last_basic_block);\n+  problem_data->out = XNEWVEC (bitmap_head, last_basic_block);\n \n   FOR_ALL_BB (bb)\n     {\n-      problem_data->in[bb->index] = BITMAP_ALLOC (NULL);\n-      problem_data->out[bb->index] = BITMAP_ALLOC (NULL);\n-      bitmap_copy (problem_data->in[bb->index], DF_LR_IN (bb));\n-      bitmap_copy (problem_data->out[bb->index], DF_LR_OUT (bb));\n+      bitmap_initialize (&problem_data->in[bb->index], &bitmap_default_obstack);\n+      bitmap_initialize (&problem_data->out[bb->index], &bitmap_default_obstack);\n+      bitmap_copy (&problem_data->in[bb->index], DF_LR_IN (bb));\n+      bitmap_copy (&problem_data->out[bb->index], DF_LR_OUT (bb));\n     }\n }\n \n@@ -1196,8 +1196,8 @@ df_lr_verify_solution_end (void)\n   else\n     FOR_ALL_BB (bb)\n       {\n-\tif ((!bitmap_equal_p (problem_data->in[bb->index], DF_LR_IN (bb)))\n-\t    || (!bitmap_equal_p (problem_data->out[bb->index], DF_LR_OUT (bb))))\n+\tif ((!bitmap_equal_p (&problem_data->in[bb->index], DF_LR_IN (bb)))\n+\t    || (!bitmap_equal_p (&problem_data->out[bb->index], DF_LR_OUT (bb))))\n \t  {\n \t    /*df_dump (stderr);*/\n \t    gcc_unreachable ();\n@@ -1208,8 +1208,8 @@ df_lr_verify_solution_end (void)\n      if the comparison fails.  */\n   FOR_ALL_BB (bb)\n     {\n-      BITMAP_FREE (problem_data->in[bb->index]);\n-      BITMAP_FREE (problem_data->out[bb->index]);\n+      bitmap_clear (&problem_data->in[bb->index]);\n+      bitmap_clear (&problem_data->out[bb->index]);\n     }\n \n   free (problem_data->in);\n@@ -1297,14 +1297,14 @@ df_lr_verify_transfer_functions (void)\n \t  if (!bitmap_bit_p (df_lr->out_of_date_transfer_functions,\n \t\t\t     bb->index))\n \t    {\n-\t      bitmap_copy (saved_def, bb_info->def);\n-\t      bitmap_copy (saved_use, bb_info->use);\n-\t      bitmap_clear (bb_info->def);\n-\t      bitmap_clear (bb_info->use);\n+\t      bitmap_copy (saved_def, &bb_info->def);\n+\t      bitmap_copy (saved_use, &bb_info->use);\n+\t      bitmap_clear (&bb_info->def);\n+\t      bitmap_clear (&bb_info->use);\n \n \t      df_lr_bb_local_compute (bb->index);\n-\t      gcc_assert (bitmap_equal_p (saved_def, bb_info->def));\n-\t      gcc_assert (bitmap_equal_p (saved_use, bb_info->use));\n+\t      gcc_assert (bitmap_equal_p (saved_def, &bb_info->def));\n+\t      gcc_assert (bitmap_equal_p (saved_use, &bb_info->use));\n \t    }\n \t}\n       else\n@@ -1355,8 +1355,8 @@ df_lr_verify_transfer_functions (void)\n /* Private data used to verify the solution for this problem.  */\n struct df_live_problem_data\n {\n-  bitmap *in;\n-  bitmap *out;\n+  bitmap_head *in;\n+  bitmap_head *out;\n };\n \n /* Scratch var used by transfer functions.  This is used to implement\n@@ -1385,10 +1385,10 @@ df_live_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n   struct df_live_bb_info *bb_info = (struct df_live_bb_info *) vbb_info;\n   if (bb_info)\n     {\n-      BITMAP_FREE (bb_info->gen);\n-      BITMAP_FREE (bb_info->kill);\n-      BITMAP_FREE (bb_info->in);\n-      BITMAP_FREE (bb_info->out);\n+      bitmap_clear (&bb_info->gen);\n+      bitmap_clear (&bb_info->kill);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n       pool_free (df_live->block_pool, bb_info);\n     }\n }\n@@ -1416,17 +1416,17 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n       struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n       if (bb_info)\n \t{\n-\t  bitmap_clear (bb_info->kill);\n-\t  bitmap_clear (bb_info->gen);\n+\t  bitmap_clear (&bb_info->kill);\n+\t  bitmap_clear (&bb_info->gen);\n \t}\n       else\n \t{\n \t  bb_info = (struct df_live_bb_info *) pool_alloc (df_live->block_pool);\n \t  df_live_set_bb_info (bb_index, bb_info);\n-\t  bb_info->kill = BITMAP_ALLOC (NULL);\n-\t  bb_info->gen = BITMAP_ALLOC (NULL);\n-\t  bb_info->in = BITMAP_ALLOC (NULL);\n-\t  bb_info->out = BITMAP_ALLOC (NULL);\n+\t  bitmap_initialize (&bb_info->kill, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->gen, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->in, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->out, &bitmap_default_obstack);\n \t}\n     }\n   df_live->optional_p = (optimize <= 1);\n@@ -1445,8 +1445,8 @@ df_live_reset (bitmap all_blocks)\n     {\n       struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n-      bitmap_clear (bb_info->in);\n-      bitmap_clear (bb_info->out);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n     }\n }\n \n@@ -1489,20 +1489,20 @@ df_live_bb_local_compute (unsigned int bb_index)\n \t\t\t\t   DF_REF_PARTIAL | DF_REF_CONDITIONAL))\n \t    /* All partial or conditional def\n \t       seen are included in the gen set. */\n-\t    bitmap_set_bit (bb_info->gen, regno);\n+\t    bitmap_set_bit (&bb_info->gen, regno);\n \t  else if (DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER))\n \t    /* Only must clobbers for the entire reg destroy the\n \t       value.  */\n-\t    bitmap_set_bit (bb_info->kill, regno);\n+\t    bitmap_set_bit (&bb_info->kill, regno);\n \t  else if (! DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n-\t    bitmap_set_bit (bb_info->gen, regno);\n+\t    bitmap_set_bit (&bb_info->gen, regno);\n \t}\n     }\n \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n-      bitmap_set_bit (bb_info->gen, DF_REF_REGNO (def));\n+      bitmap_set_bit (&bb_info->gen, DF_REF_REGNO (def));\n     }\n }\n \n@@ -1542,8 +1542,8 @@ df_live_init (bitmap all_blocks)\n \n       /* No register may reach a location where it is not used.  Thus\n \t we trim the rr result to the places where it is used.  */\n-      bitmap_and (bb_info->out, bb_info->gen, bb_lr_info->out);\n-      bitmap_clear (bb_info->in);\n+      bitmap_and (&bb_info->out, &bb_info->gen, &bb_lr_info->out);\n+      bitmap_clear (&bb_info->in);\n     }\n }\n \n@@ -1552,8 +1552,8 @@ df_live_init (bitmap all_blocks)\n static void\n df_live_confluence_n (edge e)\n {\n-  bitmap op1 = df_live_get_bb_info (e->dest->index)->in;\n-  bitmap op2 = df_live_get_bb_info (e->src->index)->out;\n+  bitmap op1 = &df_live_get_bb_info (e->dest->index)->in;\n+  bitmap op2 = &df_live_get_bb_info (e->src->index)->out;\n \n   if (e->flags & EDGE_FAKE)\n     return;\n@@ -1569,18 +1569,18 @@ df_live_transfer_function (int bb_index)\n {\n   struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n   struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n-  bitmap in = bb_info->in;\n-  bitmap out = bb_info->out;\n-  bitmap gen = bb_info->gen;\n-  bitmap kill = bb_info->kill;\n+  bitmap in = &bb_info->in;\n+  bitmap out = &bb_info->out;\n+  bitmap gen = &bb_info->gen;\n+  bitmap kill = &bb_info->kill;\n \n   /* We need to use a scratch set here so that the value returned from this\n      function invocation properly reflects whether the sets changed in a\n      significant way; i.e. not just because the lr set was anded in.  */\n-  bitmap_and (df_live_scratch, gen, bb_lr_info->out);\n+  bitmap_and (df_live_scratch, gen, &bb_lr_info->out);\n   /* No register may reach a location where it is not used.  Thus\n      we trim the rr result to the places where it is used.  */\n-  bitmap_and_into (in, bb_lr_info->in);\n+  bitmap_and_into (in, &bb_lr_info->in);\n \n   return bitmap_ior_and_compl (out, df_live_scratch, in, kill);\n }\n@@ -1604,8 +1604,8 @@ df_live_finalize (bitmap all_blocks)\n \n \t  /* No register may reach a location where it is not used.  Thus\n \t     we trim the rr result to the places where it is used.  */\n-\t  bitmap_and_into (bb_live_info->in, bb_lr_info->in);\n-\t  bitmap_and_into (bb_live_info->out, bb_lr_info->out);\n+\t  bitmap_and_into (&bb_live_info->in, &bb_lr_info->in);\n+\t  bitmap_and_into (&bb_live_info->out, &bb_lr_info->out);\n \t}\n \n       df_live->solutions_dirty = false;\n@@ -1627,10 +1627,10 @@ df_live_free (void)\n \t  struct df_live_bb_info *bb_info = df_live_get_bb_info (i);\n \t  if (bb_info)\n \t    {\n-\t      BITMAP_FREE (bb_info->gen);\n-\t      BITMAP_FREE (bb_info->kill);\n-\t      BITMAP_FREE (bb_info->in);\n-\t      BITMAP_FREE (bb_info->out);\n+\t      bitmap_clear (&bb_info->gen);\n+\t      bitmap_clear (&bb_info->kill);\n+\t      bitmap_clear (&bb_info->in);\n+\t      bitmap_clear (&bb_info->out);\n \t    }\n \t}\n \n@@ -1654,21 +1654,21 @@ df_live_top_dump (basic_block bb, FILE *file)\n   struct df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n   struct df_live_problem_data *problem_data;\n \n-  if (!bb_info || !bb_info->in)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; live  in  \\t\");\n-  df_print_regset (file, bb_info->in);\n+  df_print_regset (file, &bb_info->in);\n   if (df_live->problem_data)\n     {\n       problem_data = (struct df_live_problem_data *)df_live->problem_data;\n       fprintf (file, \";;  old in  \\t\");\n-      df_print_regset (file, problem_data->in[bb->index]);\n+      df_print_regset (file, &problem_data->in[bb->index]);\n     }\n   fprintf (file, \";; live  gen \\t\");\n-  df_print_regset (file, bb_info->gen);\n+  df_print_regset (file, &bb_info->gen);\n   fprintf (file, \";; live  kill\\t\");\n-  df_print_regset (file, bb_info->kill);\n+  df_print_regset (file, &bb_info->kill);\n }\n \n \n@@ -1680,16 +1680,16 @@ df_live_bottom_dump (basic_block bb, FILE *file)\n   struct df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n   struct df_live_problem_data *problem_data;\n \n-  if (!bb_info || !bb_info->out)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; live  out \\t\");\n-  df_print_regset (file, bb_info->out);\n+  df_print_regset (file, &bb_info->out);\n   if (df_live->problem_data)\n     {\n       problem_data = (struct df_live_problem_data *)df_live->problem_data;\n       fprintf (file, \";;  old out  \\t\");\n-      df_print_regset (file, problem_data->out[bb->index]);\n+      df_print_regset (file, &problem_data->out[bb->index]);\n     }\n }\n \n@@ -1713,15 +1713,15 @@ df_live_verify_solution_start (void)\n \n   problem_data = XNEW (struct df_live_problem_data);\n   df_live->problem_data = problem_data;\n-  problem_data->in = XNEWVEC (bitmap, last_basic_block);\n-  problem_data->out = XNEWVEC (bitmap, last_basic_block);\n+  problem_data->in = XNEWVEC (bitmap_head, last_basic_block);\n+  problem_data->out = XNEWVEC (bitmap_head, last_basic_block);\n \n   FOR_ALL_BB (bb)\n     {\n-      problem_data->in[bb->index] = BITMAP_ALLOC (NULL);\n-      problem_data->out[bb->index] = BITMAP_ALLOC (NULL);\n-      bitmap_copy (problem_data->in[bb->index], DF_LIVE_IN (bb));\n-      bitmap_copy (problem_data->out[bb->index], DF_LIVE_OUT (bb));\n+      bitmap_initialize (&problem_data->in[bb->index], &bitmap_default_obstack);\n+      bitmap_initialize (&problem_data->out[bb->index], &bitmap_default_obstack);\n+      bitmap_copy (&problem_data->in[bb->index], DF_LIVE_IN (bb));\n+      bitmap_copy (&problem_data->out[bb->index], DF_LIVE_OUT (bb));\n     }\n }\n \n@@ -1742,8 +1742,8 @@ df_live_verify_solution_end (void)\n \n   FOR_ALL_BB (bb)\n     {\n-      if ((!bitmap_equal_p (problem_data->in[bb->index], DF_LIVE_IN (bb)))\n-\t  || (!bitmap_equal_p (problem_data->out[bb->index], DF_LIVE_OUT (bb))))\n+      if ((!bitmap_equal_p (&problem_data->in[bb->index], DF_LIVE_IN (bb)))\n+\t  || (!bitmap_equal_p (&problem_data->out[bb->index], DF_LIVE_OUT (bb))))\n \t{\n \t  /*df_dump (stderr);*/\n \t  gcc_unreachable ();\n@@ -1754,8 +1754,8 @@ df_live_verify_solution_end (void)\n      if the comparison fails.  */\n   FOR_ALL_BB (bb)\n     {\n-      BITMAP_FREE (problem_data->in[bb->index]);\n-      BITMAP_FREE (problem_data->out[bb->index]);\n+      bitmap_clear (&problem_data->in[bb->index]);\n+      bitmap_clear (&problem_data->out[bb->index]);\n     }\n \n   free (problem_data->in);\n@@ -1854,14 +1854,14 @@ df_live_verify_transfer_functions (void)\n \t  if (!bitmap_bit_p (df_live->out_of_date_transfer_functions,\n \t\t\t     bb->index))\n \t    {\n-\t      bitmap_copy (saved_gen, bb_info->gen);\n-\t      bitmap_copy (saved_kill, bb_info->kill);\n-\t      bitmap_clear (bb_info->gen);\n-\t      bitmap_clear (bb_info->kill);\n+\t      bitmap_copy (saved_gen, &bb_info->gen);\n+\t      bitmap_copy (saved_kill, &bb_info->kill);\n+\t      bitmap_clear (&bb_info->gen);\n+\t      bitmap_clear (&bb_info->kill);\n \n \t      df_live_bb_local_compute (bb->index);\n-\t      gcc_assert (bitmap_equal_p (saved_gen, bb_info->gen));\n-\t      gcc_assert (bitmap_equal_p (saved_kill, bb_info->kill));\n+\t      gcc_assert (bitmap_equal_p (saved_gen, &bb_info->gen));\n+\t      gcc_assert (bitmap_equal_p (saved_kill, &bb_info->kill));\n \t    }\n \t}\n       else\n@@ -2111,7 +2111,7 @@ df_chain_create_bb (unsigned int bb_index)\n   rtx insn;\n   bitmap cpy = BITMAP_ALLOC (NULL);\n \n-  bitmap_copy (cpy, bb_info->in);\n+  bitmap_copy (cpy, &bb_info->in);\n   bitmap_set_bit (df_chain->out_of_date_transfer_functions, bb_index);\n \n   /* Since we are going forwards, process the artificial uses first\n@@ -2427,10 +2427,10 @@ df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n   struct df_byte_lr_bb_info *bb_info = (struct df_byte_lr_bb_info *) vbb_info;\n   if (bb_info)\n     {\n-      BITMAP_FREE (bb_info->use);\n-      BITMAP_FREE (bb_info->def);\n-      BITMAP_FREE (bb_info->in);\n-      BITMAP_FREE (bb_info->out);\n+      bitmap_clear (&bb_info->use);\n+      bitmap_clear (&bb_info->def);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n       pool_free (df_byte_lr->block_pool, bb_info);\n     }\n }\n@@ -2557,17 +2557,17 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n       struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n       if (bb_info)\n \t{\n-\t  bitmap_clear (bb_info->def);\n-\t  bitmap_clear (bb_info->use);\n+\t  bitmap_clear (&bb_info->def);\n+\t  bitmap_clear (&bb_info->use);\n \t}\n       else\n \t{\n \t  bb_info = (struct df_byte_lr_bb_info *) pool_alloc (df_byte_lr->block_pool);\n \t  df_byte_lr_set_bb_info (bb_index, bb_info);\n-\t  bb_info->use = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n-\t  bb_info->def = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n-\t  bb_info->in = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n-\t  bb_info->out = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->use, &problem_data->byte_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->def, &problem_data->byte_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->in, &problem_data->byte_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->out, &problem_data->byte_lr_bitmaps);\n \t}\n     }\n \n@@ -2587,8 +2587,8 @@ df_byte_lr_reset (bitmap all_blocks)\n     {\n       struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n-      bitmap_clear (bb_info->in);\n-      bitmap_clear (bb_info->out);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n     }\n }\n \n@@ -2615,8 +2615,8 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \t  unsigned int dregno = DF_REF_REGNO (def);\n \t  unsigned int start = problem_data->regno_start[dregno];\n \t  unsigned int len = problem_data->regno_len[dregno];\n-\t  bitmap_set_range (bb_info->def, start, len);\n-\t  bitmap_clear_range (bb_info->use, start, len);\n+\t  bitmap_set_range (&bb_info->def, start, len);\n+\t  bitmap_clear_range (&bb_info->use, start, len);\n \t}\n     }\n \n@@ -2630,7 +2630,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \t  unsigned int start = problem_data->regno_start[uregno];\n \t  unsigned int len = problem_data->regno_len[uregno];\n-\t  bitmap_set_range (bb_info->use, start, len);\n+\t  bitmap_set_range (&bb_info->use, start, len);\n \t}\n     }\n \n@@ -2660,8 +2660,8 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \t\t}\n \t      if (len)\n \t\t{\n-\t\t  bitmap_set_range (bb_info->def, start, len);\n-\t\t  bitmap_clear_range (bb_info->use, start, len);\n+\t\t  bitmap_set_range (&bb_info->def, start, len);\n+\t\t  bitmap_clear_range (&bb_info->use, start, len);\n \t\t}\n \t    }\n \t}\n@@ -2681,7 +2681,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \t    }\n \t  /* Add use to set of uses in this BB.  */\n \t  if (len)\n-\t    bitmap_set_range (bb_info->use, start, len);\n+\t    bitmap_set_range (&bb_info->use, start, len);\n \t}\n     }\n \n@@ -2696,8 +2696,8 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \t  unsigned int dregno = DF_REF_REGNO (def);\n \t  unsigned int start = problem_data->regno_start[dregno];\n \t  unsigned int len = problem_data->regno_len[dregno];\n-\t  bitmap_set_range (bb_info->def, start, len);\n-\t  bitmap_clear_range (bb_info->use, start, len);\n+\t  bitmap_set_range (&bb_info->def, start, len);\n+\t  bitmap_clear_range (&bb_info->use, start, len);\n \t}\n     }\n \n@@ -2734,7 +2734,7 @@ df_byte_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t  /* The exit block is special for this problem and its bits are\n \t     computed from thin air.  */\n \t  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (EXIT_BLOCK);\n-\t  df_byte_lr_expand_bitmap (bb_info->use, df->exit_block_uses);\n+\t  df_byte_lr_expand_bitmap (&bb_info->use, df->exit_block_uses);\n \t}\n       else\n \tdf_byte_lr_bb_local_compute (bb_index);\n@@ -2755,8 +2755,8 @@ df_byte_lr_init (bitmap all_blocks)\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n-      bitmap_copy (bb_info->in, bb_info->use);\n-      bitmap_clear (bb_info->out);\n+      bitmap_copy (&bb_info->in, &bb_info->use);\n+      bitmap_clear (&bb_info->out);\n     }\n }\n \n@@ -2769,7 +2769,7 @@ df_byte_lr_confluence_0 (basic_block bb)\n {\n   struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  bitmap op1 = df_byte_lr_get_bb_info (bb->index)->out;\n+  bitmap op1 = &df_byte_lr_get_bb_info (bb->index)->out;\n   if (bb != EXIT_BLOCK_PTR)\n     bitmap_copy (op1, problem_data->hardware_regs_used);\n }\n@@ -2782,8 +2782,8 @@ df_byte_lr_confluence_n (edge e)\n {\n   struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  bitmap op1 = df_byte_lr_get_bb_info (e->src->index)->out;\n-  bitmap op2 = df_byte_lr_get_bb_info (e->dest->index)->in;\n+  bitmap op1 = &df_byte_lr_get_bb_info (e->src->index)->out;\n+  bitmap op2 = &df_byte_lr_get_bb_info (e->dest->index)->in;\n \n   /* Call-clobbered registers die across exception and call edges.  */\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n@@ -2803,10 +2803,10 @@ static bool\n df_byte_lr_transfer_function (int bb_index)\n {\n   struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n-  bitmap in = bb_info->in;\n-  bitmap out = bb_info->out;\n-  bitmap use = bb_info->use;\n-  bitmap def = bb_info->def;\n+  bitmap in = &bb_info->in;\n+  bitmap out = &bb_info->out;\n+  bitmap use = &bb_info->use;\n+  bitmap def = &bb_info->def;\n \n   return bitmap_ior_and_compl (in, use, out, def);\n }\n@@ -2843,15 +2843,15 @@ static void\n df_byte_lr_top_dump (basic_block bb, FILE *file)\n {\n   struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->in)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; blr  in  \\t\");\n-  df_print_byte_regset (file, bb_info->in);\n+  df_print_byte_regset (file, &bb_info->in);\n   fprintf (file, \";; blr  use \\t\");\n-  df_print_byte_regset (file, bb_info->use);\n+  df_print_byte_regset (file, &bb_info->use);\n   fprintf (file, \";; blr  def \\t\");\n-  df_print_byte_regset (file, bb_info->def);\n+  df_print_byte_regset (file, &bb_info->def);\n }\n \n \n@@ -2861,11 +2861,11 @@ static void\n df_byte_lr_bottom_dump (basic_block bb, FILE *file)\n {\n   struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->out)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; blr  out \\t\");\n-  df_print_byte_regset (file, bb_info->out);\n+  df_print_byte_regset (file, &bb_info->out);\n }\n \n \n@@ -4212,11 +4212,11 @@ df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n   struct df_md_bb_info *bb_info = (struct df_md_bb_info *) vbb_info;\n   if (bb_info)\n     {\n-      BITMAP_FREE (bb_info->kill);\n-      BITMAP_FREE (bb_info->gen);\n-      BITMAP_FREE (bb_info->init);\n-      BITMAP_FREE (bb_info->in);\n-      BITMAP_FREE (bb_info->out);\n+      bitmap_clear (&bb_info->kill);\n+      bitmap_clear (&bb_info->gen);\n+      bitmap_clear (&bb_info->init);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n       pool_free (df_md->block_pool, bb_info);\n     }\n }\n@@ -4243,21 +4243,21 @@ df_md_alloc (bitmap all_blocks)\n       struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n       if (bb_info)\n         {\n-          bitmap_clear (bb_info->init);\n-          bitmap_clear (bb_info->gen);\n-          bitmap_clear (bb_info->kill);\n-          bitmap_clear (bb_info->in);\n-          bitmap_clear (bb_info->out);\n+          bitmap_clear (&bb_info->init);\n+          bitmap_clear (&bb_info->gen);\n+          bitmap_clear (&bb_info->kill);\n+          bitmap_clear (&bb_info->in);\n+          bitmap_clear (&bb_info->out);\n         }\n       else\n         {\n           bb_info = (struct df_md_bb_info *) pool_alloc (df_md->block_pool);\n           df_md_set_bb_info (bb_index, bb_info);\n-          bb_info->init = BITMAP_ALLOC (NULL);\n-          bb_info->gen = BITMAP_ALLOC (NULL);\n-          bb_info->kill = BITMAP_ALLOC (NULL);\n-          bb_info->in = BITMAP_ALLOC (NULL);\n-          bb_info->out = BITMAP_ALLOC (NULL);\n+\t  bitmap_initialize (&bb_info->init, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->gen, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->kill, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->in, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->out, &bitmap_default_obstack);\n         }\n     }\n \n@@ -4334,16 +4334,16 @@ df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info,\n \t      if (DF_REF_FLAGS (def)\n \t          & (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))\n \t        {\n-\t          bitmap_set_bit (bb_info->gen, dregno);\n-\t          bitmap_clear_bit (bb_info->kill, dregno);\n+\t          bitmap_set_bit (&bb_info->gen, dregno);\n+\t          bitmap_clear_bit (&bb_info->kill, dregno);\n \t        }\n \t      else\n \t        {\n \t\t  /* When we find a clobber and a regular def,\n \t\t     make sure the regular def wins.  */\n \t          bitmap_set_bit (seen_in_insn, dregno);\n-\t          bitmap_set_bit (bb_info->kill, dregno);\n-\t          bitmap_clear_bit (bb_info->gen, dregno);\n+\t          bitmap_set_bit (&bb_info->kill, dregno);\n+\t          bitmap_clear_bit (&bb_info->gen, dregno);\n \t        }\n \t    }\n \t}\n@@ -4409,12 +4409,12 @@ df_md_local_compute (bitmap all_blocks)\n   /* Add each basic block's kills to the nodes in the frontier of the BB.  */\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi1)\n     {\n-      bitmap kill = df_md_get_bb_info (bb_index)->kill;\n+      bitmap kill = &df_md_get_bb_info (bb_index)->kill;\n       EXECUTE_IF_SET_IN_BITMAP (frontiers[bb_index], 0, df_bb_index, bi2)\n \t{\n \t  basic_block bb = BASIC_BLOCK (df_bb_index);\n \t  if (bitmap_bit_p (all_blocks, df_bb_index))\n-\t    bitmap_ior_and_into (df_md_get_bb_info (df_bb_index)->init, kill,\n+\t    bitmap_ior_and_into (&df_md_get_bb_info (df_bb_index)->init, kill,\n \t\t\t\t df_get_live_in (bb));\n \t}\n     }\n@@ -4437,8 +4437,8 @@ df_md_reset (bitmap all_blocks)\n     {\n       struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n-      bitmap_clear (bb_info->in);\n-      bitmap_clear (bb_info->out);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n     }\n }\n \n@@ -4447,10 +4447,10 @@ df_md_transfer_function (int bb_index)\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n-  bitmap in = bb_info->in;\n-  bitmap out = bb_info->out;\n-  bitmap gen = bb_info->gen;\n-  bitmap kill = bb_info->kill;\n+  bitmap in = &bb_info->in;\n+  bitmap out = &bb_info->out;\n+  bitmap gen = &bb_info->gen;\n+  bitmap kill = &bb_info->kill;\n \n   /* We need to use a scratch set here so that the value returned from this\n      function invocation properly reflects whether the sets changed in a\n@@ -4476,7 +4476,7 @@ df_md_init (bitmap all_blocks)\n     {\n       struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n \n-      bitmap_copy (bb_info->in, bb_info->init);\n+      bitmap_copy (&bb_info->in, &bb_info->init);\n       df_md_transfer_function (bb_index);\n     }\n }\n@@ -4485,16 +4485,16 @@ static void\n df_md_confluence_0 (basic_block bb)\n {\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n-  bitmap_copy (bb_info->in, bb_info->init);\n+  bitmap_copy (&bb_info->in, &bb_info->init);\n }\n \n /* In of target gets or of out of source.  */\n \n static void\n df_md_confluence_n (edge e)\n {\n-  bitmap op1 = df_md_get_bb_info (e->dest->index)->in;\n-  bitmap op2 = df_md_get_bb_info (e->src->index)->out;\n+  bitmap op1 = &df_md_get_bb_info (e->dest->index)->in;\n+  bitmap op2 = &df_md_get_bb_info (e->src->index)->out;\n \n   if (e->flags & EDGE_FAKE)\n     return;\n@@ -4516,11 +4516,11 @@ df_md_free (void)\n       struct df_md_bb_info *bb_info = df_md_get_bb_info (i);\n       if (bb_info)\n \t{\n-\t  BITMAP_FREE (bb_info->kill);\n-\t  BITMAP_FREE (bb_info->gen);\n-\t  BITMAP_FREE (bb_info->init);\n-\t  BITMAP_FREE (bb_info->in);\n-\t  BITMAP_FREE (bb_info->out);\n+\t  bitmap_clear (&bb_info->kill);\n+\t  bitmap_clear (&bb_info->gen);\n+\t  bitmap_clear (&bb_info->init);\n+\t  bitmap_clear (&bb_info->in);\n+\t  bitmap_clear (&bb_info->out);\n \t}\n     }\n \n@@ -4539,17 +4539,17 @@ static void\n df_md_top_dump (basic_block bb, FILE *file)\n {\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->in)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; md  in  \\t\");\n-  df_print_regset (file, bb_info->in);\n+  df_print_regset (file, &bb_info->in);\n   fprintf (file, \";; md  init  \\t\");\n-  df_print_regset (file, bb_info->init);\n+  df_print_regset (file, &bb_info->init);\n   fprintf (file, \";; md  gen \\t\");\n-  df_print_regset (file, bb_info->gen);\n+  df_print_regset (file, &bb_info->gen);\n   fprintf (file, \";; md  kill \\t\");\n-  df_print_regset (file, bb_info->kill);\n+  df_print_regset (file, &bb_info->kill);\n }\n \n /* Debugging info at bottom of bb.  */\n@@ -4558,11 +4558,11 @@ static void\n df_md_bottom_dump (basic_block bb, FILE *file)\n {\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->out)\n+  if (!bb_info)\n     return;\n \n   fprintf (file, \";; md  out \\t\");\n-  df_print_regset (file, bb_info->out);\n+  df_print_regset (file, &bb_info->out);\n }\n \n static struct df_problem problem_MD ="}, {"sha": "bbe332be53068743afc723c7bf79465a1093939f", "filename": "gcc/df.h", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "patch": "@@ -626,20 +626,20 @@ struct df\n \n /* Most transformations that wish to use live register analysis will\n    use these macros.  This info is the and of the lr and live sets.  */\n-#define DF_LIVE_IN(BB) (DF_LIVE_BB_INFO(BB)->in)\n-#define DF_LIVE_OUT(BB) (DF_LIVE_BB_INFO(BB)->out)\n+#define DF_LIVE_IN(BB) (&DF_LIVE_BB_INFO(BB)->in)\n+#define DF_LIVE_OUT(BB) (&DF_LIVE_BB_INFO(BB)->out)\n \n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n-#define DF_LR_IN(BB) (DF_LR_BB_INFO(BB)->in)\n-#define DF_LR_OUT(BB) (DF_LR_BB_INFO(BB)->out)\n+#define DF_LR_IN(BB) (&DF_LR_BB_INFO(BB)->in)\n+#define DF_LR_OUT(BB) (&DF_LR_BB_INFO(BB)->out)\n \n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n-#define DF_BYTE_LR_IN(BB) (DF_BYTE_LR_BB_INFO(BB)->in)\n-#define DF_BYTE_LR_OUT(BB) (DF_BYTE_LR_BB_INFO(BB)->out)\n+#define DF_BYTE_LR_IN(BB) (&DF_BYTE_LR_BB_INFO(BB)->in)\n+#define DF_BYTE_LR_OUT(BB) (&DF_BYTE_LR_BB_INFO(BB)->out)\n \n /* Macros to access the elements within the ref structure.  */\n \n@@ -796,13 +796,13 @@ struct df_scan_bb_info\n struct df_rd_bb_info\n {\n   /* Local sets to describe the basic blocks.   */\n-  bitmap kill;\n-  bitmap sparse_kill;\n-  bitmap gen;   /* The set of defs generated in this block.  */\n+  bitmap_head kill;\n+  bitmap_head sparse_kill;\n+  bitmap_head gen;   /* The set of defs generated in this block.  */\n \n   /* The results of the dataflow problem.  */\n-  bitmap in;    /* At the top of the block.  */\n-  bitmap out;   /* At the bottom of the block.  */\n+  bitmap_head in;    /* At the top of the block.  */\n+  bitmap_head out;   /* At the bottom of the block.  */\n };\n \n \n@@ -812,13 +812,13 @@ struct df_rd_bb_info\n struct df_md_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n-  bitmap gen;    /* Partial/conditional definitions live at BB out.  */\n-  bitmap kill;   /* Other definitions that are live at BB out.  */\n-  bitmap init;   /* Definitions coming from dominance frontier edges. */\n+  bitmap_head gen;    /* Partial/conditional definitions live at BB out.  */\n+  bitmap_head kill;   /* Other definitions that are live at BB out.  */\n+  bitmap_head init;   /* Definitions coming from dominance frontier edges. */\n \n   /* The results of the dataflow problem.  */\n-  bitmap in;    /* Just before the block itself. */\n-  bitmap out;   /* At the bottom of the block.  */\n+  bitmap_head in;    /* Just before the block itself. */\n+  bitmap_head out;   /* At the bottom of the block.  */\n };\n \n \n@@ -828,13 +828,13 @@ struct df_md_bb_info\n struct df_lr_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n-  bitmap def;   /* The set of registers set in this block\n-                   - except artificial defs at the top.  */\n-  bitmap use;   /* The set of registers used in this block.  */\n+  bitmap_head def;   /* The set of registers set in this block\n+                        - except artificial defs at the top.  */\n+  bitmap_head use;   /* The set of registers used in this block.  */\n \n   /* The results of the dataflow problem.  */\n-  bitmap in;    /* Just before the block itself. */\n-  bitmap out;   /* At the bottom of the block.  */\n+  bitmap_head in;    /* Just before the block itself. */\n+  bitmap_head out;   /* At the bottom of the block.  */\n };\n \n \n@@ -845,13 +845,13 @@ struct df_lr_bb_info\n struct df_live_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n-  bitmap kill;  /* The set of registers unset in this block.  Calls,\n-\t\t   for instance, unset registers.  */\n-  bitmap gen;   /* The set of registers set in this block.  */\n+  bitmap_head kill;  /* The set of registers unset in this block.  Calls,\n+\t\t        for instance, unset registers.  */\n+  bitmap_head gen;   /* The set of registers set in this block.  */\n \n   /* The results of the dataflow problem.  */\n-  bitmap in;    /* At the top of the block.  */\n-  bitmap out;   /* At the bottom of the block.  */\n+  bitmap_head in;    /* At the top of the block.  */\n+  bitmap_head out;   /* At the bottom of the block.  */\n };\n \n \n@@ -861,13 +861,13 @@ indexed by the df_byte_lr_offset array which is indexed by pseudo.  */\n struct df_byte_lr_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n-  bitmap def;   /* The set of registers set in this block\n-                   - except artificial defs at the top.  */\n-  bitmap use;   /* The set of registers used in this block.  */\n+  bitmap_head def;   /* The set of registers set in this block\n+                        - except artificial defs at the top.  */\n+  bitmap_head use;   /* The set of registers used in this block.  */\n \n   /* The results of the dataflow problem.  */\n-  bitmap in;    /* Just before the block itself. */\n-  bitmap out;   /* At the bottom of the block.  */\n+  bitmap_head in;    /* Just before the block itself. */\n+  bitmap_head out;   /* At the bottom of the block.  */\n };\n \n "}, {"sha": "c96a0a301ec58209d841c947e96d8aaf96bbf2d0", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "patch": "@@ -220,8 +220,8 @@ single_def_use_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   struct df_lr_bb_info *lr_bb_info = df_lr_get_bb_info (bb_index);\n   rtx insn;\n \n-  bitmap_copy (local_md, md_bb_info->in);\n-  bitmap_copy (local_lr, lr_bb_info->in);\n+  bitmap_copy (local_md, &md_bb_info->in);\n+  bitmap_copy (local_lr, &lr_bb_info->in);\n \n   /* Push a marker for the leave_block callback.  */\n   VEC_safe_push (df_ref, heap, reg_defs_stack, NULL);"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/ipa-split.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=b33a91c9463e39c0f5a4928b8deb770d80bc80bc"}, {"sha": "141b51fc3222317764105345f2bc24848fed2b67", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a91c9463e39c0f5a4928b8deb770d80bc80bc/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=b33a91c9463e39c0f5a4928b8deb770d80bc80bc", "patch": "@@ -304,7 +304,7 @@ latch_dominating_def (rtx reg, df_ref *def)\n   for (adef = DF_REG_DEF_CHAIN (regno); adef; adef = DF_REF_NEXT_REG (adef))\n     {\n       if (!bitmap_bit_p (df->blocks_to_analyze, DF_REF_BBNO (adef))\n-\t  || !bitmap_bit_p (bb_info->out, DF_REF_ID (adef)))\n+\t  || !bitmap_bit_p (&bb_info->out, DF_REF_ID (adef)))\n \tcontinue;\n \n       /* More than one reaching definition.  */"}]}