{"sha": "0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMxZTBkNjNmZTBjZWFiYmQwNDM4NDA3MGYzYjU5ZjhiZjUwZGUwOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-11-13T04:49:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-11-13T04:49:09Z"}, "message": "Implement P0315R4, Lambdas in unevaluated contexts.\n\nWhen lambdas were added in C++11 they were banned from unevaluated contexts\nas a way to avoid needing to deal with them in mangling or SFINAE.  This\nproposal avoids that with a more narrow proposal: lambdas never compare as\nequivalent (so we don't need to mangle them), and substitution failures\nwithin a lambda are hard errors.  Lambdas appearing in places that types\ncouldn't previously have been declared introduces various complications; in\nparticular, it seems likely to mean types with no linkage being used more\nbroadly, risking ODR violations.  I want to follow up this patch with some\nrelated diagnostics.\n\n\t* decl2.c (min_vis_expr_r): Handle LAMBDA_EXPR.\n\t* mangle.c (write_expression): Handle LAMBDA_EXPR.\n\t* parser.c (cp_parser_lambda_expression): Allow lambdas in\n\tunevaluated context.  Start the tentative firewall sooner.\n\t(cp_parser_lambda_body): Use cp_evaluated.\n\t* pt.c (iterative_hash_template_arg): Handle LAMBDA_EXPR.\n\t(tsubst_function_decl): Substitute a lambda even if it isn't\n\tdependent.\n\t(tsubst_lambda_expr): Use cp_evaluated.  Always complain.\n\t(tsubst_copy_and_build) [LAMBDA_EXPR]: Do nothing if tf_partial.\n\t* semantics.c (begin_class_definition): Allow in template parm list.\n\t* tree.c (strip_typedefs_expr): Pass through LAMBDA_EXPR.\n\t(cp_tree_equal): Handle LAMBDA_EXPR.\n\nFrom-SVN: r266056", "tree": {"sha": "ccbb8ff54004ee0dd964a8e4e5621030bf011aa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccbb8ff54004ee0dd964a8e4e5621030bf011aa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d119905abdf28f56486be0ca01a42f8efcea1a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d119905abdf28f56486be0ca01a42f8efcea1a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d119905abdf28f56486be0ca01a42f8efcea1a2"}], "stats": {"total": 299, "additions": 262, "deletions": 37}, "files": [{"sha": "7e80c4e69ac1480ea4429e84fe3f0ce24dfc5f01", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -1,5 +1,20 @@\n 2018-11-12  Jason Merrill  <jason@redhat.com>\n \n+\tImplement P0315R4, Lambdas in unevaluated contexts.\n+\t* decl2.c (min_vis_expr_r): Handle LAMBDA_EXPR.\n+\t* mangle.c (write_expression): Handle LAMBDA_EXPR.\n+\t* parser.c (cp_parser_lambda_expression): Allow lambdas in\n+\tunevaluated context.  Start the tentative firewall sooner.\n+\t(cp_parser_lambda_body): Use cp_evaluated.\n+\t* pt.c (iterative_hash_template_arg): Handle LAMBDA_EXPR.\n+\t(tsubst_function_decl): Substitute a lambda even if it isn't\n+\tdependent.\n+\t(tsubst_lambda_expr): Use cp_evaluated.  Always complain.\n+\t(tsubst_copy_and_build) [LAMBDA_EXPR]: Do nothing if tf_partial.\n+\t* semantics.c (begin_class_definition): Allow in template parm list.\n+\t* tree.c (strip_typedefs_expr): Pass through LAMBDA_EXPR.\n+\t(cp_tree_equal): Handle LAMBDA_EXPR.\n+\n \t* pt.c (fn_type_unification): If we have a full set of explicit\n \targuments, go straight to substitution.\n "}, {"sha": "04537417129c90adca706da8253029de9f24f956", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -2288,6 +2288,7 @@ min_vis_expr_r (tree *tp, int */*walk_subtrees*/, void *data)\n     case DYNAMIC_CAST_EXPR:\n     case NEW_EXPR:\n     case CONSTRUCTOR:\n+    case LAMBDA_EXPR:\n       tpvis = type_visibility (TREE_TYPE (*tp));\n       break;\n "}, {"sha": "64415894bc57c3f6fb80f46365d5a12f858dc74e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -3139,6 +3139,16 @@ write_expression (tree expr)\n \twrite_expression (val);\n       write_char ('E');\n     }\n+  else if (code == LAMBDA_EXPR)\n+    {\n+      /* [temp.over.link] Two lambda-expressions are never considered\n+\t equivalent.\n+\n+\t So just use the closure type mangling.  */\n+      write_string (\"tl\");\n+      write_type (LAMBDA_EXPR_CLOSURE (expr));\n+      write_char ('E');\n+    }\n   else if (dependent_name (expr))\n     {\n       write_unqualified_id (dependent_name (expr));"}, {"sha": "db0f0338179ea1d20a574be11bead07f46650f13", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -10175,12 +10175,15 @@ cp_parser_lambda_expression (cp_parser* parser)\n \n   LAMBDA_EXPR_LOCATION (lambda_expr) = token->location;\n \n-  if (cp_unevaluated_operand)\n+  if (cxx_dialect >= cxx2a)\n+    /* C++20 allows lambdas in unevaluated context.  */;\n+  else if (cp_unevaluated_operand)\n     {\n       if (!token->error_reported)\n \t{\n \t  error_at (LAMBDA_EXPR_LOCATION (lambda_expr),\n-\t\t    \"lambda-expression in unevaluated context\");\n+\t\t    \"lambda-expression in unevaluated context\"\n+\t\t    \" only available with -std=c++2a or -std=gnu++2a\");\n \t  token->error_reported = true;\n \t}\n       ok = false;\n@@ -10189,7 +10192,8 @@ cp_parser_lambda_expression (cp_parser* parser)\n     {\n       if (!token->error_reported)\n \t{\n-\t  error_at (token->location, \"lambda-expression in template-argument\");\n+\t  error_at (token->location, \"lambda-expression in template-argument\"\n+\t\t    \" only available with -std=c++2a or -std=gnu++2a\");\n \t  token->error_reported = true;\n \t}\n       ok = false;\n@@ -10200,6 +10204,8 @@ cp_parser_lambda_expression (cp_parser* parser)\n   push_deferring_access_checks (dk_no_deferred);\n \n   cp_parser_lambda_introducer (parser, lambda_expr);\n+  if (cp_parser_error_occurred (parser))\n+    return error_mark_node;\n \n   type = begin_lambda_type (lambda_expr);\n   if (type == error_mark_node)\n@@ -10238,16 +10244,16 @@ cp_parser_lambda_expression (cp_parser* parser)\n     /* By virtue of defining a local class, a lambda expression has access to\n        the private variables of enclosing classes.  */\n \n+    if (cp_parser_start_tentative_firewall (parser))\n+      start = token;\n+\n     ok &= cp_parser_lambda_declarator_opt (parser, lambda_expr);\n \n     if (ok && cp_parser_error_occurred (parser))\n       ok = false;\n \n     if (ok)\n       {\n-\tif (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)\n-\t    && cp_parser_start_tentative_firewall (parser))\n-\t  start = token;\n \tcp_parser_lambda_body (parser, lambda_expr);\n       }\n     else if (cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n@@ -10736,6 +10742,10 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n   bool local_variables_forbidden_p = parser->local_variables_forbidden_p;\n   bool in_function_body = parser->in_function_body;\n \n+  /* The body of a lambda-expression is not a subexpression of the enclosing\n+     expression.  */\n+  cp_evaluated ev;\n+\n   if (nested)\n     push_function_context ();\n   else"}, {"sha": "b58ec06a09e5365c030eeedb94cdf03522fa65a0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -1814,10 +1814,11 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n       return iterative_hash_template_arg (TREE_OPERAND (arg, 2), val);\n \n     case LAMBDA_EXPR:\n-      /* A lambda can't appear in a template arg, but don't crash on\n-\t erroneous input.  */\n-      gcc_assert (seen_error ());\n-      return val;\n+      /* [temp.over.link] Two lambda-expressions are never considered\n+\t equivalent.\n+\n+         So just hash the closure type.  */\n+      return iterative_hash_template_arg (TREE_TYPE (arg), val);\n \n     case CAST_EXPR:\n     case IMPLICIT_CONV_EXPR:\n@@ -12842,7 +12843,8 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n   if (TREE_CODE (DECL_TI_TEMPLATE (t)) == TEMPLATE_DECL)\n     {\n       /* If T is not dependent, just return it.  */\n-      if (!uses_template_parms (DECL_TI_ARGS (t)))\n+      if (!uses_template_parms (DECL_TI_ARGS (t))\n+\t  && !LAMBDA_FUNCTION_P (t))\n \treturn t;\n \n       /* Calculate the most general template of which R is a\n@@ -17957,6 +17959,10 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       /* Let finish_function set this.  */\n       DECL_DECLARED_CONSTEXPR_P (fn) = false;\n \n+      /* The body of a lambda-expression is not a subexpression of the\n+\t enclosing expression.  */\n+      cp_evaluated ev;\n+\n       bool nested = cfun;\n       if (nested)\n \tpush_function_context ();\n@@ -17992,6 +17998,11 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  current_function_infinite_loop = ol->infinite_loop;\n \t}\n \n+      /* [temp.deduct] A lambda-expression appearing in a function type or a\n+\t template parameter is not considered part of the immediate context for\n+\t the purposes of template argument deduction. */\n+      complain = tf_warning_or_error;\n+\n       tsubst_expr (DECL_SAVED_TREE (oldfn), args, complain, r,\n \t\t   /*constexpr*/false);\n \n@@ -19285,6 +19296,13 @@ tsubst_copy_and_build (tree t,\n \n     case LAMBDA_EXPR:\n       {\n+\tif (complain & tf_partial)\n+\t  {\n+\t    /* We don't have a full set of template arguments yet; don't touch\n+\t       the lambda at all.  */\n+\t    gcc_assert (processing_template_decl);\n+\t    return t;\n+\t  }\n \ttree r = tsubst_lambda_expr (t, args, complain, in_decl);\n \n \tRETURN (build_lambda_object (r));"}, {"sha": "20fd9c47f1f46ec57f4999e049564749aea05f99", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -2988,12 +2988,6 @@ begin_class_definition (tree t)\n   if (error_operand_p (t) || error_operand_p (TYPE_MAIN_DECL (t)))\n     return error_mark_node;\n \n-  if (processing_template_parmlist)\n-    {\n-      error (\"definition of %q#T inside template parameter list\", t);\n-      return error_mark_node;\n-    }\n-\n   /* According to the C++ ABI, decimal classes defined in ISO/IEC TR 24733\n      are passed the same as decimal scalar types.  */\n   if (TREE_CODE (t) == RECORD_TYPE"}, {"sha": "02a9856acbf114ca9804f07a451d239ea7b37508", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -1834,8 +1834,7 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n       }\n \n     case LAMBDA_EXPR:\n-      error (\"lambda-expression in a constant expression\");\n-      return error_mark_node;\n+      return t;\n \n     case STATEMENT_LIST:\n       error (\"statement-expression in a constant expression\");\n@@ -2777,7 +2776,18 @@ no_linkage_check (tree t, bool relaxed_p)\n {\n   tree r;\n \n-  /* There's no point in checking linkage on template functions; we\n+  /* Lambda types that don't have mangling scope have no linkage.  We\n+     check CLASSTYPE_LAMBDA_EXPR for error_mark_node because\n+     when we get here from pushtag none of the lambda information is\n+     set up yet, so we want to assume that the lambda has linkage and\n+     fix it up later if not.  We need to check this even in templates so\n+     that we properly handle a lambda-expression in the signature.  */\n+  if (LAMBDA_TYPE_P (t)\n+      && CLASSTYPE_LAMBDA_EXPR (t) != error_mark_node\n+      && LAMBDA_TYPE_EXTRA_SCOPE (t) == NULL_TREE)\n+    return t;\n+\n+  /* Otherwise there's no point in checking linkage on template functions; we\n      can't know their complete types.  */\n   if (processing_template_decl)\n     return NULL_TREE;\n@@ -2787,15 +2797,6 @@ no_linkage_check (tree t, bool relaxed_p)\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \tgoto ptrmem;\n-      /* Lambda types that don't have mangling scope have no linkage.  We\n-\t check CLASSTYPE_LAMBDA_EXPR for error_mark_node because\n-\t when we get here from pushtag none of the lambda information is\n-\t set up yet, so we want to assume that the lambda has linkage and\n-\t fix it up later if not.  */\n-      if (CLASSTYPE_LAMBDA_EXPR (t)\n-\t  && CLASSTYPE_LAMBDA_EXPR (t) != error_mark_node\n-\t  && LAMBDA_TYPE_EXTRA_SCOPE (t) == NULL_TREE)\n-\treturn t;\n       /* Fall through.  */\n     case UNION_TYPE:\n       if (!CLASS_TYPE_P (t))\n@@ -3849,6 +3850,10 @@ cp_tree_equal (tree t1, tree t2)\n \t\t\t\t  DECL_NAME (t2)));\n       return false;\n \n+    case LAMBDA_EXPR:\n+      /* Two lambda-expressions are never considered equivalent.  */\n+      return false;\n+\n     default:\n       break;\n     }"}, {"sha": "67b669f78d7912fa7bb3a68c25a6cefc4c9ed308", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ice6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ice6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ice6.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -1,4 +1,4 @@\n // PR c++/51464\n // { dg-do compile { target c++11 } }\n \n-template<int = sizeof([])> struct A {}; // { dg-error \"lambda\" } \n+template<int = sizeof([])> struct A {}; // { dg-error \"\" } "}, {"sha": "5928894e4b9ccd94019f9ee5fb86af810c13062e", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -8,7 +8,7 @@ struct AddRvalueReferenceImpl { typedef T type; };\n \n template <typename T>\n struct AddRvalueReferenceImpl<T, typename BoolSink<false &&\n-      [] {\t\t\t// { dg-error \"lambda\" }\n+      [] {\t\t\t// { dg-error \"lambda\" \"\" { target c++17_down } }\n          extern T &&tref;\n       }>::type> {\n    typedef T &&type;\n@@ -19,17 +19,16 @@ struct AddRvalueReference : AddRvalueReferenceImpl<T, void> { };\n \n namespace ImplHelpers {\n    template <typename T>\n-   typename AddRvalueReference<T>::type create(void) { }\n+   typename AddRvalueReference<T>::type create(void);\n }\n \n template <typename T, typename U, typename ...Args>\n struct IsConstructibleImpl { enum { value = 0 }; };\n \n template <typename T, typename ...Args>\n struct IsConstructibleImpl<T, typename BoolSink<false &&\n-      [] {\t\t\t// { dg-error \"lambda\" }\n-         T t( ::ImplHelpers::create<Args>() ...);\n-      }>::type, Args ...> {\n+      [] { T t( ::ImplHelpers::create<Args>() ...); } // { dg-error \"\" }\n+  >::type, Args ...> {\n    enum { value = 1 };\n };\n "}, {"sha": "1b1f03e4773cf2b6fb5b7b37be45c0338bb16978", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-uneval.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-uneval.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-uneval.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-uneval.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -3,7 +3,7 @@\n \n template <class T>\n struct A { };\n-A<decltype([]{ return 1; }())> a; // { dg-error \"lambda.*unevaluated context\" }\n+A<decltype([]{ return 1; }())> a; // { dg-error \"lambda.*unevaluated context\" \"\" { target c++17_down } }\n \n // { dg-prune-output \"template argument\" }\n // { dg-prune-output \"invalid type\" }"}, {"sha": "f887a7d9e44e28b4bd145ff870ebd428c36a545d", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-uneval2.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-uneval2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-uneval2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-uneval2.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -3,5 +3,8 @@\n \n struct A\n {\n-  decltype( [](){ return this; }() ) x; // { dg-error \"unevaluated\" }\n+  decltype( [](){ return this; }() ) x; // { dg-error \"unevaluated\" \"\" { target c++17_down } }\n+  // { dg-error \"not captured\" \"\" { target c++2a } .-1 }\n };\n+\n+// { dg-prune-output \"declared void\" }"}, {"sha": "8a1703304ab82a1612aef075759c1114828f45f7", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval1.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++2a } }\n+\n+typedef decltype([]{}) C; // the closure type has no name for linkage purposes\n+\n+// { dg-final { scan-assembler-not \"globl\\[ \\t]*_Z1f\" } }\n+// { dg-final { scan-assembler-not \"_Z1f1C\" } }\n+void f(C) {}\n+\n+int main()\n+{\n+  C c;\n+  c();\n+  f(c);\n+}\n+\n+"}, {"sha": "f29a59e26fdbf5c9157614e3136ac9cf8b7b3588", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval2.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval2.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do compile { target c++2a } }\n+\n+// ill-formed, no diagnostic required: the two expressions are\n+// functionally equivalent but not equivalent\n+template <int N> void foo(const char (&s)[([]{}, N)]);\n+template <int N> void foo(const char (&s)[([]{}, N)]);\n+\n+// two different declarations because the non-dependent portions are not\n+// considered equivalent\n+template <class T> void spam(decltype([]{}) (*s)[sizeof(T)]);\n+template <class T> void spam(decltype([]{}) (*s)[sizeof(T)]);\n+\n+template <class T>\n+using A = decltype([] { });\n+// A<int> and A<char> refer to different closure types\n+\n+template <class T>\n+auto f(T) -> decltype([]() { T::invalid; } ()); // { dg-error \"invalid\" }\n+void f(...);\n+\n+template <class T, unsigned = sizeof([]() { T::invalid; })> // { dg-error \"invalid\" }\n+void g(T);\n+void g(...);\n+\n+template <class T>\n+auto h(T) -> decltype([x = T::invalid]() { });\n+void h(...);\n+\n+template <class T>\n+auto i(T) -> decltype([]() -> typename T::invalid { });\n+void i(...);\n+\n+template <class T>\n+auto j(T t) -> decltype([](auto x) -> decltype(x.invalid) { } (t));\n+void j(...);\n+\n+template <class,class> struct different {};\n+template <class T> struct different<T,T> { typename T::invalid t; };\n+\n+template <class,class> struct same;\n+template <class T> struct same<T,T> {};\n+\n+int main()\n+{\n+  foo<1>(\"\");\t // { dg-error \"ambiguous\" }\n+  spam<char>(nullptr);\t\t// { dg-error \"ambiguous\" }\n+  different<A<int>,A<char>>();\n+  same<A<int>,A<int>>();\n+  f(0); // error: invalid expression not part of the immediate context\n+  g(0); // error: invalid expression not part of the immediate context\n+  h(0); // error: invalid expression not part of the immediate context\n+  i(0); // error: invalid expression not part of the immediate context\n+  j(0); // deduction fails on #1, calls #2\n+}"}, {"sha": "3c9b1e1cd4523c0613a8f3828e140253ab471bfc", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval3.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <int N> void foo(const char (*s)[([]{}, N)]) {}\n+template <class T> void spam(decltype([]{}) (*s)[sizeof(T)]) {}\n+\n+int main()\n+{\n+  foo<1>(nullptr);\n+  spam<char>(nullptr);\n+}\n+\n+// { dg-final { scan-assembler-not \"weak.*_Z\" } }"}, {"sha": "e75a1270c72a21b3b628ef744e55875967f33c12", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval4.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval4.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do link { target c++2a } }\n+\n+template <class T> T f(T t) { return t; }\n+using L = decltype([]{ return f(42); });\n+int main()\n+{\n+  return L()();\n+}"}, {"sha": "7fb05c3ce9c77418587e57ede2b3a4ea68306670", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval5.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval5.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile { target c++2a } }\n+\n+using L = decltype([]{ });\n+void f(L) { }\n+// { dg-final { scan-assembler-not \"globl.*_Z1f\" } }"}, {"sha": "0396f9ff10d48a9a4adc650d0f23d91f222b5cf9", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval6.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval6.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++2a } }\n+\n+static decltype([] { }) f();\n+static decltype([] { }) f(); // { dg-error \"ambiguating\" }\n+\n+static decltype([] { }) g();\n+static decltype(g()) g(); // okay\n+\n+static void h(decltype([] { }) *) { }\n+static void h(decltype([] { }) *) { }\n+void x1() { h(nullptr); } // { dg-error \"ambiguous\" }\n+\n+using A = decltype([] { });\n+static void i(A *);\n+static void i(A *) { }\n+void x2() { i(nullptr); } // okay\n+\n+template <typename T>\n+using B = decltype([] { });\n+static void j(B<char16_t> *) { }\n+static void j(B<char32_t> *) { }\n+void x3() { j(nullptr); } // { dg-error \"ambiguous\" }\n+\n+template <int N> static void k(decltype([]{ return 0; }()));\n+template <int N> static void k(decltype([]{ return 0; }())); // okay\n+template <int N> static void k(int); // okay"}, {"sha": "41028824ce88295c5118733b56c59ad94a76514c", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval7.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval7.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <int N>\n+struct A { };\n+\n+template <int N>\n+void g(A<[]{return N;}()>) {}\n+\n+int main()\n+{\n+  g<1>({});\n+}"}, {"sha": "3692154f9becda7b5f966b8365bb26303ea6150a", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval8.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval8.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <auto N>\n+struct A {\n+  static constexpr auto n = N;\n+};\n+\n+template <auto N>\n+constexpr auto g(A<[]{return N;}> a) {\n+  return a.n();\n+}\n+\n+static_assert(g<42>({}) == 42);"}, {"sha": "e32d447819edbeadd09c71862ca408ca1f6d03f4", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval9.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.C?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do run { target c++2a } }\n+// { dg-additional-sources \"lambda-uneval9.cc\" }\n+\n+#include \"lambda-uneval9.h\"\n+int foo() { return f(); }\n+extern int bar();\n+\n+int main()\n+{\n+  if (foo() != 1) __builtin_abort();\n+  if (bar() != 2) __builtin_abort();\n+}"}, {"sha": "0ff3b12689515c126677b85bf870e5daa87d447e", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval9.cc", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.cc?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,3 @@\n+#include \"lambda-uneval9.h\"\n+\n+int bar() { return f(); }"}, {"sha": "0979748fd11add0791826ded5289a3c92f94e99a", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval9.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1e0d63fe0ceabbd04384070f3b59f8bf50de09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval9.h?ref=0c1e0d63fe0ceabbd04384070f3b59f8bf50de09", "patch": "@@ -0,0 +1,9 @@\n+// a.h:\n+template <typename T>\n+int counter() {\n+  static int cnt = 0;\n+  return ++cnt;\n+}\n+inline int f() {\n+  return counter<decltype([] {})>();\n+}"}]}