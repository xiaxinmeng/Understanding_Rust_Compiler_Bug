{"sha": "1260d70fb61e50255cf7f185efff31f568a7049c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI2MGQ3MGZiNjFlNTAyNTVjZjdmMTg1ZWZmZjMxZjU2OGE3MDQ5Yw==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2003-08-05T20:54:43Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2003-08-05T20:54:43Z"}, "message": "acinclude.m4 (GLIBCXX_ENABLE_SJLJ_EXCEPTIONS): Put down the crack pipe...\n\n2003-08-05  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* acinclude.m4 (GLIBCXX_ENABLE_SJLJ_EXCEPTIONS):  Put down the crack\n\tpipe, open the window to let out the fumes, redo the option-handling\n\tlogic to properly execute the detection test.\n\t* aclocal.m4, configure:  Regenerate.\n\nFrom-SVN: r70186", "tree": {"sha": "8f028f868a1e26f6b8c5f35ad4a2b5e60889c526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f028f868a1e26f6b8c5f35ad4a2b5e60889c526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1260d70fb61e50255cf7f185efff31f568a7049c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1260d70fb61e50255cf7f185efff31f568a7049c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1260d70fb61e50255cf7f185efff31f568a7049c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1260d70fb61e50255cf7f185efff31f568a7049c/comments", "author": null, "committer": null, "parents": [{"sha": "0196f4e0a514180bb0813f7a28f73beac5e47f13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0196f4e0a514180bb0813f7a28f73beac5e47f13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0196f4e0a514180bb0813f7a28f73beac5e47f13"}], "stats": {"total": 214, "additions": 142, "deletions": 72}, "files": [{"sha": "1effa8e7e8ab61eb0ed74018f84a3b3f48c15417", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1260d70fb61e50255cf7f185efff31f568a7049c", "patch": "@@ -1,3 +1,10 @@\n+2003-08-05  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* acinclude.m4 (GLIBCXX_ENABLE_SJLJ_EXCEPTIONS):  Put down the crack\n+\tpipe, open the window to let out the fumes, redo the option-handling\n+\tlogic to properly execute the detection test.\n+\t* aclocal.m4, configure:  Regenerate.\n+\n 2003-08-04  Phil Edwards  <pme@gcc.gnu.org>\n \n \tConvert to new autotools."}, {"sha": "f6f60ea67c777ed286be6bbd9c652626fdb31da3", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=1260d70fb61e50255cf7f185efff31f568a7049c", "patch": "@@ -1360,6 +1360,7 @@ dnl target may or may not support call frame exceptions.\n dnl\n dnl --enable-sjlj-exceptions forces the use of builtin setjmp.\n dnl --disable-sjlj-exceptions forces the use of call frame unwinding.\n+dnl Neither one forces an attempt at detection.\n dnl\n dnl Defines:\n dnl  _GLIBCXX_SJLJ_EXCEPTIONS if the compiler is configured for it\n@@ -1368,17 +1369,17 @@ AC_DEFUN(GLIBCXX_ENABLE_SJLJ_EXCEPTIONS, [\n   AC_MSG_CHECKING([for exception model to use])\n   AC_LANG_SAVE\n   AC_LANG_CPLUSPLUS\n-  GLIBCXX_ENABLE(sjlj-exceptions,no,,\n+  GLIBCXX_ENABLE(sjlj-exceptions,auto,,\n     [force use of builtin_setjmp for exceptions],\n-    [:],\n-    [# Botheration.  Now we've got to detect the exception model.\n-     # Link tests against libgcc.a are problematic since -- at least\n-     # as of this writing -- we've not been given proper -L bits for\n-     # single-tree newlib and libgloss.\n-     #\n-     # This is what AC_TRY_COMPILE would do if it didn't delete the\n-     # conftest files before we got a change to grep them first.\n-     cat > conftest.$ac_ext << EOF\n+    [permit yes|no|auto])\n+\n+  if test $enable_sjlj_exceptions = auto; then\n+    # Botheration.  Now we've got to detect the exception model.  Link tests\n+    # against libgcc.a are problematic since we've not been given proper -L\n+    # bits for single-tree newlib and libgloss.\n+    #\n+    # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n+    cat > conftest.$ac_ext << EOF\n [#]line __oline__ \"configure\"\n struct S { ~S(); };\n void bar();\n@@ -1388,27 +1389,34 @@ void foo()\n   bar();\n }\n EOF\n-     old_CXXFLAGS=\"$CXXFLAGS\"\n-     CXXFLAGS=-S\n-     if AC_TRY_EVAL(ac_compile); then\n-       if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n-         enable_sjlj_exceptions=yes\n-       elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n-         enable_sjlj_exceptions=no\n-       fi\n-     fi\n-     CXXFLAGS=\"$old_CXXFLAGS\"\n-     rm -f conftest*\n-   ])\n- if test $enable_sjlj_exceptions = yes; then\n-   AC_DEFINE(_GLIBCXX_SJLJ_EXCEPTIONS, 1,\n-     [Define if the compiler is configured for setjmp/longjmp exceptions.])\n-   ac_exception_model_name=sjlj\n- elif test x$enable_sjlj_exceptions = xno; then\n-   ac_exception_model_name=\"call frame\"\n- else\n-   AC_MSG_ERROR([unable to detect exception model])\n- fi\n+    old_CXXFLAGS=\"$CXXFLAGS\"\n+    CXXFLAGS=-S\n+    if AC_TRY_EVAL(ac_compile); then\n+      if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=yes\n+      elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=no\n+      fi\n+    fi\n+    CXXFLAGS=\"$old_CXXFLAGS\"\n+    rm -f conftest*\n+  fi\n+\n+  # This is a tad weird, for hysterical raisins.  We have to map enable/disable \n+  # to two different models.\n+  case $enable_sjlj_exceptions in\n+    yes)\n+      AC_DEFINE(_GLIBCXX_SJLJ_EXCEPTIONS, 1,\n+        [Define if the compiler is configured for setjmp/longjmp exceptions.])\n+      ac_exception_model_name=sjlj\n+      ;;\n+    no)\n+      ac_exception_model_name=\"call frame\"\n+      ;;\n+    *)\n+      AC_MSG_ERROR([unable to detect exception model])\n+      ;;\n+  esac\n  AC_LANG_RESTORE\n  AC_MSG_RESULT($ac_exception_model_name)\n ])"}, {"sha": "27aed6a1195ec9755713bcd6d49f754b8a24b111", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=1260d70fb61e50255cf7f185efff31f568a7049c", "patch": "@@ -1373,6 +1373,7 @@ dnl target may or may not support call frame exceptions.\n dnl\n dnl --enable-sjlj-exceptions forces the use of builtin setjmp.\n dnl --disable-sjlj-exceptions forces the use of call frame unwinding.\n+dnl Neither one forces an attempt at detection.\n dnl\n dnl Defines:\n dnl  _GLIBCXX_SJLJ_EXCEPTIONS if the compiler is configured for it\n@@ -1381,17 +1382,17 @@ AC_DEFUN(GLIBCXX_ENABLE_SJLJ_EXCEPTIONS, [\n   AC_MSG_CHECKING([for exception model to use])\n   AC_LANG_SAVE\n   AC_LANG_CPLUSPLUS\n-  GLIBCXX_ENABLE(sjlj-exceptions,no,,\n+  GLIBCXX_ENABLE(sjlj-exceptions,auto,,\n     [force use of builtin_setjmp for exceptions],\n-    [:],\n-    [# Botheration.  Now we've got to detect the exception model.\n-     # Link tests against libgcc.a are problematic since -- at least\n-     # as of this writing -- we've not been given proper -L bits for\n-     # single-tree newlib and libgloss.\n-     #\n-     # This is what AC_TRY_COMPILE would do if it didn't delete the\n-     # conftest files before we got a change to grep them first.\n-     cat > conftest.$ac_ext << EOF\n+    [permit yes|no|auto])\n+\n+  if test $enable_sjlj_exceptions = auto; then\n+    # Botheration.  Now we've got to detect the exception model.  Link tests\n+    # against libgcc.a are problematic since we've not been given proper -L\n+    # bits for single-tree newlib and libgloss.\n+    #\n+    # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n+    cat > conftest.$ac_ext << EOF\n [#]line __oline__ \"configure\"\n struct S { ~S(); };\n void bar();\n@@ -1401,27 +1402,34 @@ void foo()\n   bar();\n }\n EOF\n-     old_CXXFLAGS=\"$CXXFLAGS\"\n-     CXXFLAGS=-S\n-     if AC_TRY_EVAL(ac_compile); then\n-       if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n-         enable_sjlj_exceptions=yes\n-       elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n-         enable_sjlj_exceptions=no\n-       fi\n-     fi\n-     CXXFLAGS=\"$old_CXXFLAGS\"\n-     rm -f conftest*\n-   ])\n- if test $enable_sjlj_exceptions = yes; then\n-   AC_DEFINE(_GLIBCXX_SJLJ_EXCEPTIONS, 1,\n-     [Define if the compiler is configured for setjmp/longjmp exceptions.])\n-   ac_exception_model_name=sjlj\n- elif test x$enable_sjlj_exceptions = xno; then\n-   ac_exception_model_name=\"call frame\"\n- else\n-   AC_MSG_ERROR([unable to detect exception model])\n- fi\n+    old_CXXFLAGS=\"$CXXFLAGS\"\n+    CXXFLAGS=-S\n+    if AC_TRY_EVAL(ac_compile); then\n+      if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=yes\n+      elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=no\n+      fi\n+    fi\n+    CXXFLAGS=\"$old_CXXFLAGS\"\n+    rm -f conftest*\n+  fi\n+\n+  # This is a tad weird, for hysterical raisins.  We have to map enable/disable \n+  # to two different models.\n+  case $enable_sjlj_exceptions in\n+    yes)\n+      AC_DEFINE(_GLIBCXX_SJLJ_EXCEPTIONS, 1,\n+        [Define if the compiler is configured for setjmp/longjmp exceptions.])\n+      ac_exception_model_name=sjlj\n+      ;;\n+    no)\n+      ac_exception_model_name=\"call frame\"\n+      ;;\n+    *)\n+      AC_MSG_ERROR([unable to detect exception model])\n+      ;;\n+  esac\n  AC_LANG_RESTORE\n  AC_MSG_RESULT($ac_exception_model_name)\n ])"}, {"sha": "4691523decae9344c7a52258bb80d20d8949c814", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 57, "deletions": 10, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1260d70fb61e50255cf7f185efff31f568a7049c/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=1260d70fb61e50255cf7f185efff31f568a7049c", "patch": "@@ -864,7 +864,7 @@ Optional Features:\n   --disable-libtool-lock  avoid locking (might break parallel builds)\n   --enable-sjlj-exceptions\n                           force use of builtin_setjmp for exceptions\n-                          [default=no]\n+                          [default=auto]\n   --enable-libunwind-exceptions\n                           force use of libunwind for exceptions\n                           [default=no]\n@@ -4837,25 +4837,72 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n    # Check whether --enable-sjlj-exceptions or --disable-sjlj-exceptions was given.\n if test \"${enable_sjlj_exceptions+set}\" = set; then\n   enableval=\"$enable_sjlj_exceptions\"\n-  :\n+\n+      case \"$enableval\" in\n+       yes|no|auto) ;;\n+       *) { { echo \"$as_me:$LINENO: error: Unknown argument to enable/disable sjlj-exceptions\" >&5\n+echo \"$as_me: error: Unknown argument to enable/disable sjlj-exceptions\" >&2;}\n+   { (exit 1); exit 1; }; } ;;\n+                          esac\n+\n else\n-  enable_sjlj_exceptions=no\n+  enable_sjlj_exceptions=auto\n fi;\n \n- if test $enable_sjlj_exceptions = yes; then\n+\n+  if test $enable_sjlj_exceptions = auto; then\n+    # Botheration.  Now we've got to detect the exception model.  Link tests\n+    # against libgcc.a are problematic since we've not been given proper -L\n+    # bits for single-tree newlib and libgloss.\n+    #\n+    # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n+    cat > conftest.$ac_ext << EOF\n+#line 4860 \"configure\"\n+struct S { ~S(); };\n+void bar();\n+void foo()\n+{\n+  S s;\n+  bar();\n+}\n+EOF\n+    old_CXXFLAGS=\"$CXXFLAGS\"\n+    CXXFLAGS=-S\n+    if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; then\n+      if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=yes\n+      elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=no\n+      fi\n+    fi\n+    CXXFLAGS=\"$old_CXXFLAGS\"\n+    rm -f conftest*\n+  fi\n+\n+  # This is a tad weird, for hysterical raisins.  We have to map enable/disable\n+  # to two different models.\n+  case $enable_sjlj_exceptions in\n+    yes)\n \n cat >>confdefs.h <<\\_ACEOF\n #define _GLIBCXX_SJLJ_EXCEPTIONS 1\n _ACEOF\n \n-   ac_exception_model_name=sjlj\n- elif test x$enable_sjlj_exceptions = xno; then\n-   ac_exception_model_name=\"call frame\"\n- else\n-   { { echo \"$as_me:$LINENO: error: unable to detect exception model\" >&5\n+      ac_exception_model_name=sjlj\n+      ;;\n+    no)\n+      ac_exception_model_name=\"call frame\"\n+      ;;\n+    *)\n+      { { echo \"$as_me:$LINENO: error: unable to detect exception model\" >&5\n echo \"$as_me: error: unable to detect exception model\" >&2;}\n    { (exit 1); exit 1; }; }\n- fi\n+      ;;\n+  esac\n  ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'"}]}