{"sha": "422e02cfdf696450410b69d0c6491102ebc2970e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIyZTAyY2ZkZjY5NjQ1MDQxMGI2OWQwYzY0OTExMDJlYmMyOTcwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T14:08:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T14:08:02Z"}, "message": "[multiple changes]\n\n2014-07-29  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch3.adb (Constrain_Corresponding_Record): For the case\n\tof the subtype created for a record component, do not mark\n\tthe subtype as frozen. For one thing, this is anomalous (in\n\tparticular, the base type might not itself be frozen yet);\n\tfurthermore, proper freezing of the subtype must happen in any\n\tcase. So, we just mark the subtype as requiring delayed freezing\n\t(and we'll actually freeze it when generating the init_proc of\n\tthe enclosing record).\n\tAlso change the name of the constrained record subtype (append a\n\t'C' so that it is clearly different from the unconstrained record\n\ttype, \"related_idV\") to make debugging easier.\n\t(Process_Full_View): When creating a full subtype for a pending\n\tprivate subtype, re-establish the scope of the private subtype\n\tso that we get proper visibility on outer discriminants.\n\t* exp_ch3.adb (Build_Init_Statements): Freeze any component\n\tsubtype that is not frozen yet.\n\n2014-07-29  Vincent Celier  <celier@adacore.com>\n\n\t* prj-proc.adb (Recursive_Process): Always initialize the\n\tenvironment when the project is an aggregate project, even when\n\tit is not the root tree.\n\nFrom-SVN: r213197", "tree": {"sha": "ecd41f2d3e1efce20e9a370dd5399eae35d9ae03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd41f2d3e1efce20e9a370dd5399eae35d9ae03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/422e02cfdf696450410b69d0c6491102ebc2970e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422e02cfdf696450410b69d0c6491102ebc2970e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422e02cfdf696450410b69d0c6491102ebc2970e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422e02cfdf696450410b69d0c6491102ebc2970e/comments", "author": null, "committer": null, "parents": [{"sha": "0677a1c750acae35d74a1d45d95c42d883cd58a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0677a1c750acae35d74a1d45d95c42d883cd58a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0677a1c750acae35d74a1d45d95c42d883cd58a6"}], "stats": {"total": 117, "additions": 74, "deletions": 43}, "files": [{"sha": "b79abfab635ec578f3d73ebf79b71f084f440fca", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=422e02cfdf696450410b69d0c6491102ebc2970e", "patch": "@@ -1,3 +1,27 @@\n+2014-07-29  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch3.adb (Constrain_Corresponding_Record): For the case\n+\tof the subtype created for a record component, do not mark\n+\tthe subtype as frozen. For one thing, this is anomalous (in\n+\tparticular, the base type might not itself be frozen yet);\n+\tfurthermore, proper freezing of the subtype must happen in any\n+\tcase. So, we just mark the subtype as requiring delayed freezing\n+\t(and we'll actually freeze it when generating the init_proc of\n+\tthe enclosing record).\n+\tAlso change the name of the constrained record subtype (append a\n+\t'C' so that it is clearly different from the unconstrained record\n+\ttype, \"related_idV\") to make debugging easier.\n+\t(Process_Full_View): When creating a full subtype for a pending\n+\tprivate subtype, re-establish the scope of the private subtype\n+\tso that we get proper visibility on outer discriminants.\n+\t* exp_ch3.adb (Build_Init_Statements): Freeze any component\n+\tsubtype that is not frozen yet.\n+\n+2014-07-29  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-proc.adb (Recursive_Process): Always initialize the\n+\tenvironment when the project is an aggregate project, even when\n+\tit is not the root tree.\n 2014-07-29  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch5.adb, exp_ch9.adb: Minor comment additions."}, {"sha": "b9c7c99c2943d26095a199edb9d52c994837f690", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=422e02cfdf696450410b69d0c6491102ebc2970e", "patch": "@@ -2818,6 +2818,14 @@ package body Exp_Ch3 is\n             --  Regular component cases\n \n             else\n+               --  In the context of the init proc, references to discriminants\n+               --  resolve to denote the discriminals: this is where we can\n+               --  freeze discriminant dependent component subtypes.\n+\n+               if not Is_Frozen (Typ) then\n+                  Append_List_To (Stmts, Freeze_Entity (Typ, N));\n+               end if;\n+\n                --  Explicit initialization\n \n                if Present (Expression (Decl)) then"}, {"sha": "653dbe1c72d941108730af7b72bbeeecd6ee3edf", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=422e02cfdf696450410b69d0c6491102ebc2970e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2898,7 +2898,7 @@ package body Prj.Proc is\n \n             Process_Imported_Projects (Imported, Limited_With => False);\n \n-            if Project.Qualifier = Aggregate and then In_Tree.Is_Root_Tree then\n+            if Project.Qualifier = Aggregate then\n                Initialize_And_Copy (Child_Env, Copy_From => Env);\n \n             elsif Project.Qualifier = Aggregate_Library then"}, {"sha": "84858793540fc802376983b639efef2e1c6cc130", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422e02cfdf696450410b69d0c6491102ebc2970e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=422e02cfdf696450410b69d0c6491102ebc2970e", "patch": "@@ -35,7 +35,6 @@ with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Disp; use Exp_Disp;\n with Exp_Dist; use Exp_Dist;\n-with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n@@ -413,15 +412,14 @@ package body Sem_Ch3 is\n    --    Def_Id is an in/out parameter).\n    --\n    --    Related_Nod gives the place where this type has to be inserted\n-   --    in the tree\n+   --    in the tree.\n    --\n    --  The last two arguments are used to create its external name if needed.\n \n    function Constrain_Corresponding_Record\n      (Prot_Subt   : Entity_Id;\n       Corr_Rec    : Entity_Id;\n-      Related_Nod : Node_Id;\n-      Related_Id  : Entity_Id) return Entity_Id;\n+      Related_Nod : Node_Id) return Entity_Id;\n    --  When constraining a protected type or task type with discriminants,\n    --  constrain the corresponding record with the same discriminant values.\n \n@@ -10926,8 +10924,7 @@ package body Sem_Ch3 is\n          then\n             Set_Corresponding_Record_Type (Full,\n               Constrain_Corresponding_Record\n-                (Full, Corresponding_Record_Type (Full_Base),\n-                  Related_Nod, Full_Base));\n+                (Full, Corresponding_Record_Type (Full_Base), Related_Nod));\n \n          else\n             Set_Corresponding_Record_Type (Full,\n@@ -11367,8 +11364,7 @@ package body Sem_Ch3 is\n               or else Is_Protected_Type (Desig_Type))\n         and then not Is_Constrained (Desig_Type)\n       then\n-         Constrain_Concurrent\n-           (Desig_Subtype, S, Related_Nod, Desig_Type, ' ');\n+         Constrain_Concurrent (Desig_Subtype, S, Related_Nod, Desig_Type, ' ');\n \n       else\n          Error_Msg_N (\"invalid constraint on access type\", S);\n@@ -11563,7 +11559,6 @@ package body Sem_Ch3 is\n    is\n       Loc         : constant Source_Ptr := Sloc (Constrained_Typ);\n       Compon_Type : constant Entity_Id := Etype (Comp);\n-      Array_Comp  : Node_Id;\n \n       function Build_Constrained_Array_Type\n         (Old_Type : Entity_Id) return Entity_Id;\n@@ -11961,22 +11956,7 @@ package body Sem_Ch3 is\n          return Compon_Type;\n \n       elsif Is_Array_Type (Compon_Type) then\n-         Array_Comp := Build_Constrained_Array_Type (Compon_Type);\n-\n-         --  If the component of the parent is packed, and the record type is\n-         --  already frozen, as is the case for an itype, the component type\n-         --  itself will not be frozen, and the packed array type for it must\n-         --  be constructed explicitly. Since the creation of packed types is\n-         --  an expansion activity, we only do this if expansion is active.\n-\n-         if Expander_Active\n-           and then Is_Packed (Compon_Type)\n-           and then Is_Frozen (Current_Scope)\n-         then\n-            Create_Packed_Array_Impl_Type (Array_Comp);\n-         end if;\n-\n-         return Array_Comp;\n+         return Build_Constrained_Array_Type (Compon_Type);\n \n       elsif Has_Discriminants (Compon_Type) then\n          return Build_Constrained_Discriminated_Type (Compon_Type);\n@@ -12027,8 +12007,7 @@ package body Sem_Ch3 is\n \n          Set_Depends_On_Private (Def_Id, Has_Private_Component (Def_Id));\n          Set_Corresponding_Record_Type (Def_Id,\n-           Constrain_Corresponding_Record\n-             (Def_Id, T_Val, Related_Nod, Related_Id));\n+           Constrain_Corresponding_Record (Def_Id, T_Val, Related_Nod));\n \n       else\n          --  If there is no associated record, expansion is disabled and this\n@@ -12050,11 +12029,10 @@ package body Sem_Ch3 is\n    function Constrain_Corresponding_Record\n      (Prot_Subt   : Entity_Id;\n       Corr_Rec    : Entity_Id;\n-      Related_Nod : Node_Id;\n-      Related_Id  : Entity_Id) return Entity_Id\n+      Related_Nod : Node_Id) return Entity_Id\n    is\n       T_Sub : constant Entity_Id :=\n-                Create_Itype (E_Record_Subtype, Related_Nod, Related_Id, 'V');\n+                Create_Itype (E_Record_Subtype, Related_Nod, Corr_Rec, 'C');\n \n    begin\n       Set_Etype             (T_Sub, Corr_Rec);\n@@ -12063,16 +12041,6 @@ package body Sem_Ch3 is\n       Set_First_Entity      (T_Sub, First_Entity (Corr_Rec));\n       Set_Last_Entity       (T_Sub, Last_Entity  (Corr_Rec));\n \n-      --  As elsewhere, we do not want to create a freeze node for this itype\n-      --  if it is created for a constrained component of an enclosing record\n-      --  because references to outer discriminants will appear out of scope.\n-\n-      if Ekind (Scope (Prot_Subt)) /= E_Record_Type then\n-         Conditional_Delay (T_Sub, Corr_Rec);\n-      else\n-         Set_Is_Frozen (T_Sub);\n-      end if;\n-\n       if Has_Discriminants (Prot_Subt) then -- False only if errors.\n          Set_Discriminant_Constraint\n            (T_Sub, Discriminant_Constraint (Prot_Subt));\n@@ -12083,6 +12051,19 @@ package body Sem_Ch3 is\n \n       Set_Depends_On_Private      (T_Sub, Has_Private_Component (T_Sub));\n \n+      if Ekind (Scope (Prot_Subt)) /= E_Record_Type then\n+         Conditional_Delay (T_Sub, Corr_Rec);\n+\n+      else\n+         --  This is a component subtype: it will be frozen in the context of\n+         --  the enclosing record's init_proc, so that discriminant references\n+         --  are resolved to discriminals. (Note: we used to skip freezing\n+         --  altogether in that case, which caused errors downstream for\n+         --  components of a bit packed array type).\n+\n+         Set_Has_Delayed_Freeze (T_Sub);\n+      end if;\n+\n       return T_Sub;\n    end Constrain_Corresponding_Record;\n \n@@ -18622,13 +18603,15 @@ package body Sem_Ch3 is\n \n       declare\n          Priv_Elmt : Elmt_Id;\n+         Priv_Scop : Entity_Id;\n          Priv      : Entity_Id;\n          Full      : Entity_Id;\n \n       begin\n          Priv_Elmt := First_Elmt (Private_Dependents (Priv_T));\n          while Present (Priv_Elmt) loop\n             Priv := Node (Priv_Elmt);\n+            Priv_Scop := Scope (Priv);\n \n             if Ekind_In (Priv, E_Private_Subtype,\n                                E_Limited_Private_Subtype,\n@@ -18642,10 +18625,26 @@ package body Sem_Ch3 is\n                --  Now we need to complete the private subtype, but since the\n                --  base type has already been swapped, we must also swap the\n                --  subtypes (and thus, reverse the arguments in the call to\n-               --  Complete_Private_Subtype).\n+               --  Complete_Private_Subtype). Also note that we may need to\n+               --  re-establish the scope of the private subtype.\n \n                Copy_And_Swap (Priv, Full);\n+\n+               if not In_Open_Scopes (Priv_Scop) then\n+                  Push_Scope (Priv_Scop);\n+\n+               else\n+                  --  Reset Priv_Scop to Empty to indicate no scope was pushed\n+\n+                  Priv_Scop := Empty;\n+               end if;\n+\n                Complete_Private_Subtype (Full, Priv, Full_T, N);\n+\n+               if Present (Priv_Scop) then\n+                  Pop_Scope;\n+               end if;\n+\n                Replace_Elmt (Priv_Elmt, Full);\n             end if;\n "}]}