{"sha": "b385aeda3f7428271d3b2ef8e6ff3801cffd3f95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4NWFlZGEzZjc0MjgyNzFkM2IyZWY4ZTZmZjM4MDFjZmZkM2Y5NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-19T11:27:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-19T11:27:23Z"}, "message": "(zero_cost): New variable.\n\n(init_expmed): Always pass some insn to recog.\nSet shift_cost[0], shiftadd_cost[0] and shiftsub_cost[0] to something\nreasonable.\nCompute zero_cost.\n(enum alg_code): Remove alg_none; add alg_zero and alg_m.\n(struct algorithm): Rename field COEFF to LOG.\n(synth_mult): Use new ops alg_zero and alg_m for multiplication by zero and\none, respectively.\nUse MIN when helpful.\nBe consistent and don't test cost before recursive call.\nDon't special-case shift counts of zero; already handled elsewhere.\n(expand_mult): First operation is always alg_zero or alg_m; remaining\noperations can't be one of those.\nUse proper subtargets for computations.\nRemove special-cases for shift counts of zero.\nTrack value computed so far and make REG_EQUAL notes.\n\nFrom-SVN: r3786", "tree": {"sha": "e2a536e0a178b800d607e0e3c39144a2c3181d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2a536e0a178b800d607e0e3c39144a2c3181d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b385aeda3f7428271d3b2ef8e6ff3801cffd3f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b385aeda3f7428271d3b2ef8e6ff3801cffd3f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b385aeda3f7428271d3b2ef8e6ff3801cffd3f95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b385aeda3f7428271d3b2ef8e6ff3801cffd3f95/comments", "author": null, "committer": null, "parents": [{"sha": "337633f9c613670b07b4309cf92469e89f3f6685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337633f9c613670b07b4309cf92469e89f3f6685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337633f9c613670b07b4309cf92469e89f3f6685"}], "stats": {"total": 343, "additions": 176, "deletions": 167}, "files": [{"sha": "87f4181cc55dace80c4e2e9fb10238ae9e4bb1b4", "filename": "gcc/expmed.c", "status": "modified", "additions": 176, "deletions": 167, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b385aeda3f7428271d3b2ef8e6ff3801cffd3f95/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b385aeda3f7428271d3b2ef8e6ff3801cffd3f95/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b385aeda3f7428271d3b2ef8e6ff3801cffd3f95", "patch": "@@ -50,44 +50,71 @@ int mult_is_very_cheap;\n static int sdiv_pow2_cheap, smod_pow2_cheap;\n \n /* Cost of various pieces of RTL.  */\n-static int add_cost, mult_cost, negate_cost;\n+static int add_cost, mult_cost, negate_cost, zero_cost;\n static int shift_cost[BITS_PER_WORD];\n static int shiftadd_cost[BITS_PER_WORD];\n static int shiftsub_cost[BITS_PER_WORD];\n \n void\n init_expmed ()\n {\n-  char *free_point = (char *) oballoc (1);\n+  char *free_point;\n   /* This is \"some random pseudo register\" for purposes of calling recog\n      to see what insns exist.  */\n   rtx reg = gen_rtx (REG, word_mode, FIRST_PSEUDO_REGISTER);\n-  rtx pow2 = GEN_INT (32);\n-  rtx shift_tmp, shiftadd_tmp, shiftsub_tmp;\n+  rtx shift_insn, shiftadd_insn, shiftsub_insn;\n   int dummy;\n   int m;\n \n+  start_sequence ();\n+\n+  /* Since we are on the permanent obstack, we must be sure we save this\n+     spot AFTER we call start_sequence, since it will reuse the rtl it\n+     makes.  */\n+\n+  free_point = (char *) oballoc (0);\n+\n+  zero_cost = rtx_cost (const0_rtx);\n   add_cost = rtx_cost (gen_rtx (PLUS, word_mode, reg, reg), SET);\n \n-  shift_tmp = gen_rtx (ASHIFT, word_mode, reg, const0_rtx);\n-  shiftadd_tmp = gen_rtx (PLUS, word_mode, gen_rtx (MULT, word_mode, reg, const0_rtx), reg);\n-  shiftsub_tmp = gen_rtx (MINUS, word_mode, gen_rtx (MULT, word_mode, reg, const0_rtx), reg);\n+  shift_insn = emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t   gen_rtx (ASHIFT, word_mode, reg,\n+\t\t\t\t\t    const0_rtx)));\n+\n+  shiftadd_insn = emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t      gen_rtx (PLUS, word_mode,\n+\t\t\t\t\t       gen_rtx (MULT, word_mode,\n+\t\t\t\t\t\t\treg, const0_rtx),\n+\t\t\t\t\t       reg)));\n+\n+  shiftsub_insn = emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t      gen_rtx (MINUS, word_mode,\n+\t\t\t\t\t       gen_rtx (MULT, word_mode,\n+\t\t\t\t\t\t\t reg, const0_rtx),\n+\t\t\t\t\t\treg)));\n \n   init_recog ();\n-  /* Using 0 as second argument of recog in the loop is not quite right,\n-     but what else is there to do?  */\n+\n+  shift_cost[0] = 0;\n+  shiftadd_cost[0] = shiftsub_cost[0] = add_cost;\n+\n   for (m = 1; m < BITS_PER_WORD; m++)\n     {\n       shift_cost[m] = shiftadd_cost[m] = shiftsub_cost[m] = 32000;\n-      XEXP (shift_tmp, 1) = GEN_INT (m);\n-      if (recog (gen_rtx (SET, VOIDmode, reg, shift_tmp), 0, &dummy) >= 0)\n-\tshift_cost[m] = rtx_cost (shift_tmp, SET);\n-      XEXP (XEXP (shiftadd_tmp, 0), 1) = GEN_INT ((HOST_WIDE_INT) 1 << m);\n-      if (recog (gen_rtx (SET, VOIDmode, reg, shiftadd_tmp), 0, &dummy) >= 0)\n-\tshiftadd_cost[m] = rtx_cost (shiftadd_tmp, SET);\n-      XEXP (XEXP (shiftsub_tmp, 0), 1) = GEN_INT ((HOST_WIDE_INT) 1 << m);\n-      if (recog (gen_rtx (SET, VOIDmode, reg, shiftsub_tmp), 0, &dummy) >= 0)\n-\tshiftsub_cost[m] = rtx_cost (shiftsub_tmp, SET);\n+\n+      XEXP (SET_SRC (PATTERN (shift_insn)), 1) = GEN_INT (m);\n+      if (recog (PATTERN (shift_insn), shift_insn, &dummy) >= 0)\n+\tshift_cost[m] = rtx_cost (SET_SRC (PATTERN (shift_insn)), SET);\n+\n+      XEXP (XEXP (SET_SRC (PATTERN (shiftadd_insn)), 0), 1)\n+\t= GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      if (recog (PATTERN (shiftadd_insn), shiftadd_insn, &dummy) >= 0)\n+\tshiftadd_cost[m] = rtx_cost (PATTERN (SET_SRC (shiftadd_insn)), SET);\n+\n+      XEXP (XEXP (SET_SRC (PATTERN (shiftsub_insn)), 0), 1)\n+\t= GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      if (recog (PATTERN (shiftsub_insn), shiftsub_insn, &dummy) >= 0)\n+\tshiftsub_cost[m] = rtx_cost (PATTERN (SET_SRC (shiftsub_insn)), SET);\n     }\n \n   mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg), SET);\n@@ -99,11 +126,14 @@ init_expmed ()\n        < rtx_cost (gen_rtx (ASHIFT, word_mode, reg, GEN_INT (7)), SET));\n \n   sdiv_pow2_cheap\n-    = rtx_cost (gen_rtx (DIV, word_mode, reg, pow2), SET) <= 2 * add_cost;\n+    = (rtx_cost (gen_rtx (DIV, word_mode, reg, GEN_INT (32)), SET)\n+       <= 2 * add_cost);\n   smod_pow2_cheap\n-    = rtx_cost (gen_rtx (MOD, word_mode, reg, pow2), SET) <= 2 * add_cost;\n+    = (rtx_cost (gen_rtx (MOD, word_mode, reg, GEN_INT (32)), SET)\n+       <= 2 * add_cost);\n \n   /* Free the objects we just allocated.  */\n+  end_sequence ();\n   obfree (free_point);\n }\n \n@@ -1718,26 +1748,30 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n   return temp;\n }\n \f\n-enum alg_code { alg_none, alg_shift,\n+enum alg_code { alg_zero, alg_m, alg_shift,\n \t\t  alg_add_t_m2, alg_sub_t_m2,\n \t\t  alg_add_factor, alg_sub_factor,\n \t\t  alg_add_t2_m, alg_sub_t2_m,\n-alg_add, alg_subtract, alg_factor, alg_shiftop };\n+\t\t  alg_add, alg_subtract, alg_factor, alg_shiftop };\n \n /* This structure records a sequence of operations.\n    `ops' is the number of operations recorded.\n    `cost' is their total cost.\n    The operations are stored in `op' and the corresponding\n-   integer coefficients in `coeff'.\n+   logarithms of the integer coefficients in `log'.\n+\n    These are the operations:\n+   alg_zero\t\ttotal := 0;\n+   alg_m\t\ttotal := multiplicand;\n    alg_shift\t\ttotal := total * coeff\n    alg_add_t_m2\t\ttotal := total + multiplicand * coeff;\n    alg_sub_t_m2\t\ttotal := total - multiplicand * coeff;\n    alg_add_factor\ttotal := total * coeff + total;\n    alg_sub_factor\ttotal := total * coeff - total;\n    alg_add_t2_m\t\ttotal := total * coeff + multiplicand;\n    alg_sub_t2_m\t\ttotal := total * coeff - multiplicand;\n-*/\n+\n+   The first operand must be either alg_zero or alg_m.  */\n \n #ifndef MAX_BITS_PER_WORD\n #define MAX_BITS_PER_WORD BITS_PER_WORD\n@@ -1747,13 +1781,13 @@ struct algorithm\n {\n   short cost;\n   short ops;\n-/* The size of the OP and COEFF fields are not directly related to the\n-   word size, but the worst-case algorithms will be if we have few\n-   consecutive ones or zeros, i.e., a multiplicand like 10101010101...\n-   In that case we will generate shift-by-2, add, shift-by-2, add,...,\n-   in total wordsize operations.  */\n+  /* The size of the OP and LOG fields are not directly related to the\n+     word size, but the worst-case algorithms will be if we have few\n+     consecutive ones or zeros, i.e., a multiplicand like 10101010101...\n+     In that case we will generate shift-by-2, add, shift-by-2, add,...,\n+     in total wordsize operations.  */\n   enum alg_code op[MAX_BITS_PER_WORD];\n-  char coeff[MAX_BITS_PER_WORD];\n+  char log[MAX_BITS_PER_WORD];\n };\n \n /* Compute and return the best algorithm for multiplying by T.\n@@ -1781,14 +1815,34 @@ synth_mult (t, cost_limit)\n   if (cost_limit <= 0)\n     return *best_alg;\n \n-  if (t <= 1)\n+  /* t == 1 can be done in zero cost.  */\n+  if (t == 1)\n     {\n-      /* t == 0 or t == 1 takes no instructions.  */\n-      best_alg->ops = 0;\n+      best_alg->ops = 1;\n       best_alg->cost = 0;\n+      best_alg->op[0] = alg_m;\n       return *best_alg;\n     }\n \n+  /* t == 0 sometimes has a cost.  If it does and it exceeds our limit,\n+     fail now.  */\n+\n+  else if (t == 0)\n+    {\n+      if (zero_cost >= cost_limit)\n+\treturn *best_alg;\n+      else\n+\t{\n+\t  best_alg->ops = 1;\n+\t  best_alg->cost = zero_cost;\n+\t  best_alg->op[0] = alg_zero;\n+\t  return *best_alg;\n+\t}\n+    }\n+\n+  /* If we have a group of zero bits at the low-order part of T, try\n+     multiplying by the remaining bits and then doing a shift.  */\n+\n   if ((t & 1) == 0)\n     {\n       m = floor_log2 (t & -t);\t/* m = number of low zero bits */\n@@ -1803,7 +1857,7 @@ synth_mult (t, cost_limit)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n-\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops++] = alg_shift;\n \t      best_alg->cost = cost_limit = cost;\n \t    }\n@@ -1827,19 +1881,15 @@ synth_mult (t, cost_limit)\n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n       if (t % d == 0 && t > d)\n \t{\n-\t  if (shiftadd_cost[m] <= add_cost + shift_cost[m])\n-\t    cost = shiftadd_cost[m];\n-\t  else\n-\t    cost = add_cost + shift_cost[m];\n-\n+\t  cost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);\n \t  *alg_in = synth_mult (t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n \t  if (cost < best_alg->cost)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n-\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops++] = alg_add_factor;\n \t      best_alg->cost = cost_limit = cost;\n \t    }\n@@ -1848,19 +1898,15 @@ synth_mult (t, cost_limit)\n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n       if (t % d == 0 && t > d)\n \t{\n-\t  if (shiftsub_cost[m] <= add_cost + shift_cost[m])\n-\t    cost = shiftsub_cost[m];\n-\t  else\n-\t    cost = add_cost + shift_cost[m];\n-\n+\t  cost = MIN (shiftsub_cost[m], add_cost + shift_cost[m]);\n \t  *alg_in = synth_mult (t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n \t  if (cost < best_alg->cost)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n-\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops++] = alg_sub_factor;\n \t      best_alg->cost = cost_limit = cost;\n \t    }\n@@ -1875,38 +1921,32 @@ synth_mult (t, cost_limit)\n       q = q & -q;\n       m = exact_log2 (q);\n       cost = shiftadd_cost[m];\n-      if (cost < cost_limit)\n-\t{\n-\t  *alg_in = synth_mult ((t - 1) >> m, cost_limit - cost);\n+      *alg_in = synth_mult ((t - 1) >> m, cost_limit - cost);\n \n-\t  cost += alg_in->cost;\n-\t  if (cost < best_alg->cost)\n-\t    {\n-\t      struct algorithm *x;\n-\t      x = alg_in, alg_in = best_alg, best_alg = x;\n-\t      best_alg->coeff[best_alg->ops] = m;\n-\t      best_alg->op[best_alg->ops++] = alg_add_t2_m;\n-\t      best_alg->cost = cost_limit = cost;\n-\t    }\n+      cost += alg_in->cost;\n+      if (cost < best_alg->cost)\n+\t{\n+\t  struct algorithm *x;\n+\t  x = alg_in, alg_in = best_alg, best_alg = x;\n+\t  best_alg->log[best_alg->ops] = m;\n+\t  best_alg->op[best_alg->ops++] = alg_add_t2_m;\n+\t  best_alg->cost = cost_limit = cost;\n \t}\n \n       q = t + 1;\n       q = q & -q;\n       m = exact_log2 (q);\n       cost = shiftsub_cost[m];\n-      if (cost < cost_limit)\n-\t{\n-\t  *alg_in = synth_mult ((t + 1) >> m, cost_limit - cost);\n+      *alg_in = synth_mult ((t + 1) >> m, cost_limit - cost);\n \n-\t  cost += alg_in->cost;\n-\t  if (cost < best_alg->cost)\n-\t    {\n-\t      struct algorithm *x;\n-\t      x = alg_in, alg_in = best_alg, best_alg = x;\n-\t      best_alg->coeff[best_alg->ops] = m;\n-\t      best_alg->op[best_alg->ops++] = alg_sub_t2_m;\n-\t      best_alg->cost = cost_limit = cost;\n-\t    }\n+      cost += alg_in->cost;\n+      if (cost < best_alg->cost)\n+\t{\n+\t  struct algorithm *x;\n+\t  x = alg_in, alg_in = best_alg, best_alg = x;\n+\t  best_alg->log[best_alg->ops] = m;\n+\t  best_alg->op[best_alg->ops++] = alg_sub_t2_m;\n+\t  best_alg->cost = cost_limit = cost;\n \t}\n     }\n \n@@ -1926,23 +1966,18 @@ synth_mult (t, cost_limit)\n \t/* There are many bits in a row.  Make 'em by subtraction.  */\n \n \tm = exact_log2 (q);\n-\tif (m == 0)\n-\t  cost = add_cost;\n-\telse\n-\t  {\n-\t    /* Don't use shiftsub_cost here, this operation\n-\t       scales wrong operand.  */\n-\t    cost = add_cost + shift_cost[m];\n-\t  }\n \n+\t/* Don't use shiftsub_cost here, this operation\n+\t   scales wrong operand.  */\n+\tcost = add_cost + shift_cost[m];\n \t*alg_in = synth_mult (t + q, cost_limit - cost);\n \n \tcost += alg_in->cost;\n \tif (cost < best_alg->cost)\n \t  {\n \t    struct algorithm *x;\n \t    x = alg_in, alg_in = best_alg, best_alg = x;\n-\t    best_alg->coeff[best_alg->ops] = m;\n+\t    best_alg->log[best_alg->ops] = m;\n \t    best_alg->op[best_alg->ops++] = alg_sub_t_m2;\n \t    best_alg->cost = cost_limit = cost;\n \t  }\n@@ -1952,24 +1987,15 @@ synth_mult (t, cost_limit)\n \t/* There's only one or two bit at the left.  Make it by addition.  */\n \n \tm = exact_log2 (q);\n-\tif (m == 0)\n-\t  cost = add_cost;\n-\telse\n-\t  {\n-\t    if (shiftadd_cost[m] <= add_cost + shift_cost[m])\n-\t      cost = shiftadd_cost[m];\n-\t    else\n-\t      cost = add_cost + shift_cost[m];\n-\t  }\n-\n+\tcost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);\n \t*alg_in = synth_mult (t - q, cost_limit - cost);\n \n \tcost += alg_in->cost;\n \tif (cost < best_alg->cost)\n \t  {\n \t    struct algorithm *x;\n \t    x = alg_in, alg_in = best_alg, best_alg = x;\n-\t    best_alg->coeff[best_alg->ops] = m;\n+\t    best_alg->log[best_alg->ops] = m;\n \t    best_alg->op[best_alg->ops++] = alg_add_t_m2;\n \t    best_alg->cost = cost_limit = cost;\n \t  }\n@@ -2015,12 +2041,15 @@ expand_mult (mode, op0, op1, target, unsignedp)\n      produce a smaller program when -O is not used.\n      But this causes such a terrible slowdown sometimes\n      that it seems better to use synth_mult always.  */\n+\n   if (GET_CODE (const_op1) == CONST_INT && ! mult_is_very_cheap)\n     {\n       struct algorithm alg;\n       struct algorithm neg_alg;\n       int negate = 0;\n       HOST_WIDE_INT val = INTVAL (op1);\n+      HOST_WIDE_INT val_so_far;\n+      rtx insn;\n \n       /* Try to do the computation two ways: multiply by the negative of OP1\n \t and then negate, or do the multiplication directly.  The latter is\n@@ -2050,128 +2079,108 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t  if (GET_CODE (op0) == MEM)\n \t    op0 = force_reg (mode, op0);\n \n-\t  if (alg.ops == 0)\n-\t    accum = copy_to_mode_reg (mode, op0);\n-\t  else\n+\t  /* ACCUM starts out either as OP0 or as a zero, depending on\n+\t     the first operation.  */\n+\n+\t  if (alg.op[0] == alg_zero)\n \t    {\n-\t      int log = alg.coeff[0];\n-\t      enum alg_code op = alg.op[0];\n-\t      if (op == alg_shift)\n-\t\t{\n-\t\t  accum = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n-\t\t}\n-\t      else if (op == alg_add_t2_m)\n-\t\t{\n-\t\t  accum = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n-\t\t\t\t\t accum);\n-\t\t}\n-\t      else if (op == alg_sub_t2_m)\n-\t\t{\n-\t\t  accum = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n-\t\t\t\t\t accum);\n-\t\t}\n-\t      else\n-\t\tabort ();\n+\t      accum = copy_to_mode_reg (mode, const0_rtx);\n+\t      val_so_far = 0;\n+\t    }\n+\t  else if (alg.op[0] == alg_m)\n+\t    {\n+\t      accum  = copy_to_mode_reg (mode, op0);\n+\t      val_so_far = 1;\n \t    }\n+\t  else\n+\t    abort ();\n \n \t  for (opno = 1; opno < alg.ops; opno++)\n \t    {\n-\t      int log = alg.coeff[opno];\n+\t      int log = alg.log[opno];\n+\t      rtx shift_subtarget = preserve_subexpressions_p () ? 0 : accum;\n+\t      rtx add_target = opno == alg.ops - 1 && target != 0 ? target : 0;\n+\n \t      switch (alg.op[opno])\n \t\t{\n \t\tcase alg_shift:\n \t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  val_so_far <<= log;\n \t\t  break;\n \n \t\tcase alg_add_t_m2:\n-\t\t  if (log != 0)\n-\t\t    {\n-\t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t      accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n-\t\t\t\t\t     accum);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n-\t\t\t\t\t     accum);\n-\t\t    }\n+\t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n+\t\t\t\t\t add_target ? add_target : accum);\n+\t\t  val_so_far += (HOST_WIDE_INT) 1 << log;\n \t\t  break;\n \n \t\tcase alg_sub_t_m2:\n-\t\t  if (log != 0)\n-\t\t    {\n-\t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t      accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n-\t\t\t\t\t     accum);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n-\t\t\t\t\t     accum);\n-\t\t    }\n+\t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n+\t\t\t\t\t add_target ? add_target : accum);\n+\t\t  val_so_far -= (HOST_WIDE_INT) 1 << log;\n \t\t  break;\n \n \t\tcase alg_add_t2_m:\n \t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t\t\t\tbuild_int_2 (log, 0), accum, 0);\n \t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n-\t\t\t\t\t accum);\n+\t\t\t\t\t add_target ? add_target : accum);\n+\t\t  val_so_far = (val_so_far << log) + 1;\n \t\t  break;\n \n \t\tcase alg_sub_t2_m:\n \t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t\t\t\tbuild_int_2 (log, 0), accum, 0);\n \t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n-\t\t\t\t\t accum);\n+\t\t\t\t\t add_target ? add_target : accum);\n+\t\t  val_so_far = (val_so_far << log) - 1;\n \t\t  break;\n \n \t\tcase alg_add_factor:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (PLUS, mode, tem, accum),\n-\t\t\t\t\t tem);\n+\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n+\t\t\t\t\t add_target ? add_target : accum);\n+\t\t  val_so_far += val_so_far << log;\n \t\t  break;\n \n \t\tcase alg_sub_factor:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n \t\t  accum = force_operand (gen_rtx (MINUS, mode, tem, accum),\n-\t\t\t\t\t tem);\n+\t\t\t\t\t add_target ? add_target : tem);\n+\t\t  val_so_far = (val_so_far << log) - val_so_far;\n \t\t  break;\n-\t\t}\n-\t    }\n \n-\t  /* Write a REG_EQUAL note on the last insn so that we can cse\n-\t     multiplication sequences.  We need not do this if we were\n-\t     multiplying by a power of two, since only one insn would have\n-\t     been generated.\n+\t\tdefault:\n+\t\t  abort ();;\n+\t\t}\n \n-\t     ??? We could also write REG_EQUAL notes on the last insn of\n-\t     each sequence that uses a single temporary, but it is not\n-\t     clear how to calculate the partial product so far.\n+\t      /* Write a REG_EQUAL note on the last insn so that we can cse\n+\t\t multiplication sequences.  */\n \n-\t     Torbjorn: Can you do this?  */\n+\t      insn = get_last_insn ();\n+\t      REG_NOTES (insn)\n+\t\t= gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t   gen_rtx (MULT, mode, op0, GEN_INT (val_so_far)),\n+\t\t\t   REG_NOTES (insn));\n+\t    }\n \n-\t  if (exact_log2 (val) < 0)\n+\t  if (negate)\n \t    {\n-\t      rtx last = get_last_insn ();\n-\t      REG_NOTES (last)\n-\t\t= gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t   gen_rtx (MULT, mode, op0,\n-\t\t\t\t    negate ? GEN_INT (val) : op1),\n-\t\t\t   REG_NOTES (last));\n+\t      val_so_far = - val_so_far;\n+\t      accum = expand_unop (mode, neg_optab, accum, target, 0);\n \t    }\n \n-\t  return (negate ? expand_unop (mode, neg_optab, accum, target, 0)\n-\t\t  : accum);\n+\t  if (val != val_so_far)\n+\t    abort ();\n+\n+\t  return accum;\n \t}\n     }\n "}]}