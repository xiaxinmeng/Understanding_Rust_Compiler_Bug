{"sha": "026216a753ef0a757a9e368a59fa667ea422cf09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI2MjE2YTc1M2VmMGE3NTdhOWUzNjhhNTlmYTY2N2VhNDIyY2YwOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2019-03-19T22:33:34Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2019-03-19T22:33:34Z"}, "message": "RISC-V: Fix %lo overflow with BLKmode references.\n\n\tgcc/\n\tPR target/89411\n\t* config/riscv/riscv.c (riscv_valid_lo_sum_p): New arg x.  New locals\n\talign, size, offset.  Use them to handle a BLKmode reference.  Update\n\tcomment.\n\t(riscv_classify_address): Pass info->offset to riscv_valid_lo_sum_p.\n\n\tgcc/testsuite/\n\tPR target/89411\n\t* gcc.target/riscv/losum-overflow.c: New test.\n\nFrom-SVN: r269813", "tree": {"sha": "222389407fc02c0fe6d9412bf3dbebd20859fc61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/222389407fc02c0fe6d9412bf3dbebd20859fc61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/026216a753ef0a757a9e368a59fa667ea422cf09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/026216a753ef0a757a9e368a59fa667ea422cf09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/026216a753ef0a757a9e368a59fa667ea422cf09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/026216a753ef0a757a9e368a59fa667ea422cf09/comments", "author": null, "committer": null, "parents": [{"sha": "2a23a1c39fb33df0277abd4486a3da64ae5e62c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a23a1c39fb33df0277abd4486a3da64ae5e62c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a23a1c39fb33df0277abd4486a3da64ae5e62c2"}], "stats": {"total": 85, "additions": 79, "deletions": 6}, "files": [{"sha": "adf1382a441359cdaf1b904d16132f1a2540b662", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=026216a753ef0a757a9e368a59fa667ea422cf09", "patch": "@@ -1,3 +1,11 @@\n+2019-03-19  Jim Wilson  <jimw@sifive.com>\n+\n+\tPR target/89411\n+\t* config/riscv/riscv.c (riscv_valid_lo_sum_p): New arg x.  New locals\n+\talign, size, offset.  Use them to handle a BLKmode reference.  Update\n+\tcomment.\n+\t(riscv_classify_address): Pass info->offset to riscv_valid_lo_sum_p.\n+\n 2019-03-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/89768"}, {"sha": "d8446f82b9622d054e2fcffe0fb118a1ea703758", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=026216a753ef0a757a9e368a59fa667ea422cf09", "patch": "@@ -708,11 +708,15 @@ riscv_split_symbol_type (enum riscv_symbol_type symbol_type)\n }\n \n /* Return true if a LO_SUM can address a value of mode MODE when the\n-   LO_SUM symbol has type SYM_TYPE.  */\n+   LO_SUM symbol has type SYM_TYPE.  X is the LO_SUM second operand, which\n+   is used when the mode is BLKmode.  */\n \n static bool\n-riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, machine_mode mode)\n+riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, machine_mode mode,\n+\t\t      rtx x)\n {\n+  int align, size;\n+\n   /* Check that symbols of type SYMBOL_TYPE can be used to access values\n      of mode MODE.  */\n   if (riscv_symbol_insns (sym_type) == 0)\n@@ -722,11 +726,38 @@ riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, machine_mode mode)\n   if (!riscv_split_symbol_type (sym_type))\n     return false;\n \n+  /* We can't tell size or alignment when we have BLKmode, so try extracing a\n+     decl from the symbol if possible.  */\n+  if (mode == BLKmode)\n+    {\n+      rtx offset;\n+\n+      /* Extract the symbol from the LO_SUM operand, if any.  */\n+      split_const (x, &x, &offset);\n+\n+      /* Might be a CODE_LABEL.  We can compute align but not size for that,\n+\t so don't bother trying to handle it.  */\n+      if (!SYMBOL_REF_P (x))\n+\treturn false;\n+\n+      /* Use worst case assumptions if we don't have a SYMBOL_REF_DECL.  */\n+      align = (SYMBOL_REF_DECL (x)\n+\t       ? DECL_ALIGN (SYMBOL_REF_DECL (x))\n+\t       : 1);\n+      size = (SYMBOL_REF_DECL (x) && DECL_SIZE (SYMBOL_REF_DECL (x))\n+\t      ? tree_to_uhwi (DECL_SIZE (SYMBOL_REF_DECL (x)))\n+\t      : 2*BITS_PER_WORD);\n+    }\n+  else\n+    {\n+      align = GET_MODE_ALIGNMENT (mode);\n+      size = GET_MODE_BITSIZE (mode);\n+    }\n+\n   /* We may need to split multiword moves, so make sure that each word\n      can be accessed without inducing a carry.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && (!TARGET_STRICT_ALIGN\n-\t  || GET_MODE_BITSIZE (mode) > GET_MODE_ALIGNMENT (mode)))\n+  if (size > BITS_PER_WORD\n+      && (!TARGET_STRICT_ALIGN || size > align))\n     return false;\n \n   return true;\n@@ -772,7 +803,7 @@ riscv_classify_address (struct riscv_address_info *info, rtx x,\n       info->symbol_type\n \t= riscv_classify_symbolic_expression (info->offset);\n       return (riscv_valid_base_register_p (info->reg, mode, strict_p)\n-\t      && riscv_valid_lo_sum_p (info->symbol_type, mode));\n+\t      && riscv_valid_lo_sum_p (info->symbol_type, mode, info->offset));\n \n     case CONST_INT:\n       /* Small-integer addresses don't occur very often, but they"}, {"sha": "7ad6ccc1e4a0758aece2a0d8f276f36e536d40b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=026216a753ef0a757a9e368a59fa667ea422cf09", "patch": "@@ -1,3 +1,8 @@\n+2019-03-19  Jim Wilson  <jimw@sifive.com>\n+\n+\tPR target/89411\n+\t* gcc.target/riscv/losum-overflow.c: New test.\n+\n 2019-03-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/89644"}, {"sha": "9c01c7feb545e27453ada1731ddb2923d8950eb3", "filename": "gcc/testsuite/gcc.target/riscv/losum-overflow.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Flosum-overflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026216a753ef0a757a9e368a59fa667ea422cf09/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Flosum-overflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Flosum-overflow.c?ref=026216a753ef0a757a9e368a59fa667ea422cf09", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc -mabi=ilp32 -O2 -fno-section-anchors\" } */\n+\n+/* Check for %lo overflow.  Adding an offset larger than the alignment can\n+   overflow if the data is allocated to an address mod 4KB that is between\n+   2KB-offset+1 and 2KB-1.  */\n+typedef long long int int64_t;\n+\n+#pragma pack(push)\n+#pragma pack(1)\n+struct S0 {\n+   signed f0 : 4;\n+   const volatile int64_t  f1;\n+   volatile signed f2 : 1;\n+   signed f3 : 31;\n+   unsigned f4 : 8;\n+   signed f5 : 20;\n+   unsigned f6 : 5;\n+};\n+#pragma pack(pop)\n+\n+struct S0 g_3030 = {0,-9L,-0,-22553,7,-841,1};\n+\n+int64_t\n+sub (void)\n+{\n+  return g_3030.f1;\n+}\n+/* { dg-final { scan-assembler-not \"%lo\\\\(g_3030\\\\+4\\\\)\" } } */"}]}