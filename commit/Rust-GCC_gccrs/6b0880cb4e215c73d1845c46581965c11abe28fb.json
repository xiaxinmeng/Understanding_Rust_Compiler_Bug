{"sha": "6b0880cb4e215c73d1845c46581965c11abe28fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIwODgwY2I0ZTIxNWM3M2QxODQ1YzQ2NTgxOTY1YzExYWJlMjhmYg==", "commit": {"author": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2001-10-17T04:36:18Z"}, "committer": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2001-10-17T04:36:18Z"}, "message": "dsp16xx.c: Fix comment formatting to match GNU standards.\n\n\n\n* dsp16xx.c: Fix comment formatting to match GNU standards.\n(dsp16xx_output_function_prologue): Change type of 'size'\nparameter from 'int' to HOST_WIDE_INT.\n(dsp16xx_output_function_epilogue): Change type of 'size'\nparameter from 'int' to HOST_WIDE_INT.\n\nFrom-SVN: r46305", "tree": {"sha": "4d7580a19c478288302d90fc12dc2555816341bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d7580a19c478288302d90fc12dc2555816341bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b0880cb4e215c73d1845c46581965c11abe28fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0880cb4e215c73d1845c46581965c11abe28fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b0880cb4e215c73d1845c46581965c11abe28fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0880cb4e215c73d1845c46581965c11abe28fb/comments", "author": null, "committer": null, "parents": [{"sha": "33129152a081d7764163e104a7d3c889b134740c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33129152a081d7764163e104a7d3c889b134740c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33129152a081d7764163e104a7d3c889b134740c"}], "stats": {"total": 155, "additions": 77, "deletions": 78}, "files": [{"sha": "c362e938f525e31ea7251335f17d383bc95ac41e", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 77, "deletions": 78, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0880cb4e215c73d1845c46581965c11abe28fb/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0880cb4e215c73d1845c46581965c11abe28fb/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=6b0880cb4e215c73d1845c46581965c11abe28fb", "patch": "@@ -54,11 +54,11 @@ const char *chip_name;\n const char *save_chip_name;\n \n /* Save the operands of a compare. The 16xx has not lt or gt, so\n-   in these cases we swap the operands and reverse the condition */\n+   in these cases we swap the operands and reverse the condition.  */\n \n rtx dsp16xx_compare_op0;\n rtx dsp16xx_compare_op1;\n-struct rtx_def *(*dsp16xx_compare_gen)();\n+rtx (*dsp16xx_compare_gen) PARAMS (());\n \n static const char *fp;\n static const char *sp;\n@@ -168,9 +168,8 @@ hard_regno_mode_ok (regno, mode)\n     case VOIDmode:\n       return 1;\n       \n-      /* \n-\tWe can't use the c0-c2 for QImode, since they are only\n-\t8 bits in length */\n+      /* We can't use the c0-c2 for QImode, since they are only\n+\t 8 bits in length.  */\n \n     case QImode:\n       if (regno != REG_C0 && regno != REG_C1 && regno != REG_C2)\n@@ -180,7 +179,7 @@ hard_regno_mode_ok (regno, mode)\n       \n       /* We only allow a0, a1, y, and p to be allocated for 32-bit modes.\n          Additionally we allow the virtual ybase registers to be used for 32-bit\n-\t modes. */\n+\t modes.  */\n       \n     case HFmode:\n     case SFmode:\n@@ -285,8 +284,9 @@ dsp16xx_reg_class_from_letter (c)\n       return NO_REGS;\n     }\n }\n+\n /* Return the class number of the smallest class containing\n-   reg number REGNO. */\n+   reg number REGNO.  */\n \n int \n regno_reg_class(regno)\n@@ -359,7 +359,7 @@ regno_reg_class(regno)\n }\n \n /* A C expression for the maximum number of consecutive registers of class CLASS\n-   needed to hold a value of mode MODE */\n+   needed to hold a value of mode MODE.  */\n \n int\n class_max_nregs(class, mode)\n@@ -443,7 +443,7 @@ preferred_reload_class (x, class)\n      enum reg_class class;\n {\n   /* The ybase registers cannot have constants copied directly\n-     to them. */\n+     to them.  */\n \n   if (CONSTANT_P (x))\n     {\n@@ -494,7 +494,7 @@ preferred_reload_class (x, class)\n     }\n \n   /* If x is not an accumulator or a ybase register, restrict the class of registers\n-     we can copy the register into */\n+     we can copy the register into.   */\n \n   if (REG_P (x) && !IS_ACCUM_REG (REGNO (x)) && !IS_YBASE_REGISTER_WINDOW (REGNO (x)))\n     {\n@@ -687,7 +687,7 @@ preferred_reload_class (x, class)\n     }\n \n   /* If x (the input) is a ybase register, restrict the class of registers\n-     we can copy the register into */\n+     we can copy the register into.  */\n \n   if (REG_P (x) && !TARGET_RESERVE_YBASE\n       && IS_YBASE_REGISTER_WINDOW (REGNO(x)))\n@@ -795,7 +795,7 @@ preferred_reload_class (x, class)\n \t    return class;\n \n \t  /* If the accumulators are not part of the class\n-\t     being reloaded into, return NO_REGS */\n+\t     being reloaded into, return NO_REGS.  */\n #if 0\n \t  if (!reg_class_subset_p (ACCUM_REGS, class))\n \t    return (!reload_in_progress ? NO_REGS : class);\n@@ -804,9 +804,9 @@ preferred_reload_class (x, class)\n \t    return ACCUM_HIGH_REGS;\n \n \t  /* We will use accumulator 'a1l' for reloading a\n-\t     PLUS. We can only use one accumulator because\n+\t     PLUS.  We can only use one accumulator because\n \t     'reload_inqi' only allows one alternative to be\n-\t     used. */\n+\t     used.  */\n \n \t  else if (class == ACCUM_LOW_REGS)\n \t    return A1L_REG;\n@@ -824,7 +824,7 @@ preferred_reload_class (x, class)\n   else if (GET_CODE (x) == MEM)\n     {\n       /* We can't copy from a memory location into a\n-\t ybase register */\n+\t ybase register.  */\n       if (reg_class_subset_p(YBASE_VIRT_REGS, class))\n \t{\n \t  switch ((int) class)\n@@ -896,7 +896,7 @@ secondary_reload_class (class, mode, in)\n \n   /* If we are reloading a plus into a high accumulator register,\n      we need a scratch low accumulator, because the low half gets\n-     clobbered */\n+     clobbered.  */\n \n   if (class == ACCUM_HIGH_REGS \n       || class == A1H_REG\n@@ -919,7 +919,7 @@ secondary_reload_class (class, mode, in)\n \t  rtx addr1 = XEXP (in, 1);\n \t  \n \t  /* If we are reloading a plus (reg:QI) (reg:QI)\n-\t     we need an additional register. */ \n+\t     we need an additional register.  */ \n \t  if (REG_P (addr0) && REG_P (addr1))\n \t    return NO_REGS;\n \t}\n@@ -942,7 +942,7 @@ secondary_reload_class (class, mode, in)\n \n   /* We can copy the ybase registers into:\n      r0-r3, a0-a1, y, p, & x or the union of\n-     any of these. */\n+     any of these.  */\n \n   if (!TARGET_RESERVE_YBASE && IS_YBASE_REGISTER_WINDOW(regno))\n     {\n@@ -990,7 +990,7 @@ secondary_reload_class (class, mode, in)\n      directly to the ybase registers. In addition\n      we can use any of the ybase virtual registers\n      as the secondary reload registers when copying\n-     between any of these registers. */\n+     between any of these registers.  */\n \n   if (!TARGET_RESERVE_YBASE && regno != -1)\n     {\n@@ -1056,7 +1056,7 @@ secondary_reload_class (class, mode, in)\n     }\n \n   /* Memory or constants can be moved from or to any register\n-     except the ybase virtual registers */\n+     except the ybase virtual registers.  */\n   if (regno == -1 && GET_CODE(in) != PLUS)\n     {\n       if (class == YBASE_VIRT_REGS)\n@@ -1071,7 +1071,7 @@ secondary_reload_class (class, mode, in)\n       rtx addr1 = XEXP (in, 1);\n \n       /* If we are reloading a plus (reg:QI) (reg:QI)\n-\t we need a low accumulator, not a high one. */\n+\t we need a low accumulator, not a high one.  */\n       if (REG_P (addr0) && REG_P (addr1))\n \treturn ACCUM_LOW_REGS;\n     }\n@@ -1117,7 +1117,7 @@ symbolic_address_p (op)\n \n /* For a Y address space operand we allow only *rn, *rn++, *rn--.\n    This routine only recognizes *rn, the '<>' constraints recognize\n-   *rn++, *rn-- */\n+   (*rn++), and (*rn--).  */\n \n int\n Y_address_operand (op, mode)\n@@ -1252,15 +1252,15 @@ notice_update_cc(exp)\n \t    cc_status.value1 = SET_SRC (exp);\n \t    return;\n \t}\n-\t/* Certain instructions effect the condition codes. */\n+\t/* Certain instructions effect the condition codes.  */\n \telse if (GET_MODE_CLASS (GET_MODE (SET_SRC (exp))) == MODE_INT)\n-\t    switch( GET_CODE (SET_SRC (exp)) )\n+\t    switch (GET_CODE (SET_SRC (exp)))\n \t    {\n \t    case PLUS: \n \t    case MINUS:\n \t      if (REG_P (SET_DEST (exp)))\n \t\t{\n-\t\t  /* Address registers don't set the condition codes */\n+\t\t  /* Address registers don't set the condition codes.  */\n \t\t  if (IS_ADDRESS_REGISTER (REGNO (SET_DEST (exp))))\n \t\t    {\n \t\t      CC_STATUS_INIT;\n@@ -1331,7 +1331,7 @@ compute_frame_size (size)\n   long extra_size;\n   long reg_size;\n \n-  /* This value is needed to compute reg_size */\n+  /* This value is needed to compute reg_size.  */\n   current_frame_info.function_makes_calls = !leaf_function_p ();\n \n   reg_size = 0;\n@@ -1362,15 +1362,17 @@ compute_frame_size (size)\n   return total_size;\n }\n \n-int frame_size()\n+int \n+frame_size ()\n {\n   return (int) compute_frame_size(get_frame_size());\n }\n \n-int frame_pointer_offset()\n+int \n+frame_pointer_offset ()\n {\n   if (!leaf_function_p())\n-    return ( -(current_function_outgoing_args_size + 1) );\n+    return (-(current_function_outgoing_args_size + 1));\n   else\n     return 1;\n }\n@@ -1406,7 +1408,7 @@ ybase_regs_ever_used ()\n void \n dsp16xx_output_function_prologue (file, size)\n      FILE *file;\n-     int  size;\n+     HOST_WIDE_INT size;\n {\n   int regno;\n   long total_size;\n@@ -1417,7 +1419,7 @@ dsp16xx_output_function_prologue (file, size)\n   \n   total_size = compute_frame_size (size);\n   \n-  fprintf( file, \"\\t/* FUNCTION PROLOGUE: */\\n\" );\n+  fprintf (file, \"\\t/* FUNCTION PROLOGUE: */\\n\");\n   fprintf (file, \"\\t/* total=%d, vars= %d, regs= %d, args=%d, extra= %d */\\n\",\n \t   current_frame_info.total_size,\n \t   current_frame_info.var_size,\n@@ -1428,7 +1430,7 @@ dsp16xx_output_function_prologue (file, size)\n   fprintf (file, \"\\t/* fp save offset= %d, sp save_offset= %d */\\n\\n\",\n \t   current_frame_info.fp_save_offset,\n \t   current_frame_info.sp_save_offset);\n-  /* Set up the 'ybase' register window. */\n+  /* Set up the 'ybase' register window.  */\n   \n   if (ybase_regs_ever_used())\n     {\n@@ -1446,27 +1448,26 @@ dsp16xx_output_function_prologue (file, size)\n \tfprintf (file, \"\\t*%s++\\n\", sp);\n       else\n         {\n-\t  if(SMALL_INTVAL(current_frame_info.var_size) && ((current_frame_info.var_size & 0x8000) == 0))\n+\t  if (SMALL_INTVAL(current_frame_info.var_size) && ((current_frame_info.var_size & 0x8000) == 0))\n \t    fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.var_size, sp, reg_names[REG_J]);\n \t  else\n \t    fatal_error (\"Stack size > 32k\");\n \t}\n     }\n   \n   /* Save any registers this function uses, unless they are\n-   * used in a call, in which case we don't need to\n-   */\n+     used in a call, in which case we don't need to.  */\n   \n-  for( regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno )\n+  for(regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno)\n     if (dsp16xx_call_saved_register (regno)) \n       {\n-\tfprintf( file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno] );\n+\tfprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno]);\n       }\n \n   /* For debugging purposes, we want the return address to be at a predictable\n-     location */\n+     location.  */\n   if (current_frame_info.function_makes_calls)\n-    fprintf( file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[RETURN_ADDRESS_REGNUM]);\n+    fprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[RETURN_ADDRESS_REGNUM]);\n \n   if (current_frame_info.args_size)\n     {\n@@ -1478,13 +1479,13 @@ dsp16xx_output_function_prologue (file, size)\n    \n   if (frame_pointer_needed)\n     {\n-      fprintf( file, \"\\t%s=%s\\n\", a1h, sp );\n-      fprintf( file, \"\\t%s=%s\\n\", fp, a1h );  /* Establish new base frame */\n-      fprintf( file, \"\\t%s=%d\\n\", reg_names[REG_J], -total_size);\n-      fprintf( file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n+      fprintf (file, \"\\t%s=%s\\n\", a1h, sp);\n+      fprintf (file, \"\\t%s=%s\\n\", fp, a1h);  /* Establish new base frame */\n+      fprintf (file, \"\\t%s=%d\\n\", reg_names[REG_J], -total_size);\n+      fprintf (file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n     }\n   \n-  fprintf( file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\" );\n+  fprintf (file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\");\n }\n \n void\n@@ -1517,7 +1518,7 @@ init_emulation_routines ()\n void\n dsp16xx_output_function_epilogue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   int regno;\n   \n@@ -1526,7 +1527,7 @@ dsp16xx_output_function_epilogue (file, size)\n   rr = reg_names[RETURN_ADDRESS_REGNUM];   /* return address register */\n   a1h = reg_names[REG_A1];\n   \n-  fprintf( file, \"\\n\\t/* FUNCTION EPILOGUE: */\\n\" );\n+  fprintf (file, \"\\n\\t/* FUNCTION EPILOGUE: */\\n\");\n   \n   if (current_frame_info.args_size)\n     {\n@@ -1550,12 +1551,12 @@ dsp16xx_output_function_epilogue (file, size)\n     }\n \n   if (current_frame_info.function_makes_calls)\n-    fprintf( file, \"\\t%s=pop(*%s)\\n\", reg_names[RETURN_ADDRESS_REGNUM], sp );\n+    fprintf (file, \"\\t%s=pop(*%s)\\n\", reg_names[RETURN_ADDRESS_REGNUM], sp);\n   \n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; --regno)\n     if (dsp16xx_call_saved_register(regno))\n       {\n-\tfprintf( file, \"\\t%s=pop(*%s)\\n\", reg_names[regno], sp );\n+\tfprintf (file, \"\\t%s=pop(*%s)\\n\", reg_names[regno], sp);\n       }\n   \n   if (current_frame_info.var_size)\n@@ -1570,7 +1571,7 @@ dsp16xx_output_function_epilogue (file, size)\n     }\n   \n   fprintf (file, \"\\treturn\\n\");\n-  /* Reset the frame info for the next function */\n+  /* Reset the frame info for the next function.  */\n   current_frame_info = zero_frame_info;\n   init_emulation_routines ();\n }\n@@ -1613,7 +1614,7 @@ double_reg_from_memory (operands)\n \txoperands[1] = XEXP (XEXP (operands[1], 0), 0);\n \txoperands[0] = operands[0];\n \t\n-\t/* We can't use j anymore since the compiler can allocate it. */\n+\t/* We can't use j anymore since the compiler can allocate it.  */\n /*\toutput_asm_insn (\"j=-3\\n\\t%u0=*%1++\\n\\t%w0=*%1++j\", xoperands); */\n \toutput_asm_insn (\"%u0=*%1++\\n\\t%w0=*%1--\\n\\t*%1--\\n\\t*%1--\", xoperands);\n     }\n@@ -1661,7 +1662,7 @@ double_reg_to_memory (operands)\n \txoperands[0] = XEXP (XEXP (operands[0], 0), 0);\n \txoperands[1] = operands[1];\n \t\n-\t/* We can't use j anymore since the compiler can allocate it. */\n+\t/* We can't use j anymore since the compiler can allocate it.  */\n \n /*\toutput_asm_insn (\"j=-3\\n\\t*%0++=%u1\\n\\t*%0++j=%w1\", xoperands); */\n \toutput_asm_insn (\"*%0++=%u1\\n\\t*%0--=%w1\\n\\t*%0--\\n\\t*%0--\", xoperands);\n@@ -1778,9 +1779,9 @@ next_cc_user_code (insn)\n      rtx insn;\n {\n   /* If no insn could be found we assume that the jump has been\n-     deleted and the compare will be deleted later. */\n+     deleted and the compare will be deleted later.  */\n \n-  if ( !(insn = next_cc0_user (insn)))\n+  if (!(insn = next_cc0_user (insn)))\n     return (enum rtx_code) 0;\n   else if (GET_CODE (insn) == JUMP_INSN\n \t   && GET_CODE (PATTERN (insn)) == SET\n@@ -1849,9 +1850,9 @@ print_operand(file, op, letter)\n           break;  \n     }\n \n-    if( code == REG )\n+    if (code == REG)\n     {\n-\t/* Print the low half of a 32-bit register pair */\n+\t/* Print the low half of a 32-bit register pair.  */\n         if (letter == 'w')\n            fprintf (file, \"%s\", reg_names[REGNO (op) + 1]);\n         else if (letter == 'u' || !letter)\n@@ -1874,26 +1875,26 @@ print_operand(file, op, letter)\n \telse if (letter == 'h')\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n         else if (letter == 'U')\n-\t  fprintf(file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n         else\n-           output_addr_const( file, op );\n+           output_addr_const(file, op);\n     }\n-    else if( code == CONST_DOUBLE && GET_MODE(op) != DImode )\n+    else if (code == CONST_DOUBLE && GET_MODE(op) != DImode)\n     {\n \t  union { double d; int i[2]; } u;\n \t  union { float f; int i; } u1;\n \t  u.i[0] = CONST_DOUBLE_LOW (op);\n \t  u.i[1] = CONST_DOUBLE_HIGH (op);\n \t  u1.f = u.d;\n-          fprintf( file, \"0x%x\", u1.i );\n+          fprintf (file, \"0x%x\", u1.i);\n     }\n     else if (code == CONST)\n       {\n \trtx addr = XEXP (op, 0);\n \t\n \tif (GET_CODE (addr) != PLUS)\n \t  {\n-\t    output_addr_const( file, op);\n+\t    output_addr_const(file, op);\n \t    return;\n \t  }\n \t\n@@ -1924,7 +1925,7 @@ print_operand(file, op, letter)\n \t    fprintf (file, \"%d\", n);\n \t  }\n \telse\n-\t  output_addr_const( file, op);\n+\t  output_addr_const(file, op);\n       }\n     else\n       output_addr_const (file, op);\n@@ -1969,10 +1970,10 @@ print_operand_address(file, addr)\n       break;\n       \n     default:\n-      if( FITS_5_BITS( addr ) )\n-\tfprintf( file, \"*(0x%x)\", (INTVAL(addr) & 0x20) );\n+      if (FITS_5_BITS (addr))\n+\tfprintf (file, \"*(0x%x)\", (INTVAL (addr) & 0x20));\n       else\n-\toutput_addr_const(file, addr);\n+\toutput_addr_const (file, addr);\n     }\n }\n \n@@ -2008,7 +2009,7 @@ reg_save_size ()\n \treg_save_size += UNITS_PER_WORD;\n       }\n \n-  /* If the function makes calls we will save need to save the 'pr' register */\n+  /* If the function makes calls we will save need to save the 'pr' register.  */\n   if (current_frame_info.function_makes_calls)\n     reg_save_size += 1;\n \n@@ -2047,7 +2048,7 @@ initial_frame_pointer_offset()\n }\n \n /* Generate the minimum number of 1600 core shift instructions\n-   to shift by 'shift_amount'. */\n+   to shift by 'shift_amount'.  */\n \n #if 0\n void\n@@ -2398,8 +2399,7 @@ dsp16xx_address_cost (addr)\n    passed in registers, we first load the structure into the\n    register, and then when the last argument is passed, we store\n    the registers into the stack locations.  This fixes some bugs\n-   where GCC did not expect to have register arguments, followed */\n-\n+   where GCC did not expect to have register arguments, followed.  */\n \n struct rtx_def *\n dsp16xx_function_arg (args_so_far, mode, type, named)\n@@ -2463,7 +2463,7 @@ luxworks_dsp16xx_file_start (file)\n   int len, err_code;\n \n \n-  fprintf(file, \"\\t.debug \");\n+  fprintf (file, \"\\t.debug \");\n   err_code = (TARGET_DEBUG) ? fprintf (file, \"yes, \") : fprintf (file, \"no, \");\n   err_code = (TARGET_SAVE_TEMPS) ? fprintf (file, \"asm, \") : fprintf (file, \"temp, \");\n   len = strlen (main_input_filename);\n@@ -2477,8 +2477,8 @@ luxworks_dsp16xx_file_start (file)\n          p++;\n          }\n #endif\n-    fprintf(file, \"\\\"%s\\\"\\n\", temp_filename);\n-    fprintf(file, \"\");\n+    fprintf (file, \"\\\"%s\\\"\\n\", temp_filename);\n+    fprintf (file, \"\");\n \n   fprintf (file, \"#include <%s.h>\\n\", save_chip_name);\n \n@@ -2487,12 +2487,11 @@ luxworks_dsp16xx_file_start (file)\n     * object code. These have been created so that the number and\n     * type of sections remain consistent with and without -g option. Note\n     * that the .data, .text, .const and .bss are always created when -g\n-    * is provided as an option. \n-    */\n-   fprintf(file, \"\\t.rsect \\\".text\\\" , nodelete\\n\");\n-   fprintf(file, \"\\t.rsect \\\".data\\\" , nodelete\\n\");\n-   fprintf(file, \"\\t.rsect \\\".const\\\" , nodelete\\n\");\n-   fprintf(file, \"\\t.rsect \\\".bss\\\" , nodelete\\n\");\n+    * is provided as an option.  */\n+   fprintf (file, \"\\t.rsect \\\".text\\\" , nodelete\\n\");\n+   fprintf (file, \"\\t.rsect \\\".data\\\" , nodelete\\n\");\n+   fprintf (file, \"\\t.rsect \\\".const\\\" , nodelete\\n\");\n+   fprintf (file, \"\\t.rsect \\\".bss\\\" , nodelete\\n\");\n }\n \n rtx\n@@ -2526,7 +2525,7 @@ gen_compare_reg (code, x, y)\n \n   mode = GET_MODE (x);\n   /* For floating point compare insns, a call is generated so don't\n-     do anything here. */\n+     do anything here.  */\n \n   if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n     return cc0_rtx;"}]}