{"sha": "354c3840c8ff64c615c7365c5b0c1b04d2a38189", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU0YzM4NDBjOGZmNjRjNjE1YzczNjVjNWIwYzFiMDRkMmEzODE4OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T09:31:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T09:31:53Z"}, "message": "[multiple changes]\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* s-osprim-mingw.adb, sem_ch3.adb, sem_prag.adb, sem_util.adb.\n\tmakeutl.adb, sem_ch8.adb: Minor reformatting.\n\n2013-04-11  Vincent Celier  <celier@adacore.com>\n\n\t* gnat_ugn.texi: Minor fixes for VMS.\n\t* ug_words: Minor addition: -gnato? => /OVERFLOW_CHECKS=?.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* usage.adb (Usage): Minor edit to -gnatW message\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_aggr.adb (Expand_N_Aggregate): Add circuit for handling\n\tothers for string literal case. Also add big ??? comment about\n\tthis new code, which should be redundant, but is not.\n\t* sem_eval.adb (Eval_Concatenation): Handle non-static case\n\tproperly (Eval_String_Literal): Handle non-static literal properly\n\nFrom-SVN: r197744", "tree": {"sha": "ddb6615dde6578ad9a5716a43b0cfd7e81e1672d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddb6615dde6578ad9a5716a43b0cfd7e81e1672d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/354c3840c8ff64c615c7365c5b0c1b04d2a38189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354c3840c8ff64c615c7365c5b0c1b04d2a38189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354c3840c8ff64c615c7365c5b0c1b04d2a38189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354c3840c8ff64c615c7365c5b0c1b04d2a38189/comments", "author": null, "committer": null, "parents": [{"sha": "f0defe58a55705a34cb07a4d12667c2b6008ed11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0defe58a55705a34cb07a4d12667c2b6008ed11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0defe58a55705a34cb07a4d12667c2b6008ed11"}], "stats": {"total": 302, "additions": 226, "deletions": 76}, "files": [{"sha": "9118864486d4c8a0bd6879bc0c5042e5338a3686", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -1,3 +1,25 @@\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-osprim-mingw.adb, sem_ch3.adb, sem_prag.adb, sem_util.adb.\n+\tmakeutl.adb, sem_ch8.adb: Minor reformatting.\n+\n+2013-04-11  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor fixes for VMS.\n+\t* ug_words: Minor addition: -gnato? => /OVERFLOW_CHECKS=?.\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* usage.adb (Usage): Minor edit to -gnatW message\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_aggr.adb (Expand_N_Aggregate): Add circuit for handling\n+\tothers for string literal case. Also add big ??? comment about\n+\tthis new code, which should be redundant, but is not.\n+\t* sem_eval.adb (Eval_Concatenation): Handle non-static case\n+\tproperly (Eval_String_Literal): Handle non-static literal properly\n+\n 2013-03-20  Tobias Burnus  <burnus@net-b.de>\n \n \t* i-fortra.ads: Update comment, add Ada 2012's optional"}, {"sha": "ab4236645274382fd6cbdd183a067d3a7d1fdc7a", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,6 +59,7 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -5160,9 +5161,100 @@ package body Exp_Aggr is\n \n    procedure Expand_N_Aggregate (N : Node_Id) is\n    begin\n+      --  Record aggregate case\n+\n       if Is_Record_Type (Etype (N)) then\n          Expand_Record_Aggregate (N);\n+\n+      --  Array aggregate case\n+\n       else\n+         --  A special case, if we have a string subtype with bounds 1 .. N,\n+         --  where N is known at compile time, and the aggregate is of the\n+         --  form (others => 'x'), and N is less than 80 (an arbitrary limit\n+         --  for now), then replace the aggregate by the equivalent string\n+         --  literal (but do not mark it as static since it is not!)\n+\n+         --  Note: this entire circuit is redundant with respect to code in\n+         --  Expand_Array_Aggregate that collapses others choices to positional\n+         --  form, but there are two problems with that circuit:\n+\n+         --    a) It is limited to very small cases due to ill-understood\n+         --       interations with bootstrapping. That limit is removed by\n+         --       use of the No_Implicit_Loops restriction.\n+\n+         --    b) It erroneously ends up with the resulting expressions being\n+         --       considered static when they are not. For example, the\n+         --       following test should fail:\n+\n+         --           pragma Restrictions (No_Implicit_Loops);\n+         --           package NonSOthers4 is\n+         --              B  : constant String (1 .. 6) := (others => 'A');\n+         --              DH : constant String (1 .. 8) := B & \"BB\";\n+         --              X : Integer;\n+         --              pragma Export (C, X, Link_Name => DH);\n+         --           end;\n+\n+         --       But it succeeds (DH looks static to pragma Export)\n+\n+         --    To be sorted out! ???\n+\n+         if Present (Component_Associations (N)) then\n+            declare\n+               CA : constant Node_Id := First (Component_Associations (N));\n+               MX : constant         := 80;\n+\n+            begin\n+               if Nkind (First (Choices (CA))) = N_Others_Choice\n+                 and then Nkind (Expression (CA)) = N_Character_Literal\n+               then\n+                  declare\n+                     T  : constant Entity_Id := Etype (N);\n+                     X  : constant Node_Id   := First_Index (T);\n+                     EC : constant Node_Id   := Expression (CA);\n+                     CV : constant Uint      := Char_Literal_Value (EC);\n+                     CC : constant Int       := UI_To_Int (CV);\n+\n+                  begin\n+                     if Nkind (X) = N_Range\n+                       and then Compile_Time_Known_Value (Low_Bound (X))\n+                       and then Expr_Value (Low_Bound (X)) = 1\n+                       and then Compile_Time_Known_Value (High_Bound (X))\n+                     then\n+                        declare\n+                           Hi : constant Uint := Expr_Value (High_Bound (X));\n+\n+                        begin\n+                           if Hi <= MX then\n+                              Start_String;\n+\n+                              for J in 1 .. UI_To_Int (Hi) loop\n+                                 Store_String_Char (Char_Code (CC));\n+                              end loop;\n+\n+                              Rewrite (N,\n+                                Make_String_Literal (Sloc (N),\n+                                  Strval => End_String));\n+\n+                              if CC >= Int (2 ** 16) then\n+                                 Set_Has_Wide_Wide_Character (N);\n+                              elsif CC >= Int (2 ** 8) then\n+                                 Set_Has_Wide_Character (N);\n+                              end if;\n+\n+                              Analyze_And_Resolve (N, T);\n+                              Set_Is_Static_Expression (N, False);\n+                              return;\n+                           end if;\n+                        end;\n+                     end if;\n+                  end;\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Not that special case, so normal expansion of array aggregate\n+\n          Expand_Array_Aggregate (N);\n       end if;\n    exception"}, {"sha": "ad48a2193f09a163a4aa4209c3de6c57e89b9a28", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -4419,7 +4419,7 @@ cases; if two digits are given, then the first applies outside\n assertions, and the second within assertions.\n \n If no digits follow the @option{-gnato}, then it is equivalent to\n-@option{-gnato11},\n+@option{^-gnato11^/OVERFLOW_CHECKS=11^},\n causing all intermediate overflows to be handled in strict mode.\n \n This switch also causes arithmetic overflow checking to be performed\n@@ -7059,8 +7059,7 @@ with the use of @option{-gnato} in previous versions of GNAT.\n \n @findex Machine_Overflows\n Note that the @option{-gnato??} switch does not affect the code generated\n-for any floating-point operations; it applies only to integer\n-semantics.\n+for any floating-point operations; it applies only to integer semantics.\n For floating-point, @value{EDITION} has the @code{Machine_Overflows}\n attribute set to @code{False} and the normal mode of operation is to\n generate IEEE NaN and infinite values on overflow or invalid operations\n@@ -7074,13 +7073,13 @@ subscript), or a wild jump (from an out of range case value). Overflow\n checking is also quite expensive in time and space, since in general it\n requires the use of double length arithmetic.\n \n-Note again that the default is @option{-gnato00}, so overflow checking is\n-not performed in default mode. This means that out of the box, with the\n-default settings, @value{EDITION} does not do all the checks expected from the\n-language description in the Ada Reference Manual. If you want all constraint\n-checks to be performed, as described in this Manual, then you must\n-explicitly use the @option{-gnato??} switch either on the @command{gnatmake} or\n-@command{gcc} command.\n+Note again that the default is @option{^-gnato00^/OVERFLOW_CHECKS=00^},\n+so overflow checking is not performed in default mode. This means that out of\n+the box, with the default settings, @value{EDITION} does not do all the checks\n+expected from the language description in the Ada Reference Manual.\n+If you want all constraint checks to be performed, as described in this Manual,\n+then you must explicitly use the @option{-gnato??}\n+switch either on the @command{gnatmake} or @command{gcc} command.\n \n @item -gnatE\n @cindex @option{-gnatE} (@command{gcc})\n@@ -18165,7 +18164,7 @@ the generated body sample to @var{n}.\n The default indentation is 3.\n \n @item ^-gnatyo^/ORDERED_SUBPROGRAMS^\n-@cindex @option{^-gnato^/ORDERED_SUBPROGRAMS^} (@command{gnatstub})\n+@cindex @option{^-gnatyo^/ORDERED_SUBPROGRAMS^} (@command{gnatstub})\n Order local bodies alphabetically. (By default local bodies are ordered\n in the same way as the corresponding local specs in the argument spec file.)\n \n@@ -25962,10 +25961,11 @@ eliminate intermediate overflows (@code{ELIMINATED})\n As with the pragma, if only one digit appears then it applies to all\n cases; if two digits are given, then the first applies outside\n assertions, and the second within assertions. Thus the equivalent\n-of the example pragma above would be @option{-gnato23}.\n+of the example pragma above would be\n+@option{^-gnato23^/OVERFLOW_CHECKS=23^}.\n \n If no digits follow the @option{-gnato}, then it is equivalent to\n-@option{-gnato11},\n+@option{^-gnato11^/OVERFLOW_CHECKS=11^},\n causing all intermediate operations to be computed using the base\n type (@code{STRICT} mode).\n "}, {"sha": "e2d6b84f6d7314a1a2d84b5e18db0ec8b0b8f11f", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -369,12 +369,12 @@ package body Makeutl is\n       Status : Boolean;\n       --  For call to Close\n \n-      Iter : Source_Iterator :=\n-        For_Each_Source\n-          (In_Tree           => Project_Tree,\n-           Language          => Name_Ada,\n-           Encapsulated_Libs => False,\n-           Locally_Removed   => False);\n+      Iter : Source_Iterator := For_Each_Source\n+                                  (In_Tree           => Project_Tree,\n+                                   Language          => Name_Ada,\n+                                   Encapsulated_Libs => False,\n+                                   Locally_Removed   => False);\n+\n       Source : Prj.Source_Id;\n \n    begin\n@@ -431,13 +431,14 @@ package body Makeutl is\n             --  found.\n \n             if ALI_Name /= No_File then\n+\n                --  Look in the project and the projects that are extending it\n                --  to find the real ALI file.\n \n                declare\n-                  ALI : constant String := Get_Name_String (ALI_Name);\n+                  ALI      : constant String := Get_Name_String (ALI_Name);\n+                  ALI_Path : Name_Id         := No_Name;\n \n-                  ALI_Path : Name_Id := No_Name;\n                begin\n                   loop\n                      --  For library projects, use the library ALI directory,\n@@ -462,6 +463,7 @@ package body Makeutl is\n                   end loop;\n \n                   if ALI_Path /= No_Name then\n+\n                      --  First line is the unit name\n \n                      Get_Name_String (ALI_Unit);\n@@ -475,7 +477,7 @@ package body Makeutl is\n \n                      exit when not OK;\n \n-                     --  Second line it the ALI file name\n+                     --  Second line is the ALI file name\n \n                      Get_Name_String (ALI_Name);\n                      Add_Char_To_Name_Buffer (ASCII.LF);\n@@ -488,7 +490,7 @@ package body Makeutl is\n \n                      exit when not OK;\n \n-                     --  Third line it the ALI path name\n+                     --  Third line is the ALI path name\n \n                      Get_Name_String (ALI_Path);\n                      Add_Char_To_Name_Buffer (ASCII.LF);\n@@ -576,8 +578,9 @@ package body Makeutl is\n                if Sw'Length >= 3\n                  and then (Sw (2) = 'I'\n                             or else (not For_Gnatbind\n-                                       and then (Sw (2) = 'L'\n-                                         or else Sw (2) = 'A')))\n+                                      and then (Sw (2) = 'L'\n+                                                 or else\n+                                                Sw (2) = 'A')))\n                then\n                   Start := 3;\n \n@@ -592,7 +595,7 @@ package body Makeutl is\n                              or else\n                            Sw (2 .. 3) = \"aI\"\n                              or else\n-                           (For_Gnatbind and then Sw (2 .. 3) = \"A=\"))\n+                               (For_Gnatbind and then Sw (2 .. 3) = \"A=\"))\n                then\n                   Start := 4;\n "}, {"sha": "a2c466406c4fef9585f9a38833cc5ec1d2fed88c", "filename": "gcc/ada/s-osprim-mingw.adb", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fs-osprim-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fs-osprim-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-mingw.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -68,17 +68,17 @@ package body System.OS_Primitives is\n \n    type Clock_Data_Access is access all Clock_Data;\n \n-   --  Two base clock buffers. This is used to be able to update a buffer\n-   --  while the other buffer is read. The point is that we do not want to\n-   --  use a lock inside the Clock routine for performance reasons. We still\n-   --  use a lock in the Get_Base_Time which is called very rarely. Current\n-   --  is a pointer, the pragma Atomic is there to ensure that the value can\n-   --  be set or read atomically. That's it, when Get_Base_Time has updated\n-   --  a buffer the switch to the new value is done by changing Current\n-   --  pointer.\n+   --  Two base clock buffers. This is used to be able to update a buffer while\n+   --  the other buffer is read. The point is that we do not want to use a lock\n+   --  inside the Clock routine for performance reasons. We still use a lock\n+   --  in the Get_Base_Time which is called very rarely. Current is a pointer,\n+   --  the pragma Atomic is there to ensure that the value can be set or read\n+   --  atomically. That's it, when Get_Base_Time has updated a buffer the\n+   --  switch to the new value is done by changing Current pointer.\n \n    First, Second : aliased Clock_Data;\n-   Current       : Clock_Data_Access := First'Access;\n+\n+   Current : Clock_Data_Access := First'Access;\n    pragma Atomic (Current);\n \n    --  The following signature is to detect change on the base clock data\n@@ -177,9 +177,11 @@ package body System.OS_Primitives is\n       epoch_1970     : constant := 16#19D_B1DE_D53E_8000#; -- win32 UTC epoch\n       system_time_ns : constant := 100;                    -- 100 ns per tick\n       Sec_Unit       : constant := 10#1#E9;\n-      Max_Elapsed    : constant LARGE_INTEGER :=\n+\n+      Max_Elapsed : constant LARGE_INTEGER :=\n                          LARGE_INTEGER (Tick_Frequency / 100_000);\n       --  Look for a precision of 0.01 ms\n+\n       Sig            : constant Signature_Type := Signature;\n \n       Loc_Ticks, Ctrl_Ticks : aliased LARGE_INTEGER;\n@@ -269,13 +271,14 @@ package body System.OS_Primitives is\n          end if;\n       end loop;\n \n-      New_Data.Base_Clock := Duration\n-        (Long_Long_Float ((New_Data.Base_Time - epoch_1970) * system_time_ns) /\n-           Long_Long_Float (Sec_Unit));\n+      New_Data.Base_Clock :=\n+        Duration\n+          (Long_Long_Float\n+            ((New_Data.Base_Time - epoch_1970) * system_time_ns) /\n+                                               Long_Long_Float (Sec_Unit));\n \n       --  At this point all the base values have been set into the new data\n-      --  record. We just change the pointer (atomic operation) to this new\n-      --  values.\n+      --  record. Change the pointer (atomic operation) to these new values.\n \n       Current := New_Data;\n       Data    := New_Data.all;"}, {"sha": "4c68109dd83b8cb993425e0b34655efdb8f6849b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -8347,7 +8347,6 @@ package body Sem_Ch3 is\n            and then Present (Full_View (T))\n          then\n             Analyze_And_Resolve (Expr, BDT, Suppress => Overflow_Check);\n-\n          else\n             Analyze_And_Resolve (Expr, BDT);\n          end if;"}, {"sha": "9ff423b36fc66831f5d79d9fb709c9cbfd82e627", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -2821,13 +2821,13 @@ package body Sem_Ch8 is\n            and then Entity (Prefix (Nam)) = Current_Scope\n            and then Chars (Selector_Name (Nam)) = Chars (New_S)\n          then\n-            if Overriding_Renamings then\n-               null;\n+            --  This is an error, but we overlook the error and accept the\n+            --  renaming if the special Overriding_Renamings mode is in effect.\n \n-            else\n+            if not Overriding_Renamings then\n                Error_Msg_NE\n-                  (\"implicit operation& is not visible (RM 8.3 (15))\",\n-                     Nam, Old_S);\n+                 (\"implicit operation& is not visible (RM 8.3 (15))\",\n+                  Nam, Old_S);\n             end if;\n          end if;\n "}, {"sha": "0ad0a4165713523b56a808a236a6357869bcd320", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1932,20 +1932,17 @@ package body Sem_Eval is\n \n          Set_Is_Static_Expression (N, Stat);\n \n-         if Stat then\n+         --  If left operand is the empty string, the result is the\n+         --  right operand, including its bounds if anomalous.\n \n-            --  If left operand is the empty string, the result is the\n-            --  right operand, including its bounds if anomalous.\n-\n-            if Left_Len = 0\n-              and then Is_Array_Type (Etype (Right))\n-              and then Etype (Right) /= Any_String\n-            then\n-               Set_Etype (N, Etype (Right));\n-            end if;\n-\n-            Fold_Str (N, Folded_Val, Static => True);\n+         if Left_Len = 0\n+           and then Is_Array_Type (Etype (Right))\n+           and then Etype (Right) /= Any_String\n+         then\n+            Set_Etype (N, Etype (Right));\n          end if;\n+\n+         Fold_Str (N, Folded_Val, Static => Stat);\n       end;\n    end Eval_Concatenation;\n \n@@ -3411,11 +3408,12 @@ package body Sem_Eval is\n       --  is too long, or it is null, and the lower bound is type'First. In\n       --  either case it is the upper bound that is out of range of the index\n       --  type.\n-\n       if Ada_Version >= Ada_95 then\n          if Root_Type (Bas) = Standard_String\n               or else\n             Root_Type (Bas) = Standard_Wide_String\n+              or else\n+            Root_Type (Bas) = Standard_Wide_Wide_String\n          then\n             Xtp := Standard_Positive;\n          else\n@@ -3428,24 +3426,54 @@ package body Sem_Eval is\n             Lo := Type_Low_Bound (Etype (First_Index (Typ)));\n          end if;\n \n+         --  Check for string too long\n+\n          Len := String_Length (Strval (N));\n \n          if UI_From_Int (Len) > String_Type_Len (Bas) then\n-            Apply_Compile_Time_Constraint_Error\n-              (N, \"string literal too long for}\", CE_Length_Check_Failed,\n-               Ent => Bas,\n-               Typ => First_Subtype (Bas));\n+\n+            --  Issue message. Note that this message is a warning if the\n+            --  string literal is not marked as static (happens in some cases\n+            --  of folding strings known at compile time, but not static).\n+            --  Furthermore in such cases, we reword the message, since there\n+            --  is no string literal in the source program!\n+\n+            if Is_Static_Expression (N) then\n+               Apply_Compile_Time_Constraint_Error\n+                 (N, \"string literal too long for}\", CE_Length_Check_Failed,\n+                  Ent => Bas,\n+                  Typ => First_Subtype (Bas));\n+            else\n+               Apply_Compile_Time_Constraint_Error\n+                 (N, \"string value too long for}\", CE_Length_Check_Failed,\n+                  Ent  => Bas,\n+                  Typ  => First_Subtype (Bas),\n+                  Warn => True);\n+            end if;\n+\n+         --  Test for null string not allowed\n \n          elsif Len = 0\n            and then not Is_Generic_Type (Xtp)\n            and then\n              Expr_Value (Lo) = Expr_Value (Type_Low_Bound (Base_Type (Xtp)))\n          then\n-            Apply_Compile_Time_Constraint_Error\n-              (N, \"null string literal not allowed for}\",\n-               CE_Length_Check_Failed,\n-               Ent => Bas,\n-               Typ => First_Subtype (Bas));\n+            --  Same specialization of message\n+\n+            if Is_Static_Expression (N) then\n+               Apply_Compile_Time_Constraint_Error\n+                 (N, \"null string literal not allowed for}\",\n+                  CE_Length_Check_Failed,\n+                  Ent => Bas,\n+                  Typ => First_Subtype (Bas));\n+            else\n+               Apply_Compile_Time_Constraint_Error\n+                 (N, \"null string value not allowed for}\",\n+                  CE_Length_Check_Failed,\n+                  Ent  => Bas,\n+                  Typ  => First_Subtype (Bas),\n+                  Warn => True);\n+            end if;\n          end if;\n       end if;\n    end Eval_String_Literal;\n@@ -4091,7 +4119,7 @@ package body Sem_Eval is\n       --  Note that we have to reset Is_Static_Expression both after the\n       --  analyze step (because Resolve will evaluate the literal, which\n       --  will cause semantic errors if it is marked as static), and after\n-      --  the Resolve step (since Resolve in some cases sets this flag).\n+      --  the Resolve step (since Resolve in some cases resets this flag).\n \n       Analyze (N);\n       Set_Is_Static_Expression (N, Static);"}, {"sha": "e60573eb8ae177f09c00f8af191a30acceec08e3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -5256,7 +5256,7 @@ package body Sem_Prag is\n \n             elsif not Effective\n               and then Warn_On_Redundant_Constructs\n-              and then not (Status = Suppressed or Suppress_All_Inlining)\n+              and then not (Status = Suppressed or else Suppress_All_Inlining)\n             then\n                if Inlining_Not_Possible (Subp) then\n                   Error_Msg_NE\n@@ -12434,12 +12434,14 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n             Check_No_Identifiers;\n+\n             Hint := First (Pragma_Argument_Associations (N));\n             while Present (Hint) loop\n                Check_Arg_Is_One_Of (Hint,\n                  Name_No_Unroll, Name_Unroll, Name_No_Vector, Name_Vector);\n                Next (Hint);\n             end loop;\n+\n             Check_Loop_Pragma_Placement;\n          end Loop_Optimize;\n "}, {"sha": "2e05690b55dfba34391ce47cb8c22ae245e9c53f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -12009,7 +12009,7 @@ package body Sem_Util is\n       function Is_Interface_Conversion (N : Node_Id) return Boolean;\n       --  Determine whether N is a construct of the form\n       --    Some_Type (Operand._tag'Address)\n-      --  This construct appears in the context of dispatching calls\n+      --  This construct appears in the context of dispatching calls.\n \n       function Reference_To (Obj : Node_Id) return Node_Id;\n       --  An explicit dereference is created when removing side-effects from"}, {"sha": "d450164ee4cb3b02a5657a322e3e7c5a0b179269", "filename": "gcc/ada/ug_words", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fug_words", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fug_words", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fug_words?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -94,6 +94,7 @@ gcc -c          ^ GNAT COMPILE\n -gnatn2         ^ /INLINE=PRAGMA_LEVEL_2\n -gnatN          ^ /INLINE=FULL\n -gnato          ^ /CHECKS=OVERFLOW\n+-gnato?         ^ /OVERFLOW_CHECKS=?\n -gnato??        ^ /OVERFLOW_CHECKS=??\n -gnatp          ^ /CHECKS=SUPPRESS_ALL\n -gnat-p         ^ /CHECKS=UNSUPPRESS_ALL"}, {"sha": "b69b34ab152376d60fba8eb4b856595790e4c38c", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354c3840c8ff64c615c7365c5b0c1b04d2a38189/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=354c3840c8ff64c615c7365c5b0c1b04d2a38189", "patch": "@@ -584,8 +584,8 @@ begin\n \n    --  Line for -gnatW switch\n \n-   Write_Switch_Char (\"W\");\n-   Write_Str (\"Wide character encoding method (\");\n+   Write_Switch_Char (\"W?\");\n+   Write_Str (\"Wide character encoding method (?=\");\n \n    for J in WC_Encoding_Method loop\n       Write_Char (WC_Encoding_Letters (J));"}]}