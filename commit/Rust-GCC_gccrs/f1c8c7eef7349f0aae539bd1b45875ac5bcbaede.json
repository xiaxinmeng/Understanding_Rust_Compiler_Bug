{"sha": "f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFjOGM3ZWVmNzM0OWYwYWFlNTM5YmQxYjQ1ODc1YWM1YmNiYWVkZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-11-25T13:37:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-11-25T13:37:12Z"}, "message": "decl.c (gnat_to_gnu_entity): If the type has strict alignment...\n\n\t* decl.c (gnat_to_gnu_entity) <E_Record_Type>: If the type has\n\tstrict alignment, no alignment clause and a known static size, cap\n\tthe type alignment to the greatest power of 2 factor of the size.\n\t(gnat_to_gnu_field): If the field has a component clause, is aliased\n\tor of a type with strict alignment, require that its size be equal to\n\tthat of the type.\n\t(validate_size): Use the type size as the minimum size for a type with\n\tstrict alignment.\n\nFrom-SVN: r130406", "tree": {"sha": "c2f30f08a620652b6703d34c9395cbbceb397f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2f30f08a620652b6703d34c9395cbbceb397f12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/comments", "author": null, "committer": null, "parents": [{"sha": "64f6a0efdfa5c03132c45952bd1986a8adc2c19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f6a0efdfa5c03132c45952bd1986a8adc2c19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64f6a0efdfa5c03132c45952bd1986a8adc2c19d"}], "stats": {"total": 233, "additions": 205, "deletions": 28}, "files": [{"sha": "4f229ba34a4aeca2486bb7275ce9ab02ab764c8e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "patch": "@@ -1,3 +1,14 @@\n+2007-11-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (gnat_to_gnu_entity) <E_Record_Type>: If the type has\n+\tstrict alignment, no alignment clause and a known static size, cap\n+\tthe type alignment to the greatest power of 2 factor of the size.\n+\t(gnat_to_gnu_field): If the field has a component clause, is aliased\n+\tor of a type with strict alignment, require that its size be equal to\n+\tthat of the type.\n+\t(validate_size): Use the type size as the minimum size for a type with\n+\tstrict alignment.\n+\n 2007-11-23  Samuel Tardieu  <sam@rfc1149.net>\n \n \t* s-inmaop-posix.adb, s-intman-vxworks.adb, s-taprop-hpux-dce.adb,"}, {"sha": "8cac29a5c99141bc907b151496be4f47dc4552a1", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "patch": "@@ -2405,12 +2405,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_field;\n \ttree gnu_field_list = NULL_TREE;\n \ttree gnu_get_parent;\n+\t/* Set PACKED in keeping with gnat_to_gnu_field.  */\n \tint packed\n \t  = Is_Packed (gnat_entity)\n \t    ? 1\n \t    : Component_Alignment (gnat_entity) == Calign_Storage_Unit\n \t      ? -1\n-\t      : Known_Alignment (gnat_entity)\n+\t      : (Known_Alignment (gnat_entity)\n+\t\t || (Strict_Alignment (gnat_entity)\n+\t\t     && Known_Static_Esize (gnat_entity)))\n \t\t? -2\n \t\t: 0;\n \tbool has_rep = Has_Specified_Layout (gnat_entity);\n@@ -2466,6 +2469,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (Is_Atomic (gnat_entity))\n \t  TYPE_ALIGN (gnu_type)\n \t    = esize >= BITS_PER_WORD ? BITS_PER_WORD : ceil_alignment (esize);\n+\t/* If a type needs strict alignment, the minimum size will be the\n+\t   type size instead of the RM size (see validate_size).  Cap the\n+\t   alignment, lest it causes this type size to become too large.  */\n+\telse if (Strict_Alignment (gnat_entity)\n+\t\t && Known_Static_Esize (gnat_entity))\n+\t  {\n+\t    unsigned int raw_size = UI_To_Int (Esize (gnat_entity));\n+\t    TYPE_ALIGN (gnu_type)\n+\t      = MIN (BIGGEST_ALIGNMENT, raw_size & -raw_size);\n+\t  }\n \telse\n \t  TYPE_ALIGN (gnu_type) = 0;\n \n@@ -5709,38 +5722,32 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t consistent with the alignment.  */\n       if (needs_strict_alignment)\n \t{\n-\t  tree gnu_rounded_size = round_up (rm_size (gnu_field_type),\n-\t\t\t\t\t    TYPE_ALIGN (gnu_field_type));\n-\n \t  TYPE_ALIGN (gnu_record_type)\n \t    = MAX (TYPE_ALIGN (gnu_record_type), TYPE_ALIGN (gnu_field_type));\n \n-\t  /* If Atomic, the size must match exactly that of the field.  */\n-\t  if ((Is_Atomic (gnat_field) || Is_Atomic (Etype (gnat_field)))\n+\t  if (gnu_size\n \t      && !operand_equal_p (gnu_size, TYPE_SIZE (gnu_field_type), 0))\n \t    {\n-\t      post_error_ne_tree\n-\t\t(\"atomic field& must be natural size of type{ (^)}\",\n-\t\t Last_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t TYPE_SIZE (gnu_field_type));\n+\t      if (Is_Atomic (gnat_field) || Is_Atomic (Etype (gnat_field)))\n+\t\tpost_error_ne_tree\n+\t\t  (\"atomic field& must be natural size of type{ (^)}\",\n+\t\t   Last_Bit (Component_Clause (gnat_field)), gnat_field,\n+\t\t   TYPE_SIZE (gnu_field_type));\n+\n+\t      else if (Is_Aliased (gnat_field))\n+\t\tpost_error_ne_tree\n+\t\t  (\"size of aliased field& must be ^ bits\",\n+\t\t   Last_Bit (Component_Clause (gnat_field)), gnat_field,\n+\t\t   TYPE_SIZE (gnu_field_type));\n \n-\t      gnu_size = NULL_TREE;\n-\t    }\n+\t      else if (Strict_Alignment (Etype (gnat_field)))\n+\t\tpost_error_ne_tree\n+\t\t  (\"size of & with aliased or tagged components not ^ bits\",\n+\t\t   Last_Bit (Component_Clause (gnat_field)), gnat_field,\n+\t\t   TYPE_SIZE (gnu_field_type));\n \n-\t  /* If Aliased, the size must match exactly the rounded size.  We\n-\t     used to be more accommodating here and accept greater sizes, but\n-\t     fully supporting this case on big-endian platforms would require\n-\t     switching to a more involved layout for the field.  */\n-\t  else if (Is_Aliased (gnat_field)\n-\t\t   && gnu_size\n-\t\t   && ! operand_equal_p (gnu_size, gnu_rounded_size, 0))\n-\t    {\n-\t      post_error_ne_tree\n-\t\t(\"size of aliased field& must be ^ bits\",\n-\t\t Last_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t gnu_rounded_size);\n \t      gnu_size = NULL_TREE;\n-  \t    }\n+\t    }\n \n \t  if (!integer_zerop (size_binop\n \t\t\t      (TRUNC_MOD_EXPR, gnu_pos,\n@@ -5763,6 +5770,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   (\"position of & with aliased or tagged components not multiple of ^ bits\",\n \t\t   First_Bit (Component_Clause (gnat_field)), gnat_field,\n \t\t   TYPE_ALIGN (gnu_field_type));\n+\n \t      else\n \t\tgcc_unreachable ();\n \n@@ -6479,9 +6487,15 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n \t       enum tree_code kind, bool component_p, bool zero_ok)\n {\n   Node_Id gnat_error_node;\n-  tree type_size\n-    = kind == VAR_DECL ? TYPE_SIZE (gnu_type) : rm_size (gnu_type);\n-  tree size;\n+  tree type_size, size;\n+\n+  if (kind == VAR_DECL\n+      /* If a type needs strict alignment, a component of this type in\n+\t a packed record cannot be packed and thus uses the type size.  */\n+      || (kind == TYPE_DECL && Strict_Alignment (gnat_object)))\n+    type_size = TYPE_SIZE (gnu_type);\n+  else\n+    type_size = rm_size (gnu_type);\n \n   /* Find the node to use for errors.  */\n   if ((Ekind (gnat_object) == E_Component"}, {"sha": "6c4f2ac860a16a8cd79e5cf9a85608362637f965", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "patch": "@@ -1,3 +1,9 @@\n+2007-11-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/size_clause1.ads: New test.\n+\t* gnat.dg/specs/size_clause2.ads: Likewise.\n+\t* gnat.dg/specs/size_clause3.ads: Likewise.\n+\n 2007-11-25  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33499"}, {"sha": "5b8417ea79f8ff99648878f5dc80704b5ed04654", "filename": "gcc/testsuite/gnat.dg/specs/size_clause1.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause1.ads?ref=f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "patch": "@@ -0,0 +1,48 @@\n+-- { dg-do compile }\n+\n+package Size_Clause1 is\n+\n+  -- The record inherits the alignment of Integer, which is 4, so\n+  -- the real size is 64 instead of 40.  That's OK, as long as the\n+  -- size of a component of type R1 in a packed record is 40.\n+  type R1 is record\n+    I : Integer;\n+    B : Boolean;\n+  end record;\n+  for R1'Size use 40;\n+\n+  type S1 is record\n+    rr : R1; -- size must be 40\n+  end record;\n+  pragma Pack(S1);\n+\n+  -- The record is explicitly given alignment 1 so its real type is 40 too.\n+  -- The size of a component of type R2 in a packed record is naturally 40.\n+  type R2 is record\n+    I : Integer;\n+    B : Boolean;\n+  end record;\n+  for R2'Size use 40;\n+  for R2'Alignment use 1;\n+\n+  type S2 is record\n+    rr : R2; -- size must be 40\n+  end record;\n+  pragma Pack(S2);\n+\n+  -- The record is explicitly given alignment 4 so its real type is 64.\n+  -- That's OK, as long as the size of a component of type R3 in a packed\n+  -- record is 40.\n+  type R3 is record\n+    I : Integer;\n+    B : Boolean;\n+  end record;\n+  for R3'Size use 40;\n+  for R3'Alignment use 4;\n+\n+  type S3 is record\n+    rr : R3; -- size must be 40\n+  end record;\n+  pragma Pack(S3);\n+\n+end Size_Clause1;"}, {"sha": "957d3920f7560fa151f7f21aa1f26c708e39b297", "filename": "gcc/testsuite/gnat.dg/specs/size_clause2.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause2.ads?ref=f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "patch": "@@ -0,0 +1,48 @@\n+-- { dg-do compile }\n+\n+package Size_Clause2 is\n+\n+  -- The alignment of the record is capped to the greatest power of 2\n+  -- factor of the size, so that the real size is 40 too and the size\n+  -- of a component of type R1 in a packed record can be 40.\n+  type R1 is record\n+    I : Integer;\n+    B : aliased Boolean;\n+  end record;\n+  for R1'Size use 40;\n+\n+  type S1 is record\n+    rr : R1; -- size must be 40\n+  end record;\n+  pragma Pack(S1);\n+\n+  -- The record is explicitly given alignment 1 so its real type is 40 too.\n+  -- The size of a component of type R2 in a packed record is naturally 40.\n+  type R2 is record\n+    I : Integer;\n+    B : aliased Boolean;\n+  end record;\n+  for R2'Size use 40;\n+  for R2'Alignment use 1;\n+\n+  type S2 is record\n+    rr : R2; -- size must be 40\n+  end record;\n+  pragma Pack(S2);\n+\n+  -- The record is explicitly given alignment 4 so its real type is 64.\n+  -- That's not OK, because the size of a component of type R3 in a packed\n+  -- record cannot be 40 so the size clause is violated.\n+  type R3 is record\n+    I : Integer;\n+    B : aliased Boolean;\n+  end record;\n+  for R3'Size use 40;  -- { dg-error \"size for .R3. too small\" }\n+  for R3'Alignment use 4;\n+\n+  type S3 is record\n+    rr : R3; -- size must be 40\n+  end record;\n+  pragma Pack(S3);\n+\n+end Size_Clause2;"}, {"sha": "6a89114e417db8670cba08d45bb3dbd07fb2f8d7", "filename": "gcc/testsuite/gnat.dg/specs/size_clause3.ads", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c8c7eef7349f0aae539bd1b45875ac5bcbaede/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads?ref=f1c8c7eef7349f0aae539bd1b45875ac5bcbaede", "patch": "@@ -0,0 +1,50 @@\n+-- { dg-do compile }\n+\n+package Size_Clause3 is\n+\n+  -- The record inherits the alignment of Integer, which is 4, so\n+  -- the real size is 64 instead of 40.\n+  type R1 is record\n+    I : Integer;\n+    B : aliased Boolean;\n+  end record;\n+\n+  -- That's not OK, the size of a component of type R1 cannot be 40.\n+  type S1 is record\n+    rr : R1; -- size must be 40\n+  end record;\n+  for S1 use record\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size of .rr. with aliased or tagged component\" }\n+  end record;\n+\n+  -- The record is explicitly given alignment 1 so its real type is 40.\n+  type R2 is record\n+    I : Integer;\n+    B : aliased Boolean;\n+  end record;\n+  for R2'Alignment use 1;\n+\n+  -- That's OK, the size of a component of type R2 can be 40.\n+  type S2 is record\n+    rr : R2; -- size must be 40\n+  end record;\n+  for S2 use record\n+    rr at 0 range 0 .. 39;\n+  end record;\n+\n+  -- The record is explicitly given alignment 4 so its real type is 64.\n+  type R3 is record\n+    I : Integer;\n+    B : aliased Boolean;\n+  end record;\n+  for R3'Alignment use 4;\n+\n+  -- That's not OK, the size of a component of type R3 cannot be 40.\n+  type S3 is record\n+    rr : R3; -- size must be 40\n+  end record;\n+  for S3 use record\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size of .rr. with aliased or tagged component\" }\n+  end record;\n+\n+end Size_Clause3;"}]}