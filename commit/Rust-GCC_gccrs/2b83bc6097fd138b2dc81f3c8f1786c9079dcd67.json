{"sha": "2b83bc6097fd138b2dc81f3c8f1786c9079dcd67", "node_id": "C_kwDOANBUbNoAKDJiODNiYzYwOTdmZDEzOGIyZGM4MWYzYzhmMTc4NmM5MDc5ZGNkNjc", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-30T13:21:55Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-12-01T15:00:33Z"}, "message": "libstdc++: Optimize ref-count updates in COW std::string\n\nMost ref-count updates in the COW string are done via the functions in\n<ext/atomicity.h>, which will use non-atomic ops when the program is\nknown to be single-threaded. The _M_is_leaked() and _M_is_shared()\nfunctions use __atomic_load_n directly, because <ext/atomicity.h>\ndoesn't provide a load operation. Those functions can check the\n__is_single_threaded() predicate to avoid using __atomic_load_n when not\nneeded.\n\nThe move constructor for the fully-dynamic-string increments the\nref-count by either 2 or 1, for leaked or non-leaked strings\nrespectively. That can be changed to use a non-atomic store of 1 for all\nnon-shared strings. It can be non-atomic because even if the program is\nmulti-threaded, conflicting access to the rvalue object while it's being\nmoved from would be data race anyway. It can store 1 directly for all\nnon-shared strings because it doesn't matter whether the initial\nrefcount was -1 or 0, it should be 1 after the move constructor creates\na second owner.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/cow_string.h (basic_string::_M_is_leaked): Use\n\tnon-atomic load when __is_single_threaded() is true.\n\t(basic_string::_M_is_shared): Likewise.\n\t(basic_string::(basic_string&&)) [_GLIBCXX_FULLY_DYNAMIC_STRING]:\n\tUse non-atomic store when rvalue is not shared.", "tree": {"sha": "498c118b433c6e829527fcc98f497bd785cb862d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/498c118b433c6e829527fcc98f497bd785cb862d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b83bc6097fd138b2dc81f3c8f1786c9079dcd67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b83bc6097fd138b2dc81f3c8f1786c9079dcd67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b83bc6097fd138b2dc81f3c8f1786c9079dcd67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b83bc6097fd138b2dc81f3c8f1786c9079dcd67/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9089e4fa9f726405a83d8ce46baeda469ca1a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9089e4fa9f726405a83d8ce46baeda469ca1a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9089e4fa9f726405a83d8ce46baeda469ca1a1d"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "4fae1d02981004231c5100760ca334b29c1d1fa7", "filename": "libstdc++-v3/include/bits/cow_string.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b83bc6097fd138b2dc81f3c8f1786c9079dcd67/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcow_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b83bc6097fd138b2dc81f3c8f1786c9079dcd67/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcow_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcow_string.h?ref=2b83bc6097fd138b2dc81f3c8f1786c9079dcd67", "patch": "@@ -105,7 +105,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  destroy the empty-string _Rep object.\n    *\n    *  All but the last paragraph is considered pretty conventional\n-   *  for a C++ string implementation.\n+   *  for a Copy-On-Write C++ string implementation.\n   */\n   // 21.3  Template class basic_string\n   template<typename _CharT, typename _Traits, typename _Alloc>\n@@ -207,10 +207,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // so we need to use an atomic load. However, _M_is_leaked\n \t  // predicate does not change concurrently (i.e. the string is either\n \t  // leaked or not), so a relaxed load is enough.\n-\t  return __atomic_load_n(&this->_M_refcount, __ATOMIC_RELAXED) < 0;\n-#else\n-\t  return this->_M_refcount < 0;\n+\t  if (!__gnu_cxx::__is_single_threaded())\n+\t    return __atomic_load_n(&this->_M_refcount, __ATOMIC_RELAXED) < 0;\n #endif\n+\t  return this->_M_refcount < 0;\n \t}\n \n \tbool\n@@ -222,10 +222,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // but one reference concurrently with this check, so we need this\n \t  // load to be acquire to synchronize with release fetch_and_add in\n \t  // _M_dispose.\n-\t  return __atomic_load_n(&this->_M_refcount, __ATOMIC_ACQUIRE) > 0;\n-#else\n-\t  return this->_M_refcount > 0;\n+\t  if (!__gnu_cxx::__is_single_threaded())\n+\t    return __atomic_load_n(&this->_M_refcount, __ATOMIC_ACQUIRE) > 0;\n #endif\n+\t  return this->_M_refcount > 0;\n \t}\n \n \tvoid\n@@ -629,12 +629,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #else\n \t// Rather than allocate an empty string for the rvalue string,\n \t// just share ownership with it by incrementing the reference count.\n-\t// If the rvalue string was \"leaked\" then it was the unique owner,\n-\t// so need an extra increment to indicate shared ownership.\n-\tif (_M_rep()->_M_is_leaked())\n-\t  __gnu_cxx::__atomic_add_dispatch(&_M_rep()->_M_refcount, 2);\n-\telse\n+\t// If the rvalue string was the unique owner then there are exactly\n+\t// two owners now.\n+\tif (_M_rep()->_M_is_shared())\n \t  __gnu_cxx::__atomic_add_dispatch(&_M_rep()->_M_refcount, 1);\n+\telse\n+\t  _M_rep()->_M_refcount = 1;\n #endif\n       }\n "}]}