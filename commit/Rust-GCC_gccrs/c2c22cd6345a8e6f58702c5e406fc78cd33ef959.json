{"sha": "c2c22cd6345a8e6f58702c5e406fc78cd33ef959", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJjMjJjZDYzNDVhOGU2ZjU4NzAyYzVlNDA2ZmM3OGNkMzNlZjk1OQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-12-20T04:17:58Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-12-20T04:17:58Z"}, "message": "combine.c (try_combine): Improve splitting of binary operators by taking advantage of reassociative...\n\n\n\t* combine.c (try_combine): Improve splitting of binary operators\n\tby taking advantage of reassociative transformations.\n\nFrom-SVN: r108834", "tree": {"sha": "1121e7afb1420aa893aff3d3c880fafde6862df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1121e7afb1420aa893aff3d3c880fafde6862df0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2c22cd6345a8e6f58702c5e406fc78cd33ef959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2c22cd6345a8e6f58702c5e406fc78cd33ef959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2c22cd6345a8e6f58702c5e406fc78cd33ef959", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2c22cd6345a8e6f58702c5e406fc78cd33ef959/comments", "author": null, "committer": null, "parents": [{"sha": "ea65cd378bf9c6457a2a400e2f2fef92514d06bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea65cd378bf9c6457a2a400e2f2fef92514d06bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea65cd378bf9c6457a2a400e2f2fef92514d06bb"}], "stats": {"total": 72, "additions": 70, "deletions": 2}, "files": [{"sha": "b4890837d2cd2e47bd87ede3779a3efabed570da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2c22cd6345a8e6f58702c5e406fc78cd33ef959/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2c22cd6345a8e6f58702c5e406fc78cd33ef959/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2c22cd6345a8e6f58702c5e406fc78cd33ef959", "patch": "@@ -1,3 +1,8 @@\n+2005-12-19  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* combine.c (try_combine): Improve splitting of binary operators\n+\tby taking advantage of reassociative transformations.\n+\n 2005-12-19  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-dom.c (thread_across_edge): Do not use local_fold."}, {"sha": "afbf840127a20151d8478bf857cee211706a7b21", "filename": "gcc/combine.c", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2c22cd6345a8e6f58702c5e406fc78cd33ef959/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2c22cd6345a8e6f58702c5e406fc78cd33ef959/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c2c22cd6345a8e6f58702c5e406fc78cd33ef959", "patch": "@@ -2527,6 +2527,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  rtx newdest = i2dest;\n \t  enum rtx_code split_code = GET_CODE (*split);\n \t  enum machine_mode split_mode = GET_MODE (*split);\n+\t  bool subst_done = false;\n+\t  newi2pat = NULL_RTX;\n \n \t  /* Get NEWDEST as a register in the proper mode.  We have already\n \t     validated that we can do this.  */\n@@ -2572,8 +2574,69 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t    }\n #endif\n \n-\t  newi2pat = gen_rtx_SET (VOIDmode, newdest, *split);\n-\t  SUBST (*split, newdest);\n+\t  /* Attempt to split binary operators using arithmetic identities.  */\n+\t  if (BINARY_P (SET_SRC (newpat))\n+\t      && split_mode == GET_MODE (SET_SRC (newpat))\n+\t      && ! side_effects_p (SET_SRC (newpat)))\n+\t    {\n+\t      rtx setsrc = SET_SRC (newpat);\n+\t      enum machine_mode mode = GET_MODE (setsrc);\n+\t      enum rtx_code code = GET_CODE (setsrc);\n+\t      rtx src_op0 = XEXP (setsrc, 0);\n+\t      rtx src_op1 = XEXP (setsrc, 1);\n+\n+\t      /* Split \"X = Y op Y\" as \"Z = Y; X = Z op Z\".  */\n+\t      if (rtx_equal_p (src_op0, src_op1))\n+\t\t{\n+\t\t  newi2pat = gen_rtx_SET (VOIDmode, newdest, src_op0);\n+\t\t  SUBST (XEXP (setsrc, 0), newdest);\n+\t\t  SUBST (XEXP (setsrc, 1), newdest);\n+\t\t  subst_done = true;\n+\t\t}\n+\t      /* Split \"((P op Q) op R) op S\" where op is PLUS or MULT.  */\n+\t      else if ((code == PLUS || code == MULT)\n+\t\t       && GET_CODE (src_op0) == code\n+\t\t       && GET_CODE (XEXP (src_op0, 0)) == code\n+\t\t       && (INTEGRAL_MODE_P (mode)\n+\t\t\t   || (FLOAT_MODE_P (mode)\n+\t\t\t       && flag_unsafe_math_optimizations)))\n+\t\t{\n+\t\t  rtx p = XEXP (XEXP (src_op0, 0), 0);\n+\t\t  rtx q = XEXP (XEXP (src_op0, 0), 1);\n+\t\t  rtx r = XEXP (src_op0, 1);\n+\t\t  rtx s = src_op1;\n+\n+\t\t  /* Split both \"((X op Y) op X) op Y\" and\n+\t\t     \"((X op Y) op Y) op X\" as \"T op T\" where T is\n+\t\t     \"X op Y\".  */\n+\t\t  if ((rtx_equal_p (p,r) && rtx_equal_p (q,s))\n+\t\t       || (rtx_equal_p (p,s) && rtx_equal_p (q,r)))\n+\t\t    {\n+\t\t      newi2pat = gen_rtx_SET (VOIDmode, newdest,\n+\t\t\t\t\t      XEXP (src_op0, 0));\n+\t\t      SUBST (XEXP (setsrc, 0), newdest);\n+\t\t      SUBST (XEXP (setsrc, 1), newdest);\n+\t\t      subst_done = true;\n+\t\t    }\n+\t\t  /* Split \"((X op X) op Y) op Y)\" as \"T op T\" where\n+\t\t     T is \"X op Y\".  */\n+\t\t  else if (rtx_equal_p (p,q) && rtx_equal_p (r,s))\n+\t\t    {\n+\t\t      rtx tmp = simplify_gen_binary (code, mode, p, r);\n+\t\t      newi2pat = gen_rtx_SET (VOIDmode, newdest, tmp);\n+\t\t      SUBST (XEXP (setsrc, 0), newdest);\n+\t\t      SUBST (XEXP (setsrc, 1), newdest);\n+\t\t      subst_done = true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (!subst_done)\n+\t    {\n+\t      newi2pat = gen_rtx_SET (VOIDmode, newdest, *split);\n+\t      SUBST (*split, newdest);\n+\t    }\n+\n \t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n \t  /* recog_for_combine might have added CLOBBERs to newi2pat."}]}