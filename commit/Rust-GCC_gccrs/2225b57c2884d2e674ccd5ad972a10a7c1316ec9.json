{"sha": "2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIyNWI1N2MyODg0ZDJlNjc0Y2NkNWFkOTcyYTEwYTdjMTMxNmVjOQ==", "commit": {"author": {"name": "Carlos O'Donell", "email": "carlos@codesourcery.com", "date": "2006-04-04T16:19:59Z"}, "committer": {"name": "Carlos O'Donell", "email": "carlos@gcc.gnu.org", "date": "2006-04-04T16:19:59Z"}, "message": "tm.texi (TARGET_STRUCT_VALUE_RTX): Document new value 2 for incoming.\n\ngcc/\n\n2006-04-04  Carlos O'Donell  <carlos@codesourcery.com>\n\n\t* doc/tm.texi (TARGET_STRUCT_VALUE_RTX): Document\n\tnew value 2 for incoming.\n\t* function.c (expand_function_start): Call struct_value_rtx\n\twith incoming as 2.\n\t* config/sparc/sparc.md: Comment updated_return.\n\t* config/sparc/sparc.opt: Add -mstd-struct-return option.\n\t* config/sparc/sparc.c (sparc_struct_value_rtx): Use standard\n\tstruct return if sparc_std_struct_return and incoming is 2.\n\t(print_operand): Do not adjust return if\n\tsparc_std_struct_return.\n\ngcc/testsuite/\n\n2006-04-04  Carlos O'Donell  <carlos@codesourcery.com>\n\n\t* gcc.target/sparc/struct-ret-check.c: New test.\n\nFrom-SVN: r112672", "tree": {"sha": "320de322098272075404c4d8bf933e1c2b3bfa03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/320de322098272075404c4d8bf933e1c2b3bfa03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/comments", "author": null, "committer": null, "parents": [{"sha": "41ed243ff0f5c098b930eb3fcc333077b346348a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ed243ff0f5c098b930eb3fcc333077b346348a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41ed243ff0f5c098b930eb3fcc333077b346348a"}], "stats": {"total": 217, "additions": 208, "deletions": 9}, "files": [{"sha": "a9ad12d75f7791aaa061031fce85fa80b6e349cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -1,3 +1,16 @@\n+2006-04-04  Carlos O'Donell  <carlos@codesourcery.com>\n+\n+\t* doc/tm.texi (TARGET_STRUCT_VALUE_RTX): Document\n+\tnew value 2 for incoming.\n+\t* function.c (expand_function_start): Call struct_value_rtx\n+\twith incoming as 2.\n+\t* config/sparc/sparc.md: Comment updated_return.\n+\t* config/sparc/sparc.opt: Add -mstd-struct-return option.\n+\t* config/sparc/sparc.c (sparc_struct_value_rtx): Use standard\n+\tstruct return if sparc_std_struct_return and incoming is 2.\n+\t(print_operand): Do not adjust return if\n+\tsparc_std_struct_return.\n+\n 2006-04-04  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (fold_builtin_sprintf): Use fold_convert instead of"}, {"sha": "e880226412e0b726465c7de4f52c90a074ee9b6b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -5425,7 +5425,7 @@ sparc_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n    Return where to find the structure return value address.  */\n \n static rtx\n-sparc_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED, int incoming)\n+sparc_struct_value_rtx (tree fndecl, int incoming)\n {\n   if (TARGET_ARCH64)\n     return 0;\n@@ -5440,6 +5440,46 @@ sparc_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED, int incoming)\n \tmem = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t STRUCT_VALUE_OFFSET));\n \n+      /* Only follow the SPARC ABI for fixed-size structure returns. \n+         Variable size structure returns are handled per the normal \n+         procedures in GCC. This is enabled by -mstd-struct-return */\n+      if (incoming == 2 \n+\t  && sparc_std_struct_return\n+\t  && TYPE_SIZE_UNIT (TREE_TYPE (fndecl))\n+\t  && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (fndecl))) == INTEGER_CST)\n+\t{\n+\t  /* We must check and adjust the return address, as it is\n+\t     optional as to whether the return object is really\n+\t     provided.  */\n+\t  rtx ret_rtx = gen_rtx_REG (Pmode, 31);\n+\t  rtx scratch = gen_reg_rtx (SImode);\n+\t  rtx endlab = gen_label_rtx (); \n+\n+\t  /* Calculate the return object size */\n+\t  tree size = TYPE_SIZE_UNIT (TREE_TYPE (fndecl));\n+\t  rtx size_rtx = GEN_INT (TREE_INT_CST_LOW (size) & 0xfff);\n+\t  /* Construct a temporary return value */\n+\t  rtx temp_val = assign_stack_local (Pmode, TREE_INT_CST_LOW (size), 0);\n+\n+\t  /* Implement SPARC 32-bit psABI callee returns struck checking\n+\t     requirements: \n+\t    \n+\t      Fetch the instruction where we will return to and see if\n+\t     it's an unimp instruction (the most significant 10 bits\n+\t     will be zero).  */\n+\t  emit_move_insn (scratch, gen_rtx_MEM (SImode,\n+\t\t\t\t\t\tplus_constant (ret_rtx, 8)));\n+\t  /* Assume the size is valid and pre-adjust */\n+\t  emit_insn (gen_add3_insn (ret_rtx, ret_rtx, GEN_INT (4)));\n+\t  emit_cmp_and_jump_insns (scratch, size_rtx, EQ, const0_rtx, SImode, 0, endlab);\n+\t  emit_insn (gen_sub3_insn (ret_rtx, ret_rtx, GEN_INT (4)));\n+\t  /* Assign stack temp: \n+\t     Write the address of the memory pointed to by temp_val into\n+\t     the memory pointed to by mem */\n+\t  emit_move_insn (mem, XEXP (temp_val, 0));\n+\t  emit_label (endlab);\n+\t}\n+\n       set_mem_alias_set (mem, struct_value_alias_set);\n       return mem;\n     }\n@@ -6639,9 +6679,14 @@ print_operand (FILE *file, rtx x, int code)\n \t so we have to account for it.  This insn is used in the 32-bit ABI\n \t when calling a function that returns a non zero-sized structure. The\n \t 64-bit ABI doesn't have it.  Be careful to have this test be the same\n-\t as that used on the call.  */\n+\t as that used on the call. The exception here is that when \n+\t sparc_std_struct_return is enabled, the psABI is followed exactly\n+\t and the adjustment is made by the code in sparc_struct_value_rtx. \n+\t The call emitted is the same when sparc_std_struct_return is \n+\t present. */\n      if (! TARGET_ARCH64\n \t && current_function_returns_struct\n+\t && ! sparc_std_struct_return\n \t && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))\n \t     == INTEGER_CST)\n \t && ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl))))"}, {"sha": "ed68f1e8a1e52db41191ffc719bc23b885deaba1", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -7094,8 +7094,13 @@\n   DONE;\n })\n \n-;; This is a bit of a hack.  We're incrementing a fixed register (%i7),\n-;; and parts of the compiler don't want to believe that the add is needed.\n+;; Adjust the return address conditionally. If the value of op1 is equal\n+;; to all zero then adjust the return address i.e. op0 = op0 + 4.\n+;; This is technically *half* the check required by the 32-bit SPARC\n+;; psABI. This check only ensures that an \"unimp\" insn was written by\n+;; the caller, but doesn't check to see if the expected size matches\n+;; (this is encoded in the 12 lower bits). This check is obsolete and\n+;; only used by the above code \"untyped_return\".\n \n (define_insn \"update_return\"\n   [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")"}, {"sha": "8cdf11cf735db592bbed127dc07be9c296dffcce", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -99,6 +99,9 @@ mcmodel=\n Target RejectNegative Joined Var(sparc_cmodel_string)\n Use given SPARC-V9 code model\n \n+mstd-struct-return\n+Target Report RejectNegative Var(sparc_std_struct_return)\n+Enable strict 32-bit psABI struct return checking.\n \n Mask(LITTLE_ENDIAN)\n ;; Generate code for little-endian"}, {"sha": "69514e244ab21e7ffee50ba7516c603f9f4130ee", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -4187,12 +4187,15 @@ On some architectures the place where the structure value address\n is found by the called function is not the same place that the\n caller put it.  This can be due to register windows, or it could\n be because the function prologue moves it to a different place.\n-@var{incoming} is @code{true} when the location is needed in\n-the context of the called function, and @code{false} in the context of\n+@var{incoming} is @code{1} or @code{2} when the location is needed in\n+the context of the called function, and @code{0} in the context of\n the caller.\n \n-If @var{incoming} is @code{true} and the address is to be found on the\n-stack, return a @code{mem} which refers to the frame pointer.\n+If @var{incoming} is non-zero and the address is to be found on the\n+stack, return a @code{mem} which refers to the frame pointer. If\n+@var{incoming} is @code{2}, the result is being used to fetch the\n+structure value address at the beginning of a function.  If you need \n+to emit adjusting code, you should do it at this point.\n @end deftypefn\n \n @defmac PCC_STATIC_STRUCT_RETURN"}, {"sha": "3becef3183d80ba6c5d30f53394b7f022e766938", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -4120,7 +4120,7 @@ expand_function_start (tree subr)\n       else\n #endif\n \t{\n-\t  rtx sv = targetm.calls.struct_value_rtx (TREE_TYPE (subr), 1);\n+\t  rtx sv = targetm.calls.struct_value_rtx (TREE_TYPE (subr), 2);\n \t  /* Expect to be passed the address of a place to store the value.\n \t     If it is passed as an argument, assign_parms will take care of\n \t     it.  */"}, {"sha": "1872b3d7eeabbb1524631f1ae95378e4208eecb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -1,3 +1,7 @@\n+2006-04-04  Carlos O'Donell  <carlos@codesourcery.com>\n+\n+\t* gcc.target/sparc/struct-ret-check.c: New test.\n+\n 2006-04-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \t* gfortran.dg/fmt_zero_digits.f90: New test for no error when"}, {"sha": "350224eb667a30c656f2202a225d66858e615c35", "filename": "gcc/testsuite/gcc.target/sparc/struct-ret-check.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fstruct-ret-check.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225b57c2884d2e674ccd5ad972a10a7c1316ec9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fstruct-ret-check.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fstruct-ret-check.c?ref=2225b57c2884d2e674ccd5ad972a10a7c1316ec9", "patch": "@@ -0,0 +1,126 @@\n+/* Copyright (C) 2006 Free Software Foundation, Inc. */\n+/* Contributed by Carlos O'Donell on 2006-03-14 */\n+\n+/* Test that GCC follows the SPARC 32-bit psABI with regards to\n+   structure return checking in a callee. When -mstd-struct-return \n+   is specificed then gcc will emit code to skip the unimp insn. */ \n+\n+/* Origin: Carlos O'Donell <carlos@codesourcery.com> */\n+/* { dg-do run { target sparc*-*-solaris* sparc*-*-linux* sparc*-*-*bsd* } } */\n+/* { dg-options \"-mstd-struct-return\" } */\n+/* { dg-require-effective-target ilp32 } */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+/* Local declaration of div_t structure */\n+struct mydiv_t {\n+  int rem;\n+  int quot;\n+};\n+\n+/* Global check variable used by signal handler */\n+int check = 1;\n+struct mydiv_t dcheck;\n+\n+struct mydiv_t foo (void)\n+{\n+  struct mydiv_t bar;\n+  bar.rem = 3;\n+  bar.quot = 4;\n+  return bar;\n+}\n+\n+void handle_sigill (int signum)\n+{\n+  if (signum == SIGILL && check == 2)\n+    {\n+      /* We expected a SIGILL due to a mismatch in unimp size\n+\t and struct mydiv_t size */\n+      exit (0);\n+    }\n+  else\n+    abort ();\n+}\n+\n+/* Implement 3 checks to validate SPARC 32-bit psABI callee \n+   returns struct\n+   \n+   Test1: Save area is valid. unimp size is valid.\n+   Success: Save area modified correctly.\n+   Failure: Save area unmodified.\n+\n+   Test2: Save area is valid. unimp size is invalid (invalid insn).\n+   Success: Save area unmodified. check == 2.\n+   Failure: Save area modified or check == 1.\n+\n+   Test3: Save area is invalid. unimp size is invalid (invalid size).\n+   Success: Will raise a SIGILL. \n+   Failure: SIGSEGV caused by write to invalid save area. */\n+\n+int main (void)\n+{\n+  dcheck.rem = 1;\n+  dcheck.quot = 2;\n+\n+  /*** Test1 ***/\n+  /* Insert a call, insert unimp by hand */\n+  __asm__ (\"st %1, [ %%sp + 0x40 ]\\n\\t\"\n+\t   \"call foo\\n\\t\"\n+\t   \" nop\\n\\t\"\n+\t   \"unimp %2\\n\\t\" \n+\t   : \"=m\" (dcheck)\n+\t   : \"r\" (&dcheck), \"i\" (sizeof(struct mydiv_t)) \n+\t   : \"memory\");\n+\n+  /* If the caller doesn't adjust the return, then it crashes.\n+     Check the result too. */\n+\n+  if ((dcheck.rem != 3) || (dcheck.quot !=4))\n+    abort ();\n+  \n+\n+  /*** Test 2 ***/\n+  dcheck.rem = 1;\n+  dcheck.quot = 2;\n+\n+  /* Ignore the return of the function */\n+  __asm__ (\"st %3, [ %%sp + 0x40 ]\\n\\t\"\n+\t   \"call foo\\n\\t\"\n+\t   \" nop\\n\\t\"\n+\t   \"mov %2, %0\\n\\t\"\n+\t   : \"+r\" (check), \"=m\" (dcheck) \n+\t   : \"i\" (0x2), \"r\" (&dcheck)\n+\t   : \"memory\");\n+\n+  /* If the caller does an unconditional adjustment it will skip\n+     the mov, and then we can fail the test based on check's value \n+     We pass a valid pointer to a save area in order to check if \n+     caller incorrectly wrote to the save area aswell. There may\n+     be a case where the unimp check and skip is correct, but the\n+     write to the save area still occurs. */\n+\n+  if (check != 2)\n+    abort ();\n+\n+  if ((dcheck.rem != 1) || (dcheck.quot != 2))\n+    abort ();\n+\n+  /*** Test 3 ***/\n+  /* Prepare a test that must SIGILL. According to the spec\n+     if the sizes of the save area and return don't match then\n+     the copy is ignored and we return to the unimp. */\n+\n+  signal (SIGILL, handle_sigill);\n+\n+  __asm__ (\"st %%g0, [ %%sp + 0x40 ]\\n\\t\"\n+\t   \"call foo\\n\\t\"\n+\t   \" nop\\n\\t\"\n+\t   \"unimp %0\\n\\t\"\n+\t   : /* No outputs */ \n+\t   : \"i\" (sizeof(struct mydiv_t)-1) \n+\t   : \"memory\");\n+\n+  /* NEVER REACHED */\n+  exit (0);\n+}"}]}