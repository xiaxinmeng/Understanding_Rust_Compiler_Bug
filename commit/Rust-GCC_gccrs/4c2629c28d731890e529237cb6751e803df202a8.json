{"sha": "4c2629c28d731890e529237cb6751e803df202a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMyNjI5YzI4ZDczMTg5MGU1MjkyMzdjYjY3NTFlODAzZGYyMDJhOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-02-05T12:27:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-07T09:29:17Z"}, "message": "[Ada] Replace packed records with integers in low-level implementation\n\ngcc/ada/\n\n\t* atree.ads (Slot): Change to modular type.\n\t(Slot_1_Bit): Delete.\n\t(Slot_2_Bit): Likewise.\n\t(Slot_4_Bit): Likewise.\n\t(Slot_8_Bit): Likewise.\n\t(Slot_32_Bit): Likewise.\n\t* atree.adb (Get_1_Bit_Val): Adjust to above change.\n\t(Get_2_Bit_Val): Likewise.\n\t(Get_4_Bit_Val): Likewise.\n\t(Get_8_Bit_Val): Likewise.\n\t(Get_32_Bit_Val): Likewise.\n\t(Set_1_Bit_Val): Likewise.\n\t(Set_2_Bit_Val): Likewise.\n\t(Set_4_Bit_Val): Likewise.\n\t(Set_8_Bit_Val): Likewise.\n\t(Set_32_Bit_Val): Likewise.\n\t(Print_Atree_Info): Likewise.\n\t(Zero): Likewise.\n\t* atree.h (Get_1_Bit_Field): Likewise.\n\t(Get_2_Bit_Field): Likewise.\n\t(Get_4_Bit_Field): Likewise.\n\t(Get_8_Bit_Field): Likewise.\n\t(Get_32_Bit_Field): Likewise.\n\t(Get_32_Bit_Field_With_Default): Likewise.\n\t* types.h (slot_1_bit): Delete.\n\t(slot_2_bit): Likewise.\n\t(slot_4_bit): Likewise.\n\t(slot_8_bit): Likewise.\n\t(slot_32_bit): Likewise.\n\t(any_slot): Change to unsigned int.\n\t(Slot_Size): New macro.", "tree": {"sha": "370d0e97fae5af7c73f506ce90ec5609b0b16bd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/370d0e97fae5af7c73f506ce90ec5609b0b16bd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c2629c28d731890e529237cb6751e803df202a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2629c28d731890e529237cb6751e803df202a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2629c28d731890e529237cb6751e803df202a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2629c28d731890e529237cb6751e803df202a8/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17ba0ad5294f51c15dcf1e1a176b6f15d71e905e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ba0ad5294f51c15dcf1e1a176b6f15d71e905e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17ba0ad5294f51c15dcf1e1a176b6f15d71e905e"}], "stats": {"total": 490, "additions": 77, "deletions": 413}, "files": [{"sha": "cb58e665a441ad97ac7ac1b9963a43c0871104b1", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 31, "deletions": 159, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=4c2629c28d731890e529237cb6751e803df202a8", "patch": "@@ -599,119 +599,55 @@ package body Atree is\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_1_Bit\n       is\n          --  We wish we were using packed arrays, but instead we're simulating\n-         --  packed arrays using packed records. L here (and elsewhere) is the\n-         --  'Length of that array.\n-         L : constant Field_Offset := 32;\n+         --  them with modular integers. L here (and elsewhere) is the 'Length\n+         --  of that simulated array.\n+         L : constant Field_Offset := Slot_Size / 1;\n \n          pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => return S.Slot_1.F0;\n-            when 1 => return S.Slot_1.F1;\n-            when 2 => return S.Slot_1.F2;\n-            when 3 => return S.Slot_1.F3;\n-            when 4 => return S.Slot_1.F4;\n-            when 5 => return S.Slot_1.F5;\n-            when 6 => return S.Slot_1.F6;\n-            when 7 => return S.Slot_1.F7;\n-            when 8 => return S.Slot_1.F8;\n-            when 9 => return S.Slot_1.F9;\n-            when 10 => return S.Slot_1.F10;\n-            when 11 => return S.Slot_1.F11;\n-            when 12 => return S.Slot_1.F12;\n-            when 13 => return S.Slot_1.F13;\n-            when 14 => return S.Slot_1.F14;\n-            when 15 => return S.Slot_1.F15;\n-            when 16 => return S.Slot_1.F16;\n-            when 17 => return S.Slot_1.F17;\n-            when 18 => return S.Slot_1.F18;\n-            when 19 => return S.Slot_1.F19;\n-            when 20 => return S.Slot_1.F20;\n-            when 21 => return S.Slot_1.F21;\n-            when 22 => return S.Slot_1.F22;\n-            when 23 => return S.Slot_1.F23;\n-            when 24 => return S.Slot_1.F24;\n-            when 25 => return S.Slot_1.F25;\n-            when 26 => return S.Slot_1.F26;\n-            when 27 => return S.Slot_1.F27;\n-            when 28 => return S.Slot_1.F28;\n-            when 29 => return S.Slot_1.F29;\n-            when 30 => return S.Slot_1.F30;\n-            when 31 => return S.Slot_1.F31;\n-         end case;\n+         return Field_1_Bit (Shift_Right (S, V) and 1);\n       end Get_1_Bit_Val;\n \n       function Get_2_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_2_Bit\n       is\n-         L : constant Field_Offset := 16;\n+         L : constant Field_Offset := Slot_Size / 2;\n \n          pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => return S.Slot_2.F0;\n-            when 1 => return S.Slot_2.F1;\n-            when 2 => return S.Slot_2.F2;\n-            when 3 => return S.Slot_2.F3;\n-            when 4 => return S.Slot_2.F4;\n-            when 5 => return S.Slot_2.F5;\n-            when 6 => return S.Slot_2.F6;\n-            when 7 => return S.Slot_2.F7;\n-            when 8 => return S.Slot_2.F8;\n-            when 9 => return S.Slot_2.F9;\n-            when 10 => return S.Slot_2.F10;\n-            when 11 => return S.Slot_2.F11;\n-            when 12 => return S.Slot_2.F12;\n-            when 13 => return S.Slot_2.F13;\n-            when 14 => return S.Slot_2.F14;\n-            when 15 => return S.Slot_2.F15;\n-         end case;\n+         return Field_2_Bit (Shift_Right (S, V) and 3);\n       end Get_2_Bit_Val;\n \n       function Get_4_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_4_Bit\n       is\n-         L : constant Field_Offset := 8;\n+         L : constant Field_Offset := Slot_Size / 4;\n \n          pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => return S.Slot_4.F0;\n-            when 1 => return S.Slot_4.F1;\n-            when 2 => return S.Slot_4.F2;\n-            when 3 => return S.Slot_4.F3;\n-            when 4 => return S.Slot_4.F4;\n-            when 5 => return S.Slot_4.F5;\n-            when 6 => return S.Slot_4.F6;\n-            when 7 => return S.Slot_4.F7;\n-         end case;\n+         return Field_4_Bit (Shift_Right (S, V) and 15);\n       end Get_4_Bit_Val;\n \n       function Get_8_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_8_Bit\n       is\n-         L : constant Field_Offset := 4;\n+         L : constant Field_Offset := Slot_Size / 8;\n \n          pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => return S.Slot_8.F0;\n-            when 1 => return S.Slot_8.F1;\n-            when 2 => return S.Slot_8.F2;\n-            when 3 => return S.Slot_8.F3;\n-         end case;\n+         return Field_8_Bit (Shift_Right (S, V) and 255);\n       end Get_8_Bit_Val;\n \n       function Get_32_Bit_Val\n@@ -721,123 +657,59 @@ package body Atree is\n \n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset);\n       begin\n-         return S.Slot_32;\n+         return Field_32_Bit (S);\n       end Get_32_Bit_Val;\n \n       procedure Set_1_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_1_Bit)\n       is\n-         L : constant Field_Offset := 32;\n+         L : constant Field_Offset := Slot_Size / 1;\n \n          pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => S.Slot_1.F0 := Val;\n-            when 1 => S.Slot_1.F1 := Val;\n-            when 2 => S.Slot_1.F2 := Val;\n-            when 3 => S.Slot_1.F3 := Val;\n-            when 4 => S.Slot_1.F4 := Val;\n-            when 5 => S.Slot_1.F5 := Val;\n-            when 6 => S.Slot_1.F6 := Val;\n-            when 7 => S.Slot_1.F7 := Val;\n-            when 8 => S.Slot_1.F8 := Val;\n-            when 9 => S.Slot_1.F9 := Val;\n-            when 10 => S.Slot_1.F10 := Val;\n-            when 11 => S.Slot_1.F11 := Val;\n-            when 12 => S.Slot_1.F12 := Val;\n-            when 13 => S.Slot_1.F13 := Val;\n-            when 14 => S.Slot_1.F14 := Val;\n-            when 15 => S.Slot_1.F15 := Val;\n-            when 16 => S.Slot_1.F16 := Val;\n-            when 17 => S.Slot_1.F17 := Val;\n-            when 18 => S.Slot_1.F18 := Val;\n-            when 19 => S.Slot_1.F19 := Val;\n-            when 20 => S.Slot_1.F20 := Val;\n-            when 21 => S.Slot_1.F21 := Val;\n-            when 22 => S.Slot_1.F22 := Val;\n-            when 23 => S.Slot_1.F23 := Val;\n-            when 24 => S.Slot_1.F24 := Val;\n-            when 25 => S.Slot_1.F25 := Val;\n-            when 26 => S.Slot_1.F26 := Val;\n-            when 27 => S.Slot_1.F27 := Val;\n-            when 28 => S.Slot_1.F28 := Val;\n-            when 29 => S.Slot_1.F29 := Val;\n-            when 30 => S.Slot_1.F30 := Val;\n-            when 31 => S.Slot_1.F31 := Val;\n-         end case;\n+         S := (S and not Shift_Left (1, V)) or Shift_Left (Slot (Val), V);\n       end Set_1_Bit_Val;\n \n       procedure Set_2_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_2_Bit)\n       is\n-         L : constant Field_Offset := 16;\n+         L : constant Field_Offset := Slot_Size / 2;\n \n          pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => S.Slot_2.F0 := Val;\n-            when 1 => S.Slot_2.F1 := Val;\n-            when 2 => S.Slot_2.F2 := Val;\n-            when 3 => S.Slot_2.F3 := Val;\n-            when 4 => S.Slot_2.F4 := Val;\n-            when 5 => S.Slot_2.F5 := Val;\n-            when 6 => S.Slot_2.F6 := Val;\n-            when 7 => S.Slot_2.F7 := Val;\n-            when 8 => S.Slot_2.F8 := Val;\n-            when 9 => S.Slot_2.F9 := Val;\n-            when 10 => S.Slot_2.F10 := Val;\n-            when 11 => S.Slot_2.F11 := Val;\n-            when 12 => S.Slot_2.F12 := Val;\n-            when 13 => S.Slot_2.F13 := Val;\n-            when 14 => S.Slot_2.F14 := Val;\n-            when 15 => S.Slot_2.F15 := Val;\n-         end case;\n+         S := (S and not Shift_Left (3, V)) or Shift_Left (Slot (Val), V);\n       end Set_2_Bit_Val;\n \n       procedure Set_4_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_4_Bit)\n       is\n-         L : constant Field_Offset := 8;\n+         L : constant Field_Offset := Slot_Size / 4;\n \n          pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => S.Slot_4.F0 := Val;\n-            when 1 => S.Slot_4.F1 := Val;\n-            when 2 => S.Slot_4.F2 := Val;\n-            when 3 => S.Slot_4.F3 := Val;\n-            when 4 => S.Slot_4.F4 := Val;\n-            when 5 => S.Slot_4.F5 := Val;\n-            when 6 => S.Slot_4.F6 := Val;\n-            when 7 => S.Slot_4.F7 := Val;\n-         end case;\n+         S := (S and not Shift_Left (15, V)) or Shift_Left (Slot (Val), V);\n       end Set_4_Bit_Val;\n \n       procedure Set_8_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_8_Bit)\n       is\n-         L : constant Field_Offset := 4;\n+         L : constant Field_Offset := Slot_Size / 8;\n \n          pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n \n-         subtype Offset_In_Slot is Field_Offset range 0 .. L - 1;\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n+         V : constant Integer := Integer ((Offset mod L) * (Slot_Size / L));\n       begin\n-         case Offset_In_Slot'(Offset mod L) is\n-            when 0 => S.Slot_8.F0 := Val;\n-            when 1 => S.Slot_8.F1 := Val;\n-            when 2 => S.Slot_8.F2 := Val;\n-            when 3 => S.Slot_8.F3 := Val;\n-         end case;\n+         S := (S and not Shift_Left (255, V)) or Shift_Left (Slot (Val), V);\n       end Set_8_Bit_Val;\n \n       procedure Set_32_Bit_Val\n@@ -847,7 +719,7 @@ package body Atree is\n \n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset);\n       begin\n-         S.Slot_32 := Val;\n+         S := Slot (Val);\n       end Set_32_Bit_Val;\n \n    end Atree_Private_Part;\n@@ -2006,7 +1878,7 @@ package body Atree is\n    ----------------------\n \n    procedure Print_Atree_Info (N : Node_Or_Entity_Id) is\n-      function Cast is new Unchecked_Conversion (Slot_32_Bit, Int);\n+      function Cast is new Unchecked_Conversion (Slot, Int);\n    begin\n       Write_Int (Int (Size_In_Slots (N)));\n       Write_Str (\" slots (\");\n@@ -2017,7 +1889,7 @@ package body Atree is\n \n       for Off in Off_0 (N) .. Off_L (N) loop\n          Write_Str (\" \");\n-         Write_Int (Cast (Slots.Table (Off).Slot_32));\n+         Write_Int (Cast (Slots.Table (Off)));\n       end loop;\n \n       Write_Eol;\n@@ -2507,7 +2379,7 @@ package body Atree is\n       Locked := False;\n    end Unlock_Nodes;\n \n-   Zero : constant Slot := (Field_Size => 32, Slot_32 => 0);\n+   Zero : constant Slot := 0;\n \n    procedure Zero_Slots (F, L : Node_Offset) is\n    begin"}, {"sha": "d0184c7a568b8e5c087cc358c66a19e5cd9ddc12", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=4c2629c28d731890e529237cb6751e803df202a8", "patch": "@@ -722,57 +722,21 @@ package Atree is\n          Table_Increment      => Alloc.Node_Offsets_Increment,\n          Table_Name           => \"Node_Offsets\");\n \n-      --  We define type Slot as a packed Unchecked_Union of slots with\n-      --  appropriate numbers of components of appropriate size. The reason\n-      --  for this (as opposed to using packed arrays) is that we are using\n-      --  bit fields on the C++ side, and C++ doesn't have packed arrays.\n-\n-      type Field_1_Bit is mod 2**1;\n-      type Slot_1_Bit is record -- 32 1-bit fields\n-         F0, F1, F2, F3, F4, F5, F6, F7, F8, F9,\n-         F10, F11, F12, F13, F14, F15, F16, F17, F18, F19,\n-         F20, F21, F22, F23, F24, F25, F26, F27, F28, F29,\n-         F30, F31 :\n-           Field_1_Bit;\n-      end record with Pack, Convention => C;\n-      pragma Assert (Slot_1_Bit'Size = 32);\n-\n-      type Field_2_Bit is mod 2**2;\n-      type Slot_2_Bit is record -- 16 2-bit fields\n-         F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15 :\n-           Field_2_Bit;\n-      end record with Pack, Convention => C;\n-      pragma Assert (Slot_2_Bit'Size = 32);\n-\n-      type Field_4_Bit is mod 2**4;\n-      type Slot_4_Bit is record -- 8 4-bit fields\n-         F0, F1, F2, F3, F4, F5, F6, F7 :\n-           Field_4_Bit;\n-      end record with Pack, Convention => C;\n-      pragma Assert (Slot_4_Bit'Size = 32);\n-\n-      type Field_8_Bit is mod 2**8;\n-      type Slot_8_Bit is record -- 4 8-bit fields\n-         F0, F1, F2, F3 :\n-           Field_8_Bit;\n-      end record with Pack, Convention => C;\n-      pragma Assert (Slot_8_Bit'Size = 32);\n-\n+      --  We define the type Slot as a 32-bit modular integer. It is logically\n+      --  split into the appropriate numbers of components of appropriate size,\n+      --  but this splitting is not explicit because packed arrays cannot be\n+      --  properly interfaced in C/C++ and packed records are way too slow.\n+\n+      Slot_Size : constant := 32;\n+      type Slot is mod 2**Slot_Size;\n+      for Slot'Size use Slot_Size;\n+      pragma Provide_Shift_Operators (Slot);\n+\n+      type Field_1_Bit  is mod 2**1;\n+      type Field_2_Bit  is mod 2**2;\n+      type Field_4_Bit  is mod 2**4;\n+      type Field_8_Bit  is mod 2**8;\n       type Field_32_Bit is mod 2**32;\n-      subtype Slot_32_Bit is Field_32_Bit; -- 1 32-bit field\n-      pragma Assert (Slot_32_Bit'Size = 32);\n-\n-      type Slot (Field_Size : Field_Size_In_Bits := 9999) is record\n-         case Field_Size is\n-            when 1 => Slot_1 : Slot_1_Bit;\n-            when 2 => Slot_2 : Slot_2_Bit;\n-            when 4 => Slot_4 : Slot_4_Bit;\n-            when 8 => Slot_8 : Slot_8_Bit;\n-            when 32 => Slot_32 : Slot_32_Bit;\n-            when others => null;\n-         end case;\n-      end record with Unchecked_Union;\n-      pragma Assert (Slot'Size = 32);\n \n       Slots_Low_Bound : constant Field_Offset := Field_Offset'First + 1;\n "}, {"sha": "9b203f764161dd32d8a5c1b252de38668cc04a80", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 29, "deletions": 113, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=4c2629c28d731890e529237cb6751e803df202a8", "patch": "@@ -72,144 +72,60 @@ extern Node_Id Current_Error_Node;\n extern Field_Offset *Node_Offsets_Ptr;\n extern any_slot *Slots_Ptr;\n \n-INLINE Union_Id Get_1_Bit_Field (Node_Id N, Field_Offset Offset);\n-INLINE Union_Id Get_2_Bit_Field (Node_Id N, Field_Offset Offset);\n-INLINE Union_Id Get_4_Bit_Field (Node_Id N, Field_Offset Offset);\n-INLINE Union_Id Get_8_Bit_Field (Node_Id N, Field_Offset Offset);\n-INLINE Union_Id Get_32_Bit_Field (Node_Id N, Field_Offset Offset);\n-INLINE Union_Id Get_32_Bit_Field_With_Default (Node_Id N, Field_Offset Offset,\n-\t\t\t\t\t       Union_Id Default_Value);\n-\n-INLINE Union_Id\n+INLINE unsigned int Get_1_Bit_Field (Node_Id, Field_Offset);\n+INLINE unsigned int Get_2_Bit_Field (Node_Id, Field_Offset);\n+INLINE unsigned int Get_4_Bit_Field (Node_Id, Field_Offset);\n+INLINE unsigned int Get_8_Bit_Field (Node_Id, Field_Offset);\n+INLINE unsigned int Get_32_Bit_Field (Node_Id, Field_Offset);\n+INLINE unsigned int Get_32_Bit_Field_With_Default (Node_Id, Field_Offset,\n+\t\t\t\t\t\t   unsigned int);\n+\n+INLINE unsigned int\n Get_1_Bit_Field (Node_Id N, Field_Offset Offset)\n {\n-  const Field_Offset L = 32;\n-\n-  slot_1_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset / L))->slot_1;\n-\n-  switch (Offset % L)\n-    {\n-    case 0: return slot.f0;\n-    case 1: return slot.f1;\n-    case 2: return slot.f2;\n-    case 3: return slot.f3;\n-    case 4: return slot.f4;\n-    case 5: return slot.f5;\n-    case 6: return slot.f6;\n-    case 7: return slot.f7;\n-    case 8: return slot.f8;\n-    case 9: return slot.f9;\n-    case 10: return slot.f10;\n-    case 11: return slot.f11;\n-    case 12: return slot.f12;\n-    case 13: return slot.f13;\n-    case 14: return slot.f14;\n-    case 15: return slot.f15;\n-    case 16: return slot.f16;\n-    case 17: return slot.f17;\n-    case 18: return slot.f18;\n-    case 19: return slot.f19;\n-    case 20: return slot.f20;\n-    case 21: return slot.f21;\n-    case 22: return slot.f22;\n-    case 23: return slot.f23;\n-    case 24: return slot.f24;\n-    case 25: return slot.f25;\n-    case 26: return slot.f26;\n-    case 27: return slot.f27;\n-    case 28: return slot.f28;\n-    case 29: return slot.f29;\n-    case 30: return slot.f30;\n-    case 31: return slot.f31;\n-    default: gcc_unreachable ();\n-    }\n+  const Field_Offset L = Slot_Size / 1;\n+  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n+  return (slot >> (Offset % L) * (Slot_Size / L)) & 1;\n }\n \n-INLINE Union_Id\n+INLINE unsigned int\n Get_2_Bit_Field (Node_Id N, Field_Offset Offset)\n {\n-  const Field_Offset L = 16;\n-\n-  slot_2_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset / L))->slot_2;\n-\n-  switch (Offset % L)\n-    {\n-    case 0: return slot.f0;\n-    case 1: return slot.f1;\n-    case 2: return slot.f2;\n-    case 3: return slot.f3;\n-    case 4: return slot.f4;\n-    case 5: return slot.f5;\n-    case 6: return slot.f6;\n-    case 7: return slot.f7;\n-    case 8: return slot.f8;\n-    case 9: return slot.f9;\n-    case 10: return slot.f10;\n-    case 11: return slot.f11;\n-    case 12: return slot.f12;\n-    case 13: return slot.f13;\n-    case 14: return slot.f14;\n-    case 15: return slot.f15;\n-    default: gcc_unreachable ();\n-    }\n+  const Field_Offset L = Slot_Size / 2;\n+  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n+  return (slot >> (Offset % L) * (Slot_Size / L)) & 3;\n }\n \n-INLINE Union_Id\n+INLINE unsigned int\n Get_4_Bit_Field (Node_Id N, Field_Offset Offset)\n {\n-  const Field_Offset L = 8;\n-\n-  slot_4_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset / L))->slot_4;\n-\n-  switch (Offset % L)\n-    {\n-    case 0: return slot.f0;\n-    case 1: return slot.f1;\n-    case 2: return slot.f2;\n-    case 3: return slot.f3;\n-    case 4: return slot.f4;\n-    case 5: return slot.f5;\n-    case 6: return slot.f6;\n-    case 7: return slot.f7;\n-    default: gcc_unreachable ();\n-    }\n+  const Field_Offset L = Slot_Size / 4;\n+  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n+  return (slot >> (Offset % L) * (Slot_Size / L)) & 15;\n }\n \n-INLINE Union_Id\n+INLINE unsigned int\n Get_8_Bit_Field (Node_Id N, Field_Offset Offset)\n {\n-  const Field_Offset L = 4;\n-\n-  slot_8_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset / L))->slot_8;\n-\n-  switch (Offset % L)\n-    {\n-    case 0: return slot.f0;\n-    case 1: return slot.f1;\n-    case 2: return slot.f2;\n-    case 3: return slot.f3;\n-    default: gcc_unreachable ();\n-    }\n+  const Field_Offset L = Slot_Size / 8;\n+  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n+  return (slot >> (Offset % L) * (Slot_Size / L)) & 255;\n }\n \n-INLINE Union_Id\n+INLINE unsigned int\n Get_32_Bit_Field (Node_Id N, Field_Offset Offset)\n {\n   const Field_Offset L = 1;\n-\n-  slot_32_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset / L))->slot_32;\n-\n+  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n   return slot;\n }\n \n-INLINE Union_Id\n+INLINE unsigned int\n Get_32_Bit_Field_With_Default (Node_Id N, Field_Offset Offset,\n-\t\t\t       Union_Id Default_Value)\n+\t\t\t       unsigned int Default_Value)\n {\n   const Field_Offset L = 1;\n-\n-  slot_32_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset / L))->slot_32;\n-\n+  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n   return slot == Empty ? Default_Value : slot;\n }\n "}, {"sha": "ac30db346eb8b0543bc60372384378eacdd6507f", "filename": "gcc/ada/types.h", "status": "modified", "additions": 3, "deletions": 91, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2629c28d731890e529237cb6751e803df202a8/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=4c2629c28d731890e529237cb6751e803df202a8", "patch": "@@ -374,103 +374,15 @@ typedef Nat Small_Paren_Count_Type;\n \n typedef Nat Field_Offset;\n \n-typedef struct\n-{\n-  unsigned f0 : 1;\n-  unsigned f1 : 1;\n-  unsigned f2 : 1;\n-  unsigned f3 : 1;\n-  unsigned f4 : 1;\n-  unsigned f5 : 1;\n-  unsigned f6 : 1;\n-  unsigned f7 : 1;\n-  unsigned f8 : 1;\n-  unsigned f9 : 1;\n-  unsigned f10 : 1;\n-  unsigned f11 : 1;\n-  unsigned f12 : 1;\n-  unsigned f13 : 1;\n-  unsigned f14 : 1;\n-  unsigned f15 : 1;\n-  unsigned f16 : 1;\n-  unsigned f17 : 1;\n-  unsigned f18 : 1;\n-  unsigned f19 : 1;\n-  unsigned f20 : 1;\n-  unsigned f21 : 1;\n-  unsigned f22 : 1;\n-  unsigned f23 : 1;\n-  unsigned f24 : 1;\n-  unsigned f25 : 1;\n-  unsigned f26 : 1;\n-  unsigned f27 : 1;\n-  unsigned f28 : 1;\n-  unsigned f29 : 1;\n-  unsigned f30 : 1;\n-  unsigned f31 : 1;\n-} slot_1_bit;\n-\n-typedef struct\n-{\n-  unsigned f0 : 2;\n-  unsigned f1 : 2;\n-  unsigned f2 : 2;\n-  unsigned f3 : 2;\n-  unsigned f4 : 2;\n-  unsigned f5 : 2;\n-  unsigned f6 : 2;\n-  unsigned f7 : 2;\n-  unsigned f8 : 2;\n-  unsigned f9 : 2;\n-  unsigned f10 : 2;\n-  unsigned f11 : 2;\n-  unsigned f12 : 2;\n-  unsigned f13 : 2;\n-  unsigned f14 : 2;\n-  unsigned f15 : 2;\n-} slot_2_bit;\n-\n-typedef struct\n-{\n-  unsigned f0 : 4;\n-  unsigned f1 : 4;\n-  unsigned f2 : 4;\n-  unsigned f3 : 4;\n-  unsigned f4 : 4;\n-  unsigned f5 : 4;\n-  unsigned f6 : 4;\n-  unsigned f7 : 4;\n-} slot_4_bit;\n-\n-typedef struct\n-{\n-  unsigned f0 : 8;\n-  unsigned f1 : 8;\n-  unsigned f2 : 8;\n-  unsigned f3 : 8;\n-} slot_8_bit;\n-\n-typedef Union_Id slot_32_bit;\n+typedef unsigned int any_slot;\n \n-typedef union\n-{\n-  slot_1_bit slot_1;\n-  slot_2_bit slot_2;\n-  slot_4_bit slot_4;\n-  slot_8_bit slot_8;\n-  slot_32_bit slot_32;\n-} any_slot;\n+#define Slot_Size (sizeof (any_slot) * 8)\n \n /* Slots are 32 bits (for now, but we might want to make that 64).\n    The first bootstrap stage uses -std=gnu++98, so we cannot use\n    static_assert in that case.  */\n #if __cplusplus >= 201402L\n-static_assert (sizeof (slot_1_bit) == 4);\n-static_assert (sizeof (slot_2_bit) == 4);\n-static_assert (sizeof (slot_4_bit) == 4);\n-static_assert (sizeof (slot_8_bit) == 4);\n-static_assert (sizeof (slot_32_bit) == 4);\n-static_assert (sizeof (any_slot) == 4);\n+static_assert (Slot_Size == 32);\n #endif\n \n /* Definitions of Reason codes for Raise_xxx_Error nodes.  */"}]}