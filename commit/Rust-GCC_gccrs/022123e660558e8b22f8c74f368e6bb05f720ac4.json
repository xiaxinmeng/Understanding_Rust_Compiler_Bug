{"sha": "022123e660558e8b22f8c74f368e6bb05f720ac4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyMTIzZTY2MDU1OGU4YjIyZjhjNzRmMzY4ZTZiYjA1ZjcyMGFjNA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-12-03T00:05:03Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-12-03T00:05:03Z"}, "message": "rs6000.c (rs6000_stack_t): Remove toc_save_p, toc_save_offset, toc_size, lr_size.\n\n\t* config/rs6000/rs6000.c (rs6000_stack_t): Remove toc_save_p,\n\ttoc_save_offset, toc_size, lr_size.\n\t(rs6000_stack_info): Use memset rather than bss struct copy to init.\n\tTest rs6000_ra_ever_killed last in condition setting lr_save_p.\n\tAdjust for removal of unused rs6000_stack_t fields.\n\t(debug_stack_info): Adjust.\n\t(rs6000_ra_ever_killed): Expand FIND_REG_INC_NOTE.  Test for calls\n\tfirst, and don't bother checking for set/inc of lr on sibcalls.\n\t(rs6000_emit_epilogue): Tidy code restoring stack pointer.\n\nFrom-SVN: r107962", "tree": {"sha": "950dd5ca03071093a9768030b2248692eb677af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/950dd5ca03071093a9768030b2248692eb677af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/022123e660558e8b22f8c74f368e6bb05f720ac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022123e660558e8b22f8c74f368e6bb05f720ac4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/022123e660558e8b22f8c74f368e6bb05f720ac4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022123e660558e8b22f8c74f368e6bb05f720ac4/comments", "author": null, "committer": null, "parents": [{"sha": "0cd0c6fbbb9f66b24e29118abc0b2cba3fc004eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd0c6fbbb9f66b24e29118abc0b2cba3fc004eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cd0c6fbbb9f66b24e29118abc0b2cba3fc004eb"}], "stats": {"total": 109, "additions": 44, "deletions": 65}, "files": [{"sha": "613a300904bf2cf2eb63a48be03e9a7df3bbf7b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022123e660558e8b22f8c74f368e6bb05f720ac4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022123e660558e8b22f8c74f368e6bb05f720ac4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=022123e660558e8b22f8c74f368e6bb05f720ac4", "patch": "@@ -1,3 +1,15 @@\n+2005-12-03  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (rs6000_stack_t): Remove toc_save_p,\n+\ttoc_save_offset, toc_size, lr_size.\n+\t(rs6000_stack_info): Use memset rather than bss struct copy to init.\n+\tTest rs6000_ra_ever_killed last in condition setting lr_save_p.\n+\tAdjust for removal of unused rs6000_stack_t fields.\n+\t(debug_stack_info): Adjust.\n+\t(rs6000_ra_ever_killed): Expand FIND_REG_INC_NOTE.  Test for calls\n+\tfirst, and don't bother checking for set/inc of lr on sibcalls.\n+\t(rs6000_emit_epilogue): Tidy code restoring stack pointer.\n+\n 2005-12-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/25199"}, {"sha": "30007531e6fa63abc0cef30096c687fcb1e3fb53", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 32, "deletions": 65, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022123e660558e8b22f8c74f368e6bb05f720ac4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022123e660558e8b22f8c74f368e6bb05f720ac4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=022123e660558e8b22f8c74f368e6bb05f720ac4", "patch": "@@ -77,7 +77,6 @@ typedef struct rs6000_stack {\n   int lr_save_p;\t\t/* true if the link reg needs to be saved */\n   int cr_save_p;\t\t/* true if the CR reg needs to be saved */\n   unsigned int vrsave_mask;\t/* mask of vec registers to save */\n-  int toc_save_p;\t\t/* true if the TOC needs to be saved */\n   int push_p;\t\t\t/* true if we need to allocate stack space */\n   int calls_p;\t\t\t/* true if the function makes any calls */\n   int world_save_p;\t\t/* true if we're saving *everything*:\n@@ -90,7 +89,6 @@ typedef struct rs6000_stack {\n   int cr_save_offset;\t\t/* offset to save CR from initial SP */\n   int vrsave_save_offset;\t/* offset to save VRSAVE from initial SP */\n   int spe_gp_save_offset;\t/* offset to save spe 64-bit gprs  */\n-  int toc_save_offset;\t\t/* offset to save the TOC pointer */\n   int varargs_save_offset;\t/* offset to save the varargs registers */\n   int ehrd_offset;\t\t/* offset to EH return data */\n   int reg_size;\t\t\t/* register size (4 or 8) */\n@@ -102,13 +100,11 @@ typedef struct rs6000_stack {\n   int fp_size;\t\t\t/* size of saved FP registers */\n   int altivec_size;\t\t/* size of saved AltiVec registers */\n   int cr_size;\t\t\t/* size to hold CR if not in save_size */\n-  int lr_size;\t\t\t/* size to hold LR if not in save_size */\n   int vrsave_size;\t\t/* size to hold VRSAVE if not in save_size */\n   int altivec_padding_size;\t/* size of altivec alignment padding if\n \t\t\t\t   not in save_size */\n   int spe_gp_size;\t\t/* size of 64-bit GPR save size for SPE */\n   int spe_padding_size;\n-  int toc_size;\t\t\t/* size to hold TOC if not in save_size */\n   HOST_WIDE_INT total_size;\t/* total bytes allocated for stack */\n   int spe_64bit_regs_used;\n } rs6000_stack_t;\n@@ -12672,15 +12668,14 @@ is_altivec_return_reg (rtx reg, void *xyes)\n static rs6000_stack_t *\n rs6000_stack_info (void)\n {\n-  static rs6000_stack_t info, zero_info;\n+  static rs6000_stack_t info;\n   rs6000_stack_t *info_ptr = &info;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   int ehrd_size;\n   int save_align;\n   HOST_WIDE_INT non_fixed_size;\n \n-  /* Zero all fields portably.  */\n-  info = zero_info;\n+  memset (&info, 0, sizeof (info));\n \n   if (TARGET_SPE)\n     {\n@@ -12733,18 +12728,18 @@ rs6000_stack_info (void)\n \t\t       || cfun->machine->ra_needs_full_frame);\n \n   /* Determine if we need to save the link register.  */\n-  if (rs6000_ra_ever_killed ()\n-      || (DEFAULT_ABI == ABI_AIX\n-\t  && current_function_profile\n-\t  && !TARGET_PROFILE_KERNEL)\n+  if ((DEFAULT_ABI == ABI_AIX\n+       && current_function_profile\n+       && !TARGET_PROFILE_KERNEL)\n #ifdef TARGET_RELOCATABLE\n       || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n #endif\n       || (info_ptr->first_fp_reg_save != 64\n \t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n       || info_ptr->first_altivec_reg_save <= LAST_ALTIVEC_REGNO\n       || (DEFAULT_ABI == ABI_V4 && current_function_calls_alloca)\n-      || info_ptr->calls_p)\n+      || info_ptr->calls_p\n+      || rs6000_ra_ever_killed ())\n     {\n       info_ptr->lr_save_p = 1;\n       regs_ever_live[LINK_REGISTER_REGNUM] = 1;\n@@ -12867,8 +12862,7 @@ rs6000_stack_info (void)\n \t    - info_ptr->spe_gp_size;\n \n \t  /* Adjust for SPE case.  */\n-\t  info_ptr->toc_save_offset\n-\t    = info_ptr->spe_gp_save_offset - info_ptr->toc_size;\n+\t  info_ptr->ehrd_offset = info_ptr->spe_gp_save_offset;\n \t}\n       else if (TARGET_ALTIVEC_ABI)\n \t{\n@@ -12888,12 +12882,11 @@ rs6000_stack_info (void)\n \t    - info_ptr->altivec_size;\n \n \t  /* Adjust for AltiVec case.  */\n-\t  info_ptr->toc_save_offset\n-\t    = info_ptr->altivec_save_offset - info_ptr->toc_size;\n+\t  info_ptr->ehrd_offset = info_ptr->altivec_save_offset;\n \t}\n       else\n-\tinfo_ptr->toc_save_offset  = info_ptr->cr_save_offset - info_ptr->toc_size;\n-      info_ptr->ehrd_offset      = info_ptr->toc_save_offset - ehrd_size;\n+\tinfo_ptr->ehrd_offset    = info_ptr->cr_save_offset;\n+      info_ptr->ehrd_offset      -= ehrd_size;\n       info_ptr->lr_save_offset   = reg_size;\n       break;\n     }\n@@ -12907,9 +12900,7 @@ rs6000_stack_info (void)\n \t\t\t\t\t + info_ptr->spe_padding_size\n \t\t\t\t\t + ehrd_size\n \t\t\t\t\t + info_ptr->cr_size\n-\t\t\t\t\t + info_ptr->lr_size\n-\t\t\t\t\t + info_ptr->vrsave_size\n-\t\t\t\t\t + info_ptr->toc_size,\n+\t\t\t\t\t + info_ptr->vrsave_size,\n \t\t\t\t\t save_align);\n \n   non_fixed_size\t = (info_ptr->vars_size\n@@ -12970,9 +12961,6 @@ rs6000_stack_info (void)\n   if (! info_ptr->cr_save_p)\n     info_ptr->cr_save_offset = 0;\n \n-  if (! info_ptr->toc_save_p)\n-    info_ptr->toc_save_offset = 0;\n-\n   return info_ptr;\n }\n \n@@ -13068,9 +13056,6 @@ debug_stack_info (rs6000_stack_t *info)\n   if (info->cr_save_p)\n     fprintf (stderr, \"\\tcr_save_p           = %5d\\n\", info->cr_save_p);\n \n-  if (info->toc_save_p)\n-    fprintf (stderr, \"\\ttoc_save_p          = %5d\\n\", info->toc_save_p);\n-\n   if (info->vrsave_mask)\n     fprintf (stderr, \"\\tvrsave_mask         = 0x%x\\n\", info->vrsave_mask);\n \n@@ -13104,9 +13089,6 @@ debug_stack_info (rs6000_stack_t *info)\n   if (info->cr_save_offset)\n     fprintf (stderr, \"\\tcr_save_offset      = %5d\\n\", info->cr_save_offset);\n \n-  if (info->toc_save_offset)\n-    fprintf (stderr, \"\\ttoc_save_offset     = %5d\\n\", info->toc_save_offset);\n-\n   if (info->varargs_save_offset)\n     fprintf (stderr, \"\\tvarargs_save_offset = %5d\\n\", info->varargs_save_offset);\n \n@@ -13147,15 +13129,9 @@ debug_stack_info (rs6000_stack_t *info)\n     fprintf (stderr, \"\\tspe_padding_size    = %5d\\n\",\n \t     info->spe_padding_size);\n \n-  if (info->lr_size)\n-    fprintf (stderr, \"\\tlr_size             = %5d\\n\", info->lr_size);\n-\n   if (info->cr_size)\n     fprintf (stderr, \"\\tcr_size             = %5d\\n\", info->cr_size);\n \n-  if (info->toc_size)\n-    fprintf (stderr, \"\\ttoc_size            = %5d\\n\", info->toc_size);\n-\n   if (info->save_size)\n     fprintf (stderr, \"\\tsave_size           = %5d\\n\", info->save_size);\n \n@@ -13278,10 +13254,12 @@ rs6000_ra_ever_killed (void)\n     {\n       if (INSN_P (insn))\n \t{\n-\t  if (FIND_REG_INC_NOTE (insn, reg))\n-\t    return 1;\n-\t  else if (GET_CODE (insn) == CALL_INSN\n-\t\t   && !SIBLING_CALL_P (insn))\n+\t  if (CALL_P (insn))\n+\t    {\n+\t      if (!SIBLING_CALL_P (insn))\n+\t\treturn 1;\n+\t    }\n+\t  else if (find_regno_note (insn, REG_INC, LINK_REGISTER_REGNUM))\n \t    return 1;\n \t  else if (set_of (reg, insn) != NULL_RTX\n \t\t   && !prologue_epilogue_contains (insn))\n@@ -14713,7 +14691,6 @@ rs6000_emit_epilogue (int sibcall)\n \n       emit_move_insn (frame_reg_rtx,\n \t\t      gen_rtx_MEM (Pmode, sp_reg_rtx));\n-\n     }\n   else if (info->push_p)\n     {\n@@ -14947,30 +14924,20 @@ rs6000_emit_epilogue (int sibcall)\n     }\n \n   /* If this is V.4, unwind the stack pointer after all of the loads\n-     have been done.  We need to emit a block here so that sched\n-     doesn't decide to move the sp change before the register restores\n-     (which may not have any obvious dependency on the stack).  This\n-     doesn't hurt performance, because there is no scheduling that can\n-     be done after this point.  */\n-  if (DEFAULT_ABI == ABI_V4\n-      || current_function_calls_eh_return)\n-    {\n-      if (frame_reg_rtx != sp_reg_rtx)\n-\trs6000_emit_stack_tie ();\n-\n-      if (use_backchain_to_restore_sp)\n-\t{\n-\t  emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n-\t}\n-      else if (sp_offset != 0)\n-\t{\n-\t  emit_insn (TARGET_32BIT\n-\t\t     ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (sp_offset))\n-\t\t     : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (sp_offset)));\n-\t}\n-    }\n+     have been done.  */\n+  if (frame_reg_rtx != sp_reg_rtx)\n+    {\n+      /* This blockage is needed so that sched doesn't decide to move\n+\t the sp change before the register restores.  */\n+      rs6000_emit_stack_tie ();\n+      emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n+    }\n+  else if (sp_offset != 0)\n+    emit_insn (TARGET_32BIT\n+\t       ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n+\t\t\t     GEN_INT (sp_offset))\n+\t       : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n+\t\t\t     GEN_INT (sp_offset)));\n \n   if (current_function_calls_eh_return)\n     {"}]}