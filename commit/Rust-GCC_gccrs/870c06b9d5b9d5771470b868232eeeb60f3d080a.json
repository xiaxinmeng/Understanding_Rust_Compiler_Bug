{"sha": "870c06b9d5b9d5771470b868232eeeb60f3d080a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwYzA2YjlkNWI5ZDU3NzE0NzBiODY4MjMyZWVlYjYwZjNkMDgwYQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-08-01T20:27:27Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-08-01T20:27:27Z"}, "message": "re PR libfortran/32954 (pack with -fdefault-integer-8)\n\n2007-08-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32954\n\t* intrinsic.c (resolve_mask_arg):  New function.\n\t(gfc_resolve_maxloc):  Use resolve_mask_arg for mask resolution.\n\t(gfc_resolve_maxval):  Likewise.\n\t(gfc_resolve_minloc):  Likewise.\n\t(gfc_resolve_minval):  Likewise.\n\t(gfc_resolve_pack):  Likewise.\n\t(gfc_resolve_product):  Likewise.\n\t(gfc_resolve_sum):  Likewise.\n\t(gfc_resolve_unpack):  Likewise.\n\n2007-08-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32954\n\t* minmaxloc_3.f90:  New test case.\n\nFrom-SVN: r127137", "tree": {"sha": "147166a2485977f5092668b2dfccd1d28aa8c731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/147166a2485977f5092668b2dfccd1d28aa8c731"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/870c06b9d5b9d5771470b868232eeeb60f3d080a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870c06b9d5b9d5771470b868232eeeb60f3d080a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870c06b9d5b9d5771470b868232eeeb60f3d080a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870c06b9d5b9d5771470b868232eeeb60f3d080a/comments", "author": null, "committer": null, "parents": [{"sha": "e4fd64d6757db8dba0b706f1b141b3d7cb1ac63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fd64d6757db8dba0b706f1b141b3d7cb1ac63c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4fd64d6757db8dba0b706f1b141b3d7cb1ac63c"}], "stats": {"total": 277, "additions": 180, "deletions": 97}, "files": [{"sha": "1d6ca667456ce8050e9d47c1029aee03cd3d7af3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=870c06b9d5b9d5771470b868232eeeb60f3d080a", "patch": "@@ -1,3 +1,16 @@\n+2007-08-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32954\n+\t* intrinsic.c (resolve_mask_arg):  New function.\n+\t(gfc_resolve_maxloc):  Use resolve_mask_arg for mask resolution.\n+\t(gfc_resolve_maxval):  Likewise.\n+\t(gfc_resolve_minloc):  Likewise.\n+\t(gfc_resolve_minval):  Likewise.\n+\t(gfc_resolve_pack):  Likewise.\n+\t(gfc_resolve_product):  Likewise.\n+\t(gfc_resolve_sum):  Likewise.\n+\t(gfc_resolve_unpack):  Likewise.\n+\n 2007-08-01  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/32936"}, {"sha": "32ed6da5645379e835d3143862fc448c7598fdcc", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 43, "deletions": 97, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=870c06b9d5b9d5771470b868232eeeb60f3d080a", "patch": "@@ -72,6 +72,41 @@ check_charlen_present (gfc_expr *source)\n     }\n }\n \n+/* Helper function for resolving the \"mask\" argument.  */\n+\n+static void\n+resolve_mask_arg (gfc_expr *mask)\n+{\n+  int newkind;\n+\n+  /* The mask can be kind 4 or 8 for the array case.\n+     For the scalar case, coerce it to kind=4 unconditionally\n+     (because this is the only kind we have a library function\n+     for).  */\n+\n+  newkind = 0;\n+\n+  if (mask->rank == 0)\n+    {\n+      if (mask->ts.kind != 4)\n+\tnewkind = 4;\n+    }\n+  else\n+    {\n+      if (mask->ts.kind < 4)\n+\tnewkind = gfc_default_logical_kind;\n+    }\n+\n+  if (newkind)\n+    {\n+      gfc_typespec ts;\n+\n+      ts.type = BT_LOGICAL;\n+      ts.kind = newkind;\n+      gfc_convert_type (mask, &ts, 2);\n+    }\n+}\n+\n /********************** Resolution functions **********************/\n \n \n@@ -1232,16 +1267,7 @@ gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n       else\n \tname = \"mmaxloc\";\n \n-      /* The mask can be kind 4 or 8 for the array case.  For the\n-\t scalar case, coerce it to default kind unconditionally.  */\n-      if ((mask->ts.kind < gfc_default_logical_kind)\n-\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n-\t{\n-\t  gfc_typespec ts;\n-\t  ts.type = BT_LOGICAL;\n-\t  ts.kind = gfc_default_logical_kind;\n-\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n-\t}\n+      resolve_mask_arg (mask);\n     }\n   else\n     name = \"maxloc\";\n@@ -1286,16 +1312,7 @@ gfc_resolve_maxval (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n       else\n \tname = \"mmaxval\";\n \n-      /* The mask can be kind 4 or 8 for the array case.  For the\n-\t scalar case, coerce it to default kind unconditionally.  */\n-      if ((mask->ts.kind < gfc_default_logical_kind)\n-\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n-\t{\n-\t  gfc_typespec ts;\n-\t  ts.type = BT_LOGICAL;\n-\t  ts.kind = gfc_default_logical_kind;\n-\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n-\t}\n+      resolve_mask_arg (mask);\n     }\n   else\n     name = \"maxval\";\n@@ -1386,16 +1403,7 @@ gfc_resolve_minloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n       else\n \tname = \"mminloc\";\n \n-      /* The mask can be kind 4 or 8 for the array case.  For the\n-\t scalar case, coerce it to default kind unconditionally.  */\n-      if ((mask->ts.kind < gfc_default_logical_kind)\n-\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n-\t{\n-\t  gfc_typespec ts;\n-\t  ts.type = BT_LOGICAL;\n-\t  ts.kind = gfc_default_logical_kind;\n-\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n-\t}\n+      resolve_mask_arg (mask);\n     }\n   else\n     name = \"minloc\";\n@@ -1440,16 +1448,7 @@ gfc_resolve_minval (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n       else\n \tname = \"mminval\";\n \n-      /* The mask can be kind 4 or 8 for the array case.  For the\n-\t scalar case, coerce it to default kind unconditionally.  */\n-      if ((mask->ts.kind < gfc_default_logical_kind)\n-\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n-\t{\n-\t  gfc_typespec ts;\n-\t  ts.type = BT_LOGICAL;\n-\t  ts.kind = gfc_default_logical_kind;\n-\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n-\t}\n+      resolve_mask_arg (mask);\n     }\n   else\n     name = \"minval\";\n@@ -1555,35 +1554,10 @@ void\n gfc_resolve_pack (gfc_expr *f, gfc_expr *array, gfc_expr *mask,\n \t\t  gfc_expr *vector ATTRIBUTE_UNUSED)\n {\n-  int newkind;\n-\n   f->ts = array->ts;\n   f->rank = 1;\n \n-  /* The mask can be kind 4 or 8 for the array case.  For the scalar\n-     case, coerce it to kind=4 unconditionally (because this is the only\n-     kind we have a library function for).  */\n-\n-  newkind = 0;\n-  if (mask->rank == 0)\n-    {\n-      if (mask->ts.kind != 4)\n-\tnewkind = 4;\n-    }\n-  else\n-    {\n-      if (mask->ts.kind < 4)\n-\tnewkind = gfc_default_logical_kind;\n-    }\n-\n-  if (newkind)\n-    {\n-      gfc_typespec ts;\n-\n-      ts.type = BT_LOGICAL;\n-      ts.kind = gfc_default_logical_kind;\n-      gfc_convert_type (mask, &ts, 2);\n-    }\n+  resolve_mask_arg (mask);\n \n   if (mask->rank != 0)\n     f->value.function.name = (array->ts.type == BT_CHARACTER\n@@ -1615,16 +1589,7 @@ gfc_resolve_product (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n       else\n \tname = \"mproduct\";\n \n-      /* The mask can be kind 4 or 8 for the array case.  For the\n-\t scalar case, coerce it to default kind unconditionally.  */\n-      if ((mask->ts.kind < gfc_default_logical_kind)\n-\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n-\t{\n-\t  gfc_typespec ts;\n-\t  ts.type = BT_LOGICAL;\n-\t  ts.kind = gfc_default_logical_kind;\n-\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n-\t}\n+      resolve_mask_arg (mask);\n     }\n   else\n     name = \"product\";\n@@ -2112,16 +2077,7 @@ gfc_resolve_sum (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n       else\n \tname = \"msum\";\n \n-      /* The mask can be kind 4 or 8 for the array case.  For the\n-\t scalar case, coerce it to default kind unconditionally.  */\n-      if ((mask->ts.kind < gfc_default_logical_kind)\n-\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n-\t{\n-\t  gfc_typespec ts;\n-\t  ts.type = BT_LOGICAL;\n-\t  ts.kind = gfc_default_logical_kind;\n-\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n-\t}\n+      resolve_mask_arg (mask);\n     }\n   else\n     name = \"sum\";\n@@ -2350,17 +2306,7 @@ gfc_resolve_unpack (gfc_expr *f, gfc_expr *vector, gfc_expr *mask,\n {\n   f->ts = vector->ts;\n   f->rank = mask->rank;\n-\n-  /* Coerce the mask to default logical kind if it has kind < 4.  */\n-\n-  if (mask->ts.kind < 4)\n-    {\n-      gfc_typespec ts;\n-\n-      ts.type = BT_LOGICAL;\n-      ts.kind = gfc_default_logical_kind;\n-      gfc_convert_type (mask, &ts, 2);\n-    }\n+  resolve_mask_arg (mask);\n \n   f->value.function.name\n     = gfc_get_string (PREFIX (\"unpack%d%s\"), field->rank > 0 ? 1 : 0,"}, {"sha": "15364b98d94fc6a9bd6efc7584c97159dbc32ae5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=870c06b9d5b9d5771470b868232eeeb60f3d080a", "patch": "@@ -1,3 +1,8 @@\n+2007-08-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32954\n+\t* minmaxloc_3.f90:  New test case.\n+\n 2007-08-01  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/32936"}, {"sha": "fbc1b09f727c2bb3bfbe525c09a785c1f2261154", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_3.f90", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870c06b9d5b9d5771470b868232eeeb60f3d080a/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_3.f90?ref=870c06b9d5b9d5771470b868232eeeb60f3d080a", "patch": "@@ -0,0 +1,119 @@\n+! { dg-do run }\n+! { dg-options \"-fdefault-integer-8\" }\n+! Check max/minloc.\n+! PR fortran/32956, wrong mask kind with -fdefault-integer-8\n+!\n+program test\n+  implicit none\n+  integer :: i(1), j(-1:1), res(1)\n+  logical, volatile :: m(3), m2(3)\n+  m = (/ .false., .false., .false. /)\n+  m2 = (/ .false., .true., .false. /)\n+  call check(1, 0, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=.FALSE.))\n+  call check(2, 0, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=m))\n+  call check(3, 2, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=m2))\n+  call check(4, 0, MAXLOC(i(1:0), DIM=1, MASK=.TRUE.))\n+  call check(5, 0, MAXLOC(i(1:0), DIM=1, MASK=.FALSE.))\n+  call check(6, 0, MAXLOC(i(1:0), DIM=1, MASK=m(1:0)))\n+  call check(7, 0, MAXLOC(i(1:0), DIM=1))\n+  call check(8, 0, MINLOC((/ 42, 23, 11 /), DIM=1, MASK=.FALSE.))\n+  call check(9, 0, MINLOC((/ 42, 23, 11 /), DIM=1, MASK=m))\n+  call check(10, 0, MINLOC(i(1:0), DIM=1, MASK=.FALSE.))\n+  call check(11,0, MINLOC(i(1:0), DIM=1, MASK=m(1:0)))\n+  call check(12,0, MINLOC(i(1:0), DIM=1, MASK=.TRUE.))\n+  call check(13,0, MINLOC(i(1:0), DIM=1))\n+\n+  j = (/ 1, 2, 1 /); call check(14, 2, MAXLOC(j, DIM=1))\n+  j = (/ 1, 2, 3 /); call check(15, 3, MAXLOC(j, DIM=1))\n+  j = (/ 3, 2, 1 /); call check(16, 1, MAXLOC(j, DIM=1))\n+  j = (/ 1, 2, 1 /); call check(17, 1, MINLOC(j, DIM=1))\n+  j = (/ 1, 2, 3 /); call check(18, 1, MINLOC(j, DIM=1))\n+  j = (/ 3, 2, 1 /); call check(19, 3, MINLOC(j, DIM=1))\n+\n+  j = (/ 1, 2, 1 /); call check(20, 2, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 3 /); call check(21, 3, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 3, 2, 1 /); call check(22, 1, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 1 /); call check(23, 1, MINLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 3 /); call check(24, 1, MINLOC(j, DIM=1,mask=.true.))\n+  j = (/ 3, 2, 1 /); call check(25, 3, MINLOC(j, DIM=1,mask=.true.))\n+\n+  j = (/ 1, 2, 1 /); call check(26, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 3 /); call check(27, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 3, 2, 1 /); call check(28, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 1 /); call check(29, 0, MINLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 3 /); call check(30, 0, MINLOC(j, DIM=1,mask=.false.))\n+  j = (/ 3, 2, 1 /); call check(31, 0, MINLOC(j, DIM=1,mask=.false.))\n+\n+  j = (/ 1, 2, 1 /); call check(32, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 3 /); call check(33, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 3, 2, 1 /); call check(34, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 1 /); call check(35, 0, MINLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 3 /); call check(36, 0, MINLOC(j, DIM=1,mask=m))\n+  j = (/ 3, 2, 1 /); call check(37, 0, MINLOC(j, DIM=1,mask=m))\n+\n+  j = (/ 1, 2, 1 /); call check(38, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 3 /); call check(39, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 3, 2, 1 /); call check(40, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 1 /); call check(41, 2, MINLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 3 /); call check(42, 2, MINLOC(j, DIM=1,mask=m2))\n+  j = (/ 3, 2, 1 /); call check(43, 2, MINLOC(j, DIM=1,mask=m2))\n+\n+! Check the library minloc and maxloc\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=.FALSE.); call check(44, 0,  res(1))\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=m); call check(45, 0,  res(1))\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=m2); call check(46, 2,  res(1))\n+  res = MAXLOC(i(1:0), MASK=.TRUE.); call check(47, 0,  res(1))\n+  res = MAXLOC(i(1:0), MASK=.FALSE.); call check(48, 0,  res(1))\n+  res = MAXLOC(i(1:0), MASK=m(1:0)); call check(49, 0,  res(1))\n+  res = MAXLOC(i(1:0)); call check(50, 0,  res(1))\n+  res = MINLOC((/ 42, 23, 11 /), MASK=.FALSE.); call check(51, 0, res(1))\n+  res = MINLOC((/ 42, 23, 11 /), MASK=m); call check(52, 0, res(1))\n+  res = MINLOC(i(1:0), MASK=.FALSE.); call check(53, 0, res(1))\n+  res = MINLOC(i(1:0), MASK=m(1:0)); call check(54,0, res(1))\n+  res = MINLOC(i(1:0), MASK=.TRUE.); call check(55,0, res(1))\n+  res = MINLOC(i(1:0)); call check(56,0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j); call check(57, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j); call check(58, 3,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j); call check(59, 1,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j); call check(60, 1, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j); call check(61, 1, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j); call check(62, 3, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=.true.); call check(63, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=.true.); call check(65, 3,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=.true.); call check(66, 1,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=.true.); call check(67, 1, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=.true.); call check(68, 1, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=.true.); call check(69, 3, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=.false.); call check(70, 0,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=.false.); call check(71, 0,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=.false.); call check(72, 0,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=.false.); call check(73, 0, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=.false.); call check(74, 0, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=.false.); call check(75, 0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=m); call check(76, 0,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=m); call check(77, 0,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=m); call check(78, 0,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=m); call check(79, 0, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=m); call check(80, 0, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=m);call check(81, 0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=m2); call check(82, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=m2); call check(83, 2,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=m2); call check(84, 2,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=m2); call check(85, 2, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=m2); call check(86, 2, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=m2); call check(87, 2, res(1))\n+\n+contains\n+subroutine check(n, i,j)\n+  integer, value, intent(in) :: i,j,n\n+  if(i /= j) then\n+     call abort()\n+!    print *, 'ERROR: Test',n,' expected ',i,' received ', j\n+  end if\n+end subroutine check\n+end program"}]}