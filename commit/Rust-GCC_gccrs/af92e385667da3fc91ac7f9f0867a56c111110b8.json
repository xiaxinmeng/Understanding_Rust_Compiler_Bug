{"sha": "af92e385667da3fc91ac7f9f0867a56c111110b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY5MmUzODU2NjdkYTNmYzkxYWM3ZjlmMDg2N2E1NmMxMTExMTBiOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-25T21:54:22Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-25T21:54:22Z"}, "message": "libgo: Update to weekly.2012-01-20.\n\nFrom-SVN: r183540", "tree": {"sha": "c8e8990a2197e33f6fe50a28a16714aafe982102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8e8990a2197e33f6fe50a28a16714aafe982102"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af92e385667da3fc91ac7f9f0867a56c111110b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af92e385667da3fc91ac7f9f0867a56c111110b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af92e385667da3fc91ac7f9f0867a56c111110b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af92e385667da3fc91ac7f9f0867a56c111110b8/comments", "author": null, "committer": null, "parents": [{"sha": "df1304ee03f41aed179545d1e8b4684cfd22bbdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1304ee03f41aed179545d1e8b4684cfd22bbdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df1304ee03f41aed179545d1e8b4684cfd22bbdf"}], "stats": {"total": 7068, "additions": 5120, "deletions": 1948}, "files": [{"sha": "4207948a9cb2f7b5e6c779c489fe400a46c3b019", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,4 +1,4 @@\n-354b17404643\n+9f2be4fbbf69\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "84b70191384a552d09cb66cfb11799209dfc7b0c", "filename": "libgo/Makefile.am", "status": "modified", "additions": 69, "deletions": 43, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -197,6 +197,16 @@ toolexeclibgocryptox509dir = $(toolexeclibgocryptodir)/x509\n toolexeclibgocryptox509_DATA = \\\n \tcrypto/x509/pkix.gox\n \n+toolexeclibgodatabasedir = $(toolexeclibgodir)/database\n+\n+toolexeclibgodatabase_DATA = \\\n+\tdatabase/sql.gox\n+\n+toolexeclibgodatabasesqldir = $(toolexeclibgodatabasedir)/sql\n+\n+toolexeclibgodatabasesql_DATA = \\\n+\tdatabase/sql/driver.gox\n+\n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n \n toolexeclibgodebug_DATA = \\\n@@ -237,15 +247,10 @@ toolexeclibgoexp_DATA = \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n \texp/spdy.gox \\\n-\texp/sql.gox \\\n \texp/ssh.gox \\\n \texp/terminal.gox \\\n-\texp/types.gox\n-\n-toolexeclibgoexpsqldir = $(toolexeclibgoexpdir)/sql\n-\n-toolexeclibgoexpsql_DATA = \\\n-\texp/sql/driver.gox\n+\texp/types.gox \\\n+\texp/utf8string.gox\n \n toolexeclibgogodir = $(toolexeclibgodir)/go\n \n@@ -717,6 +722,7 @@ go_net_files = \\\n \tgo/net/dnsclient_unix.go \\\n \tgo/net/dnsconfig.go \\\n \tgo/net/dnsmsg.go \\\n+\tgo/net/doc.go \\\n \t$(go_net_newpollserver_file) \\\n \tgo/net/fd.go \\\n \t$(go_net_fd_os_file) \\\n@@ -793,6 +799,7 @@ endif\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n+\tgo/os/doc.go \\\n \tgo/os/env.go \\\n \tgo/os/error.go \\\n \tgo/os/error_posix.go \\\n@@ -1005,7 +1012,8 @@ go_crypto_dsa_files = \\\n go_crypto_ecdsa_files = \\\n \tgo/crypto/ecdsa/ecdsa.go\n go_crypto_elliptic_files = \\\n-\tgo/crypto/elliptic/elliptic.go\n+\tgo/crypto/elliptic/elliptic.go \\\n+\tgo/crypto/elliptic/p224.go\n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n go_crypto_md4_files = \\\n@@ -1094,6 +1102,14 @@ go_crypto_openpgp_s2k_files = \\\n go_crypto_x509_pkix_files = \\\n \tgo/crypto/x509/pkix/pkix.go\n \n+go_database_sql_files = \\\n+\tgo/database/sql/convert.go \\\n+\tgo/database/sql/sql.go\n+\n+go_database_sql_driver_files = \\\n+\tgo/database/sql/driver/driver.go \\\n+\tgo/database/sql/driver/types.go\n+\n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n@@ -1179,9 +1195,6 @@ go_exp_spdy_files = \\\n \tgo/exp/spdy/read.go \\\n \tgo/exp/spdy/types.go \\\n \tgo/exp/spdy/write.go\n-go_exp_sql_files = \\\n-\tgo/exp/sql/convert.go \\\n-\tgo/exp/sql/sql.go\n go_exp_ssh_files = \\\n \tgo/exp/ssh/channel.go \\\n \tgo/exp/ssh/cipher.go \\\n@@ -1205,10 +1218,8 @@ go_exp_types_files = \\\n \tgo/exp/types/gcimporter.go \\\n \tgo/exp/types/types.go \\\n \tgo/exp/types/universe.go\n-\n-go_exp_sql_driver_files = \\\n-\tgo/exp/sql/driver/driver.go \\\n-\tgo/exp/sql/driver/types.go\n+go_exp_utf8string_files = \\\n+\tgo/exp/utf8string/string.go\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n@@ -1467,7 +1478,6 @@ go_text_scanner_files = \\\n go_unicode_utf16_files = \\\n \tgo/unicode/utf16/utf16.go\n go_unicode_utf8_files = \\\n-\tgo/unicode/utf8/string.go \\\n \tgo/unicode/utf8/utf8.go\n \n # Define Syscall and Syscall6.\n@@ -1751,6 +1761,8 @@ libgo_go_objs = \\\n \tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n \tcrypto/x509/pkix.lo \\\n+\tdatabase/sql.lo \\\n+\tdatabase/sql/driver.lo \\\n \tdebug/dwarf.lo \\\n \tdebug/elf.lo \\\n \tdebug/gosym.lo \\\n@@ -1772,11 +1784,10 @@ libgo_go_objs = \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n \texp/spdy.lo \\\n-\texp/sql.lo \\\n \texp/ssh.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n-\texp/sql/driver.lo \\\n+\texp/utf8string.lo \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n@@ -2646,6 +2657,26 @@ crypto/x509/pkix/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/x509/pkix/check\n \n+@go_include@ database/sql.lo.dep\n+database/sql.lo.dep: $(go_database_sql_files)\n+\t$(BUILDDEPS)\n+database/sql.lo: $(go_database_sql_files)\n+\t$(BUILDPACKAGE)\n+database/sql/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) database/sql\n+\t@$(CHECK)\n+.PHONY: database/sql/check\n+\n+@go_include@ database/sql/driver.lo.dep\n+database/sql/driver.lo.dep: $(go_database_sql_driver_files)\n+\t$(BUILDDEPS)\n+database/sql/driver.lo: $(go_database_sql_driver_files)\n+\t$(BUILDPACKAGE)\n+database/sql/driver/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) database/sql/driver\n+\t@$(CHECK)\n+.PHONY: database/sql/driver/check\n+\n @go_include@ debug/dwarf.lo.dep\n debug/dwarf.lo.dep: $(go_debug_dwarf_files)\n \t$(BUILDDEPS)\n@@ -2856,16 +2887,6 @@ exp/spdy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/spdy/check\n \n-@go_include@ exp/sql.lo.dep\n-exp/sql.lo.dep: $(go_exp_sql_files)\n-\t$(BUILDDEPS)\n-exp/sql.lo: $(go_exp_sql_files)\n-\t$(BUILDPACKAGE)\n-exp/sql/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/sql\n-\t@$(CHECK)\n-.PHONY: exp/sql/check\n-\n @go_include@ exp/ssh.lo.dep\n exp/ssh.lo.dep: $(go_exp_ssh_files)\n \t$(BUILDDEPS)\n@@ -2896,6 +2917,16 @@ exp/types/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/types/check\n \n+@go_include@ exp/utf8string.lo.dep\n+exp/utf8string.lo.dep: $(go_exp_utf8string_files)\n+\t$(BUILDDEPS)\n+exp/utf8string.lo: $(go_exp_utf8string_files)\n+\t$(BUILDPACKAGE)\n+exp/utf8string/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/utf8string\n+\t@$(CHECK)\n+.PHONY: exp/utf8string/check\n+\n @go_include@ exp/inotify.lo.dep\n exp/inotify.lo.dep: $(go_exp_inotify_files)\n \t$(BUILDDEPS)\n@@ -2906,16 +2937,6 @@ exp/inotify/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/inotify/check\n \n-@go_include@ exp/sql/driver.lo.dep\n-exp/sql/driver.lo.dep: $(go_exp_sql_driver_files)\n-\t$(BUILDDEPS)\n-exp/sql/driver.lo: $(go_exp_sql_driver_files)\n-\t$(BUILDPACKAGE)\n-exp/sql/driver/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/sql/driver\n-\t@$(CHECK)\n-.PHONY: exp/sql/driver/check\n-\n @go_include@ html/template.lo.dep\n html/template.lo.dep: $(go_html_template_files)\n \t$(BUILDDEPS)\n@@ -3670,6 +3691,12 @@ crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n crypto/x509/pkix.gox: crypto/x509/pkix.lo\n \t$(BUILDGOX)\n \n+database/sql.gox: database/sql.lo\n+\t$(BUILDGOX)\n+\n+database/sql/driver.gox: database/sql/driver.lo\n+\t$(BUILDGOX)\n+\n debug/dwarf.gox: debug/dwarf.lo\n \t$(BUILDGOX)\n debug/elf.gox: debug/elf.lo\n@@ -3716,16 +3743,13 @@ exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n exp/spdy.gox: exp/spdy.lo\n \t$(BUILDGOX)\n-exp/sql.gox: exp/sql.lo\n-\t$(BUILDGOX)\n exp/ssh.gox: exp/ssh.lo\n \t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n \t$(BUILDGOX)\n-\n-exp/sql/driver.gox: exp/sql/driver.lo\n+exp/utf8string.gox: exp/utf8string.lo\t\n \t$(BUILDGOX)\n \n html/template.gox: html/template.lo\n@@ -3941,6 +3965,8 @@ TEST_PACKAGES = \\\n \tcrypto/openpgp/elgamal/check \\\n \tcrypto/openpgp/packet/check \\\n \tcrypto/openpgp/s2k/check \\\n+\tdatabase/sql/check \\\n+\tdatabase/sql/driver/check \\\n \tdebug/dwarf/check \\\n \tdebug/elf/check \\\n \tdebug/macho/check \\\n@@ -3962,9 +3988,9 @@ TEST_PACKAGES = \\\n \texp/norm/check \\\n \texp/proxy/check \\\n \texp/spdy/check \\\n-\texp/sql/check \\\n \texp/ssh/check \\\n \texp/terminal/check \\\n+\texp/utf8string/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\"}, {"sha": "31c58d912a773e5cca7396939520ceca0a98381f", "filename": "libgo/Makefile.in", "status": "modified", "additions": 174, "deletions": 122, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -99,10 +99,11 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgodatabasedir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodebugdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoencodingdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpdir)\" \\\n-\t\"$(DESTDIR)$(toolexeclibgoexpsqldir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgogodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohashdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohtmldir)\" \\\n@@ -154,33 +155,33 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \tcrypto/tls.lo crypto/twofish.lo crypto/x509.lo crypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo crypto/openpgp/elgamal.lo \\\n \tcrypto/openpgp/errors.lo crypto/openpgp/packet.lo \\\n-\tcrypto/openpgp/s2k.lo crypto/x509/pkix.lo debug/dwarf.lo \\\n-\tdebug/elf.lo debug/gosym.lo debug/macho.lo debug/pe.lo \\\n-\tencoding/ascii85.lo encoding/asn1.lo encoding/base32.lo \\\n-\tencoding/base64.lo encoding/binary.lo encoding/csv.lo \\\n-\tencoding/git85.lo encoding/gob.lo encoding/hex.lo \\\n-\tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n-\texp/norm.lo exp/proxy.lo exp/spdy.lo exp/sql.lo exp/ssh.lo \\\n-\texp/terminal.lo exp/types.lo exp/sql/driver.lo \\\n-\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/parser.lo \\\n-\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n-\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n-\tnet/http/fcgi.lo net/http/httptest.lo net/http/httputil.lo \\\n-\tnet/http/pprof.lo image/bmp.lo image/color.lo image/draw.lo \\\n-\timage/gif.lo image/jpeg.lo image/png.lo image/tiff.lo \\\n-\tindex/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n-\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n-\tmime/mime.lo mime/multipart.lo net/dict.lo net/http.lo \\\n-\tnet/mail.lo net/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n-\told/netchan.lo old/regexp.lo old/template.lo \\\n-\t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n-\tregexp/syntax.lo net/rpc/jsonrpc.lo runtime/debug.lo \\\n-\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n-\tsyscall/syscall.lo syscall/errno.lo syscall/wait.lo \\\n-\ttext/scanner.lo text/tabwriter.lo text/template.lo \\\n-\ttext/template/parse.lo testing/testing.lo testing/iotest.lo \\\n-\ttesting/quick.lo testing/script.lo unicode/utf16.lo \\\n-\tunicode/utf8.lo\n+\tcrypto/openpgp/s2k.lo crypto/x509/pkix.lo database/sql.lo \\\n+\tdatabase/sql/driver.lo debug/dwarf.lo debug/elf.lo \\\n+\tdebug/gosym.lo debug/macho.lo debug/pe.lo encoding/ascii85.lo \\\n+\tencoding/asn1.lo encoding/base32.lo encoding/base64.lo \\\n+\tencoding/binary.lo encoding/csv.lo encoding/git85.lo \\\n+\tencoding/gob.lo encoding/hex.lo encoding/json.lo \\\n+\tencoding/pem.lo encoding/xml.lo exp/ebnf.lo exp/norm.lo \\\n+\texp/proxy.lo exp/spdy.lo exp/ssh.lo exp/terminal.lo \\\n+\texp/types.lo exp/utf8string.lo html/template.lo go/ast.lo \\\n+\tgo/build.lo go/doc.lo go/parser.lo go/printer.lo go/scanner.lo \\\n+\tgo/token.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n+\thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n+\tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n+\timage/bmp.lo image/color.lo image/draw.lo image/gif.lo \\\n+\timage/jpeg.lo image/png.lo image/tiff.lo index/suffixarray.lo \\\n+\tio/ioutil.lo log/syslog.lo log/syslog/syslog_c.lo math/big.lo \\\n+\tmath/cmplx.lo math/rand.lo mime/mime.lo mime/multipart.lo \\\n+\tnet/dict.lo net/http.lo net/mail.lo net/rpc.lo net/smtp.lo \\\n+\tnet/textproto.lo net/url.lo old/netchan.lo old/regexp.lo \\\n+\told/template.lo $(am__DEPENDENCIES_1) os/user.lo os/signal.lo \\\n+\tpath/filepath.lo regexp/syntax.lo net/rpc/jsonrpc.lo \\\n+\truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n+\tsync/atomic_c.lo syscall/syscall.lo syscall/errno.lo \\\n+\tsyscall/wait.lo text/scanner.lo text/tabwriter.lo \\\n+\ttext/template.lo text/template/parse.lo testing/testing.lo \\\n+\ttesting/iotest.lo testing/quick.lo testing/script.lo \\\n+\tunicode/utf16.lo unicode/utf8.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -289,20 +290,20 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocompress_DATA) $(toolexeclibgocontainer_DATA) \\\n \t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptoopenpgp_DATA) \\\n-\t$(toolexeclibgocryptox509_DATA) $(toolexeclibgodebug_DATA) \\\n+\t$(toolexeclibgocryptox509_DATA) $(toolexeclibgodatabase_DATA) \\\n+\t$(toolexeclibgodatabasesql_DATA) $(toolexeclibgodebug_DATA) \\\n \t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n-\t$(toolexeclibgoexpsql_DATA) $(toolexeclibgogo_DATA) \\\n-\t$(toolexeclibgohash_DATA) $(toolexeclibgohtml_DATA) \\\n-\t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n-\t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n-\t$(toolexeclibgomath_DATA) $(toolexeclibgomime_DATA) \\\n-\t$(toolexeclibgonet_DATA) $(toolexeclibgonethttp_DATA) \\\n-\t$(toolexeclibgonetrpc_DATA) $(toolexeclibgoold_DATA) \\\n-\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n-\t$(toolexeclibgoregexp_DATA) $(toolexeclibgoruntime_DATA) \\\n-\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n-\t$(toolexeclibgotext_DATA) $(toolexeclibgotexttemplate_DATA) \\\n-\t$(toolexeclibgounicode_DATA)\n+\t$(toolexeclibgogo_DATA) $(toolexeclibgohash_DATA) \\\n+\t$(toolexeclibgohtml_DATA) $(toolexeclibgoimage_DATA) \\\n+\t$(toolexeclibgoindex_DATA) $(toolexeclibgoio_DATA) \\\n+\t$(toolexeclibgolog_DATA) $(toolexeclibgomath_DATA) \\\n+\t$(toolexeclibgomime_DATA) $(toolexeclibgonet_DATA) \\\n+\t$(toolexeclibgonethttp_DATA) $(toolexeclibgonetrpc_DATA) \\\n+\t$(toolexeclibgoold_DATA) $(toolexeclibgoos_DATA) \\\n+\t$(toolexeclibgopath_DATA) $(toolexeclibgoregexp_DATA) \\\n+\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n+\t$(toolexeclibgotesting_DATA) $(toolexeclibgotext_DATA) \\\n+\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -661,6 +662,14 @@ toolexeclibgocryptox509dir = $(toolexeclibgocryptodir)/x509\n toolexeclibgocryptox509_DATA = \\\n \tcrypto/x509/pkix.gox\n \n+toolexeclibgodatabasedir = $(toolexeclibgodir)/database\n+toolexeclibgodatabase_DATA = \\\n+\tdatabase/sql.gox\n+\n+toolexeclibgodatabasesqldir = $(toolexeclibgodatabasedir)/sql\n+toolexeclibgodatabasesql_DATA = \\\n+\tdatabase/sql/driver.gox\n+\n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n toolexeclibgodebug_DATA = \\\n \tdebug/dwarf.gox \\\n@@ -695,14 +704,10 @@ toolexeclibgoexp_DATA = \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n \texp/spdy.gox \\\n-\texp/sql.gox \\\n \texp/ssh.gox \\\n \texp/terminal.gox \\\n-\texp/types.gox\n-\n-toolexeclibgoexpsqldir = $(toolexeclibgoexpdir)/sql\n-toolexeclibgoexpsql_DATA = \\\n-\texp/sql/driver.gox\n+\texp/types.gox \\\n+\texp/utf8string.gox\n \n toolexeclibgogodir = $(toolexeclibgodir)/go\n toolexeclibgogo_DATA = \\\n@@ -1072,6 +1077,7 @@ go_net_files = \\\n \tgo/net/dnsclient_unix.go \\\n \tgo/net/dnsconfig.go \\\n \tgo/net/dnsmsg.go \\\n+\tgo/net/doc.go \\\n \t$(go_net_newpollserver_file) \\\n \tgo/net/fd.go \\\n \t$(go_net_fd_os_file) \\\n@@ -1118,6 +1124,7 @@ go_net_files = \\\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n+\tgo/os/doc.go \\\n \tgo/os/env.go \\\n \tgo/os/error.go \\\n \tgo/os/error_posix.go \\\n@@ -1320,7 +1327,8 @@ go_crypto_ecdsa_files = \\\n \tgo/crypto/ecdsa/ecdsa.go\n \n go_crypto_elliptic_files = \\\n-\tgo/crypto/elliptic/elliptic.go\n+\tgo/crypto/elliptic/elliptic.go \\\n+\tgo/crypto/elliptic/p224.go\n \n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n@@ -1430,6 +1438,14 @@ go_crypto_openpgp_s2k_files = \\\n go_crypto_x509_pkix_files = \\\n \tgo/crypto/x509/pkix/pkix.go\n \n+go_database_sql_files = \\\n+\tgo/database/sql/convert.go \\\n+\tgo/database/sql/sql.go\n+\n+go_database_sql_driver_files = \\\n+\tgo/database/sql/driver/driver.go \\\n+\tgo/database/sql/driver/types.go\n+\n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n@@ -1535,10 +1551,6 @@ go_exp_spdy_files = \\\n \tgo/exp/spdy/types.go \\\n \tgo/exp/spdy/write.go\n \n-go_exp_sql_files = \\\n-\tgo/exp/sql/convert.go \\\n-\tgo/exp/sql/sql.go\n-\n go_exp_ssh_files = \\\n \tgo/exp/ssh/channel.go \\\n \tgo/exp/ssh/cipher.go \\\n@@ -1565,9 +1577,8 @@ go_exp_types_files = \\\n \tgo/exp/types/types.go \\\n \tgo/exp/types/universe.go\n \n-go_exp_sql_driver_files = \\\n-\tgo/exp/sql/driver/driver.go \\\n-\tgo/exp/sql/driver/types.go\n+go_exp_utf8string_files = \\\n+\tgo/exp/utf8string/string.go\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n@@ -1854,7 +1865,6 @@ go_unicode_utf16_files = \\\n \tgo/unicode/utf16/utf16.go\n \n go_unicode_utf8_files = \\\n-\tgo/unicode/utf8/string.go \\\n \tgo/unicode/utf8/utf8.go\n \n @LIBGO_IS_RTEMS_FALSE@syscall_syscall_file = go/syscall/syscall_unix.go\n@@ -2025,6 +2035,8 @@ libgo_go_objs = \\\n \tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n \tcrypto/x509/pkix.lo \\\n+\tdatabase/sql.lo \\\n+\tdatabase/sql/driver.lo \\\n \tdebug/dwarf.lo \\\n \tdebug/elf.lo \\\n \tdebug/gosym.lo \\\n@@ -2046,11 +2058,10 @@ libgo_go_objs = \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n \texp/spdy.lo \\\n-\texp/sql.lo \\\n \texp/ssh.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n-\texp/sql/driver.lo \\\n+\texp/utf8string.lo \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n@@ -2294,6 +2305,8 @@ TEST_PACKAGES = \\\n \tcrypto/openpgp/elgamal/check \\\n \tcrypto/openpgp/packet/check \\\n \tcrypto/openpgp/s2k/check \\\n+\tdatabase/sql/check \\\n+\tdatabase/sql/driver/check \\\n \tdebug/dwarf/check \\\n \tdebug/elf/check \\\n \tdebug/macho/check \\\n@@ -2315,9 +2328,9 @@ TEST_PACKAGES = \\\n \texp/norm/check \\\n \texp/proxy/check \\\n \texp/spdy/check \\\n-\texp/sql/check \\\n \texp/ssh/check \\\n \texp/terminal/check \\\n+\texp/utf8string/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\\n@@ -3365,6 +3378,46 @@ uninstall-toolexeclibgocryptox509DATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgocryptox509dir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" && rm -f $$files\n+install-toolexeclibgodatabaseDATA: $(toolexeclibgodatabase_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgodatabasedir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgodatabasedir)\"\n+\t@list='$(toolexeclibgodatabase_DATA)'; test -n \"$(toolexeclibgodatabasedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgodatabasedir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgodatabasedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgodatabaseDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgodatabase_DATA)'; test -n \"$(toolexeclibgodatabasedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgodatabasedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgodatabasedir)\" && rm -f $$files\n+install-toolexeclibgodatabasesqlDATA: $(toolexeclibgodatabasesql_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgodatabasesqldir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\"\n+\t@list='$(toolexeclibgodatabasesql_DATA)'; test -n \"$(toolexeclibgodatabasesqldir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgodatabasesqldir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgodatabasesqlDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgodatabasesql_DATA)'; test -n \"$(toolexeclibgodatabasesqldir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgodatabasesqldir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" && rm -f $$files\n install-toolexeclibgodebugDATA: $(toolexeclibgodebug_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgodebugdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgodebugdir)\"\n@@ -3425,26 +3478,6 @@ uninstall-toolexeclibgoexpDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoexpdir)\" && rm -f $$files\n-install-toolexeclibgoexpsqlDATA: $(toolexeclibgoexpsql_DATA)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(toolexeclibgoexpsqldir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpsqldir)\"\n-\t@list='$(toolexeclibgoexpsql_DATA)'; test -n \"$(toolexeclibgoexpsqldir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexpsqldir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-toolexeclibgoexpsqlDATA:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclibgoexpsql_DATA)'; test -n \"$(toolexeclibgoexpsqldir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\ttest -n \"$$files\" || exit 0; \\\n-\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpsqldir)' && rm -f\" $$files \")\"; \\\n-\tcd \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" && rm -f $$files\n install-toolexeclibgogoDATA: $(toolexeclibgogo_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgogodir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgogodir)\"\n@@ -4202,7 +4235,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -4270,14 +4303,16 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocryptoDATA \\\n \tinstall-toolexeclibgocryptoopenpgpDATA \\\n \tinstall-toolexeclibgocryptox509DATA \\\n+\tinstall-toolexeclibgodatabaseDATA \\\n+\tinstall-toolexeclibgodatabasesqlDATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n-\tinstall-toolexeclibgoexpsqlDATA install-toolexeclibgogoDATA \\\n-\tinstall-toolexeclibgohashDATA install-toolexeclibgohtmlDATA \\\n-\tinstall-toolexeclibgoimageDATA install-toolexeclibgoindexDATA \\\n-\tinstall-toolexeclibgoioDATA install-toolexeclibgologDATA \\\n-\tinstall-toolexeclibgomathDATA install-toolexeclibgomimeDATA \\\n-\tinstall-toolexeclibgonetDATA install-toolexeclibgonethttpDATA \\\n+\tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n+\tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n+\tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n+\tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n+\tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n+\tinstall-toolexeclibgonethttpDATA \\\n \tinstall-toolexeclibgonetrpcDATA install-toolexeclibgooldDATA \\\n \tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n \tinstall-toolexeclibgoregexpDATA \\\n@@ -4334,11 +4369,12 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgocryptoDATA \\\n \tuninstall-toolexeclibgocryptoopenpgpDATA \\\n \tuninstall-toolexeclibgocryptox509DATA \\\n+\tuninstall-toolexeclibgodatabaseDATA \\\n+\tuninstall-toolexeclibgodatabasesqlDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA \\\n-\tuninstall-toolexeclibgoexpsqlDATA \\\n-\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n+\tuninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n@@ -4382,14 +4418,16 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocryptoDATA \\\n \tinstall-toolexeclibgocryptoopenpgpDATA \\\n \tinstall-toolexeclibgocryptox509DATA \\\n+\tinstall-toolexeclibgodatabaseDATA \\\n+\tinstall-toolexeclibgodatabasesqlDATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n-\tinstall-toolexeclibgoexpsqlDATA install-toolexeclibgogoDATA \\\n-\tinstall-toolexeclibgohashDATA install-toolexeclibgohtmlDATA \\\n-\tinstall-toolexeclibgoimageDATA install-toolexeclibgoindexDATA \\\n-\tinstall-toolexeclibgoioDATA install-toolexeclibgologDATA \\\n-\tinstall-toolexeclibgomathDATA install-toolexeclibgomimeDATA \\\n-\tinstall-toolexeclibgonetDATA install-toolexeclibgonethttpDATA \\\n+\tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n+\tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n+\tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n+\tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n+\tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n+\tinstall-toolexeclibgonethttpDATA \\\n \tinstall-toolexeclibgonetrpcDATA install-toolexeclibgooldDATA \\\n \tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n \tinstall-toolexeclibgoregexpDATA \\\n@@ -4410,11 +4448,12 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgocryptoDATA \\\n \tuninstall-toolexeclibgocryptoopenpgpDATA \\\n \tuninstall-toolexeclibgocryptox509DATA \\\n+\tuninstall-toolexeclibgodatabaseDATA \\\n+\tuninstall-toolexeclibgodatabasesqlDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA \\\n-\tuninstall-toolexeclibgoexpsqlDATA \\\n-\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n+\tuninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n@@ -5230,6 +5269,26 @@ crypto/x509/pkix/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/x509/pkix/check\n \n+@go_include@ database/sql.lo.dep\n+database/sql.lo.dep: $(go_database_sql_files)\n+\t$(BUILDDEPS)\n+database/sql.lo: $(go_database_sql_files)\n+\t$(BUILDPACKAGE)\n+database/sql/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) database/sql\n+\t@$(CHECK)\n+.PHONY: database/sql/check\n+\n+@go_include@ database/sql/driver.lo.dep\n+database/sql/driver.lo.dep: $(go_database_sql_driver_files)\n+\t$(BUILDDEPS)\n+database/sql/driver.lo: $(go_database_sql_driver_files)\n+\t$(BUILDPACKAGE)\n+database/sql/driver/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) database/sql/driver\n+\t@$(CHECK)\n+.PHONY: database/sql/driver/check\n+\n @go_include@ debug/dwarf.lo.dep\n debug/dwarf.lo.dep: $(go_debug_dwarf_files)\n \t$(BUILDDEPS)\n@@ -5440,16 +5499,6 @@ exp/spdy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/spdy/check\n \n-@go_include@ exp/sql.lo.dep\n-exp/sql.lo.dep: $(go_exp_sql_files)\n-\t$(BUILDDEPS)\n-exp/sql.lo: $(go_exp_sql_files)\n-\t$(BUILDPACKAGE)\n-exp/sql/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/sql\n-\t@$(CHECK)\n-.PHONY: exp/sql/check\n-\n @go_include@ exp/ssh.lo.dep\n exp/ssh.lo.dep: $(go_exp_ssh_files)\n \t$(BUILDDEPS)\n@@ -5480,6 +5529,16 @@ exp/types/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/types/check\n \n+@go_include@ exp/utf8string.lo.dep\n+exp/utf8string.lo.dep: $(go_exp_utf8string_files)\n+\t$(BUILDDEPS)\n+exp/utf8string.lo: $(go_exp_utf8string_files)\n+\t$(BUILDPACKAGE)\n+exp/utf8string/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/utf8string\n+\t@$(CHECK)\n+.PHONY: exp/utf8string/check\n+\n @go_include@ exp/inotify.lo.dep\n exp/inotify.lo.dep: $(go_exp_inotify_files)\n \t$(BUILDDEPS)\n@@ -5490,16 +5549,6 @@ exp/inotify/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/inotify/check\n \n-@go_include@ exp/sql/driver.lo.dep\n-exp/sql/driver.lo.dep: $(go_exp_sql_driver_files)\n-\t$(BUILDDEPS)\n-exp/sql/driver.lo: $(go_exp_sql_driver_files)\n-\t$(BUILDPACKAGE)\n-exp/sql/driver/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/sql/driver\n-\t@$(CHECK)\n-.PHONY: exp/sql/driver/check\n-\n @go_include@ html/template.lo.dep\n html/template.lo.dep: $(go_html_template_files)\n \t$(BUILDDEPS)\n@@ -6249,6 +6298,12 @@ crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n crypto/x509/pkix.gox: crypto/x509/pkix.lo\n \t$(BUILDGOX)\n \n+database/sql.gox: database/sql.lo\n+\t$(BUILDGOX)\n+\n+database/sql/driver.gox: database/sql/driver.lo\n+\t$(BUILDGOX)\n+\n debug/dwarf.gox: debug/dwarf.lo\n \t$(BUILDGOX)\n debug/elf.gox: debug/elf.lo\n@@ -6295,16 +6350,13 @@ exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n exp/spdy.gox: exp/spdy.lo\n \t$(BUILDGOX)\n-exp/sql.gox: exp/sql.lo\n-\t$(BUILDGOX)\n exp/ssh.gox: exp/ssh.lo\n \t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n \t$(BUILDGOX)\n-\n-exp/sql/driver.gox: exp/sql/driver.lo\n+exp/utf8string.gox: exp/utf8string.lo\t\n \t$(BUILDGOX)\n \n html/template.gox: html/template.lo"}, {"sha": "0234a012a4e8187e612dac0c260ea2eebbaaa5de", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package bytes_test\n \n import ("}, {"sha": "7af636b45133c4b56df97cc19d37a0da866cb512", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -3,7 +3,13 @@\n // license that can be found in the LICENSE file.\n \n // Package heap provides heap operations for any type that implements\n-// heap.Interface.\n+// heap.Interface. A heap is a tree with the property that each node is the\n+// highest-valued node in its subtree.\n+//\n+// A heap is a common way to impement a priority queue. To build a priority\n+// queue, implement the Heap interface with the (negative) priority as the\n+// ordering for the Less method, so Push adds items while Pop removes the\n+// highest-priority item from the queue.\n //\n package heap\n "}, {"sha": "d2f7d8f9bb3a6168b5ab9842451dce4c5c15c626", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -20,7 +20,7 @@ import (\n \n // PublicKey represents an ECDSA public key.\n type PublicKey struct {\n-\t*elliptic.Curve\n+\telliptic.Curve\n \tX, Y *big.Int\n }\n \n@@ -34,22 +34,23 @@ var one = new(big.Int).SetInt64(1)\n \n // randFieldElement returns a random element of the field underlying the given\n // curve using the procedure given in [NSA] A.2.1.\n-func randFieldElement(c *elliptic.Curve, rand io.Reader) (k *big.Int, err error) {\n-\tb := make([]byte, c.BitSize/8+8)\n+func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error) {\n+\tparams := c.Params()\n+\tb := make([]byte, params.BitSize/8+8)\n \t_, err = io.ReadFull(rand, b)\n \tif err != nil {\n \t\treturn\n \t}\n \n \tk = new(big.Int).SetBytes(b)\n-\tn := new(big.Int).Sub(c.N, one)\n+\tn := new(big.Int).Sub(params.N, one)\n \tk.Mod(k, n)\n \tk.Add(k, one)\n \treturn\n }\n \n // GenerateKey generates a public&private key pair.\n-func GenerateKey(c *elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error) {\n+func GenerateKey(c elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error) {\n \tk, err := randFieldElement(c, rand)\n \tif err != nil {\n \t\treturn\n@@ -66,8 +67,8 @@ func GenerateKey(c *elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error\n // about how this is done. [NSA] suggests that this is done in the obvious\n // manner, but [SECG] truncates the hash to the bit-length of the curve order\n // first. We follow [SECG] because that's what OpenSSL does.\n-func hashToInt(hash []byte, c *elliptic.Curve) *big.Int {\n-\torderBits := c.N.BitLen()\n+func hashToInt(hash []byte, c elliptic.Curve) *big.Int {\n+\torderBits := c.Params().N.BitLen()\n \torderBytes := (orderBits + 7) / 8\n \tif len(hash) > orderBytes {\n \t\thash = hash[:orderBytes]\n@@ -88,6 +89,7 @@ func hashToInt(hash []byte, c *elliptic.Curve) *big.Int {\n func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n \t// See [NSA] 3.4.1\n \tc := priv.PublicKey.Curve\n+\tN := c.Params().N\n \n \tvar k, kInv *big.Int\n \tfor {\n@@ -98,9 +100,9 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \t\t\t\treturn\n \t\t\t}\n \n-\t\t\tkInv = new(big.Int).ModInverse(k, c.N)\n+\t\t\tkInv = new(big.Int).ModInverse(k, N)\n \t\t\tr, _ = priv.Curve.ScalarBaseMult(k.Bytes())\n-\t\t\tr.Mod(r, priv.Curve.N)\n+\t\t\tr.Mod(r, N)\n \t\t\tif r.Sign() != 0 {\n \t\t\t\tbreak\n \t\t\t}\n@@ -110,7 +112,7 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \t\ts = new(big.Int).Mul(priv.D, r)\n \t\ts.Add(s, e)\n \t\ts.Mul(s, kInv)\n-\t\ts.Mod(s, priv.PublicKey.Curve.N)\n+\t\ts.Mod(s, N)\n \t\tif s.Sign() != 0 {\n \t\t\tbreak\n \t\t}\n@@ -124,15 +126,16 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \t// See [NSA] 3.4.2\n \tc := pub.Curve\n+\tN := c.Params().N\n \n \tif r.Sign() == 0 || s.Sign() == 0 {\n \t\treturn false\n \t}\n-\tif r.Cmp(c.N) >= 0 || s.Cmp(c.N) >= 0 {\n+\tif r.Cmp(N) >= 0 || s.Cmp(N) >= 0 {\n \t\treturn false\n \t}\n \te := hashToInt(hash, c)\n-\tw := new(big.Int).ModInverse(s, c.N)\n+\tw := new(big.Int).ModInverse(s, N)\n \n \tu1 := e.Mul(e, w)\n \tu2 := w.Mul(r, w)\n@@ -143,6 +146,6 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \t\treturn false\n \t}\n \tx, _ := c.Add(x1, y1, x2, y2)\n-\tx.Mod(x, c.N)\n+\tx.Mod(x, N)\n \treturn x.Cmp(r) == 0\n }"}, {"sha": "3a2b3efbab3921f90c905323afe82e1e8b489cb6", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -13,7 +13,7 @@ import (\n \t\"testing\"\n )\n \n-func testKeyGeneration(t *testing.T, c *elliptic.Curve, tag string) {\n+func testKeyGeneration(t *testing.T, c elliptic.Curve, tag string) {\n \tpriv, err := GenerateKey(c, rand.Reader)\n \tif err != nil {\n \t\tt.Errorf(\"%s: error: %s\", tag, err)\n@@ -34,7 +34,7 @@ func TestKeyGeneration(t *testing.T) {\n \ttestKeyGeneration(t, elliptic.P521(), \"p521\")\n }\n \n-func testSignAndVerify(t *testing.T, c *elliptic.Curve, tag string) {\n+func testSignAndVerify(t *testing.T, c elliptic.Curve, tag string) {\n \tpriv, _ := GenerateKey(c, rand.Reader)\n \n \thashed := []byte(\"testing\")"}, {"sha": "30835a90b91a1691e7fd2c81c150df6406fbf667", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -21,16 +21,37 @@ import (\n \n // A Curve represents a short-form Weierstrass curve with a=-3.\n // See http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\n-type Curve struct {\n+type Curve interface {\n+\t// Params returns the parameters for the curve.\n+\tParams() *CurveParams\n+\t// IsOnCurve returns true if the given (x,y) lies on the curve.\n+\tIsOnCurve(x, y *big.Int) bool\n+\t// Add returns the sum of (x1,y1) and (x2,y2)\n+\tAdd(x1, y1, x2, y2 *big.Int) (x, y *big.Int)\n+\t// Double returns 2*(x,y)\n+\tDouble(x1, y1 *big.Int) (x, y *big.Int)\n+\t// ScalarMult returns k*(Bx,By) where k is a number in big-endian form.\n+\tScalarMult(x1, y1 *big.Int, scalar []byte) (x, y *big.Int)\n+\t// ScalarBaseMult returns k*G, where G is the base point of the group and k\n+\t// is an integer in big-endian form.\n+\tScalarBaseMult(scalar []byte) (x, y *big.Int)\n+}\n+\n+// CurveParams contains the parameters of an elliptic curve and also provides\n+// a generic, non-constant time implementation of Curve.\n+type CurveParams struct {\n \tP       *big.Int // the order of the underlying field\n \tN       *big.Int // the order of the base point\n \tB       *big.Int // the constant of the curve equation\n \tGx, Gy  *big.Int // (x,y) of the base point\n \tBitSize int      // the size of the underlying field\n }\n \n-// IsOnCurve returns true if the given (x,y) lies on the curve.\n-func (curve *Curve) IsOnCurve(x, y *big.Int) bool {\n+func (curve *CurveParams) Params() *CurveParams {\n+\treturn curve\n+}\n+\n+func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {\n \t// y\u00b2 = x\u00b3 - 3x + b\n \ty2 := new(big.Int).Mul(y, y)\n \ty2.Mod(y2, curve.P)\n@@ -50,7 +71,7 @@ func (curve *Curve) IsOnCurve(x, y *big.Int) bool {\n \n // affineFromJacobian reverses the Jacobian transform. See the comment at the\n // top of the file.\n-func (curve *Curve) affineFromJacobian(x, y, z *big.Int) (xOut, yOut *big.Int) {\n+func (curve *CurveParams) affineFromJacobian(x, y, z *big.Int) (xOut, yOut *big.Int) {\n \tzinv := new(big.Int).ModInverse(z, curve.P)\n \tzinvsq := new(big.Int).Mul(zinv, zinv)\n \n@@ -62,15 +83,14 @@ func (curve *Curve) affineFromJacobian(x, y, z *big.Int) (xOut, yOut *big.Int) {\n \treturn\n }\n \n-// Add returns the sum of (x1,y1) and (x2,y2)\n-func (curve *Curve) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) {\n+func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) {\n \tz := new(big.Int).SetInt64(1)\n \treturn curve.affineFromJacobian(curve.addJacobian(x1, y1, z, x2, y2, z))\n }\n \n // addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and\n // (x2, y2, z2) and returns their sum, also in Jacobian form.\n-func (curve *Curve) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int, *big.Int, *big.Int) {\n+func (curve *CurveParams) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int, *big.Int, *big.Int) {\n \t// See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl\n \tz1z1 := new(big.Int).Mul(z1, z1)\n \tz1z1.Mod(z1z1, curve.P)\n@@ -133,15 +153,14 @@ func (curve *Curve) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int, *big\n \treturn x3, y3, z3\n }\n \n-// Double returns 2*(x,y)\n-func (curve *Curve) Double(x1, y1 *big.Int) (*big.Int, *big.Int) {\n+func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int) {\n \tz1 := new(big.Int).SetInt64(1)\n \treturn curve.affineFromJacobian(curve.doubleJacobian(x1, y1, z1))\n }\n \n // doubleJacobian takes a point in Jacobian coordinates, (x, y, z), and\n // returns its double, also in Jacobian form.\n-func (curve *Curve) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int, *big.Int) {\n+func (curve *CurveParams) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int, *big.Int) {\n \t// See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n \tdelta := new(big.Int).Mul(z, z)\n \tdelta.Mod(delta, curve.P)\n@@ -199,8 +218,7 @@ func (curve *Curve) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int, *big.I\n \treturn x3, y3, z3\n }\n \n-// ScalarMult returns k*(Bx,By) where k is a number in big-endian form.\n-func (curve *Curve) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) {\n+func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) {\n \t// We have a slight problem in that the identity of the group (the\n \t// point at infinity) cannot be represented in (x, y) form on a finite\n \t// machine. Thus the standard add/double algorithm has to be tweaked\n@@ -238,18 +256,17 @@ func (curve *Curve) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) {\n \treturn curve.affineFromJacobian(x, y, z)\n }\n \n-// ScalarBaseMult returns k*G, where G is the base point of the group and k is\n-// an integer in big-endian form.\n-func (curve *Curve) ScalarBaseMult(k []byte) (*big.Int, *big.Int) {\n+func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int) {\n \treturn curve.ScalarMult(curve.Gx, curve.Gy, k)\n }\n \n var mask = []byte{0xff, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f}\n \n-// GenerateKey returns a public/private key pair. The private key is generated\n-// using the given reader, which must return random data.\n-func (curve *Curve) GenerateKey(rand io.Reader) (priv []byte, x, y *big.Int, err error) {\n-\tbyteLen := (curve.BitSize + 7) >> 3\n+// GenerateKey returns a public/private key pair. The private key is\n+// generated using the given reader, which must return random data.\n+func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error) {\n+\tbitSize := curve.Params().BitSize\n+\tbyteLen := (bitSize + 7) >> 3\n \tpriv = make([]byte, byteLen)\n \n \tfor x == nil {\n@@ -259,7 +276,7 @@ func (curve *Curve) GenerateKey(rand io.Reader) (priv []byte, x, y *big.Int, err\n \t\t}\n \t\t// We have to mask off any excess bits in the case that the size of the\n \t\t// underlying field is not a whole number of bytes.\n-\t\tpriv[0] &= mask[curve.BitSize%8]\n+\t\tpriv[0] &= mask[bitSize%8]\n \t\t// This is because, in tests, rand will return all zeros and we don't\n \t\t// want to get the point at infinity and loop forever.\n \t\tpriv[1] ^= 0x42\n@@ -268,10 +285,9 @@ func (curve *Curve) GenerateKey(rand io.Reader) (priv []byte, x, y *big.Int, err\n \treturn\n }\n \n-// Marshal converts a point into the form specified in section 4.3.6 of ANSI\n-// X9.62.\n-func (curve *Curve) Marshal(x, y *big.Int) []byte {\n-\tbyteLen := (curve.BitSize + 7) >> 3\n+// Marshal converts a point into the form specified in section 4.3.6 of ANSI X9.62.\n+func Marshal(curve Curve, x, y *big.Int) []byte {\n+\tbyteLen := (curve.Params().BitSize + 7) >> 3\n \n \tret := make([]byte, 1+2*byteLen)\n \tret[0] = 4 // uncompressed point\n@@ -283,10 +299,9 @@ func (curve *Curve) Marshal(x, y *big.Int) []byte {\n \treturn ret\n }\n \n-// Unmarshal converts a point, serialized by Marshal, into an x, y pair. On\n-// error, x = nil.\n-func (curve *Curve) Unmarshal(data []byte) (x, y *big.Int) {\n-\tbyteLen := (curve.BitSize + 7) >> 3\n+// Unmarshal converts a point, serialized by Marshal, into an x, y pair. On error, x = nil.\n+func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n+\tbyteLen := (curve.Params().BitSize + 7) >> 3\n \tif len(data) != 1+2*byteLen {\n \t\treturn\n \t}\n@@ -299,10 +314,9 @@ func (curve *Curve) Unmarshal(data []byte) (x, y *big.Int) {\n }\n \n var initonce sync.Once\n-var p224 *Curve\n-var p256 *Curve\n-var p384 *Curve\n-var p521 *Curve\n+var p256 *CurveParams\n+var p384 *CurveParams\n+var p521 *CurveParams\n \n func initAll() {\n \tinitP224()\n@@ -311,20 +325,9 @@ func initAll() {\n \tinitP521()\n }\n \n-func initP224() {\n-\t// See FIPS 186-3, section D.2.2\n-\tp224 = new(Curve)\n-\tp224.P, _ = new(big.Int).SetString(\"26959946667150639794667015087019630673557916260026308143510066298881\", 10)\n-\tp224.N, _ = new(big.Int).SetString(\"26959946667150639794667015087019625940457807714424391721682722368061\", 10)\n-\tp224.B, _ = new(big.Int).SetString(\"b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", 16)\n-\tp224.Gx, _ = new(big.Int).SetString(\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", 16)\n-\tp224.Gy, _ = new(big.Int).SetString(\"bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\", 16)\n-\tp224.BitSize = 224\n-}\n-\n func initP256() {\n \t// See FIPS 186-3, section D.2.3\n-\tp256 = new(Curve)\n+\tp256 = new(CurveParams)\n \tp256.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n \tp256.N, _ = new(big.Int).SetString(\"115792089210356248762697446949407573529996955224135760342422259061068512044369\", 10)\n \tp256.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)\n@@ -335,7 +338,7 @@ func initP256() {\n \n func initP384() {\n \t// See FIPS 186-3, section D.2.4\n-\tp384 = new(Curve)\n+\tp384 = new(CurveParams)\n \tp384.P, _ = new(big.Int).SetString(\"39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\", 10)\n \tp384.N, _ = new(big.Int).SetString(\"39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\", 10)\n \tp384.B, _ = new(big.Int).SetString(\"b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\", 16)\n@@ -346,7 +349,7 @@ func initP384() {\n \n func initP521() {\n \t// See FIPS 186-3, section D.2.5\n-\tp521 = new(Curve)\n+\tp521 = new(CurveParams)\n \tp521.P, _ = new(big.Int).SetString(\"6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\", 10)\n \tp521.N, _ = new(big.Int).SetString(\"6864797660130609714981900799081393217269435300143305409394463459185543183397655394245057746333217197532963996371363321113864768612440380340372808892707005449\", 10)\n \tp521.B, _ = new(big.Int).SetString(\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\", 16)\n@@ -355,26 +358,20 @@ func initP521() {\n \tp521.BitSize = 521\n }\n \n-// P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2)\n-func P224() *Curve {\n-\tinitonce.Do(initAll)\n-\treturn p224\n-}\n-\n // P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n-func P256() *Curve {\n+func P256() Curve {\n \tinitonce.Do(initAll)\n \treturn p256\n }\n \n // P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n-func P384() *Curve {\n+func P384() Curve {\n \tinitonce.Do(initAll)\n \treturn p384\n }\n \n // P256 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n-func P521() *Curve {\n+func P521() Curve {\n \tinitonce.Do(initAll)\n \treturn p521\n }"}, {"sha": "c23af754f78f0aa580c975b530e85253018fba6e", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -13,7 +13,7 @@ import (\n \n func TestOnCurve(t *testing.T) {\n \tp224 := P224()\n-\tif !p224.IsOnCurve(p224.Gx, p224.Gy) {\n+\tif !p224.IsOnCurve(p224.Params().Gx, p224.Params().Gy) {\n \t\tt.Errorf(\"FAIL\")\n \t}\n }\n@@ -295,7 +295,25 @@ func TestBaseMult(t *testing.T) {\n \t\t}\n \t\tx, y := p224.ScalarBaseMult(k.Bytes())\n \t\tif fmt.Sprintf(\"%x\", x) != e.x || fmt.Sprintf(\"%x\", y) != e.y {\n-\t\t\tt.Errorf(\"%d: bad output for k=%s: got (%x, %s), want (%x, %s)\", i, e.k, x, y, e.x, e.y)\n+\t\t\tt.Errorf(\"%d: bad output for k=%s: got (%x, %x), want (%s, %s)\", i, e.k, x, y, e.x, e.y)\n+\t\t}\n+\t\tif testing.Short() && i > 5 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+func TestGenericBaseMult(t *testing.T) {\n+\t// We use the P224 CurveParams directly in order to test the generic implementation.\n+\tp224 := P224().Params()\n+\tfor i, e := range p224BaseMultTests {\n+\t\tk, ok := new(big.Int).SetString(e.k, 10)\n+\t\tif !ok {\n+\t\t\tt.Errorf(\"%d: bad value for k: %s\", i, e.k)\n+\t\t}\n+\t\tx, y := p224.ScalarBaseMult(k.Bytes())\n+\t\tif fmt.Sprintf(\"%x\", x) != e.x || fmt.Sprintf(\"%x\", y) != e.y {\n+\t\t\tt.Errorf(\"%d: bad output for k=%s: got (%x, %x), want (%s, %s)\", i, e.k, x, y, e.x, e.y)\n \t\t}\n \t\tif testing.Short() && i > 5 {\n \t\t\tbreak\n@@ -316,13 +334,13 @@ func BenchmarkBaseMult(b *testing.B) {\n \n func TestMarshal(t *testing.T) {\n \tp224 := P224()\n-\t_, x, y, err := p224.GenerateKey(rand.Reader)\n+\t_, x, y, err := GenerateKey(p224, rand.Reader)\n \tif err != nil {\n \t\tt.Error(err)\n \t\treturn\n \t}\n-\tserialized := p224.Marshal(x, y)\n-\txx, yy := p224.Unmarshal(serialized)\n+\tserialized := Marshal(p224, x, y)\n+\txx, yy := Unmarshal(p224, serialized)\n \tif xx == nil {\n \t\tt.Error(\"failed to unmarshal\")\n \t\treturn"}, {"sha": "08db5bcc679f503005e03ff757a7a59df1b8d9e7", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "added", "additions": 685, "deletions": 0, "changes": 685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,685 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package elliptic\n+\n+// This is a constant-time, 32-bit implementation of P224. See FIPS 186-3,\n+// section D.2.2.\n+//\n+// See http://www.imperialviolet.org/2010/12/04/ecc.html ([1]) for background.\n+\n+import (\n+\t\"math/big\"\n+)\n+\n+var p224 p224Curve\n+\n+type p224Curve struct {\n+\t*CurveParams\n+\tgx, gy, b p224FieldElement\n+}\n+\n+func initP224() {\n+\t// See FIPS 186-3, section D.2.2\n+\tp224.CurveParams = new(CurveParams)\n+\tp224.P, _ = new(big.Int).SetString(\"26959946667150639794667015087019630673557916260026308143510066298881\", 10)\n+\tp224.N, _ = new(big.Int).SetString(\"26959946667150639794667015087019625940457807714424391721682722368061\", 10)\n+\tp224.B, _ = new(big.Int).SetString(\"b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", 16)\n+\tp224.Gx, _ = new(big.Int).SetString(\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", 16)\n+\tp224.Gy, _ = new(big.Int).SetString(\"bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\", 16)\n+\tp224.BitSize = 224\n+\n+\tp224FromBig(&p224.gx, p224.Gx)\n+\tp224FromBig(&p224.gy, p224.Gy)\n+\tp224FromBig(&p224.b, p224.B)\n+}\n+\n+// P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2)\n+func P224() Curve {\n+\tinitonce.Do(initAll)\n+\treturn p224\n+}\n+\n+func (curve p224Curve) Params() *CurveParams {\n+\treturn curve.CurveParams\n+}\n+\n+func (curve p224Curve) IsOnCurve(bigX, bigY *big.Int) bool {\n+\tvar x, y p224FieldElement\n+\tp224FromBig(&x, bigX)\n+\tp224FromBig(&y, bigY)\n+\n+\t// y\u00b2 = x\u00b3 - 3x + b\n+\tvar tmp p224LargeFieldElement\n+\tvar x3 p224FieldElement\n+\tp224Square(&x3, &x, &tmp)\n+\tp224Mul(&x3, &x3, &x, &tmp)\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tx[i] *= 3\n+\t}\n+\tp224Sub(&x3, &x3, &x)\n+\tp224Reduce(&x3)\n+\tp224Add(&x3, &x3, &curve.b)\n+\tp224Contract(&x3, &x3)\n+\n+\tp224Square(&y, &y, &tmp)\n+\tp224Contract(&y, &y)\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tif y[i] != x3[i] {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func (p224Curve) Add(bigX1, bigY1, bigX2, bigY2 *big.Int) (x, y *big.Int) {\n+\tvar x1, y1, z1, x2, y2, z2, x3, y3, z3 p224FieldElement\n+\n+\tp224FromBig(&x1, bigX1)\n+\tp224FromBig(&y1, bigY1)\n+\tz1[0] = 1\n+\tp224FromBig(&x2, bigX2)\n+\tp224FromBig(&y2, bigY2)\n+\tz2[0] = 1\n+\n+\tp224AddJacobian(&x3, &y3, &z3, &x1, &y1, &z1, &x2, &y2, &z2)\n+\treturn p224ToAffine(&x3, &y3, &z3)\n+}\n+\n+func (p224Curve) Double(bigX1, bigY1 *big.Int) (x, y *big.Int) {\n+\tvar x1, y1, z1, x2, y2, z2 p224FieldElement\n+\n+\tp224FromBig(&x1, bigX1)\n+\tp224FromBig(&y1, bigY1)\n+\tz1[0] = 1\n+\n+\tp224DoubleJacobian(&x2, &y2, &z2, &x1, &y1, &z1)\n+\treturn p224ToAffine(&x2, &y2, &z2)\n+}\n+\n+func (p224Curve) ScalarMult(bigX1, bigY1 *big.Int, scalar []byte) (x, y *big.Int) {\n+\tvar x1, y1, z1, x2, y2, z2 p224FieldElement\n+\n+\tp224FromBig(&x1, bigX1)\n+\tp224FromBig(&y1, bigY1)\n+\tz1[0] = 1\n+\n+\tp224ScalarMult(&x2, &y2, &z2, &x1, &y1, &z1, scalar)\n+\treturn p224ToAffine(&x2, &y2, &z2)\n+}\n+\n+func (curve p224Curve) ScalarBaseMult(scalar []byte) (x, y *big.Int) {\n+\tvar z1, x2, y2, z2 p224FieldElement\n+\n+\tz1[0] = 1\n+\tp224ScalarMult(&x2, &y2, &z2, &curve.gx, &curve.gy, &z1, scalar)\n+\treturn p224ToAffine(&x2, &y2, &z2)\n+}\n+\n+// Field element functions.\n+//\n+// The field that we're dealing with is \u2124/p\u2124 where p = 2**224 - 2**96 + 1.\n+//\n+// Field elements are represented by a FieldElement, which is a typedef to an\n+// array of 8 uint32's. The value of a FieldElement, a, is:\n+//   a[0] + 2**28\u00b7a[1] + 2**56\u00b7a[1] + ... + 2**196\u00b7a[7]\n+//\n+// Using 28-bit limbs means that there's only 4 bits of headroom, which is less\n+// than we would really like. But it has the useful feature that we hit 2**224\n+// exactly, making the reflections during a reduce much nicer.\n+type p224FieldElement [8]uint32\n+\n+// p224Add computes *out = a+b\n+//\n+// a[i] + b[i] < 2**32\n+func p224Add(out, a, b *p224FieldElement) {\n+\tfor i := 0; i < 8; i++ {\n+\t\tout[i] = a[i] + b[i]\n+\t}\n+}\n+\n+const two31p3 = 1<<31 + 1<<3\n+const two31m3 = 1<<31 - 1<<3\n+const two31m15m3 = 1<<31 - 1<<15 - 1<<3\n+\n+// p224ZeroModP31 is 0 mod p where bit 31 is set in all limbs so that we can\n+// subtract smaller amounts without underflow. See the section \"Subtraction\" in\n+// [1] for reasoning.\n+var p224ZeroModP31 = []uint32{two31p3, two31m3, two31m3, two31m15m3, two31m3, two31m3, two31m3, two31m3}\n+\n+// p224Sub computes *out = a-b\n+//\n+// a[i], b[i] < 2**30\n+// out[i] < 2**32\n+func p224Sub(out, a, b *p224FieldElement) {\n+\tfor i := 0; i < 8; i++ {\n+\t\tout[i] = a[i] + p224ZeroModP31[i] - b[i]\n+\t}\n+}\n+\n+// LargeFieldElement also represents an element of the field. The limbs are\n+// still spaced 28-bits apart and in little-endian order. So the limbs are at\n+// 0, 28, 56, ..., 392 bits, each 64-bits wide.\n+type p224LargeFieldElement [15]uint64\n+\n+const two63p35 = 1<<63 + 1<<35\n+const two63m35 = 1<<63 - 1<<35\n+const two63m35m19 = 1<<63 - 1<<35 - 1<<19\n+\n+// p224ZeroModP63 is 0 mod p where bit 63 is set in all limbs. See the section\n+// \"Subtraction\" in [1] for why.\n+var p224ZeroModP63 = [8]uint64{two63p35, two63m35, two63m35, two63m35, two63m35m19, two63m35, two63m35, two63m35}\n+\n+const bottom12Bits = 0xfff\n+const bottom28Bits = 0xfffffff\n+\n+// p224Mul computes *out = a*b\n+//\n+// a[i] < 2**29, b[i] < 2**30 (or vice versa)\n+// out[i] < 2**29\n+func p224Mul(out, a, b *p224FieldElement, tmp *p224LargeFieldElement) {\n+\tfor i := 0; i < 15; i++ {\n+\t\ttmp[i] = 0\n+\t}\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tfor j := 0; j < 8; j++ {\n+\t\t\ttmp[i+j] += uint64(a[i]) * uint64(b[j])\n+\t\t}\n+\t}\n+\n+\tp224ReduceLarge(out, tmp)\n+}\n+\n+// Square computes *out = a*a\n+//\n+// a[i] < 2**29\n+// out[i] < 2**29\n+func p224Square(out, a *p224FieldElement, tmp *p224LargeFieldElement) {\n+\tfor i := 0; i < 15; i++ {\n+\t\ttmp[i] = 0\n+\t}\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tfor j := 0; j <= i; j++ {\n+\t\t\tr := uint64(a[i]) * uint64(a[j])\n+\t\t\tif i == j {\n+\t\t\t\ttmp[i+j] += r\n+\t\t\t} else {\n+\t\t\t\ttmp[i+j] += r << 1\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tp224ReduceLarge(out, tmp)\n+}\n+\n+// ReduceLarge converts a p224LargeFieldElement to a p224FieldElement.\n+//\n+// in[i] < 2**62\n+func p224ReduceLarge(out *p224FieldElement, in *p224LargeFieldElement) {\n+\tfor i := 0; i < 8; i++ {\n+\t\tin[i] += p224ZeroModP63[i]\n+\t}\n+\n+\t// Elimintate the coefficients at 2**224 and greater.\n+\tfor i := 14; i >= 8; i-- {\n+\t\tin[i-8] -= in[i]\n+\t\tin[i-5] += (in[i] & 0xffff) << 12\n+\t\tin[i-4] += in[i] >> 16\n+\t}\n+\tin[8] = 0\n+\t// in[0..8] < 2**64\n+\n+\t// As the values become small enough, we start to store them in |out|\n+\t// and use 32-bit operations.\n+\tfor i := 1; i < 8; i++ {\n+\t\tin[i+1] += in[i] >> 28\n+\t\tout[i] = uint32(in[i] & bottom28Bits)\n+\t}\n+\tin[0] -= in[8]\n+\tout[3] += uint32(in[8]&0xffff) << 12\n+\tout[4] += uint32(in[8] >> 16)\n+\t// in[0] < 2**64\n+\t// out[3] < 2**29\n+\t// out[4] < 2**29\n+\t// out[1,2,5..7] < 2**28\n+\n+\tout[0] = uint32(in[0] & bottom28Bits)\n+\tout[1] += uint32((in[0] >> 28) & bottom28Bits)\n+\tout[2] += uint32(in[0] >> 56)\n+\t// out[0] < 2**28\n+\t// out[1..4] < 2**29\n+\t// out[5..7] < 2**28\n+}\n+\n+// Reduce reduces the coefficients of a to smaller bounds.\n+//\n+// On entry: a[i] < 2**31 + 2**30\n+// On exit: a[i] < 2**29\n+func p224Reduce(a *p224FieldElement) {\n+\tfor i := 0; i < 7; i++ {\n+\t\ta[i+1] += a[i] >> 28\n+\t\ta[i] &= bottom28Bits\n+\t}\n+\ttop := a[7] >> 28\n+\ta[7] &= bottom28Bits\n+\n+\t// top < 2**4\n+\tmask := top\n+\tmask |= mask >> 2\n+\tmask |= mask >> 1\n+\tmask <<= 31\n+\tmask = uint32(int32(mask) >> 31)\n+\t// Mask is all ones if top != 0, all zero otherwise\n+\n+\ta[0] -= top\n+\ta[3] += top << 12\n+\n+\t// We may have just made a[0] negative but, if we did, then we must\n+\t// have added something to a[3], this it's > 2**12. Therefore we can\n+\t// carry down to a[0].\n+\ta[3] -= 1 & mask\n+\ta[2] += mask & (1<<28 - 1)\n+\ta[1] += mask & (1<<28 - 1)\n+\ta[0] += mask & (1 << 28)\n+}\n+\n+// p224Invert calcuates *out = in**-1 by computing in**(2**224 - 2**96 - 1),\n+// i.e. Fermat's little theorem.\n+func p224Invert(out, in *p224FieldElement) {\n+\tvar f1, f2, f3, f4 p224FieldElement\n+\tvar c p224LargeFieldElement\n+\n+\tp224Square(&f1, in, &c)    // 2\n+\tp224Mul(&f1, &f1, in, &c)  // 2**2 - 1\n+\tp224Square(&f1, &f1, &c)   // 2**3 - 2\n+\tp224Mul(&f1, &f1, in, &c)  // 2**3 - 1\n+\tp224Square(&f2, &f1, &c)   // 2**4 - 2\n+\tp224Square(&f2, &f2, &c)   // 2**5 - 4\n+\tp224Square(&f2, &f2, &c)   // 2**6 - 8\n+\tp224Mul(&f1, &f1, &f2, &c) // 2**6 - 1\n+\tp224Square(&f2, &f1, &c)   // 2**7 - 2\n+\tfor i := 0; i < 5; i++ {   // 2**12 - 2**6\n+\t\tp224Square(&f2, &f2, &c)\n+\t}\n+\tp224Mul(&f2, &f2, &f1, &c) // 2**12 - 1\n+\tp224Square(&f3, &f2, &c)   // 2**13 - 2\n+\tfor i := 0; i < 11; i++ {  // 2**24 - 2**12\n+\t\tp224Square(&f3, &f3, &c)\n+\t}\n+\tp224Mul(&f2, &f3, &f2, &c) // 2**24 - 1\n+\tp224Square(&f3, &f2, &c)   // 2**25 - 2\n+\tfor i := 0; i < 23; i++ {  // 2**48 - 2**24\n+\t\tp224Square(&f3, &f3, &c)\n+\t}\n+\tp224Mul(&f3, &f3, &f2, &c) // 2**48 - 1\n+\tp224Square(&f4, &f3, &c)   // 2**49 - 2\n+\tfor i := 0; i < 47; i++ {  // 2**96 - 2**48\n+\t\tp224Square(&f4, &f4, &c)\n+\t}\n+\tp224Mul(&f3, &f3, &f4, &c) // 2**96 - 1\n+\tp224Square(&f4, &f3, &c)   // 2**97 - 2\n+\tfor i := 0; i < 23; i++ {  // 2**120 - 2**24\n+\t\tp224Square(&f4, &f4, &c)\n+\t}\n+\tp224Mul(&f2, &f4, &f2, &c) // 2**120 - 1\n+\tfor i := 0; i < 6; i++ {   // 2**126 - 2**6\n+\t\tp224Square(&f2, &f2, &c)\n+\t}\n+\tp224Mul(&f1, &f1, &f2, &c) // 2**126 - 1\n+\tp224Square(&f1, &f1, &c)   // 2**127 - 2\n+\tp224Mul(&f1, &f1, in, &c)  // 2**127 - 1\n+\tfor i := 0; i < 97; i++ {  // 2**224 - 2**97\n+\t\tp224Square(&f1, &f1, &c)\n+\t}\n+\tp224Mul(out, &f1, &f3, &c) // 2**224 - 2**96 - 1\n+}\n+\n+// p224Contract converts a FieldElement to its unique, minimal form.\n+//\n+// On entry, in[i] < 2**32\n+// On exit, in[i] < 2**28\n+func p224Contract(out, in *p224FieldElement) {\n+\tcopy(out[:], in[:])\n+\n+\tfor i := 0; i < 7; i++ {\n+\t\tout[i+1] += out[i] >> 28\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\ttop := out[7] >> 28\n+\tout[7] &= bottom28Bits\n+\n+\tout[0] -= top\n+\tout[3] += top << 12\n+\n+\t// We may just have made out[i] negative. So we carry down. If we made\n+\t// out[0] negative then we know that out[3] is sufficiently positive\n+\t// because we just added to it.\n+\tfor i := 0; i < 3; i++ {\n+\t\tmask := uint32(int32(out[i]) >> 31)\n+\t\tout[i] += (1 << 28) & mask\n+\t\tout[i+1] -= 1 & mask\n+\t}\n+\n+\t// Now we see if the value is >= p and, if so, subtract p.\n+\n+\t// First we build a mask from the top four limbs, which must all be\n+\t// equal to bottom28Bits if the whole value is >= p. If top4AllOnes\n+\t// ends up with any zero bits in the bottom 28 bits, then this wasn't\n+\t// true.\n+\ttop4AllOnes := uint32(0xffffffff)\n+\tfor i := 4; i < 8; i++ {\n+\t\ttop4AllOnes &= (out[i] & bottom28Bits) - 1\n+\t}\n+\ttop4AllOnes |= 0xf0000000\n+\t// Now we replicate any zero bits to all the bits in top4AllOnes.\n+\ttop4AllOnes &= top4AllOnes >> 16\n+\ttop4AllOnes &= top4AllOnes >> 8\n+\ttop4AllOnes &= top4AllOnes >> 4\n+\ttop4AllOnes &= top4AllOnes >> 2\n+\ttop4AllOnes &= top4AllOnes >> 1\n+\ttop4AllOnes = uint32(int32(top4AllOnes<<31) >> 31)\n+\n+\t// Now we test whether the bottom three limbs are non-zero.\n+\tbottom3NonZero := out[0] | out[1] | out[2]\n+\tbottom3NonZero |= bottom3NonZero >> 16\n+\tbottom3NonZero |= bottom3NonZero >> 8\n+\tbottom3NonZero |= bottom3NonZero >> 4\n+\tbottom3NonZero |= bottom3NonZero >> 2\n+\tbottom3NonZero |= bottom3NonZero >> 1\n+\tbottom3NonZero = uint32(int32(bottom3NonZero<<31) >> 31)\n+\n+\t// Everything depends on the value of out[3].\n+\t//    If it's > 0xffff000 and top4AllOnes != 0 then the whole value is >= p\n+\t//    If it's = 0xffff000 and top4AllOnes != 0 and bottom3NonZero != 0,\n+\t//      then the whole value is >= p\n+\t//    If it's < 0xffff000, then the whole value is < p\n+\tn := out[3] - 0xffff000\n+\tout3Equal := n\n+\tout3Equal |= out3Equal >> 16\n+\tout3Equal |= out3Equal >> 8\n+\tout3Equal |= out3Equal >> 4\n+\tout3Equal |= out3Equal >> 2\n+\tout3Equal |= out3Equal >> 1\n+\tout3Equal = ^uint32(int32(out3Equal<<31) >> 31)\n+\n+\t// If out[3] > 0xffff000 then n's MSB will be zero.\n+\tout3GT := ^uint32(int32(n<<31) >> 31)\n+\n+\tmask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)\n+\tout[0] -= 1 & mask\n+\tout[3] -= 0xffff000 & mask\n+\tout[4] -= 0xfffffff & mask\n+\tout[5] -= 0xfffffff & mask\n+\tout[6] -= 0xfffffff & mask\n+\tout[7] -= 0xfffffff & mask\n+}\n+\n+// Group element functions.\n+//\n+// These functions deal with group elements. The group is an elliptic curve\n+// group with a = -3 defined in FIPS 186-3, section D.2.2.\n+\n+// p224AddJacobian computes *out = a+b where a != b.\n+func p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2 *p224FieldElement) {\n+\t// See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-p224Add-2007-bl\n+\tvar z1z1, z2z2, u1, u2, s1, s2, h, i, j, r, v p224FieldElement\n+\tvar c p224LargeFieldElement\n+\n+\t// Z1Z1 = Z1\u00b2\n+\tp224Square(&z1z1, z1, &c)\n+\t// Z2Z2 = Z2\u00b2\n+\tp224Square(&z2z2, z2, &c)\n+\t// U1 = X1*Z2Z2\n+\tp224Mul(&u1, x1, &z2z2, &c)\n+\t// U2 = X2*Z1Z1\n+\tp224Mul(&u2, x2, &z1z1, &c)\n+\t// S1 = Y1*Z2*Z2Z2\n+\tp224Mul(&s1, z2, &z2z2, &c)\n+\tp224Mul(&s1, y1, &s1, &c)\n+\t// S2 = Y2*Z1*Z1Z1\n+\tp224Mul(&s2, z1, &z1z1, &c)\n+\tp224Mul(&s2, y2, &s2, &c)\n+\t// H = U2-U1\n+\tp224Sub(&h, &u2, &u1)\n+\tp224Reduce(&h)\n+\t// I = (2*H)\u00b2\n+\tfor j := 0; j < 8; j++ {\n+\t\ti[j] = h[j] << 1\n+\t}\n+\tp224Reduce(&i)\n+\tp224Square(&i, &i, &c)\n+\t// J = H*I\n+\tp224Mul(&j, &h, &i, &c)\n+\t// r = 2*(S2-S1)\n+\tp224Sub(&r, &s2, &s1)\n+\tp224Reduce(&r)\n+\tfor i := 0; i < 8; i++ {\n+\t\tr[i] <<= 1\n+\t}\n+\tp224Reduce(&r)\n+\t// V = U1*I\n+\tp224Mul(&v, &u1, &i, &c)\n+\t// Z3 = ((Z1+Z2)\u00b2-Z1Z1-Z2Z2)*H\n+\tp224Add(&z1z1, &z1z1, &z2z2)\n+\tp224Add(&z2z2, z1, z2)\n+\tp224Reduce(&z2z2)\n+\tp224Square(&z2z2, &z2z2, &c)\n+\tp224Sub(z3, &z2z2, &z1z1)\n+\tp224Reduce(z3)\n+\tp224Mul(z3, z3, &h, &c)\n+\t// X3 = r\u00b2-J-2*V\n+\tfor i := 0; i < 8; i++ {\n+\t\tz1z1[i] = v[i] << 1\n+\t}\n+\tp224Add(&z1z1, &j, &z1z1)\n+\tp224Reduce(&z1z1)\n+\tp224Square(x3, &r, &c)\n+\tp224Sub(x3, x3, &z1z1)\n+\tp224Reduce(x3)\n+\t// Y3 = r*(V-X3)-2*S1*J\n+\tfor i := 0; i < 8; i++ {\n+\t\ts1[i] <<= 1\n+\t}\n+\tp224Mul(&s1, &s1, &j, &c)\n+\tp224Sub(&z1z1, &v, x3)\n+\tp224Reduce(&z1z1)\n+\tp224Mul(&z1z1, &z1z1, &r, &c)\n+\tp224Sub(y3, &z1z1, &s1)\n+\tp224Reduce(y3)\n+}\n+\n+// p224DoubleJacobian computes *out = a+a.\n+func p224DoubleJacobian(x3, y3, z3, x1, y1, z1 *p224FieldElement) {\n+\tvar delta, gamma, beta, alpha, t p224FieldElement\n+\tvar c p224LargeFieldElement\n+\n+\tp224Square(&delta, z1, &c)\n+\tp224Square(&gamma, y1, &c)\n+\tp224Mul(&beta, x1, &gamma, &c)\n+\n+\t// alpha = 3*(X1-delta)*(X1+delta)\n+\tp224Add(&t, x1, &delta)\n+\tfor i := 0; i < 8; i++ {\n+\t\tt[i] += t[i] << 1\n+\t}\n+\tp224Reduce(&t)\n+\tp224Sub(&alpha, x1, &delta)\n+\tp224Reduce(&alpha)\n+\tp224Mul(&alpha, &alpha, &t, &c)\n+\n+\t// Z3 = (Y1+Z1)\u00b2-gamma-delta\n+\tp224Add(z3, y1, z1)\n+\tp224Reduce(z3)\n+\tp224Square(z3, z3, &c)\n+\tp224Sub(z3, z3, &gamma)\n+\tp224Reduce(z3)\n+\tp224Sub(z3, z3, &delta)\n+\tp224Reduce(z3)\n+\n+\t// X3 = alpha\u00b2-8*beta\n+\tfor i := 0; i < 8; i++ {\n+\t\tdelta[i] = beta[i] << 3\n+\t}\n+\tp224Reduce(&delta)\n+\tp224Square(x3, &alpha, &c)\n+\tp224Sub(x3, x3, &delta)\n+\tp224Reduce(x3)\n+\n+\t// Y3 = alpha*(4*beta-X3)-8*gamma\u00b2\n+\tfor i := 0; i < 8; i++ {\n+\t\tbeta[i] <<= 2\n+\t}\n+\tp224Sub(&beta, &beta, x3)\n+\tp224Reduce(&beta)\n+\tp224Square(&gamma, &gamma, &c)\n+\tfor i := 0; i < 8; i++ {\n+\t\tgamma[i] <<= 3\n+\t}\n+\tp224Reduce(&gamma)\n+\tp224Mul(y3, &alpha, &beta, &c)\n+\tp224Sub(y3, y3, &gamma)\n+\tp224Reduce(y3)\n+}\n+\n+// p224CopyConditional sets *out = *in iff the least-significant-bit of control\n+// is true, and it runs in constant time.\n+func p224CopyConditional(out, in *p224FieldElement, control uint32) {\n+\tcontrol <<= 31\n+\tcontrol = uint32(int32(control) >> 31)\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tout[i] ^= (out[i] ^ in[i]) & control\n+\t}\n+}\n+\n+func p224ScalarMult(outX, outY, outZ, inX, inY, inZ *p224FieldElement, scalar []byte) {\n+\tvar xx, yy, zz p224FieldElement\n+\tfor i := 0; i < 8; i++ {\n+\t\toutZ[i] = 0\n+\t}\n+\n+\tfirstBit := uint32(1)\n+\tfor _, byte := range scalar {\n+\t\tfor bitNum := uint(0); bitNum < 8; bitNum++ {\n+\t\t\tp224DoubleJacobian(outX, outY, outZ, outX, outY, outZ)\n+\t\t\tbit := uint32((byte >> (7 - bitNum)) & 1)\n+\t\t\tp224AddJacobian(&xx, &yy, &zz, inX, inY, inZ, outX, outY, outZ)\n+\t\t\tp224CopyConditional(outX, inX, firstBit&bit)\n+\t\t\tp224CopyConditional(outY, inY, firstBit&bit)\n+\t\t\tp224CopyConditional(outZ, inZ, firstBit&bit)\n+\t\t\tp224CopyConditional(outX, &xx, ^firstBit&bit)\n+\t\t\tp224CopyConditional(outY, &yy, ^firstBit&bit)\n+\t\t\tp224CopyConditional(outZ, &zz, ^firstBit&bit)\n+\t\t\tfirstBit = firstBit & ^bit\n+\t\t}\n+\t}\n+}\n+\n+// p224ToAffine converts from Jacobian to affine form.\n+func p224ToAffine(x, y, z *p224FieldElement) (*big.Int, *big.Int) {\n+\tvar zinv, zinvsq, outx, outy p224FieldElement\n+\tvar tmp p224LargeFieldElement\n+\n+\tisPointAtInfinity := true\n+\tfor i := 0; i < 8; i++ {\n+\t\tif z[i] != 0 {\n+\t\t\tisPointAtInfinity = false\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif isPointAtInfinity {\n+\t\treturn nil, nil\n+\t}\n+\n+\tp224Invert(&zinv, z)\n+\tp224Square(&zinvsq, &zinv, &tmp)\n+\tp224Mul(x, x, &zinvsq, &tmp)\n+\tp224Mul(&zinvsq, &zinvsq, &zinv, &tmp)\n+\tp224Mul(y, y, &zinvsq, &tmp)\n+\n+\tp224Contract(&outx, x)\n+\tp224Contract(&outy, y)\n+\treturn p224ToBig(&outx), p224ToBig(&outy)\n+}\n+\n+// get28BitsFromEnd returns the least-significant 28 bits from buf>>shift,\n+// where buf is interpreted as a big-endian number.\n+func get28BitsFromEnd(buf []byte, shift uint) (uint32, []byte) {\n+\tvar ret uint32\n+\n+\tfor i := uint(0); i < 4; i++ {\n+\t\tvar b byte\n+\t\tif l := len(buf); l > 0 {\n+\t\t\tb = buf[l-1]\n+\t\t\t// We don't remove the byte if we're about to return and we're not\n+\t\t\t// reading all of it.\n+\t\t\tif i != 3 || shift == 4 {\n+\t\t\t\tbuf = buf[:l-1]\n+\t\t\t}\n+\t\t}\n+\t\tret |= uint32(b) << (8 * i) >> shift\n+\t}\n+\tret &= bottom28Bits\n+\treturn ret, buf\n+}\n+\n+// p224FromBig sets *out = *in.\n+func p224FromBig(out *p224FieldElement, in *big.Int) {\n+\tbytes := in.Bytes()\n+\tout[0], bytes = get28BitsFromEnd(bytes, 0)\n+\tout[1], bytes = get28BitsFromEnd(bytes, 4)\n+\tout[2], bytes = get28BitsFromEnd(bytes, 0)\n+\tout[3], bytes = get28BitsFromEnd(bytes, 4)\n+\tout[4], bytes = get28BitsFromEnd(bytes, 0)\n+\tout[5], bytes = get28BitsFromEnd(bytes, 4)\n+\tout[6], bytes = get28BitsFromEnd(bytes, 0)\n+\tout[7], bytes = get28BitsFromEnd(bytes, 4)\n+}\n+\n+// p224ToBig returns in as a big.Int.\n+func p224ToBig(in *p224FieldElement) *big.Int {\n+\tvar buf [28]byte\n+\tbuf[27] = byte(in[0])\n+\tbuf[26] = byte(in[0] >> 8)\n+\tbuf[25] = byte(in[0] >> 16)\n+\tbuf[24] = byte(((in[0] >> 24) & 0x0f) | (in[1]<<4)&0xf0)\n+\n+\tbuf[23] = byte(in[1] >> 4)\n+\tbuf[22] = byte(in[1] >> 12)\n+\tbuf[21] = byte(in[1] >> 20)\n+\n+\tbuf[20] = byte(in[2])\n+\tbuf[19] = byte(in[2] >> 8)\n+\tbuf[18] = byte(in[2] >> 16)\n+\tbuf[17] = byte(((in[2] >> 24) & 0x0f) | (in[3]<<4)&0xf0)\n+\n+\tbuf[16] = byte(in[3] >> 4)\n+\tbuf[15] = byte(in[3] >> 12)\n+\tbuf[14] = byte(in[3] >> 20)\n+\n+\tbuf[13] = byte(in[4])\n+\tbuf[12] = byte(in[4] >> 8)\n+\tbuf[11] = byte(in[4] >> 16)\n+\tbuf[10] = byte(((in[4] >> 24) & 0x0f) | (in[5]<<4)&0xf0)\n+\n+\tbuf[9] = byte(in[5] >> 4)\n+\tbuf[8] = byte(in[5] >> 12)\n+\tbuf[7] = byte(in[5] >> 20)\n+\n+\tbuf[6] = byte(in[6])\n+\tbuf[5] = byte(in[6] >> 8)\n+\tbuf[4] = byte(in[6] >> 16)\n+\tbuf[3] = byte(((in[6] >> 24) & 0x0f) | (in[7]<<4)&0xf0)\n+\n+\tbuf[2] = byte(in[7] >> 4)\n+\tbuf[1] = byte(in[7] >> 12)\n+\tbuf[0] = byte(in[7] >> 20)\n+\n+\treturn new(big.Int).SetBytes(buf[:])\n+}"}, {"sha": "4b26d1610ed80d8ceb0c9dde2a8ecc4ba5afda46", "filename": "libgo/go/crypto/elliptic/p224_test.go", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package elliptic\n+\n+import (\n+\t\"math/big\"\n+\t\"testing\"\n+)\n+\n+var toFromBigTests = []string{\n+\t\"0\",\n+\t\"1\",\n+\t\"23\",\n+\t\"b70e0cb46bb4bf7f321390b94a03c1d356c01122343280d6105c1d21\",\n+\t\"706a46d476dcb76798e6046d89474788d164c18032d268fd10704fa6\",\n+}\n+\n+func p224AlternativeToBig(in *p224FieldElement) *big.Int {\n+\tret := new(big.Int)\n+\ttmp := new(big.Int)\n+\n+\tfor i := uint(0); i < 8; i++ {\n+\t\ttmp.SetInt64(int64(in[i]))\n+\t\ttmp.Lsh(tmp, 28*i)\n+\t\tret.Add(ret, tmp)\n+\t}\n+\tret.Mod(ret, p224.P)\n+\treturn ret\n+}\n+\n+func TestToFromBig(t *testing.T) {\n+\tfor i, test := range toFromBigTests {\n+\t\tn, _ := new(big.Int).SetString(test, 16)\n+\t\tvar x p224FieldElement\n+\t\tp224FromBig(&x, n)\n+\t\tm := p224ToBig(&x)\n+\t\tif n.Cmp(m) != 0 {\n+\t\t\tt.Errorf(\"#%d: %x != %x\", i, n, m)\n+\t\t}\n+\t\tq := p224AlternativeToBig(&x)\n+\t\tif n.Cmp(q) != 0 {\n+\t\t\tt.Errorf(\"#%d: %x != %x (alternative)\", i, n, m)\n+\t\t}\n+\t}\n+}"}, {"sha": "a97ce09727abaaacccbba5db59a588e81ae17d51", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,32 +9,20 @@\n package hmac\n \n import (\n-\t\"crypto/md5\"\n-\t\"crypto/sha1\"\n-\t\"crypto/sha256\"\n \t\"hash\"\n )\n \n // FIPS 198:\n // http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf\n \n-// key is zero padded to 64 bytes\n-// ipad = 0x36 byte repeated to 64 bytes\n-// opad = 0x5c byte repeated to 64 bytes\n+// key is zero padded to the block size of the hash function\n+// ipad = 0x36 byte repeated for key length\n+// opad = 0x5c byte repeated for key length\n // hmac = H([key ^ opad] H([key ^ ipad] text))\n \n-const (\n-\t// NOTE(rsc): This constant is actually the\n-\t// underlying hash function's block size.\n-\t// HMAC is only conventionally used with\n-\t// MD5 and SHA1, and both use 64-byte blocks.\n-\t// The hash.Hash interface doesn't provide a\n-\t// way to find out the block size.\n-\tpadSize = 64\n-)\n-\n type hmac struct {\n \tsize         int\n+\tblocksize    int\n \tkey, tmp     []byte\n \touter, inner hash.Hash\n }\n@@ -43,7 +31,7 @@ func (h *hmac) tmpPad(xor byte) {\n \tfor i, k := range h.key {\n \t\th.tmp[i] = xor ^ k\n \t}\n-\tfor i := len(h.key); i < padSize; i++ {\n+\tfor i := len(h.key); i < h.blocksize; i++ {\n \t\th.tmp[i] = xor\n \t}\n }\n@@ -52,7 +40,7 @@ func (h *hmac) Sum(in []byte) []byte {\n \torigLen := len(in)\n \tin = h.inner.Sum(in)\n \th.tmpPad(0x5c)\n-\tcopy(h.tmp[padSize:], in[origLen:])\n+\tcopy(h.tmp[h.blocksize:], in[origLen:])\n \th.outer.Reset()\n \th.outer.Write(h.tmp)\n \treturn h.outer.Sum(in[:origLen])\n@@ -64,20 +52,23 @@ func (h *hmac) Write(p []byte) (n int, err error) {\n \n func (h *hmac) Size() int { return h.size }\n \n+func (h *hmac) BlockSize() int { return h.blocksize }\n+\n func (h *hmac) Reset() {\n \th.inner.Reset()\n \th.tmpPad(0x36)\n-\th.inner.Write(h.tmp[0:padSize])\n+\th.inner.Write(h.tmp[0:h.blocksize])\n }\n \n-// New returns a new HMAC hash using the given hash generator and key.\n+// New returns a new HMAC hash using the given hash.Hash type and key.\n func New(h func() hash.Hash, key []byte) hash.Hash {\n \thm := new(hmac)\n \thm.outer = h()\n \thm.inner = h()\n \thm.size = hm.inner.Size()\n-\thm.tmp = make([]byte, padSize+hm.size)\n-\tif len(key) > padSize {\n+\thm.blocksize = hm.inner.BlockSize()\n+\thm.tmp = make([]byte, hm.blocksize+hm.size)\n+\tif len(key) > hm.blocksize {\n \t\t// If key is too big, hash it.\n \t\thm.outer.Write(key)\n \t\tkey = hm.outer.Sum(nil)\n@@ -87,12 +78,3 @@ func New(h func() hash.Hash, key []byte) hash.Hash {\n \thm.Reset()\n \treturn hm\n }\n-\n-// NewMD5 returns a new HMAC-MD5 hash using the given key.\n-func NewMD5(key []byte) hash.Hash { return New(md5.New, key) }\n-\n-// NewSHA1 returns a new HMAC-SHA1 hash using the given key.\n-func NewSHA1(key []byte) hash.Hash { return New(sha1.New, key) }\n-\n-// NewSHA256 returns a new HMAC-SHA256 hash using the given key.\n-func NewSHA256(key []byte) hash.Hash { return New(sha256.New, key) }"}, {"sha": "07957414c8836086750149c29346b482e8ea8a79", "filename": "libgo/go/crypto/hmac/hmac_test.go", "status": "modified", "additions": 300, "deletions": 12, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -5,13 +5,17 @@\n package hmac\n \n import (\n+\t\"crypto/md5\"\n+\t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n+\t\"crypto/sha512\"\n \t\"fmt\"\n \t\"hash\"\n \t\"testing\"\n )\n \n type hmacTest struct {\n-\thash func([]byte) hash.Hash\n+\thash func() hash.Hash\n \tkey  []byte\n \tin   []byte\n \tout  string\n@@ -21,7 +25,7 @@ var hmacTests = []hmacTest{\n \t// Tests from US FIPS 198\n \t// http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf\n \t{\n-\t\tNewSHA1,\n+\t\tsha1.New,\n \t\t[]byte{\n \t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n \t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n@@ -36,7 +40,7 @@ var hmacTests = []hmacTest{\n \t\t\"4f4ca3d5d68ba7cc0a1208c9c61e9c5da0403c0a\",\n \t},\n \t{\n-\t\tNewSHA1,\n+\t\tsha1.New,\n \t\t[]byte{\n \t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n \t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n@@ -46,7 +50,7 @@ var hmacTests = []hmacTest{\n \t\t\"0922d3405faa3d194f82a45830737d5cc6c75d24\",\n \t},\n \t{\n-\t\tNewSHA1,\n+\t\tsha1.New,\n \t\t[]byte{\n \t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n \t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n@@ -68,15 +72,15 @@ var hmacTests = []hmacTest{\n \n \t// Test from Plan 9.\n \t{\n-\t\tNewMD5,\n+\t\tmd5.New,\n \t\t[]byte(\"Jefe\"),\n \t\t[]byte(\"what do ya want for nothing?\"),\n \t\t\"750c783e6ab0b503eaa86e310a5db738\",\n \t},\n \n \t// Tests from RFC 4231\n \t{\n-\t\tNewSHA256,\n+\t\tsha256.New,\n \t\t[]byte{\n \t\t\t0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,\n \t\t\t0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,\n@@ -86,13 +90,13 @@ var hmacTests = []hmacTest{\n \t\t\"b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\",\n \t},\n \t{\n-\t\tNewSHA256,\n+\t\tsha256.New,\n \t\t[]byte(\"Jefe\"),\n \t\t[]byte(\"what do ya want for nothing?\"),\n \t\t\"5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\",\n \t},\n \t{\n-\t\tNewSHA256,\n+\t\tsha256.New,\n \t\t[]byte{\n \t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n \t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n@@ -110,7 +114,7 @@ var hmacTests = []hmacTest{\n \t\t\"773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe\",\n \t},\n \t{\n-\t\tNewSHA256,\n+\t\tsha256.New,\n \t\t[]byte{\n \t\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n \t\t\t0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n@@ -129,7 +133,7 @@ var hmacTests = []hmacTest{\n \t\t\"82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b\",\n \t},\n \t{\n-\t\tNewSHA256,\n+\t\tsha256.New,\n \t\t[]byte{\n \t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n \t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n@@ -153,7 +157,7 @@ var hmacTests = []hmacTest{\n \t\t\"60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54\",\n \t},\n \t{\n-\t\tNewSHA256,\n+\t\tsha256.New,\n \t\t[]byte{\n \t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n \t\t\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n@@ -178,11 +182,295 @@ var hmacTests = []hmacTest{\n \t\t\t\"be hashed before being used by the HMAC algorithm.\"),\n \t\t\"9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2\",\n \t},\n+\n+\t// Tests from http://csrc.nist.gov/groups/ST/toolkit/examples.html\n+\t// (truncated tag tests are left out)\n+\t{\n+\t\tsha1.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"5fd596ee78d5553c8ff4e72d266dfd192366da29\",\n+\t},\n+\t{\n+\t\tsha1.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen<blocklen\"),\n+\t\t\"4c99ff0cb1b31bd33f8431dbaf4d17fcd356a807\",\n+\t},\n+\t{\n+\t\tsha1.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+\t\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+\t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+\t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+\t\t\t0x60, 0x61, 0x62, 0x63,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"2d51b2f7750e410584662e38f133435f4c4fd42a\",\n+\t},\n+\t{\n+\t\tsha256.New224,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"c7405e3ae058e8cd30b08b4140248581ed174cb34e1224bcc1efc81b\",\n+\t},\n+\t{\n+\t\tsha256.New224,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen<blocklen\"),\n+\t\t\"e3d249a8cfb67ef8b7a169e9a0a599714a2cecba65999a51beb8fbbe\",\n+\t},\n+\t{\n+\t\tsha256.New224,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+\t\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+\t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+\t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+\t\t\t0x60, 0x61, 0x62, 0x63,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"91c52509e5af8531601ae6230099d90bef88aaefb961f4080abc014d\",\n+\t},\n+\t{\n+\t\tsha256.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"8bb9a1db9806f20df7f77b82138c7914d174d59e13dc4d0169c9057b133e1d62\",\n+\t},\n+\t{\n+\t\tsha256.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen<blocklen\"),\n+\t\t\"a28cf43130ee696a98f14a37678b56bcfcbdd9e5cf69717fecf5480f0ebdf790\",\n+\t},\n+\t{\n+\t\tsha256.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+\t\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+\t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+\t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+\t\t\t0x60, 0x61, 0x62, 0x63,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"bdccb6c72ddeadb500ae768386cb38cc41c63dbb0878ddb9c7a38a431b78378d\",\n+\t},\n+\t{\n+\t\tsha512.New384,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+\t\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+\t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+\t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+\t\t\t0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+\t\t\t0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+\t\t\t0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+\t\t\t0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"63c5daa5e651847ca897c95814ab830bededc7d25e83eef9195cd45857a37f448947858f5af50cc2b1b730ddf29671a9\",\n+\t},\n+\t{\n+\t\tsha512.New384,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen<blocklen\"),\n+\t\t\"6eb242bdbb582ca17bebfa481b1e23211464d2b7f8c20b9ff2201637b93646af5ae9ac316e98db45d9cae773675eeed0\",\n+\t},\n+\t{\n+\t\tsha512.New384,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+\t\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+\t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+\t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+\t\t\t0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+\t\t\t0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+\t\t\t0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+\t\t\t0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+\t\t\t0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+\t\t\t0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+\t\t\t0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+\t\t\t0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+\t\t\t0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+\t\t\t0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+\t\t\t0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+\t\t\t0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+\t\t\t0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"5b664436df69b0ca22551231a3f0a3d5b4f97991713cfa84bff4d0792eff96c27dccbbb6f79b65d548b40e8564cef594\",\n+\t},\n+\t{\n+\t\tsha512.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+\t\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+\t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+\t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+\t\t\t0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+\t\t\t0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+\t\t\t0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+\t\t\t0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"fc25e240658ca785b7a811a8d3f7b4ca\" +\n+\t\t\t\"48cfa26a8a366bf2cd1f836b05fcb024bd36853081811d6c\" +\n+\t\t\t\"ea4216ebad79da1cfcb95ea4586b8a0ce356596a55fb1347\",\n+\t},\n+\t{\n+\t\tsha512.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen<blocklen\"),\n+\t\t\"fd44c18bda0bb0a6ce0e82b031bf2818\" +\n+\t\t\t\"f6539bd56ec00bdc10a8a2d730b3634de2545d639b0f2cf7\" +\n+\t\t\t\"10d0692c72a1896f1f211c2b922d1a96c392e07e7ea9fedc\",\n+\t},\n+\t{\n+\t\tsha512.New,\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+\t\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+\t\t\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+\t\t\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+\t\t\t0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+\t\t\t0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+\t\t\t0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+\t\t\t0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+\t\t\t0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+\t\t\t0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+\t\t\t0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+\t\t\t0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+\t\t\t0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+\t\t\t0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+\t\t\t0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+\t\t\t0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+\t\t\t0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+\t\t},\n+\t\t[]byte(\"Sample message for keylen=blocklen\"),\n+\t\t\"d93ec8d2de1ad2a9957cb9b83f14e76a\" +\n+\t\t\t\"d6b5e0cce285079a127d3b14bccb7aa7286d4ac0d4ce6421\" +\n+\t\t\t\"5f2bc9e6870b33d97438be4aaa20cda5c5a912b48b8e27f3\",\n+\t},\n }\n \n func TestHMAC(t *testing.T) {\n \tfor i, tt := range hmacTests {\n-\t\th := tt.hash(tt.key)\n+\t\th := New(tt.hash, tt.key)\n \t\tfor j := 0; j < 2; j++ {\n \t\t\tn, err := h.Write(tt.in)\n \t\t\tif n != len(tt.in) || err != nil {"}, {"sha": "c5f7c57d16e05a7a1c817ad01e01ac4780b3d5ac", "filename": "libgo/go/crypto/md4/md4.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -17,6 +17,9 @@ func init() {\n // The size of an MD4 checksum in bytes.\n const Size = 16\n \n+// The blocksize of MD4 in bytes.\n+const BlockSize = 64\n+\n const (\n \t_Chunk = 64\n \t_Init0 = 0x67452301\n@@ -51,6 +54,8 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n+func (d *digest) BlockSize() int { return BlockSize }\n+\n func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)"}, {"sha": "cfb728c9441202f8ec90a3f7eafe4b93549fdefe", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -17,6 +17,9 @@ func init() {\n // The size of an MD5 checksum in bytes.\n const Size = 16\n \n+// The blocksize of MD5 in bytes.\n+const BlockSize = 64\n+\n const (\n \t_Chunk = 64\n \t_Init0 = 0x67452301\n@@ -51,6 +54,8 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n+func (d *digest) BlockSize() int { return BlockSize }\n+\n func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)"}, {"sha": "f0e9f94ee7fc4ec163dccc6085a51f645af1ba81", "filename": "libgo/go/crypto/ocsp/ocsp_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package ocsp\n \n import ("}, {"sha": "e601e389f1299cd0f02e3a11f0f5e42ca8bb6e22", "filename": "libgo/go/crypto/openpgp/canonical_text.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -53,3 +53,7 @@ func (cth *canonicalTextHash) Reset() {\n func (cth *canonicalTextHash) Size() int {\n \treturn cth.h.Size()\n }\n+\n+func (cth *canonicalTextHash) BlockSize() int {\n+\treturn cth.h.BlockSize()\n+}"}, {"sha": "8f3ba2a8814ea9c48b0d34fa6018c5aa5468d283", "filename": "libgo/go/crypto/openpgp/canonical_text_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -29,6 +29,10 @@ func (r recordingHash) Size() int {\n \tpanic(\"shouldn't be called\")\n }\n \n+func (r recordingHash) BlockSize() int {\n+\tpanic(\"shouldn't be called\")\n+}\n+\n func testCanonicalText(t *testing.T, input, expected string) {\n \tr := recordingHash{bytes.NewBuffer(nil)}\n \tc := NewCanonicalTextHash(r)"}, {"sha": "da690f0b92f52f5b1b7f983f3198f2697b14dc85", "filename": "libgo/go/crypto/ripemd160/ripemd160.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -55,6 +55,8 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n+func (d *digest) BlockSize() int { return BlockSize }\n+\n func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.tc += uint64(nn)"}, {"sha": "876e7992a3a7b6d3695c55c5f5577e9544ab2d5a", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -17,6 +17,9 @@ func init() {\n // The size of a SHA1 checksum in bytes.\n const Size = 20\n \n+// The blocksize of SHA1 in bytes.\n+const BlockSize = 64\n+\n const (\n \t_Chunk = 64\n \t_Init0 = 0x67452301\n@@ -53,6 +56,8 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n+func (d *digest) BlockSize() int { return BlockSize }\n+\n func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)"}, {"sha": "a61e30b4251be3d5a6782084c6dde6cbeb80fdac", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -22,6 +22,9 @@ const Size = 32\n // The size of a SHA224 checksum in bytes.\n const Size224 = 28\n \n+// The blocksize of SHA256 and SHA224 in bytes.\n+const BlockSize = 64\n+\n const (\n \t_Chunk     = 64\n \t_Init0     = 0x6A09E667\n@@ -97,6 +100,8 @@ func (d *digest) Size() int {\n \treturn Size224\n }\n \n+func (d *digest) BlockSize() int { return BlockSize }\n+\n func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)"}, {"sha": "a245fd68e55968f3c65f51b59c5587fa60b009be", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -22,6 +22,9 @@ const Size = 64\n // The size of a SHA384 checksum in bytes.\n const Size384 = 48\n \n+// The blocksize of SHA512 and SHA384 in bytes.\n+const BlockSize = 128\n+\n const (\n \t_Chunk     = 128\n \t_Init0     = 0x6a09e667f3bcc908\n@@ -97,6 +100,8 @@ func (d *digest) Size() int {\n \treturn Size384\n }\n \n+func (d *digest) BlockSize() int { return BlockSize }\n+\n func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)"}, {"sha": "00695e7d15b484d0bc85ccc36b685fc1d8287128", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -91,7 +91,7 @@ func macSHA1(version uint16, key []byte) macFunction {\n \t\tcopy(mac.key, key)\n \t\treturn mac\n \t}\n-\treturn tls10MAC{hmac.NewSHA1(key)}\n+\treturn tls10MAC{hmac.New(sha1.New, key)}\n }\n \n type macFunction interface {"}, {"sha": "e6cee1278c3102154b5e4cceedd63b6d539437f3", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"io\"\n \t\"net\"\n \t\"sync\"\n+\t\"time\"\n )\n \n // A Conn represents a secured connection.\n@@ -86,24 +87,23 @@ func (c *Conn) RemoteAddr() net.Addr {\n \treturn c.conn.RemoteAddr()\n }\n \n-// SetTimeout sets the read deadline associated with the connection.\n+// SetDeadline sets the read deadline associated with the connection.\n // There is no write deadline.\n-func (c *Conn) SetTimeout(nsec int64) error {\n-\treturn c.conn.SetTimeout(nsec)\n+// A zero value for t means Read will not time out.\n+func (c *Conn) SetDeadline(t time.Time) error {\n+\treturn c.conn.SetDeadline(t)\n }\n \n-// SetReadTimeout sets the time (in nanoseconds) that\n-// Read will wait for data before returning a net.Error\n-// with Timeout() == true.\n-// Setting nsec == 0 (the default) disables the deadline.\n-func (c *Conn) SetReadTimeout(nsec int64) error {\n-\treturn c.conn.SetReadTimeout(nsec)\n+// SetReadDeadline sets the read deadline on the underlying connection.\n+// A zero value for t means Read will not time out.\n+func (c *Conn) SetReadDeadline(t time.Time) error {\n+\treturn c.conn.SetReadDeadline(t)\n }\n \n-// SetWriteTimeout exists to satisfy the net.Conn interface\n+// SetWriteDeadline exists to satisfy the net.Conn interface\n // but is not implemented by TLS.  It always returns an error.\n-func (c *Conn) SetWriteTimeout(nsec int64) error {\n-\treturn errors.New(\"TLS does not support SetWriteTimeout\")\n+func (c *Conn) SetWriteDeadline(t time.Time) error {\n+\treturn errors.New(\"TLS does not support SetWriteDeadline\")\n }\n \n // A halfConn represents one direction of the record layer\n@@ -744,7 +744,7 @@ func (c *Conn) Write(b []byte) (n int, err error) {\n }\n \n // Read can be made to time out and return a net.Error with Timeout() == true\n-// after a fixed time limit; see SetTimeout and SetReadTimeout.\n+// after a fixed time limit; see SetDeadline and SetReadDeadline.\n func (c *Conn) Read(b []byte) (n int, err error) {\n \tif err = c.Handshake(); err != nil {\n \t\treturn"}, {"sha": "75f5c73464a14e5a4f783719d33eab6fd2af077f", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -105,7 +105,7 @@ func md5SHA1Hash(slices ...[]byte) []byte {\n // pre-master secret is then calculated using ECDH.\n type ecdheRSAKeyAgreement struct {\n \tprivateKey []byte\n-\tcurve      *elliptic.Curve\n+\tcurve      elliptic.Curve\n \tx, y       *big.Int\n }\n \n@@ -132,11 +132,11 @@ Curve:\n \n \tvar x, y *big.Int\n \tvar err error\n-\tka.privateKey, x, y, err = ka.curve.GenerateKey(config.rand())\n+\tka.privateKey, x, y, err = elliptic.GenerateKey(ka.curve, config.rand())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tecdhePublic := ka.curve.Marshal(x, y)\n+\tecdhePublic := elliptic.Marshal(ka.curve, x, y)\n \n \t// http://tools.ietf.org/html/rfc4492#section-5.4\n \tserverECDHParams := make([]byte, 1+2+1+len(ecdhePublic))\n@@ -167,12 +167,12 @@ func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *cl\n \tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n \t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n \t}\n-\tx, y := ka.curve.Unmarshal(ckx.ciphertext[1:])\n+\tx, y := elliptic.Unmarshal(ka.curve, ckx.ciphertext[1:])\n \tif x == nil {\n \t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n \t}\n \tx, _ = ka.curve.ScalarMult(x, y, ka.privateKey)\n-\tpreMasterSecret := make([]byte, (ka.curve.BitSize+7)>>3)\n+\tpreMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)>>3)\n \txBytes := x.Bytes()\n \tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n \n@@ -205,7 +205,7 @@ func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientH\n \tif publicLen+4 > len(skx.key) {\n \t\treturn errServerKeyExchange\n \t}\n-\tka.x, ka.y = ka.curve.Unmarshal(skx.key[4 : 4+publicLen])\n+\tka.x, ka.y = elliptic.Unmarshal(ka.curve, skx.key[4:4+publicLen])\n \tif ka.x == nil {\n \t\treturn errServerKeyExchange\n \t}\n@@ -229,16 +229,16 @@ func (ka *ecdheRSAKeyAgreement) generateClientKeyExchange(config *Config, client\n \tif ka.curve == nil {\n \t\treturn nil, nil, errors.New(\"missing ServerKeyExchange message\")\n \t}\n-\tpriv, mx, my, err := ka.curve.GenerateKey(config.rand())\n+\tpriv, mx, my, err := elliptic.GenerateKey(ka.curve, config.rand())\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n \tx, _ := ka.curve.ScalarMult(ka.x, ka.y, priv)\n-\tpreMasterSecret := make([]byte, (ka.curve.BitSize+7)>>3)\n+\tpreMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)>>3)\n \txBytes := x.Bytes()\n \tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n \n-\tserialized := ka.curve.Marshal(mx, my)\n+\tserialized := elliptic.Marshal(ka.curve, mx, my)\n \n \tckx := new(clientKeyExchangeMsg)\n \tckx.ciphertext = make([]byte, 1+len(serialized))"}, {"sha": "acaf3dd9d67a071d18d8c19c9e390f0a9dbb1d3b", "filename": "libgo/go/crypto/tls/root_unix.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -13,10 +13,11 @@ import (\n \n // Possible certificate files; stop after finding one.\n var certFiles = []string{\n-\t\"/etc/ssl/certs/ca-certificates.crt\", // Linux etc\n-\t\"/etc/pki/tls/certs/ca-bundle.crt\",   // Fedora/RHEL\n-\t\"/etc/ssl/ca-bundle.pem\",             // OpenSUSE\n-\t\"/etc/ssl/cert.pem\",                  // OpenBSD\n+\t\"/etc/ssl/certs/ca-certificates.crt\",     // Linux etc\n+\t\"/etc/pki/tls/certs/ca-bundle.crt\",       // Fedora/RHEL\n+\t\"/etc/ssl/ca-bundle.pem\",                 // OpenSUSE\n+\t\"/etc/ssl/cert.pem\",                      // OpenBSD\n+\t\"/usr/local/share/certs/ca-root-nss.crt\", // FreeBSD\n }\n \n func initDefaultRoots() {"}, {"sha": "bf39c5dec0af7cdb99cdd56caaea8383bd9e10b4", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -899,6 +899,14 @@ var (\n \toidRSA         = []int{1, 2, 840, 113549, 1, 1, 1}\n )\n \n+func subjectBytes(cert *Certificate) ([]byte, error) {\n+\tif len(cert.RawSubject) > 0 {\n+\t\treturn cert.RawSubject, nil\n+\t}\n+\n+\treturn asn1.Marshal(cert.Subject.ToRDNSequence())\n+}\n+\n // CreateCertificate creates a new certificate based on a template. The\n // following members of template are used: SerialNumber, Subject, NotBefore,\n // NotAfter, KeyUsage, BasicConstraintsValid, IsCA, MaxPathLen, SubjectKeyId,\n@@ -909,10 +917,23 @@ var (\n // signee and priv is the private key of the signer.\n //\n // The returned slice is the certificate in DER encoding.\n-func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (cert []byte, err error) {\n+//\n+// The only supported key type is RSA (*rsa.PublicKey for pub, *rsa.PrivateKey\n+// for priv).\n+func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interface{}, priv interface{}) (cert []byte, err error) {\n+\trsaPub, ok := pub.(*rsa.PublicKey)\n+\tif !ok {\n+\t\treturn nil, errors.New(\"x509: non-RSA public keys not supported\")\n+\t}\n+\n+\trsaPriv, ok := priv.(*rsa.PrivateKey)\n+\tif !ok {\n+\t\treturn nil, errors.New(\"x509: non-RSA private keys not supported\")\n+\t}\n+\n \tasn1PublicKey, err := asn1.Marshal(rsaPublicKey{\n-\t\tN: pub.N,\n-\t\tE: pub.E,\n+\t\tN: rsaPub.N,\n+\t\tE: rsaPub.E,\n \t})\n \tif err != nil {\n \t\treturn\n@@ -927,16 +948,12 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \t\treturn\n \t}\n \n-\tvar asn1Issuer []byte\n-\tif len(parent.RawSubject) > 0 {\n-\t\tasn1Issuer = parent.RawSubject\n-\t} else {\n-\t\tif asn1Issuer, err = asn1.Marshal(parent.Subject.ToRDNSequence()); err != nil {\n-\t\t\treturn\n-\t\t}\n+\tasn1Issuer, err := subjectBytes(parent)\n+\tif err != nil {\n+\t\treturn\n \t}\n \n-\tasn1Subject, err := asn1.Marshal(template.Subject.ToRDNSequence())\n+\tasn1Subject, err := subjectBytes(template)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -964,7 +981,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \th.Write(tbsCertContents)\n \tdigest := h.Sum(nil)\n \n-\tsignature, err := rsa.SignPKCS1v15(rand, priv, crypto.SHA1, digest)\n+\tsignature, err := rsa.SignPKCS1v15(rand, rsaPriv, crypto.SHA1, digest)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -1011,7 +1028,13 @@ func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err error) {\n \n // CreateCRL returns a DER encoded CRL, signed by this Certificate, that\n // contains the given list of revoked certificates.\n-func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error) {\n+//\n+// The only supported key type is RSA (*rsa.PrivateKey for priv).\n+func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error) {\n+\trsaPriv, ok := priv.(*rsa.PrivateKey)\n+\tif !ok {\n+\t\treturn nil, errors.New(\"x509: non-RSA private keys not supported\")\n+\t}\n \ttbsCertList := pkix.TBSCertificateList{\n \t\tVersion: 2,\n \t\tSignature: pkix.AlgorithmIdentifier{\n@@ -1032,7 +1055,7 @@ func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCer\n \th.Write(tbsCertListContents)\n \tdigest := h.Sum(nil)\n \n-\tsignature, err := rsa.SignPKCS1v15(rand, priv, crypto.SHA1, digest)\n+\tsignature, err := rsa.SignPKCS1v15(rand, rsaPriv, crypto.SHA1, digest)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "9835e38de7e24c2e806640f4ec9b26d8857c7d28", "filename": "libgo/go/database/sql/convert.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -7,8 +7,8 @@\n package sql\n \n import (\n+\t\"database/sql/driver\"\n \t\"errors\"\n-\t\"exp/sql/driver\"\n \t\"fmt\"\n \t\"reflect\"\n \t\"strconv\"", "previous_filename": "libgo/go/exp/sql/convert.go"}, {"sha": "b188864f62328b965872b13f2b40b7e96b0cd9af", "filename": "libgo/go/database/sql/convert_test.go", "status": "renamed", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -5,6 +5,7 @@\n package sql\n \n import (\n+\t\"database/sql/driver\"\n \t\"fmt\"\n \t\"reflect\"\n \t\"testing\"\n@@ -154,8 +155,8 @@ func TestConversions(t *testing.T) {\n \t}\n }\n \n-func TestNullableString(t *testing.T) {\n-\tvar ns NullableString\n+func TestNullString(t *testing.T) {\n+\tvar ns NullString\n \tconvertAssign(&ns, []byte(\"foo\"))\n \tif !ns.Valid {\n \t\tt.Errorf(\"expecting not null\")\n@@ -171,3 +172,35 @@ func TestNullableString(t *testing.T) {\n \t\tt.Errorf(\"expecting blank on nil; got %q\", ns.String)\n \t}\n }\n+\n+type valueConverterTest struct {\n+\tc       driver.ValueConverter\n+\tin, out interface{}\n+\terr     string\n+}\n+\n+var valueConverterTests = []valueConverterTest{\n+\t{driver.DefaultParameterConverter, NullString{\"hi\", true}, \"hi\", \"\"},\n+\t{driver.DefaultParameterConverter, NullString{\"\", false}, nil, \"\"},\n+}\n+\n+func TestValueConverters(t *testing.T) {\n+\tfor i, tt := range valueConverterTests {\n+\t\tout, err := tt.c.ConvertValue(tt.in)\n+\t\tgoterr := \"\"\n+\t\tif err != nil {\n+\t\t\tgoterr = err.Error()\n+\t\t}\n+\t\tif goterr != tt.err {\n+\t\t\tt.Errorf(\"test %d: %s(%T(%v)) error = %q; want error = %q\",\n+\t\t\t\ti, tt.c, tt.in, tt.in, goterr, tt.err)\n+\t\t}\n+\t\tif tt.err != \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !reflect.DeepEqual(out, tt.out) {\n+\t\t\tt.Errorf(\"test %d: %s(%T(%v)) = %v (%T); want %v (%T)\",\n+\t\t\t\ti, tt.c, tt.in, tt.in, out, out, tt.out, tt.out)\n+\t\t}\n+\t}\n+}", "previous_filename": "libgo/go/exp/sql/convert_test.go"}, {"sha": "0cd2562d6822d360b58fc663a66da32df04ba861", "filename": "libgo/go/database/sql/driver/driver.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "previous_filename": "libgo/go/exp/sql/driver/driver.go"}, {"sha": "f38388523119b1731f33e398d76c4cfac26ffc97", "filename": "libgo/go/database/sql/driver/types.go", "status": "renamed", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -32,6 +32,15 @@ type ValueConverter interface {\n \tConvertValue(v interface{}) (interface{}, error)\n }\n \n+// SubsetValuer is the interface providing the SubsetValue method.\n+//\n+// Types implementing SubsetValuer interface are able to convert\n+// themselves to one of the driver's allowed subset values.\n+type SubsetValuer interface {\n+\t// SubsetValue returns a driver parameter subset value.\n+\tSubsetValue() (interface{}, error)\n+}\n+\n // Bool is a ValueConverter that converts input values to bools.\n //\n // The conversion rules are:\n@@ -136,6 +145,32 @@ func (stringType) ConvertValue(v interface{}) (interface{}, error) {\n \treturn fmt.Sprintf(\"%v\", v), nil\n }\n \n+// Null is a type that implements ValueConverter by allowing nil\n+// values but otherwise delegating to another ValueConverter.\n+type Null struct {\n+\tConverter ValueConverter\n+}\n+\n+func (n Null) ConvertValue(v interface{}) (interface{}, error) {\n+\tif v == nil {\n+\t\treturn nil, nil\n+\t}\n+\treturn n.Converter.ConvertValue(v)\n+}\n+\n+// NotNull is a type that implements ValueConverter by disallowing nil\n+// values but otherwise delegating to another ValueConverter.\n+type NotNull struct {\n+\tConverter ValueConverter\n+}\n+\n+func (n NotNull) ConvertValue(v interface{}) (interface{}, error) {\n+\tif v == nil {\n+\t\treturn nil, fmt.Errorf(\"nil value not allowed\")\n+\t}\n+\treturn n.Converter.ConvertValue(v)\n+}\n+\n // IsParameterSubsetType reports whether v is of a valid type for a\n // parameter. These types are:\n //\n@@ -200,6 +235,17 @@ func (defaultConverter) ConvertValue(v interface{}) (interface{}, error) {\n \t\treturn v, nil\n \t}\n \n+\tif svi, ok := v.(SubsetValuer); ok {\n+\t\tsv, err := svi.SubsetValue()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif !IsParameterSubsetType(sv) {\n+\t\t\treturn nil, fmt.Errorf(\"non-subset type %T returned from SubsetValue\", sv)\n+\t\t}\n+\t\treturn sv, nil\n+\t}\n+\n \trv := reflect.ValueOf(v)\n \tswitch rv.Kind() {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n@@ -215,5 +261,5 @@ func (defaultConverter) ConvertValue(v interface{}) (interface{}, error) {\n \tcase reflect.Float32, reflect.Float64:\n \t\treturn rv.Float(), nil\n \t}\n-\treturn nil, fmt.Errorf(\"unsupported type %s\", rv.Kind())\n+\treturn nil, fmt.Errorf(\"unsupported type %T, a %s\", v, rv.Kind())\n }", "previous_filename": "libgo/go/exp/sql/driver/types.go"}, {"sha": "966bc6b45877eaf303e4bc5ec40aaff477637221", "filename": "libgo/go/database/sql/driver/types_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "previous_filename": "libgo/go/exp/sql/driver/types_test.go"}, {"sha": "b0d137cd71568d08a3c9f1bb10bdf2573dbbbeca", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -5,6 +5,7 @@\n package sql\n \n import (\n+\t\"database/sql/driver\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n@@ -13,8 +14,6 @@ import (\n \t\"strings\"\n \t\"sync\"\n \t\"time\"\n-\n-\t\"exp/sql/driver\"\n )\n \n var _ = log.Printf\n@@ -589,7 +588,9 @@ func converterForType(typ string) driver.ValueConverter {\n \tcase \"int32\":\n \t\treturn driver.Int32\n \tcase \"string\":\n-\t\treturn driver.String\n+\t\treturn driver.NotNull{driver.String}\n+\tcase \"nullstring\":\n+\t\treturn driver.Null{driver.String}\n \tcase \"datetime\":\n \t\treturn driver.DefaultParameterConverter\n \t}", "previous_filename": "libgo/go/exp/sql/fakedb_test.go"}, {"sha": "a8bf2a8b00c933d9963f5c82681cbaaf2823070b", "filename": "libgo/go/database/sql/sql.go", "status": "renamed", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -7,12 +7,11 @@\n package sql\n \n import (\n+\t\"database/sql/driver\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"sync\"\n-\n-\t\"exp/sql/driver\"\n )\n \n var drivers = make(map[string]driver.Driver)\n@@ -30,11 +29,16 @@ func Register(name string, driver driver.Driver) {\n \tdrivers[name] = driver\n }\n \n-// NullableString represents a string that may be null.\n-// NullableString implements the ScannerInto interface so\n+// RawBytes is a byte slice that holds a reference to memory owned by\n+// the database itself. After a Scan into a RawBytes, the slice is only\n+// valid until the next call to Next, Scan, or Close.\n+type RawBytes []byte\n+\n+// NullString represents a string that may be null.\n+// NullString implements the ScannerInto interface so\n // it can be used as a scan destination:\n //\n-//  var s NullableString\n+//  var s NullString\n //  err := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&s)\n //  ...\n //  if s.Valid {\n@@ -44,19 +48,27 @@ func Register(name string, driver driver.Driver) {\n //  }\n //\n // TODO(bradfitz): add other types.\n-type NullableString struct {\n+type NullString struct {\n \tString string\n \tValid  bool // Valid is true if String is not NULL\n }\n \n // ScanInto implements the ScannerInto interface.\n-func (ms *NullableString) ScanInto(value interface{}) error {\n+func (ns *NullString) ScanInto(value interface{}) error {\n \tif value == nil {\n-\t\tms.String, ms.Valid = \"\", false\n+\t\tns.String, ns.Valid = \"\", false\n \t\treturn nil\n \t}\n-\tms.Valid = true\n-\treturn convertAssign(&ms.String, value)\n+\tns.Valid = true\n+\treturn convertAssign(&ns.String, value)\n+}\n+\n+// SubsetValue implements the driver SubsetValuer interface.\n+func (ns NullString) SubsetValue() (interface{}, error) {\n+\tif !ns.Valid {\n+\t\treturn nil, nil\n+\t}\n+\treturn ns.String, nil\n }\n \n // ScannerInto is an interface used by Scan.\n@@ -525,6 +537,27 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \t// Convert args to subset types.\n \tif cc, ok := si.(driver.ColumnConverter); ok {\n \t\tfor n, arg := range args {\n+\t\t\t// First, see if the value itself knows how to convert\n+\t\t\t// itself to a driver type.  For example, a NullString\n+\t\t\t// struct changing into a string or nil.\n+\t\t\tif svi, ok := arg.(driver.SubsetValuer); ok {\n+\t\t\t\tsv, err := svi.SubsetValue()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d from SubsetValue: %v\", n, err)\n+\t\t\t\t}\n+\t\t\t\tif !driver.IsParameterSubsetType(sv) {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d: non-subset type %T returned from SubsetValue\", n, sv)\n+\t\t\t\t}\n+\t\t\t\targ = sv\n+\t\t\t}\n+\n+\t\t\t// Second, ask the column to sanity check itself. For\n+\t\t\t// example, drivers might use this to make sure that\n+\t\t\t// an int64 values being inserted into a 16-bit\n+\t\t\t// integer field is in range (before getting\n+\t\t\t// truncated), or that a nil can't go into a NOT NULL\n+\t\t\t// column before going across the network to get the\n+\t\t\t// same error.\n \t\t\targs[n], err = cc.ColumnConverter(n).ConvertValue(arg)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n@@ -760,9 +793,13 @@ func (rs *Rows) Columns() ([]string, error) {\n }\n \n // Scan copies the columns in the current row into the values pointed\n-// at by dest. If dest contains pointers to []byte, the slices should\n-// not be modified and should only be considered valid until the next\n-// call to Next or Scan.\n+// at by dest.\n+//\n+// If an argument has type *[]byte, Scan saves in that argument a copy\n+// of the corresponding data. The copy is owned by the caller and can\n+// be modified and held indefinitely. The copy can be avoided by using\n+// an argument of type *RawBytes instead; see the documentation for\n+// RawBytes for restrictions on its use.\n func (rs *Rows) Scan(dest ...interface{}) error {\n \tif rs.closed {\n \t\treturn errors.New(\"sql: Rows closed\")\n@@ -782,6 +819,18 @@ func (rs *Rows) Scan(dest ...interface{}) error {\n \t\t\treturn fmt.Errorf(\"sql: Scan error on column index %d: %v\", i, err)\n \t\t}\n \t}\n+\tfor _, dp := range dest {\n+\t\tb, ok := dp.(*[]byte)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif _, ok = dp.(*RawBytes); ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\tclone := make([]byte, len(*b))\n+\t\tcopy(clone, *b)\n+\t\t*b = clone\n+\t}\n \treturn nil\n }\n \n@@ -838,6 +887,9 @@ func (r *Row) Scan(dest ...interface{}) error {\n \t// they were obtained from the network anyway) But for now we\n \t// don't care.\n \tfor _, dp := range dest {\n+\t\tif _, ok := dp.(*RawBytes); ok {\n+\t\t\treturn errors.New(\"sql: RawBytes isn't allowed on Row.Scan\")\n+\t\t}\n \t\tb, ok := dp.(*[]byte)\n \t\tif !ok {\n \t\t\tcontinue", "previous_filename": "libgo/go/exp/sql/sql.go"}, {"sha": "3fe93986faa6d0bfaa289cde3f7c341cb8bed4c6", "filename": "libgo/go/database/sql/sql_test.go", "status": "renamed", "additions": 101, "deletions": 2, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -76,7 +76,7 @@ func TestQuery(t *testing.T) {\n \t\t{age: 3, name: \"Chris\"},\n \t}\n \tif !reflect.DeepEqual(got, want) {\n-\t\tt.Logf(\" got: %#v\\nwant: %#v\", got, want)\n+\t\tt.Errorf(\"mismatch.\\n got: %#v\\nwant: %#v\", got, want)\n \t}\n \n \t// And verify that the final rows.Next() call, which hit EOF,\n@@ -86,6 +86,43 @@ func TestQuery(t *testing.T) {\n \t}\n }\n \n+func TestByteOwnership(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\trows, err := db.Query(\"SELECT|people|name,photo|\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Query: %v\", err)\n+\t}\n+\ttype row struct {\n+\t\tname  []byte\n+\t\tphoto RawBytes\n+\t}\n+\tgot := []row{}\n+\tfor rows.Next() {\n+\t\tvar r row\n+\t\terr = rows.Scan(&r.name, &r.photo)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Scan: %v\", err)\n+\t\t}\n+\t\tgot = append(got, r)\n+\t}\n+\tcorruptMemory := []byte(\"\\xffPHOTO\")\n+\twant := []row{\n+\t\t{name: []byte(\"Alice\"), photo: corruptMemory},\n+\t\t{name: []byte(\"Bob\"), photo: corruptMemory},\n+\t\t{name: []byte(\"Chris\"), photo: corruptMemory},\n+\t}\n+\tif !reflect.DeepEqual(got, want) {\n+\t\tt.Errorf(\"mismatch.\\n got: %#v\\nwant: %#v\", got, want)\n+\t}\n+\n+\tvar photo RawBytes\n+\terr = db.QueryRow(\"SELECT|people|photo|name=?\", \"Alice\").Scan(&photo)\n+\tif err == nil {\n+\t\tt.Error(\"want error scanning into RawBytes from QueryRow\")\n+\t}\n+}\n+\n func TestRowsColumns(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -300,6 +337,68 @@ func TestQueryRowClosingStmt(t *testing.T) {\n \t}\n \tfakeConn := db.freeConn[0].(*fakeConn)\n \tif made, closed := fakeConn.stmtsMade, fakeConn.stmtsClosed; made != closed {\n-\t\tt.Logf(\"statement close mismatch: made %d, closed %d\", made, closed)\n+\t\tt.Errorf(\"statement close mismatch: made %d, closed %d\", made, closed)\n+\t}\n+}\n+\n+func TestNullStringParam(t *testing.T) {\n+\tdb := newTestDB(t, \"\")\n+\tdefer closeDB(t, db)\n+\texec(t, db, \"CREATE|t|id=int32,name=string,favcolor=nullstring\")\n+\n+\t// Inserts with db.Exec:\n+\texec(t, db, \"INSERT|t|id=?,name=?,favcolor=?\", 1, \"alice\", NullString{\"aqua\", true})\n+\texec(t, db, \"INSERT|t|id=?,name=?,favcolor=?\", 2, \"bob\", NullString{\"brown\", false})\n+\n+\t_, err := db.Exec(\"INSERT|t|id=?,name=?,favcolor=?\", 999, nil, nil)\n+\tif err == nil {\n+\t\t// TODO: this test fails, but it's just because\n+\t\t// fakeConn implements the optional Execer interface,\n+\t\t// so arguably this is the correct behavior.  But\n+\t\t// maybe I should flesh out the fakeConn.Exec\n+\t\t// implementation so this properly fails.\n+\t\t// t.Errorf(\"expected error inserting nil name with Exec\")\n+\t}\n+\n+\t// Inserts with a prepared statement:\n+\tstmt, err := db.Prepare(\"INSERT|t|id=?,name=?,favcolor=?\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"prepare: %v\", err)\n+\t}\n+\tif _, err := stmt.Exec(3, \"chris\", \"chartreuse\"); err != nil {\n+\t\tt.Errorf(\"exec insert chris: %v\", err)\n+\t}\n+\tif _, err := stmt.Exec(4, \"dave\", NullString{\"darkred\", true}); err != nil {\n+\t\tt.Errorf(\"exec insert dave: %v\", err)\n+\t}\n+\tif _, err := stmt.Exec(5, \"eleanor\", NullString{\"eel\", false}); err != nil {\n+\t\tt.Errorf(\"exec insert dave: %v\", err)\n+\t}\n+\n+\t// Can't put null name into non-nullstring column,\n+\tif _, err := stmt.Exec(5, NullString{\"\", false}, nil); err == nil {\n+\t\tt.Errorf(\"expected error inserting nil name with prepared statement Exec\")\n+\t}\n+\n+\ttype nameColor struct {\n+\t\tname     string\n+\t\tfavColor NullString\n+\t}\n+\n+\twantMap := map[int]nameColor{\n+\t\t1: nameColor{\"alice\", NullString{\"aqua\", true}},\n+\t\t2: nameColor{\"bob\", NullString{\"\", false}},\n+\t\t3: nameColor{\"chris\", NullString{\"chartreuse\", true}},\n+\t\t4: nameColor{\"dave\", NullString{\"darkred\", true}},\n+\t\t5: nameColor{\"eleanor\", NullString{\"\", false}},\n+\t}\n+\tfor id, want := range wantMap {\n+\t\tvar got nameColor\n+\t\tif err := db.QueryRow(\"SELECT|t|name,favcolor|id=?\", id).Scan(&got.name, &got.favColor); err != nil {\n+\t\t\tt.Errorf(\"id=%d Scan: %v\", id, err)\n+\t\t}\n+\t\tif got != want {\n+\t\t\tt.Errorf(\"id=%d got %#v, want %#v\", id, got, want)\n+\t\t}\n \t}\n }", "previous_filename": "libgo/go/exp/sql/sql_test.go"}, {"sha": "4a61d0fb2f8b676c0b17c09cb8e7adc2cdb8000e", "filename": "libgo/go/encoding/gob/debug.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package gob\n \n // This file is not normally included in the gob package.  Used only for debugging the package itself."}, {"sha": "f7d822c11e4a6c48d7ee7196f3e1c4ad34019c7c", "filename": "libgo/go/encoding/gob/dump.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package main\n \n // Need to compile package gob with debug.go to build this program."}, {"sha": "eac14a47ed7ac1722dfaf595c5ca0ecec0577892", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -39,6 +39,8 @@ import (\n //\n // String values encode as JSON strings, with each invalid UTF-8 sequence\n // replaced by the encoding of the Unicode replacement character U+FFFD.\n+// The angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\n+// to keep some browsers from misinterpreting JSON output as HTML.\n //\n // Array and slice values encode as JSON arrays, except that\n // []byte encodes as a base64-encoded string.\n@@ -77,7 +79,8 @@ import (\n //    Int64String int64 `json:\",string\"`\n //\n // The key name will be used if it's a non-empty string consisting of\n-// only Unicode letters, digits, dollar signs, hyphens, and underscores.\n+// only Unicode letters, digits, dollar signs, percent signs, hyphens,\n+// underscores and slashes.\n //\n // Map values encode as JSON objects.\n // The map's key type must be string; the object keys are used directly\n@@ -417,8 +420,13 @@ func isValidTag(s string) bool {\n \t\treturn false\n \t}\n \tfor _, c := range s {\n-\t\tif c != '$' && c != '-' && c != '_' && !unicode.IsLetter(c) && !unicode.IsDigit(c) {\n-\t\t\treturn false\n+\t\tswitch c {\n+\t\tcase '$', '-', '_', '/', '%':\n+\t\t\t// Acceptable\n+\t\tdefault:\n+\t\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t}\n \t}\n \treturn true"}, {"sha": "bba5730353d27f0e26d3cc4f7444da89bdb7a21b", "filename": "libgo/go/encoding/json/tagkey_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,7 +9,7 @@ import (\n )\n \n type basicLatin2xTag struct {\n-\tV string `json:\"$-\"`\n+\tV string `json:\"$%-/\"`\n }\n \n type basicLatin3xTag struct {\n@@ -36,6 +36,10 @@ type miscPlaneTag struct {\n \tV string `json:\"\u8272\u306f\u5302\u3078\u3069\"`\n }\n \n+type percentSlashTag struct {\n+\tV string `json:\"text/html%\"` // http://golang.org/issue/2718\n+}\n+\n type emptyTag struct {\n \tW string\n }\n@@ -49,15 +53,15 @@ type badFormatTag struct {\n }\n \n type badCodeTag struct {\n-\tZ string `json:\" !\\\"#%&'()*+,./\"`\n+\tZ string `json:\" !\\\"#&'()*+,.\"`\n }\n \n var structTagObjectKeyTests = []struct {\n \traw   interface{}\n \tvalue string\n \tkey   string\n }{\n-\t{basicLatin2xTag{\"2x\"}, \"2x\", \"$-\"},\n+\t{basicLatin2xTag{\"2x\"}, \"2x\", \"$%-/\"},\n \t{basicLatin3xTag{\"3x\"}, \"3x\", \"0123456789\"},\n \t{basicLatin4xTag{\"4x\"}, \"4x\", \"ABCDEFGHIJKLMO\"},\n \t{basicLatin5xTag{\"5x\"}, \"5x\", \"PQRSTUVWXYZ_\"},\n@@ -68,6 +72,7 @@ var structTagObjectKeyTests = []struct {\n \t{misnamedTag{\"Animal Kingdom\"}, \"Animal Kingdom\", \"X\"},\n \t{badFormatTag{\"Orfevre\"}, \"Orfevre\", \"Y\"},\n \t{badCodeTag{\"Reliable Man\"}, \"Reliable Man\", \"Z\"},\n+\t{percentSlashTag{\"brut\"}, \"brut\", \"text/html%\"},\n }\n \n func TestStructTagObjectKey(t *testing.T) {\n@@ -88,7 +93,7 @@ func TestStructTagObjectKey(t *testing.T) {\n \t\t\t\t\tt.Fatalf(\"Unexpected value: %#q, want %v\", s, tt.value)\n \t\t\t\t}\n \t\t\tdefault:\n-\t\t\t\tt.Fatalf(\"Unexpected key: %#q\", i)\n+\t\t\t\tt.Fatalf(\"Unexpected key: %#q, from %#q\", i, b)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "f23b2cb7e080e2bc226d45ecbd789f1f65503c69", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -150,6 +150,10 @@ type XMLNameWithoutTag struct {\n \tValue   string \",chardata\"\n }\n \n+type NameInField struct {\n+\tFoo Name `xml:\"ns foo\"`\n+}\n+\n type AttrTest struct {\n \tInt   int     `xml:\",attr\"`\n \tLower int     `xml:\"int,attr\"`\n@@ -483,6 +487,19 @@ var marshalTests = []struct {\n \t\tUnmarshalOnly: true,\n \t},\n \n+\t// xml.Name works in a plain field as well.\n+\t{\n+\t\tValue:     &NameInField{Name{Space: \"ns\", Local: \"foo\"}},\n+\t\tExpectXML: `<NameInField><foo xmlns=\"ns\"></foo></NameInField>`,\n+\t},\n+\n+\t// Marshaling zero xml.Name uses the tag or field name.\n+\t{\n+\t\tValue:       &NameInField{},\n+\t\tExpectXML:   `<NameInField><foo xmlns=\"ns\"></foo></NameInField>`,\n+\t\tMarshalOnly: true,\n+\t},\n+\n \t// Test attributes\n \t{\n \t\tValue: &AttrTest{"}, {"sha": "4419ed1e4773fc111b26a891cc10411a40cd008a", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -271,6 +271,10 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) error {\n \tcase reflect.Struct:\n \t\tsv = v\n \t\ttyp := sv.Type()\n+\t\tif typ == nameType {\n+\t\t\tv.Set(reflect.ValueOf(start.Name))\n+\t\t\tbreak\n+\t\t}\n \t\ttinfo, err = getTypeInfo(typ)\n \t\tif err != nil {\n \t\t\treturn err"}, {"sha": "36b35ed2ee888920cf6ec75c68c7cc04144a21de", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -46,6 +46,8 @@ const (\n var tinfoMap = make(map[reflect.Type]*typeInfo)\n var tinfoLock sync.RWMutex\n \n+var nameType = reflect.TypeOf(Name{})\n+\n // getTypeInfo returns the typeInfo structure with details necessary\n // for marshalling and unmarshalling typ.\n func getTypeInfo(typ reflect.Type) (*typeInfo, error) {\n@@ -56,7 +58,7 @@ func getTypeInfo(typ reflect.Type) (*typeInfo, error) {\n \t\treturn tinfo, nil\n \t}\n \ttinfo = &typeInfo{}\n-\tif typ.Kind() == reflect.Struct {\n+\tif typ.Kind() == reflect.Struct && typ != nameType {\n \t\tn := typ.NumField()\n \t\tfor i := 0; i < n; i++ {\n \t\t\tf := typ.Field(i)"}, {"sha": "ba8a51f135e3c0c5a32c260f399aaab1e5ea544e", "filename": "libgo/go/exp/gotype/testdata/test1.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package p\n \n func _() {"}, {"sha": "c2160fc65375d42198940fa55d9285848c3b435f", "filename": "libgo/go/exp/inotify/inotify_linux_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -83,14 +83,15 @@ func TestInotifyClose(t *testing.T) {\n \twatcher, _ := NewWatcher()\n \twatcher.Close()\n \n-\tdone := false\n+\tdone := make(chan bool)\n \tgo func() {\n \t\twatcher.Close()\n-\t\tdone = true\n+\t\tdone <- true\n \t}()\n \n-\ttime.Sleep(50 * time.Millisecond)\n-\tif !done {\n+\tselect {\n+\tcase <-done:\n+\tcase <-time.After(50 * time.Millisecond):\n \t\tt.Fatal(\"double Close() test failed: second Close() call didn't return\")\n \t}\n "}, {"sha": "c457c9d974a99385ed5c68bacd8732ed43780251", "filename": "libgo/go/exp/norm/trie_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package norm\n \n import ("}, {"sha": "b6cfd45108a2626a141d5728223268db7461d7e3", "filename": "libgo/go/exp/proxy/proxy.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"net\"\n \t\"net/url\"\n \t\"os\"\n-\t\"strings\"\n )\n \n // A Dialer is a means to establish a connection.\n@@ -70,14 +69,11 @@ func RegisterDialerType(scheme string, f func(*url.URL, Dialer) (Dialer, error))\n // Dialer for it to make network requests.\n func FromURL(u *url.URL, forward Dialer) (Dialer, error) {\n \tvar auth *Auth\n-\tif len(u.RawUserinfo) > 0 {\n+\tif u.User != nil {\n \t\tauth = new(Auth)\n-\t\tparts := strings.SplitN(u.RawUserinfo, \":\", 1)\n-\t\tif len(parts) == 1 {\n-\t\t\tauth.User = parts[0]\n-\t\t} else if len(parts) >= 2 {\n-\t\t\tauth.User = parts[0]\n-\t\t\tauth.Password = parts[1]\n+\t\tauth.User = u.User.Username()\n+\t\tif p, ok := u.User.Password(); ok {\n+\t\t\tauth.Password = p\n \t\t}\n \t}\n "}, {"sha": "eb6c0352210fa7b00b30fde74f4da951923f338b", "filename": "libgo/go/exp/ssh/client.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -306,9 +306,8 @@ type clientChan struct {\n \tstdout      *chanReader      // receives the payload of channelData messages\n \tstderr      *chanReader      // receives the payload of channelExtendedData messages\n \tmsg         chan interface{} // incoming messages\n-\n-\ttheyClosed bool // indicates the close msg has been received from the remote side\n-\tweClosed   bool // incidates the close msg has been sent from our side\n+\ttheyClosed  bool             // indicates the close msg has been received from the remote side\n+\tweClosed    bool             // incidates the close msg has been sent from our side\n }\n \n // newClientChan returns a partially constructed *clientChan"}, {"sha": "34ad131ff64e7f5d927857746e94b4c472c0da24", "filename": "libgo/go/exp/ssh/messages.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -484,6 +484,26 @@ func intLength(n *big.Int) int {\n \treturn length\n }\n \n+func marshalUint32(to []byte, n uint32) []byte {\n+\tto[0] = byte(n >> 24)\n+\tto[1] = byte(n >> 16)\n+\tto[2] = byte(n >> 8)\n+\tto[3] = byte(n)\n+\treturn to[4:]\n+}\n+\n+func marshalUint64(to []byte, n uint64) []byte {\n+\tto[0] = byte(n >> 56)\n+\tto[1] = byte(n >> 48)\n+\tto[2] = byte(n >> 40)\n+\tto[3] = byte(n >> 32)\n+\tto[4] = byte(n >> 24)\n+\tto[5] = byte(n >> 16)\n+\tto[6] = byte(n >> 8)\n+\tto[7] = byte(n)\n+\treturn to[8:]\n+}\n+\n func marshalInt(to []byte, n *big.Int) []byte {\n \tlengthBytes := to\n \tto = to[4:]"}, {"sha": "ea4addbd50b074abda90bf3fbb25ebf7fb3d45b5", "filename": "libgo/go/exp/ssh/session.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -70,7 +70,7 @@ type Session struct {\n \n \tstarted   bool // true once Start, Run or Shell is invoked.\n \tcopyFuncs []func() error\n-\terrch     chan error // one send per copyFunc\n+\terrors    chan error // one send per copyFunc\n \n \t// true if pipe method is active\n \tstdinpipe, stdoutpipe, stderrpipe bool\n@@ -244,10 +244,10 @@ func (s *Session) start() error {\n \t\tsetupFd(s)\n \t}\n \n-\ts.errch = make(chan error, len(s.copyFuncs))\n+\ts.errors = make(chan error, len(s.copyFuncs))\n \tfor _, fn := range s.copyFuncs {\n \t\tgo func(fn func() error) {\n-\t\t\ts.errch <- fn()\n+\t\t\ts.errors <- fn()\n \t\t}(fn)\n \t}\n \treturn nil\n@@ -270,7 +270,7 @@ func (s *Session) Wait() error {\n \n \tvar copyError error\n \tfor _ = range s.copyFuncs {\n-\t\tif err := <-s.errch; err != nil && copyError == nil {\n+\t\tif err := <-s.errors; err != nil && copyError == nil {\n \t\t\tcopyError = err\n \t\t}\n \t}"}, {"sha": "e0c47bca1fcd4180dc89b56f73e3091443fdcbc8", "filename": "libgo/go/exp/ssh/tcpip.go", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"net\"\n+\t\"time\"\n )\n \n // Dial initiates a connection to the addr from the remote host.\n@@ -107,27 +108,25 @@ func (t *tcpchanconn) RemoteAddr() net.Addr {\n \treturn t.raddr\n }\n \n-// SetTimeout sets the read and write deadlines associated\n+// SetDeadline sets the read and write deadlines associated\n // with the connection.\n-func (t *tcpchanconn) SetTimeout(nsec int64) error {\n-\tif err := t.SetReadTimeout(nsec); err != nil {\n+func (t *tcpchanconn) SetDeadline(deadline time.Time) error {\n+\tif err := t.SetReadDeadline(deadline); err != nil {\n \t\treturn err\n \t}\n-\treturn t.SetWriteTimeout(nsec)\n+\treturn t.SetWriteDeadline(deadline)\n }\n \n-// SetReadTimeout sets the time (in nanoseconds) that\n-// Read will wait for data before returning an error with Timeout() == true.\n-// Setting nsec == 0 (the default) disables the deadline.\n-func (t *tcpchanconn) SetReadTimeout(nsec int64) error {\n-\treturn errors.New(\"ssh: tcpchan: timeout not supported\")\n+// SetReadDeadline sets the read deadline.\n+// A zero value for t means Read will not time out.\n+// After the deadline, the error from Read will implement net.Error\n+// with Timeout() == true.\n+func (t *tcpchanconn) SetReadDeadline(deadline time.Time) error {\n+\treturn errors.New(\"ssh: tcpchan: deadline not supported\")\n }\n \n-// SetWriteTimeout sets the time (in nanoseconds) that\n-// Write will wait to send its data before returning an error with Timeout() == true.\n-// Setting nsec == 0 (the default) disables the deadline.\n-// Even if write times out, it may return n > 0, indicating that\n-// some of the data was successfully written.\n-func (t *tcpchanconn) SetWriteTimeout(nsec int64) error {\n-\treturn errors.New(\"ssh: tcpchan: timeout not supported\")\n+// SetWriteDeadline exists to satisfy the net.Conn interface\n+// but is not implemented by this type.  It always returns an error.\n+func (t *tcpchanconn) SetWriteDeadline(deadline time.Time) error {\n+\treturn errors.New(\"ssh: tcpchan: deadline not supported\")\n }"}, {"sha": "e21bc4ba2025084bf687e0b2676ab7197f77739a", "filename": "libgo/go/exp/ssh/transport.go", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"crypto\"\n \t\"crypto/cipher\"\n \t\"crypto/hmac\"\n+\t\"crypto/sha1\"\n \t\"crypto/subtle\"\n \t\"errors\"\n \t\"hash\"\n@@ -266,7 +267,7 @@ func (c *common) setupKeys(d direction, K, H, sessionId []byte, hashFunc crypto.\n \tgenerateKeyMaterial(key, d.keyTag, K, H, sessionId, h)\n \tgenerateKeyMaterial(macKey, d.macKeyTag, K, H, sessionId, h)\n \n-\tc.mac = truncatingMAC{12, hmac.NewSHA1(macKey)}\n+\tc.mac = truncatingMAC{12, hmac.New(sha1.New, macKey)}\n \n \tcipher, err := cipherMode.createCipher(key, iv)\n \tif err != nil {\n@@ -328,6 +329,8 @@ func (t truncatingMAC) Size() int {\n \treturn t.length\n }\n \n+func (t truncatingMAC) BlockSize() int { return t.hmac.BlockSize() }\n+\n // maxVersionStringBytes is the maximum number of bytes that we'll accept as a\n // version string. In the event that the client is talking a different protocol\n // we need to set a limit otherwise we will keep using more and more memory\n@@ -337,35 +340,30 @@ const maxVersionStringBytes = 1024\n // Read version string as specified by RFC 4253, section 4.2.\n func readVersion(r io.Reader) ([]byte, error) {\n \tversionString := make([]byte, 0, 64)\n-\tvar ok, seenCR bool\n+\tvar ok bool\n \tvar buf [1]byte\n forEachByte:\n \tfor len(versionString) < maxVersionStringBytes {\n \t\t_, err := io.ReadFull(r, buf[:])\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tb := buf[0]\n-\n-\t\tif !seenCR {\n-\t\t\tif b == '\\r' {\n-\t\t\t\tseenCR = true\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif b == '\\n' {\n-\t\t\t\tok = true\n-\t\t\t\tbreak forEachByte\n-\t\t\t} else {\n-\t\t\t\tseenCR = false\n-\t\t\t}\n+\t\t// The RFC says that the version should be terminated with \\r\\n\n+\t\t// but several SSH servers actually only send a \\n.\n+\t\tif buf[0] == '\\n' {\n+\t\t\tok = true\n+\t\t\tbreak forEachByte\n \t\t}\n-\t\tversionString = append(versionString, b)\n+\t\tversionString = append(versionString, buf[0])\n \t}\n \n \tif !ok {\n-\t\treturn nil, errors.New(\"failed to read version string\")\n+\t\treturn nil, errors.New(\"ssh: failed to read version string\")\n \t}\n \n-\t// We need to remove the CR from versionString\n-\treturn versionString[:len(versionString)-1], nil\n+\t// There might be a '\\r' on the end which we should remove.\n+\tif len(versionString) > 0 && versionString[len(versionString)-1] == '\\r' {\n+\t\tversionString = versionString[:len(versionString)-1]\n+\t}\n+\treturn versionString, nil\n }"}, {"sha": "ab9177f0d11fa42e3e80b4f0e7e040e29becbea3", "filename": "libgo/go/exp/ssh/transport_test.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -11,7 +11,7 @@ import (\n )\n \n func TestReadVersion(t *testing.T) {\n-\tbuf := []byte(serverVersion)\n+\tbuf := serverVersion\n \tresult, err := readVersion(bufio.NewReader(bytes.NewBuffer(buf)))\n \tif err != nil {\n \t\tt.Errorf(\"readVersion didn't read version correctly: %s\", err)\n@@ -21,6 +21,20 @@ func TestReadVersion(t *testing.T) {\n \t}\n }\n \n+func TestReadVersionWithJustLF(t *testing.T) {\n+\tvar buf []byte\n+\tbuf = append(buf, serverVersion...)\n+\tbuf = buf[:len(buf)-1]\n+\tbuf[len(buf)-1] = '\\n'\n+\tresult, err := readVersion(bufio.NewReader(bytes.NewBuffer(buf)))\n+\tif err != nil {\n+\t\tt.Error(\"readVersion failed to handle just a \\n\")\n+\t}\n+\tif !bytes.Equal(buf[:len(buf)-1], result) {\n+\t\tt.Errorf(\"version read did not match expected: got %x, want %x\", result, buf[:len(buf)-1])\n+\t}\n+}\n+\n func TestReadVersionTooLong(t *testing.T) {\n \tbuf := make([]byte, maxVersionStringBytes+1)\n \tif _, err := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); err == nil {\n@@ -29,7 +43,7 @@ func TestReadVersionTooLong(t *testing.T) {\n }\n \n func TestReadVersionWithoutCRLF(t *testing.T) {\n-\tbuf := []byte(serverVersion)\n+\tbuf := serverVersion\n \tbuf = buf[:len(buf)-1]\n \tif _, err := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); err == nil {\n \t\tt.Error(\"readVersion did not notice \\\\n was missing\")"}, {"sha": "0e20646a005bc188a1d2fe34108007a507f3ab3a", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -47,26 +47,24 @@ var tests = []struct {\n \n var fset = token.NewFileSet()\n \n-// TODO(gri) This functionality should be in token.Fileset.\n-func getFile(filename string) *token.File {\n-\tfor f := range fset.Files() {\n+func getFile(filename string) (file *token.File) {\n+\tfset.Iterate(func(f *token.File) bool {\n \t\tif f.Name() == filename {\n-\t\t\treturn f\n+\t\t\tfile = f\n+\t\t\treturn false // end iteration\n \t\t}\n-\t}\n-\treturn nil\n+\t\treturn true\n+\t})\n+\treturn file\n }\n \n-// TODO(gri) This functionality should be in token.Fileset.\n func getPos(filename string, offset int) token.Pos {\n \tif f := getFile(filename); f != nil {\n \t\treturn f.Pos(offset)\n \t}\n \treturn token.NoPos\n }\n \n-// TODO(gri) Need to revisit parser interface. We should be able to use parser.ParseFiles\n-//           or a similar function instead.\n func parseFiles(t *testing.T, testname string, filenames []string) (map[string]*ast.File, error) {\n \tfiles := make(map[string]*ast.File)\n \tvar errors scanner.ErrorList\n@@ -145,8 +143,6 @@ func eliminate(t *testing.T, expected map[token.Pos]string, errors error) {\n \tfor _, error := range errors.(scanner.ErrorList) {\n \t\t// error.Pos is a token.Position, but we want\n \t\t// a token.Pos so we can do a map lookup\n-\t\t// TODO(gri) Need to move scanner.Errors over\n-\t\t//           to use token.Pos and file set info.\n \t\tpos := getPos(error.Pos.Filename, error.Pos.Offset)\n \t\tif msg, found := expected[pos]; found {\n \t\t\t// we expect a message at pos; check if it matches"}, {"sha": "a573fbb2463edc4f7741cd041263df37fdc8e9f3", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -460,29 +460,32 @@ func (p *gcParser) parseSignature() *Func {\n \treturn &Func{Params: params, Results: results, IsVariadic: isVariadic}\n }\n \n-// MethodSpec = ( identifier | ExportedName )  Signature .\n+// MethodOrEmbedSpec = Name [ Signature ] .\n //\n-func (p *gcParser) parseMethodSpec() *ast.Object {\n-\tif p.tok == scanner.Ident {\n-\t\tp.expect(scanner.Ident)\n-\t} else {\n-\t\tp.parseExportedName()\n+func (p *gcParser) parseMethodOrEmbedSpec() *ast.Object {\n+\tp.parseName()\n+\tif p.tok == '(' {\n+\t\tp.parseSignature()\n+\t\t// TODO(gri) compute method object\n+\t\treturn ast.NewObj(ast.Fun, \"_\")\n \t}\n-\tp.parseSignature()\n-\n-\t// TODO(gri) compute method object\n-\treturn ast.NewObj(ast.Fun, \"_\")\n+\t// TODO lookup name and return that type\n+\treturn ast.NewObj(ast.Typ, \"_\")\n }\n \n-// InterfaceType = \"interface\" \"{\" [ MethodList ] \"}\" .\n-// MethodList    = MethodSpec { \";\" MethodSpec } .\n+// InterfaceType = \"interface\" \"{\" [ MethodOrEmbedList ] \"}\" .\n+// MethodOrEmbedList = MethodOrEmbedSpec { \";\" MethodOrEmbedSpec } .\n //\n func (p *gcParser) parseInterfaceType() Type {\n \tvar methods ObjList\n \n \tparseMethod := func() {\n-\t\tmeth := p.parseMethodSpec()\n-\t\tmethods = append(methods, meth)\n+\t\tswitch m := p.parseMethodOrEmbedSpec(); m.Kind {\n+\t\tcase ast.Typ:\n+\t\t\t// TODO expand embedded methods\n+\t\tcase ast.Fun:\n+\t\t\tmethods = append(methods, m)\n+\t\t}\n \t}\n \n \tp.expectKeyword(\"interface\")"}, {"sha": "da1e2de1ea2fc4db8c3f6cf6eda4670ca56733a5", "filename": "libgo/go/exp/utf8string/string.go", "status": "renamed", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Futf8string%2Fstring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Futf8string%2Fstring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Futf8string%2Fstring.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -2,9 +2,13 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package utf8\n+// Package utf8string provides an efficient way to index strings by rune rather than by byte.\n+package utf8string\n \n-import \"errors\"\n+import (\n+\t\"errors\"\n+\t\"unicode/utf8\"\n+)\n \n // String wraps a regular string with a small structure that provides more\n // efficient indexing by code point index, as opposed to byte index.\n@@ -37,10 +41,10 @@ func (s *String) Init(contents string) *String {\n \ts.bytePos = 0\n \ts.runePos = 0\n \tfor i := 0; i < len(contents); i++ {\n-\t\tif contents[i] >= RuneSelf {\n+\t\tif contents[i] >= utf8.RuneSelf {\n \t\t\t// Not ASCII.\n-\t\t\ts.numRunes = RuneCountInString(contents)\n-\t\t\t_, s.width = DecodeRuneInString(contents)\n+\t\t\ts.numRunes = utf8.RuneCountInString(contents)\n+\t\t\t_, s.width = utf8.DecodeRuneInString(contents)\n \t\t\ts.nonASCII = i\n \t\t\treturn s\n \t\t}\n@@ -121,7 +125,7 @@ func (s *String) At(i int) rune {\n \tswitch {\n \n \tcase i == s.runePos-1: // backing up one rune\n-\t\tr, s.width = DecodeLastRuneInString(s.str[0:s.bytePos])\n+\t\tr, s.width = utf8.DecodeLastRuneInString(s.str[0:s.bytePos])\n \t\ts.runePos = i\n \t\ts.bytePos -= s.width\n \t\treturn r\n@@ -130,16 +134,16 @@ func (s *String) At(i int) rune {\n \t\ts.bytePos += s.width\n \t\tfallthrough\n \tcase i == s.runePos:\n-\t\tr, s.width = DecodeRuneInString(s.str[s.bytePos:])\n+\t\tr, s.width = utf8.DecodeRuneInString(s.str[s.bytePos:])\n \t\treturn r\n \tcase i == 0: // start of string\n-\t\tr, s.width = DecodeRuneInString(s.str)\n+\t\tr, s.width = utf8.DecodeRuneInString(s.str)\n \t\ts.runePos = 0\n \t\ts.bytePos = 0\n \t\treturn r\n \n \tcase i == s.numRunes-1: // last rune in string\n-\t\tr, s.width = DecodeLastRuneInString(s.str)\n+\t\tr, s.width = utf8.DecodeLastRuneInString(s.str)\n \t\ts.runePos = i\n \t\ts.bytePos = len(s.str) - s.width\n \t\treturn r\n@@ -175,7 +179,7 @@ func (s *String) At(i int) rune {\n \tif forward {\n \t\t// TODO: Is it much faster to use a range loop for this scan?\n \t\tfor {\n-\t\t\tr, s.width = DecodeRuneInString(s.str[s.bytePos:])\n+\t\t\tr, s.width = utf8.DecodeRuneInString(s.str[s.bytePos:])\n \t\t\tif s.runePos == i {\n \t\t\t\tbreak\n \t\t\t}\n@@ -184,7 +188,7 @@ func (s *String) At(i int) rune {\n \t\t}\n \t} else {\n \t\tfor {\n-\t\t\tr, s.width = DecodeLastRuneInString(s.str[0:s.bytePos])\n+\t\t\tr, s.width = utf8.DecodeLastRuneInString(s.str[0:s.bytePos])\n \t\t\ts.runePos--\n \t\t\ts.bytePos -= s.width\n \t\t\tif s.runePos == i {", "previous_filename": "libgo/go/unicode/utf8/string.go"}, {"sha": "28511b2f5f159274bce88245387f6f317be27ff1", "filename": "libgo/go/exp/utf8string/string_test.go", "status": "renamed", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Futf8string%2Fstring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fexp%2Futf8string%2Fstring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Futf8string%2Fstring_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -2,14 +2,23 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package utf8_test\n+package utf8string\n \n import (\n \t\"math/rand\"\n \t\"testing\"\n-\t. \"unicode/utf8\"\n+\t\"unicode/utf8\"\n )\n \n+var testStrings = []string{\n+\t\"\",\n+\t\"abcd\",\n+\t\"\u263a\u263b\u2639\",\n+\t\"\u65e5a\u672cb\u8a9e\u00e7\u65e5\u00f0\u672c\u00ca\u8a9e\u00fe\u65e5\u00a5\u672c\u00bc\u8a9ei\u65e5\u00a9\",\n+\t\"\u65e5a\u672cb\u8a9e\u00e7\u65e5\u00f0\u672c\u00ca\u8a9e\u00fe\u65e5\u00a5\u672c\u00bc\u8a9ei\u65e5\u00a9\u65e5a\u672cb\u8a9e\u00e7\u65e5\u00f0\u672c\u00ca\u8a9e\u00fe\u65e5\u00a5\u672c\u00bc\u8a9ei\u65e5\u00a9\u65e5a\u672cb\u8a9e\u00e7\u65e5\u00f0\u672c\u00ca\u8a9e\u00fe\u65e5\u00a5\u672c\u00bc\u8a9ei\u65e5\u00a9\",\n+\t\"\\x80\\x80\\x80\\x80\",\n+}\n+\n func TestScanForwards(t *testing.T) {\n \tfor _, s := range testStrings {\n \t\trunes := []rune(s)\n@@ -106,7 +115,7 @@ func TestLimitSliceAccess(t *testing.T) {\n \t\tif str.Slice(0, 0) != \"\" {\n \t\t\tt.Error(\"failure with empty slice at beginning\")\n \t\t}\n-\t\tnr := RuneCountInString(s)\n+\t\tnr := utf8.RuneCountInString(s)\n \t\tif str.Slice(nr, nr) != \"\" {\n \t\t\tt.Error(\"failure with empty slice at end\")\n \t\t}", "previous_filename": "libgo/go/unicode/utf8/string_test.go"}, {"sha": "504194ce467aeebd114b040c2f144d32cd308a9c", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -508,27 +508,28 @@ func BenchmarkSprintfFloat(b *testing.B) {\n \n var mallocBuf bytes.Buffer\n \n+// gccgo numbers are different because gccgo does not have escape\n+// analysis yet.\n var mallocTest = []struct {\n \tcount int\n \tdesc  string\n \tfn    func()\n }{\n-\t{0, `Sprintf(\"\")`, func() { Sprintf(\"\") }},\n-\t{1, `Sprintf(\"xxx\")`, func() { Sprintf(\"xxx\") }},\n-\t{1, `Sprintf(\"%x\")`, func() { Sprintf(\"%x\", 7) }},\n-\t{2, `Sprintf(\"%s\")`, func() { Sprintf(\"%s\", \"hello\") }},\n-\t{1, `Sprintf(\"%x %x\")`, func() { Sprintf(\"%x %x\", 7, 112) }},\n-\t{1, `Sprintf(\"%g\")`, func() { Sprintf(\"%g\", 3.14159) }},\n-\t{0, `Fprintf(buf, \"%x %x %x\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%x %x %x\", 7, 8, 9) }},\n-\t{1, `Fprintf(buf, \"%s\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%s\", \"hello\") }},\n+\t{5, `Sprintf(\"\")`, func() { Sprintf(\"\") }},\n+\t{5, `Sprintf(\"xxx\")`, func() { Sprintf(\"xxx\") }},\n+\t{5, `Sprintf(\"%x\")`, func() { Sprintf(\"%x\", 7) }},\n+\t{5, `Sprintf(\"%s\")`, func() { Sprintf(\"%s\", \"hello\") }},\n+\t{5, `Sprintf(\"%x %x\")`, func() { Sprintf(\"%x %x\", 7, 112) }},\n+\t// For %g we use a float32, not float64, to guarantee passing the argument\n+\t// does not need to allocate memory to store the result in a pointer-sized word.\n+\t{20, `Sprintf(\"%g\")`, func() { Sprintf(\"%g\", float32(3.14159)) }},\n+\t{5, `Fprintf(buf, \"%x %x %x\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%x %x %x\", 7, 8, 9) }},\n+\t{5, `Fprintf(buf, \"%s\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%s\", \"hello\") }},\n }\n \n var _ bytes.Buffer\n \n func TestCountMallocs(t *testing.T) {\n-\tif testing.Short() {\n-\t\treturn\n-\t}\n \tfor _, mt := range mallocTest {\n \t\tconst N = 100\n \t\truntime.UpdateMemStats()\n@@ -538,7 +539,7 @@ func TestCountMallocs(t *testing.T) {\n \t\t}\n \t\truntime.UpdateMemStats()\n \t\tmallocs += runtime.MemStats.Mallocs\n-\t\tif mallocs/N != uint64(mt.count) {\n+\t\tif mallocs/N > uint64(mt.count) {\n \t\t\tt.Errorf(\"%s: expected %d mallocs, got %d\", mt.desc, mt.count, mallocs/N)\n \t\t}\n \t}"}, {"sha": "b86f8288ea6d9527a6b59688d8d12e06821f4dd5", "filename": "libgo/go/go/build/path.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -105,14 +105,14 @@ func FindTree(path string) (tree *Tree, pkg string, err error) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\ttree = t\n-\t\t\tpkg = path[len(tpath):]\n+\t\t\tpkg = filepath.ToSlash(path[len(tpath):])\n \t\t\treturn\n \t\t}\n \t\terr = fmt.Errorf(\"path %q not inside a GOPATH\", path)\n \t\treturn\n \t}\n \ttree = defaultTree\n-\tpkg = path\n+\tpkg = filepath.ToSlash(path)\n \tfor _, t := range Path {\n \t\tif t.HasSrc(pkg) {\n \t\t\ttree = t"}, {"sha": "ee9fd5de68862c3ed01883d9a1bd8b9a4e5c9b4b", "filename": "libgo/go/go/build/pkgtest/sqrt_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package pkgtest\n \n import \"fmt\""}, {"sha": "3898d1dda590fb318e775bc2b39aeeb4487ba47b", "filename": "libgo/go/go/build/pkgtest/xsqrt_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package pkgtest_test\n \n import \"pkgtest\""}, {"sha": "d73b1315954bc7d5820b72d6cf368eb3bb9c0736", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -68,7 +68,8 @@ var (\n \thtml_endp   = []byte(\"</p>\\n\")\n \thtml_pre    = []byte(\"<pre>\")\n \thtml_endpre = []byte(\"</pre>\\n\")\n-\thtml_h      = []byte(\"<h3>\")\n+\thtml_h      = []byte(`<h3 id=\"`)\n+\thtml_hq     = []byte(`\">`)\n \thtml_endh   = []byte(\"</h3>\\n\")\n )\n \n@@ -225,6 +226,12 @@ type block struct {\n \tlines []string\n }\n \n+var nonAlphaNumRx = regexp.MustCompile(`[^a-zA-Z0-9]`)\n+\n+func anchorID(line string) string {\n+\treturn nonAlphaNumRx.ReplaceAllString(line, \"_\")\n+}\n+\n // ToHTML converts comment text to formatted HTML.\n // The comment was prepared by DocReader,\n // so it is known not to have leading, trailing blank lines\n@@ -253,9 +260,18 @@ func ToHTML(w io.Writer, text string, words map[string]string) {\n \t\t\tw.Write(html_endp)\n \t\tcase opHead:\n \t\t\tw.Write(html_h)\n+\t\t\tid := \"\"\n \t\t\tfor _, line := range b.lines {\n+\t\t\t\tif id == \"\" {\n+\t\t\t\t\tid = anchorID(line)\n+\t\t\t\t\tw.Write([]byte(id))\n+\t\t\t\t\tw.Write(html_hq)\n+\t\t\t\t}\n \t\t\t\tcommentEscape(w, line, true)\n \t\t\t}\n+\t\t\tif id == \"\" {\n+\t\t\t\tw.Write(html_hq)\n+\t\t\t}\n \t\t\tw.Write(html_endh)\n \t\tcase opPre:\n \t\t\tw.Write(html_pre)"}, {"sha": "0259a6fec9c5929c9eb07e4702175e76ba8867e2", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -15,7 +15,7 @@ type Package struct {\n \tDoc        string\n \tName       string\n \tImportPath string\n-\tImports    []string // TODO(gri) this field is not computed at the moment\n+\tImports    []string\n \tFilenames  []string\n \tConsts     []*Value\n \tTypes      []*Type\n@@ -36,8 +36,8 @@ type Value struct {\n type Method struct {\n \t*Func\n \t// TODO(gri) The following fields are not set at the moment. \n-\tRecv  *Type // original receiver base type\n-\tLevel int   // embedding level; 0 means Func is not embedded\n+\tOrigin *Type // original receiver base type\n+\tLevel  int   // embedding level; 0 means Func is not embedded\n }\n \n // Type is the documentation for type declaration."}, {"sha": "0a4830148afef44c71d5f0ce91a25f41367a2397", "filename": "libgo/go/go/doc/doc_test.go", "status": "modified", "additions": 86, "deletions": 108, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -6,132 +6,110 @@ package doc\n \n import (\n \t\"bytes\"\n-\t\"fmt\"\n-\t\"go/ast\"\n+\t\"flag\"\n \t\"go/parser\"\n+\t\"go/printer\"\n \t\"go/token\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n \t\"testing\"\n \t\"text/template\"\n )\n \n-type sources map[string]string // filename -> file contents\n+var update = flag.Bool(\"update\", false, \"update golden (.out) files\")\n \n-type testCase struct {\n-\tname       string\n-\timportPath string\n-\tmode       Mode\n-\tsrcs       sources\n-\tdoc        string\n+const dataDir = \"testdata\"\n+\n+var templateTxt = readTemplate(\"template.txt\")\n+\n+func readTemplate(filename string) *template.Template {\n+\tt := template.New(filename)\n+\tt.Funcs(template.FuncMap{\n+\t\t\"node\":     nodeFmt,\n+\t\t\"synopsis\": synopsisFmt,\n+\t})\n+\treturn template.Must(t.ParseFiles(filepath.Join(dataDir, filename)))\n }\n \n-var tests = make(map[string]*testCase)\n-\n-// To register a new test case, use the pattern:\n-//\n-//\tvar _ = register(&testCase{ ... })\n-//\n-// (The result value of register is always 0 and only present to enable the pattern.)\n-//\n-func register(test *testCase) int {\n-\tif _, found := tests[test.name]; found {\n-\t\tpanic(fmt.Sprintf(\"registration failed: test case %q already exists\", test.name))\n-\t}\n-\ttests[test.name] = test\n-\treturn 0\n+func nodeFmt(node interface{}, fset *token.FileSet) string {\n+\tvar buf bytes.Buffer\n+\tprinter.Fprint(&buf, fset, node)\n+\treturn strings.Replace(strings.TrimSpace(buf.String()), \"\\n\", \"\\n\\t\", -1)\n }\n \n-func runTest(t *testing.T, test *testCase) {\n-\t// create AST\n-\tfset := token.NewFileSet()\n-\tvar pkg ast.Package\n-\tpkg.Files = make(map[string]*ast.File)\n-\tfor filename, src := range test.srcs {\n-\t\tfile, err := parser.ParseFile(fset, filename, src, parser.ParseComments)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test %s: %v\", test.name, err)\n-\t\t\treturn\n-\t\t}\n-\t\tswitch {\n-\t\tcase pkg.Name == \"\":\n-\t\t\tpkg.Name = file.Name.Name\n-\t\tcase pkg.Name != file.Name.Name:\n-\t\t\tt.Errorf(\"test %s: different package names in test files\", test.name)\n-\t\t\treturn\n+func synopsisFmt(s string) string {\n+\tconst n = 64\n+\tif len(s) > n {\n+\t\t// cut off excess text and go back to a word boundary\n+\t\ts = s[0:n]\n+\t\tif i := strings.LastIndexAny(s, \"\\t\\n \"); i >= 0 {\n+\t\t\ts = s[0:i]\n \t\t}\n-\t\tpkg.Files[filename] = file\n+\t\ts = strings.TrimSpace(s) + \" ...\"\n \t}\n+\treturn \"// \" + strings.Replace(s, \"\\n\", \" \", -1)\n+}\n \n-\tdoc := New(&pkg, test.importPath, test.mode).String()\n-\tif doc != test.doc {\n-\t\t//TODO(gri) Enable this once the sorting issue of comments is fixed\n-\t\t//t.Errorf(\"test %s\\n\\tgot : %s\\n\\twant: %s\", test.name, doc, test.doc)\n-\t}\n+func isGoFile(fi os.FileInfo) bool {\n+\tname := fi.Name()\n+\treturn !fi.IsDir() &&\n+\t\tlen(name) > 0 && name[0] != '.' && // ignore .files\n+\t\tfilepath.Ext(name) == \".go\"\n+}\n+\n+type bundle struct {\n+\t*Package\n+\tFSet *token.FileSet\n }\n \n func Test(t *testing.T) {\n-\tfor _, test := range tests {\n-\t\trunTest(t, test)\n+\t// get all packages\n+\tfset := token.NewFileSet()\n+\tpkgs, err := parser.ParseDir(fset, dataDir, isGoFile, parser.ParseComments)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n \t}\n-}\n \n-// ----------------------------------------------------------------------------\n-// Printing support\n+\t// test all packages\n+\tfor _, pkg := range pkgs {\n+\t\timportpath := dataDir + \"/\" + pkg.Name\n+\t\tdoc := New(pkg, importpath, 0)\n \n-func (pkg *Package) String() string {\n-\tvar buf bytes.Buffer\n-\tdocText.Execute(&buf, pkg) // ignore error - test will fail w/ incorrect output\n-\treturn buf.String()\n-}\n+\t\t// golden files always use / in filenames - canonicalize them\n+\t\tfor i, filename := range doc.Filenames {\n+\t\t\tdoc.Filenames[i] = filepath.ToSlash(filename)\n+\t\t}\n+\n+\t\t// print documentation\n+\t\tvar buf bytes.Buffer\n+\t\tif err := templateTxt.Execute(&buf, bundle{doc, fset}); err != nil {\n+\t\t\tt.Error(err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tgot := buf.Bytes()\n+\n+\t\t// update golden file if necessary\n+\t\tgolden := filepath.Join(dataDir, pkg.Name+\".out\")\n+\t\tif *update {\n+\t\t\terr := ioutil.WriteFile(golden, got, 0644)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n \n-// TODO(gri) complete template\n-var docText = template.Must(template.New(\"docText\").Parse(\n-\t`\n-PACKAGE {{.Name}}\n-DOC {{printf \"%q\" .Doc}}\n-IMPORTPATH {{.ImportPath}}\n-FILENAMES {{.Filenames}}\n-`))\n-\n-// ----------------------------------------------------------------------------\n-// Test cases\n-\n-// Test that all package comments and bugs are collected,\n-// and that the importPath is correctly set.\n-//\n-var _ = register(&testCase{\n-\tname:       \"p\",\n-\timportPath: \"p\",\n-\tsrcs: sources{\n-\t\t\"p1.go\": \"// comment 1\\npackage p\\n//BUG(uid): bug1\",\n-\t\t\"p0.go\": \"// comment 0\\npackage p\\n// BUG(uid): bug0\",\n-\t},\n-\tdoc: `\n-PACKAGE p\n-DOC \"comment 0\\n\\ncomment 1\\n\"\n-IMPORTPATH p\n-FILENAMES [p0.go p1.go]\n-`,\n-})\n-\n-// Test basic functionality.\n-//\n-var _ = register(&testCase{\n-\tname:       \"p1\",\n-\timportPath: \"p\",\n-\tsrcs: sources{\n-\t\t\"p.go\": `\n-package p\n-import \"a\"\n-const pi = 3.14       // pi\n-type T struct{}       // T\n-var V T               // v\n-func F(x int) int {}  // F\n-`,\n-\t},\n-\tdoc: `\n-PACKAGE p\n-DOC \"\"\n-IMPORTPATH p\n-FILENAMES [p.go]\n-`,\n-})\n+\t\t// get golden file\n+\t\twant, err := ioutil.ReadFile(golden)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// compare\n+\t\tif bytes.Compare(got, want) != 0 {\n+\t\t\tt.Errorf(\"package %s\\n\\tgot:\\n%s\\n\\twant:\\n%s\", pkg.Name, got, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "a35b3e2391497aed5ccfba50b17a496acb512270", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -124,6 +124,9 @@ func (doc *docReader) filterType(tinfo *typeInfo, typ ast.Expr) bool {\n \n func (doc *docReader) filterSpec(spec ast.Spec) bool {\n \tswitch s := spec.(type) {\n+\tcase *ast.ImportSpec:\n+\t\t// always keep imports so we can collect them\n+\t\treturn true\n \tcase *ast.ValueSpec:\n \t\ts.Names = filterIdentList(s.Names)\n \t\tif len(s.Names) > 0 {"}, {"sha": "1a2fad559a63cf29e276a85d5e2eb4d6ed38d1a6", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"go/token\"\n \t\"regexp\"\n \t\"sort\"\n+\t\"strconv\"\n )\n \n // ----------------------------------------------------------------------------\n@@ -55,6 +56,7 @@ type docReader struct {\n \tdoc      *ast.CommentGroup // package documentation, if any\n \tpkgName  string\n \tmode     Mode\n+\timports  map[string]int\n \tvalues   []*ast.GenDecl // consts and vars\n \ttypes    map[string]*typeInfo\n \tembedded map[string]*typeInfo // embedded types, possibly not exported\n@@ -65,6 +67,7 @@ type docReader struct {\n func (doc *docReader) init(pkgName string, mode Mode) {\n \tdoc.pkgName = pkgName\n \tdoc.mode = mode\n+\tdoc.imports = make(map[string]int)\n \tdoc.types = make(map[string]*typeInfo)\n \tdoc.embedded = make(map[string]*typeInfo)\n \tdoc.funcs = make(map[string]*ast.FuncDecl)\n@@ -244,6 +247,13 @@ func (doc *docReader) addDecl(decl ast.Decl) {\n \tcase *ast.GenDecl:\n \t\tif len(d.Specs) > 0 {\n \t\t\tswitch d.Tok {\n+\t\t\tcase token.IMPORT:\n+\t\t\t\t// imports are handled individually\n+\t\t\t\tfor _, spec := range d.Specs {\n+\t\t\t\t\tif import_, err := strconv.Unquote(spec.(*ast.ImportSpec).Path.Value); err == nil {\n+\t\t\t\t\t\tdoc.imports[import_] = 1\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\tcase token.CONST, token.VAR:\n \t\t\t\t// constants and variables are always handled as a group\n \t\t\t\tdoc.addValue(d)\n@@ -346,6 +356,17 @@ func (doc *docReader) addFile(src *ast.File) {\n // ----------------------------------------------------------------------------\n // Conversion to external representation\n \n+func (doc *docReader) makeImports() []string {\n+\tlist := make([]string, len(doc.imports))\n+\ti := 0\n+\tfor import_ := range doc.imports {\n+\t\tlist[i] = import_\n+\t\ti++\n+\t}\n+\tsort.Strings(list)\n+\treturn list\n+}\n+\n type sortValue []*Value\n \n func (p sortValue) Len() int      { return len(p) }\n@@ -661,6 +682,7 @@ func (doc *docReader) newDoc(importpath string, filenames []string) *Package {\n \t// doc.funcs and thus must be called before any other\n \t// function consuming those lists\n \tp.Types = doc.makeTypes(doc.types)\n+\tp.Imports = doc.makeImports()\n \tp.Consts = makeValues(doc.values, token.CONST)\n \tp.Vars = makeValues(doc.values, token.VAR)\n \tp.Funcs = makeFuncs(doc.funcs)"}, {"sha": "24db02d348f5cc81cdabfb978d126d185d74a710", "filename": "libgo/go/go/doc/testdata/a.out", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.out?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,13 @@\n+// comment 0  comment 1 \n+PACKAGE a\n+\n+IMPORTPATH\n+\ttestdata/a\n+\n+FILENAMES\n+\ttestdata/a0.go\n+\ttestdata/a1.go\n+\n+BUGS\n+\t// bug0 \n+\t// bug1 "}, {"sha": "dc552989ec26ce6d11f76d1cd47ce7e542bed1c0", "filename": "libgo/go/go/doc/testdata/a0.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa0.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// comment 0\n+package a\n+\n+//BUG(uid): bug0"}, {"sha": "098776c1b0e43a590614ef2624314227aa841ec4", "filename": "libgo/go/go/doc/testdata/a1.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa1.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// comment 1\n+package a\n+\n+//BUG(uid): bug1"}, {"sha": "cdc77ef784c6ee68fb747a7938c2ab42df0705f5", "filename": "libgo/go/go/doc/testdata/b.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package b\n+\n+import \"a\"\n+\n+const Pi = 3.14   // Pi\n+var MaxInt int    // MaxInt\n+type T struct{}   // T\n+var V T           // v\n+func F(x int) int {} // F"}, {"sha": "c5ad0d0fc83e71565cef62f0c0489734486c363b", "filename": "libgo/go/go/doc/testdata/b.out", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.out?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,34 @@\n+// \n+PACKAGE b\n+\n+IMPORTPATH\n+\ttestdata/b\n+\n+IMPORTS\n+\ta\n+\n+FILENAMES\n+\ttestdata/b.go\n+\n+CONSTANTS\n+\t// \n+\tconst Pi = 3.14\t// Pi\n+\n+\n+VARIABLES\n+\t// \n+\tvar MaxInt int\t// MaxInt\n+\n+\n+FUNCTIONS\n+\t// \n+\tfunc F(x int) int\n+\n+\n+TYPES\n+\t// \n+\ttype T struct{}\t// T\n+\n+\t// \n+\tvar V T\t// v\n+"}, {"sha": "0bf567b7c4d898fa6e159a15e1c198a6a7a12e64", "filename": "libgo/go/go/doc/testdata/benchmark.go", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,293 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package testing\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"time\"\n+)\n+\n+var matchBenchmarks = flag.String(\"test.bench\", \"\", \"regular expression to select benchmarks to run\")\n+var benchTime = flag.Float64(\"test.benchtime\", 1, \"approximate run time for each benchmark, in seconds\")\n+\n+// An internal type but exported because it is cross-package; part of the implementation\n+// of gotest.\n+type InternalBenchmark struct {\n+\tName string\n+\tF    func(b *B)\n+}\n+\n+// B is a type passed to Benchmark functions to manage benchmark\n+// timing and to specify the number of iterations to run.\n+type B struct {\n+\tcommon\n+\tN         int\n+\tbenchmark InternalBenchmark\n+\tbytes     int64\n+\ttimerOn   bool\n+\tresult    BenchmarkResult\n+}\n+\n+// StartTimer starts timing a test.  This function is called automatically\n+// before a benchmark starts, but it can also used to resume timing after\n+// a call to StopTimer.\n+func (b *B) StartTimer() {\n+\tif !b.timerOn {\n+\t\tb.start = time.Now()\n+\t\tb.timerOn = true\n+\t}\n+}\n+\n+// StopTimer stops timing a test.  This can be used to pause the timer\n+// while performing complex initialization that you don't\n+// want to measure.\n+func (b *B) StopTimer() {\n+\tif b.timerOn {\n+\t\tb.duration += time.Now().Sub(b.start)\n+\t\tb.timerOn = false\n+\t}\n+}\n+\n+// ResetTimer sets the elapsed benchmark time to zero.\n+// It does not affect whether the timer is running.\n+func (b *B) ResetTimer() {\n+\tif b.timerOn {\n+\t\tb.start = time.Now()\n+\t}\n+\tb.duration = 0\n+}\n+\n+// SetBytes records the number of bytes processed in a single operation.\n+// If this is called, the benchmark will report ns/op and MB/s.\n+func (b *B) SetBytes(n int64) { b.bytes = n }\n+\n+func (b *B) nsPerOp() int64 {\n+\tif b.N <= 0 {\n+\t\treturn 0\n+\t}\n+\treturn b.duration.Nanoseconds() / int64(b.N)\n+}\n+\n+// runN runs a single benchmark for the specified number of iterations.\n+func (b *B) runN(n int) {\n+\t// Try to get a comparable environment for each run\n+\t// by clearing garbage from previous runs.\n+\truntime.GC()\n+\tb.N = n\n+\tb.ResetTimer()\n+\tb.StartTimer()\n+\tb.benchmark.F(b)\n+\tb.StopTimer()\n+}\n+\n+func min(x, y int) int {\n+\tif x > y {\n+\t\treturn y\n+\t}\n+\treturn x\n+}\n+\n+func max(x, y int) int {\n+\tif x < y {\n+\t\treturn y\n+\t}\n+\treturn x\n+}\n+\n+// roundDown10 rounds a number down to the nearest power of 10.\n+func roundDown10(n int) int {\n+\tvar tens = 0\n+\t// tens = floor(log_10(n))\n+\tfor n > 10 {\n+\t\tn = n / 10\n+\t\ttens++\n+\t}\n+\t// result = 10^tens\n+\tresult := 1\n+\tfor i := 0; i < tens; i++ {\n+\t\tresult *= 10\n+\t}\n+\treturn result\n+}\n+\n+// roundUp rounds x up to a number of the form [1eX, 2eX, 5eX].\n+func roundUp(n int) int {\n+\tbase := roundDown10(n)\n+\tif n < (2 * base) {\n+\t\treturn 2 * base\n+\t}\n+\tif n < (5 * base) {\n+\t\treturn 5 * base\n+\t}\n+\treturn 10 * base\n+}\n+\n+// run times the benchmark function in a separate goroutine.\n+func (b *B) run() BenchmarkResult {\n+\tgo b.launch()\n+\t<-b.signal\n+\treturn b.result\n+}\n+\n+// launch launches the benchmark function.  It gradually increases the number\n+// of benchmark iterations until the benchmark runs for a second in order\n+// to get a reasonable measurement.  It prints timing information in this form\n+//\t\ttesting.BenchmarkHello\t100000\t\t19 ns/op\n+// launch is run by the fun function as a separate goroutine.\n+func (b *B) launch() {\n+\t// Run the benchmark for a single iteration in case it's expensive.\n+\tn := 1\n+\n+\t// Signal that we're done whether we return normally\n+\t// or by FailNow's runtime.Goexit.\n+\tdefer func() {\n+\t\tb.signal <- b\n+\t}()\n+\n+\tb.runN(n)\n+\t// Run the benchmark for at least the specified amount of time.\n+\td := time.Duration(*benchTime * float64(time.Second))\n+\tfor !b.failed && b.duration < d && n < 1e9 {\n+\t\tlast := n\n+\t\t// Predict iterations/sec.\n+\t\tif b.nsPerOp() == 0 {\n+\t\t\tn = 1e9\n+\t\t} else {\n+\t\t\tn = int(d.Nanoseconds() / b.nsPerOp())\n+\t\t}\n+\t\t// Run more iterations than we think we'll need for a second (1.5x).\n+\t\t// Don't grow too fast in case we had timing errors previously.\n+\t\t// Be sure to run at least one more than last time.\n+\t\tn = max(min(n+n/2, 100*last), last+1)\n+\t\t// Round up to something easy to read.\n+\t\tn = roundUp(n)\n+\t\tb.runN(n)\n+\t}\n+\tb.result = BenchmarkResult{b.N, b.duration, b.bytes}\n+}\n+\n+// The results of a benchmark run.\n+type BenchmarkResult struct {\n+\tN     int           // The number of iterations.\n+\tT     time.Duration // The total time taken.\n+\tBytes int64         // Bytes processed in one iteration.\n+}\n+\n+func (r BenchmarkResult) NsPerOp() int64 {\n+\tif r.N <= 0 {\n+\t\treturn 0\n+\t}\n+\treturn r.T.Nanoseconds() / int64(r.N)\n+}\n+\n+func (r BenchmarkResult) mbPerSec() float64 {\n+\tif r.Bytes <= 0 || r.T <= 0 || r.N <= 0 {\n+\t\treturn 0\n+\t}\n+\treturn (float64(r.Bytes) * float64(r.N) / 1e6) / r.T.Seconds()\n+}\n+\n+func (r BenchmarkResult) String() string {\n+\tmbs := r.mbPerSec()\n+\tmb := \"\"\n+\tif mbs != 0 {\n+\t\tmb = fmt.Sprintf(\"\\t%7.2f MB/s\", mbs)\n+\t}\n+\tnsop := r.NsPerOp()\n+\tns := fmt.Sprintf(\"%10d ns/op\", nsop)\n+\tif r.N > 0 && nsop < 100 {\n+\t\t// The format specifiers here make sure that\n+\t\t// the ones digits line up for all three possible formats.\n+\t\tif nsop < 10 {\n+\t\t\tns = fmt.Sprintf(\"%13.2f ns/op\", float64(r.T.Nanoseconds())/float64(r.N))\n+\t\t} else {\n+\t\t\tns = fmt.Sprintf(\"%12.1f ns/op\", float64(r.T.Nanoseconds())/float64(r.N))\n+\t\t}\n+\t}\n+\treturn fmt.Sprintf(\"%8d\\t%s%s\", r.N, ns, mb)\n+}\n+\n+// An internal function but exported because it is cross-package; part of the implementation\n+// of gotest.\n+func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) {\n+\t// If no flag was specified, don't run benchmarks.\n+\tif len(*matchBenchmarks) == 0 {\n+\t\treturn\n+\t}\n+\tfor _, Benchmark := range benchmarks {\n+\t\tmatched, err := matchString(*matchBenchmarks, Benchmark.Name)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: invalid regexp for -test.bench: %s\\n\", err)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tif !matched {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, procs := range cpuList {\n+\t\t\truntime.GOMAXPROCS(procs)\n+\t\t\tb := &B{\n+\t\t\t\tcommon: common{\n+\t\t\t\t\tsignal: make(chan interface{}),\n+\t\t\t\t},\n+\t\t\t\tbenchmark: Benchmark,\n+\t\t\t}\n+\t\t\tbenchName := Benchmark.Name\n+\t\t\tif procs != 1 {\n+\t\t\t\tbenchName = fmt.Sprintf(\"%s-%d\", Benchmark.Name, procs)\n+\t\t\t}\n+\t\t\tfmt.Printf(\"%s\\t\", benchName)\n+\t\t\tr := b.run()\n+\t\t\tif b.failed {\n+\t\t\t\t// The output could be very long here, but probably isn't.\n+\t\t\t\t// We print it all, regardless, because we don't want to trim the reason\n+\t\t\t\t// the benchmark failed.\n+\t\t\t\tfmt.Printf(\"--- FAIL: %s\\n%s\", benchName, b.output)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfmt.Printf(\"%v\\n\", r)\n+\t\t\t// Unlike with tests, we ignore the -chatty flag and always print output for\n+\t\t\t// benchmarks since the output generation time will skew the results.\n+\t\t\tif len(b.output) > 0 {\n+\t\t\t\tb.trimOutput()\n+\t\t\t\tfmt.Printf(\"--- BENCH: %s\\n%s\", benchName, b.output)\n+\t\t\t}\n+\t\t\tif p := runtime.GOMAXPROCS(-1); p != procs {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s left GOMAXPROCS set to %d\\n\", benchName, p)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// trimOutput shortens the output from a benchmark, which can be very long.\n+func (b *B) trimOutput() {\n+\t// The output is likely to appear multiple times because the benchmark\n+\t// is run multiple times, but at least it will be seen. This is not a big deal\n+\t// because benchmarks rarely print, but just in case, we trim it if it's too long.\n+\tconst maxNewlines = 10\n+\tfor nlCount, j := 0, 0; j < len(b.output); j++ {\n+\t\tif b.output[j] == '\\n' {\n+\t\t\tnlCount++\n+\t\t\tif nlCount >= maxNewlines {\n+\t\t\t\tb.output = append(b.output[:j], \"\\n\\t... [output truncated]\\n\"...)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// Benchmark benchmarks a single function. Useful for creating\n+// custom benchmarks that do not use gotest.\n+func Benchmark(f func(b *B)) BenchmarkResult {\n+\tb := &B{\n+\t\tcommon: common{\n+\t\t\tsignal: make(chan interface{}),\n+\t\t},\n+\t\tbenchmark: InternalBenchmark{\"\", f},\n+\t}\n+\treturn b.run()\n+}"}, {"sha": "fdeda137e7614facde2b4a4ade14e67970610ade", "filename": "libgo/go/go/doc/testdata/example.go", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fexample.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package testing\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type InternalExample struct {\n+\tName   string\n+\tF      func()\n+\tOutput string\n+}\n+\n+func RunExamples(examples []InternalExample) (ok bool) {\n+\tok = true\n+\n+\tvar eg InternalExample\n+\n+\tstdout, stderr := os.Stdout, os.Stderr\n+\tdefer func() {\n+\t\tos.Stdout, os.Stderr = stdout, stderr\n+\t\tif e := recover(); e != nil {\n+\t\t\tfmt.Printf(\"--- FAIL: %s\\npanic: %v\\n\", eg.Name, e)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}()\n+\n+\tfor _, eg = range examples {\n+\t\tif *chatty {\n+\t\t\tfmt.Printf(\"=== RUN: %s\\n\", eg.Name)\n+\t\t}\n+\n+\t\t// capture stdout and stderr\n+\t\tr, w, err := os.Pipe()\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tos.Stdout, os.Stderr = w, w\n+\t\toutC := make(chan string)\n+\t\tgo func() {\n+\t\t\tbuf := new(bytes.Buffer)\n+\t\t\t_, err := io.Copy(buf, r)\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(stderr, \"testing: copying pipe: %v\\n\", err)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\toutC <- buf.String()\n+\t\t}()\n+\n+\t\t// run example\n+\t\tt0 := time.Now()\n+\t\teg.F()\n+\t\tdt := time.Now().Sub(t0)\n+\n+\t\t// close pipe, restore stdout/stderr, get output\n+\t\tw.Close()\n+\t\tos.Stdout, os.Stderr = stdout, stderr\n+\t\tout := <-outC\n+\n+\t\t// report any errors\n+\t\ttstr := fmt.Sprintf(\"(%.2f seconds)\", dt.Seconds())\n+\t\tif g, e := strings.TrimSpace(out), strings.TrimSpace(eg.Output); g != e {\n+\t\t\tfmt.Printf(\"--- FAIL: %s %s\\ngot:\\n%s\\nwant:\\n%s\\n\",\n+\t\t\t\teg.Name, tstr, g, e)\n+\t\t\tok = false\n+\t\t} else if *chatty {\n+\t\t\tfmt.Printf(\"--- PASS: %s %s\\n\", eg.Name, tstr)\n+\t\t}\n+\t}\n+\n+\treturn\n+}"}, {"sha": "32e331cdd101e0724e4ad044cf2e271e301b0a4d", "filename": "libgo/go/go/doc/testdata/template.txt", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftemplate.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftemplate.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftemplate.txt?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,65 @@\n+{{synopsis .Doc}}\n+PACKAGE {{.Name}}\n+\n+IMPORTPATH\n+\t{{.ImportPath}}\n+\n+{{with .Imports}}IMPORTS\n+{{range .}}\t{{.}}\n+{{end}}\n+{{end}}{{/*\n+\n+*/}}FILENAMES\n+{{range .Filenames}}\t{{.}}\n+{{end}}{{/*\n+\n+*/}}{{with .Consts}}\n+CONSTANTS\n+{{range .}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{end}}{{end}}{{/*\n+\n+*/}}{{with .Vars}}\n+VARIABLES\n+{{range .}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{end}}{{end}}{{/*\n+\n+*/}}{{with .Funcs}}\n+FUNCTIONS\n+{{range .}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{end}}{{end}}{{/*\n+\n+*/}}{{with .Types}}\n+TYPES\n+{{range .}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{range .Consts}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{end}}{{/*\n+\n+*/}}{{range .Vars}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{end}}{{/*\n+\n+*/}}{{range .Funcs}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{end}}{{/*\n+\n+*/}}{{range .Methods}}\t{{synopsis .Doc}}\n+\t{{node .Decl $.FSet}}\n+\n+{{end}}{{end}}{{end}}{{/*\n+\n+*/}}{{with .Bugs}}\n+BUGS\n+{{range .}}\t{{synopsis .}}\n+{{end}}{{end}}\n\\ No newline at end of file"}, {"sha": "cfe212dc1d78ff16e7fdc03c3b2afb97111cda21", "filename": "libgo/go/go/doc/testdata/testing.go", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,404 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package testing provides support for automated testing of Go packages.\n+// It is intended to be used in concert with the ``gotest'' utility, which automates\n+// execution of any function of the form\n+//     func TestXxx(*testing.T)\n+// where Xxx can be any alphanumeric string (but the first letter must not be in\n+// [a-z]) and serves to identify the test routine.\n+// These TestXxx routines should be declared within the package they are testing.\n+//\n+// Functions of the form\n+//     func BenchmarkXxx(*testing.B)\n+// are considered benchmarks, and are executed by gotest when the -test.bench\n+// flag is provided.\n+//\n+// A sample benchmark function looks like this:\n+//     func BenchmarkHello(b *testing.B) {\n+//         for i := 0; i < b.N; i++ {\n+//             fmt.Sprintf(\"hello\")\n+//         }\n+//     }\n+// The benchmark package will vary b.N until the benchmark function lasts\n+// long enough to be timed reliably.  The output\n+//     testing.BenchmarkHello    10000000    282 ns/op\n+// means that the loop ran 10000000 times at a speed of 282 ns per loop.\n+//\n+// If a benchmark needs some expensive setup before running, the timer\n+// may be stopped:\n+//     func BenchmarkBigLen(b *testing.B) {\n+//         b.StopTimer()\n+//         big := NewBig()\n+//         b.StartTimer()\n+//         for i := 0; i < b.N; i++ {\n+//             big.Len()\n+//         }\n+//     }\n+package testing\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"runtime/pprof\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+var (\n+\t// The short flag requests that tests run more quickly, but its functionality\n+\t// is provided by test writers themselves.  The testing package is just its\n+\t// home.  The all.bash installation script sets it to make installation more\n+\t// efficient, but by default the flag is off so a plain \"gotest\" will do a\n+\t// full test of the package.\n+\tshort = flag.Bool(\"test.short\", false, \"run smaller test suite to save time\")\n+\n+\t// Report as tests are run; default is silent for success.\n+\tchatty         = flag.Bool(\"test.v\", false, \"verbose: print additional output\")\n+\tmatch          = flag.String(\"test.run\", \"\", \"regular expression to select tests to run\")\n+\tmemProfile     = flag.String(\"test.memprofile\", \"\", \"write a memory profile to the named file after execution\")\n+\tmemProfileRate = flag.Int(\"test.memprofilerate\", 0, \"if >=0, sets runtime.MemProfileRate\")\n+\tcpuProfile     = flag.String(\"test.cpuprofile\", \"\", \"write a cpu profile to the named file during execution\")\n+\ttimeout        = flag.Duration(\"test.timeout\", 0, \"if positive, sets an aggregate time limit for all tests\")\n+\tcpuListStr     = flag.String(\"test.cpu\", \"\", \"comma-separated list of number of CPUs to use for each test\")\n+\tparallel       = flag.Int(\"test.parallel\", runtime.GOMAXPROCS(0), \"maximum test parallelism\")\n+\n+\tcpuList []int\n+)\n+\n+// common holds the elements common between T and B and\n+// captures common methods such as Errorf.\n+type common struct {\n+\toutput   []byte    // Output generated by test or benchmark.\n+\tfailed   bool      // Test or benchmark has failed.\n+\tstart    time.Time // Time test or benchmark started\n+\tduration time.Duration\n+\tself     interface{}      // To be sent on signal channel when done.\n+\tsignal   chan interface{} // Output for serial tests.\n+}\n+\n+// Short reports whether the -test.short flag is set.\n+func Short() bool {\n+\treturn *short\n+}\n+\n+// decorate inserts the final newline if needed and indentation tabs for formatting.\n+// If addFileLine is true, it also prefixes the string with the file and line of the call site.\n+func decorate(s string, addFileLine bool) string {\n+\tif addFileLine {\n+\t\t_, file, line, ok := runtime.Caller(3) // decorate + log + public function.\n+\t\tif ok {\n+\t\t\t// Truncate file name at last file name separator.\n+\t\t\tif index := strings.LastIndex(file, \"/\"); index >= 0 {\n+\t\t\t\tfile = file[index+1:]\n+\t\t\t} else if index = strings.LastIndex(file, \"\\\\\"); index >= 0 {\n+\t\t\t\tfile = file[index+1:]\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfile = \"???\"\n+\t\t\tline = 1\n+\t\t}\n+\t\ts = fmt.Sprintf(\"%s:%d: %s\", file, line, s)\n+\t}\n+\ts = \"\\t\" + s // Every line is indented at least one tab.\n+\tn := len(s)\n+\tif n > 0 && s[n-1] != '\\n' {\n+\t\ts += \"\\n\"\n+\t\tn++\n+\t}\n+\tfor i := 0; i < n-1; i++ { // -1 to avoid final newline\n+\t\tif s[i] == '\\n' {\n+\t\t\t// Second and subsequent lines are indented an extra tab.\n+\t\t\treturn s[0:i+1] + \"\\t\" + decorate(s[i+1:n], false)\n+\t\t}\n+\t}\n+\treturn s\n+}\n+\n+// T is a type passed to Test functions to manage test state and support formatted test logs.\n+// Logs are accumulated during execution and dumped to standard error when done.\n+type T struct {\n+\tcommon\n+\tname          string    // Name of test.\n+\tstartParallel chan bool // Parallel tests will wait on this.\n+}\n+\n+// Fail marks the function as having failed but continues execution.\n+func (c *common) Fail() { c.failed = true }\n+\n+// Failed returns whether the function has failed.\n+func (c *common) Failed() bool { return c.failed }\n+\n+// FailNow marks the function as having failed and stops its execution.\n+// Execution will continue at the next Test.\n+func (c *common) FailNow() {\n+\tc.Fail()\n+\n+\t// Calling runtime.Goexit will exit the goroutine, which\n+\t// will run the deferred functions in this goroutine,\n+\t// which will eventually run the deferred lines in tRunner,\n+\t// which will signal to the test loop that this test is done.\n+\t//\n+\t// A previous version of this code said:\n+\t//\n+\t//\tc.duration = ...\n+\t//\tc.signal <- c.self\n+\t//\truntime.Goexit()\n+\t//\n+\t// This previous version duplicated code (those lines are in\n+\t// tRunner no matter what), but worse the goroutine teardown\n+\t// implicit in runtime.Goexit was not guaranteed to complete\n+\t// before the test exited.  If a test deferred an important cleanup\n+\t// function (like removing temporary files), there was no guarantee\n+\t// it would run on a test failure.  Because we send on c.signal during\n+\t// a top-of-stack deferred function now, we know that the send\n+\t// only happens after any other stacked defers have completed.\n+\truntime.Goexit()\n+}\n+\n+// log generates the output. It's always at the same stack depth.\n+func (c *common) log(s string) {\n+\tc.output = append(c.output, decorate(s, true)...)\n+}\n+\n+// Log formats its arguments using default formatting, analogous to Println(),\n+// and records the text in the error log.\n+func (c *common) Log(args ...interface{}) { c.log(fmt.Sprintln(args...)) }\n+\n+// Logf formats its arguments according to the format, analogous to Printf(),\n+// and records the text in the error log.\n+func (c *common) Logf(format string, args ...interface{}) { c.log(fmt.Sprintf(format, args...)) }\n+\n+// Error is equivalent to Log() followed by Fail().\n+func (c *common) Error(args ...interface{}) {\n+\tc.log(fmt.Sprintln(args...))\n+\tc.Fail()\n+}\n+\n+// Errorf is equivalent to Logf() followed by Fail().\n+func (c *common) Errorf(format string, args ...interface{}) {\n+\tc.log(fmt.Sprintf(format, args...))\n+\tc.Fail()\n+}\n+\n+// Fatal is equivalent to Log() followed by FailNow().\n+func (c *common) Fatal(args ...interface{}) {\n+\tc.log(fmt.Sprintln(args...))\n+\tc.FailNow()\n+}\n+\n+// Fatalf is equivalent to Logf() followed by FailNow().\n+func (c *common) Fatalf(format string, args ...interface{}) {\n+\tc.log(fmt.Sprintf(format, args...))\n+\tc.FailNow()\n+}\n+\n+// Parallel signals that this test is to be run in parallel with (and only with) \n+// other parallel tests in this CPU group.\n+func (t *T) Parallel() {\n+\tt.signal <- (*T)(nil) // Release main testing loop\n+\t<-t.startParallel     // Wait for serial tests to finish\n+}\n+\n+// An internal type but exported because it is cross-package; part of the implementation\n+// of gotest.\n+type InternalTest struct {\n+\tName string\n+\tF    func(*T)\n+}\n+\n+func tRunner(t *T, test *InternalTest) {\n+\tt.start = time.Now()\n+\n+\t// When this goroutine is done, either because test.F(t)\n+\t// returned normally or because a test failure triggered \n+\t// a call to runtime.Goexit, record the duration and send\n+\t// a signal saying that the test is done.\n+\tdefer func() {\n+\t\tt.duration = time.Now().Sub(t.start)\n+\t\tt.signal <- t\n+\t}()\n+\n+\ttest.F(t)\n+}\n+\n+// An internal function but exported because it is cross-package; part of the implementation\n+// of gotest.\n+func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) {\n+\tflag.Parse()\n+\tparseCpuList()\n+\n+\tbefore()\n+\tstartAlarm()\n+\ttestOk := RunTests(matchString, tests)\n+\texampleOk := RunExamples(examples)\n+\tif !testOk || !exampleOk {\n+\t\tfmt.Println(\"FAIL\")\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println(\"PASS\")\n+\tstopAlarm()\n+\tRunBenchmarks(matchString, benchmarks)\n+\tafter()\n+}\n+\n+func (t *T) report() {\n+\ttstr := fmt.Sprintf(\"(%.2f seconds)\", t.duration.Seconds())\n+\tformat := \"--- %s: %s %s\\n%s\"\n+\tif t.failed {\n+\t\tfmt.Printf(format, \"FAIL\", t.name, tstr, t.output)\n+\t} else if *chatty {\n+\t\tfmt.Printf(format, \"PASS\", t.name, tstr, t.output)\n+\t}\n+}\n+\n+func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool) {\n+\tok = true\n+\tif len(tests) == 0 {\n+\t\tfmt.Fprintln(os.Stderr, \"testing: warning: no tests to run\")\n+\t\treturn\n+\t}\n+\tfor _, procs := range cpuList {\n+\t\truntime.GOMAXPROCS(procs)\n+\t\t// We build a new channel tree for each run of the loop.\n+\t\t// collector merges in one channel all the upstream signals from parallel tests.\n+\t\t// If all tests pump to the same channel, a bug can occur where a test\n+\t\t// kicks off a goroutine that Fails, yet the test still delivers a completion signal,\n+\t\t// which skews the counting.\n+\t\tvar collector = make(chan interface{})\n+\n+\t\tnumParallel := 0\n+\t\tstartParallel := make(chan bool)\n+\n+\t\tfor i := 0; i < len(tests); i++ {\n+\t\t\tmatched, err := matchString(*match, tests[i].Name)\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testing: invalid regexp for -test.run: %s\\n\", err)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tif !matched {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ttestName := tests[i].Name\n+\t\t\tif procs != 1 {\n+\t\t\t\ttestName = fmt.Sprintf(\"%s-%d\", tests[i].Name, procs)\n+\t\t\t}\n+\t\t\tt := &T{\n+\t\t\t\tcommon: common{\n+\t\t\t\t\tsignal: make(chan interface{}),\n+\t\t\t\t},\n+\t\t\t\tname:          testName,\n+\t\t\t\tstartParallel: startParallel,\n+\t\t\t}\n+\t\t\tt.self = t\n+\t\t\tif *chatty {\n+\t\t\t\tfmt.Printf(\"=== RUN %s\\n\", t.name)\n+\t\t\t}\n+\t\t\tgo tRunner(t, &tests[i])\n+\t\t\tout := (<-t.signal).(*T)\n+\t\t\tif out == nil { // Parallel run.\n+\t\t\t\tgo func() {\n+\t\t\t\t\tcollector <- <-t.signal\n+\t\t\t\t}()\n+\t\t\t\tnumParallel++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tt.report()\n+\t\t\tok = ok && !out.failed\n+\t\t}\n+\n+\t\trunning := 0\n+\t\tfor numParallel+running > 0 {\n+\t\t\tif running < *parallel && numParallel > 0 {\n+\t\t\t\tstartParallel <- true\n+\t\t\t\trunning++\n+\t\t\t\tnumParallel--\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tt := (<-collector).(*T)\n+\t\t\tt.report()\n+\t\t\tok = ok && !t.failed\n+\t\t\trunning--\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// before runs before all testing.\n+func before() {\n+\tif *memProfileRate > 0 {\n+\t\truntime.MemProfileRate = *memProfileRate\n+\t}\n+\tif *cpuProfile != \"\" {\n+\t\tf, err := os.Create(*cpuProfile)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif err := pprof.StartCPUProfile(f); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: can't start cpu profile: %s\", err)\n+\t\t\tf.Close()\n+\t\t\treturn\n+\t\t}\n+\t\t// Could save f so after can call f.Close; not worth the effort.\n+\t}\n+\n+}\n+\n+// after runs after all testing.\n+func after() {\n+\tif *cpuProfile != \"\" {\n+\t\tpprof.StopCPUProfile() // flushes profile to disk\n+\t}\n+\tif *memProfile != \"\" {\n+\t\tf, err := os.Create(*memProfile)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif err = pprof.WriteHeapProfile(f); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: can't write %s: %s\", *memProfile, err)\n+\t\t}\n+\t\tf.Close()\n+\t}\n+}\n+\n+var timer *time.Timer\n+\n+// startAlarm starts an alarm if requested.\n+func startAlarm() {\n+\tif *timeout > 0 {\n+\t\ttimer = time.AfterFunc(*timeout, alarm)\n+\t}\n+}\n+\n+// stopAlarm turns off the alarm.\n+func stopAlarm() {\n+\tif *timeout > 0 {\n+\t\ttimer.Stop()\n+\t}\n+}\n+\n+// alarm is called if the timeout expires.\n+func alarm() {\n+\tpanic(\"test timed out\")\n+}\n+\n+func parseCpuList() {\n+\tif len(*cpuListStr) == 0 {\n+\t\tcpuList = append(cpuList, runtime.GOMAXPROCS(-1))\n+\t} else {\n+\t\tfor _, val := range strings.Split(*cpuListStr, \",\") {\n+\t\t\tcpu, err := strconv.Atoi(val)\n+\t\t\tif err != nil || cpu <= 0 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testing: invalid value %q for -test.cpu\", val)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tcpuList = append(cpuList, cpu)\n+\t\t}\n+\t}\n+}"}, {"sha": "15a90398664c504dab7ecfa89c143e8cc2516ac1", "filename": "libgo/go/go/doc/testdata/testing.out", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.out?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,156 @@\n+// Package testing provides support for automated testing of Go ...\n+PACKAGE testing\n+\n+IMPORTPATH\n+\ttestdata/testing\n+\n+IMPORTS\n+\tbytes\n+\tflag\n+\tfmt\n+\tio\n+\tos\n+\truntime\n+\truntime/pprof\n+\tstrconv\n+\tstrings\n+\ttime\n+\n+FILENAMES\n+\ttestdata/benchmark.go\n+\ttestdata/example.go\n+\ttestdata/testing.go\n+\n+FUNCTIONS\n+\t// An internal function but exported because it is cross-package; ...\n+\tfunc Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n+\n+\t// An internal function but exported because it is cross-package; ...\n+\tfunc RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)\n+\n+\t// \n+\tfunc RunExamples(examples []InternalExample) (ok bool)\n+\n+\t// \n+\tfunc RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)\n+\n+\t// Short reports whether the -test.short flag is set. \n+\tfunc Short() bool\n+\n+\n+TYPES\n+\t// B is a type passed to Benchmark functions to manage benchmark ...\n+\ttype B struct {\n+\t\tN int\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// Error is equivalent to Log() followed by Fail(). \n+\tfunc (c *B) Error(args ...interface{})\n+\n+\t// Errorf is equivalent to Logf() followed by Fail(). \n+\tfunc (c *B) Errorf(format string, args ...interface{})\n+\n+\t// Fail marks the function as having failed but continues ...\n+\tfunc (c *B) Fail()\n+\n+\t// FailNow marks the function as having failed and stops its ...\n+\tfunc (c *B) FailNow()\n+\n+\t// Failed returns whether the function has failed. \n+\tfunc (c *B) Failed() bool\n+\n+\t// Fatal is equivalent to Log() followed by FailNow(). \n+\tfunc (c *B) Fatal(args ...interface{})\n+\n+\t// Fatalf is equivalent to Logf() followed by FailNow(). \n+\tfunc (c *B) Fatalf(format string, args ...interface{})\n+\n+\t// Log formats its arguments using default formatting, analogous ...\n+\tfunc (c *B) Log(args ...interface{})\n+\n+\t// Logf formats its arguments according to the format, analogous ...\n+\tfunc (c *B) Logf(format string, args ...interface{})\n+\n+\t// ResetTimer sets the elapsed benchmark time to zero. It does not ...\n+\tfunc (b *B) ResetTimer()\n+\n+\t// SetBytes records the number of bytes processed in a single ...\n+\tfunc (b *B) SetBytes(n int64)\n+\n+\t// StartTimer starts timing a test.  This function is called ...\n+\tfunc (b *B) StartTimer()\n+\n+\t// StopTimer stops timing a test.  This can be used to pause the ...\n+\tfunc (b *B) StopTimer()\n+\n+\t// The results of a benchmark run. \n+\ttype BenchmarkResult struct {\n+\t\tN\tint\t\t// The number of iterations.\n+\t\tT\ttime.Duration\t// The total time taken.\n+\t\tBytes\tint64\t\t// Bytes processed in one iteration.\n+\t}\n+\n+\t// Benchmark benchmarks a single function. Useful for creating ...\n+\tfunc Benchmark(f func(b *B)) BenchmarkResult\n+\n+\t// \n+\tfunc (r BenchmarkResult) NsPerOp() int64\n+\n+\t// \n+\tfunc (r BenchmarkResult) String() string\n+\n+\t// An internal type but exported because it is cross-package; part ...\n+\ttype InternalBenchmark struct {\n+\t\tName\tstring\n+\t\tF\tfunc(b *B)\n+\t}\n+\n+\t// \n+\ttype InternalExample struct {\n+\t\tName\tstring\n+\t\tF\tfunc()\n+\t\tOutput\tstring\n+\t}\n+\n+\t// An internal type but exported because it is cross-package; part ...\n+\ttype InternalTest struct {\n+\t\tName\tstring\n+\t\tF\tfunc(*T)\n+\t}\n+\n+\t// T is a type passed to Test functions to manage test state and ...\n+\ttype T struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// Error is equivalent to Log() followed by Fail(). \n+\tfunc (c *T) Error(args ...interface{})\n+\n+\t// Errorf is equivalent to Logf() followed by Fail(). \n+\tfunc (c *T) Errorf(format string, args ...interface{})\n+\n+\t// Fail marks the function as having failed but continues ...\n+\tfunc (c *T) Fail()\n+\n+\t// FailNow marks the function as having failed and stops its ...\n+\tfunc (c *T) FailNow()\n+\n+\t// Failed returns whether the function has failed. \n+\tfunc (c *T) Failed() bool\n+\n+\t// Fatal is equivalent to Log() followed by FailNow(). \n+\tfunc (c *T) Fatal(args ...interface{})\n+\n+\t// Fatalf is equivalent to Logf() followed by FailNow(). \n+\tfunc (c *T) Fatalf(format string, args ...interface{})\n+\n+\t// Log formats its arguments using default formatting, analogous ...\n+\tfunc (c *T) Log(args ...interface{})\n+\n+\t// Logf formats its arguments according to the format, analogous ...\n+\tfunc (c *T) Logf(format string, args ...interface{})\n+\n+\t// Parallel signals that this test is to be run in parallel with ...\n+\tfunc (t *T) Parallel()\n+"}, {"sha": "4b72f38518eeb8636c9995f3497a20e9d8dda3a7", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -135,8 +135,10 @@ func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, m\n // \n func ParseExpr(x string) (ast.Expr, error) {\n \t// parse x within the context of a complete package for correct scopes;\n-\t// use //line directive for correct positions in error messages\n-\tfile, err := ParseFile(token.NewFileSet(), \"\", \"package p;func _(){_=\\n//line :1\\n\"+x+\";}\", 0)\n+\t// use //line directive for correct positions in error messages and put\n+\t// x alone on a separate line (handles line comments), followed by a ';'\n+\t// to force an error if the expression is incomplete\n+\tfile, err := ParseFile(token.NewFileSet(), \"\", \"package p;func _(){_=\\n//line :1\\n\"+x+\"\\n;}\", 0)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "05665b25487e58d5385a522b50f54d43848749ed", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -6,7 +6,7 @@\n // source which can then be tokenized through repeated calls to the Scan\n // function. Typical use:\n //\n-//\tvar s Scanner\n+//\tvar s scanner.Scanner\n //\tfset := token.NewFileSet()  // position information is relative to fset\n //      file := fset.AddFile(filename, fset.Base(), len(src))  // register file\n //\ts.Init(file, src, nil /* no error handler */, 0)"}, {"sha": "647d1b770b66e6d4034a9935464cd4d543315276", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 140, "deletions": 131, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -12,6 +12,9 @@ import (\n \t\"sync\"\n )\n \n+// -----------------------------------------------------------------------------\n+// Positions\n+\n // Position describes an arbitrary source position\n // including the file, line, and column location.\n // A Position is valid if the line number is > 0.\n@@ -81,84 +84,8 @@ func (p Pos) IsValid() bool {\n \treturn p != NoPos\n }\n \n-func searchFiles(a []*File, x int) int {\n-\treturn sort.Search(len(a), func(i int) bool { return a[i].base > x }) - 1\n-}\n-\n-func (s *FileSet) file(p Pos) *File {\n-\t// common case: p is in last file touched\n-\tif f := s.last; f != nil && f.base <= int(p) && int(p) <= f.base+f.size {\n-\t\treturn f\n-\t}\n-\t// p is not in last file touched - search all files\n-\tif i := searchFiles(s.files, int(p)); i >= 0 {\n-\t\tf := s.files[i]\n-\t\t// f.base <= int(p) by definition of searchFiles\n-\t\tif int(p) <= f.base+f.size {\n-\t\t\ts.last = f\n-\t\t\treturn f\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// File returns the file which contains the position p.\n-// If no such file is found (for instance for p == NoPos),\n-// the result is nil.\n-//\n-func (s *FileSet) File(p Pos) (f *File) {\n-\tif p != NoPos {\n-\t\ts.mutex.RLock()\n-\t\tf = s.file(p)\n-\t\ts.mutex.RUnlock()\n-\t}\n-\treturn\n-}\n-\n-func (f *File) position(p Pos) (pos Position) {\n-\toffset := int(p) - f.base\n-\tpos.Offset = offset\n-\tpos.Filename, pos.Line, pos.Column = f.info(offset)\n-\treturn\n-}\n-\n-// Position converts a Pos in the fileset into a general Position.\n-func (s *FileSet) Position(p Pos) (pos Position) {\n-\tif p != NoPos {\n-\t\ts.mutex.RLock()\n-\t\tif f := s.file(p); f != nil {\n-\t\t\tpos = f.position(p)\n-\t\t}\n-\t\ts.mutex.RUnlock()\n-\t}\n-\treturn\n-}\n-\n-// A lineInfo object describes alternative file and line number\n-// information (such as provided via a //line comment in a .go\n-// file) for a given file offset.\n-type lineInfo struct {\n-\t// fields are exported to make them accessible to gob\n-\tOffset   int\n-\tFilename string\n-\tLine     int\n-}\n-\n-// AddLineInfo adds alternative file and line number information for\n-// a given file offset. The offset must be larger than the offset for\n-// the previously added alternative line info and smaller than the\n-// file size; otherwise the information is ignored.\n-//\n-// AddLineInfo is typically used to register alternative position\n-// information for //line filename:line comments in source files.\n-//\n-func (f *File) AddLineInfo(offset int, filename string, line int) {\n-\tf.set.mutex.Lock()\n-\tif i := len(f.infos); i == 0 || f.infos[i-1].Offset < offset && offset < f.size {\n-\t\tf.infos = append(f.infos, lineInfo{offset, filename, line})\n-\t}\n-\tf.set.mutex.Unlock()\n-}\n+// -----------------------------------------------------------------------------\n+// File\n \n // A File is a handle for a file belonging to a FileSet.\n // A File has a name, size, and line offset table.\n@@ -253,6 +180,32 @@ func (f *File) SetLinesForContent(content []byte) {\n \tf.set.mutex.Unlock()\n }\n \n+// A lineInfo object describes alternative file and line number\n+// information (such as provided via a //line comment in a .go\n+// file) for a given file offset.\n+type lineInfo struct {\n+\t// fields are exported to make them accessible to gob\n+\tOffset   int\n+\tFilename string\n+\tLine     int\n+}\n+\n+// AddLineInfo adds alternative file and line number information for\n+// a given file offset. The offset must be larger than the offset for\n+// the previously added alternative line info and smaller than the\n+// file size; otherwise the information is ignored.\n+//\n+// AddLineInfo is typically used to register alternative position\n+// information for //line filename:line comments in source files.\n+//\n+func (f *File) AddLineInfo(offset int, filename string, line int) {\n+\tf.set.mutex.Lock()\n+\tif i := len(f.infos); i == 0 || f.infos[i-1].Offset < offset && offset < f.size {\n+\t\tf.infos = append(f.infos, lineInfo{offset, filename, line})\n+\t}\n+\tf.set.mutex.Unlock()\n+}\n+\n // Pos returns the Pos value for the given file offset;\n // the offset must be <= f.Size().\n // f.Pos(f.Offset(p)) == p.\n@@ -283,41 +236,6 @@ func (f *File) Line(p Pos) int {\n \treturn f.Position(p).Line\n }\n \n-// Position returns the Position value for the given file position p;\n-// p must be a Pos value in that file or NoPos.\n-//\n-func (f *File) Position(p Pos) (pos Position) {\n-\tif p != NoPos {\n-\t\tif int(p) < f.base || int(p) > f.base+f.size {\n-\t\t\tpanic(\"illegal Pos value\")\n-\t\t}\n-\t\tpos = f.position(p)\n-\t}\n-\treturn\n-}\n-\n-func searchInts(a []int, x int) int {\n-\t// This function body is a manually inlined version of:\n-\t//\n-\t//   return sort.Search(len(a), func(i int) bool { return a[i] > x }) - 1\n-\t//\n-\t// With better compiler optimizations, this may not be needed in the\n-\t// future, but at the moment this change improves the go/printer\n-\t// benchmark performance by ~30%. This has a direct impact on the\n-\t// speed of gofmt and thus seems worthwhile (2011-04-29).\n-\ti, j := 0, len(a)\n-\tfor i < j {\n-\t\th := i + (j-i)/2 // avoid overflow when computing h\n-\t\t// i \u2264 h < j\n-\t\tif a[h] <= x {\n-\t\t\ti = h + 1\n-\t\t} else {\n-\t\t\tj = h\n-\t\t}\n-\t}\n-\treturn i - 1\n-}\n-\n func searchLineInfos(a []lineInfo, x int) int {\n \treturn sort.Search(len(a), func(i int) bool { return a[i].Offset > x }) - 1\n }\n@@ -341,6 +259,29 @@ func (f *File) info(offset int) (filename string, line, column int) {\n \treturn\n }\n \n+func (f *File) position(p Pos) (pos Position) {\n+\toffset := int(p) - f.base\n+\tpos.Offset = offset\n+\tpos.Filename, pos.Line, pos.Column = f.info(offset)\n+\treturn\n+}\n+\n+// Position returns the Position value for the given file position p;\n+// p must be a Pos value in that file or NoPos.\n+//\n+func (f *File) Position(p Pos) (pos Position) {\n+\tif p != NoPos {\n+\t\tif int(p) < f.base || int(p) > f.base+f.size {\n+\t\t\tpanic(\"illegal Pos value\")\n+\t\t}\n+\t\tpos = f.position(p)\n+\t}\n+\treturn\n+}\n+\n+// -----------------------------------------------------------------------------\n+// FileSet\n+\n // A FileSet represents a set of source files.\n // Methods of file sets are synchronized; multiple goroutines\n // may invoke them concurrently.\n@@ -404,23 +345,91 @@ func (s *FileSet) AddFile(filename string, base, size int) *File {\n \treturn f\n }\n \n-// Files returns the files added to the file set.\n-func (s *FileSet) Files() <-chan *File {\n-\tch := make(chan *File)\n-\tgo func() {\n-\t\tfor i := 0; ; i++ {\n-\t\t\tvar f *File\n-\t\t\ts.mutex.RLock()\n-\t\t\tif i < len(s.files) {\n-\t\t\t\tf = s.files[i]\n-\t\t\t}\n-\t\t\ts.mutex.RUnlock()\n-\t\t\tif f == nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tch <- f\n+// Iterate calls f for the files in the file set in the order they were added\n+// until f returns false.\n+// \n+func (s *FileSet) Iterate(f func(*File) bool) {\n+\tfor i := 0; ; i++ {\n+\t\tvar file *File\n+\t\ts.mutex.RLock()\n+\t\tif i < len(s.files) {\n+\t\t\tfile = s.files[i]\n+\t\t}\n+\t\ts.mutex.RUnlock()\n+\t\tif file == nil || !f(file) {\n+\t\t\tbreak\n \t\t}\n-\t\tclose(ch)\n-\t}()\n-\treturn ch\n+\t}\n+}\n+\n+func searchFiles(a []*File, x int) int {\n+\treturn sort.Search(len(a), func(i int) bool { return a[i].base > x }) - 1\n+}\n+\n+func (s *FileSet) file(p Pos) *File {\n+\t// common case: p is in last file\n+\tif f := s.last; f != nil && f.base <= int(p) && int(p) <= f.base+f.size {\n+\t\treturn f\n+\t}\n+\t// p is not in last file - search all files\n+\tif i := searchFiles(s.files, int(p)); i >= 0 {\n+\t\tf := s.files[i]\n+\t\t// f.base <= int(p) by definition of searchFiles\n+\t\tif int(p) <= f.base+f.size {\n+\t\t\ts.last = f\n+\t\t\treturn f\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// File returns the file that contains the position p.\n+// If no such file is found (for instance for p == NoPos),\n+// the result is nil.\n+//\n+func (s *FileSet) File(p Pos) (f *File) {\n+\tif p != NoPos {\n+\t\ts.mutex.RLock()\n+\t\tf = s.file(p)\n+\t\ts.mutex.RUnlock()\n+\t}\n+\treturn\n+}\n+\n+// Position converts a Pos in the fileset into a general Position.\n+func (s *FileSet) Position(p Pos) (pos Position) {\n+\tif p != NoPos {\n+\t\ts.mutex.RLock()\n+\t\tif f := s.file(p); f != nil {\n+\t\t\tpos = f.position(p)\n+\t\t}\n+\t\ts.mutex.RUnlock()\n+\t}\n+\treturn\n+}\n+\n+// -----------------------------------------------------------------------------\n+// Helper functions\n+\n+func searchInts(a []int, x int) int {\n+\t// This function body is a manually inlined version of:\n+\t//\n+\t//   return sort.Search(len(a), func(i int) bool { return a[i] > x }) - 1\n+\t//\n+\t// With better compiler optimizations, this may not be needed in the\n+\t// future, but at the moment this change improves the go/printer\n+\t// benchmark performance by ~30%. This has a direct impact on the\n+\t// speed of gofmt and thus seems worthwhile (2011-04-29).\n+\t// TODO(gri): Remove this when compilers have caught up.\n+\ti, j := 0, len(a)\n+\tfor i < j {\n+\t\th := i + (j-i)/2 // avoid overflow when computing h\n+\t\t// i \u2264 h < j\n+\t\tif a[h] <= x {\n+\t\t\ti = h + 1\n+\t\t} else {\n+\t\t\tj = h\n+\t\t}\n+\t}\n+\treturn i - 1\n }"}, {"sha": "160107df407df8b7a2ab7f9b3ef189f6cd7766c4", "filename": "libgo/go/go/token/position_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -167,12 +167,13 @@ func TestFiles(t *testing.T) {\n \tfor i, test := range tests {\n \t\tfset.AddFile(test.filename, fset.Base(), test.size)\n \t\tj := 0\n-\t\tfor g := range fset.Files() {\n-\t\t\tif g.Name() != tests[j].filename {\n-\t\t\t\tt.Errorf(\"expected filename = %s; got %s\", tests[j].filename, g.Name())\n+\t\tfset.Iterate(func(f *File) bool {\n+\t\t\tif f.Name() != tests[j].filename {\n+\t\t\t\tt.Errorf(\"expected filename = %s; got %s\", tests[j].filename, f.Name())\n \t\t\t}\n \t\t\tj++\n-\t\t}\n+\t\t\treturn true\n+\t\t})\n \t\tif j != i+1 {\n \t\t\tt.Errorf(\"expected %d files; got %d\", i+1, j)\n \t\t}"}, {"sha": "64fe68c443f027a2fab301e1a501a3ddeca76da1", "filename": "libgo/go/hash/adler32/adler32.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -38,6 +38,8 @@ func New() hash.Hash32 {\n \n func (d *digest) Size() int { return Size }\n \n+func (d *digest) BlockSize() int { return 1 }\n+\n // Add p to the running checksum a, b.\n func update(a, b uint32, p []byte) (aa, bb uint32) {\n \tfor _, pi := range p {"}, {"sha": "236d7787289c170234af166d571218cefad7a238", "filename": "libgo/go/hash/crc32/crc32.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -94,6 +94,8 @@ func NewIEEE() hash.Hash32 { return New(IEEETable) }\n \n func (d *digest) Size() int { return Size }\n \n+func (d *digest) BlockSize() int { return 1 }\n+\n func (d *digest) Reset() { d.crc = 0 }\n \n func update(crc uint32, tab *Table, p []byte) uint32 {"}, {"sha": "5b64390f3d5b51d6e72ea3448c6e6983dc7b5e6b", "filename": "libgo/go/hash/crc64/crc64.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -53,6 +53,8 @@ func New(tab *Table) hash.Hash64 { return &digest{0, tab} }\n \n func (d *digest) Size() int { return Size }\n \n+func (d *digest) BlockSize() int { return 1 }\n+\n func (d *digest) Reset() { d.crc = 0 }\n \n func update(crc uint64, tab *Table, p []byte) uint64 {"}, {"sha": "ea50198180f54ad427e9c8c8b4447d8468144a2e", "filename": "libgo/go/hash/fnv/fnv.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -104,6 +104,11 @@ func (s *sum32a) Size() int { return 4 }\n func (s *sum64) Size() int  { return 8 }\n func (s *sum64a) Size() int { return 8 }\n \n+func (s *sum32) BlockSize() int  { return 1 }\n+func (s *sum32a) BlockSize() int { return 1 }\n+func (s *sum64) BlockSize() int  { return 1 }\n+func (s *sum64a) BlockSize() int { return 1 }\n+\n func (s *sum32) Sum(in []byte) []byte {\n \tv := uint32(*s)\n \tin = append(in, byte(v>>24))"}, {"sha": "aa895cf98470ce10939a84b6ae95b530c03143a8", "filename": "libgo/go/hash/hash.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhash%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fhash.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -22,6 +22,12 @@ type Hash interface {\n \n \t// Size returns the number of bytes Sum will return.\n \tSize() int\n+\n+\t// BlockSize returns the hash's underlying block size.\n+\t// The Write method must be able to accept any amount\n+\t// of data, but it may operate more efficiently if all writes\n+\t// are a multiple of the block size.\n+\tBlockSize() int\n }\n \n // Hash32 is the common interface implemented by all 32-bit hash functions."}, {"sha": "04f4ae7533494312ae79bf591ff33902daa3bceb", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1713,8 +1713,8 @@ func parseForeignContent(p *parser) bool {\n \t\t}\n \t\tif breakout[p.tok.Data] {\n \t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\t\t\t// TODO: HTML, MathML integration points.\n-\t\t\t\tif p.oe[i].Namespace == \"\" {\n+\t\t\t\t// TODO: MathML integration points.\n+\t\t\t\tif p.oe[i].Namespace == \"\" || htmlIntegrationPoint(p.oe[i]) {\n \t\t\t\t\tp.oe = p.oe[:i+1]\n \t\t\t\t\tbreak\n \t\t\t\t}"}, {"sha": "1528dffaafa1533304fdba8022b3db5f4b0aa648", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -184,7 +184,7 @@ func TestParser(t *testing.T) {\n \t\t{\"tests4.dat\", -1},\n \t\t{\"tests5.dat\", -1},\n \t\t{\"tests6.dat\", -1},\n-\t\t{\"tests10.dat\", 33},\n+\t\t{\"tests10.dat\", 35},\n \t}\n \tfor _, tf := range testFiles {\n \t\tf, err := os.Open(\"testdata/webkit/\" + tf.filename)"}, {"sha": "77a9bf2e225b8a0aefdd691bd53d1b81b3da2a5b", "filename": "libgo/go/html/template/doc.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -31,8 +31,8 @@ Example\n \n   import \"text/template\"\n   ...\n-  t, err := (&template.Set{}).Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n-  err = t.Execute(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n+  t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n+  err = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n \n produces\n \n@@ -42,12 +42,12 @@ but with contextual autoescaping,\n \n   import \"html/template\"\n   ...\n-  t, err := (&template.Set{}).Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n-  err = t.Execute(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n+  t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n+  err = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n \n produces safe, escaped HTML output\n \n-  Hello, &lt;script&gt;alert('you have been pwned')&lt;/script&gt;!\n+  Hello, &lt;script&gt;alert(&#39;you have been pwned&#39;)&lt;/script&gt;!\n \n \n Contexts\n@@ -57,8 +57,8 @@ functions to each simple action pipeline, so given the excerpt\n \n   <a href=\"/search?q={{.}}\">{{.}}</a>\n \n-At parse time each {{.}} is overwritten to add escaping functions as necessary,\n-in this case,\n+At parse time each {{.}} is overwritten to add escaping functions as necessary.\n+In this case it becomes\n \n   <a href=\"/search?q={{. | urlquery}}\">{{. | html}}</a>\n "}, {"sha": "0e31674f05fd1b38e42565501ac3b3387f3206e9", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -899,7 +899,7 @@ func TestErrors(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\t`<a href=\"{{if .F}}/foo?a={{else}}/bar/{{end}}{{.H}}\">`,\n-\t\t\t\"z:1: (action: [(command: [F=[H]])]) appears in an ambiguous URL context\",\n+\t\t\t\"z:1: {{.H}} appears in an ambiguous URL context\",\n \t\t},\n \t\t{\n \t\t\t`<a onclick=\"alert('Hello \\`,\n@@ -1490,62 +1490,62 @@ func TestEnsurePipelineContains(t *testing.T) {\n \t}{\n \t\t{\n \t\t\t\"{{.X}}\",\n-\t\t\t\"[(command: [F=[X]])]\",\n+\t\t\t\".X\",\n \t\t\t[]string{},\n \t\t},\n \t\t{\n \t\t\t\"{{.X | html}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=html])]\",\n+\t\t\t\".X | html\",\n \t\t\t[]string{},\n \t\t},\n \t\t{\n \t\t\t\"{{.X}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=html])]\",\n+\t\t\t\".X | html\",\n \t\t\t[]string{\"html\"},\n \t\t},\n \t\t{\n \t\t\t\"{{.X | html}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=html]) (command: [I=urlquery])]\",\n+\t\t\t\".X | html | urlquery\",\n \t\t\t[]string{\"urlquery\"},\n \t\t},\n \t\t{\n \t\t\t\"{{.X | html | urlquery}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=html]) (command: [I=urlquery])]\",\n+\t\t\t\".X | html | urlquery\",\n \t\t\t[]string{\"urlquery\"},\n \t\t},\n \t\t{\n \t\t\t\"{{.X | html | urlquery}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=html]) (command: [I=urlquery])]\",\n+\t\t\t\".X | html | urlquery\",\n \t\t\t[]string{\"html\", \"urlquery\"},\n \t\t},\n \t\t{\n \t\t\t\"{{.X | html | urlquery}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=html]) (command: [I=urlquery])]\",\n+\t\t\t\".X | html | urlquery\",\n \t\t\t[]string{\"html\"},\n \t\t},\n \t\t{\n \t\t\t\"{{.X | urlquery}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=html]) (command: [I=urlquery])]\",\n+\t\t\t\".X | html | urlquery\",\n \t\t\t[]string{\"html\", \"urlquery\"},\n \t\t},\n \t\t{\n \t\t\t\"{{.X | html | print}}\",\n-\t\t\t\"[(command: [F=[X]]) (command: [I=urlquery]) (command: [I=html]) (command: [I=print])]\",\n+\t\t\t\".X | urlquery | html | print\",\n \t\t\t[]string{\"urlquery\", \"html\"},\n \t\t},\n \t}\n-\tfor _, test := range tests {\n+\tfor i, test := range tests {\n \t\ttmpl := template.Must(template.New(\"test\").Parse(test.input))\n \t\taction, ok := (tmpl.Tree.Root.Nodes[0].(*parse.ActionNode))\n \t\tif !ok {\n-\t\t\tt.Errorf(\"First node is not an action: %s\", test.input)\n+\t\t\tt.Errorf(\"#%d: First node is not an action: %s\", i, test.input)\n \t\t\tcontinue\n \t\t}\n \t\tpipe := action.Pipe\n \t\tensurePipelineContains(pipe, test.ids)\n \t\tgot := pipe.String()\n \t\tif got != test.output {\n-\t\t\tt.Errorf(\"%s, %v: want\\n\\t%s\\ngot\\n\\t%s\", test.input, test.ids, test.output, got)\n+\t\t\tt.Errorf(\"#%d: %s, %v: want\\n\\t%s\\ngot\\n\\t%s\", i, test.input, test.ids, test.output, got)\n \t\t}\n \t}\n }"}, {"sha": "29a7b8a40011408864ed3e12ddb779b7bbbca135", "filename": "libgo/go/image/color/color.go", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -152,26 +152,35 @@ func (m *modelFunc) Convert(c Color) Color {\n \treturn m.f(c)\n }\n \n-// RGBAModel is the Model for RGBA colors.\n-var RGBAModel Model = ModelFunc(func(c Color) Color {\n+// Models for the standard color types.\n+var (\n+\tRGBAModel    Model = ModelFunc(rgbaModel)\n+\tRGBA64Model  Model = ModelFunc(rgba64Model)\n+\tNRGBAModel   Model = ModelFunc(nrgbaModel)\n+\tNRGBA64Model Model = ModelFunc(nrgba64Model)\n+\tAlphaModel   Model = ModelFunc(alphaModel)\n+\tAlpha16Model Model = ModelFunc(alpha16Model)\n+\tGrayModel    Model = ModelFunc(grayModel)\n+\tGray16Model  Model = ModelFunc(gray16Model)\n+)\n+\n+func rgbaModel(c Color) Color {\n \tif _, ok := c.(RGBA); ok {\n \t\treturn c\n \t}\n \tr, g, b, a := c.RGBA()\n \treturn RGBA{uint8(r >> 8), uint8(g >> 8), uint8(b >> 8), uint8(a >> 8)}\n-})\n+}\n \n-// RGBAModel is the Model for RGBA64 colors.\n-var RGBA64Model Model = ModelFunc(func(c Color) Color {\n+func rgba64Model(c Color) Color {\n \tif _, ok := c.(RGBA64); ok {\n \t\treturn c\n \t}\n \tr, g, b, a := c.RGBA()\n \treturn RGBA64{uint16(r), uint16(g), uint16(b), uint16(a)}\n-})\n+}\n \n-// NRGBAModel is the Model for NRGBA colors.\n-var NRGBAModel Model = ModelFunc(func(c Color) Color {\n+func nrgbaModel(c Color) Color {\n \tif _, ok := c.(NRGBA); ok {\n \t\treturn c\n \t}\n@@ -187,10 +196,9 @@ var NRGBAModel Model = ModelFunc(func(c Color) Color {\n \tg = (g * 0xffff) / a\n \tb = (b * 0xffff) / a\n \treturn NRGBA{uint8(r >> 8), uint8(g >> 8), uint8(b >> 8), uint8(a >> 8)}\n-})\n+}\n \n-// NRGBAModel is the Model for NRGBA64 colors.\n-var NRGBA64Model Model = ModelFunc(func(c Color) Color {\n+func nrgba64Model(c Color) Color {\n \tif _, ok := c.(NRGBA64); ok {\n \t\treturn c\n \t}\n@@ -206,45 +214,41 @@ var NRGBA64Model Model = ModelFunc(func(c Color) Color {\n \tg = (g * 0xffff) / a\n \tb = (b * 0xffff) / a\n \treturn NRGBA64{uint16(r), uint16(g), uint16(b), uint16(a)}\n-})\n+}\n \n-// AlphaModel is the Model for Alpha colors.\n-var AlphaModel Model = ModelFunc(func(c Color) Color {\n+func alphaModel(c Color) Color {\n \tif _, ok := c.(Alpha); ok {\n \t\treturn c\n \t}\n \t_, _, _, a := c.RGBA()\n \treturn Alpha{uint8(a >> 8)}\n-})\n+}\n \n-// Alpha16Model is the Model for Alpha16 colors.\n-var Alpha16Model Model = ModelFunc(func(c Color) Color {\n+func alpha16Model(c Color) Color {\n \tif _, ok := c.(Alpha16); ok {\n \t\treturn c\n \t}\n \t_, _, _, a := c.RGBA()\n \treturn Alpha16{uint16(a)}\n-})\n+}\n \n-// GrayModel is the Model for Gray colors.\n-var GrayModel Model = ModelFunc(func(c Color) Color {\n+func grayModel(c Color) Color {\n \tif _, ok := c.(Gray); ok {\n \t\treturn c\n \t}\n \tr, g, b, _ := c.RGBA()\n \ty := (299*r + 587*g + 114*b + 500) / 1000\n \treturn Gray{uint8(y >> 8)}\n-})\n+}\n \n-// Gray16Model is the Model for Gray16 colors.\n-var Gray16Model Model = ModelFunc(func(c Color) Color {\n+func gray16Model(c Color) Color {\n \tif _, ok := c.(Gray16); ok {\n \t\treturn c\n \t}\n \tr, g, b, _ := c.RGBA()\n \ty := (299*r + 587*g + 114*b + 500) / 1000\n \treturn Gray16{uint16(y)}\n-})\n+}\n \n // Palette is a palette of colors.\n type Palette []Color\n@@ -290,13 +294,10 @@ func (p Palette) Index(c Color) int {\n \treturn ret\n }\n \n+// Standard colors.\n var (\n-\t// Black is an opaque black Color.\n-\tBlack = Gray16{0}\n-\t// White is an opaque white Color.\n-\tWhite = Gray16{0xffff}\n-\t// Transparent is a fully transparent Color.\n+\tBlack       = Gray16{0}\n+\tWhite       = Gray16{0xffff}\n \tTransparent = Alpha16{0}\n-\t// Opaque is a fully opaque Color.\n-\tOpaque = Alpha16{0xffff}\n+\tOpaque      = Alpha16{0xffff}\n )"}, {"sha": "4c2f29ea021978ce3371c15540a5951c91221844", "filename": "libgo/go/image/color/ycbcr.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -4,8 +4,7 @@\n \n package color\n \n-// RGBToYCbCr converts an RGB triple to a Y'CbCr triple. All components lie\n-// within the range [0, 255].\n+// RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8) {\n \t// The JFIF specification says:\n \t//\tY' =  0.2990*R + 0.5870*G + 0.1140*B\n@@ -36,8 +35,7 @@ func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8) {\n \treturn uint8(yy), uint8(cb), uint8(cr)\n }\n \n-// YCbCrToRGB converts a Y'CbCr triple to an RGB triple. All components lie\n-// within the range [0, 255].\n+// YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n func YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8) {\n \t// The JFIF specification says:\n \t//\tR = Y' + 1.40200*(Cr-128)\n@@ -89,11 +87,13 @@ func (c YCbCr) RGBA() (uint32, uint32, uint32, uint32) {\n }\n \n // YCbCrModel is the Model for Y'CbCr colors.\n-var YCbCrModel Model = ModelFunc(func(c Color) Color {\n+var YCbCrModel Model = ModelFunc(yCbCrModel)\n+\n+func yCbCrModel(c Color) Color {\n \tif _, ok := c.(YCbCr); ok {\n \t\treturn c\n \t}\n \tr, g, b, _ := c.RGBA()\n \ty, u, v := RGBToYCbCr(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n \treturn YCbCr{y, u, v}\n-})\n+}"}, {"sha": "3b6679f7c7eb5c38083a6844f5fcd8b9a0243009", "filename": "libgo/go/image/draw/draw.go", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -171,7 +171,7 @@ func drawFillOver(dst *image.RGBA, r image.Rectangle, src *image.Uniform) {\n \tsr, sg, sb, sa := src.RGBA()\n \t// The 0x101 is here for the same reason as in drawRGBA.\n \ta := (m - sa) * 0x101\n-\ti0 := (r.Min.Y-dst.Rect.Min.Y)*dst.Stride + (r.Min.X-dst.Rect.Min.X)*4\n+\ti0 := dst.PixOffset(r.Min.X, r.Min.Y)\n \ti1 := i0 + r.Dx()*4\n \tfor y := r.Min.Y; y != r.Max.Y; y++ {\n \t\tfor i := i0; i < i1; i += 4 {\n@@ -195,7 +195,7 @@ func drawFillSrc(dst *image.RGBA, r image.Rectangle, src *image.Uniform) {\n \t// The built-in copy function is faster than a straightforward for loop to fill the destination with\n \t// the color, but copy requires a slice source. We therefore use a for loop to fill the first row, and\n \t// then use the first row as the slice source for the remaining rows.\n-\ti0 := (r.Min.Y-dst.Rect.Min.Y)*dst.Stride + (r.Min.X-dst.Rect.Min.X)*4\n+\ti0 := dst.PixOffset(r.Min.X, r.Min.Y)\n \ti1 := i0 + r.Dx()*4\n \tfor i := i0; i < i1; i += 4 {\n \t\tdst.Pix[i+0] = uint8(sr >> 8)\n@@ -213,8 +213,8 @@ func drawFillSrc(dst *image.RGBA, r image.Rectangle, src *image.Uniform) {\n \n func drawCopyOver(dst *image.RGBA, r image.Rectangle, src *image.RGBA, sp image.Point) {\n \tdx, dy := r.Dx(), r.Dy()\n-\td0 := (r.Min.Y-dst.Rect.Min.Y)*dst.Stride + (r.Min.X-dst.Rect.Min.X)*4\n-\ts0 := (sp.Y-src.Rect.Min.Y)*src.Stride + (sp.X-src.Rect.Min.X)*4\n+\td0 := dst.PixOffset(r.Min.X, r.Min.Y)\n+\ts0 := src.PixOffset(sp.X, sp.Y)\n \tvar (\n \t\tddelta, sdelta int\n \t\ti0, i1, idelta int\n@@ -261,8 +261,8 @@ func drawCopyOver(dst *image.RGBA, r image.Rectangle, src *image.RGBA, sp image.\n \n func drawCopySrc(dst *image.RGBA, r image.Rectangle, src *image.RGBA, sp image.Point) {\n \tn, dy := 4*r.Dx(), r.Dy()\n-\td0 := (r.Min.Y-dst.Rect.Min.Y)*dst.Stride + (r.Min.X-dst.Rect.Min.X)*4\n-\ts0 := (sp.Y-src.Rect.Min.Y)*src.Stride + (sp.X-src.Rect.Min.X)*4\n+\td0 := dst.PixOffset(r.Min.X, r.Min.Y)\n+\ts0 := src.PixOffset(sp.X, sp.Y)\n \tvar ddelta, sdelta int\n \tif r.Min.Y <= sp.Y {\n \t\tddelta = dst.Stride\n@@ -348,9 +348,6 @@ func drawNRGBASrc(dst *image.RGBA, r image.Rectangle, src *image.NRGBA, sp image\n func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Point) {\n \t// An image.YCbCr is always fully opaque, and so if the mask is implicitly nil\n \t// (i.e. fully opaque) then the op is effectively always Src.\n-\tvar (\n-\t\tyy, cb, cr uint8\n-\t)\n \tx0 := (r.Min.X - dst.Rect.Min.X) * 4\n \tx1 := (r.Max.X - dst.Rect.Min.X) * 4\n \ty0 := r.Min.Y - dst.Rect.Min.Y\n@@ -359,12 +356,11 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Po\n \tcase image.YCbCrSubsampleRatio422:\n \t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n \t\t\tdpix := dst.Pix[y*dst.Stride:]\n-\t\t\tfor x, sx := x0, sp.X; x != x1; x, sx = x+4, sx+1 {\n-\t\t\t\ti := sx / 2\n-\t\t\t\tyy = src.Y[sy*src.YStride+sx]\n-\t\t\t\tcb = src.Cb[sy*src.CStride+i]\n-\t\t\t\tcr = src.Cr[sy*src.CStride+i]\n-\t\t\t\trr, gg, bb := color.YCbCrToRGB(yy, cb, cr)\n+\t\t\tyi := (sy-src.Rect.Min.Y)*src.YStride + (sp.X - src.Rect.Min.X)\n+\t\t\tciBase := (sy-src.Rect.Min.Y)*src.CStride - src.Rect.Min.X/2\n+\t\t\tfor x, sx := x0, sp.X; x != x1; x, sx, yi = x+4, sx+1, yi+1 {\n+\t\t\t\tci := ciBase + sx/2\n+\t\t\t\trr, gg, bb := color.YCbCrToRGB(src.Y[yi], src.Cb[ci], src.Cr[ci])\n \t\t\t\tdpix[x+0] = rr\n \t\t\t\tdpix[x+1] = gg\n \t\t\t\tdpix[x+2] = bb\n@@ -374,12 +370,11 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Po\n \tcase image.YCbCrSubsampleRatio420:\n \t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n \t\t\tdpix := dst.Pix[y*dst.Stride:]\n-\t\t\tfor x, sx := x0, sp.X; x != x1; x, sx = x+4, sx+1 {\n-\t\t\t\ti, j := sx/2, sy/2\n-\t\t\t\tyy = src.Y[sy*src.YStride+sx]\n-\t\t\t\tcb = src.Cb[j*src.CStride+i]\n-\t\t\t\tcr = src.Cr[j*src.CStride+i]\n-\t\t\t\trr, gg, bb := color.YCbCrToRGB(yy, cb, cr)\n+\t\t\tyi := (sy-src.Rect.Min.Y)*src.YStride + (sp.X - src.Rect.Min.X)\n+\t\t\tciBase := (sy/2-src.Rect.Min.Y/2)*src.CStride - src.Rect.Min.X/2\n+\t\t\tfor x, sx := x0, sp.X; x != x1; x, sx, yi = x+4, sx+1, yi+1 {\n+\t\t\t\tci := ciBase + sx/2\n+\t\t\t\trr, gg, bb := color.YCbCrToRGB(src.Y[yi], src.Cb[ci], src.Cr[ci])\n \t\t\t\tdpix[x+0] = rr\n \t\t\t\tdpix[x+1] = gg\n \t\t\t\tdpix[x+2] = bb\n@@ -390,11 +385,10 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Po\n \t\t// Default to 4:4:4 subsampling.\n \t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n \t\t\tdpix := dst.Pix[y*dst.Stride:]\n-\t\t\tfor x, sx := x0, sp.X; x != x1; x, sx = x+4, sx+1 {\n-\t\t\t\tyy = src.Y[sy*src.YStride+sx]\n-\t\t\t\tcb = src.Cb[sy*src.CStride+sx]\n-\t\t\t\tcr = src.Cr[sy*src.CStride+sx]\n-\t\t\t\trr, gg, bb := color.YCbCrToRGB(yy, cb, cr)\n+\t\t\tyi := (sy-src.Rect.Min.Y)*src.YStride + (sp.X - src.Rect.Min.X)\n+\t\t\tci := (sy-src.Rect.Min.Y)*src.CStride + (sp.X - src.Rect.Min.X)\n+\t\t\tfor x := x0; x != x1; x, yi, ci = x+4, yi+1, ci+1 {\n+\t\t\t\trr, gg, bb := color.YCbCrToRGB(src.Y[yi], src.Cb[ci], src.Cr[ci])\n \t\t\t\tdpix[x+0] = rr\n \t\t\t\tdpix[x+1] = gg\n \t\t\t\tdpix[x+2] = bb\n@@ -405,9 +399,9 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Po\n }\n \n func drawGlyphOver(dst *image.RGBA, r image.Rectangle, src *image.Uniform, mask *image.Alpha, mp image.Point) {\n-\ti0 := (r.Min.Y-dst.Rect.Min.Y)*dst.Stride + (r.Min.X-dst.Rect.Min.X)*4\n+\ti0 := dst.PixOffset(r.Min.X, r.Min.Y)\n \ti1 := i0 + r.Dx()*4\n-\tmi0 := (mp.Y-mask.Rect.Min.Y)*mask.Stride + mp.X - mask.Rect.Min.X\n+\tmi0 := mask.PixOffset(mp.X, mp.Y)\n \tsr, sg, sb, sa := src.RGBA()\n \tfor y, my := r.Min.Y, mp.Y; y != r.Max.Y; y, my = y+1, my+1 {\n \t\tfor i, mi := i0, mi0; i < i1; i, mi = i+4, mi+1 {\n@@ -451,7 +445,7 @@ func drawRGBA(dst *image.RGBA, r image.Rectangle, src image.Image, sp image.Poin\n \tsx0 := sp.X + x0 - r.Min.X\n \tmx0 := mp.X + x0 - r.Min.X\n \tsx1 := sx0 + (x1 - x0)\n-\ti0 := (y0-dst.Rect.Min.Y)*dst.Stride + (x0-dst.Rect.Min.X)*4\n+\ti0 := dst.PixOffset(x0, y0)\n \tdi := dx * 4\n \tfor y := y0; y != y1; y, sy, my = y+dy, sy+dy, my+dy {\n \t\tfor i, sx, mx := i0, sx0, mx0; sx != sx1; i, sx, mx = i+di, sx+dx, mx+dx {"}, {"sha": "e123483314c2e5148f7c6edec0db0030e8e1f423", "filename": "libgo/go/image/geom.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fgeom.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fgeom.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgeom.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -112,7 +112,7 @@ func (r Rectangle) Add(p Point) Rectangle {\n \t}\n }\n \n-// Add returns the rectangle r translated by -p.\n+// Sub returns the rectangle r translated by -p.\n func (r Rectangle) Sub(p Point) Rectangle {\n \treturn Rectangle{\n \t\tPoint{r.Min.X - p.X, r.Min.Y - p.Y},"}, {"sha": "9dd676aceddfb720e1a2076e9711083d06fa731e", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 99, "deletions": 45, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -61,15 +61,21 @@ func (p *RGBA) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.RGBA{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+\ti := p.PixOffset(x, y)\n \treturn color.RGBA{p.Pix[i+0], p.Pix[i+1], p.Pix[i+2], p.Pix[i+3]}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *RGBA) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+}\n+\n func (p *RGBA) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+\ti := p.PixOffset(x, y)\n \tc1 := color.RGBAModel.Convert(c).(color.RGBA)\n \tp.Pix[i+0] = c1.R\n \tp.Pix[i+1] = c1.G\n@@ -81,7 +87,7 @@ func (p *RGBA) SetRGBA(x, y int, c color.RGBA) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i+0] = c.R\n \tp.Pix[i+1] = c.G\n \tp.Pix[i+2] = c.B\n@@ -98,7 +104,7 @@ func (p *RGBA) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &RGBA{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*4\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &RGBA{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -124,7 +130,7 @@ func (p *RGBA) Opaque() bool {\n \treturn true\n }\n \n-// NewRGBA returns a new RGBA with the given width and height.\n+// NewRGBA returns a new RGBA with the given bounds.\n func NewRGBA(r Rectangle) *RGBA {\n \tw, h := r.Dx(), r.Dy()\n \tbuf := make([]uint8, 4*w*h)\n@@ -150,7 +156,7 @@ func (p *RGBA64) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.RGBA64{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+\ti := p.PixOffset(x, y)\n \treturn color.RGBA64{\n \t\tuint16(p.Pix[i+0])<<8 | uint16(p.Pix[i+1]),\n \t\tuint16(p.Pix[i+2])<<8 | uint16(p.Pix[i+3]),\n@@ -159,11 +165,17 @@ func (p *RGBA64) At(x, y int) color.Color {\n \t}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *RGBA64) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+}\n+\n func (p *RGBA64) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+\ti := p.PixOffset(x, y)\n \tc1 := color.RGBA64Model.Convert(c).(color.RGBA64)\n \tp.Pix[i+0] = uint8(c1.R >> 8)\n \tp.Pix[i+1] = uint8(c1.R)\n@@ -179,7 +191,7 @@ func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i+0] = uint8(c.R >> 8)\n \tp.Pix[i+1] = uint8(c.R)\n \tp.Pix[i+2] = uint8(c.G >> 8)\n@@ -200,7 +212,7 @@ func (p *RGBA64) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &RGBA64{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*8\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &RGBA64{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -226,7 +238,7 @@ func (p *RGBA64) Opaque() bool {\n \treturn true\n }\n \n-// NewRGBA64 returns a new RGBA64 with the given width and height.\n+// NewRGBA64 returns a new RGBA64 with the given bounds.\n func NewRGBA64(r Rectangle) *RGBA64 {\n \tw, h := r.Dx(), r.Dy()\n \tpix := make([]uint8, 8*w*h)\n@@ -252,15 +264,21 @@ func (p *NRGBA) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.NRGBA{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+\ti := p.PixOffset(x, y)\n \treturn color.NRGBA{p.Pix[i+0], p.Pix[i+1], p.Pix[i+2], p.Pix[i+3]}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *NRGBA) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+}\n+\n func (p *NRGBA) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+\ti := p.PixOffset(x, y)\n \tc1 := color.NRGBAModel.Convert(c).(color.NRGBA)\n \tp.Pix[i+0] = c1.R\n \tp.Pix[i+1] = c1.G\n@@ -272,7 +290,7 @@ func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*4\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i+0] = c.R\n \tp.Pix[i+1] = c.G\n \tp.Pix[i+2] = c.B\n@@ -289,7 +307,7 @@ func (p *NRGBA) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &NRGBA{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*4\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &NRGBA{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -315,7 +333,7 @@ func (p *NRGBA) Opaque() bool {\n \treturn true\n }\n \n-// NewNRGBA returns a new NRGBA with the given width and height.\n+// NewNRGBA returns a new NRGBA with the given bounds.\n func NewNRGBA(r Rectangle) *NRGBA {\n \tw, h := r.Dx(), r.Dy()\n \tpix := make([]uint8, 4*w*h)\n@@ -341,7 +359,7 @@ func (p *NRGBA64) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.NRGBA64{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+\ti := p.PixOffset(x, y)\n \treturn color.NRGBA64{\n \t\tuint16(p.Pix[i+0])<<8 | uint16(p.Pix[i+1]),\n \t\tuint16(p.Pix[i+2])<<8 | uint16(p.Pix[i+3]),\n@@ -350,11 +368,17 @@ func (p *NRGBA64) At(x, y int) color.Color {\n \t}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *NRGBA64) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+}\n+\n func (p *NRGBA64) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+\ti := p.PixOffset(x, y)\n \tc1 := color.NRGBA64Model.Convert(c).(color.NRGBA64)\n \tp.Pix[i+0] = uint8(c1.R >> 8)\n \tp.Pix[i+1] = uint8(c1.R)\n@@ -370,7 +394,7 @@ func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*8\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i+0] = uint8(c.R >> 8)\n \tp.Pix[i+1] = uint8(c.R)\n \tp.Pix[i+2] = uint8(c.G >> 8)\n@@ -391,7 +415,7 @@ func (p *NRGBA64) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &NRGBA64{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*8\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &NRGBA64{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -417,7 +441,7 @@ func (p *NRGBA64) Opaque() bool {\n \treturn true\n }\n \n-// NewNRGBA64 returns a new NRGBA64 with the given width and height.\n+// NewNRGBA64 returns a new NRGBA64 with the given bounds.\n func NewNRGBA64(r Rectangle) *NRGBA64 {\n \tw, h := r.Dx(), r.Dy()\n \tpix := make([]uint8, 8*w*h)\n@@ -443,23 +467,29 @@ func (p *Alpha) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.Alpha{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \treturn color.Alpha{p.Pix[i]}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *Alpha) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*1\n+}\n+\n func (p *Alpha) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i] = color.AlphaModel.Convert(c).(color.Alpha).A\n }\n \n func (p *Alpha) SetAlpha(x, y int, c color.Alpha) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i] = c.A\n }\n \n@@ -473,7 +503,7 @@ func (p *Alpha) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &Alpha{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*1\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &Alpha{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -499,7 +529,7 @@ func (p *Alpha) Opaque() bool {\n \treturn true\n }\n \n-// NewAlpha returns a new Alpha with the given width and height.\n+// NewAlpha returns a new Alpha with the given bounds.\n func NewAlpha(r Rectangle) *Alpha {\n \tw, h := r.Dx(), r.Dy()\n \tpix := make([]uint8, 1*w*h)\n@@ -525,15 +555,21 @@ func (p *Alpha16) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.Alpha16{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+\ti := p.PixOffset(x, y)\n \treturn color.Alpha16{uint16(p.Pix[i+0])<<8 | uint16(p.Pix[i+1])}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *Alpha16) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+}\n+\n func (p *Alpha16) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+\ti := p.PixOffset(x, y)\n \tc1 := color.Alpha16Model.Convert(c).(color.Alpha16)\n \tp.Pix[i+0] = uint8(c1.A >> 8)\n \tp.Pix[i+1] = uint8(c1.A)\n@@ -543,7 +579,7 @@ func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i+0] = uint8(c.A >> 8)\n \tp.Pix[i+1] = uint8(c.A)\n }\n@@ -558,7 +594,7 @@ func (p *Alpha16) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &Alpha16{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*2\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &Alpha16{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -584,7 +620,7 @@ func (p *Alpha16) Opaque() bool {\n \treturn true\n }\n \n-// NewAlpha16 returns a new Alpha16 with the given width and height.\n+// NewAlpha16 returns a new Alpha16 with the given bounds.\n func NewAlpha16(r Rectangle) *Alpha16 {\n \tw, h := r.Dx(), r.Dy()\n \tpix := make([]uint8, 2*w*h)\n@@ -610,23 +646,29 @@ func (p *Gray) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.Gray{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \treturn color.Gray{p.Pix[i]}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *Gray) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*1\n+}\n+\n func (p *Gray) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i] = color.GrayModel.Convert(c).(color.Gray).Y\n }\n \n func (p *Gray) SetGray(x, y int, c color.Gray) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i] = c.Y\n }\n \n@@ -640,7 +682,7 @@ func (p *Gray) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &Gray{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*1\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &Gray{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -653,7 +695,7 @@ func (p *Gray) Opaque() bool {\n \treturn true\n }\n \n-// NewGray returns a new Gray with the given width and height.\n+// NewGray returns a new Gray with the given bounds.\n func NewGray(r Rectangle) *Gray {\n \tw, h := r.Dx(), r.Dy()\n \tpix := make([]uint8, 1*w*h)\n@@ -679,15 +721,21 @@ func (p *Gray16) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.Gray16{}\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+\ti := p.PixOffset(x, y)\n \treturn color.Gray16{uint16(p.Pix[i+0])<<8 | uint16(p.Pix[i+1])}\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *Gray16) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+}\n+\n func (p *Gray16) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+\ti := p.PixOffset(x, y)\n \tc1 := color.Gray16Model.Convert(c).(color.Gray16)\n \tp.Pix[i+0] = uint8(c1.Y >> 8)\n \tp.Pix[i+1] = uint8(c1.Y)\n@@ -697,7 +745,7 @@ func (p *Gray16) SetGray16(x, y int, c color.Gray16) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*2\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i+0] = uint8(c.Y >> 8)\n \tp.Pix[i+1] = uint8(c.Y)\n }\n@@ -712,7 +760,7 @@ func (p *Gray16) SubImage(r Rectangle) Image {\n \tif r.Empty() {\n \t\treturn &Gray16{}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*2\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &Gray16{\n \t\tPix:    p.Pix[i:],\n \t\tStride: p.Stride,\n@@ -725,7 +773,7 @@ func (p *Gray16) Opaque() bool {\n \treturn true\n }\n \n-// NewGray16 returns a new Gray16 with the given width and height.\n+// NewGray16 returns a new Gray16 with the given bounds.\n func NewGray16(r Rectangle) *Gray16 {\n \tw, h := r.Dx(), r.Dy()\n \tpix := make([]uint8, 2*w*h)\n@@ -756,31 +804,37 @@ func (p *Paletted) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn p.Palette[0]\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \treturn p.Palette[p.Pix[i]]\n }\n \n+// PixOffset returns the index of the first element of Pix that corresponds to\n+// the pixel at (x, y).\n+func (p *Paletted) PixOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*1\n+}\n+\n func (p *Paletted) Set(x, y int, c color.Color) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i] = uint8(p.Palette.Index(c))\n }\n \n func (p *Paletted) ColorIndexAt(x, y int) uint8 {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn 0\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \treturn p.Pix[i]\n }\n \n func (p *Paletted) SetColorIndex(x, y int, index uint8) {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn\n \t}\n-\ti := (y-p.Rect.Min.Y)*p.Stride + (x - p.Rect.Min.X)\n+\ti := p.PixOffset(x, y)\n \tp.Pix[i] = index\n }\n \n@@ -796,7 +850,7 @@ func (p *Paletted) SubImage(r Rectangle) Image {\n \t\t\tPalette: p.Palette,\n \t\t}\n \t}\n-\ti := (r.Min.Y-p.Rect.Min.Y)*p.Stride + (r.Min.X-p.Rect.Min.X)*1\n+\ti := p.PixOffset(r.Min.X, r.Min.Y)\n \treturn &Paletted{\n \t\tPix:     p.Pix[i:],\n \t\tStride:  p.Stride,"}, {"sha": "2e412ad171626a399f7bb91338bc6053c3509574", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -203,8 +203,7 @@ func (d *decoder) makeImg(h0, v0, mxx, myy int) {\n \t\treturn\n \t}\n \tvar subsampleRatio image.YCbCrSubsampleRatio\n-\tn := h0 * v0\n-\tswitch n {\n+\tswitch h0 * v0 {\n \tcase 1:\n \t\tsubsampleRatio = image.YCbCrSubsampleRatio444\n \tcase 2:\n@@ -214,16 +213,8 @@ func (d *decoder) makeImg(h0, v0, mxx, myy int) {\n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}\n-\tb := make([]byte, mxx*myy*(1*8*8*n+2*8*8))\n-\td.img3 = &image.YCbCr{\n-\t\tY:              b[mxx*myy*(0*8*8*n+0*8*8) : mxx*myy*(1*8*8*n+0*8*8)],\n-\t\tCb:             b[mxx*myy*(1*8*8*n+0*8*8) : mxx*myy*(1*8*8*n+1*8*8)],\n-\t\tCr:             b[mxx*myy*(1*8*8*n+1*8*8) : mxx*myy*(1*8*8*n+2*8*8)],\n-\t\tSubsampleRatio: subsampleRatio,\n-\t\tYStride:        mxx * 8 * h0,\n-\t\tCStride:        mxx * 8,\n-\t\tRect:           image.Rect(0, 0, d.width, d.height),\n-\t}\n+\tm := image.NewYCbCr(image.Rect(0, 0, 8*h0*mxx, 8*v0*myy), subsampleRatio)\n+\td.img3 = m.SubImage(image.Rect(0, 0, d.width, d.height)).(*image.YCbCr)\n }\n \n // Specified in section B.2.3."}, {"sha": "dc5a87a9fb93e1cb844dec1eeae8dfb901300000", "filename": "libgo/go/image/tiff/reader.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -223,8 +223,8 @@ func (d *decoder) decode(dst image.Image, ymin, ymax int) error {\n \t\t}\n \tcase mRGB:\n \t\timg := dst.(*image.RGBA)\n-\t\tmin := (ymin-img.Rect.Min.Y)*img.Stride - img.Rect.Min.X*4\n-\t\tmax := (ymax-img.Rect.Min.Y)*img.Stride - img.Rect.Min.X*4\n+\t\tmin := img.PixOffset(0, ymin)\n+\t\tmax := img.PixOffset(0, ymax)\n \t\tvar off int\n \t\tfor i := min; i < max; i += 4 {\n \t\t\timg.Pix[i+0] = d.buf[off+0]\n@@ -235,16 +235,16 @@ func (d *decoder) decode(dst image.Image, ymin, ymax int) error {\n \t\t}\n \tcase mNRGBA:\n \t\timg := dst.(*image.NRGBA)\n-\t\tmin := (ymin-img.Rect.Min.Y)*img.Stride - img.Rect.Min.X*4\n-\t\tmax := (ymax-img.Rect.Min.Y)*img.Stride - img.Rect.Min.X*4\n+\t\tmin := img.PixOffset(0, ymin)\n+\t\tmax := img.PixOffset(0, ymax)\n \t\tif len(d.buf) != max-min {\n \t\t\treturn FormatError(\"short data strip\")\n \t\t}\n \t\tcopy(img.Pix[min:max], d.buf)\n \tcase mRGBA:\n \t\timg := dst.(*image.RGBA)\n-\t\tmin := (ymin-img.Rect.Min.Y)*img.Stride - img.Rect.Min.X*4\n-\t\tmax := (ymax-img.Rect.Min.Y)*img.Stride - img.Rect.Min.X*4\n+\t\tmin := img.PixOffset(0, ymin)\n+\t\tmax := img.PixOffset(0, ymax)\n \t\tif len(d.buf) != max-min {\n \t\t\treturn FormatError(\"short data strip\")\n \t\t}"}, {"sha": "c1a0b666f8308935f061e398e49137330b4fda2b", "filename": "libgo/go/image/ycbcr.go", "status": "modified", "additions": 81, "deletions": 24, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -17,6 +17,18 @@ const (\n \tYCbCrSubsampleRatio420\n )\n \n+func (s YCbCrSubsampleRatio) String() string {\n+\tswitch s {\n+\tcase YCbCrSubsampleRatio444:\n+\t\treturn \"YCbCrSubsampleRatio444\"\n+\tcase YCbCrSubsampleRatio422:\n+\t\treturn \"YCbCrSubsampleRatio422\"\n+\tcase YCbCrSubsampleRatio420:\n+\t\treturn \"YCbCrSubsampleRatio420\"\n+\t}\n+\treturn \"YCbCrSubsampleRatioUnknown\"\n+}\n+\n // YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per\n // pixel, but each Cb and Cr sample can span one or more pixels.\n // YStride is the Y slice index delta between vertically adjacent pixels.\n@@ -28,9 +40,7 @@ const (\n //\tFor 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2.\n //\tFor 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4.\n type YCbCr struct {\n-\tY              []uint8\n-\tCb             []uint8\n-\tCr             []uint8\n+\tY, Cb, Cr      []uint8\n \tYStride        int\n \tCStride        int\n \tSubsampleRatio YCbCrSubsampleRatio\n@@ -49,39 +59,86 @@ func (p *YCbCr) At(x, y int) color.Color {\n \tif !(Point{x, y}.In(p.Rect)) {\n \t\treturn color.YCbCr{}\n \t}\n+\tyi := p.YOffset(x, y)\n+\tci := p.COffset(x, y)\n+\treturn color.YCbCr{\n+\t\tp.Y[yi],\n+\t\tp.Cb[ci],\n+\t\tp.Cr[ci],\n+\t}\n+}\n+\n+// YOffset returns the index of the first element of Y that corresponds to\n+// the pixel at (x, y).\n+func (p *YCbCr) YOffset(x, y int) int {\n+\treturn (y-p.Rect.Min.Y)*p.YStride + (x - p.Rect.Min.X)\n+}\n+\n+// COffset returns the index of the first element of Cb or Cr that corresponds\n+// to the pixel at (x, y).\n+func (p *YCbCr) COffset(x, y int) int {\n \tswitch p.SubsampleRatio {\n \tcase YCbCrSubsampleRatio422:\n-\t\ti := x / 2\n-\t\treturn color.YCbCr{\n-\t\t\tp.Y[y*p.YStride+x],\n-\t\t\tp.Cb[y*p.CStride+i],\n-\t\t\tp.Cr[y*p.CStride+i],\n-\t\t}\n+\t\treturn (y-p.Rect.Min.Y)*p.CStride + (x/2 - p.Rect.Min.X/2)\n \tcase YCbCrSubsampleRatio420:\n-\t\ti, j := x/2, y/2\n-\t\treturn color.YCbCr{\n-\t\t\tp.Y[y*p.YStride+x],\n-\t\t\tp.Cb[j*p.CStride+i],\n-\t\t\tp.Cr[j*p.CStride+i],\n-\t\t}\n+\t\treturn (y/2-p.Rect.Min.Y/2)*p.CStride + (x/2 - p.Rect.Min.X/2)\n \t}\n \t// Default to 4:4:4 subsampling.\n-\treturn color.YCbCr{\n-\t\tp.Y[y*p.YStride+x],\n-\t\tp.Cb[y*p.CStride+x],\n-\t\tp.Cr[y*p.CStride+x],\n-\t}\n+\treturn (y-p.Rect.Min.Y)*p.CStride + (x - p.Rect.Min.X)\n }\n \n // SubImage returns an image representing the portion of the image p visible\n // through r. The returned value shares pixels with the original image.\n func (p *YCbCr) SubImage(r Rectangle) Image {\n-\tq := new(YCbCr)\n-\t*q = *p\n-\tq.Rect = q.Rect.Intersect(r)\n-\treturn q\n+\tr = r.Intersect(p.Rect)\n+\t// If r1 and r2 are Rectangles, r1.Intersect(r2) is not guaranteed to be inside\n+\t// either r1 or r2 if the intersection is empty. Without explicitly checking for\n+\t// this, the Pix[i:] expression below can panic.\n+\tif r.Empty() {\n+\t\treturn &YCbCr{\n+\t\t\tSubsampleRatio: p.SubsampleRatio,\n+\t\t}\n+\t}\n+\tyi := p.YOffset(r.Min.X, r.Min.Y)\n+\tci := p.COffset(r.Min.X, r.Min.Y)\n+\treturn &YCbCr{\n+\t\tY:              p.Y[yi:],\n+\t\tCb:             p.Cb[ci:],\n+\t\tCr:             p.Cr[ci:],\n+\t\tSubsampleRatio: p.SubsampleRatio,\n+\t\tYStride:        p.YStride,\n+\t\tCStride:        p.CStride,\n+\t\tRect:           r,\n+\t}\n }\n \n func (p *YCbCr) Opaque() bool {\n \treturn true\n }\n+\n+// NewYCbCr returns a new YCbCr with the given bounds and subsample ratio.\n+func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr {\n+\tw, h, cw, ch := r.Dx(), r.Dy(), 0, 0\n+\tswitch subsampleRatio {\n+\tcase YCbCrSubsampleRatio422:\n+\t\tcw = (r.Max.X+1)/2 - r.Min.X/2\n+\t\tch = h\n+\tcase YCbCrSubsampleRatio420:\n+\t\tcw = (r.Max.X+1)/2 - r.Min.X/2\n+\t\tch = (r.Max.Y+1)/2 - r.Min.Y/2\n+\tdefault:\n+\t\t// Default to 4:4:4 subsampling.\n+\t\tcw = w\n+\t\tch = h\n+\t}\n+\tb := make([]byte, w*h+2*cw*ch)\n+\treturn &YCbCr{\n+\t\tY:              b[:w*h],\n+\t\tCb:             b[w*h+0*cw*ch : w*h+1*cw*ch],\n+\t\tCr:             b[w*h+1*cw*ch : w*h+2*cw*ch],\n+\t\tSubsampleRatio: subsampleRatio,\n+\t\tYStride:        w,\n+\t\tCStride:        cw,\n+\t\tRect:           r,\n+\t}\n+}"}, {"sha": "eb8b1950bfef6165367b732ad637af5e97cb48c2", "filename": "libgo/go/image/ycbcr_test.go", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fycbcr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fimage%2Fycbcr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package image_test\n+\n+import (\n+\t. \"image\"\n+\t\"image/color\"\n+\t\"testing\"\n+)\n+\n+func TestYCbCr(t *testing.T) {\n+\trects := []Rectangle{\n+\t\tRect(0, 0, 16, 16),\n+\t\tRect(1, 0, 16, 16),\n+\t\tRect(0, 1, 16, 16),\n+\t\tRect(1, 1, 16, 16),\n+\t\tRect(1, 1, 15, 16),\n+\t\tRect(1, 1, 16, 15),\n+\t\tRect(1, 1, 15, 15),\n+\t\tRect(2, 3, 14, 15),\n+\t\tRect(7, 0, 7, 16),\n+\t\tRect(0, 8, 16, 8),\n+\t\tRect(0, 0, 10, 11),\n+\t\tRect(5, 6, 16, 16),\n+\t\tRect(7, 7, 8, 8),\n+\t\tRect(7, 8, 8, 9),\n+\t\tRect(8, 7, 9, 8),\n+\t\tRect(8, 8, 9, 9),\n+\t\tRect(7, 7, 17, 17),\n+\t\tRect(8, 8, 17, 17),\n+\t\tRect(9, 9, 17, 17),\n+\t\tRect(10, 10, 17, 17),\n+\t}\n+\tsubsampleRatios := []YCbCrSubsampleRatio{\n+\t\tYCbCrSubsampleRatio444,\n+\t\tYCbCrSubsampleRatio422,\n+\t\tYCbCrSubsampleRatio420,\n+\t}\n+\tdeltas := []Point{\n+\t\tPt(0, 0),\n+\t\tPt(1000, 1001),\n+\t\tPt(5001, -400),\n+\t\tPt(-701, -801),\n+\t}\n+\tfor _, r := range rects {\n+\t\tfor _, subsampleRatio := range subsampleRatios {\n+\t\t\tfor _, delta := range deltas {\n+\t\t\t\ttestYCbCr(t, r, subsampleRatio, delta)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func testYCbCr(t *testing.T, r Rectangle, subsampleRatio YCbCrSubsampleRatio, delta Point) {\n+\t// Create a YCbCr image m, whose bounds are r translated by (delta.X, delta.Y).\n+\tr1 := r.Add(delta)\n+\tm := NewYCbCr(r1, subsampleRatio)\n+\n+\t// Test that the image buffer is reasonably small even if (delta.X, delta.Y) is far from the origin.\n+\tif len(m.Y) > 100*100 {\n+\t\tt.Errorf(\"r=%v, subsampleRatio=%v, delta=%v: image buffer is too large\",\n+\t\t\tr, subsampleRatio, delta)\n+\t\treturn\n+\t}\n+\n+\t// Initialize m's pixels. For 422 and 420 subsampling, some of the Cb and Cr elements\n+\t// will be set multiple times. That's OK. We just want to avoid a uniform image.\n+\tfor y := r1.Min.Y; y < r1.Max.Y; y++ {\n+\t\tfor x := r1.Min.X; x < r1.Max.X; x++ {\n+\t\t\tyi := m.YOffset(x, y)\n+\t\t\tci := m.COffset(x, y)\n+\t\t\tm.Y[yi] = uint8(16*y + x)\n+\t\t\tm.Cb[ci] = uint8(y + 16*x)\n+\t\t\tm.Cr[ci] = uint8(y + 16*x)\n+\t\t}\n+\t}\n+\n+\t// Make various sub-images of m.\n+\tfor y0 := delta.Y + 3; y0 < delta.Y+7; y0++ {\n+\t\tfor y1 := delta.Y + 8; y1 < delta.Y+13; y1++ {\n+\t\t\tfor x0 := delta.X + 3; x0 < delta.X+7; x0++ {\n+\t\t\t\tfor x1 := delta.X + 8; x1 < delta.X+13; x1++ {\n+\t\t\t\t\tsubRect := Rect(x0, y0, x1, y1)\n+\t\t\t\t\tsub := m.SubImage(subRect).(*YCbCr)\n+\n+\t\t\t\t\t// For each point in the sub-image's bounds, check that m.At(x, y) equals sub.At(x, y).\n+\t\t\t\t\tfor y := sub.Rect.Min.Y; y < sub.Rect.Max.Y; y++ {\n+\t\t\t\t\t\tfor x := sub.Rect.Min.X; x < sub.Rect.Max.X; x++ {\n+\t\t\t\t\t\t\tcolor0 := m.At(x, y).(color.YCbCr)\n+\t\t\t\t\t\t\tcolor1 := sub.At(x, y).(color.YCbCr)\n+\t\t\t\t\t\t\tif color0 != color1 {\n+\t\t\t\t\t\t\t\tt.Errorf(\"r=%v, subsampleRatio=%v, delta=%v, x=%d, y=%d, color0=%v, color1=%v\",\n+\t\t\t\t\t\t\t\t\tr, subsampleRatio, delta, x, y, color0, color1)\n+\t\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "65f4b3ac2e57725f2b08c89472823df1f4a8792d", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -50,7 +50,7 @@ func ReadFile(filename string) ([]byte, error) {\n // WriteFile writes data to a file named by filename.\n // If the file does not exist, WriteFile creates it with permissions perm;\n // otherwise WriteFile truncates it before writing.\n-func WriteFile(filename string, data []byte, perm uint32) error {\n+func WriteFile(filename string, data []byte, perm os.FileMode) error {\n \tf, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n \tif err != nil {\n \t\treturn err"}, {"sha": "b9793e91abd712e729773474b26e8bfdc956046d", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"log\"\n \t\"net\"\n \t\"testing\"\n+\t\"time\"\n )\n \n var serverAddr string\n@@ -31,7 +32,7 @@ func startServer(done chan<- string) {\n \t\tlog.Fatalf(\"net.ListenPacket failed udp :0 %v\", e)\n \t}\n \tserverAddr = c.LocalAddr().String()\n-\tc.SetReadTimeout(100e6) // 100ms\n+\tc.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n \tgo runSyslog(c, done)\n }\n "}, {"sha": "8955219203075efc02465776f8548d2a3bd82f60", "filename": "libgo/go/math/rand/rand.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Frand%2Frand.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -107,7 +107,9 @@ func (r *Rand) Perm(n int) []int {\n \n var globalRand = New(&lockedSource{src: NewSource(1)})\n \n-// Seed uses the provided seed value to initialize the generator to a deterministic state.\n+// Seed uses the provided seed value to initialize the generator to a\n+// deterministic state. If Seed is not called, the generator behaves as\n+// if seeded by Seed(1).\n func Seed(seed int64) { globalRand.Seed(seed) }\n \n // Int63 returns a non-negative pseudo-random 63-bit integer as an int64."}, {"sha": "0ba8f98c4965ba493511c213783eff819d4687fe", "filename": "libgo/go/math/rand/rand_test.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmath%2Frand%2Frand_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmath%2Frand%2Frand_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Frand%2Frand_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -131,8 +131,14 @@ func TestStandardNormalValues(t *testing.T) {\n }\n \n func TestNonStandardNormalValues(t *testing.T) {\n-\tfor sd := 0.5; sd < 1000; sd *= 2 {\n-\t\tfor m := 0.5; m < 1000; m *= 2 {\n+\tsdmax := 1000.0\n+\tmmax := 1000.0\n+\tif testing.Short() {\n+\t\tsdmax = 5\n+\t\tmmax = 5\n+\t}\n+\tfor sd := 0.5; sd < sdmax; sd *= 2 {\n+\t\tfor m := 0.5; m < mmax; m *= 2 {\n \t\t\tfor _, seed := range testSeeds {\n \t\t\t\ttestNormalDistribution(t, numTestSamples, m, sd, seed)\n \t\t\t}"}, {"sha": "41844c25f2af595f8e5b419939089734517c95e9", "filename": "libgo/go/mime/mediatype.go", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmime%2Fmediatype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmime%2Fmediatype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -12,17 +12,22 @@ import (\n \t\"unicode\"\n )\n \n-// FormatMediaType serializes type t, subtype sub and the paramaters\n-// param as a media type conform RFC 2045 and RFC 2616.\n-// The type, subtype, and parameter names are written in lower-case.\n+// FormatMediaType serializes mediatype t and the parameters\n+// param as a media type conforming to RFC 2045 and RFC 2616.\n+// The type and parameter names are written in lower-case.\n // When any of the arguments result in a standard violation then\n // FormatMediaType returns the empty string.\n-func FormatMediaType(t, sub string, param map[string]string) string {\n-\tif !(IsToken(t) && IsToken(sub)) {\n+func FormatMediaType(t string, param map[string]string) string {\n+\tslash := strings.Index(t, \"/\")\n+\tif slash == -1 {\n+\t\treturn \"\"\n+\t}\n+\tmajor, sub := t[:slash], t[slash+1:]\n+\tif !IsToken(major) || !IsToken(sub) {\n \t\treturn \"\"\n \t}\n \tvar b bytes.Buffer\n-\tb.WriteString(strings.ToLower(t))\n+\tb.WriteString(strings.ToLower(major))\n \tb.WriteByte('/')\n \tb.WriteString(strings.ToLower(sub))\n "}, {"sha": "64ab29134157217699ffd1a2a217045e04c1803c", "filename": "libgo/go/mime/mediatype_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmime%2Fmediatype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmime%2Fmediatype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -253,3 +253,24 @@ func TestParseMediaTypeBogus(t *testing.T) {\n \t\tt.Errorf(\"expected invalid media parameter; got error %q\", err)\n \t}\n }\n+\n+type formatTest struct {\n+\ttyp    string\n+\tparams map[string]string\n+\twant   string\n+}\n+\n+var formatTests = []formatTest{\n+\t{\"noslash\", nil, \"\"},\n+\t{\"foo/BAR\", nil, \"foo/bar\"},\n+\t{\"foo/BAR\", map[string]string{\"X\": \"Y\"}, \"foo/bar; x=Y\"},\n+}\n+\n+func TestFormatMediaType(t *testing.T) {\n+\tfor i, tt := range formatTests {\n+\t\tgot := FormatMediaType(tt.typ, tt.params)\n+\t\tif got != tt.want {\n+\t\t\tt.Errorf(\"%d. FormatMediaType(%q, %v) = %q; want %q\", i, tt.typ, tt.params, got, tt.want)\n+\t\t}\n+\t}\n+}"}, {"sha": "00cff263bad95646190c43d735584526d6e610d7", "filename": "libgo/go/mime/type.go", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fmime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -62,21 +62,14 @@ func AddExtensionType(ext, typ string) error {\n }\n \n func setExtensionType(extension, mimeType string) error {\n-\tfull, param, err := ParseMediaType(mimeType)\n+\t_, param, err := ParseMediaType(mimeType)\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif split := strings.Index(full, \"/\"); split < 0 {\n-\t\treturn fmt.Errorf(`mime: malformed MIME type \"%s\"`, mimeType)\n-\t} else {\n-\t\tmain := full[:split]\n-\t\tsub := full[split+1:]\n-\t\tif main == \"text\" && param[\"charset\"] == \"\" {\n-\t\t\tparam[\"charset\"] = \"utf-8\"\n-\t\t}\n-\t\tmimeType = FormatMediaType(main, sub, param)\n+\tif strings.HasPrefix(mimeType, \"text/\") && param[\"charset\"] == \"\" {\n+\t\tparam[\"charset\"] = \"utf-8\"\n+\t\tmimeType = FormatMediaType(mimeType, param)\n \t}\n-\n \tmimeLock.Lock()\n \tmimeTypes[extension] = mimeType\n \tmimeLock.Unlock()"}, {"sha": "18c39360e40454ad6302adf57f65e6cd0ab2c580", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -45,7 +45,11 @@ func exchange(cfg *dnsConfig, c Conn, name string, qtype uint16) (*dnsMsg, error\n \t\t\treturn nil, err\n \t\t}\n \n-\t\tc.SetReadTimeout(int64(cfg.timeout) * 1e9) // nanoseconds\n+\t\tif cfg.timeout == 0 {\n+\t\t\tc.SetReadDeadline(time.Time{})\n+\t\t} else {\n+\t\t\tc.SetReadDeadline(time.Now().Add(time.Duration(cfg.timeout) * time.Second))\n+\t\t}\n \n \t\tbuf := make([]byte, 2000) // More than enough.\n \t\tn, err = c.Read(buf)"}, {"sha": "3a44e528eb22dd8f1d7bc80fff1c0b81dee7c547", "filename": "libgo/go/net/doc.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdoc.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+// LookupHost looks up the given host using the local resolver.\n+// It returns an array of that host's addresses.\n+func LookupHost(host string) (addrs []string, err error) {\n+\treturn lookupHost(host)\n+}\n+\n+// LookupIP looks up host using the local resolver.\n+// It returns an array of that host's IPv4 and IPv6 addresses.\n+func LookupIP(host string) (addrs []IP, err error) {\n+\treturn lookupIP(host)\n+}\n+\n+// LookupPort looks up the port for the given network and service.\n+func LookupPort(network, service string) (port int, err error) {\n+\treturn lookupPort(network, service)\n+}\n+\n+// LookupCNAME returns the canonical DNS host for the given name.\n+// Callers that do not care about the canonical name can call\n+// LookupHost or LookupIP directly; both take care of resolving\n+// the canonical name as part of the lookup.\n+func LookupCNAME(name string) (cname string, err error) {\n+\treturn lookupCNAME(name)\n+}\n+\n+// LookupSRV tries to resolve an SRV query of the given service,\n+// protocol, and domain name.  The proto is \"tcp\" or \"udp\".\n+// The returned records are sorted by priority and randomized\n+// by weight within a priority.\n+//\n+// LookupSRV constructs the DNS name to look up following RFC 2782.\n+// That is, it looks up _service._proto.name.  To accommodate services\n+// publishing SRV records under non-standard names, if both service\n+// and proto are empty strings, LookupSRV looks up name directly.\n+func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n+\treturn lookupSRV(service, proto, name)\n+}\n+\n+// LookupMX returns the DNS MX records for the given domain name sorted by preference.\n+func LookupMX(name string) (mx []*MX, err error) {\n+\treturn lookupMX(name)\n+}\n+\n+// LookupTXT returns the DNS TXT records for the given domain name.\n+func LookupTXT(name string) (txt []string, err error) {\n+\treturn lookupTXT(name)\n+}\n+\n+// LookupAddr performs a reverse lookup for the given address, returning a list\n+// of names mapping to that address.\n+func LookupAddr(addr string) (name []string, err error) {\n+\treturn lookupAddr(addr)\n+}"}, {"sha": "7ecd135d20645c9ffa87e140336b1008e0756b47", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 9, "deletions": 46, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -24,7 +24,7 @@ type netFD struct {\n \t// immutable until Close\n \tsysfd   int\n \tfamily  int\n-\tproto   int\n+\tsotype  int\n \tsysfile *os.File\n \tcr      chan bool\n \tcw      chan bool\n@@ -33,12 +33,10 @@ type netFD struct {\n \traddr   Addr\n \n \t// owned by client\n-\trdeadline_delta int64\n-\trdeadline       int64\n-\trio             sync.Mutex\n-\twdeadline_delta int64\n-\twdeadline       int64\n-\twio             sync.Mutex\n+\trdeadline int64\n+\trio       sync.Mutex\n+\twdeadline int64\n+\twio       sync.Mutex\n \n \t// owned by fd wait server\n \tncr, ncw int\n@@ -276,15 +274,15 @@ func startServer() {\n \tpollserver = p\n }\n \n-func newFD(fd, family, proto int, net string) (f *netFD, err error) {\n+func newFD(fd, family, sotype int, net string) (f *netFD, err error) {\n \tonceStartServer.Do(startServer)\n \tif e := syscall.SetNonblock(fd, true); e != nil {\n \t\treturn nil, e\n \t}\n \tf = &netFD{\n \t\tsysfd:  fd,\n \t\tfamily: family,\n-\t\tproto:  proto,\n+\t\tsotype: sotype,\n \t\tnet:    net,\n \t}\n \tf.cr = make(chan bool, 1)\n@@ -388,11 +386,6 @@ func (fd *netFD) Read(p []byte) (n int, err error) {\n \tif fd.sysfile == nil {\n \t\treturn 0, os.EINVAL\n \t}\n-\tif fd.rdeadline_delta > 0 {\n-\t\tfd.rdeadline = pollserver.Now() + fd.rdeadline_delta\n-\t} else {\n-\t\tfd.rdeadline = 0\n-\t}\n \tfor {\n \t\tn, err = syscall.Read(fd.sysfile.Fd(), p)\n \t\tif err == syscall.EAGAIN {\n@@ -404,7 +397,7 @@ func (fd *netFD) Read(p []byte) (n int, err error) {\n \t\t}\n \t\tif err != nil {\n \t\t\tn = 0\n-\t\t} else if n == 0 && err == nil && fd.proto != syscall.SOCK_DGRAM {\n+\t\t} else if n == 0 && err == nil && fd.sotype != syscall.SOCK_DGRAM {\n \t\t\terr = io.EOF\n \t\t}\n \t\tbreak\n@@ -423,11 +416,6 @@ func (fd *netFD) ReadFrom(p []byte) (n int, sa syscall.Sockaddr, err error) {\n \tdefer fd.rio.Unlock()\n \tfd.incref()\n \tdefer fd.decref()\n-\tif fd.rdeadline_delta > 0 {\n-\t\tfd.rdeadline = pollserver.Now() + fd.rdeadline_delta\n-\t} else {\n-\t\tfd.rdeadline = 0\n-\t}\n \tfor {\n \t\tn, sa, err = syscall.Recvfrom(fd.sysfd, p, 0)\n \t\tif err == syscall.EAGAIN {\n@@ -456,11 +444,6 @@ func (fd *netFD) ReadMsg(p []byte, oob []byte) (n, oobn, flags int, sa syscall.S\n \tdefer fd.rio.Unlock()\n \tfd.incref()\n \tdefer fd.decref()\n-\tif fd.rdeadline_delta > 0 {\n-\t\tfd.rdeadline = pollserver.Now() + fd.rdeadline_delta\n-\t} else {\n-\t\tfd.rdeadline = 0\n-\t}\n \tfor {\n \t\tn, oobn, flags, sa, err = syscall.Recvmsg(fd.sysfd, p, oob, 0)\n \t\tif err == syscall.EAGAIN {\n@@ -493,11 +476,6 @@ func (fd *netFD) Write(p []byte) (n int, err error) {\n \tif fd.sysfile == nil {\n \t\treturn 0, os.EINVAL\n \t}\n-\tif fd.wdeadline_delta > 0 {\n-\t\tfd.wdeadline = pollserver.Now() + fd.wdeadline_delta\n-\t} else {\n-\t\tfd.wdeadline = 0\n-\t}\n \tnn := 0\n \n \tfor {\n@@ -539,11 +517,6 @@ func (fd *netFD) WriteTo(p []byte, sa syscall.Sockaddr) (n int, err error) {\n \tdefer fd.wio.Unlock()\n \tfd.incref()\n \tdefer fd.decref()\n-\tif fd.wdeadline_delta > 0 {\n-\t\tfd.wdeadline = pollserver.Now() + fd.wdeadline_delta\n-\t} else {\n-\t\tfd.wdeadline = 0\n-\t}\n \tfor {\n \t\terr = syscall.Sendto(fd.sysfd, p, 0, sa)\n \t\tif err == syscall.EAGAIN {\n@@ -571,11 +544,6 @@ func (fd *netFD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oob\n \tdefer fd.wio.Unlock()\n \tfd.incref()\n \tdefer fd.decref()\n-\tif fd.wdeadline_delta > 0 {\n-\t\tfd.wdeadline = pollserver.Now() + fd.wdeadline_delta\n-\t} else {\n-\t\tfd.wdeadline = 0\n-\t}\n \tfor {\n \t\terr = syscall.Sendmsg(fd.sysfd, p, oob, sa, 0)\n \t\tif err == syscall.EAGAIN {\n@@ -603,11 +571,6 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \n \tfd.incref()\n \tdefer fd.decref()\n-\tif fd.rdeadline_delta > 0 {\n-\t\tfd.rdeadline = pollserver.Now() + fd.rdeadline_delta\n-\t} else {\n-\t\tfd.rdeadline = 0\n-\t}\n \n \t// See ../syscall/exec.go for description of ForkLock.\n \t// It is okay to hold the lock across syscall.Accept\n@@ -636,7 +599,7 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n-\tif nfd, err = newFD(s, fd.family, fd.proto, fd.net); err != nil {\n+\tif nfd, err = newFD(s, fd.family, fd.sotype, fd.net); err != nil {\n \t\tsyscall.Close(s)\n \t\treturn nil, err\n \t}"}, {"sha": "6e37b4eb6f1a26e231ab239754c3039a89504536", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -150,12 +150,13 @@ func (s *ioSrv) ProcessRemoteIO() {\n }\n \n // ExecIO executes a single io operation. It either executes it\n-// inline, or, if timeouts are employed, passes the request onto\n+// inline, or, if a deadline is employed, passes the request onto\n // a special goroutine and waits for completion or cancels request.\n-func (s *ioSrv) ExecIO(oi anOpIface, deadline_delta int64) (n int, err error) {\n+// deadline is unix nanos.\n+func (s *ioSrv) ExecIO(oi anOpIface, deadline int64) (n int, err error) {\n \tvar e error\n \to := oi.Op()\n-\tif deadline_delta > 0 {\n+\tif deadline != 0 {\n \t\t// Send request to a special dedicated thread,\n \t\t// so it can stop the io with CancelIO later.\n \t\ts.submchan <- oi\n@@ -172,12 +173,17 @@ func (s *ioSrv) ExecIO(oi anOpIface, deadline_delta int64) (n int, err error) {\n \t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, e}\n \t}\n \t// Wait for our request to complete.\n-\t// TODO(rsc): This should stop the timer.\n \tvar r ioResult\n-\tif deadline_delta > 0 {\n+\tif deadline != 0 {\n+\t\tdt := deadline - time.Now().UnixNano()\n+\t\tif dt < 1 {\n+\t\t\tdt = 1\n+\t\t}\n+\t\ttimer := time.NewTimer(time.Duration(dt) * time.Nanosecond)\n+\t\tdefer timer.Stop()\n \t\tselect {\n \t\tcase r = <-o.resultc:\n-\t\tcase <-time.After(time.Duration(deadline_delta) * time.Nanosecond):\n+\t\tcase <-timer.C:\n \t\t\ts.canchan <- oi\n \t\t\t<-o.errnoc\n \t\t\tr = <-o.resultc\n@@ -224,27 +230,25 @@ type netFD struct {\n \t// immutable until Close\n \tsysfd   syscall.Handle\n \tfamily  int\n-\tproto   int\n+\tsotype  int\n \tnet     string\n \tladdr   Addr\n \traddr   Addr\n \tresultc [2]chan ioResult // read/write completion results\n \terrnoc  [2]chan error    // read/write submit or cancel operation errors\n \n \t// owned by client\n-\trdeadline_delta int64\n-\trdeadline       int64\n-\trio             sync.Mutex\n-\twdeadline_delta int64\n-\twdeadline       int64\n-\twio             sync.Mutex\n+\trdeadline int64\n+\trio       sync.Mutex\n+\twdeadline int64\n+\twio       sync.Mutex\n }\n \n-func allocFD(fd syscall.Handle, family, proto int, net string) (f *netFD) {\n+func allocFD(fd syscall.Handle, family, sotype int, net string) (f *netFD) {\n \tf = &netFD{\n \t\tsysfd:  fd,\n \t\tfamily: family,\n-\t\tproto:  proto,\n+\t\tsotype: sotype,\n \t\tnet:    net,\n \t}\n \truntime.SetFinalizer(f, (*netFD).Close)\n@@ -357,7 +361,7 @@ func (fd *netFD) Read(buf []byte) (n int, err error) {\n \t}\n \tvar o readOp\n \to.Init(fd, buf, 'r')\n-\tn, err = iosrv.ExecIO(&o, fd.rdeadline_delta)\n+\tn, err = iosrv.ExecIO(&o, fd.rdeadline)\n \tif err == nil && n == 0 {\n \t\terr = io.EOF\n \t}\n@@ -398,7 +402,7 @@ func (fd *netFD) ReadFrom(buf []byte) (n int, sa syscall.Sockaddr, err error) {\n \tvar o readFromOp\n \to.Init(fd, buf, 'r')\n \to.rsan = int32(unsafe.Sizeof(o.rsa))\n-\tn, err = iosrv.ExecIO(&o, fd.rdeadline_delta)\n+\tn, err = iosrv.ExecIO(&o, fd.rdeadline)\n \tif err != nil {\n \t\treturn 0, nil, err\n \t}\n@@ -434,7 +438,7 @@ func (fd *netFD) Write(buf []byte) (n int, err error) {\n \t}\n \tvar o writeOp\n \to.Init(fd, buf, 'w')\n-\treturn iosrv.ExecIO(&o, fd.wdeadline_delta)\n+\treturn iosrv.ExecIO(&o, fd.wdeadline)\n }\n \n // WriteTo to network.\n@@ -470,7 +474,7 @@ func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (n int, err error) {\n \tvar o writeToOp\n \to.Init(fd, buf, 'w')\n \to.sa = sa\n-\treturn iosrv.ExecIO(&o, fd.wdeadline_delta)\n+\treturn iosrv.ExecIO(&o, fd.wdeadline)\n }\n \n // Accept new network connections.\n@@ -502,7 +506,7 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \t// Get new socket.\n \t// See ../syscall/exec.go for description of ForkLock.\n \tsyscall.ForkLock.RLock()\n-\ts, e := syscall.Socket(fd.family, fd.proto, 0)\n+\ts, e := syscall.Socket(fd.family, fd.sotype, 0)\n \tif e != nil {\n \t\tsyscall.ForkLock.RUnlock()\n \t\treturn nil, e\n@@ -542,7 +546,7 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \tlsa, _ := lrsa.Sockaddr()\n \trsa, _ := rrsa.Sockaddr()\n \n-\tnfd = allocFD(s, fd.family, fd.proto, fd.net)\n+\tnfd = allocFD(s, fd.family, fd.sotype, fd.net)\n \tnfd.setAddr(toAddr(lsa), toAddr(rsa))\n \treturn nfd, nil\n }"}, {"sha": "73a9b6ea6811c105a2cc2430fc5f89ef91db97d4", "filename": "libgo/go/net/http/cgi/host.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -124,7 +124,7 @@ func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t\t\"GATEWAY_INTERFACE=CGI/1.1\",\n \t\t\"REQUEST_METHOD=\" + req.Method,\n \t\t\"QUERY_STRING=\" + req.URL.RawQuery,\n-\t\t\"REQUEST_URI=\" + req.URL.RawPath,\n+\t\t\"REQUEST_URI=\" + req.URL.RequestURI(),\n \t\t\"PATH_INFO=\" + pathInfo,\n \t\t\"SCRIPT_NAME=\" + root,\n \t\t\"SCRIPT_FILENAME=\" + h.Path,"}, {"sha": "b8dbdb4edd2b7b31006ba157683b098ad69fb5a4", "filename": "libgo/go/net/http/cgi/host_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -364,7 +364,7 @@ func TestCopyError(t *testing.T) {\n \tconn.Close()\n \n \ttries := 0\n-\tfor tries < 15 && childRunning() {\n+\tfor tries < 25 && childRunning() {\n \t\ttime.Sleep(50 * time.Millisecond * time.Duration(tries))\n \t\ttries++\n \t}"}, {"sha": "1d70672695c7ac1d717e7f119f4cd9b25c08b746", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -24,11 +24,13 @@ import (\n // The Client's Transport typically has internal state (cached\n // TCP connections), so Clients should be reused instead of created as\n // needed. Clients are safe for concurrent use by multiple goroutines.\n-//\n-// Client is not yet very configurable.\n type Client struct {\n-\tTransport RoundTripper // if nil, DefaultTransport is used\n+\t// Transport specifies the mechanism by which individual\n+\t// HTTP requests are made.\n+\t// If nil, DefaultTransport is used.\n+\tTransport RoundTripper\n \n+\t// CheckRedirect specifies the policy for handling redirects.\n \t// If CheckRedirect is not nil, the client calls it before\n \t// following an HTTP redirect. The arguments req and via\n \t// are the upcoming request and the requests made already,\n@@ -121,9 +123,8 @@ func send(req *Request, t RoundTripper) (resp *Response, err error) {\n \t\treq.Header = make(Header)\n \t}\n \n-\tinfo := req.URL.RawUserinfo\n-\tif len(info) > 0 {\n-\t\treq.Header.Set(\"Authorization\", \"Basic \"+base64.URLEncoding.EncodeToString([]byte(info)))\n+\tif u := req.URL.User; u != nil {\n+\t\treq.Header.Set(\"Authorization\", \"Basic \"+base64.URLEncoding.EncodeToString([]byte(u.String())))\n \t}\n \treturn t.RoundTrip(req)\n }\n@@ -213,11 +214,11 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfor _, cookie := range jar.Cookies(req.URL) {\n-\t\t\t\treq.AddCookie(cookie)\n-\t\t\t}\n \t\t}\n \n+\t\tfor _, cookie := range jar.Cookies(req.URL) {\n+\t\t\treq.AddCookie(cookie)\n+\t\t}\n \t\turlStr = req.URL.String()\n \t\tif r, err = send(req, c.Transport); err != nil {\n \t\t\tbreak"}, {"sha": "c74611011a819f7661d882e2de843628f2ffb1f0", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -18,6 +18,7 @@ import (\n \t\"net/url\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"testing\"\n )\n \n@@ -236,6 +237,92 @@ func TestRedirects(t *testing.T) {\n \t}\n }\n \n+var expectedCookies = []*Cookie{\n+\t&Cookie{Name: \"ChocolateChip\", Value: \"tasty\"},\n+\t&Cookie{Name: \"First\", Value: \"Hit\"},\n+\t&Cookie{Name: \"Second\", Value: \"Hit\"},\n+}\n+\n+var echoCookiesRedirectHandler = HandlerFunc(func(w ResponseWriter, r *Request) {\n+\tfor _, cookie := range r.Cookies() {\n+\t\tSetCookie(w, cookie)\n+\t}\n+\tif r.URL.Path == \"/\" {\n+\t\tSetCookie(w, expectedCookies[1])\n+\t\tRedirect(w, r, \"/second\", StatusMovedPermanently)\n+\t} else {\n+\t\tSetCookie(w, expectedCookies[2])\n+\t\tw.Write([]byte(\"hello\"))\n+\t}\n+})\n+\n+// Just enough correctness for our redirect tests. Uses the URL.Host as the\n+// scope of all cookies.\n+type TestJar struct {\n+\tm      sync.Mutex\n+\tperURL map[string][]*Cookie\n+}\n+\n+func (j *TestJar) SetCookies(u *url.URL, cookies []*Cookie) {\n+\tj.m.Lock()\n+\tdefer j.m.Unlock()\n+\tj.perURL[u.Host] = cookies\n+}\n+\n+func (j *TestJar) Cookies(u *url.URL) []*Cookie {\n+\tj.m.Lock()\n+\tdefer j.m.Unlock()\n+\treturn j.perURL[u.Host]\n+}\n+\n+func TestRedirectCookiesOnRequest(t *testing.T) {\n+\tvar ts *httptest.Server\n+\tts = httptest.NewServer(echoCookiesRedirectHandler)\n+\tdefer ts.Close()\n+\tc := &Client{}\n+\treq, _ := NewRequest(\"GET\", ts.URL, nil)\n+\treq.AddCookie(expectedCookies[0])\n+\t// TODO: Uncomment when an implementation of a RFC6265 cookie jar lands.\n+\t_ = c\n+\t// resp, _ := c.Do(req)\n+\t// matchReturnedCookies(t, expectedCookies, resp.Cookies())\n+\n+\treq, _ = NewRequest(\"GET\", ts.URL, nil)\n+\t// resp, _ = c.Do(req)\n+\t// matchReturnedCookies(t, expectedCookies[1:], resp.Cookies())\n+}\n+\n+func TestRedirectCookiesJar(t *testing.T) {\n+\tvar ts *httptest.Server\n+\tts = httptest.NewServer(echoCookiesRedirectHandler)\n+\tdefer ts.Close()\n+\tc := &Client{}\n+\tc.Jar = &TestJar{perURL: make(map[string][]*Cookie)}\n+\tu, _ := url.Parse(ts.URL)\n+\tc.Jar.SetCookies(u, []*Cookie{expectedCookies[0]})\n+\tresp, _ := c.Get(ts.URL)\n+\tmatchReturnedCookies(t, expectedCookies, resp.Cookies())\n+}\n+\n+func matchReturnedCookies(t *testing.T, expected, given []*Cookie) {\n+\tt.Logf(\"Received cookies: %v\", given)\n+\tif len(given) != len(expected) {\n+\t\tt.Errorf(\"Expected %d cookies, got %d\", len(expected), len(given))\n+\t}\n+\tfor _, ec := range expected {\n+\t\tfoundC := false\n+\t\tfor _, c := range given {\n+\t\t\tif ec.Name == c.Name && ec.Value == c.Value {\n+\t\t\t\tfoundC = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !foundC {\n+\t\t\tt.Errorf(\"Missing cookie %v\", ec)\n+\t\t}\n+\t}\n+}\n+\n func TestStreamingGet(t *testing.T) {\n \tsay := make(chan string)\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {"}, {"sha": "8962ed31e6a31b36fa0d79e9c666314a13bd4203", "filename": "libgo/go/net/http/doc.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -34,7 +34,8 @@ settings, create a Client:\n \tresp, err := client.Get(\"http://example.com\")\n \t// ...\n \n-\treq := http.NewRequest(\"GET\", \"http://example.com\", nil)\n+\treq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n+\t// ...\n \treq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n \tresp, err := client.Do(req)\n \t// ..."}, {"sha": "85cad3ec71b597cdbaef0ddb504d2e5e22326570", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -224,26 +224,24 @@ func TestEmptyDirOpenCWD(t *testing.T) {\n \n func TestServeFileContentType(t *testing.T) {\n \tconst ctype = \"icecream/chocolate\"\n-\toverride := false\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n-\t\tif override {\n+\t\tif r.FormValue(\"override\") == \"1\" {\n \t\t\tw.Header().Set(\"Content-Type\", ctype)\n \t\t}\n \t\tServeFile(w, r, \"testdata/file\")\n \t}))\n \tdefer ts.Close()\n-\tget := func(want string) {\n-\t\tresp, err := Get(ts.URL)\n+\tget := func(override, want string) {\n+\t\tresp, err := Get(ts.URL + \"?override=\" + override)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\tif h := resp.Header.Get(\"Content-Type\"); h != want {\n \t\t\tt.Errorf(\"Content-Type mismatch: got %q, want %q\", h, want)\n \t\t}\n \t}\n-\tget(\"text/plain; charset=utf-8\")\n-\toverride = true\n-\tget(ctype)\n+\tget(\"0\", \"text/plain; charset=utf-8\")\n+\tget(\"1\", ctype)\n }\n \n func TestServeFileMimeType(t *testing.T) {"}, {"sha": "b8a98ee42929b033497f74acb19719304ddf9298", "filename": "libgo/go/net/http/httputil/dump.go", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"net\"\n \t\"net/http\"\n \t\"strings\"\n+\t\"time\"\n )\n \n // One of the copies, say from b to r2, could be avoided by using a more\n@@ -36,12 +37,12 @@ type dumpConn struct {\n \tio.Reader\n }\n \n-func (c *dumpConn) Close() error                     { return nil }\n-func (c *dumpConn) LocalAddr() net.Addr              { return nil }\n-func (c *dumpConn) RemoteAddr() net.Addr             { return nil }\n-func (c *dumpConn) SetTimeout(nsec int64) error      { return nil }\n-func (c *dumpConn) SetReadTimeout(nsec int64) error  { return nil }\n-func (c *dumpConn) SetWriteTimeout(nsec int64) error { return nil }\n+func (c *dumpConn) Close() error                       { return nil }\n+func (c *dumpConn) LocalAddr() net.Addr                { return nil }\n+func (c *dumpConn) RemoteAddr() net.Addr               { return nil }\n+func (c *dumpConn) SetDeadline(t time.Time) error      { return nil }\n+func (c *dumpConn) SetReadDeadline(t time.Time) error  { return nil }\n+func (c *dumpConn) SetWriteDeadline(t time.Time) error { return nil }\n \n // DumpRequestOut is like DumpRequest but includes\n // headers that the standard http.Transport adds,\n@@ -124,16 +125,8 @@ func DumpRequest(req *http.Request, body bool) (dump []byte, err error) {\n \n \tvar b bytes.Buffer\n \n-\turlStr := req.URL.Raw\n-\tif urlStr == \"\" {\n-\t\turlStr = valueOrDefault(req.URL.EncodedPath(), \"/\")\n-\t\tif req.URL.RawQuery != \"\" {\n-\t\t\turlStr += \"?\" + req.URL.RawQuery\n-\t\t}\n-\t}\n-\n-\tfmt.Fprintf(&b, \"%s %s HTTP/%d.%d\\r\\n\", valueOrDefault(req.Method, \"GET\"), urlStr,\n-\t\treq.ProtoMajor, req.ProtoMinor)\n+\tfmt.Fprintf(&b, \"%s %s HTTP/%d.%d\\r\\n\", valueOrDefault(req.Method, \"GET\"),\n+\t\treq.URL.RequestURI(), req.ProtoMajor, req.ProtoMinor)\n \n \thost := req.Host\n \tif host == \"\" && req.URL != nil {"}, {"sha": "1072e2e342604bb47fa32812f45569f73821cab1", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -59,11 +59,6 @@ func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy {\n \t\treq.URL.Scheme = target.Scheme\n \t\treq.URL.Host = target.Host\n \t\treq.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)\n-\t\tif q := req.URL.RawQuery; q != \"\" {\n-\t\t\treq.URL.RawPath = req.URL.Path + \"?\" + q\n-\t\t} else {\n-\t\t\treq.URL.RawPath = req.URL.Path\n-\t\t}\n \t\treq.URL.RawQuery = target.RawQuery\n \t}\n \treturn &ReverseProxy{Director: director}"}, {"sha": "da3e4050fe11368b830df4b70bc62506507e2259", "filename": "libgo/go/net/http/readrequest_test.go", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -44,15 +44,9 @@ var reqTests = []reqTest{\n \t\t&Request{\n \t\t\tMethod: \"GET\",\n \t\t\tURL: &url.URL{\n-\t\t\t\tRaw:          \"http://www.techcrunch.com/\",\n-\t\t\t\tScheme:       \"http\",\n-\t\t\t\tRawPath:      \"/\",\n-\t\t\t\tRawAuthority: \"www.techcrunch.com\",\n-\t\t\t\tRawUserinfo:  \"\",\n-\t\t\t\tHost:         \"www.techcrunch.com\",\n-\t\t\t\tPath:         \"/\",\n-\t\t\t\tRawQuery:     \"\",\n-\t\t\t\tFragment:     \"\",\n+\t\t\t\tScheme: \"http\",\n+\t\t\t\tHost:   \"www.techcrunch.com\",\n+\t\t\t\tPath:   \"/\",\n \t\t\t},\n \t\t\tProto:      \"HTTP/1.1\",\n \t\t\tProtoMajor: 1,\n@@ -86,9 +80,7 @@ var reqTests = []reqTest{\n \t\t&Request{\n \t\t\tMethod: \"GET\",\n \t\t\tURL: &url.URL{\n-\t\t\t\tRaw:     \"/\",\n-\t\t\t\tPath:    \"/\",\n-\t\t\t\tRawPath: \"/\",\n+\t\t\t\tPath: \"/\",\n \t\t\t},\n \t\t\tProto:         \"HTTP/1.1\",\n \t\t\tProtoMajor:    1,\n@@ -113,15 +105,7 @@ var reqTests = []reqTest{\n \t\t&Request{\n \t\t\tMethod: \"GET\",\n \t\t\tURL: &url.URL{\n-\t\t\t\tRaw:          \"//user@host/is/actually/a/path/\",\n-\t\t\t\tScheme:       \"\",\n-\t\t\t\tRawPath:      \"//user@host/is/actually/a/path/\",\n-\t\t\t\tRawAuthority: \"\",\n-\t\t\t\tRawUserinfo:  \"\",\n-\t\t\t\tHost:         \"\",\n-\t\t\t\tPath:         \"//user@host/is/actually/a/path/\",\n-\t\t\t\tRawQuery:     \"\",\n-\t\t\t\tFragment:     \"\",\n+\t\t\t\tPath: \"//user@host/is/actually/a/path/\",\n \t\t\t},\n \t\t\tProto:         \"HTTP/1.1\",\n \t\t\tProtoMajor:    1,\n@@ -170,9 +154,7 @@ var reqTests = []reqTest{\n \t\t&Request{\n \t\t\tMethod: \"POST\",\n \t\t\tURL: &url.URL{\n-\t\t\t\tRaw:     \"/\",\n-\t\t\t\tPath:    \"/\",\n-\t\t\t\tRawPath: \"/\",\n+\t\t\t\tPath: \"/\",\n \t\t\t},\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t\tProto:            \"HTTP/1.1\","}, {"sha": "5a4e739073ac9278ef481c11d77bc6a37ddad9a6", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -302,26 +302,14 @@ func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) err\n \t\thost = req.URL.Host\n \t}\n \n-\turlStr := req.URL.RawPath\n-\tif strings.HasPrefix(urlStr, \"?\") {\n-\t\turlStr = \"/\" + urlStr // Issue 2344\n-\t}\n-\tif urlStr == \"\" {\n-\t\turlStr = valueOrDefault(req.URL.RawPath, valueOrDefault(req.URL.EncodedPath(), \"/\"))\n-\t\tif req.URL.RawQuery != \"\" {\n-\t\t\turlStr += \"?\" + req.URL.RawQuery\n-\t\t}\n-\t\tif usingProxy {\n-\t\t\tif urlStr == \"\" || urlStr[0] != '/' {\n-\t\t\t\turlStr = \"/\" + urlStr\n-\t\t\t}\n-\t\t\turlStr = req.URL.Scheme + \"://\" + host + urlStr\n-\t\t}\n+\truri := req.URL.RequestURI()\n+\tif usingProxy && req.URL.Scheme != \"\" && req.URL.Opaque == \"\" {\n+\t\truri = req.URL.Scheme + \"://\" + host + ruri\n \t}\n-\t// TODO(bradfitz): escape at least newlines in urlStr?\n+\t// TODO(bradfitz): escape at least newlines in ruri?\n \n \tbw := bufio.NewWriter(w)\n-\tfmt.Fprintf(bw, \"%s %s HTTP/1.1\\r\\n\", valueOrDefault(req.Method, \"GET\"), urlStr)\n+\tfmt.Fprintf(bw, \"%s %s HTTP/1.1\\r\\n\", valueOrDefault(req.Method, \"GET\"), ruri)\n \n \t// Header lines\n \tfmt.Fprintf(bw, \"Host: %s\\r\\n\", host)"}, {"sha": "fc3186f0c0cb49af50201385a17daefa3dd458a7", "filename": "libgo/go/net/http/requestwrite_test.go", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Frequestwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Frequestwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequestwrite_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -32,15 +32,9 @@ var reqWriteTests = []reqWriteTest{\n \t\tReq: Request{\n \t\t\tMethod: \"GET\",\n \t\t\tURL: &url.URL{\n-\t\t\t\tRaw:          \"http://www.techcrunch.com/\",\n-\t\t\t\tScheme:       \"http\",\n-\t\t\t\tRawPath:      \"http://www.techcrunch.com/\",\n-\t\t\t\tRawAuthority: \"www.techcrunch.com\",\n-\t\t\t\tRawUserinfo:  \"\",\n-\t\t\t\tHost:         \"www.techcrunch.com\",\n-\t\t\t\tPath:         \"/\",\n-\t\t\t\tRawQuery:     \"\",\n-\t\t\t\tFragment:     \"\",\n+\t\t\t\tScheme: \"http\",\n+\t\t\t\tHost:   \"www.techcrunch.com\",\n+\t\t\t\tPath:   \"/\",\n \t\t\t},\n \t\t\tProto:      \"HTTP/1.1\",\n \t\t\tProtoMajor: 1,\n@@ -60,7 +54,7 @@ var reqWriteTests = []reqWriteTest{\n \t\t\tForm:  map[string][]string{},\n \t\t},\n \n-\t\tWantWrite: \"GET http://www.techcrunch.com/ HTTP/1.1\\r\\n\" +\n+\t\tWantWrite: \"GET / HTTP/1.1\\r\\n\" +\n \t\t\t\"Host: www.techcrunch.com\\r\\n\" +\n \t\t\t\"User-Agent: Fake\\r\\n\" +\n \t\t\t\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\" +\n@@ -198,7 +192,7 @@ var reqWriteTests = []reqWriteTest{\n \t\t\t\"\\r\\n\" +\n \t\t\t\"abcdef\",\n \n-\t\tWantProxy: \"POST / HTTP/1.1\\r\\n\" +\n+\t\tWantProxy: \"POST http://example.com/ HTTP/1.1\\r\\n\" +\n \t\t\t\"Host: example.com\\r\\n\" +\n \t\t\t\"User-Agent: Go http package\\r\\n\" +\n \t\t\t\"Content-Length: 6\\r\\n\" +"}, {"sha": "147c216ec78744a1dd1036a3fed0fb676806a519", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -84,15 +84,15 @@ func (c *testConn) RemoteAddr() net.Addr {\n \treturn dummyAddr(\"remote-addr\")\n }\n \n-func (c *testConn) SetTimeout(nsec int64) error {\n+func (c *testConn) SetDeadline(t time.Time) error {\n \treturn nil\n }\n \n-func (c *testConn) SetReadTimeout(nsec int64) error {\n+func (c *testConn) SetReadDeadline(t time.Time) error {\n \treturn nil\n }\n \n-func (c *testConn) SetWriteTimeout(nsec int64) error {\n+func (c *testConn) SetWriteDeadline(t time.Time) error {\n \treturn nil\n }\n \n@@ -642,7 +642,7 @@ func TestServerExpect(t *testing.T) {\n \t\t// Note using r.FormValue(\"readbody\") because for POST\n \t\t// requests that would read from r.Body, which we only\n \t\t// conditionally want to do.\n-\t\tif strings.Contains(r.URL.RawPath, \"readbody=true\") {\n+\t\tif strings.Contains(r.URL.RawQuery, \"readbody=true\") {\n \t\t\tioutil.ReadAll(r.Body)\n \t\t\tw.Write([]byte(\"Hi\"))\n \t\t} else {\n@@ -904,24 +904,26 @@ func testHandlerPanic(t *testing.T, withHijack bool) {\n \t\tpanic(\"intentional death for testing\")\n \t}))\n \tdefer ts.Close()\n-\t_, err := Get(ts.URL)\n-\tif err == nil {\n-\t\tt.Logf(\"expected an error\")\n-\t}\n \n \t// Do a blocking read on the log output pipe so its logging\n \t// doesn't bleed into the next test.  But wait only 5 seconds\n \t// for it.\n-\tdone := make(chan bool)\n+\tdone := make(chan bool, 1)\n \tgo func() {\n-\t\tbuf := make([]byte, 1024)\n+\t\tbuf := make([]byte, 4<<10)\n \t\t_, err := pr.Read(buf)\n \t\tpr.Close()\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\tdone <- true\n \t}()\n+\n+\t_, err := Get(ts.URL)\n+\tif err == nil {\n+\t\tt.Logf(\"expected an error\")\n+\t}\n+\n \tselect {\n \tcase <-done:\n \t\treturn"}, {"sha": "bad3bcb28969c17d65e776897b00380a3d27cd89", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -569,14 +569,15 @@ func (c *conn) serve() {\n \t\tif err == nil {\n \t\t\treturn\n \t\t}\n-\t\tif c.rwc != nil { // may be nil if connection hijacked\n-\t\t\tc.rwc.Close()\n-\t\t}\n \n \t\tvar buf bytes.Buffer\n \t\tfmt.Fprintf(&buf, \"http: panic serving %v: %v\\n\", c.remoteAddr, err)\n \t\tbuf.Write(debug.Stack())\n \t\tlog.Print(buf.String())\n+\n+\t\tif c.rwc != nil { // may be nil if connection hijacked\n+\t\t\tc.rwc.Close()\n+\t\t}\n \t}()\n \n \tif tlsConn, ok := c.rwc.(*tls.Conn); ok {\n@@ -954,8 +955,8 @@ func Serve(l net.Listener, handler Handler) error {\n type Server struct {\n \tAddr           string        // TCP address to listen on, \":http\" if empty\n \tHandler        Handler       // handler to invoke, http.DefaultServeMux if nil\n-\tReadTimeout    time.Duration // the net.Conn.SetReadTimeout value for new connections\n-\tWriteTimeout   time.Duration // the net.Conn.SetWriteTimeout value for new connections\n+\tReadTimeout    time.Duration // maximum duration before timing out read of the request\n+\tWriteTimeout   time.Duration // maximum duration before timing out write of the response\n \tMaxHeaderBytes int           // maximum size of request headers, DefaultMaxHeaderBytes if 0\n }\n \n@@ -989,10 +990,10 @@ func (srv *Server) Serve(l net.Listener) error {\n \t\t\treturn e\n \t\t}\n \t\tif srv.ReadTimeout != 0 {\n-\t\t\trw.SetReadTimeout(srv.ReadTimeout.Nanoseconds())\n+\t\t\trw.SetReadDeadline(time.Now().Add(srv.ReadTimeout))\n \t\t}\n \t\tif srv.WriteTimeout != 0 {\n-\t\t\trw.SetWriteTimeout(srv.WriteTimeout.Nanoseconds())\n+\t\t\trw.SetWriteDeadline(time.Now().Add(srv.WriteTimeout))\n \t\t}\n \t\tc, err := srv.newConn(rw)\n \t\tif err != nil {"}, {"sha": "1b9ad1b85c55178264df1aa1bbb78739a7826f59", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -229,9 +229,8 @@ func (cm *connectMethod) proxyAuth() string {\n \tif cm.proxyURL == nil {\n \t\treturn \"\"\n \t}\n-\tproxyInfo := cm.proxyURL.RawUserinfo\n-\tif proxyInfo != \"\" {\n-\t\treturn \"Basic \" + base64.URLEncoding.EncodeToString([]byte(proxyInfo))\n+\tif u := cm.proxyURL.User; u != nil {\n+\t\treturn \"Basic \" + base64.URLEncoding.EncodeToString([]byte(u.String()))\n \t}\n \treturn \"\"\n }\n@@ -332,7 +331,7 @@ func (t *Transport) getConn(cm *connectMethod) (*persistConn, error) {\n \tcase cm.targetScheme == \"https\":\n \t\tconnectReq := &Request{\n \t\t\tMethod: \"CONNECT\",\n-\t\t\tURL:    &url.URL{RawPath: cm.targetAddr},\n+\t\t\tURL:    &url.URL{Opaque: cm.targetAddr},\n \t\t\tHost:   cm.targetAddr,\n \t\t\tHeader: make(Header),\n \t\t}"}, {"sha": "c74bfcd6c79c81b817c07d11745c6687b28a6fcc", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"flag\"\n \t\"os\"\n \t\"testing\"\n+\t\"time\"\n )\n \n const ICMP_ECHO_REQUEST = 8\n@@ -101,7 +102,7 @@ func TestICMP(t *testing.T) {\n \t\tt.Fatalf(`net.WriteToIP(..., %v) = %v, %v`, raddr, n, err)\n \t}\n \n-\tc.SetTimeout(100e6)\n+\tc.SetDeadline(time.Now().Add(100 * time.Millisecond))\n \tresp := make([]byte, 1024)\n \tfor {\n \t\tn, from, err := c.ReadFrom(resp)"}, {"sha": "58df607e3becd01f823d3b6d0c8d60641e967ab9", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -8,12 +8,28 @@ package net\n \n import (\n \t\"os\"\n+\t\"time\"\n )\n \n // IPConn is the implementation of the Conn and PacketConn\n // interfaces for IP network connections.\n type IPConn bool\n \n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *IPConn) SetDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *IPConn) SetReadDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *IPConn) SetWriteDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n // Implementation of the Conn interface - see Conn for documentation.\n \n // Read implements the net.Conn Read method.\n@@ -41,21 +57,6 @@ func (c *IPConn) RemoteAddr() Addr {\n \treturn nil\n }\n \n-// SetTimeout implements the net.Conn SetTimeout method.\n-func (c *IPConn) SetTimeout(nsec int64) error {\n-\treturn os.EPLAN9\n-}\n-\n-// SetReadTimeout implements the net.Conn SetReadTimeout method.\n-func (c *IPConn) SetReadTimeout(nsec int64) error {\n-\treturn os.EPLAN9\n-}\n-\n-// SetWriteTimeout implements the net.Conn SetWriteTimeout method.\n-func (c *IPConn) SetWriteTimeout(nsec int64) error {\n-\treturn os.EPLAN9\n-}\n-\n // IP-specific methods.\n \n // ReadFrom implements the net.PacketConn ReadFrom method.\n@@ -68,7 +69,7 @@ func (c *IPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n //\n // WriteToIP can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;\n-// see SetTimeout and SetWriteTimeout.\n+// see SetDeadline and SetWriteDeadline.\n // On packet-oriented connections, write timeouts are rare.\n func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (n int, err error) {\n \treturn 0, os.EPLAN9"}, {"sha": "e4f755bc785f049204dc97d9e17a416874b8a226", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"errors\"\n \t\"os\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n func sockaddrToIP(sa syscall.Sockaddr) Addr {\n@@ -97,28 +98,28 @@ func (c *IPConn) RemoteAddr() Addr {\n \treturn c.fd.raddr\n }\n \n-// SetTimeout implements the net.Conn SetTimeout method.\n-func (c *IPConn) SetTimeout(nsec int64) error {\n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *IPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setTimeout(c.fd, nsec)\n+\treturn setDeadline(c.fd, t)\n }\n \n-// SetReadTimeout implements the net.Conn SetReadTimeout method.\n-func (c *IPConn) SetReadTimeout(nsec int64) error {\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *IPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setReadTimeout(c.fd, nsec)\n+\treturn setReadDeadline(c.fd, t)\n }\n \n-// SetWriteTimeout implements the net.Conn SetWriteTimeout method.\n-func (c *IPConn) SetWriteTimeout(nsec int64) error {\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *IPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setWriteTimeout(c.fd, nsec)\n+\treturn setWriteDeadline(c.fd, t)\n }\n \n // SetReadBuffer sets the size of the operating system's\n@@ -146,8 +147,8 @@ func (c *IPConn) SetWriteBuffer(bytes int) error {\n // that was on the packet.\n //\n // ReadFromIP can be made to time out and return an error with\n-// Timeout() == true after a fixed time limit; see SetTimeout and\n-// SetReadTimeout.\n+// Timeout() == true after a fixed time limit; see SetDeadline and\n+// SetReadDeadline.\n func (c *IPConn) ReadFromIP(b []byte) (n int, addr *IPAddr, err error) {\n \tif !c.ok() {\n \t\treturn 0, nil, os.EINVAL\n@@ -182,7 +183,7 @@ func (c *IPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n //\n // WriteToIP can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;\n-// see SetTimeout and SetWriteTimeout.\n+// see SetDeadline and SetWriteDeadline.\n // On packet-oriented connections, write timeouts are rare.\n func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (n int, err error) {\n \tif !c.ok() {"}, {"sha": "09d8d6b4e040de926bda0b45ac65e30b5972388f", "filename": "libgo/go/net/ipsock_plan9.go", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"errors\"\n \t\"io\"\n \t\"os\"\n+\t\"time\"\n )\n \n // probeIPv6Stack returns two boolean values.  If the first boolean value is\n@@ -156,27 +157,18 @@ func (c *plan9Conn) RemoteAddr() Addr {\n \treturn c.raddr\n }\n \n-// SetTimeout implements the net.Conn SetTimeout method.\n-func (c *plan9Conn) SetTimeout(nsec int64) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n-\t}\n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *plan9Conn) SetDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetReadTimeout implements the net.Conn SetReadTimeout method.\n-func (c *plan9Conn) SetReadTimeout(nsec int64) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n-\t}\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *plan9Conn) SetReadDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetWriteTimeout implements the net.Conn SetWriteTimeout method.\n-func (c *plan9Conn) SetWriteTimeout(nsec int64) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n-\t}\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *plan9Conn) SetWriteDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n "}, {"sha": "3a059f516bcba10f14600c31b569e1768f7fc894", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -101,7 +101,7 @@ type sockaddr interface {\n \tfamily() int\n }\n \n-func internetSocket(net string, laddr, raddr sockaddr, socktype, proto int, mode string, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n+func internetSocket(net string, laddr, raddr sockaddr, sotype, proto int, mode string, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n \tvar oserr error\n \tvar la, ra syscall.Sockaddr\n \tfamily := favoriteAddrFamily(net, raddr, laddr, mode)\n@@ -115,7 +115,7 @@ func internetSocket(net string, laddr, raddr sockaddr, socktype, proto int, mode\n \t\t\tgoto Error\n \t\t}\n \t}\n-\tfd, oserr = socket(net, family, socktype, proto, la, ra, toAddr)\n+\tfd, oserr = socket(net, family, sotype, proto, la, ra, toAddr)\n \tif oserr != nil {\n \t\tgoto Error\n \t}"}, {"sha": "645aa6d2493e1762748e500da64235f7be42f0be", "filename": "libgo/go/net/lookup_plan9.go", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -69,9 +69,7 @@ func queryDNS(addr string, typ string) (res []string, err error) {\n \treturn query(\"/net/dns\", addr+\" \"+typ, 1024)\n }\n \n-// LookupHost looks up the given host using the local resolver.\n-// It returns an array of that host's addresses.\n-func LookupHost(host string) (addrs []string, err error) {\n+func lookupHost(host string) (addrs []string, err error) {\n \t// Use /net/cs insead of /net/dns because cs knows about\n \t// host names in local network (e.g. from /lib/ndb/local)\n \tlines, err := queryCS(\"tcp\", host, \"1\")\n@@ -95,9 +93,7 @@ func LookupHost(host string) (addrs []string, err error) {\n \treturn\n }\n \n-// LookupIP looks up host using the local resolver.\n-// It returns an array of that host's IPv4 and IPv6 addresses.\n-func LookupIP(host string) (ips []IP, err error) {\n+func lookupIP(host string) (ips []IP, err error) {\n \taddrs, err := LookupHost(host)\n \tif err != nil {\n \t\treturn\n@@ -110,8 +106,7 @@ func LookupIP(host string) (ips []IP, err error) {\n \treturn\n }\n \n-// LookupPort looks up the port for the given network and service.\n-func LookupPort(network, service string) (port int, err error) {\n+func lookupPort(network, service string) (port int, err error) {\n \tswitch network {\n \tcase \"tcp4\", \"tcp6\":\n \t\tnetwork = \"tcp\"\n@@ -140,11 +135,7 @@ func LookupPort(network, service string) (port int, err error) {\n \treturn 0, unknownPortError\n }\n \n-// LookupCNAME returns the canonical DNS host for the given name.\n-// Callers that do not care about the canonical name can call\n-// LookupHost or LookupIP directly; both take care of resolving\n-// the canonical name as part of the lookup.\n-func LookupCNAME(name string) (cname string, err error) {\n+func lookupCNAME(name string) (cname string, err error) {\n \tlines, err := queryDNS(name, \"cname\")\n \tif err != nil {\n \t\treturn\n@@ -157,16 +148,7 @@ func LookupCNAME(name string) (cname string, err error) {\n \treturn \"\", errors.New(\"net: bad response from ndb/dns\")\n }\n \n-// LookupSRV tries to resolve an SRV query of the given service,\n-// protocol, and domain name.  The proto is \"tcp\" or \"udp\".\n-// The returned records are sorted by priority and randomized\n-// by weight within a priority.\n-//\n-// LookupSRV constructs the DNS name to look up following RFC 2782.\n-// That is, it looks up _service._proto.name.  To accommodate services\n-// publishing SRV records under non-standard names, if both service\n-// and proto are empty strings, LookupSRV looks up name directly.\n-func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n+func lookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n \tvar target string\n \tif service == \"\" && proto == \"\" {\n \t\ttarget = name\n@@ -195,8 +177,7 @@ func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err err\n \treturn\n }\n \n-// LookupMX returns the DNS MX records for the given domain name sorted by preference.\n-func LookupMX(name string) (mx []*MX, err error) {\n+func lookupMX(name string) (mx []*MX, err error) {\n \tlines, err := queryDNS(name, \"mx\")\n \tif err != nil {\n \t\treturn\n@@ -214,8 +195,7 @@ func LookupMX(name string) (mx []*MX, err error) {\n \treturn\n }\n \n-// LookupTXT returns the DNS TXT records for the given domain name.\n-func LookupTXT(name string) (txt []string, err error) {\n+func lookupTXT(name string) (txt []string, err error) {\n \tlines, err := queryDNS(name, \"txt\")\n \tif err != nil {\n \t\treturn\n@@ -228,9 +208,7 @@ func LookupTXT(name string) (txt []string, err error) {\n \treturn\n }\n \n-// LookupAddr performs a reverse lookup for the given address, returning a list\n-// of names mapping to that address.\n-func LookupAddr(addr string) (name []string, err error) {\n+func lookupAddr(addr string) (name []string, err error) {\n \tarpa, err := reverseaddr(addr)\n \tif err != nil {\n \t\treturn"}, {"sha": "d500a1240d49de8993bba7fd0e29c65d2509e4e1", "filename": "libgo/go/net/lookup_unix.go", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_unix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -52,57 +52,39 @@ func lookupProtocol(name string) (proto int, err error) {\n \treturn\n }\n \n-// LookupHost looks up the given host using the local resolver.\n-// It returns an array of that host's addresses.\n-func LookupHost(host string) (addrs []string, err error) {\n+func lookupHost(host string) (addrs []string, err error) {\n \taddrs, err, ok := cgoLookupHost(host)\n \tif !ok {\n \t\taddrs, err = goLookupHost(host)\n \t}\n \treturn\n }\n \n-// LookupIP looks up host using the local resolver.\n-// It returns an array of that host's IPv4 and IPv6 addresses.\n-func LookupIP(host string) (addrs []IP, err error) {\n+func lookupIP(host string) (addrs []IP, err error) {\n \taddrs, err, ok := cgoLookupIP(host)\n \tif !ok {\n \t\taddrs, err = goLookupIP(host)\n \t}\n \treturn\n }\n \n-// LookupPort looks up the port for the given network and service.\n-func LookupPort(network, service string) (port int, err error) {\n+func lookupPort(network, service string) (port int, err error) {\n \tport, err, ok := cgoLookupPort(network, service)\n \tif !ok {\n \t\tport, err = goLookupPort(network, service)\n \t}\n \treturn\n }\n \n-// LookupCNAME returns the canonical DNS host for the given name.\n-// Callers that do not care about the canonical name can call\n-// LookupHost or LookupIP directly; both take care of resolving\n-// the canonical name as part of the lookup.\n-func LookupCNAME(name string) (cname string, err error) {\n+func lookupCNAME(name string) (cname string, err error) {\n \tcname, err, ok := cgoLookupCNAME(name)\n \tif !ok {\n \t\tcname, err = goLookupCNAME(name)\n \t}\n \treturn\n }\n \n-// LookupSRV tries to resolve an SRV query of the given service,\n-// protocol, and domain name.  The proto is \"tcp\" or \"udp\".\n-// The returned records are sorted by priority and randomized\n-// by weight within a priority.\n-//\n-// LookupSRV constructs the DNS name to look up following RFC 2782.\n-// That is, it looks up _service._proto.name.  To accommodate services\n-// publishing SRV records under non-standard names, if both service\n-// and proto are empty strings, LookupSRV looks up name directly.\n-func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n+func lookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n \tvar target string\n \tif service == \"\" && proto == \"\" {\n \t\ttarget = name\n@@ -123,8 +105,7 @@ func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err err\n \treturn\n }\n \n-// LookupMX returns the DNS MX records for the given domain name sorted by preference.\n-func LookupMX(name string) (mx []*MX, err error) {\n+func lookupMX(name string) (mx []*MX, err error) {\n \t_, records, err := lookup(name, dnsTypeMX)\n \tif err != nil {\n \t\treturn\n@@ -138,8 +119,7 @@ func LookupMX(name string) (mx []*MX, err error) {\n \treturn\n }\n \n-// LookupTXT returns the DNS TXT records for the given domain name.\n-func LookupTXT(name string) (txt []string, err error) {\n+func lookupTXT(name string) (txt []string, err error) {\n \t_, records, err := lookup(name, dnsTypeTXT)\n \tif err != nil {\n \t\treturn\n@@ -151,9 +131,7 @@ func LookupTXT(name string) (txt []string, err error) {\n \treturn\n }\n \n-// LookupAddr performs a reverse lookup for the given address, returning a list\n-// of names mapping to that address.\n-func LookupAddr(addr string) (name []string, err error) {\n+func lookupAddr(addr string) (name []string, err error) {\n \tname = lookupStaticAddr(addr)\n \tif len(name) > 0 {\n \t\treturn"}, {"sha": "dfe2ff6f1fa762447c9616fb51b634b31ec1f739", "filename": "libgo/go/net/lookup_windows.go", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Flookup_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Flookup_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_windows.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -28,7 +28,7 @@ func lookupProtocol(name string) (proto int, err error) {\n \treturn int(p.Proto), nil\n }\n \n-func LookupHost(name string) (addrs []string, err error) {\n+func lookupHost(name string) (addrs []string, err error) {\n \tips, err := LookupIP(name)\n \tif err != nil {\n \t\treturn\n@@ -40,7 +40,7 @@ func LookupHost(name string) (addrs []string, err error) {\n \treturn\n }\n \n-func LookupIP(name string) (addrs []IP, err error) {\n+func lookupIP(name string) (addrs []IP, err error) {\n \thostentLock.Lock()\n \tdefer hostentLock.Unlock()\n \th, e := syscall.GetHostByName(name)\n@@ -61,7 +61,7 @@ func LookupIP(name string) (addrs []IP, err error) {\n \treturn addrs, nil\n }\n \n-func LookupPort(network, service string) (port int, err error) {\n+func lookupPort(network, service string) (port int, err error) {\n \tswitch network {\n \tcase \"tcp4\", \"tcp6\":\n \t\tnetwork = \"tcp\"\n@@ -77,7 +77,7 @@ func LookupPort(network, service string) (port int, err error) {\n \treturn int(syscall.Ntohs(s.Port)), nil\n }\n \n-func LookupCNAME(name string) (cname string, err error) {\n+func lookupCNAME(name string) (cname string, err error) {\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(name, syscall.DNS_TYPE_CNAME, 0, nil, &r, nil)\n \tif e != nil {\n@@ -91,16 +91,7 @@ func LookupCNAME(name string) (cname string, err error) {\n \treturn\n }\n \n-// LookupSRV tries to resolve an SRV query of the given service,\n-// protocol, and domain name.  The proto is \"tcp\" or \"udp\".\n-// The returned records are sorted by priority and randomized\n-// by weight within a priority.\n-//\n-// LookupSRV constructs the DNS name to look up following RFC 2782.\n-// That is, it looks up _service._proto.name.  To accommodate services\n-// publishing SRV records under non-standard names, if both service\n-// and proto are empty strings, LookupSRV looks up name directly.\n-func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n+func lookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n \tvar target string\n \tif service == \"\" && proto == \"\" {\n \t\ttarget = name\n@@ -122,7 +113,7 @@ func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err err\n \treturn name, addrs, nil\n }\n \n-func LookupMX(name string) (mx []*MX, err error) {\n+func lookupMX(name string) (mx []*MX, err error) {\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(name, syscall.DNS_TYPE_MX, 0, nil, &r, nil)\n \tif e != nil {\n@@ -138,7 +129,7 @@ func LookupMX(name string) (mx []*MX, err error) {\n \treturn mx, nil\n }\n \n-func LookupTXT(name string) (txt []string, err error) {\n+func lookupTXT(name string) (txt []string, err error) {\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(name, syscall.DNS_TYPE_TEXT, 0, nil, &r, nil)\n \tif e != nil {\n@@ -156,7 +147,7 @@ func LookupTXT(name string) (txt []string, err error) {\n \treturn\n }\n \n-func LookupAddr(addr string) (name []string, err error) {\n+func lookupAddr(addr string) (name []string, err error) {\n \tarpa, err := reverseaddr(addr)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "609fee242d0dbacdd77655b206888a2bbe707ef1", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,7 +9,10 @@ package net\n // TODO(rsc):\n //\tsupport for raw ethernet sockets\n \n-import \"errors\"\n+import (\n+\t\"errors\"\n+\t\"time\"\n+)\n \n // Addr represents a network end point address.\n type Addr interface {\n@@ -21,12 +24,12 @@ type Addr interface {\n type Conn interface {\n \t// Read reads data from the connection.\n \t// Read can be made to time out and return a net.Error with Timeout() == true\n-\t// after a fixed time limit; see SetTimeout and SetReadTimeout.\n+\t// after a fixed time limit; see SetDeadline and SetReadDeadline.\n \tRead(b []byte) (n int, err error)\n \n \t// Write writes data to the connection.\n \t// Write can be made to time out and return a net.Error with Timeout() == true\n-\t// after a fixed time limit; see SetTimeout and SetWriteTimeout.\n+\t// after a fixed time limit; see SetDeadline and SetWriteDeadline.\n \tWrite(b []byte) (n int, err error)\n \n \t// Close closes the connection.\n@@ -38,21 +41,23 @@ type Conn interface {\n \t// RemoteAddr returns the remote network address.\n \tRemoteAddr() Addr\n \n-\t// SetTimeout sets the read and write deadlines associated\n+\t// SetDeadline sets the read and write deadlines associated\n \t// with the connection.\n-\tSetTimeout(nsec int64) error\n-\n-\t// SetReadTimeout sets the time (in nanoseconds) that\n-\t// Read will wait for data before returning an error with Timeout() == true.\n-\t// Setting nsec == 0 (the default) disables the deadline.\n-\tSetReadTimeout(nsec int64) error\n-\n-\t// SetWriteTimeout sets the time (in nanoseconds) that\n-\t// Write will wait to send its data before returning an error with Timeout() == true.\n-\t// Setting nsec == 0 (the default) disables the deadline.\n+\tSetDeadline(t time.Time) error\n+\n+\t// SetReadDeadline sets the deadline for all Read calls to return.\n+\t// If the deadline is reached, Read will fail with a timeout\n+\t// (see type Error) instead of blocking.\n+\t// A zero value for t means Read will not time out.\n+\tSetReadDeadline(t time.Time) error\n+\n+\t// SetWriteDeadline sets the deadline for all Write calls to return.\n+\t// If the deadline is reached, Write will fail with a timeout\n+\t// (see type Error) instead of blocking.\n+\t// A zero value for t means Write will not time out.\n \t// Even if write times out, it may return n > 0, indicating that\n \t// some of the data was successfully written.\n-\tSetWriteTimeout(nsec int64) error\n+\tSetWriteDeadline(t time.Time) error\n }\n \n // An Error represents a network error.\n@@ -70,13 +75,13 @@ type PacketConn interface {\n \t// was on the packet.\n \t// ReadFrom can be made to time out and return\n \t// an error with Timeout() == true after a fixed time limit;\n-\t// see SetTimeout and SetReadTimeout.\n+\t// see SetDeadline and SetReadDeadline.\n \tReadFrom(b []byte) (n int, addr Addr, err error)\n \n \t// WriteTo writes a packet with payload b to addr.\n \t// WriteTo can be made to time out and return\n \t// an error with Timeout() == true after a fixed time limit;\n-\t// see SetTimeout and SetWriteTimeout.\n+\t// see SetDeadline and SetWriteDeadline.\n \t// On packet-oriented connections, write timeouts are rare.\n \tWriteTo(b []byte, addr Addr) (n int, err error)\n \n@@ -86,21 +91,23 @@ type PacketConn interface {\n \t// LocalAddr returns the local network address.\n \tLocalAddr() Addr\n \n-\t// SetTimeout sets the read and write deadlines associated\n+\t// SetDeadline sets the read and write deadlines associated\n \t// with the connection.\n-\tSetTimeout(nsec int64) error\n-\n-\t// SetReadTimeout sets the time (in nanoseconds) that\n-\t// Read will wait for data before returning an error with Timeout() == true.\n-\t// Setting nsec == 0 (the default) disables the deadline.\n-\tSetReadTimeout(nsec int64) error\n-\n-\t// SetWriteTimeout sets the time (in nanoseconds) that\n-\t// Write will wait to send its data before returning an error with Timeout() == true.\n-\t// Setting nsec == 0 (the default) disables the deadline.\n+\tSetDeadline(t time.Time) error\n+\n+\t// SetReadDeadline sets the deadline for all Read calls to return.\n+\t// If the deadline is reached, Read will fail with a timeout\n+\t// (see type Error) instead of blocking.\n+\t// A zero value for t means Read will not time out.\n+\tSetReadDeadline(t time.Time) error\n+\n+\t// SetWriteDeadline sets the deadline for all Write calls to return.\n+\t// If the deadline is reached, Write will fail with a timeout\n+\t// (see type Error) instead of blocking.\n+\t// A zero value for t means Write will not time out.\n \t// Even if write times out, it may return n > 0, indicating that\n \t// some of the data was successfully written.\n-\tSetWriteTimeout(nsec int64) error\n+\tSetWriteDeadline(t time.Time) error\n }\n \n // A Listener is a generic network listener for stream-oriented protocols."}, {"sha": "f1a2eca4e8847b4321af226e7c43a493d0cdeb81", "filename": "libgo/go/net/pipe.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fpipe.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -7,6 +7,7 @@ package net\n import (\n \t\"errors\"\n \t\"io\"\n+\t\"time\"\n )\n \n // Pipe creates a synchronous, in-memory, full duplex\n@@ -53,14 +54,14 @@ func (p *pipe) RemoteAddr() Addr {\n \treturn pipeAddr(0)\n }\n \n-func (p *pipe) SetTimeout(nsec int64) error {\n-\treturn errors.New(\"net.Pipe does not support timeouts\")\n+func (p *pipe) SetDeadline(t time.Time) error {\n+\treturn errors.New(\"net.Pipe does not support deadlines\")\n }\n \n-func (p *pipe) SetReadTimeout(nsec int64) error {\n-\treturn errors.New(\"net.Pipe does not support timeouts\")\n+func (p *pipe) SetReadDeadline(t time.Time) error {\n+\treturn errors.New(\"net.Pipe does not support deadlines\")\n }\n \n-func (p *pipe) SetWriteTimeout(nsec int64) error {\n-\treturn errors.New(\"net.Pipe does not support timeouts\")\n+func (p *pipe) SetWriteDeadline(t time.Time) error {\n+\treturn errors.New(\"net.Pipe does not support deadlines\")\n }"}, {"sha": "e9ab066663ea8619993dbdde5ac288a8c2707952", "filename": "libgo/go/net/sendfile_linux.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_linux.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -40,15 +40,6 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \tdefer c.wio.Unlock()\n \tc.incref()\n \tdefer c.decref()\n-\tif c.wdeadline_delta > 0 {\n-\t\t// This is a little odd that we're setting the timeout\n-\t\t// for the entire file but Write has the same issue\n-\t\t// (if one slurps the whole file into memory and\n-\t\t// do one large Write). At least they're consistent.\n-\t\tc.wdeadline = pollserver.Now() + c.wdeadline_delta\n-\t} else {\n-\t\tc.wdeadline = 0\n-\t}\n \n \tdst := c.sysfd\n \tsrc := f.Fd()"}, {"sha": "b0b546be32b7047d2dfd19023f3e6d818813fdaa", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n // Do not test empty datagrams by default.\n@@ -63,7 +64,7 @@ func connect(t *testing.T, network, addr string, isEmpty bool) {\n \tif err != nil {\n \t\tt.Fatalf(\"net.Dial(%q, %q) = _, %v\", network, addr, err)\n \t}\n-\tfd.SetReadTimeout(1e9) // 1s\n+\tfd.SetReadDeadline(time.Now().Add(1 * time.Second))\n \n \tvar b []byte\n \tif !isEmpty {\n@@ -91,7 +92,7 @@ func connect(t *testing.T, network, addr string, isEmpty bool) {\n }\n \n func doTest(t *testing.T, network, listenaddr, dialaddr string) {\n-\tt.Logf(\"Test %q %q %q\\n\", network, listenaddr, dialaddr)\n+\tt.Logf(\"Test %q %q %q\", network, listenaddr, dialaddr)\n \tswitch listenaddr {\n \tcase \"\", \"0.0.0.0\", \"[::]\", \"[::ffff:0.0.0.0]\":\n \t\tif testing.Short() || avoidMacFirewall {\n@@ -169,10 +170,10 @@ func runPacket(t *testing.T, network, addr string, listening chan<- string, done\n \t\tt.Fatalf(\"net.ListenPacket(%q, %q) = _, %v\", network, addr, err)\n \t}\n \tlistening <- c.LocalAddr().String()\n-\tc.SetReadTimeout(10e6) // 10ms\n \tvar buf [1000]byte\n Run:\n \tfor {\n+\t\tc.SetReadDeadline(time.Now().Add(10 * time.Millisecond))\n \t\tn, addr, err := c.ReadFrom(buf[0:])\n \t\tif e, ok := err.(Error); ok && e.Timeout() {\n \t\t\tselect {\n@@ -194,7 +195,7 @@ Run:\n }\n \n func doTestPacket(t *testing.T, network, listenaddr, dialaddr string, isEmpty bool) {\n-\tt.Logf(\"TestPacket %s %s %s\\n\", network, listenaddr, dialaddr)\n+\tt.Logf(\"TestPacket %q %q %q\", network, listenaddr, dialaddr)\n \tlistening := make(chan string)\n \tdone := make(chan int)\n \tif network == \"udp\" {"}, {"sha": "d401e3c21fd0721e87c0a66594328b2049dacd2b", "filename": "libgo/go/net/smtp/auth.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsmtp%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsmtp%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsmtp%2Fauth.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -6,6 +6,7 @@ package smtp\n \n import (\n \t\"crypto/hmac\"\n+\t\"crypto/md5\"\n \t\"errors\"\n \t\"fmt\"\n )\n@@ -88,7 +89,7 @@ func (a *cramMD5Auth) Start(server *ServerInfo) (string, []byte, error) {\n \n func (a *cramMD5Auth) Next(fromServer []byte, more bool) ([]byte, error) {\n \tif more {\n-\t\td := hmac.NewMD5([]byte(a.secret))\n+\t\td := hmac.New(md5.New, []byte(a.secret))\n \t\td.Write(fromServer)\n \t\ts := make([]byte, 0, d.Size())\n \t\treturn []byte(fmt.Sprintf(\"%s %x\", a.username, d.Sum(s))), nil"}, {"sha": "2f3210b428891c214dd31c002494c5638336b6e6", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -17,28 +17,28 @@ import (\n var listenerBacklog = maxListenerBacklog()\n \n // Generic socket creation.\n-func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n+func socket(net string, f, t, p int, la, ra syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n \t// See ../syscall/exec.go for description of ForkLock.\n \tsyscall.ForkLock.RLock()\n-\ts, e := syscall.Socket(f, p, t)\n+\ts, err := syscall.Socket(f, t, p)\n \tif err != nil {\n \t\tsyscall.ForkLock.RUnlock()\n \t\treturn nil, err\n \t}\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n-\tsetDefaultSockopts(s, f, p)\n+\tsetDefaultSockopts(s, f, t)\n \n \tif la != nil {\n-\t\te = syscall.Bind(s, la)\n-\t\tif e != nil {\n+\t\terr = syscall.Bind(s, la)\n+\t\tif err != nil {\n \t\t\tclosesocket(s)\n-\t\t\treturn nil, e\n+\t\t\treturn nil, err\n \t\t}\n \t}\n \n-\tif fd, err = newFD(s, f, p, net); err != nil {\n+\tif fd, err = newFD(s, f, t, net); err != nil {\n \t\tclosesocket(s)\n \t\treturn nil, err\n \t}"}, {"sha": "59f9af5f30adb334cec6a304476b4f22cf437fa2", "filename": "libgo/go/net/sockopt.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"bytes\"\n \t\"os\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n // Boolean to int.\n@@ -115,21 +116,21 @@ func setWriteBuffer(fd *netFD, bytes int) error {\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes))\n }\n \n-func setReadTimeout(fd *netFD, nsec int64) error {\n-\tfd.rdeadline_delta = nsec\n+func setReadDeadline(fd *netFD, t time.Time) error {\n+\tfd.rdeadline = t.UnixNano()\n \treturn nil\n }\n \n-func setWriteTimeout(fd *netFD, nsec int64) error {\n-\tfd.wdeadline_delta = nsec\n+func setWriteDeadline(fd *netFD, t time.Time) error {\n+\tfd.wdeadline = t.UnixNano()\n \treturn nil\n }\n \n-func setTimeout(fd *netFD, nsec int64) error {\n-\tif e := setReadTimeout(fd, nsec); e != nil {\n+func setDeadline(fd *netFD, t time.Time) error {\n+\tif e := setReadDeadline(fd, t); e != nil {\n \t\treturn e\n \t}\n-\treturn setWriteTimeout(fd, nsec)\n+\treturn setWriteDeadline(fd, t)\n }\n \n func setReuseAddr(fd *netFD, reuse bool) error {"}, {"sha": "2093e08127db5de47f40e16b3d9a015456af351c", "filename": "libgo/go/net/sockopt_bsd.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -12,14 +12,15 @@ import (\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s, f, p int) {\n+func setDefaultSockopts(s, f, t int) {\n \tswitch f {\n \tcase syscall.AF_INET6:\n \t\t// Allow both IP versions even if the OS default is otherwise.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n \n-\tif f == syscall.AF_UNIX || p == syscall.IPPROTO_TCP {\n+\tif f == syscall.AF_UNIX ||\n+\t\t(f == syscall.AF_INET || f == syscall.AF_INET6) && t == syscall.SOCK_STREAM {\n \t\t// Allow reuse of recently-used addresses.\n \t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n "}, {"sha": "9dbb4e5dde48042e494e30f1f36cad6f9e79a922", "filename": "libgo/go/net/sockopt_linux.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_linux.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -10,14 +10,15 @@ import (\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s, f, p int) {\n+func setDefaultSockopts(s, f, t int) {\n \tswitch f {\n \tcase syscall.AF_INET6:\n \t\t// Allow both IP versions even if the OS default is otherwise.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n \n-\tif f == syscall.AF_UNIX || p == syscall.IPPROTO_TCP {\n+\tif f == syscall.AF_UNIX ||\n+\t\t(f == syscall.AF_INET || f == syscall.AF_INET6) && t == syscall.SOCK_STREAM {\n \t\t// Allow reuse of recently-used addresses.\n \t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n \t}"}, {"sha": "a7b5606d865f607390b4e81649f8607f97ace830", "filename": "libgo/go/net/sockopt_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_windows.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s syscall.Handle, f, p int) {\n+func setDefaultSockopts(s syscall.Handle, f, t int) {\n \tswitch f {\n \tcase syscall.AF_INET6:\n \t\t// Allow both IP versions even if the OS default is otherwise."}, {"sha": "288ec056ab0e9e3dd659b0c94953be04ec1da5b1", "filename": "libgo/go/net/tcpsock_plan9.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -8,6 +8,7 @@ package net\n \n import (\n \t\"os\"\n+\t\"time\"\n )\n \n // TCPConn is an implementation of the Conn interface\n@@ -16,6 +17,21 @@ type TCPConn struct {\n \tplan9Conn\n }\n \n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *TCPConn) SetDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *TCPConn) SetReadDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *TCPConn) SetWriteDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n // CloseRead shuts down the reading side of the TCP connection.\n // Most callers should just use Close.\n func (c *TCPConn) CloseRead() error {"}, {"sha": "91816fa9d46c8ae302d2b8ef682e291a000e510a", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n // BUG(rsc): On OpenBSD, listening on the \"tcp\" network does not listen for\n@@ -134,28 +135,28 @@ func (c *TCPConn) RemoteAddr() Addr {\n \treturn c.fd.raddr\n }\n \n-// SetTimeout implements the net.Conn SetTimeout method.\n-func (c *TCPConn) SetTimeout(nsec int64) error {\n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *TCPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setTimeout(c.fd, nsec)\n+\treturn setDeadline(c.fd, t)\n }\n \n-// SetReadTimeout implements the net.Conn SetReadTimeout method.\n-func (c *TCPConn) SetReadTimeout(nsec int64) error {\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *TCPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setReadTimeout(c.fd, nsec)\n+\treturn setReadDeadline(c.fd, t)\n }\n \n-// SetWriteTimeout implements the net.Conn SetWriteTimeout method.\n-func (c *TCPConn) SetWriteTimeout(nsec int64) error {\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *TCPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setWriteTimeout(c.fd, nsec)\n+\treturn setWriteDeadline(c.fd, t)\n }\n \n // SetReadBuffer sets the size of the operating system's\n@@ -294,12 +295,13 @@ func (l *TCPListener) Close() error {\n // Addr returns the listener's network address, a *TCPAddr.\n func (l *TCPListener) Addr() Addr { return l.fd.laddr }\n \n-// SetTimeout sets the deadline associated with the listener\n-func (l *TCPListener) SetTimeout(nsec int64) error {\n+// SetDeadline sets the deadline associated with the listener.\n+// A zero time value disables the deadline.\n+func (l *TCPListener) SetDeadline(t time.Time) error {\n \tif l == nil || l.fd == nil {\n \t\treturn os.EINVAL\n \t}\n-\treturn setTimeout(l.fd, nsec)\n+\treturn setDeadline(l.fd, t)\n }\n \n // File returns a copy of the underlying os.File, set to blocking mode."}, {"sha": "11db012ff576393fbfeb8c27d2e4ffd7e15e2026", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -5,6 +5,7 @@\n package net\n \n import (\n+\t\"fmt\"\n \t\"runtime\"\n \t\"testing\"\n \t\"time\"\n@@ -17,26 +18,41 @@ func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n \t\treturn\n \t}\n \tdefer fd.Close()\n-\tt0 := time.Now()\n-\tfd.SetReadTimeout(1e8) // 100ms\n-\tvar b [100]byte\n-\tvar n int\n-\tvar err1 error\n-\tif readFrom {\n-\t\tn, _, err1 = fd.(PacketConn).ReadFrom(b[0:])\n-\t} else {\n-\t\tn, err1 = fd.Read(b[0:])\n-\t}\n-\tt1 := time.Now()\n \twhat := \"Read\"\n \tif readFrom {\n \t\twhat = \"ReadFrom\"\n \t}\n-\tif n != 0 || err1 == nil || !err1.(Error).Timeout() {\n-\t\tt.Errorf(\"fd.%s on %s %s did not return 0, timeout: %v, %v\", what, network, addr, n, err1)\n-\t}\n-\tif dt := t1.Sub(t0); dt < 50*time.Millisecond || dt > 150*time.Millisecond {\n-\t\tt.Errorf(\"fd.%s on %s %s took %s, expected 0.1s\", what, network, addr, dt)\n+\n+\terrc := make(chan error, 1)\n+\tgo func() {\n+\t\tt0 := time.Now()\n+\t\tfd.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\tvar b [100]byte\n+\t\tvar n int\n+\t\tvar err1 error\n+\t\tif readFrom {\n+\t\t\tn, _, err1 = fd.(PacketConn).ReadFrom(b[0:])\n+\t\t} else {\n+\t\t\tn, err1 = fd.Read(b[0:])\n+\t\t}\n+\t\tt1 := time.Now()\n+\t\tif n != 0 || err1 == nil || !err1.(Error).Timeout() {\n+\t\t\terrc <- fmt.Errorf(\"fd.%s on %s %s did not return 0, timeout: %v, %v\", what, network, addr, n, err1)\n+\t\t\treturn\n+\t\t}\n+\t\tif dt := t1.Sub(t0); dt < 50*time.Millisecond || dt > 250*time.Millisecond {\n+\t\t\terrc <- fmt.Errorf(\"fd.%s on %s %s took %s, expected 0.1s\", what, network, addr, dt)\n+\t\t\treturn\n+\t\t}\n+\t\terrc <- nil\n+\t}()\n+\tselect {\n+\tcase err := <-errc:\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\tcase <-time.After(1 * time.Second):\n+\t\tt.Errorf(\"%s on %s %s took over 1 second, expected 0.1s\", what, network, addr)\n \t}\n }\n "}, {"sha": "246c9ad94b5b50caaf51ac790bfa08401f380f1b", "filename": "libgo/go/net/udpsock_plan9.go", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,6 +9,7 @@ package net\n import (\n \t\"errors\"\n \t\"os\"\n+\t\"time\"\n )\n \n // UDPConn is the implementation of the Conn and PacketConn\n@@ -17,14 +18,29 @@ type UDPConn struct {\n \tplan9Conn\n }\n \n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *UDPConn) SetDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *UDPConn) SetReadDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n+\treturn os.EPLAN9\n+}\n+\n // UDP-specific methods.\n \n // ReadFromUDP reads a UDP packet from c, copying the payload into b.\n // It returns the number of bytes copied into b and the return address\n // that was on the packet.\n //\n // ReadFromUDP can be made to time out and return an error with Timeout() == true\n-// after a fixed time limit; see SetTimeout and SetReadTimeout.\n+// after a fixed time limit; see SetDeadline and SetReadDeadline.\n func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \tif !c.ok() {\n \t\treturn 0, nil, os.EINVAL\n@@ -62,7 +78,7 @@ func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n //\n // WriteToUDP can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;\n-// see SetTimeout and SetWriteTimeout.\n+// see SetDeadline and SetWriteDeadline.\n // On packet-oriented connections, write timeouts are rare.\n func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err error) {\n \tif !c.ok() {"}, {"sha": "0b5bc16f822f8fc95d7ba13d0bc589558f0c5c22", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -11,6 +11,7 @@ package net\n import (\n \t\"os\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n func sockaddrToUDP(sa syscall.Sockaddr) Addr {\n@@ -98,28 +99,28 @@ func (c *UDPConn) RemoteAddr() Addr {\n \treturn c.fd.raddr\n }\n \n-// SetTimeout implements the net.Conn SetTimeout method.\n-func (c *UDPConn) SetTimeout(nsec int64) error {\n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *UDPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setTimeout(c.fd, nsec)\n+\treturn setDeadline(c.fd, t)\n }\n \n-// SetReadTimeout implements the net.Conn SetReadTimeout method.\n-func (c *UDPConn) SetReadTimeout(nsec int64) error {\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *UDPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setReadTimeout(c.fd, nsec)\n+\treturn setReadDeadline(c.fd, t)\n }\n \n-// SetWriteTimeout implements the net.Conn SetWriteTimeout method.\n-func (c *UDPConn) SetWriteTimeout(nsec int64) error {\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setWriteTimeout(c.fd, nsec)\n+\treturn setWriteDeadline(c.fd, t)\n }\n \n // SetReadBuffer sets the size of the operating system's\n@@ -147,7 +148,7 @@ func (c *UDPConn) SetWriteBuffer(bytes int) error {\n // that was on the packet.\n //\n // ReadFromUDP can be made to time out and return an error with Timeout() == true\n-// after a fixed time limit; see SetTimeout and SetReadTimeout.\n+// after a fixed time limit; see SetDeadline and SetReadDeadline.\n func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \tif !c.ok() {\n \t\treturn 0, nil, os.EINVAL\n@@ -175,7 +176,7 @@ func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n //\n // WriteToUDP can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;\n-// see SetTimeout and SetWriteTimeout.\n+// see SetDeadline and SetWriteDeadline.\n // On packet-oriented connections, write timeouts are rare.\n func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err error) {\n \tif !c.ok() {"}, {"sha": "297276d3a7f6dc417d665e54d2656fd3424f6cb4", "filename": "libgo/go/net/unicast_test.go", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Funicast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Funicast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funicast_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -5,6 +5,7 @@\n package net\n \n import (\n+\t\"io\"\n \t\"runtime\"\n \t\"testing\"\n )\n@@ -15,42 +16,53 @@ var unicastTests = []struct {\n \tipv6   bool\n \tpacket bool\n }{\n-\t{\"tcp4\", \"127.0.0.1:0\", false, false},\n-\t{\"tcp6\", \"[::1]:0\", true, false},\n-\t{\"udp4\", \"127.0.0.1:0\", false, true},\n-\t{\"udp6\", \"[::1]:0\", true, true},\n+\t{net: \"tcp4\", laddr: \"127.0.0.1:0\"},\n+\t{net: \"tcp4\", laddr: \"previous\"},\n+\t{net: \"tcp6\", laddr: \"[::1]:0\", ipv6: true},\n+\t{net: \"tcp6\", laddr: \"previous\", ipv6: true},\n+\t{net: \"udp4\", laddr: \"127.0.0.1:0\", packet: true},\n+\t{net: \"udp6\", laddr: \"[::1]:0\", ipv6: true, packet: true},\n }\n \n func TestUnicastTCPAndUDP(t *testing.T) {\n \tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" {\n \t\treturn\n \t}\n \n+\tprevladdr := \"\"\n \tfor _, tt := range unicastTests {\n \t\tif tt.ipv6 && !supportsIPv6 {\n \t\t\tcontinue\n \t\t}\n-\t\tvar fd *netFD\n+\t\tvar (\n+\t\t\tfd     *netFD\n+\t\t\tcloser io.Closer\n+\t\t)\n \t\tif !tt.packet {\n-\t\t\tc, err := Listen(tt.net, tt.laddr)\n+\t\t\tif tt.laddr == \"previous\" {\n+\t\t\t\ttt.laddr = prevladdr\n+\t\t\t}\n+\t\t\tl, err := Listen(tt.net, tt.laddr)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"Listen failed: %v\", err)\n \t\t\t}\n-\t\t\tdefer c.Close()\n-\t\t\tfd = c.(*TCPListener).fd\n+\t\t\tprevladdr = l.Addr().String()\n+\t\t\tcloser = l\n+\t\t\tfd = l.(*TCPListener).fd\n \t\t} else {\n \t\t\tc, err := ListenPacket(tt.net, tt.laddr)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"ListenPacket failed: %v\", err)\n \t\t\t}\n-\t\t\tdefer c.Close()\n+\t\t\tcloser = c\n \t\t\tfd = c.(*UDPConn).fd\n \t\t}\n \t\tif !tt.ipv6 {\n \t\t\ttestIPv4UnicastSocketOptions(t, fd)\n \t\t} else {\n \t\t\ttestIPv6UnicastSocketOptions(t, fd)\n \t\t}\n+\t\tcloser.Close()\n \t}\n }\n "}, {"sha": "e8087d09a360943b05f79f983995f325e766f115", "filename": "libgo/go/net/unixsock_plan9.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -8,6 +8,7 @@ package net\n \n import (\n \t\"os\"\n+\t\"time\"\n )\n \n // UnixConn is an implementation of the Conn interface\n@@ -44,18 +45,18 @@ func (c *UnixConn) RemoteAddr() Addr {\n \treturn nil\n }\n \n-// SetTimeout implements the net.Conn SetTimeout method.\n-func (c *UnixConn) SetTimeout(nsec int64) error {\n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *UnixConn) SetDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetReadTimeout implements the net.Conn SetReadTimeout method.\n-func (c *UnixConn) SetReadTimeout(nsec int64) error {\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *UnixConn) SetReadDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetWriteTimeout implements the net.Conn SetWriteTimeout method.\n-func (c *UnixConn) SetWriteTimeout(nsec int64) error {\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n "}, {"sha": "5b8b2e4c7c67e76e2f0b2617cf3f3f6cb805bb2c", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -11,19 +11,20 @@ package net\n import (\n \t\"os\"\n \t\"syscall\"\n+\t\"time\"\n )\n \n func unixSocket(net string, laddr, raddr *UnixAddr, mode string) (fd *netFD, err error) {\n-\tvar proto int\n+\tvar sotype int\n \tswitch net {\n \tdefault:\n \t\treturn nil, UnknownNetworkError(net)\n \tcase \"unix\":\n-\t\tproto = syscall.SOCK_STREAM\n+\t\tsotype = syscall.SOCK_STREAM\n \tcase \"unixgram\":\n-\t\tproto = syscall.SOCK_DGRAM\n+\t\tsotype = syscall.SOCK_DGRAM\n \tcase \"unixpacket\":\n-\t\tproto = syscall.SOCK_SEQPACKET\n+\t\tsotype = syscall.SOCK_SEQPACKET\n \t}\n \n \tvar la, ra syscall.Sockaddr\n@@ -37,7 +38,7 @@ func unixSocket(net string, laddr, raddr *UnixAddr, mode string) (fd *netFD, err\n \t\t}\n \t\tif raddr != nil {\n \t\t\tra = &syscall.SockaddrUnix{Name: raddr.Name}\n-\t\t} else if proto != syscall.SOCK_DGRAM || laddr == nil {\n+\t\t} else if sotype != syscall.SOCK_DGRAM || laddr == nil {\n \t\t\treturn nil, &OpError{Op: mode, Net: net, Err: errMissingAddress}\n \t\t}\n \n@@ -52,13 +53,13 @@ func unixSocket(net string, laddr, raddr *UnixAddr, mode string) (fd *netFD, err\n \t}\n \n \tf := sockaddrToUnix\n-\tif proto == syscall.SOCK_DGRAM {\n+\tif sotype == syscall.SOCK_DGRAM {\n \t\tf = sockaddrToUnixgram\n-\t} else if proto == syscall.SOCK_SEQPACKET {\n+\t} else if sotype == syscall.SOCK_SEQPACKET {\n \t\tf = sockaddrToUnixpacket\n \t}\n \n-\tfd, oserr := socket(net, syscall.AF_UNIX, proto, 0, la, ra, f)\n+\tfd, oserr := socket(net, syscall.AF_UNIX, sotype, 0, la, ra, f)\n \tif oserr != nil {\n \t\tgoto Error\n \t}\n@@ -93,16 +94,16 @@ func sockaddrToUnixpacket(sa syscall.Sockaddr) Addr {\n \treturn nil\n }\n \n-func protoToNet(proto int) string {\n-\tswitch proto {\n+func sotypeToNet(sotype int) string {\n+\tswitch sotype {\n \tcase syscall.SOCK_STREAM:\n \t\treturn \"unix\"\n \tcase syscall.SOCK_SEQPACKET:\n \t\treturn \"unixpacket\"\n \tcase syscall.SOCK_DGRAM:\n \t\treturn \"unixgram\"\n \tdefault:\n-\t\tpanic(\"protoToNet unknown protocol\")\n+\t\tpanic(\"sotypeToNet unknown socket type\")\n \t}\n \treturn \"\"\n }\n@@ -164,28 +165,28 @@ func (c *UnixConn) RemoteAddr() Addr {\n \treturn c.fd.raddr\n }\n \n-// SetTimeout implements the net.Conn SetTimeout method.\n-func (c *UnixConn) SetTimeout(nsec int64) error {\n+// SetDeadline implements the net.Conn SetDeadline method.\n+func (c *UnixConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setTimeout(c.fd, nsec)\n+\treturn setDeadline(c.fd, t)\n }\n \n-// SetReadTimeout implements the net.Conn SetReadTimeout method.\n-func (c *UnixConn) SetReadTimeout(nsec int64) error {\n+// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+func (c *UnixConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setReadTimeout(c.fd, nsec)\n+\treturn setReadDeadline(c.fd, t)\n }\n \n-// SetWriteTimeout implements the net.Conn SetWriteTimeout method.\n-func (c *UnixConn) SetWriteTimeout(nsec int64) error {\n+// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n-\treturn setWriteTimeout(c.fd, nsec)\n+\treturn setWriteDeadline(c.fd, t)\n }\n \n // SetReadBuffer sets the size of the operating system's\n@@ -212,15 +213,15 @@ func (c *UnixConn) SetWriteBuffer(bytes int) error {\n //\n // ReadFromUnix can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;\n-// see SetTimeout and SetReadTimeout.\n+// see SetDeadline and SetReadDeadline.\n func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error) {\n \tif !c.ok() {\n \t\treturn 0, nil, os.EINVAL\n \t}\n \tn, sa, err := c.fd.ReadFrom(b)\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrUnix:\n-\t\taddr = &UnixAddr{sa.Name, protoToNet(c.fd.proto)}\n+\t\taddr = &UnixAddr{sa.Name, sotypeToNet(c.fd.sotype)}\n \t}\n \treturn\n }\n@@ -238,13 +239,13 @@ func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n //\n // WriteToUnix can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;\n-// see SetTimeout and SetWriteTimeout.\n+// see SetDeadline and SetWriteDeadline.\n // On packet-oriented connections, write timeouts are rare.\n func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n \t}\n-\tif addr.Net != protoToNet(c.fd.proto) {\n+\tif addr.Net != sotypeToNet(c.fd.sotype) {\n \t\treturn 0, os.EAFNOSUPPORT\n \t}\n \tsa := &syscall.SockaddrUnix{Name: addr.Name}\n@@ -270,7 +271,7 @@ func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAdd\n \tn, oobn, flags, sa, err := c.fd.ReadMsg(b, oob)\n \tswitch sa := sa.(type) {\n \tcase *syscall.SockaddrUnix:\n-\t\taddr = &UnixAddr{sa.Name, protoToNet(c.fd.proto)}\n+\t\taddr = &UnixAddr{sa.Name, sotypeToNet(c.fd.sotype)}\n \t}\n \treturn\n }\n@@ -280,7 +281,7 @@ func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err\n \t\treturn 0, 0, os.EINVAL\n \t}\n \tif addr != nil {\n-\t\tif addr.Net != protoToNet(c.fd.proto) {\n+\t\tif addr.Net != sotypeToNet(c.fd.sotype) {\n \t\t\treturn 0, 0, os.EAFNOSUPPORT\n \t\t}\n \t\tsa := &syscall.SockaddrUnix{Name: addr.Name}\n@@ -386,12 +387,13 @@ func (l *UnixListener) Close() error {\n // Addr returns the listener's network address.\n func (l *UnixListener) Addr() Addr { return l.fd.laddr }\n \n-// SetTimeout sets the deadline associated wuth the listener\n-func (l *UnixListener) SetTimeout(nsec int64) (err error) {\n+// SetDeadline sets the deadline associated with the listener.\n+// A zero time value disables the deadline.\n+func (l *UnixListener) SetDeadline(t time.Time) (err error) {\n \tif l == nil || l.fd == nil {\n \t\treturn os.EINVAL\n \t}\n-\treturn setTimeout(l.fd, nsec)\n+\treturn setDeadline(l.fd, t)\n }\n \n // File returns a copy of the underlying os.File, set to blocking mode."}, {"sha": "0068e98affa5fee73b615badc4d5cd147eefa156", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 163, "deletions": 184, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -52,7 +52,6 @@ const (\n \tencodeUserPassword\n \tencodeQueryComponent\n \tencodeFragment\n-\tencodeOpaque\n )\n \n type EscapeError string\n@@ -69,6 +68,7 @@ func shouldEscape(c byte, mode encoding) bool {\n \tif 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' {\n \t\treturn false\n \t}\n+\t// TODO: Update the character sets after RFC 3986.\n \tswitch c {\n \tcase '-', '_', '.', '!', '~', '*', '\\'', '(', ')': // \u00a72.3 Unreserved characters (mark)\n \t\treturn false\n@@ -78,12 +78,10 @@ func shouldEscape(c byte, mode encoding) bool {\n \t\t// the reserved characters to appear unescaped.\n \t\tswitch mode {\n \t\tcase encodePath: // \u00a73.3\n-\t\t\t// The RFC allows : @ & = + $ , but saves / ; for assigning\n-\t\t\t// meaning to individual path segments.  This package\n+\t\t\t// The RFC allows : @ & = + $ but saves / ; , for assigning\n+\t\t\t// meaning to individual path segments. This package\n \t\t\t// only manipulates the path as a whole, so we allow those\n-\t\t\t// last two as well.  Clients that need to distinguish between\n-\t\t\t// `/foo;y=z/bar` and `/foo%3by=z/bar` will have to re-decode RawPath.\n-\t\t\t// That leaves only ? to escape.\n+\t\t\t// last two as well. That leaves only ? to escape.\n \t\t\treturn c == '?'\n \n \t\tcase encodeUserPassword: // \u00a73.2.2\n@@ -99,12 +97,6 @@ func shouldEscape(c byte, mode encoding) bool {\n \t\t\t// The RFC text is silent but the grammar allows\n \t\t\t// everything, so escape nothing.\n \t\t\treturn false\n-\n-\t\tcase encodeOpaque: // \u00a73 opaque_part\n-\t\t\t// The RFC allows opaque_part to use all characters\n-\t\t\t// except that the leading / must be escaped.\n-\t\t\t// (We implement that case in String.)\n-\t\t\treturn false\n \t\t}\n \t}\n \n@@ -217,64 +209,73 @@ func escape(s string, mode encoding) string {\n \treturn string(t)\n }\n \n-// UnescapeUserinfo parses the RawUserinfo field of a URL\n-// as the form user or user:password and unescapes and returns\n-// the two halves.\n+// A URL represents a parsed URL (technically, a URI reference).\n+// The general form represented is:\n //\n-// This functionality should only be used with legacy web sites.\n-// RFC 2396 warns that interpreting Userinfo this way\n-// ``is NOT RECOMMENDED, because the passing of authentication\n-// information in clear text (such as URI) has proven to be a\n-// security risk in almost every case where it has been used.''\n-func UnescapeUserinfo(rawUserinfo string) (user, password string, err error) {\n-\tu, p := split(rawUserinfo, ':', true)\n-\tif user, err = unescape(u, encodeUserPassword); err != nil {\n-\t\treturn \"\", \"\", err\n-\t}\n-\tif password, err = unescape(p, encodeUserPassword); err != nil {\n-\t\treturn \"\", \"\", err\n-\t}\n-\treturn\n+//\tscheme://[userinfo@]host/path[?query][#fragment]\n+//\n+// URLs that do not start with a slash after the scheme are interpreted as:\n+//\n+//\tscheme:opaque[?query][#fragment]\n+//\n+type URL struct {\n+\tScheme   string\n+\tOpaque   string    // encoded opaque data\n+\tUser     *Userinfo // username and password information\n+\tHost     string\n+\tPath     string\n+\tRawQuery string // encoded query values, without '?'\n+\tFragment string // fragment for references, without '#'\n }\n \n-// EscapeUserinfo combines user and password in the form\n-// user:password (or just user if password is empty) and then\n-// escapes it for use as the URL.RawUserinfo field.\n-//\n+// User returns a Userinfo containing the provided username\n+// and no password set.\n+func User(username string) *Userinfo {\n+\treturn &Userinfo{username, \"\", false}\n+}\n+\n+// UserPassword returns a Userinfo containing the provided username\n+// and password.\n // This functionality should only be used with legacy web sites.\n // RFC 2396 warns that interpreting Userinfo this way\n // ``is NOT RECOMMENDED, because the passing of authentication\n // information in clear text (such as URI) has proven to be a\n // security risk in almost every case where it has been used.''\n-func EscapeUserinfo(user, password string) string {\n-\traw := escape(user, encodeUserPassword)\n-\tif password != \"\" {\n-\t\traw += \":\" + escape(password, encodeUserPassword)\n+func UserPassword(username, password string) *Userinfo {\n+\treturn &Userinfo{username, password, true}\n+}\n+\n+// The Userinfo type is an immutable encapsulation of username and\n+// password details for a URL. An existing Userinfo value is guaranteed\n+// to have a username set (potentially empty, as allowed by RFC 2396),\n+// and optionally a password.\n+type Userinfo struct {\n+\tusername    string\n+\tpassword    string\n+\tpasswordSet bool\n+}\n+\n+// Username returns the username.\n+func (u *Userinfo) Username() string {\n+\treturn u.username\n+}\n+\n+// Password returns the password in case it is set, and whether it is set.\n+func (u *Userinfo) Password() (string, bool) {\n+\tif u.passwordSet {\n+\t\treturn u.password, true\n \t}\n-\treturn raw\n+\treturn \"\", false\n }\n \n-// A URL represents a parsed URL (technically, a URI reference).\n-// The general form represented is:\n-//\tscheme://[userinfo@]host/path[?query][#fragment]\n-// The Raw, RawAuthority, RawPath, and RawQuery fields are in \"wire format\"\n-// (special characters must be hex-escaped if not meant to have special meaning).\n-// All other fields are logical values; '+' or '%' represent themselves.\n-//\n-// The various Raw values are supplied in wire format because\n-// clients typically have to split them into pieces before further\n-// decoding.\n-type URL struct {\n-\tRaw          string // the original string\n-\tScheme       string // scheme\n-\tRawAuthority string // [userinfo@]host\n-\tRawUserinfo  string // userinfo\n-\tHost         string // host\n-\tRawPath      string // /path[?query][#fragment]\n-\tPath         string // /path\n-\tOpaquePath   bool   // path is opaque (unrooted when scheme is present)\n-\tRawQuery     string // query\n-\tFragment     string // fragment\n+// String returns the encoded userinfo information in the standard form\n+// of \"username[:password]\".\n+func (u *Userinfo) String() string {\n+\ts := escape(u.username, encodeUserPassword)\n+\tif u.passwordSet {\n+\t\ts += \":\" + escape(u.password, encodeUserPassword)\n+\t}\n+\treturn s\n }\n \n // Maybe rawurl is of the form scheme:path.\n@@ -341,136 +342,112 @@ func ParseRequest(rawurl string) (url *URL, err error) {\n // in which case only absolute URLs or path-absolute relative URLs are allowed.\n // If viaRequest is false, all forms of relative URLs are allowed.\n func parse(rawurl string, viaRequest bool) (url *URL, err error) {\n-\tvar (\n-\t\tleadingSlash bool\n-\t\tpath         string\n-\t)\n+\tvar rest string\n \n \tif rawurl == \"\" {\n \t\terr = errors.New(\"empty url\")\n \t\tgoto Error\n \t}\n \turl = new(URL)\n-\turl.Raw = rawurl\n \n \t// Split off possible leading \"http:\", \"mailto:\", etc.\n \t// Cannot contain escaped characters.\n-\tif url.Scheme, path, err = getscheme(rawurl); err != nil {\n+\tif url.Scheme, rest, err = getscheme(rawurl); err != nil {\n \t\tgoto Error\n \t}\n-\tleadingSlash = strings.HasPrefix(path, \"/\")\n \n-\tif url.Scheme != \"\" && !leadingSlash {\n-\t\t// RFC 2396:\n-\t\t// Absolute URI (has scheme) with non-rooted path\n-\t\t// is uninterpreted.  It doesn't even have a ?query.\n-\t\t// This is the case that handles mailto:name@example.com.\n-\t\turl.RawPath = path\n+\trest, url.RawQuery = split(rest, '?', true)\n \n-\t\tif url.Path, err = unescape(path, encodeOpaque); err != nil {\n-\t\t\tgoto Error\n+\tif !strings.HasPrefix(rest, \"/\") {\n+\t\tif url.Scheme != \"\" {\n+\t\t\t// We consider rootless paths per RFC 3986 as opaque.\n+\t\t\turl.Opaque = rest\n+\t\t\treturn url, nil\n \t\t}\n-\t\turl.OpaquePath = true\n-\t} else {\n-\t\tif viaRequest && !leadingSlash {\n+\t\tif viaRequest {\n \t\t\terr = errors.New(\"invalid URI for request\")\n \t\t\tgoto Error\n \t\t}\n+\t}\n \n-\t\t// Split off query before parsing path further.\n-\t\turl.RawPath = path\n-\t\tpath, query := split(path, '?', false)\n-\t\tif len(query) > 1 {\n-\t\t\turl.RawQuery = query[1:]\n-\t\t}\n-\n-\t\t// Maybe path is //authority/path\n-\t\tif (url.Scheme != \"\" || !viaRequest) &&\n-\t\t\tstrings.HasPrefix(path, \"//\") && !strings.HasPrefix(path, \"///\") {\n-\t\t\turl.RawAuthority, path = split(path[2:], '/', false)\n-\t\t\turl.RawPath = url.RawPath[2+len(url.RawAuthority):]\n-\t\t}\n-\n-\t\t// Split authority into userinfo@host.\n-\t\t// If there's no @, split's default is wrong.  Check explicitly.\n-\t\tvar rawHost string\n-\t\tif strings.Index(url.RawAuthority, \"@\") < 0 {\n-\t\t\trawHost = url.RawAuthority\n-\t\t} else {\n-\t\t\turl.RawUserinfo, rawHost = split(url.RawAuthority, '@', true)\n-\t\t}\n-\n-\t\t// We leave RawAuthority only in raw form because clients\n-\t\t// of common protocols should be using Userinfo and Host\n-\t\t// instead.  Clients that wish to use RawAuthority will have to\n-\t\t// interpret it themselves: RFC 2396 does not define the meaning.\n-\n-\t\tif strings.Contains(rawHost, \"%\") {\n-\t\t\t// Host cannot contain escaped characters.\n-\t\t\terr = errors.New(\"hexadecimal escape in host\")\n+\tif (url.Scheme != \"\" || !viaRequest) && strings.HasPrefix(rest, \"//\") && !strings.HasPrefix(rest, \"///\") {\n+\t\tvar authority string\n+\t\tauthority, rest = split(rest[2:], '/', false)\n+\t\turl.User, url.Host, err = parseAuthority(authority)\n+\t\tif err != nil {\n \t\t\tgoto Error\n \t\t}\n-\t\turl.Host = rawHost\n-\n-\t\tif url.Path, err = unescape(path, encodePath); err != nil {\n+\t\tif strings.Contains(url.Host, \"%\") {\n+\t\t\terr = errors.New(\"hexadecimal escape in host\")\n \t\t\tgoto Error\n \t\t}\n \t}\n+\tif url.Path, err = unescape(rest, encodePath); err != nil {\n+\t\tgoto Error\n+\t}\n \treturn url, nil\n \n Error:\n \treturn nil, &Error{\"parse\", rawurl, err}\n+}\n \n+func parseAuthority(authority string) (user *Userinfo, host string, err error) {\n+\tif strings.Index(authority, \"@\") < 0 {\n+\t\thost = authority\n+\t\treturn\n+\t}\n+\tuserinfo, host := split(authority, '@', true)\n+\tif strings.Index(userinfo, \":\") < 0 {\n+\t\tif userinfo, err = unescape(userinfo, encodeUserPassword); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tuser = User(userinfo)\n+\t} else {\n+\t\tusername, password := split(userinfo, ':', true)\n+\t\tif username, err = unescape(username, encodeUserPassword); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif password, err = unescape(password, encodeUserPassword); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tuser = UserPassword(username, password)\n+\t}\n+\treturn\n }\n \n // ParseWithReference is like Parse but allows a trailing #fragment.\n func ParseWithReference(rawurlref string) (url *URL, err error) {\n-\t// Cut off #frag.\n-\trawurl, frag := split(rawurlref, '#', false)\n+\t// Cut off #frag\n+\trawurl, frag := split(rawurlref, '#', true)\n \tif url, err = Parse(rawurl); err != nil {\n \t\treturn nil, err\n \t}\n-\turl.Raw += frag\n-\turl.RawPath += frag\n-\tif len(frag) > 1 {\n-\t\tfrag = frag[1:]\n-\t\tif url.Fragment, err = unescape(frag, encodeFragment); err != nil {\n-\t\t\treturn nil, &Error{\"parse\", rawurl, err}\n-\t\t}\n+\tif frag == \"\" {\n+\t\treturn url, nil\n+\t}\n+\tif url.Fragment, err = unescape(frag, encodeFragment); err != nil {\n+\t\treturn nil, &Error{\"parse\", rawurlref, err}\n \t}\n \treturn url, nil\n }\n \n // String reassembles url into a valid URL string.\n-//\n-// There are redundant fields stored in the URL structure:\n-// the String method consults Scheme, Path, Host, RawUserinfo,\n-// RawQuery, and Fragment, but not Raw, RawPath or RawAuthority.\n func (url *URL) String() string {\n+\t// TODO: Rewrite to use bytes.Buffer\n \tresult := \"\"\n \tif url.Scheme != \"\" {\n \t\tresult += url.Scheme + \":\"\n \t}\n-\tif url.Host != \"\" || url.RawUserinfo != \"\" {\n-\t\tresult += \"//\"\n-\t\tif url.RawUserinfo != \"\" {\n-\t\t\t// hide the password, if any\n-\t\t\tinfo := url.RawUserinfo\n-\t\t\tif i := strings.Index(info, \":\"); i >= 0 {\n-\t\t\t\tinfo = info[0:i] + \":******\"\n+\tif url.Opaque != \"\" {\n+\t\tresult += url.Opaque\n+\t} else {\n+\t\tif url.Host != \"\" || url.User != nil {\n+\t\t\tresult += \"//\"\n+\t\t\tif u := url.User; u != nil {\n+\t\t\t\tresult += u.String() + \"@\"\n \t\t\t}\n-\t\t\tresult += info + \"@\"\n-\t\t}\n-\t\tresult += url.Host\n-\t}\n-\tif url.OpaquePath {\n-\t\tpath := url.Path\n-\t\tif strings.HasPrefix(path, \"/\") {\n-\t\t\tresult += \"%2f\"\n-\t\t\tpath = path[1:]\n+\t\t\tresult += url.Host\n \t\t}\n-\t\tresult += escape(path, encodeOpaque)\n-\t} else {\n \t\tresult += escape(url.Path, encodePath)\n \t}\n \tif url.RawQuery != \"\" {\n@@ -630,47 +607,38 @@ func (base *URL) Parse(ref string) (*URL, error) {\n // base or reference. If ref is an absolute URL, then ResolveReference\n // ignores base and returns a copy of ref.\n func (base *URL) ResolveReference(ref *URL) *URL {\n-\turl := new(URL)\n-\tswitch {\n-\tcase ref.IsAbs():\n-\t\t*url = *ref\n-\tdefault:\n-\t\t// relativeURI   = ( net_path | abs_path | rel_path ) [ \"?\" query ]\n-\t\t*url = *base\n-\t\tif ref.RawAuthority != \"\" {\n-\t\t\t// The \"net_path\" case.\n-\t\t\turl.RawAuthority = ref.RawAuthority\n-\t\t\turl.Host = ref.Host\n-\t\t\turl.RawUserinfo = ref.RawUserinfo\n-\t\t}\n-\t\tswitch {\n-\t\tcase url.OpaquePath:\n-\t\t\turl.Path = ref.Path\n-\t\t\turl.RawPath = ref.RawPath\n-\t\t\turl.RawQuery = ref.RawQuery\n-\t\tcase strings.HasPrefix(ref.Path, \"/\"):\n-\t\t\t// The \"abs_path\" case.\n-\t\t\turl.Path = ref.Path\n-\t\t\turl.RawPath = ref.RawPath\n-\t\t\turl.RawQuery = ref.RawQuery\n-\t\tdefault:\n-\t\t\t// The \"rel_path\" case.\n-\t\t\tpath := resolvePath(base.Path, ref.Path)\n-\t\t\tif !strings.HasPrefix(path, \"/\") {\n-\t\t\t\tpath = \"/\" + path\n-\t\t\t}\n-\t\t\turl.Path = path\n-\t\t\turl.RawPath = url.Path\n-\t\t\turl.RawQuery = ref.RawQuery\n-\t\t\tif ref.RawQuery != \"\" {\n-\t\t\t\turl.RawPath += \"?\" + url.RawQuery\n-\t\t\t}\n+\tif ref.IsAbs() {\n+\t\turl := *ref\n+\t\treturn &url\n+\t}\n+\t// relativeURI = ( net_path | abs_path | rel_path ) [ \"?\" query ]\n+\turl := *base\n+\turl.RawQuery = ref.RawQuery\n+\turl.Fragment = ref.Fragment\n+\tif ref.Opaque != \"\" {\n+\t\turl.Opaque = ref.Opaque\n+\t\turl.User = nil\n+\t\turl.Host = \"\"\n+\t\turl.Path = \"\"\n+\t\treturn &url\n+\t}\n+\tif ref.Host != \"\" || ref.User != nil {\n+\t\t// The \"net_path\" case.\n+\t\turl.Host = ref.Host\n+\t\turl.User = ref.User\n+\t}\n+\tif strings.HasPrefix(ref.Path, \"/\") {\n+\t\t// The \"abs_path\" case.\n+\t\turl.Path = ref.Path\n+\t} else {\n+\t\t// The \"rel_path\" case.\n+\t\tpath := resolvePath(base.Path, ref.Path)\n+\t\tif !strings.HasPrefix(path, \"/\") {\n+\t\t\tpath = \"/\" + path\n \t\t}\n-\n-\t\turl.Fragment = ref.Fragment\n+\t\turl.Path = path\n \t}\n-\turl.Raw = url.String()\n-\treturn url\n+\treturn &url\n }\n \n // Query parses RawQuery and returns the corresponding values.\n@@ -679,7 +647,18 @@ func (u *URL) Query() Values {\n \treturn v\n }\n \n-// EncodedPath returns the URL's path in \"URL path encoded\" form.\n-func (u *URL) EncodedPath() string {\n-\treturn escape(u.Path, encodePath)\n+// RequestURI returns the encoded path?query or opaque?query\n+// string that would be used in an HTTP request for u.\n+func (u *URL) RequestURI() string {\n+\tresult := u.Opaque\n+\tif result == \"\" {\n+\t\tresult = escape(u.Path, encodePath)\n+\t\tif result == \"\" {\n+\t\t\tresult = \"/\"\n+\t\t}\n+\t}\n+\tif u.RawQuery != \"\" {\n+\t\tresult += \"?\" + u.RawQuery\n+\t}\n+\treturn result\n }"}, {"sha": "9fe5ff886b7d8be48ef6e366e8a4347be9daf9cb", "filename": "libgo/go/net/url/url_test.go", "status": "modified", "additions": 188, "deletions": 166, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -21,162 +21,128 @@ var urltests = []URLTest{\n \t{\n \t\t\"http://www.google.com\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n+\t\t\tScheme: \"http\",\n+\t\t\tHost:   \"www.google.com\",\n \t\t},\n \t\t\"\",\n \t},\n \t// path\n \t{\n \t\t\"http://www.google.com/\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/\",\n-\t\t\tPath:         \"/\",\n+\t\t\tScheme: \"http\",\n+\t\t\tHost:   \"www.google.com\",\n+\t\t\tPath:   \"/\",\n \t\t},\n \t\t\"\",\n \t},\n \t// path with hex escaping\n \t{\n \t\t\"http://www.google.com/file%20one%26two\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/file%20one%26two\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/file%20one%26two\",\n-\t\t\tPath:         \"/file one&two\",\n+\t\t\tScheme: \"http\",\n+\t\t\tHost:   \"www.google.com\",\n+\t\t\tPath:   \"/file one&two\",\n \t\t},\n \t\t\"http://www.google.com/file%20one&two\",\n \t},\n \t// user\n \t{\n \t\t\"ftp://webmaster@www.google.com/\",\n \t\t&URL{\n-\t\t\tRaw:          \"ftp://webmaster@www.google.com/\",\n-\t\t\tScheme:       \"ftp\",\n-\t\t\tRawAuthority: \"webmaster@www.google.com\",\n-\t\t\tRawUserinfo:  \"webmaster\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/\",\n-\t\t\tPath:         \"/\",\n+\t\t\tScheme: \"ftp\",\n+\t\t\tUser:   User(\"webmaster\"),\n+\t\t\tHost:   \"www.google.com\",\n+\t\t\tPath:   \"/\",\n \t\t},\n \t\t\"\",\n \t},\n \t// escape sequence in username\n \t{\n \t\t\"ftp://john%20doe@www.google.com/\",\n \t\t&URL{\n-\t\t\tRaw:          \"ftp://john%20doe@www.google.com/\",\n-\t\t\tScheme:       \"ftp\",\n-\t\t\tRawAuthority: \"john%20doe@www.google.com\",\n-\t\t\tRawUserinfo:  \"john%20doe\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/\",\n-\t\t\tPath:         \"/\",\n+\t\t\tScheme: \"ftp\",\n+\t\t\tUser:   User(\"john doe\"),\n+\t\t\tHost:   \"www.google.com\",\n+\t\t\tPath:   \"/\",\n \t\t},\n \t\t\"ftp://john%20doe@www.google.com/\",\n \t},\n \t// query\n \t{\n \t\t\"http://www.google.com/?q=go+language\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/?q=go+language\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/?q=go+language\",\n-\t\t\tPath:         \"/\",\n-\t\t\tRawQuery:     \"q=go+language\",\n+\t\t\tScheme:   \"http\",\n+\t\t\tHost:     \"www.google.com\",\n+\t\t\tPath:     \"/\",\n+\t\t\tRawQuery: \"q=go+language\",\n \t\t},\n \t\t\"\",\n \t},\n \t// query with hex escaping: NOT parsed\n \t{\n \t\t\"http://www.google.com/?q=go%20language\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/?q=go%20language\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/?q=go%20language\",\n-\t\t\tPath:         \"/\",\n-\t\t\tRawQuery:     \"q=go%20language\",\n+\t\t\tScheme:   \"http\",\n+\t\t\tHost:     \"www.google.com\",\n+\t\t\tPath:     \"/\",\n+\t\t\tRawQuery: \"q=go%20language\",\n \t\t},\n \t\t\"\",\n \t},\n \t// %20 outside query\n \t{\n \t\t\"http://www.google.com/a%20b?q=c+d\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/a%20b?q=c+d\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/a%20b?q=c+d\",\n-\t\t\tPath:         \"/a b\",\n-\t\t\tRawQuery:     \"q=c+d\",\n+\t\t\tScheme:   \"http\",\n+\t\t\tHost:     \"www.google.com\",\n+\t\t\tPath:     \"/a b\",\n+\t\t\tRawQuery: \"q=c+d\",\n \t\t},\n \t\t\"\",\n \t},\n-\t// path without leading /, so no query parsing\n+\t// path without leading /, so no parsing\n \t{\n \t\t\"http:www.google.com/?q=go+language\",\n \t\t&URL{\n-\t\t\tRaw:        \"http:www.google.com/?q=go+language\",\n-\t\t\tScheme:     \"http\",\n-\t\t\tRawPath:    \"www.google.com/?q=go+language\",\n-\t\t\tPath:       \"www.google.com/?q=go+language\",\n-\t\t\tOpaquePath: true,\n+\t\t\tScheme:   \"http\",\n+\t\t\tOpaque:   \"www.google.com/\",\n+\t\t\tRawQuery: \"q=go+language\",\n \t\t},\n \t\t\"http:www.google.com/?q=go+language\",\n \t},\n-\t// path without leading /, so no query parsing\n+\t// path without leading /, so no parsing\n \t{\n \t\t\"http:%2f%2fwww.google.com/?q=go+language\",\n \t\t&URL{\n-\t\t\tRaw:        \"http:%2f%2fwww.google.com/?q=go+language\",\n-\t\t\tScheme:     \"http\",\n-\t\t\tRawPath:    \"%2f%2fwww.google.com/?q=go+language\",\n-\t\t\tPath:       \"//www.google.com/?q=go+language\",\n-\t\t\tOpaquePath: true,\n+\t\t\tScheme:   \"http\",\n+\t\t\tOpaque:   \"%2f%2fwww.google.com/\",\n+\t\t\tRawQuery: \"q=go+language\",\n \t\t},\n-\t\t\"http:%2f/www.google.com/?q=go+language\",\n+\t\t\"http:%2f%2fwww.google.com/?q=go+language\",\n \t},\n \t// non-authority\n \t{\n \t\t\"mailto:/webmaster@golang.org\",\n \t\t&URL{\n-\t\t\tRaw:     \"mailto:/webmaster@golang.org\",\n-\t\t\tScheme:  \"mailto\",\n-\t\t\tRawPath: \"/webmaster@golang.org\",\n-\t\t\tPath:    \"/webmaster@golang.org\",\n+\t\t\tScheme: \"mailto\",\n+\t\t\tPath:   \"/webmaster@golang.org\",\n \t\t},\n \t\t\"\",\n \t},\n \t// non-authority\n \t{\n \t\t\"mailto:webmaster@golang.org\",\n \t\t&URL{\n-\t\t\tRaw:        \"mailto:webmaster@golang.org\",\n-\t\t\tScheme:     \"mailto\",\n-\t\t\tRawPath:    \"webmaster@golang.org\",\n-\t\t\tPath:       \"webmaster@golang.org\",\n-\t\t\tOpaquePath: true,\n+\t\t\tScheme: \"mailto\",\n+\t\t\tOpaque: \"webmaster@golang.org\",\n \t\t},\n \t\t\"\",\n \t},\n \t// unescaped :// in query should not create a scheme\n \t{\n \t\t\"/foo?query=http://bad\",\n \t\t&URL{\n-\t\t\tRaw:      \"/foo?query=http://bad\",\n-\t\t\tRawPath:  \"/foo?query=http://bad\",\n \t\t\tPath:     \"/foo\",\n \t\t\tRawQuery: \"query=http://bad\",\n \t\t},\n@@ -186,27 +152,18 @@ var urltests = []URLTest{\n \t{\n \t\t\"//foo\",\n \t\t&URL{\n-\t\t\tRawAuthority: \"foo\",\n-\t\t\tRaw:          \"//foo\",\n-\t\t\tHost:         \"foo\",\n-\t\t\tScheme:       \"\",\n-\t\t\tRawPath:      \"\",\n-\t\t\tPath:         \"\",\n+\t\t\tHost: \"foo\",\n \t\t},\n \t\t\"\",\n \t},\n \t// leading // without scheme, with userinfo, path, and query\n \t{\n \t\t\"//user@foo/path?a=b\",\n \t\t&URL{\n-\t\t\tRaw:          \"//user@foo/path?a=b\",\n-\t\t\tRawAuthority: \"user@foo\",\n-\t\t\tRawUserinfo:  \"user\",\n-\t\t\tScheme:       \"\",\n-\t\t\tRawPath:      \"/path?a=b\",\n-\t\t\tPath:         \"/path\",\n-\t\t\tRawQuery:     \"a=b\",\n-\t\t\tHost:         \"foo\",\n+\t\t\tUser:     User(\"user\"),\n+\t\t\tHost:     \"foo\",\n+\t\t\tPath:     \"/path\",\n+\t\t\tRawQuery: \"a=b\",\n \t\t},\n \t\t\"\",\n \t},\n@@ -218,50 +175,29 @@ var urltests = []URLTest{\n \t{\n \t\t\"///threeslashes\",\n \t\t&URL{\n-\t\t\tRawAuthority: \"\",\n-\t\t\tRaw:          \"///threeslashes\",\n-\t\t\tHost:         \"\",\n-\t\t\tScheme:       \"\",\n-\t\t\tRawPath:      \"///threeslashes\",\n-\t\t\tPath:         \"///threeslashes\",\n+\t\t\tPath: \"///threeslashes\",\n \t\t},\n \t\t\"\",\n \t},\n \t{\n \t\t\"http://user:password@google.com\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://user:password@google.com\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"user:password@google.com\",\n-\t\t\tRawUserinfo:  \"user:password\",\n-\t\t\tHost:         \"google.com\",\n-\t\t},\n-\t\t\"http://user:******@google.com\",\n-\t},\n-\t{\n-\t\t\"http://user:longerpass@google.com\",\n-\t\t&URL{\n-\t\t\tRaw:          \"http://user:longerpass@google.com\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"user:longerpass@google.com\",\n-\t\t\tRawUserinfo:  \"user:longerpass\",\n-\t\t\tHost:         \"google.com\",\n+\t\t\tScheme: \"http\",\n+\t\t\tUser:   UserPassword(\"user\", \"password\"),\n+\t\t\tHost:   \"google.com\",\n \t\t},\n-\t\t\"http://user:******@google.com\",\n+\t\t\"http://user:password@google.com\",\n \t},\n }\n \n var urlnofragtests = []URLTest{\n \t{\n \t\t\"http://www.google.com/?q=go+language#foo\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/?q=go+language#foo\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/?q=go+language#foo\",\n-\t\t\tPath:         \"/\",\n-\t\t\tRawQuery:     \"q=go+language#foo\",\n+\t\t\tScheme:   \"http\",\n+\t\t\tHost:     \"www.google.com\",\n+\t\t\tPath:     \"/\",\n+\t\t\tRawQuery: \"q=go+language#foo\",\n \t\t},\n \t\t\"\",\n \t},\n@@ -271,38 +207,38 @@ var urlfragtests = []URLTest{\n \t{\n \t\t\"http://www.google.com/?q=go+language#foo\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/?q=go+language#foo\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/?q=go+language#foo\",\n-\t\t\tPath:         \"/\",\n-\t\t\tRawQuery:     \"q=go+language\",\n-\t\t\tFragment:     \"foo\",\n+\t\t\tScheme:   \"http\",\n+\t\t\tHost:     \"www.google.com\",\n+\t\t\tPath:     \"/\",\n+\t\t\tRawQuery: \"q=go+language\",\n+\t\t\tFragment: \"foo\",\n \t\t},\n \t\t\"\",\n \t},\n \t{\n \t\t\"http://www.google.com/?q=go+language#foo%26bar\",\n \t\t&URL{\n-\t\t\tRaw:          \"http://www.google.com/?q=go+language#foo%26bar\",\n-\t\t\tScheme:       \"http\",\n-\t\t\tRawAuthority: \"www.google.com\",\n-\t\t\tHost:         \"www.google.com\",\n-\t\t\tRawPath:      \"/?q=go+language#foo%26bar\",\n-\t\t\tPath:         \"/\",\n-\t\t\tRawQuery:     \"q=go+language\",\n-\t\t\tFragment:     \"foo&bar\",\n+\t\t\tScheme:   \"http\",\n+\t\t\tHost:     \"www.google.com\",\n+\t\t\tPath:     \"/\",\n+\t\t\tRawQuery: \"q=go+language\",\n+\t\t\tFragment: \"foo&bar\",\n \t\t},\n \t\t\"http://www.google.com/?q=go+language#foo&bar\",\n \t},\n }\n \n // more useful string for debugging than fmt's struct printer\n func ufmt(u *URL) string {\n-\treturn fmt.Sprintf(\"raw=%q, scheme=%q, rawpath=%q, auth=%q, userinfo=%q, host=%q, path=%q, rawq=%q, frag=%q\",\n-\t\tu.Raw, u.Scheme, u.RawPath, u.RawAuthority, u.RawUserinfo,\n-\t\tu.Host, u.Path, u.RawQuery, u.Fragment)\n+\tvar user, pass interface{}\n+\tif u.User != nil {\n+\t\tuser = u.User.Username()\n+\t\tif p, ok := u.User.Password(); ok {\n+\t\t\tpass = p\n+\t\t}\n+\t}\n+\treturn fmt.Sprintf(\"opaque=%q, scheme=%q, user=%#v, pass=%#v, host=%q, path=%q, rawq=%q, frag=%q\",\n+\t\tu.Opaque, u.Scheme, user, pass, u.Host, u.Path, u.RawQuery, u.Fragment)\n }\n \n func DoTest(t *testing.T, parse func(string) (*URL, error), name string, tests []URLTest) {\n@@ -370,11 +306,11 @@ func DoTestString(t *testing.T, parse func(string) (*URL, error), name string, t\n \t\t\tt.Errorf(\"%s(%q) returned error %s\", name, tt.in, err)\n \t\t\tcontinue\n \t\t}\n-\t\ts := u.String()\n \t\texpected := tt.in\n \t\tif len(tt.roundtrip) > 0 {\n \t\t\texpected = tt.roundtrip\n \t\t}\n+\t\ts := u.String()\n \t\tif s != expected {\n \t\t\tt.Errorf(\"%s(%q).String() == %q (expected %q)\", name, tt.in, s, expected)\n \t\t}\n@@ -504,33 +440,11 @@ func TestEscape(t *testing.T) {\n \t}\n }\n \n-type UserinfoTest struct {\n-\tUser     string\n-\tPassword string\n-\tRaw      string\n-}\n-\n-var userinfoTests = []UserinfoTest{\n-\t{\"user\", \"password\", \"user:password\"},\n-\t{\"foo:bar\", \"~!@#$%^&*()_+{}|[]\\\\-=`:;'\\\"<>?,./\",\n-\t\t\"foo%3Abar:~!%40%23$%25%5E&*()_+%7B%7D%7C%5B%5D%5C-=%60%3A;'%22%3C%3E?,.%2F\"},\n-}\n-\n-func TestEscapeUserinfo(t *testing.T) {\n-\tfor _, tt := range userinfoTests {\n-\t\tif raw := EscapeUserinfo(tt.User, tt.Password); raw != tt.Raw {\n-\t\t\tt.Errorf(\"EscapeUserinfo(%q, %q) = %q, want %q\", tt.User, tt.Password, raw, tt.Raw)\n-\t\t}\n-\t}\n-}\n-\n-func TestUnescapeUserinfo(t *testing.T) {\n-\tfor _, tt := range userinfoTests {\n-\t\tif user, pass, err := UnescapeUserinfo(tt.Raw); user != tt.User || pass != tt.Password || err != nil {\n-\t\t\tt.Errorf(\"UnescapeUserinfo(%q) = %q, %q, %v, want %q, %q, nil\", tt.Raw, user, pass, err, tt.User, tt.Password)\n-\t\t}\n-\t}\n-}\n+//var userinfoTests = []UserinfoTest{\n+//\t{\"user\", \"password\", \"user:password\"},\n+//\t{\"foo:bar\", \"~!@#$%^&*()_+{}|[]\\\\-=`:;'\\\"<>?,./\",\n+//\t\t\"foo%3Abar:~!%40%23$%25%5E&*()_+%7B%7D%7C%5B%5D%5C-=%60%3A;'%22%3C%3E?,.%2F\"},\n+//}\n \n type EncodeQueryTest struct {\n \tm         Values\n@@ -664,6 +578,57 @@ func TestResolveReference(t *testing.T) {\n \t\tt.Errorf(\"Expected an error from Parse wrapper parsing an empty string.\")\n \t}\n \n+\t// Ensure Opaque resets the URL.\n+\tbase = mustParse(\"scheme://user@foo.com/bar\")\n+\tabs = base.ResolveReference(&URL{Opaque: \"opaque\"})\n+\twant := mustParse(\"scheme:opaque\")\n+\tif *abs != *want {\n+\t\tt.Errorf(\"ResolveReference failed to resolve opaque URL: want %#v, got %#v\", abs, want)\n+\t}\n+}\n+\n+func TestResolveReferenceOpaque(t *testing.T) {\n+\tmustParse := func(url string) *URL {\n+\t\tu, err := ParseWithReference(url)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Expected URL to parse: %q, got error: %v\", url, err)\n+\t\t}\n+\t\treturn u\n+\t}\n+\tfor _, test := range resolveReferenceTests {\n+\t\tbase := mustParse(test.base)\n+\t\trel := mustParse(test.rel)\n+\t\turl := base.ResolveReference(rel)\n+\t\turlStr := url.String()\n+\t\tif urlStr != test.expected {\n+\t\t\tt.Errorf(\"Resolving %q + %q != %q; got %q\", test.base, test.rel, test.expected, urlStr)\n+\t\t}\n+\t}\n+\n+\t// Test that new instances are returned.\n+\tbase := mustParse(\"http://foo.com/\")\n+\tabs := base.ResolveReference(mustParse(\".\"))\n+\tif base == abs {\n+\t\tt.Errorf(\"Expected no-op reference to return new URL instance.\")\n+\t}\n+\tbarRef := mustParse(\"http://bar.com/\")\n+\tabs = base.ResolveReference(barRef)\n+\tif abs == barRef {\n+\t\tt.Errorf(\"Expected resolution of absolute reference to return new URL instance.\")\n+\t}\n+\n+\t// Test the convenience wrapper too\n+\tbase = mustParse(\"http://foo.com/path/one/\")\n+\tabs, _ = base.Parse(\"../two\")\n+\texpected := \"http://foo.com/path/two\"\n+\tif abs.String() != expected {\n+\t\tt.Errorf(\"Parse wrapper got %q; expected %q\", abs.String(), expected)\n+\t}\n+\t_, err := base.Parse(\"\")\n+\tif err == nil {\n+\t\tt.Errorf(\"Expected an error from Parse wrapper parsing an empty string.\")\n+\t}\n+\n }\n \n func TestQueryValues(t *testing.T) {\n@@ -747,3 +712,60 @@ func TestParseQuery(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+type RequestURITest struct {\n+\turl *URL\n+\tout string\n+}\n+\n+var requritests = []RequestURITest{\n+\t{\n+\t\t&URL{\n+\t\t\tScheme: \"http\",\n+\t\t\tHost:   \"example.com\",\n+\t\t\tPath:   \"\",\n+\t\t},\n+\t\t\"/\",\n+\t},\n+\t{\n+\t\t&URL{\n+\t\t\tScheme: \"http\",\n+\t\t\tHost:   \"example.com\",\n+\t\t\tPath:   \"/a b\",\n+\t\t},\n+\t\t\"/a%20b\",\n+\t},\n+\t{\n+\t\t&URL{\n+\t\t\tScheme:   \"http\",\n+\t\t\tHost:     \"example.com\",\n+\t\t\tPath:     \"/a b\",\n+\t\t\tRawQuery: \"q=go+language\",\n+\t\t},\n+\t\t\"/a%20b?q=go+language\",\n+\t},\n+\t{\n+\t\t&URL{\n+\t\t\tScheme: \"myschema\",\n+\t\t\tOpaque: \"opaque\",\n+\t\t},\n+\t\t\"opaque\",\n+\t},\n+\t{\n+\t\t&URL{\n+\t\t\tScheme:   \"myschema\",\n+\t\t\tOpaque:   \"opaque\",\n+\t\t\tRawQuery: \"q=go+language\",\n+\t\t},\n+\t\t\"opaque?q=go+language\",\n+\t},\n+}\n+\n+func TestRequestURI(t *testing.T) {\n+\tfor _, tt := range requritests {\n+\t\ts := tt.url.RequestURI()\n+\t\tif s != tt.out {\n+\t\t\tt.Errorf(\"%#v.RequestURI() == %q (expected %q)\", tt.url, s, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "d0daf53720bcac6cf317c1b9ecd1a480bb6fce39", "filename": "libgo/go/old/netchan/common.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fold%2Fnetchan%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fold%2Fnetchan%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fnetchan%2Fcommon.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -165,9 +165,11 @@ func (cs *clientSet) sync(timeout time.Duration) error {\n \tdeadline := time.Now().Add(timeout)\n \t// seq remembers the clients and their seqNum at point of entry.\n \tseq := make(map[unackedCounter]int64)\n+\tcs.mu.Lock()\n \tfor client := range cs.clients {\n \t\tseq[client] = client.seq()\n \t}\n+\tcs.mu.Unlock()\n \tfor {\n \t\tpending := false\n \t\tcs.mu.Lock()"}, {"sha": "d3044d0c1d767cf69ff94b78c48b8e8a8cfeed63", "filename": "libgo/go/old/regexp/regexp.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,4 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "0e3c39976d429456326009fd9a69a224f776ba2a", "filename": "libgo/go/os/dir.go", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -28,19 +28,7 @@ func clen(n []byte) int {\n \n var elen int;\n \n-// Readdirnames reads and returns a slice of names from the directory f.\n-//\n-// If n > 0, Readdirnames returns at most n names. In this case, if\n-// Readdirnames returns an empty slice, it will return a non-nil error\n-// explaining why. At the end of a directory, the error is os.EOF.\n-//\n-// If n <= 0, Readdirnames returns all the names from the directory in\n-// a single slice. In this case, if Readdirnames succeeds (reads all\n-// the way to the end of the directory), it returns the slice and a\n-// nil error. If it encounters an error before the end of the\n-// directory, Readdirnames returns the names read until that point and\n-// a non-nil error.\n-func (file *File) Readdirnames(n int) (names []string, err error) {\n+func (file *File) readdirnames(n int) (names []string, err error) {\n \tif elen == 0 {\n \t\tvar dummy syscall.Dirent;\n \t\telen = (unsafe.Offsetof(dummy.Name) +"}, {"sha": "f2dc15409dbe89edab922382eee8e8ca5157e8c1", "filename": "libgo/go/os/dir_plan9.go", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdir_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdir_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -10,22 +10,7 @@ import (\n \t\"syscall\"\n )\n \n-// Readdir reads the contents of the directory associated with file and\n-// returns an array of up to n FileInfo structures, as would be returned\n-// by Lstat, in directory order. Subsequent calls on the same file will yield\n-// further FileInfos.\n-//\n-// If n > 0, Readdir returns at most n FileInfo structures. In this case, if\n-// Readdirnames returns an empty slice, it will return a non-nil error\n-// explaining why. At the end of a directory, the error is io.EOF.\n-//\n-// If n <= 0, Readdir returns all the FileInfo from the directory in\n-// a single slice. In this case, if Readdir succeeds (reads all\n-// the way to the end of the directory), it returns the slice and a\n-// nil error. If it encounters an error before the end of the\n-// directory, Readdir returns the FileInfo read until that point\n-// and a non-nil error.\n-func (file *File) Readdir(n int) (fi []FileInfo, err error) {\n+func (file *File) readdir(n int) (fi []FileInfo, err error) {\n \t// If this file has no dirinfo, create one.\n \tif file.dirinfo == nil {\n \t\tfile.dirinfo = new(dirInfo)\n@@ -76,19 +61,7 @@ func (file *File) Readdir(n int) (fi []FileInfo, err error) {\n \treturn result, nil\n }\n \n-// Readdirnames reads and returns a slice of names from the directory f.\n-//\n-// If n > 0, Readdirnames returns at most n names. In this case, if\n-// Readdirnames returns an empty slice, it will return a non-nil error\n-// explaining why. At the end of a directory, the error is io.EOF.\n-//\n-// If n <= 0, Readdirnames returns all the names from the directory in\n-// a single slice. In this case, if Readdirnames succeeds (reads all\n-// the way to the end of the directory), it returns the slice and a\n-// nil error. If it encounters an error before the end of the\n-// directory, Readdirnames returns the names read until that point and\n-// a non-nil error.\n-func (file *File) Readdirnames(n int) (names []string, err error) {\n+func (file *File) readdirnames(n int) (names []string, err error) {\n \tfi, err := file.Readdir(n)\n \tnames = make([]string, len(fi))\n \tfor i := range fi {"}, {"sha": "f41f939a97b549c178524c86acc3b0009892d4d1", "filename": "libgo/go/os/dir_unix.go", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdir_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdir_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_unix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -15,19 +15,7 @@ const (\n \tblockSize = 4096\n )\n \n-// Readdirnames reads and returns a slice of names from the directory f.\n-//\n-// If n > 0, Readdirnames returns at most n names. In this case, if\n-// Readdirnames returns an empty slice, it will return a non-nil error\n-// explaining why. At the end of a directory, the error is io.EOF.\n-//\n-// If n <= 0, Readdirnames returns all the names from the directory in\n-// a single slice. In this case, if Readdirnames succeeds (reads all\n-// the way to the end of the directory), it returns the slice and a\n-// nil error. If it encounters an error before the end of the\n-// directory, Readdirnames returns the names read until that point and\n-// a non-nil error.\n-func (f *File) Readdirnames(n int) (names []string, err error) {\n+func (f *File) readdirnames(n int) (names []string, err error) {\n \t// If this file has no dirinfo, create one.\n \tif f.dirinfo == nil {\n \t\tf.dirinfo = new(dirInfo)"}, {"sha": "ef857c0429f9a6b468e31bc4ca08b8eed2f17b37", "filename": "libgo/go/os/doc.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdoc.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+// FindProcess looks for a running process by its pid.\n+// The Process it returns can be used to obtain information\n+// about the underlying operating system process.\n+func FindProcess(pid int) (p *Process, err error) {\n+\treturn findProcess(pid)\n+}\n+\n+// Hostname returns the host name reported by the kernel.\n+func Hostname() (name string, err error) {\n+\treturn hostname()\n+}\n+\n+// Readdir reads the contents of the directory associated with file and\n+// returns an array of up to n FileInfo values, as would be returned\n+// by Lstat, in directory order. Subsequent calls on the same file will yield\n+// further FileInfos.\n+//\n+// If n > 0, Readdir returns at most n FileInfo structures. In this case, if\n+// Readdir returns an empty slice, it will return a non-nil error\n+// explaining why. At the end of a directory, the error is io.EOF.\n+//\n+// If n <= 0, Readdir returns all the FileInfo from the directory in\n+// a single slice. In this case, if Readdir succeeds (reads all\n+// the way to the end of the directory), it returns the slice and a\n+// nil error. If it encounters an error before the end of the\n+// directory, Readdir returns the FileInfo read until that point\n+// and a non-nil error.\n+func (f *File) Readdir(n int) (fi []FileInfo, err error) {\n+\treturn f.readdir(n)\n+}\n+\n+// Readdirnames reads and returns a slice of names from the directory f.\n+//\n+// If n > 0, Readdirnames returns at most n names. In this case, if\n+// Readdirnames returns an empty slice, it will return a non-nil error\n+// explaining why. At the end of a directory, the error is io.EOF.\n+//\n+// If n <= 0, Readdirnames returns all the names from the directory in\n+// a single slice. In this case, if Readdirnames succeeds (reads all\n+// the way to the end of the directory), it returns the slice and a\n+// nil error. If it encounters an error before the end of the\n+// directory, Readdirnames returns the names read until that point and\n+// a non-nil error.\n+func (f *File) Readdirnames(n int) (names []string, err error) {\n+\treturn f.readdirnames(n)\n+}"}, {"sha": "3c727b2ab39e44d0151e1612efd9ee7e51d5f732", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -17,10 +17,6 @@ type SyscallError struct {\n \n func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Err }\n \n-// Note: If the name of the function NewSyscallError changes,\n-// pkg/go/doc/doc.go should be adjusted since it hardwires\n-// this name in a heuristic.\n-\n // NewSyscallError returns, as an error, a new SyscallError\n // with the given system call name and error details.\n // As a convenience, if err is nil, NewSyscallError returns nil."}, {"sha": "1a08627256ac7af9beabc4e07ca691775e57c5d1", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -59,10 +59,6 @@ type SyscallError struct {\n \n func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Errno.Error() }\n \n-// Note: If the name of the function NewSyscallError changes,\n-// pkg/go/doc/doc.go should be adjusted since it hardwires\n-// this name in a heuristic.\n-\n // NewSyscallError returns, as an error, a new SyscallError\n // with the given system call name and error details.\n // As a convenience, if err is nil, NewSyscallError returns nil."}, {"sha": "2d3a919dc6e85348f4a54646206dab6d6ee4a505", "filename": "libgo/go/os/exec/lp_unix.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -47,8 +47,9 @@ func LookPath(file string) (string, error) {\n \t\t\t// Unix shell semantics: path element \"\" means \".\"\n \t\t\tdir = \".\"\n \t\t}\n-\t\tif err := findExecutable(dir + \"/\" + file); err == nil {\n-\t\t\treturn dir + \"/\" + file, nil\n+\t\tpath := dir + \"/\" + file\n+\t\tif err := findExecutable(path); err == nil {\n+\t\t\treturn path, nil\n \t\t}\n \t}\n \treturn \"\", &Error{file, ErrNotFound}"}, {"sha": "b7efcd68b8030be006262c681d00128487b72667", "filename": "libgo/go/os/exec/lp_windows.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -42,6 +42,11 @@ func findExecutable(file string, exts []string) (string, error) {\n \treturn ``, os.ENOENT\n }\n \n+// LookPath searches for an executable binary named file\n+// in the directories named by the PATH environment variable.\n+// If file contains a slash, it is tried directly and the PATH is not consulted.\n+// LookPath also uses PATHEXT environment variable to match\n+// a suitable candidate.\n func LookPath(file string) (f string, err error) {\n \tx := os.Getenv(`PATHEXT`)\n \tif x == `` {"}, {"sha": "879d4d2a736d5bcdc5d6ec4ce68f56b6c5504acd", "filename": "libgo/go/os/exec_plan9.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -138,10 +138,7 @@ func (p *Process) Release() error {\n \treturn nil\n }\n \n-// FindProcess looks for a running process by its pid.\n-// The Process it returns can be used to obtain information\n-// about the underlying operating system process.\n-func FindProcess(pid int) (p *Process, err error) {\n+func findProcess(pid int) (p *Process, err error) {\n \t// NOOP for Plan 9.\n \treturn newProcess(pid, 0), nil\n }"}, {"sha": "6c11b63c34fd0cbc14cee10dc4479234048efee9", "filename": "libgo/go/os/exec_unix.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -72,10 +72,7 @@ func (p *Process) Release() error {\n \treturn nil\n }\n \n-// FindProcess looks for a running process by its pid.\n-// The Process it returns can be used to obtain information\n-// about the underlying operating system process.\n-func FindProcess(pid int) (p *Process, err error) {\n+func findProcess(pid int) (p *Process, err error) {\n \t// NOOP for unix.\n \treturn newProcess(pid, 0), nil\n }"}, {"sha": "7eb7d194d60edf0166a40447adb961c6ec2a7de7", "filename": "libgo/go/os/exec_windows.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -11,6 +11,8 @@ import (\n \t\"unsafe\"\n )\n \n+// Wait waits for the Process to exit or stop, and then returns a\n+// Waitmsg describing its status and an error, if any.\n func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n \ts, e := syscall.WaitForSingleObject(syscall.Handle(p.handle), syscall.INFINITE)\n \tswitch s {\n@@ -43,6 +45,7 @@ func (p *Process) Signal(sig Signal) error {\n \treturn syscall.Errno(syscall.EWINDOWS)\n }\n \n+// Release releases any resources associated with the Process.\n func (p *Process) Release() error {\n \tif p.handle == -1 {\n \t\treturn EINVAL\n@@ -57,7 +60,7 @@ func (p *Process) Release() error {\n \treturn nil\n }\n \n-func FindProcess(pid int) (p *Process, err error) {\n+func findProcess(pid int) (p *Process, err error) {\n \tconst da = syscall.STANDARD_RIGHTS_READ |\n \t\tsyscall.PROCESS_QUERY_INFORMATION | syscall.SYNCHRONIZE\n \th, e := syscall.OpenProcess(da, false, uint32(pid))"}, {"sha": "3efa650c6575666ac2aed54a6418a3ebced76005", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -158,8 +158,8 @@ func (f *File) WriteString(s string) (ret int, err error) {\n \n // Mkdir creates a new directory with the specified name and permission bits.\n // It returns an error, if any.\n-func Mkdir(name string, perm uint32) error {\n-\te := syscall.Mkdir(name, perm)\n+func Mkdir(name string, perm FileMode) error {\n+\te := syscall.Mkdir(name, syscallMode(perm))\n \tif e != nil {\n \t\treturn &PathError{\"mkdir\", name, e}\n \t}"}, {"sha": "86ac1cab2cbf4e370c7733dcd95ebb2df79256db", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -81,18 +81,34 @@ func Rename(oldname, newname string) error {\n \treturn nil\n }\n \n+// syscallMode returns the syscall-specific mode bits from Go's portable mode bits.\n+func syscallMode(i FileMode) (o uint32) {\n+\to |= uint32(i.Perm())\n+\tif i&ModeSetuid != 0 {\n+\t\to |= syscall.S_ISUID\n+\t}\n+\tif i&ModeSetgid != 0 {\n+\t\to |= syscall.S_ISGID\n+\t}\n+\tif i&ModeSticky != 0 {\n+\t\to |= syscall.S_ISVTX\n+\t}\n+\t// No mapping for Go's ModeTemporary (plan9 only).\n+\treturn\n+}\n+\n // Chmod changes the mode of the named file to mode.\n // If the file is a symbolic link, it changes the mode of the link's target.\n-func Chmod(name string, mode uint32) error {\n-\tif e := syscall.Chmod(name, mode); e != nil {\n+func Chmod(name string, mode FileMode) error {\n+\tif e := syscall.Chmod(name, syscallMode(mode)); e != nil {\n \t\treturn &PathError{\"chmod\", name, e}\n \t}\n \treturn nil\n }\n \n // Chmod changes the mode of the file to mode.\n-func (f *File) Chmod(mode uint32) error {\n-\tif e := syscall.Fchmod(f.fd, mode); e != nil {\n+func (f *File) Chmod(mode FileMode) error {\n+\tif e := syscall.Fchmod(f.fd, syscallMode(mode)); e != nil {\n \t\treturn &PathError{\"chmod\", f.name, e}\n \t}\n \treturn nil"}, {"sha": "9a9ed92ee3c1b48f3103ad114797c21134faa68b", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -60,8 +60,8 @@ const DevNull = \"/dev/null\"\n // (O_RDONLY etc.) and perm, (0666 etc.) if applicable.  If successful,\n // methods on the returned File can be used for I/O.\n // It returns the File and an error, if any.\n-func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n-\tr, e := syscall.Open(name, flag|syscall.O_CLOEXEC, perm)\n+func OpenFile(name string, flag int, perm FileMode) (file *File, err error) {\n+\tr, e := syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))\n \tif e != nil {\n \t\treturn nil, &PathError{\"open\", name, e}\n \t}\n@@ -145,22 +145,7 @@ func Lstat(name string) (fi FileInfo, err error) {\n \treturn fileInfoFromStat(&stat, name), nil\n }\n \n-// Readdir reads the contents of the directory associated with file and\n-// returns an array of up to n FileInfo values, as would be returned\n-// by Lstat, in directory order. Subsequent calls on the same file will yield\n-// further FileInfos.\n-//\n-// If n > 0, Readdir returns at most n FileInfo structures. In this case, if\n-// Readdir returns an empty slice, it will return a non-nil error\n-// explaining why. At the end of a directory, the error is io.EOF.\n-//\n-// If n <= 0, Readdir returns all the FileInfo from the directory in\n-// a single slice. In this case, if Readdir succeeds (reads all\n-// the way to the end of the directory), it returns the slice and a\n-// nil error. If it encounters an error before the end of the\n-// directory, Readdir returns the FileInfo read until that point\n-// and a non-nil error.\n-func (f *File) Readdir(n int) (fi []FileInfo, err error) {\n+func (f *File) readdir(n int) (fi []FileInfo, err error) {\n \tdirname := f.name\n \tif dirname == \"\" {\n \t\tdirname = \".\""}, {"sha": "e962f3e397b39d4d82b50cbab57d212ba0b76611", "filename": "libgo/go/os/path.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -13,7 +13,7 @@ import \"io\"\n // directories that MkdirAll creates.\n // If path is already a directory, MkdirAll does nothing\n // and returns nil.\n-func MkdirAll(path string, perm uint32) error {\n+func MkdirAll(path string, perm FileMode) error {\n \t// If path exists, stop with success or error.\n \tdir, err := Stat(path)\n \tif err == nil {"}, {"sha": "8d1323af9c6f14a13f0ec2a7dbe7cced23a9dab9", "filename": "libgo/go/os/stat_openbsd.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_openbsd.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -45,6 +45,9 @@ func fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n \tif st.Mode&syscall.S_ISUID != 0 {\n \t\tfs.mode |= ModeSetuid\n \t}\n+\tif st.Mode&syscall.S_ISVTX != 0 {\n+\t\tfs.mode |= ModeSticky\n+\t}\n \treturn fs\n }\n "}, {"sha": "0f263f1c121c9052471304675dbe068b696f7ddb", "filename": "libgo/go/os/sys_bsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fsys_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fsys_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_bsd.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -11,7 +11,7 @@ package os\n \n import \"syscall\"\n \n-func Hostname() (name string, err error) {\n+func hostname() (name string, err error) {\n \tname, err = syscall.Sysctl(\"kern.hostname\")\n \tif err != nil {\n \t\treturn \"\", NewSyscallError(\"sysctl kern.hostname\", err)"}, {"sha": "76cdf5043239963d6a01430929edaf04af6e777a", "filename": "libgo/go/os/sys_linux.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fsys_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fsys_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_linux.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -6,8 +6,7 @@\n \n package os\n \n-// Hostname returns the host name reported by the kernel.\n-func Hostname() (name string, err error) {\n+func hostname() (name string, err error) {\n \tf, err := Open(\"/proc/sys/kernel/hostname\")\n \tif err != nil {\n \t\treturn \"\", err"}, {"sha": "07a7905f4721fd4133e77c9e837eddf38ed0634f", "filename": "libgo/go/os/sys_plan9.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fsys_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Fsys_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_plan9.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -6,7 +6,7 @@\n \n package os\n \n-func Hostname() (name string, err error) {\n+func hostname() (name string, err error) {\n \tf, err := Open(\"#c/sysname\")\n \tif err != nil {\n \t\treturn \"\", err"}, {"sha": "a3f187c25cb44f32d185efacdae34bbd29cc06d7", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -39,14 +39,15 @@ const (\n \tModeDir        FileMode = 1 << (32 - 1 - iota) // d: is a directory\n \tModeAppend                                     // a: append-only\n \tModeExclusive                                  // l: exclusive use\n-\tModeTemporary                                  // t: temporary file (not backed up)\n+\tModeTemporary                                  // T: temporary file (not backed up)\n \tModeSymlink                                    // L: symbolic link\n \tModeDevice                                     // D: device file\n \tModeNamedPipe                                  // p: named pipe (FIFO)\n \tModeSocket                                     // S: Unix domain socket\n \tModeSetuid                                     // u: setuid\n \tModeSetgid                                     // g: setgid\n \tModeCharDevice                                 // c: Unix character device, when ModeDevice is set\n+\tModeSticky                                     // t: sticky\n \n \t// Mask for the type bits. For regular files, none will be set.\n \tModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice\n@@ -55,7 +56,7 @@ const (\n )\n \n func (m FileMode) String() string {\n-\tconst str = \"daltLDpSugc\"\n+\tconst str = \"dalTLDpSugct\"\n \tvar buf [20]byte\n \tw := 0\n \tfor i, c := range str {"}, {"sha": "c9cffee11c48fcdef0a7e56381a996c5fd81e427", "filename": "libgo/go/patch/textdiff.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fpatch%2Ftextdiff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fpatch%2Ftextdiff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpatch%2Ftextdiff.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package patch\n \n import ("}, {"sha": "f0ac1301408755f1f048c17f2f672a007abdb587", "filename": "libgo/go/path/example_test.go", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fpath%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fpath%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fexample_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package path\n+\n+/* Commented out until gccgo has example support.\n+\n+import (\n+\t\"fmt\"\n+\t\"path\"\n+)\n+\n+// b\n+func ExampleBase() {\n+\tfmt.Println(path.Base(\"/a/b\"))\n+}\n+\n+// Clean(\"a/c\") = \"a/c\"\n+// Clean(\"a//c\") = \"a/c\"\n+// Clean(\"a/c/.\") = \"a/c\"\n+// Clean(\"a/c/b/..\") = \"a/c\"\n+// Clean(\"/../a/c\") = \"/a/c\"\n+// Clean(\"/../a/b/../././/c\") = \"/a/c\"\n+func ExampleClean() {\n+\tpaths := []string{\n+\t\t\"a/c\",\n+\t\t\"a//c\",\n+\t\t\"a/c/.\",\n+\t\t\"a/c/b/..\",\n+\t\t\"/../a/c\",\n+\t\t\"/../a/b/../././/c\",\n+\t}\n+\n+\tfor _, p := range paths {\n+\t\tfmt.Printf(\"Clean(%q) = %q\\n\", p, path.Clean(p))\n+\t}\n+}\n+\n+// /a/b\n+func ExampleDir() {\n+\tfmt.Println(path.Dir(\"/a/b/c\"))\n+}\n+\n+// .css\n+func ExampleExt() {\n+\tfmt.Println(path.Ext(\"/a/b/c/bar.css\"))\n+}\n+\n+// true\n+func ExampleIsAbs() {\n+\tfmt.Println(path.IsAbs(\"/dev/null\"))\n+}\n+\n+// a/b/c\n+func ExampleJoin() {\n+\tfmt.Println(path.Join(\"a\", \"b\", \"c\"))\n+}\n+\n+// static/ myfile.css\n+func ExampleSplit() {\n+\tfmt.Println(path.Split(\"static/myfile.css\"))\n+}\n+\n+*/"}, {"sha": "902a359786dbe2d7e8f76e80e722c24a8e94bd73", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1364,8 +1364,19 @@ func TestFieldByName(t *testing.T) {\n }\n \n func TestImportPath(t *testing.T) {\n-\tif path := TypeOf(&base64.Encoding{}).Elem().PkgPath(); path != \"libgo_encoding.base64\" {\n-\t\tt.Errorf(`TypeOf(&base64.Encoding{}).Elem().PkgPath() = %q, want \"libgo_encoding.base64\"`, path)\n+\ttests := []struct {\n+\t\tt    Type\n+\t\tpath string\n+\t}{\n+\t\t{TypeOf(&base64.Encoding{}).Elem(), \"libgo_encoding.base64\"},\n+\t\t{TypeOf(uint(0)), \"\"},\n+\t\t{TypeOf(map[string]int{}), \"\"},\n+\t\t{TypeOf((*error)(nil)).Elem(), \"\"},\n+\t}\n+\tfor _, test := range tests {\n+\t\tif path := test.t.PkgPath(); path != test.path {\n+\t\t\tt.Errorf(\"%v.PkgPath() = %q, want %q\", test.t, path, test.path)\n+\t\t}\n \t}\n }\n "}, {"sha": "e30cf088bb153fdbefc66c0cfeca28765160e7ba", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -69,7 +69,7 @@ type Type interface {\n \n \t// PkgPath returns the type's package path.\n \t// The package path is a full package import path like \"encoding/base64\".\n-\t// PkgPath returns an empty string for unnamed types.\n+\t// PkgPath returns an empty string for unnamed or predeclared types.\n \tPkgPath() string\n \n \t// Size returns the number of bytes needed to store"}, {"sha": "107dfe37cc7fed251f5ffecb93012ac0ff59fddd", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -289,30 +289,45 @@ func TestLiteralPrefix(t *testing.T) {\n \t}\n }\n \n-type numSubexpCase struct {\n-\tinput    string\n-\texpected int\n-}\n-\n-var numSubexpCases = []numSubexpCase{\n-\t{``, 0},\n-\t{`.*`, 0},\n-\t{`abba`, 0},\n-\t{`ab(b)a`, 1},\n-\t{`ab(.*)a`, 1},\n-\t{`(.*)ab(.*)a`, 2},\n-\t{`(.*)(ab)(.*)a`, 3},\n-\t{`(.*)((a)b)(.*)a`, 4},\n-\t{`(.*)(\\(ab)(.*)a`, 3},\n-\t{`(.*)(\\(a\\)b)(.*)a`, 3},\n-}\n-\n-func TestNumSubexp(t *testing.T) {\n-\tfor _, c := range numSubexpCases {\n+type subexpCase struct {\n+\tinput string\n+\tnum   int\n+\tnames []string\n+}\n+\n+var subexpCases = []subexpCase{\n+\t{``, 0, nil},\n+\t{`.*`, 0, nil},\n+\t{`abba`, 0, nil},\n+\t{`ab(b)a`, 1, []string{\"\", \"\"}},\n+\t{`ab(.*)a`, 1, []string{\"\", \"\"}},\n+\t{`(.*)ab(.*)a`, 2, []string{\"\", \"\", \"\"}},\n+\t{`(.*)(ab)(.*)a`, 3, []string{\"\", \"\", \"\", \"\"}},\n+\t{`(.*)((a)b)(.*)a`, 4, []string{\"\", \"\", \"\", \"\", \"\"}},\n+\t{`(.*)(\\(ab)(.*)a`, 3, []string{\"\", \"\", \"\", \"\"}},\n+\t{`(.*)(\\(a\\)b)(.*)a`, 3, []string{\"\", \"\", \"\", \"\"}},\n+\t{`(?P<foo>.*)(?P<bar>(a)b)(?P<foo>.*)a`, 4, []string{\"\", \"foo\", \"bar\", \"\", \"foo\"}},\n+}\n+\n+func TestSubexp(t *testing.T) {\n+\tfor _, c := range subexpCases {\n \t\tre := MustCompile(c.input)\n \t\tn := re.NumSubexp()\n-\t\tif n != c.expected {\n-\t\t\tt.Errorf(\"NumSubexp for %q returned %d, expected %d\", c.input, n, c.expected)\n+\t\tif n != c.num {\n+\t\t\tt.Errorf(\"%q: NumSubexp = %d, want %d\", c.input, n, c.num)\n+\t\t\tcontinue\n+\t\t}\n+\t\tnames := re.SubexpNames()\n+\t\tif len(names) != 1+n {\n+\t\t\tt.Errorf(\"%q: len(SubexpNames) = %d, want %d\", c.input, len(names), n)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif c.names != nil {\n+\t\t\tfor i := 0; i < 1+n; i++ {\n+\t\t\t\tif names[i] != c.names[i] {\n+\t\t\t\t\tt.Errorf(\"%q: SubexpNames[%d] = %q, want %q\", c.input, i, names[i], c.names[i])\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "333ca25542832c2fa67fe018e60ee284057ea25b", "filename": "libgo/go/regexp/exec.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexec.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package regexp\n \n import ("}, {"sha": "ef94fa09b118e7fb640e5976ee76e3582828d124", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,4 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -85,6 +86,7 @@ type Regexp struct {\n \tprefixRune     rune           // first rune in prefix\n \tcond           syntax.EmptyOp // empty-width conditions required at start of match\n \tnumSubexp      int\n+\tsubexpNames    []string\n \tlongest        bool\n \n \t// cache of machines for running regexp\n@@ -140,17 +142,20 @@ func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error) {\n \t\treturn nil, err\n \t}\n \tmaxCap := re.MaxCap()\n+\tcapNames := re.CapNames()\n+\n \tre = re.Simplify()\n \tprog, err := syntax.Compile(re)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tregexp := &Regexp{\n-\t\texpr:      expr,\n-\t\tprog:      prog,\n-\t\tnumSubexp: maxCap,\n-\t\tcond:      prog.StartCond(),\n-\t\tlongest:   longest,\n+\t\texpr:        expr,\n+\t\tprog:        prog,\n+\t\tnumSubexp:   maxCap,\n+\t\tsubexpNames: capNames,\n+\t\tcond:        prog.StartCond(),\n+\t\tlongest:     longest,\n \t}\n \tregexp.prefix, regexp.prefixComplete = prog.Prefix()\n \tif regexp.prefix != \"\" {\n@@ -223,6 +228,15 @@ func (re *Regexp) NumSubexp() int {\n \treturn re.numSubexp\n }\n \n+// SubexpNames returns the names of the parenthesized subexpressions\n+// in this Regexp.  The name for the first sub-expression is names[1],\n+// so that if m is a match slice, the name for m[i] is SubexpNames()[i].\n+// Since the Regexp as a whole cannot be named, names[0] is always\n+// the empty string.  The slice should not be modified.\n+func (re *Regexp) SubexpNames() []string {\n+\treturn re.subexpNames\n+}\n+\n const endOfText rune = -1\n \n // input abstracts different representations of the input text. It provides"}, {"sha": "41955bfc29a2af3d104abe9ea26e4fce6fa9c831", "filename": "libgo/go/regexp/syntax/compile.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package syntax\n \n import \"unicode\""}, {"sha": "902d3b3a57e17797cca9937a08aeb2c8c7b99719", "filename": "libgo/go/regexp/syntax/prog.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package syntax\n \n import ("}, {"sha": "0d96507d9aa726ae4413a559b4199226b25115eb", "filename": "libgo/go/regexp/syntax/prog_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package syntax_test\n \n import ("}, {"sha": "668a07764a1781ca0519c355b0fd096401436729", "filename": "libgo/go/regexp/syntax/regexp.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -303,3 +303,19 @@ func (re *Regexp) MaxCap() int {\n \t}\n \treturn m\n }\n+\n+// CapNames walks the regexp to find the names of capturing groups.\n+func (re *Regexp) CapNames() []string {\n+\tnames := make([]string, re.MaxCap()+1)\n+\tre.capNames(names)\n+\treturn names\n+}\n+\n+func (re *Regexp) capNames(names []string) {\n+\tif re.Op == OpCapture {\n+\t\tnames[re.Cap] = re.Name\n+\t}\n+\tfor _, sub := range re.Sub {\n+\t\tsub.capNames(names)\n+\t}\n+}"}, {"sha": "88598cb7d4b116f4c6c95b7309639973e579388b", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -27,7 +27,7 @@ func Caller(skip int) (pc uintptr, file string, line int, ok bool)\n \n // Callers fills the slice pc with the program counters of function invocations\n // on the calling goroutine's stack.  The argument skip is the number of stack frames\n-// to skip before recording in pc, with 0 starting at the caller of Caller.\n+// to skip before recording in pc, with 0 starting at the caller of Callers.\n // It returns the number of entries written to pc.\n func Callers(skip int, pc []uintptr) int\n "}, {"sha": "00b3a04ce9d0f0fcd82af1f1db9ea6509d8007b7", "filename": "libgo/go/runtime/gc_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fruntime%2Fgc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fruntime%2Fgc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fgc_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package runtime_test\n \n import ("}, {"sha": "ad7557650f60895d95a2a7b79de6392e762cf18f", "filename": "libgo/go/sync/atomic/atomic_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1037,7 +1037,7 @@ func TestStoreLoadSeqCst32(t *testing.T) {\n \t\t\t\tif my != i && his != i {\n \t\t\t\t\tt.Fatalf(\"store/load are not sequentially consistent: %d/%d (%d)\", my, his, i)\n \t\t\t\t}\n-\t\t\t\tack[me][(i-1)%3] = -1\n+\t\t\t\tStoreInt32(&ack[me][(i-1)%3], -1)\n \t\t\t}\n \t\t\tc <- true\n \t\t}(p)\n@@ -1078,7 +1078,7 @@ func TestStoreLoadSeqCst64(t *testing.T) {\n \t\t\t\tif my != i && his != i {\n \t\t\t\t\tt.Fatalf(\"store/load are not sequentially consistent: %d/%d (%d)\", my, his, i)\n \t\t\t\t}\n-\t\t\t\tack[me][(i-1)%3] = -1\n+\t\t\t\tStoreInt64(&ack[me][(i-1)%3], -1)\n \t\t\t}\n \t\t\tc <- true\n \t\t}(p)"}, {"sha": "f77719789928224302fa80d748bb11c327a95d27", "filename": "libgo/go/syscall/syscall.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -34,3 +34,11 @@ var _zero uintptr\n \n var dummy *byte\n const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))\n+\n+func (ts *Timespec) Unix() (sec int64, nsec int64) {\n+\treturn int64(ts.Sec), int64(ts.Nsec)\n+}\n+\n+func (tv *Timeval) Unix() (sec int64, nsec int64) {\n+\treturn int64(tv.Sec), int64(tv.Usec) * 1000\n+}"}, {"sha": "7f8ff2d0541552ba1863e17f2717ccc30adfef5e", "filename": "libgo/go/testing/example.go", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftesting%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftesting%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fexample.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -25,13 +25,6 @@ func RunExamples(examples []InternalExample) (ok bool) {\n \tvar eg InternalExample\n \n \tstdout, stderr := os.Stdout, os.Stderr\n-\tdefer func() {\n-\t\tos.Stdout, os.Stderr = stdout, stderr\n-\t\tif e := recover(); e != nil {\n-\t\t\tfmt.Printf(\"--- FAIL: %s\\npanic: %v\\n\", eg.Name, e)\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t}()\n \n \tfor _, eg = range examples {\n \t\tif *chatty {"}, {"sha": "f1acb97e1b64cccb4db2fac7a1cbe2090d09c70c", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // Package testing provides support for automated testing of Go packages.\n-// It is intended to be used in concert with the ``gotest'' utility, which automates\n+// It is intended to be used in concert with the ``go test'' command, which automates\n // execution of any function of the form\n //     func TestXxx(*testing.T)\n // where Xxx can be any alphanumeric string (but the first letter must not be in\n@@ -21,6 +21,7 @@\n //             fmt.Sprintf(\"hello\")\n //         }\n //     }\n+//\n // The benchmark package will vary b.N until the benchmark function lasts\n // long enough to be timed reliably.  The output\n //     testing.BenchmarkHello    10000000    282 ns/op\n@@ -36,6 +37,33 @@\n //             big.Len()\n //         }\n //     }\n+//\n+// The package also runs and verifies example code. Example functions\n+// include an introductory comment that is compared with the standard output\n+// of the function when the tests are run, as in this example of an example:\n+//\n+//     // hello\n+//     func ExampleHello() {\n+//             fmt.Println(\"hello\")\n+//     }\n+//\n+// Example functions without comments are compiled but not executed.\n+//\n+// The naming convention to declare examples for a function F, a type T and\n+// method M on type T are:\n+//\n+//     func ExampleF() { ... }\n+//     func ExampleT() { ... }\n+//     func ExampleT_M() { ... }\n+//\n+// Multiple example functions for a type/function/method may be provided by\n+// appending a distinct suffix to the name. The suffix must start with a\n+// lower-case letter.\n+//\n+//     func ExampleF_suffix() { ... }\n+//     func ExampleT_suffix() { ... }\n+//     func ExampleT_M_suffix() { ... }\n+//\n package testing\n \n import ("}, {"sha": "274f5ef147778afd0a94908abc4aee657e65e3c9", "filename": "libgo/go/text/template/multi_test.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -9,6 +9,7 @@ package template\n import (\n \t\"bytes\"\n \t\"fmt\"\n+\t\"strings\"\n \t\"testing\"\n \t\"text/template/parse\"\n )\n@@ -32,10 +33,10 @@ var multiParseTests = []multiParseTest{\n \t\tnil},\n \t{\"one\", `{{define \"foo\"}} FOO {{end}}`, noError,\n \t\t[]string{\"foo\"},\n-\t\t[]string{`[(text: \" FOO \")]`}},\n+\t\t[]string{`\" FOO \"`}},\n \t{\"two\", `{{define \"foo\"}} FOO {{end}}{{define \"bar\"}} BAR {{end}}`, noError,\n \t\t[]string{\"foo\", \"bar\"},\n-\t\t[]string{`[(text: \" FOO \")]`, `[(text: \" BAR \")]`}},\n+\t\t[]string{`\" FOO \"`, `\" BAR \"`}},\n \t// errors\n \t{\"missing end\", `{{define \"foo\"}} FOO `, hasError,\n \t\tnil,\n@@ -257,3 +258,17 @@ func TestAddParseTree(t *testing.T) {\n \t\tt.Errorf(\"expected %q got %q\", \"broot\", b.String())\n \t}\n }\n+\n+func TestRedefinition(t *testing.T) {\n+\tvar tmpl *Template\n+\tvar err error\n+\tif tmpl, err = New(\"tmpl1\").Parse(`{{define \"test\"}}foo{{end}}`); err != nil {\n+\t\tt.Fatalf(\"parse 1: %v\", err)\n+\t}\n+\tif _, err = tmpl.New(\"tmpl2\").Parse(`{{define \"test\"}}bar{{end}}`); err == nil {\n+\t\tt.Fatal(\"expected error\")\n+\t}\n+\tif !strings.Contains(err.Error(), \"redefinition\") {\n+\t\tt.Fatalf(\"expected redefinition error; got %v\", err)\n+\t}\n+}"}, {"sha": "0d030b8b4be6d07abb042c2b1f5c2a837009a792", "filename": "libgo/go/text/template/parse/node.go", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -67,11 +67,9 @@ func (l *ListNode) append(n Node) {\n \n func (l *ListNode) String() string {\n \tb := new(bytes.Buffer)\n-\tfmt.Fprint(b, \"[\")\n \tfor _, n := range l.Nodes {\n \t\tfmt.Fprint(b, n)\n \t}\n-\tfmt.Fprint(b, \"]\")\n \treturn b.String()\n }\n \n@@ -86,7 +84,7 @@ func newText(text string) *TextNode {\n }\n \n func (t *TextNode) String() string {\n-\treturn fmt.Sprintf(\"(text: %q)\", t.Text)\n+\treturn fmt.Sprintf(\"%q\", t.Text)\n }\n \n // PipeNode holds a pipeline with optional declaration\n@@ -106,10 +104,23 @@ func (p *PipeNode) append(command *CommandNode) {\n }\n \n func (p *PipeNode) String() string {\n-\tif p.Decl != nil {\n-\t\treturn fmt.Sprintf(\"%v := %v\", p.Decl, p.Cmds)\n+\ts := \"\"\n+\tif len(p.Decl) > 0 {\n+\t\tfor i, v := range p.Decl {\n+\t\t\tif i > 0 {\n+\t\t\t\ts += \", \"\n+\t\t\t}\n+\t\t\ts += v.String()\n+\t\t}\n+\t\ts += \" := \"\n+\t}\n+\tfor i, c := range p.Cmds {\n+\t\tif i > 0 {\n+\t\t\ts += \" | \"\n+\t\t}\n+\t\ts += c.String()\n \t}\n-\treturn fmt.Sprintf(\"%v\", p.Cmds)\n+\treturn s\n }\n \n // ActionNode holds an action (something bounded by delimiters).\n@@ -126,7 +137,8 @@ func newAction(line int, pipe *PipeNode) *ActionNode {\n }\n \n func (a *ActionNode) String() string {\n-\treturn fmt.Sprintf(\"(action: %v)\", a.Pipe)\n+\treturn fmt.Sprintf(\"{{%s}}\", a.Pipe)\n+\n }\n \n // CommandNode holds a command (a pipeline inside an evaluating action).\n@@ -144,7 +156,14 @@ func (c *CommandNode) append(arg Node) {\n }\n \n func (c *CommandNode) String() string {\n-\treturn fmt.Sprintf(\"(command: %v)\", c.Args)\n+\ts := \"\"\n+\tfor i, arg := range c.Args {\n+\t\tif i > 0 {\n+\t\t\ts += \" \"\n+\t\t}\n+\t\ts += arg.String()\n+\t}\n+\treturn s\n }\n \n // IdentifierNode holds an identifier.\n@@ -159,7 +178,7 @@ func NewIdentifier(ident string) *IdentifierNode {\n }\n \n func (i *IdentifierNode) String() string {\n-\treturn fmt.Sprintf(\"I=%s\", i.Ident)\n+\treturn i.Ident\n }\n \n // VariableNode holds a list of variable names. The dollar sign is\n@@ -174,7 +193,14 @@ func newVariable(ident string) *VariableNode {\n }\n \n func (v *VariableNode) String() string {\n-\treturn fmt.Sprintf(\"V=%s\", v.Ident)\n+\ts := \"\"\n+\tfor i, id := range v.Ident {\n+\t\tif i > 0 {\n+\t\t\ts += \".\"\n+\t\t}\n+\t\ts += id\n+\t}\n+\treturn s\n }\n \n // DotNode holds the special identifier '.'. It is represented by a nil pointer.\n@@ -189,7 +215,7 @@ func (d *DotNode) Type() NodeType {\n }\n \n func (d *DotNode) String() string {\n-\treturn \"{{<.>}}\"\n+\treturn \".\"\n }\n \n // FieldNode holds a field (identifier starting with '.').\n@@ -205,7 +231,11 @@ func newField(ident string) *FieldNode {\n }\n \n func (f *FieldNode) String() string {\n-\treturn fmt.Sprintf(\"F=%s\", f.Ident)\n+\ts := \"\"\n+\tfor _, id := range f.Ident {\n+\t\ts += \".\" + id\n+\t}\n+\treturn s\n }\n \n // BoolNode holds a boolean constant.\n@@ -219,7 +249,10 @@ func newBool(true bool) *BoolNode {\n }\n \n func (b *BoolNode) String() string {\n-\treturn fmt.Sprintf(\"B=%t\", b.True)\n+\tif b.True {\n+\t\treturn \"true\"\n+\t}\n+\treturn \"false\"\n }\n \n // NumberNode holds a number: signed or unsigned integer, float, or complex.\n@@ -337,7 +370,7 @@ func (n *NumberNode) simplifyComplex() {\n }\n \n func (n *NumberNode) String() string {\n-\treturn fmt.Sprintf(\"N=%s\", n.Text)\n+\treturn n.Text\n }\n \n // StringNode holds a string constant. The value has been \"unquoted\".\n@@ -352,7 +385,7 @@ func newString(orig, text string) *StringNode {\n }\n \n func (s *StringNode) String() string {\n-\treturn fmt.Sprintf(\"S=%#q\", s.Text)\n+\treturn s.Quoted\n }\n \n // endNode represents an {{end}} action. It is represented by a nil pointer.\n@@ -411,9 +444,9 @@ func (b *BranchNode) String() string {\n \t\tpanic(\"unknown branch type\")\n \t}\n \tif b.ElseList != nil {\n-\t\treturn fmt.Sprintf(\"({{%s %s}} %s {{else}} %s)\", name, b.Pipe, b.List, b.ElseList)\n+\t\treturn fmt.Sprintf(\"{{%s %s}}%s{{else}}%s{{end}}\", name, b.Pipe, b.List, b.ElseList)\n \t}\n-\treturn fmt.Sprintf(\"({{%s %s}} %s)\", name, b.Pipe, b.List)\n+\treturn fmt.Sprintf(\"{{%s %s}}%s{{end}}\", name, b.Pipe, b.List)\n }\n \n // IfNode represents an {{if}} action and its commands."}, {"sha": "13c5548abbf5616cb37f2baffa8e5fe324a6e26e", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -150,7 +150,7 @@ type parseTest struct {\n \tname   string\n \tinput  string\n \tok     bool\n-\tresult string\n+\tresult string // what the user would see in an error message.\n }\n \n const (\n@@ -160,59 +160,57 @@ const (\n \n var parseTests = []parseTest{\n \t{\"empty\", \"\", noError,\n-\t\t`[]`},\n+\t\t``},\n \t{\"comment\", \"{{/*\\n\\n\\n*/}}\", noError,\n-\t\t`[]`},\n+\t\t``},\n \t{\"spaces\", \" \\t\\n\", noError,\n-\t\t`[(text: \" \\t\\n\")]`},\n+\t\t`\" \\t\\n\"`},\n \t{\"text\", \"some text\", noError,\n-\t\t`[(text: \"some text\")]`},\n+\t\t`\"some text\"`},\n \t{\"emptyAction\", \"{{}}\", hasError,\n-\t\t`[(action: [])]`},\n+\t\t`{{}}`},\n \t{\"field\", \"{{.X}}\", noError,\n-\t\t`[(action: [(command: [F=[X]])])]`},\n+\t\t`{{.X}}`},\n \t{\"simple command\", \"{{printf}}\", noError,\n-\t\t`[(action: [(command: [I=printf])])]`},\n+\t\t`{{printf}}`},\n \t{\"$ invocation\", \"{{$}}\", noError,\n-\t\t\"[(action: [(command: [V=[$]])])]\"},\n+\t\t\"{{$}}\"},\n \t{\"variable invocation\", \"{{with $x := 3}}{{$x 23}}{{end}}\", noError,\n-\t\t\"[({{with [V=[$x]] := [(command: [N=3])]}} [(action: [(command: [V=[$x] N=23])])])]\"},\n+\t\t\"{{with $x := 3}}{{$x 23}}{{end}}\"},\n \t{\"variable with fields\", \"{{$.I}}\", noError,\n-\t\t\"[(action: [(command: [V=[$ I]])])]\"},\n+\t\t\"{{$.I}}\"},\n \t{\"multi-word command\", \"{{printf `%d` 23}}\", noError,\n-\t\t\"[(action: [(command: [I=printf S=`%d` N=23])])]\"},\n+\t\t\"{{printf `%d` 23}}\"},\n \t{\"pipeline\", \"{{.X|.Y}}\", noError,\n-\t\t`[(action: [(command: [F=[X]]) (command: [F=[Y]])])]`},\n+\t\t`{{.X | .Y}}`},\n \t{\"pipeline with decl\", \"{{$x := .X|.Y}}\", noError,\n-\t\t`[(action: [V=[$x]] := [(command: [F=[X]]) (command: [F=[Y]])])]`},\n-\t{\"declaration\", \"{{.X|.Y}}\", noError,\n-\t\t`[(action: [(command: [F=[X]]) (command: [F=[Y]])])]`},\n+\t\t`{{$x := .X | .Y}}`},\n \t{\"simple if\", \"{{if .X}}hello{{end}}\", noError,\n-\t\t`[({{if [(command: [F=[X]])]}} [(text: \"hello\")])]`},\n+\t\t`{{if .X}}\"hello\"{{end}}`},\n \t{\"if with else\", \"{{if .X}}true{{else}}false{{end}}\", noError,\n-\t\t`[({{if [(command: [F=[X]])]}} [(text: \"true\")] {{else}} [(text: \"false\")])]`},\n+\t\t`{{if .X}}\"true\"{{else}}\"false\"{{end}}`},\n \t{\"simple range\", \"{{range .X}}hello{{end}}\", noError,\n-\t\t`[({{range [(command: [F=[X]])]}} [(text: \"hello\")])]`},\n+\t\t`{{range .X}}\"hello\"{{end}}`},\n \t{\"chained field range\", \"{{range .X.Y.Z}}hello{{end}}\", noError,\n-\t\t`[({{range [(command: [F=[X Y Z]])]}} [(text: \"hello\")])]`},\n+\t\t`{{range .X.Y.Z}}\"hello\"{{end}}`},\n \t{\"nested range\", \"{{range .X}}hello{{range .Y}}goodbye{{end}}{{end}}\", noError,\n-\t\t`[({{range [(command: [F=[X]])]}} [(text: \"hello\")({{range [(command: [F=[Y]])]}} [(text: \"goodbye\")])])]`},\n+\t\t`{{range .X}}\"hello\"{{range .Y}}\"goodbye\"{{end}}{{end}}`},\n \t{\"range with else\", \"{{range .X}}true{{else}}false{{end}}\", noError,\n-\t\t`[({{range [(command: [F=[X]])]}} [(text: \"true\")] {{else}} [(text: \"false\")])]`},\n+\t\t`{{range .X}}\"true\"{{else}}\"false\"{{end}}`},\n \t{\"range over pipeline\", \"{{range .X|.M}}true{{else}}false{{end}}\", noError,\n-\t\t`[({{range [(command: [F=[X]]) (command: [F=[M]])]}} [(text: \"true\")] {{else}} [(text: \"false\")])]`},\n+\t\t`{{range .X | .M}}\"true\"{{else}}\"false\"{{end}}`},\n \t{\"range []int\", \"{{range .SI}}{{.}}{{end}}\", noError,\n-\t\t`[({{range [(command: [F=[SI]])]}} [(action: [(command: [{{<.>}}])])])]`},\n+\t\t`{{range .SI}}{{.}}{{end}}`},\n \t{\"constants\", \"{{range .SI 1 -3.2i true false 'a'}}{{end}}\", noError,\n-\t\t`[({{range [(command: [F=[SI] N=1 N=-3.2i B=true B=false N='a'])]}} [])]`},\n+\t\t`{{range .SI 1 -3.2i true false 'a'}}{{end}}`},\n \t{\"template\", \"{{template `x`}}\", noError,\n-\t\t`[{{template \"x\"}}]`},\n+\t\t`{{template \"x\"}}`},\n \t{\"template with arg\", \"{{template `x` .Y}}\", noError,\n-\t\t`[{{template \"x\" [(command: [F=[Y]])]}}]`},\n+\t\t`{{template \"x\" .Y}}`},\n \t{\"with\", \"{{with .X}}hello{{end}}\", noError,\n-\t\t`[({{with [(command: [F=[X]])]}} [(text: \"hello\")])]`},\n+\t\t`{{with .X}}\"hello\"{{end}}`},\n \t{\"with with else\", \"{{with .X}}hello{{else}}goodbye{{end}}\", noError,\n-\t\t`[({{with [(command: [F=[X]])]}} [(text: \"hello\")] {{else}} [(text: \"goodbye\")])]`},\n+\t\t`{{with .X}}\"hello\"{{else}}\"goodbye\"{{end}}`},\n \t// Errors.\n \t{\"unclosed action\", \"hello{{range\", hasError, \"\"},\n \t{\"unmatched end\", \"{{end}}\", hasError, \"\"},"}, {"sha": "87e39d3af740f817c1f1a9825f79d2fd88b75a92", "filename": "libgo/go/text/template/template.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -198,7 +198,7 @@ func (t *Template) associate(new *Template) error {\n \tname := new.name\n \tif old := t.tmpl[name]; old != nil {\n \t\toldIsEmpty := parse.IsEmptyTree(old.Root)\n-\t\tnewIsEmpty := parse.IsEmptyTree(new.Root)\n+\t\tnewIsEmpty := new.Tree != nil && parse.IsEmptyTree(new.Root)\n \t\tif !oldIsEmpty && !newIsEmpty {\n \t\t\treturn fmt.Errorf(\"template: redefinition of template %q\", name)\n \t\t}"}, {"sha": "76bf6ff4194873b428e57f31f2eb4c58e4950b5c", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package time\n \n import \"errors\""}, {"sha": "39d4b95dd0648285ea3d86bbc8a9900781ebd61a", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -130,24 +130,24 @@ var days = [...]string{\n func (d Weekday) String() string { return days[d] }\n \n // Computations on time.\n-// \n+//\n // The zero value for a Time is defined to be\n //\tJanuary 1, year 1, 00:00:00.000000000 UTC\n // which (1) looks like a zero, or as close as you can get in a date\n // (1-1-1 00:00:00 UTC), (2) is unlikely enough to arise in practice to\n // be a suitable \"not set\" sentinel, unlike Jan 1 1970, and (3) has a\n // non-negative year even in time zones west of UTC, unlike 1-1-0\n // 00:00:00 UTC, which would be 12-31-(-1) 19:00:00 in New York.\n-// \n+//\n // The zero Time value does not force a specific epoch for the time\n // representation.  For example, to use the Unix epoch internally, we\n // could define that to distinguish a zero value from Jan 1 1970, that\n // time would be represented by sec=-1, nsec=1e9.  However, it does\n // suggest a representation, namely using 1-1-1 00:00:00 UTC as the\n // epoch, and that's what we do.\n-// \n+//\n // The Add and Sub computations are oblivious to the choice of epoch.\n-// \n+//\n // The presentation computations - year, month, minute, and so on - all\n // rely heavily on division and modulus by positive constants.  For\n // calendrical calculations we want these divisions to round down, even\n@@ -172,7 +172,7 @@ func (d Weekday) String() string { return days[d] }\n //\t}\n //\n // everywhere.\n-// \n+//\n // The calendar runs on an exact 400 year cycle: a 400-year calendar\n // printed for 1970-2469 will apply as well to 2470-2869.  Even the days\n // of the week match up.  It simplifies the computations to choose the\n@@ -182,30 +182,30 @@ func (d Weekday) String() string { return days[d] }\n // is the 100th year, and the missed missed leap year is the 400th year.\n // So we'd prefer instead to print a calendar for 2001-2400 and reuse it\n // for 2401-2800.\n-// \n+//\n // Finally, it's convenient if the delta between the Unix epoch and\n // long-ago epoch is representable by an int64 constant.\n-// \n+//\n // These three considerations\u2014choose an epoch as early as possible, that\n // uses a year equal to 1 mod 400, and that is no more than 2\u2076\u00b3 seconds\n // earlier than 1970\u2014bring us to the year -292277022399.  We refer to\n // this year as the absolute zero year, and to times measured as a uint64\n // seconds since this year as absolute times.\n-// \n+//\n // Times measured as an int64 seconds since the year 1\u2014the representation\n // used for Time's sec field\u2014are called internal times.\n-// \n+//\n // Times measured as an int64 seconds since the year 1970 are called Unix\n // times.\n-// \n+//\n // It is tempting to just use the year 1 as the absolute epoch, defining\n // that the routines are only valid for years >= 1.  However, the\n // routines would then be invalid when displaying the epoch in time zones\n // west of UTC, since it is year 0.  It doesn't seem tenable to say that\n // printing the zero time correctly isn't supported in half the time\n // zones.  By comparison, it's reasonable to mishandle some times in\n // the year -292277022399.\n-// \n+//\n // All this is opaque to clients of the API and can be changed if a\n // better implementation presents itself.\n \n@@ -288,8 +288,8 @@ func (t Time) Weekday() Weekday {\n }\n \n // ISOWeek returns the ISO 8601 year and week number in which t occurs.\n-// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to \n-// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 \n+// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to\n+// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1\n // of year n+1.\n func (t Time) ISOWeek() (year, week int) {\n \tyear, month, day, yday := t.date(true)\n@@ -566,6 +566,12 @@ func (t Time) Sub(u Time) Duration {\n \treturn Duration(t.sec-u.sec)*Second + Duration(t.nsec-u.nsec)\n }\n \n+// Since returns the time elapsed since t.\n+// It is shorthand for time.Now().Sub(t).\n+func Since(t Time) Duration {\n+\treturn Now().Sub(t)\n+}\n+\n // AddDate returns the time corresponding to adding the\n // given number of years, months, and days to t.\n // For example, AddDate(-1, 2, 3) applied to January 1, 2011"}, {"sha": "22dbc1f8db37f204b16e286e443c010a62224170", "filename": "libgo/go/websocket/hixie.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhixie.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -343,7 +343,7 @@ func hixie76ClientHandshake(config *Config, br *bufio.Reader, bw *bufio.Writer)\n \t}\n \t// 4.1. Opening handshake.\n \t// Step 5.  send a request line.\n-\tbw.WriteString(\"GET \" + config.Location.RawPath + \" HTTP/1.1\\r\\n\")\n+\tbw.WriteString(\"GET \" + config.Location.RequestURI() + \" HTTP/1.1\\r\\n\")\n \n \t// Step 6-14. push request headers in fields.\n \tfields := []string{\n@@ -456,7 +456,7 @@ func hixie75ClientHandshake(config *Config, br *bufio.Reader, bw *bufio.Writer)\n \tif config.Version != ProtocolVersionHixie75 {\n \t\tpanic(\"wrong protocol version.\")\n \t}\n-\tbw.WriteString(\"GET \" + config.Location.RawPath + \" HTTP/1.1\\r\\n\")\n+\tbw.WriteString(\"GET \" + config.Location.RequestURI() + \" HTTP/1.1\\r\\n\")\n \tbw.WriteString(\"Upgrade: WebSocket\\r\\n\")\n \tbw.WriteString(\"Connection: Upgrade\\r\\n\")\n \tbw.WriteString(\"Host: \" + config.Location.Host + \"\\r\\n\")\n@@ -557,7 +557,7 @@ func (c *hixie76ServerHandshaker) ReadHandshake(buf *bufio.Reader, req *http.Req\n \t} else {\n \t\tscheme = \"ws\"\n \t}\n-\tc.Location, err = url.ParseRequest(scheme + \"://\" + req.Host + req.URL.RawPath)\n+\tc.Location, err = url.ParseRequest(scheme + \"://\" + req.Host + req.URL.RequestURI())\n \tif err != nil {\n \t\treturn http.StatusBadRequest, err\n \t}\n@@ -653,7 +653,7 @@ func (c *hixie75ServerHandshaker) ReadHandshake(buf *bufio.Reader, req *http.Req\n \t} else {\n \t\tscheme = \"ws\"\n \t}\n-\tc.Location, err = url.ParseRequest(scheme + \"://\" + req.Host + req.URL.RawPath)\n+\tc.Location, err = url.ParseRequest(scheme + \"://\" + req.Host + req.URL.RequestURI())\n \tif err != nil {\n \t\treturn http.StatusBadRequest, err\n \t}"}, {"sha": "6b0c5286f2820a8006a9949fdc34484db76fc22a", "filename": "libgo/go/websocket/hybi.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fwebsocket%2Fhybi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fwebsocket%2Fhybi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhybi.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -390,7 +390,7 @@ func hybiClientHandshake(config *Config, br *bufio.Reader, bw *bufio.Writer) (er\n \t\tpanic(\"wrong protocol version.\")\n \t}\n \n-\tbw.WriteString(\"GET \" + config.Location.RawPath + \" HTTP/1.1\\r\\n\")\n+\tbw.WriteString(\"GET \" + config.Location.RequestURI() + \" HTTP/1.1\\r\\n\")\n \n \tbw.WriteString(\"Host: \" + config.Location.Host + \"\\r\\n\")\n \tbw.WriteString(\"Upgrade: websocket\\r\\n\")\n@@ -505,7 +505,7 @@ func (c *hybiServerHandshaker) ReadHandshake(buf *bufio.Reader, req *http.Reques\n \t} else {\n \t\tscheme = \"ws\"\n \t}\n-\tc.Location, err = url.ParseRequest(scheme + \"://\" + req.Host + req.URL.RawPath)\n+\tc.Location, err = url.ParseRequest(scheme + \"://\" + req.Host + req.URL.RequestURI())\n \tif err != nil {\n \t\treturn http.StatusBadRequest, err\n \t}"}, {"sha": "f7aabc94b35d1d48dd9c63fa9705a9e3512785be", "filename": "libgo/go/websocket/websocket.go", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92e385667da3fc91ac7f9f0867a56c111110b8/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go?ref=af92e385667da3fc91ac7f9f0867a56c111110b8", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/url\"\n \t\"sync\"\n+\t\"time\"\n )\n \n const (\n@@ -243,30 +244,30 @@ func (ws *Conn) RemoteAddr() net.Addr {\n \treturn &Addr{ws.config.Origin}\n }\n \n-var errSetTimeout = errors.New(\"websocket: cannot set timeout: not using a net.Conn\")\n+var errSetDeadline = errors.New(\"websocket: cannot set deadline: not using a net.Conn\")\n \n-// SetTimeout sets the connection's network timeout in nanoseconds.\n-func (ws *Conn) SetTimeout(nsec int64) error {\n+// SetDeadline sets the connection's network read & write deadlines.\n+func (ws *Conn) SetDeadline(t time.Time) error {\n \tif conn, ok := ws.rwc.(net.Conn); ok {\n-\t\treturn conn.SetTimeout(nsec)\n+\t\treturn conn.SetDeadline(t)\n \t}\n-\treturn errSetTimeout\n+\treturn errSetDeadline\n }\n \n-// SetReadTimeout sets the connection's network read timeout in nanoseconds.\n-func (ws *Conn) SetReadTimeout(nsec int64) error {\n+// SetReadDeadline sets the connection's network read deadline.\n+func (ws *Conn) SetReadDeadline(t time.Time) error {\n \tif conn, ok := ws.rwc.(net.Conn); ok {\n-\t\treturn conn.SetReadTimeout(nsec)\n+\t\treturn conn.SetReadDeadline(t)\n \t}\n-\treturn errSetTimeout\n+\treturn errSetDeadline\n }\n \n-// SetWriteTimeout sets the connection's network write timeout in nanoseconds.\n-func (ws *Conn) SetWriteTimeout(nsec int64) error {\n+// SetWriteDeadline sets the connection's network write deadline.\n+func (ws *Conn) SetWriteDeadline(t time.Time) error {\n \tif conn, ok := ws.rwc.(net.Conn); ok {\n-\t\treturn conn.SetWriteTimeout(nsec)\n+\t\treturn conn.SetWriteDeadline(t)\n \t}\n-\treturn errSetTimeout\n+\treturn errSetDeadline\n }\n \n // Config returns the WebSocket config."}]}