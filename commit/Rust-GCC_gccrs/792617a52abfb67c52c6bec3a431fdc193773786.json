{"sha": "792617a52abfb67c52c6bec3a431fdc193773786", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyNjE3YTUyYWJmYjY3YzUyYzZiZWMzYTQzMWZkYzE5Mzc3Mzc4Ng==", "commit": {"author": {"name": "Anthony Balkissoon", "email": "abalkiss@redhat.com", "date": "2006-03-28T16:12:52Z"}, "committer": {"name": "Anthony Balkissoon", "email": "abalkiss@gcc.gnu.org", "date": "2006-03-28T16:12:52Z"}, "message": "unicode-muncher.pl: Removed this file.\n\n2006-03-28  Anthony Balkissoon  <abalkiss@redhat.com>\n\n\t* scripts/unicode-muncher.pl: Removed this file.\n\t* scripts/MakeCharTables.java: Likewise.\n\t* scripts/unicode-to-chartables.pl: New file.\n\t* java/lang/natCharacter.cc: \n\t(UNASSIGNED_TYPE): New field.\n\t(UNASSIGNED_DIGIT): Likewise.\n\t(UNASSIGNED_DIRECTION): Likewise.\n\t(UNASSIGNED_NUMERIC_VALUE): Likewise.\n\t(PRIVATE_TYPE): Likewise.\n\t(PRIVATE_DIRECTION): Likewise.\n\t(readCodePoint): New method.\n\t(getType(jint)): Likewise.\n\t(toLowerCase(jint)): Likewise.\n\t(toUpperCase(jint)): Likewise.\n\t(toTitleCase(jint)): Likewise.\n\t(digit(jint, jint)): Likewise.\n\t(getNumericValue(jint)): Likewise.\n\t(getDirectionality(jint)): Likewise.\n\t(readChar),\n\t(getType(jchar)),\n\t(toLowerCase(jchar)),\n\t(toUpperCase(jchar)),\n\t(toTitleCase(jchar)),\n\t(digit(jchar, jint)),\n\t(getNumericValue(jchar)),\n\t(getDirectionality(jchar)): Changed references from data to data[0], \n\tblocks to blocks[0], direction to direction[0], numValue to \n\tnumValue[0], upper to upper[0], lower to lower[0], and shift to \n\tshift[0] to reflect the new structures in java-chartables.h.\t\n\t* java/lang/Character.java:\n\t(readCodePoint): Declared new native method.\n\t(getType(int)): Likewise.\n\t(toLowerCase(int)): Likewise.\n\t(toUpperCase(int)): Likewise.\n\t(toTitleCase(int)): Likewise.\n\t(digit(int, int)): Likewise.\n\t(getNumericValue(int)): Likewise.\n\t(getDirectionality(int)): Likewise.\n\t(isLowerCase(int)): New method.\n\t(isUpperCase(int)): Likewise.\n\t(itTitleCase(int)): Likewise.\n\t(isDigit(int)): Likewise.\n\t(isDefined(int)): Likewise.\n\t(isLetter(int)): Likewise.\n\t(isLetterOrDigit(int)): Likewise.\n\t(isJavaIdentifierStart(int)): Likewise.\n\t(isJavaIdentifierPart(int)): Likewise.\n\t(isUnicodeIdentifierStart(int)): Likewise.\n\t(isUnicodeIdentifierPart(int)): Likewise.\n\t(isIdentifierIgnorable(int)): Likewise.\n\t(isSpaceChar(int)): Likewise.\n\t(isWhitespace(int)): Likewise.\n\t(isISOControl(int)): Likewise.\n\t(isMirrored(int)): Likewise.\n\t* include/java-chartables.h: Generated from \n\tscripts/unicode-to-chartables.h.\n\nFrom-SVN: r112454", "tree": {"sha": "33d3cdf25e29b600aa40340320a592051654c632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33d3cdf25e29b600aa40340320a592051654c632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792617a52abfb67c52c6bec3a431fdc193773786", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792617a52abfb67c52c6bec3a431fdc193773786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792617a52abfb67c52c6bec3a431fdc193773786", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792617a52abfb67c52c6bec3a431fdc193773786/comments", "author": null, "committer": null, "parents": [{"sha": "72922229b7431aac7f5ac3d207a017473dccce4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72922229b7431aac7f5ac3d207a017473dccce4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72922229b7431aac7f5ac3d207a017473dccce4d"}], "stats": {"total": 3996, "additions": 3110, "deletions": 886}, "files": [{"sha": "3540ccf057b6afb257216357d2307b7407ef273d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=792617a52abfb67c52c6bec3a431fdc193773786", "patch": "@@ -1,3 +1,62 @@\n+2006-03-28  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* scripts/unicode-muncher.pl: Removed this file.\n+\t* scripts/MakeCharTables.java: Likewise.\n+\t* scripts/unicode-to-chartables.pl: New file.\n+\t* java/lang/natCharacter.cc: \n+\t(UNASSIGNED_TYPE): New field.\n+\t(UNASSIGNED_DIGIT): Likewise.\n+\t(UNASSIGNED_DIRECTION): Likewise.\n+\t(UNASSIGNED_NUMERIC_VALUE): Likewise.\n+\t(PRIVATE_TYPE): Likewise.\n+\t(PRIVATE_DIRECTION): Likewise.\n+\t(readCodePoint): New method.\n+\t(getType(jint)): Likewise.\n+\t(toLowerCase(jint)): Likewise.\n+\t(toUpperCase(jint)): Likewise.\n+\t(toTitleCase(jint)): Likewise.\n+\t(digit(jint, jint)): Likewise.\n+\t(getNumericValue(jint)): Likewise.\n+\t(getDirectionality(jint)): Likewise.\n+\t(readChar),\n+\t(getType(jchar)),\n+\t(toLowerCase(jchar)),\n+\t(toUpperCase(jchar)),\n+\t(toTitleCase(jchar)),\n+\t(digit(jchar, jint)),\n+\t(getNumericValue(jchar)),\n+\t(getDirectionality(jchar)): Changed references from data to data[0], \n+\tblocks to blocks[0], direction to direction[0], numValue to \n+\tnumValue[0], upper to upper[0], lower to lower[0], and shift to \n+\tshift[0] to reflect the new structures in java-chartables.h.\t\n+\t* java/lang/Character.java:\n+\t(readCodePoint): Declared new native method.\n+\t(getType(int)): Likewise.\n+\t(toLowerCase(int)): Likewise.\n+\t(toUpperCase(int)): Likewise.\n+\t(toTitleCase(int)): Likewise.\n+\t(digit(int, int)): Likewise.\n+\t(getNumericValue(int)): Likewise.\n+\t(getDirectionality(int)): Likewise.\n+\t(isLowerCase(int)): New method.\n+\t(isUpperCase(int)): Likewise.\n+\t(itTitleCase(int)): Likewise.\n+\t(isDigit(int)): Likewise.\n+\t(isDefined(int)): Likewise.\n+\t(isLetter(int)): Likewise.\n+\t(isLetterOrDigit(int)): Likewise.\n+\t(isJavaIdentifierStart(int)): Likewise.\n+\t(isJavaIdentifierPart(int)): Likewise.\n+\t(isUnicodeIdentifierStart(int)): Likewise.\n+\t(isUnicodeIdentifierPart(int)): Likewise.\n+\t(isIdentifierIgnorable(int)): Likewise.\n+\t(isSpaceChar(int)): Likewise.\n+\t(isWhitespace(int)): Likewise.\n+\t(isISOControl(int)): Likewise.\n+\t(isMirrored(int)): Likewise.\n+\t* include/java-chartables.h: Generated from \n+\tscripts/unicode-to-chartables.h.\n+\n 2006-03-24  David Daney  <ddaney@avtrex.com)\n \n \t* testsuite/libjava.lang/PR26858.java: New test."}, {"sha": "d882c675e980bec6d7f6256f1f5a13f6494e467e", "filename": "libjava/include/java-chartables.h", "status": "modified", "additions": 1509, "deletions": 879, "changes": 2388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Finclude%2Fjava-chartables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Finclude%2Fjava-chartables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-chartables.h?ref=792617a52abfb67c52c6bec3a431fdc193773786"}, {"sha": "ec6d2a4af1447a0b1e18593a49b005118fb9f7f0", "filename": "libjava/java/lang/Character.java", "status": "modified", "additions": 609, "deletions": 0, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Fjava%2Flang%2FCharacter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Fjava%2Flang%2FCharacter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter.java?ref=792617a52abfb67c52c6bec3a431fdc193773786", "patch": "@@ -2168,6 +2168,21 @@ else if (blockName.indexOf('_') != -1)\n    */\n   private static native char readChar(char ch);\n \n+  /**\n+   * Grabs an attribute offset from the Unicode attribute database. The lower\n+   * 5 bits are the character type, the next 2 bits are flags, and the top\n+   * 9 bits are the offset into the attribute tables. Note that the top 9\n+   * bits are meaningless in this context; they are useful only in the native\n+   * code.\n+   *\n+   * @param codePoint the character to look up\n+   * @return the character's attribute offset and type\n+   * @see #TYPE_MASK\n+   * @see #NO_BREAK_MASK\n+   * @see #MIRROR_MASK\n+   */\n+  private static native char readCodePoint(int codePoint);\n+\n   /**\n    * Wraps up a character.\n    *\n@@ -2256,6 +2271,26 @@ public static boolean isLowerCase(char ch)\n     return getType(ch) == LOWERCASE_LETTER;\n   }\n \n+  /**\n+   * Determines if a character is a Unicode lowercase letter. For example,\n+   * <code>'a'</code> is lowercase.  Unlike isLowerCase(char), this method\n+   * supports supplementary Unicode code points.\n+   * <br>\n+   * lowercase = [Ll]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is a Unicode lowercase letter, else false\n+   * @see #isUpperCase(int)\n+   * @see #isTitleCase(int)\n+   * @see #toLowerCase(int)\n+   * @see #getType(int)\n+   * @since 1.5\n+   */\n+  public static boolean isLowerCase(int codePoint)\n+  {\n+    return getType(codePoint) == LOWERCASE_LETTER;\n+  }\n+\n   /**\n    * Determines if a character is a Unicode uppercase letter. For example,\n    * <code>'A'</code> is uppercase.\n@@ -2274,6 +2309,26 @@ public static boolean isUpperCase(char ch)\n     return getType(ch) == UPPERCASE_LETTER;\n   }\n \n+  /**\n+   * Determines if a character is a Unicode uppercase letter. For example,\n+   * <code>'A'</code> is uppercase.  Unlike isUpperCase(char), this method\n+   * supports supplementary Unicode code points.\n+   * <br>\n+   * uppercase = [Lu]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is a Unicode uppercase letter, else false\n+   * @see #isLowerCase(int)\n+   * @see #isTitleCase(int)\n+   * @see #toUpperCase(int)\n+   * @see #getType(int)\n+   * @since 1.5\n+   */\n+  public static boolean isUpperCase(int codePoint)\n+  {\n+    return getType(codePoint) == UPPERCASE_LETTER;\n+  }\n+\n   /**\n    * Determines if a character is a Unicode titlecase letter. For example,\n    * the character \"Lj\" (Latin capital L with small letter j) is titlecase.\n@@ -2292,6 +2347,27 @@ public static boolean isTitleCase(char ch)\n     return getType(ch) == TITLECASE_LETTER;\n   }\n \n+  /**\n+   * Determines if a character is a Unicode titlecase letter. For example,\n+   * the character \"Lj\" (Latin capital L with small letter j) is titlecase.\n+   * Unlike isTitleCase(char), this method supports supplementary Unicode\n+   * code points.\n+   * <br>\n+   * titlecase = [Lt]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is a Unicode titlecase letter, else false\n+   * @see #isLowerCase(int)\n+   * @see #isUpperCase(int)\n+   * @see #toTitleCase(int)\n+   * @see #getType(int)\n+   * @since 1.5\n+   */\n+  public static boolean isTitleCase(int codePoint)\n+  {\n+    return getType(codePoint) == TITLECASE_LETTER;\n+  }\n+\n   /**\n    * Determines if a character is a Unicode decimal digit. For example,\n    * <code>'0'</code> is a digit.\n@@ -2309,6 +2385,25 @@ public static boolean isDigit(char ch)\n     return getType(ch) == DECIMAL_DIGIT_NUMBER;\n   }\n \n+  /**\n+   * Determines if a character is a Unicode decimal digit. For example,\n+   * <code>'0'</code> is a digit.  Unlike isDigit(char), this method\n+   * supports supplementary Unicode code points.\n+   * <br>\n+   * Unicode decimal digit = [Nd]\n+   *\n+   * @param codePoint character to test\n+   * @return true if ccodePoint is a Unicode decimal digit, else false\n+   * @see #digit(int, int)\n+   * @see #forDigit(int, int)\n+   * @see #getType(int)\n+   * @since 1.5\n+   */\n+  public static boolean isDigit(int codePoint)\n+  {\n+    return getType(codePoint) == DECIMAL_DIGIT_NUMBER;\n+  }\n+\n   /**\n    * Determines if a character is part of the Unicode Standard. This is an\n    * evolving standard, but covers every character in the data file.\n@@ -2329,6 +2424,28 @@ public static boolean isDefined(char ch)\n     return getType(ch) != UNASSIGNED;\n   }\n \n+  /**\n+   * Determines if a character is part of the Unicode Standard. This is an\n+   * evolving standard, but covers every character in the data file.  Unlike\n+   * isDefined(char), this method supports supplementary Unicode code points.\n+   * <br>\n+   * defined = not [Cn]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is a Unicode character, else false\n+   * @see #isDigit(int)\n+   * @see #isLetter(int)\n+   * @see #isLetterOrDigit(int)\n+   * @see #isLowerCase(int)\n+   * @see #isTitleCase(int)\n+   * @see #isUpperCase(int)\n+   * @since 1.5\n+   */\n+  public static boolean isDefined(int codePoint)\n+  {\n+    return getType(codePoint) != UNASSIGNED;\n+  }\n+\n   /**\n    * Determines if a character is a Unicode letter. Not all letters have case,\n    * so this may return true when isLowerCase and isUpperCase return false.\n@@ -2357,6 +2474,37 @@ public static boolean isLetter(char ch)\n                | (1 << OTHER_LETTER))) != 0;\n   }\n \n+  /**\n+   * Determines if a character is a Unicode letter. Not all letters have case,\n+   * so this may return true when isLowerCase and isUpperCase return false.\n+   * Unlike isLetter(char), this method supports supplementary Unicode code\n+   * points.\n+   * <br>\n+   * letter = [Lu]|[Ll]|[Lt]|[Lm]|[Lo]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is a Unicode letter, else false\n+   * @see #isDigit(int)\n+   * @see #isJavaIdentifierStart(int)\n+   * @see #isJavaLetter(int)\n+   * @see #isJavaLetterOrDigit(int)\n+   * @see #isLetterOrDigit(int)\n+   * @see #isLowerCase(int)\n+   * @see #isTitleCase(int)\n+   * @see #isUnicodeIdentifierStart(int)\n+   * @see #isUpperCase(int)\n+   * @since 1.5\n+   */\n+  public static boolean isLetter(int codePoint)\n+  {\n+    return ((1 << getType(codePoint))\n+            & ((1 << UPPERCASE_LETTER)\n+               | (1 << LOWERCASE_LETTER)\n+               | (1 << TITLECASE_LETTER)\n+               | (1 << MODIFIER_LETTER)\n+               | (1 << OTHER_LETTER))) != 0;\n+  }\n+\n   /**\n    * Determines if a character is a Unicode letter or a Unicode digit. This\n    * is the combination of isLetter and isDigit.\n@@ -2383,6 +2531,34 @@ public static boolean isLetterOrDigit(char ch)\n                | (1 << DECIMAL_DIGIT_NUMBER))) != 0;\n   }\n \n+  /**\n+   * Determines if a character is a Unicode letter or a Unicode digit. This\n+   * is the combination of isLetter and isDigit.  Unlike isLetterOrDigit(char),\n+   * this method supports supplementary Unicode code points.\n+   * <br>\n+   * letter or digit = [Lu]|[Ll]|[Lt]|[Lm]|[Lo]|[Nd]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is a Unicode letter or a Unicode digit, else false\n+   * @see #isDigit(int)\n+   * @see #isJavaIdentifierPart(int)\n+   * @see #isJavaLetter(int)\n+   * @see #isJavaLetterOrDigit(int)\n+   * @see #isLetter(int)\n+   * @see #isUnicodeIdentifierPart(int)\n+   * @since 1.5\n+   */\n+  public static boolean isLetterOrDigit(int codePoint)\n+  {\n+    return ((1 << getType(codePoint)\n+            & ((1 << UPPERCASE_LETTER)\n+               | (1 << LOWERCASE_LETTER)\n+               | (1 << TITLECASE_LETTER)\n+               | (1 << MODIFIER_LETTER)\n+               | (1 << OTHER_LETTER)\n+               | (1 << DECIMAL_DIGIT_NUMBER))) != 0);\n+  }\n+\n   /**\n    * Determines if a character can start a Java identifier. This is the\n    * combination of isLetter, any character where getType returns\n@@ -2404,6 +2580,35 @@ public static boolean isJavaLetter(char ch)\n     return isJavaIdentifierStart(ch);\n   }\n \n+  /**\n+   * Determines if a character can start a Java identifier. This is the\n+   * combination of isLetter, any character where getType returns\n+   * LETTER_NUMBER, currency symbols (like '$'), and connecting punctuation\n+   * (like '_'). Unlike isJavaIdentifierStart(char), this method supports\n+   * supplementary Unicode code points.\n+   * <br>\n+   * Java identifier start = [Lu]|[Ll]|[Lt]|[Lm]|[Lo]|[Nl]|[Sc]|[Pc]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint can start a Java identifier, else false\n+   * @see #isJavaIdentifierPart(int)\n+   * @see #isLetter(int)\n+   * @see #isUnicodeIdentifierStart(int)\n+   * @since 1.5\n+   */\n+  public static boolean isJavaIdentifierStart(int codePoint)\n+  {\n+    return ((1 << getType(codePoint))\n+            & ((1 << UPPERCASE_LETTER)\n+               | (1 << LOWERCASE_LETTER)\n+               | (1 << TITLECASE_LETTER)\n+               | (1 << MODIFIER_LETTER)\n+               | (1 << OTHER_LETTER)\n+               | (1 << LETTER_NUMBER)\n+               | (1 << CURRENCY_SYMBOL)\n+               | (1 << CONNECTOR_PUNCTUATION))) != 0;\n+  }\n+\n   /**\n    * Determines if a character can follow the first letter in\n    * a Java identifier.  This is the combination of isJavaLetter (isLetter,\n@@ -2493,6 +2698,45 @@ public static boolean isJavaIdentifierPart(char ch)\n       || (category == CONTROL && isIdentifierIgnorable(ch));\n   }\n \n+  /**\n+   * Determines if a character can follow the first letter in\n+   * a Java identifier.  This is the combination of isJavaLetter (isLetter,\n+   * type of LETTER_NUMBER, currency, connecting punctuation) and digit,\n+   * numeric letter (like Roman numerals), combining marks, non-spacing marks,\n+   * or isIdentifierIgnorable. Unlike isJavaIdentifierPart(char), this method\n+   * supports supplementary Unicode code points.\n+   * <br>\n+   * Java identifier extender =\n+   *   [Lu]|[Ll]|[Lt]|[Lm]|[Lo]|[Nl]|[Sc]|[Pc]|[Mn]|[Mc]|[Nd]|[Cf]\n+   *   |U+0000-U+0008|U+000E-U+001B|U+007F-U+009F\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint can follow the first letter in a Java identifier\n+   * @see #isIdentifierIgnorable(int)\n+   * @see #isJavaIdentifierStart(int)\n+   * @see #isLetterOrDigit(int)\n+   * @see #isUnicodeIdentifierPart(int)\n+   * @since 1.5\n+   */\n+  public static boolean isJavaIdentifierPart(int codePoint)\n+  {\n+    int category = getType(codePoint);\n+    return ((1 << category)\n+            & ((1 << UPPERCASE_LETTER)\n+               | (1 << LOWERCASE_LETTER)\n+               | (1 << TITLECASE_LETTER)\n+               | (1 << MODIFIER_LETTER)\n+               | (1 << OTHER_LETTER)\n+               | (1 << NON_SPACING_MARK)\n+               | (1 << COMBINING_SPACING_MARK)\n+               | (1 << DECIMAL_DIGIT_NUMBER)\n+               | (1 << LETTER_NUMBER)\n+               | (1 << CURRENCY_SYMBOL)\n+               | (1 << CONNECTOR_PUNCTUATION)\n+               | (1 << FORMAT))) != 0\n+      || (category == CONTROL && isIdentifierIgnorable(codePoint));\n+  }\n+\n   /**\n    * Determines if a character can start a Unicode identifier.  Only\n    * letters can start a Unicode identifier, but this includes characters\n@@ -2518,6 +2762,32 @@ public static boolean isUnicodeIdentifierStart(char ch)\n                | (1 << LETTER_NUMBER))) != 0;\n   }\n \n+  /**\n+   * Determines if a character can start a Unicode identifier.  Only\n+   * letters can start a Unicode identifier, but this includes characters\n+   * in LETTER_NUMBER.  Unlike isUnicodeIdentifierStart(char), this method\n+   * supports supplementary Unicode code points.\n+   * <br>\n+   * Unicode identifier start = [Lu]|[Ll]|[Lt]|[Lm]|[Lo]|[Nl]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint can start a Unicode identifier, else false\n+   * @see #isJavaIdentifierStart(int)\n+   * @see #isLetter(int)\n+   * @see #isUnicodeIdentifierPart(int)\n+   * @since 1.5\n+   */\n+  public static boolean isUnicodeIdentifierStart(int codePoint)\n+  {\n+    return ((1 << getType(codePoint))\n+            & ((1 << UPPERCASE_LETTER)\n+               | (1 << LOWERCASE_LETTER)\n+               | (1 << TITLECASE_LETTER)\n+               | (1 << MODIFIER_LETTER)\n+               | (1 << OTHER_LETTER)\n+               | (1 << LETTER_NUMBER))) != 0;\n+  }\n+\n   /**\n    * Determines if a character can follow the first letter in\n    * a Unicode identifier. This includes letters, connecting punctuation,\n@@ -2554,6 +2824,44 @@ public static boolean isUnicodeIdentifierPart(char ch)\n       || (category == CONTROL && isIdentifierIgnorable(ch));\n   }\n \n+  /**\n+   * Determines if a character can follow the first letter in\n+   * a Unicode identifier. This includes letters, connecting punctuation,\n+   * digits, numeric letters, combining marks, non-spacing marks, and\n+   * isIdentifierIgnorable.  Unlike isUnicodeIdentifierPart(char), this method\n+   * supports supplementary Unicode code points.\n+   * <br>\n+   * Unicode identifier extender =\n+   *   [Lu]|[Ll]|[Lt]|[Lm]|[Lo]|[Nl]|[Mn]|[Mc]|[Nd]|[Pc]|[Cf]|\n+   *   |U+0000-U+0008|U+000E-U+001B|U+007F-U+009F\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint can follow the first letter in a Unicode \n+   *         identifier\n+   * @see #isIdentifierIgnorable(int)\n+   * @see #isJavaIdentifierPart(int)\n+   * @see #isLetterOrDigit(int)\n+   * @see #isUnicodeIdentifierStart(int)\n+   * @since 1.5\n+   */\n+  public static boolean isUnicodeIdentifierPart(int codePoint)\n+  {\n+    int category = getType(codePoint);\n+    return ((1 << category)\n+            & ((1 << UPPERCASE_LETTER)\n+               | (1 << LOWERCASE_LETTER)\n+               | (1 << TITLECASE_LETTER)\n+               | (1 << MODIFIER_LETTER)\n+               | (1 << OTHER_LETTER)\n+               | (1 << NON_SPACING_MARK)\n+               | (1 << COMBINING_SPACING_MARK)\n+               | (1 << DECIMAL_DIGIT_NUMBER)\n+               | (1 << LETTER_NUMBER)\n+               | (1 << CONNECTOR_PUNCTUATION)\n+               | (1 << FORMAT))) != 0\n+      || (category == CONTROL && isIdentifierIgnorable(codePoint));\n+  }\n+\n   /**\n    * Determines if a character is ignorable in a Unicode identifier. This\n    * includes the non-whitespace ISO control characters (<code>'\\u0000'</code>\n@@ -2577,6 +2885,32 @@ public static boolean isIdentifierIgnorable(char ch)\n       || getType(ch) == FORMAT;\n   }\n \n+  /**\n+   * Determines if a character is ignorable in a Unicode identifier. This\n+   * includes the non-whitespace ISO control characters (<code>'\\u0000'</code>\n+   * through <code>'\\u0008'</code>, <code>'\\u000E'</code> through\n+   * <code>'\\u001B'</code>, and <code>'\\u007F'</code> through\n+   * <code>'\\u009F'</code>), and FORMAT characters.  Unlike \n+   * isIdentifierIgnorable(char), this method supports supplementary Unicode\n+   * code points.\n+   * <br>\n+   * Unicode identifier ignorable = [Cf]|U+0000-U+0008|U+000E-U+001B\n+   *    |U+007F-U+009F\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is ignorable in a Unicode or Java identifier\n+   * @see #isJavaIdentifierPart(int)\n+   * @see #isUnicodeIdentifierPart(int)\n+   * @since 1.5\n+   */\n+  public static boolean isIdentifierIgnorable(int codePoint)\n+  {\n+    return ((codePoint >= 0 && codePoint <= 0x0008)\n+        || (codePoint >= 0x000E && codePoint <= 0x001B)\n+        || (codePoint >= 0x007F && codePoint <= 0x009F)\n+            || getType(codePoint) == FORMAT);\n+  }\n+\n   /**\n    * Converts a Unicode character into its lowercase equivalent mapping.\n    * If a mapping does not exist, then the character passed is returned.\n@@ -2592,6 +2926,24 @@ public static boolean isIdentifierIgnorable(char ch)\n    */\n   public static native char toLowerCase(char ch);\n \n+  /**\n+   * Converts a Unicode character into its lowercase equivalent mapping.\n+   * If a mapping does not exist, then the character passed is returned.\n+   * Note that isLowerCase(toLowerCase(codePoint)) does not always return true.\n+   * Unlike toLowerCase(char), this method supports supplementary Unicode\n+   * code points.\n+   *\n+   * @param codePoint character to convert to lowercase\n+   * @return lowercase mapping of codePoint, or codePoint if lowercase \n+   *         mapping does not exist\n+   * @see #isLowerCase(int)\n+   * @see #isUpperCase(int)\n+   * @see #toTitleCase(int)\n+   * @see #toUpperCase(int)\n+   * @since 1.5\n+   */\n+  public static native int toLowerCase(int codePoint);\n+\n   /**\n    * Converts a Unicode character into its uppercase equivalent mapping.\n    * If a mapping does not exist, then the character passed is returned.\n@@ -2607,6 +2959,24 @@ public static boolean isIdentifierIgnorable(char ch)\n    */\n   public static native char toUpperCase(char ch);\n \n+  /**\n+   * Converts a Unicode character into its uppercase equivalent mapping.\n+   * If a mapping does not exist, then the character passed is returned.\n+   * Note that isUpperCase(toUpperCase(codePoint)) does not always return true.\n+   * Unlike toUpperCase(char), this method supports supplementary \n+   * Unicode code points.\n+   *\n+   * @param codePoint character to convert to uppercase\n+   * @return uppercase mapping of codePoint, or codePoint if uppercase \n+   *         mapping does not exist\n+   * @see #isLowerCase(int)\n+   * @see #isUpperCase(int)\n+   * @see #toLowerCase(int)\n+   * @see #toTitleCase(int)\n+   * @since 1.5\n+   */\n+  public static native int toUpperCase(int codePoint);\n+\n   /**\n    * Converts a Unicode character into its titlecase equivalent mapping.\n    * If a mapping does not exist, then the character passed is returned.\n@@ -2621,6 +2991,23 @@ public static boolean isIdentifierIgnorable(char ch)\n    */\n   public static native char toTitleCase(char ch);\n \n+  /**\n+   * Converts a Unicode character into its titlecase equivalent mapping.\n+   * If a mapping does not exist, then the character passed is returned.\n+   * Note that isTitleCase(toTitleCase(codePoint)) does not always return true.\n+   * Unlike toTitleCase(char), this method supports supplementary \n+   * Unicode code points.\n+   * \n+   * @param codePoint character to convert to titlecase\n+   * @return titlecase mapping of codePoint, or codePoint if titlecase \n+   *         mapping does not exist\n+   * @see #isTitleCase(int)\n+   * @see #toLowerCase(int)\n+   * @see #toUpperCase(int)\n+   * @since 1.5\n+   */\n+  public static native int toTitleCase(int codePoint);\n+\n   /**\n    * Converts a character into a digit of the specified radix. If the radix\n    * exceeds MIN_RADIX or MAX_RADIX, or if the result of getNumericValue(ch)\n@@ -2641,6 +3028,28 @@ public static boolean isIdentifierIgnorable(char ch)\n    */\n   public static native int digit(char ch, int radix);\n \n+  /**\n+   * Converts a character into a digit of the specified radix. If the radix\n+   * exceeds MIN_RADIX or MAX_RADIX, or if the result of getNumericValue(int)\n+   * exceeds the radix, or if codePoint is not a decimal digit or in the case\n+   * insensitive set of 'a'-'z', the result is -1.  Unlike digit(char, int), \n+   * this method supports supplementary Unicode code points.\n+   * <br>\n+   * character argument boundary = [Nd]|U+0041-U+005A|U+0061-U+007A\n+   *    |U+FF21-U+FF3A|U+FF41-U+FF5A\n+   *\n+   * @param codePoint character to convert into a digit\n+   * @param radix radix in which codePoint is a digit\n+   * @return digit which codePoint represents in radix, or -1 not a valid digit\n+   * @see #MIN_RADIX\n+   * @see #MAX_RADIX\n+   * @see #forDigit(int, int)\n+   * @see #isDigit(int)\n+   * @see #getNumericValue(int)\n+   * @since 1.5\n+   */\n+  public static native int digit(int codePoint, int radix);\n+\n   /**\n    * Returns the Unicode numeric value property of a character. For example,\n    * <code>'\\\\u216C'</code> (the Roman numeral fifty) returns 50.\n@@ -2670,6 +3079,38 @@ public static boolean isIdentifierIgnorable(char ch)\n    */\n   public static native int getNumericValue(char ch);\n \n+  /**\n+   * Returns the Unicode numeric value property of a character. For example,\n+   * <code>'\\\\u216C'</code> (the Roman numeral fifty) returns 50.\n+   *\n+   * <p>This method also returns values for the letters A through Z, (not\n+   * specified by Unicode), in these ranges: <code>'\\u0041'</code>\n+   * through <code>'\\u005A'</code> (uppercase); <code>'\\u0061'</code>\n+   * through <code>'\\u007A'</code> (lowercase); and <code>'\\uFF21'</code>\n+   * through <code>'\\uFF3A'</code>, <code>'\\uFF41'</code> through\n+   * <code>'\\uFF5A'</code> (full width variants).\n+   *\n+   * <p>If the character lacks a numeric value property, -1 is returned.\n+   * If the character has a numeric value property which is not representable\n+   * as a nonnegative integer, such as a fraction, -2 is returned.\n+   *\n+   * Unlike getNumericValue(char), this method supports supplementary Unicode\n+   * code points.\n+   *\n+   * character argument boundary = [Nd]|[Nl]|[No]|U+0041-U+005A|U+0061-U+007A\n+   *    |U+FF21-U+FF3A|U+FF41-U+FF5A\n+   *\n+   * @param codePoint character from which the numeric value property will\n+   *        be retrieved\n+   * @return the numeric value property of codePoint, or -1 if it does not \n+   *         exist, or -2 if it is not representable as a nonnegative integer\n+   * @see #forDigit(int, int)\n+   * @see #digit(int, int)\n+   * @see #isDigit(int)\n+   * @since 1.5\n+   */\n+  public static native int getNumericValue(int codePoint);\n+\n   /**\n    * Determines if a character is a ISO-LATIN-1 space. This is only the five\n    * characters <code>'\\t'</code>, <code>'\\n'</code>, <code>'\\f'</code>,\n@@ -2713,6 +3154,26 @@ public static boolean isSpaceChar(char ch)\n                | (1 << PARAGRAPH_SEPARATOR))) != 0;\n   }\n \n+  /**\n+   * Determines if a character is a Unicode space character. This includes\n+   * SPACE_SEPARATOR, LINE_SEPARATOR, and PARAGRAPH_SEPARATOR.  Unlike\n+   * isSpaceChar(char), this method supports supplementary Unicode code points.\n+   * <br>\n+   * Unicode space = [Zs]|[Zp]|[Zl]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is a Unicode space, else false\n+   * @see #isWhitespace(int)\n+   * @since 1.5\n+   */\n+  public static boolean isSpaceChar(int codePoint)\n+  {\n+    return ((1 << getType(codePoint))\n+            & ((1 << SPACE_SEPARATOR)\n+               | (1 << LINE_SEPARATOR)\n+               | (1 << PARAGRAPH_SEPARATOR))) != 0;\n+  }\n+\n   /**\n    * Determines if a character is Java whitespace. This includes Unicode\n    * space characters (SPACE_SEPARATOR, LINE_SEPARATOR, and\n@@ -2750,6 +3211,47 @@ public static boolean isWhitespace(char ch)\n                                 | (1 << '\\u001F'))) != 0);\n   }\n \n+  /**\n+   * Determines if a character is Java whitespace. This includes Unicode\n+   * space characters (SPACE_SEPARATOR, LINE_SEPARATOR, and\n+   * PARAGRAPH_SEPARATOR) except the non-breaking spaces\n+   * (<code>'\\u00A0'</code>, <code>'\\u2007'</code>, and <code>'\\u202F'</code>);\n+   * and these characters: <code>'\\u0009'</code>, <code>'\\u000A'</code>,\n+   * <code>'\\u000B'</code>, <code>'\\u000C'</code>, <code>'\\u000D'</code>,\n+   * <code>'\\u001C'</code>, <code>'\\u001D'</code>, <code>'\\u001E'</code>,\n+   * and <code>'\\u001F'</code>.  Unlike isWhitespace(char), this method\n+   * supports supplementary Unicode code points.\n+   * <br>\n+   * Java whitespace = ([Zs] not Nb)|[Zl]|[Zp]|U+0009-U+000D|U+001C-U+001F\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is Java whitespace, else false\n+   * @see #isSpaceChar(int)\n+   * @since 1.5\n+   */\n+  public static boolean isWhitespace(int codePoint)\n+  {\n+    int plane = codePoint >>> 16;\n+    if (plane > 2 && plane != 14)\n+      return false;\n+    int attr = readCodePoint(codePoint);\n+    return ((((1 << (attr & TYPE_MASK))\n+              & ((1 << SPACE_SEPARATOR)\n+                 | (1 << LINE_SEPARATOR)\n+                 | (1 << PARAGRAPH_SEPARATOR))) != 0)\n+            && (attr & NO_BREAK_MASK) == 0)\n+      || (codePoint <= '\\u001F' && ((1 << codePoint)\n+                             & ((1 << '\\t')\n+                                | (1 << '\\n')\n+                                | (1 << '\\u000B')\n+                                | (1 << '\\u000C')\n+                                | (1 << '\\r')\n+                                | (1 << '\\u001C')\n+                                | (1 << '\\u001D')\n+                                | (1 << '\\u001E')\n+                                | (1 << '\\u001F'))) != 0);\n+  }\n+\n   /**\n    * Determines if a character has the ISO Control property.\n    * <br>\n@@ -2766,6 +3268,24 @@ public static boolean isISOControl(char ch)\n     return getType(ch) == CONTROL;\n   }\n \n+  /**\n+   * Determines if a character has the ISO Control property.  Unlike\n+   * isISOControl(char), this method supports supplementary unicode\n+   * code points.\n+   * <br>\n+   * ISO Control = [Cc]\n+   *\n+   * @param codePoint character to test\n+   * @return true if codePoint is an ISO Control character, else false\n+   * @see #isSpaceChar(int)\n+   * @see #isWhitespace(int)\n+   * @since 1.5\n+   */\n+  public static boolean isISOControl(int codePoint)\n+  {\n+    return getType(codePoint) == CONTROL;\n+  }\n+\n   /**\n    * Returns the Unicode general category property of a character.\n    *\n@@ -2805,6 +3325,46 @@ public static boolean isISOControl(char ch)\n    */\n   public static native int getType(char ch);\n \n+  /**\n+   * Returns the Unicode general category property of a character.  Supports\n+   * supplementary Unicode code points.\n+   *\n+   * @param codePoint character from which the general category property will\n+   *        be retrieved\n+   * @return the character category property of codePoint as an integer\n+   * @see #UNASSIGNED\n+   * @see #UPPERCASE_LETTER\n+   * @see #LOWERCASE_LETTER\n+   * @see #TITLECASE_LETTER\n+   * @see #MODIFIER_LETTER\n+   * @see #OTHER_LETTER\n+   * @see #NON_SPACING_MARK\n+   * @see #ENCLOSING_MARK\n+   * @see #COMBINING_SPACING_MARK\n+   * @see #DECIMAL_DIGIT_NUMBER\n+   * @see #LETTER_NUMBER\n+   * @see #OTHER_NUMBER\n+   * @see #SPACE_SEPARATOR\n+   * @see #LINE_SEPARATOR\n+   * @see #PARAGRAPH_SEPARATOR\n+   * @see #CONTROL\n+   * @see #FORMAT\n+   * @see #PRIVATE_USE\n+   * @see #SURROGATE\n+   * @see #DASH_PUNCTUATION\n+   * @see #START_PUNCTUATION\n+   * @see #END_PUNCTUATION\n+   * @see #CONNECTOR_PUNCTUATION\n+   * @see #OTHER_PUNCTUATION\n+   * @see #MATH_SYMBOL\n+   * @see #CURRENCY_SYMBOL\n+   * @see #MODIFIER_SYMBOL\n+   * @see #INITIAL_QUOTE_PUNCTUATION\n+   * @see #FINAL_QUOTE_PUNCTUATION\n+   * @since 1.5\n+   */\n+  public static native int getType(int codePoint);\n+\n   /**\n    * Converts a digit into a character which represents that digit\n    * in a specified radix. If the radix exceeds MIN_RADIX or MAX_RADIX,\n@@ -2858,6 +3418,37 @@ public static char forDigit(int digit, int radix)\n    */\n   public static native byte getDirectionality(char ch);\n \n+  /**\n+   * Returns the Unicode directionality property of the character. This\n+   * is used in the visual ordering of text.  Unlike getDirectionality(char),\n+   * this method supports supplementary Unicode code points.\n+   *\n+   * @param codePoint the character to look up\n+   * @return the directionality constant, or DIRECTIONALITY_UNDEFINED\n+   * @see #DIRECTIONALITY_UNDEFINED\n+   * @see #DIRECTIONALITY_LEFT_TO_RIGHT\n+   * @see #DIRECTIONALITY_RIGHT_TO_LEFT\n+   * @see #DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC\n+   * @see #DIRECTIONALITY_EUROPEAN_NUMBER\n+   * @see #DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR\n+   * @see #DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR\n+   * @see #DIRECTIONALITY_ARABIC_NUMBER\n+   * @see #DIRECTIONALITY_COMMON_NUMBER_SEPARATOR\n+   * @see #DIRECTIONALITY_NONSPACING_MARK\n+   * @see #DIRECTIONALITY_BOUNDARY_NEUTRAL\n+   * @see #DIRECTIONALITY_PARAGRAPH_SEPARATOR\n+   * @see #DIRECTIONALITY_SEGMENT_SEPARATOR\n+   * @see #DIRECTIONALITY_WHITESPACE\n+   * @see #DIRECTIONALITY_OTHER_NEUTRALS\n+   * @see #DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING\n+   * @see #DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE\n+   * @see #DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING\n+   * @see #DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE\n+   * @see #DIRECTIONALITY_POP_DIRECTIONAL_FORMAT\n+   * @since 1.5\n+   */\n+  public static native byte getDirectionality(int codePoint);\n+\n   /**\n    * Determines whether the character is mirrored according to Unicode. For\n    * example, <code>\\u0028</code> (LEFT PARENTHESIS) appears as '(' in\n@@ -2872,6 +3463,24 @@ public static boolean isMirrored(char ch)\n     return (readChar(ch) & MIRROR_MASK) != 0;\n   }\n \n+  /**\n+   * Determines whether the character is mirrored according to Unicode. For\n+   * example, <code>\\u0028</code> (LEFT PARENTHESIS) appears as '(' in\n+   * left-to-right text, but ')' in right-to-left text.  Unlike \n+   * isMirrored(char), this method supports supplementary Unicode code points.\n+   *\n+   * @param codePoint the character to look up\n+   * @return true if the character is mirrored\n+   * @since 1.5\n+   */\n+  public static boolean isMirrored(int codePoint)\n+  {\n+    int plane = codePoint >>> 16;\n+    if (plane > 2 && plane != 14)\n+      return false;\n+    return (readCodePoint(codePoint) & MIRROR_MASK) != 0;\n+  }\n+\n   /**\n    * Compares another Character to this Character, numerically.\n    *"}, {"sha": "8d246dd566e89920610f9c86f2352ad6c0c6a9dd", "filename": "libjava/java/lang/natCharacter.cc", "status": "modified", "additions": 131, "deletions": 7, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Fjava%2Flang%2FnatCharacter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Fjava%2Flang%2FnatCharacter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatCharacter.cc?ref=792617a52abfb67c52c6bec3a431fdc193773786", "patch": "@@ -45,30 +45,91 @@ exception statement from your version. */\n \n \f\n \n+// These constants define the return values for characters that are unassigned\n+// or reserved for private use.\n+#define UNASSIGNED_TYPE 0\n+#define UNASSIGNED_DIGIT -1\n+#define UNASSIGNED_DIRECTION -1\n+#define UNASSIGNED_NUMERIC_VALUE -1\n+\n+#define PRIVATE_TYPE 18\n+#define PRIVATE_DIRECTION 0\n+\n+// The methods that take a char as an argument all have counterparts that \n+// take ints.  The ones that take chars only work for the BMP or plane 0 of the\n+// Unicode standard but the ones that take ints work for all Unicode code\n+// points.  However, the ones that take chars don't simply redirect the calls\n+// because the BMP is by far the most used plane so saving a little time on\n+// each call makes sense.\n+\n jchar\n java::lang::Character::readChar(jchar ch)\n {\n   // Perform 16-bit addition to find the correct entry in data.\n-  return data[(jchar) (blocks[ch >> SHIFT] + ch)];\n+  return data[0][(jchar) (blocks[0][ch >> shift[0]] + ch)];\n+}\n+\n+jchar\n+java::lang::Character::readCodePoint(jint codePoint)\n+{\n+  jint plane = codePoint >> 16;\n+  jchar offset = (jchar)(codePoint & 0xffff);\n+  // Be careful not to call this method with an unassigned character.  The only\n+  // characters assigned as of Unicode 4.0.0 belong to planes 0, 1, 2, and 14.\n+  return data[plane][(jchar) (blocks[plane][offset >> shift[plane]] + offset)];\n }\n \n jint\n java::lang::Character::getType(jchar ch)\n {\n   // Perform 16-bit addition to find the correct entry in data.\n-  return (jint) (data[(jchar) (blocks[ch >> SHIFT] + ch)] & TYPE_MASK);\n+  return (jint) (data[0][(jchar) (blocks[0][ch >> shift[0]] + ch)] & TYPE_MASK);\n+}\n+\n+jint\n+java::lang::Character::getType(jint codePoint)\n+{\n+  jint plane = codePoint >> 16;\n+  if (plane > 2 && plane != 14)\n+    {\n+      if (plane > 14 && ((codePoint & 0xffff) < 0xfffe))\n+        return (jint) PRIVATE_TYPE;\n+      return (jint) UNASSIGNED_TYPE;\n+    }\n+  jint offset = codePoint & 0xffff;\n+  return (jint) \n+    (data[plane]\n+     [(jchar) (blocks[plane][offset >> shift[plane]] + offset)] & TYPE_MASK);\n }\n \n jchar\n java::lang::Character::toLowerCase(jchar ch)\n {\n-  return (jchar) (ch + lower[readChar(ch) >> 7]);\n+  return (jchar) (ch + lower[0][readChar(ch) >> 7]);\n+}\n+\n+jint\n+java::lang::Character::toLowerCase(jint codePoint)\n+{\n+  jint plane = codePoint >> 16;\n+  if (plane > 2 && plane != 14)\n+    return codePoint;\n+  return (lower[plane][readCodePoint(codePoint) >> 7]) + codePoint;\n }\n \n jchar\n java::lang::Character::toUpperCase(jchar ch)\n {\n-  return (jchar) (ch + upper[readChar(ch) >> 7]);\n+  return (jchar) (ch + upper[0][readChar(ch) >> 7]);\n+}\n+\n+jint\n+java::lang::Character::toUpperCase(jint codePoint)\n+{\n+  jint plane = codePoint >> 16;\n+  if (plane > 2 && plane != 14)\n+    return codePoint;\n+  return (upper[plane][readCodePoint(codePoint) >> 7]) + codePoint;\n }\n \n jchar\n@@ -81,6 +142,16 @@ java::lang::Character::toTitleCase(jchar ch)\n   return toUpperCase(ch);\n }\n \n+jint\n+java::lang::Character::toTitleCase(jint codePoint)\n+{\n+  // As of Unicode 4.0.0 no characters outside of plane 0 have titlecase\n+  // mappings that are different from their uppercase mapping.\n+  if (codePoint < 0x10000)\n+    return toTitleCase((jchar)codePoint);\n+  return toUpperCase(codePoint);\n+}\n+\n jint\n java::lang::Character::digit(jchar ch, jint radix)\n {\n@@ -93,21 +164,74 @@ java::lang::Character::digit(jchar ch, jint radix)\n           | (1 << DECIMAL_DIGIT_NUMBER))))\n     {\n       // Signedness doesn't matter; 0xffff vs. -1 are both rejected.\n-      jint digit = (jint) numValue[attr >> 7];\n+      jint digit = (jint) numValue[0][attr >> 7];\n       return (digit >= 0 && digit < radix) ? digit : (jint) -1;\n     }\n   return (jint) -1;\n }\n \n+jint\n+java::lang::Character::digit(jint codePoint, jint radix)\n+{\n+  if (radix < MIN_RADIX || radix > MAX_RADIX)\n+    return (jint) -1;\n+\n+  jint plane = codePoint >> 16;\n+  if (plane > 2 && plane != 14)\n+    return UNASSIGNED_DIGIT;\n+\n+  jchar attr = readCodePoint(codePoint);\n+  if (((1 << (attr & TYPE_MASK))\n+       & ((1 << UPPERCASE_LETTER)\n+          | (1 << LOWERCASE_LETTER)\n+          | (1 << DECIMAL_DIGIT_NUMBER))))\n+    {\n+      // Signedness doesn't matter; 0xffff vs. -1 are both rejected.\n+      jint digit = (jint) numValue[plane][attr >> 7];\n+      if (digit <= -3)\n+        digit = largenums[-digit -3];\n+      return (digit >= 0 && digit < radix) ? digit : (jint) -1;\n+    }\n+  return (jint) -1;\n+\n+}\n+\n jint\n java::lang::Character::getNumericValue(jchar ch)\n {\n   // numValue is stored as an array of jshort, since 10000 is the maximum.\n-  return (jint) numValue[readChar(ch) >> 7];\n+  return (jint) numValue[0][readChar(ch) >> 7];\n+}\n+\n+jint\n+java::lang::Character::getNumericValue(jint codePoint)\n+{\n+  jint plane = codePoint >> 16;\n+  if (plane > 2 && plane != 14)\n+    return UNASSIGNED_NUMERIC_VALUE;\n+  jshort num = numValue[plane][readCodePoint(codePoint) >> 7];\n+  if (num <= -3)\n+    return largenums[-num - 3];\n+  return num;\n }\n \n jbyte\n java::lang::Character::getDirectionality(jchar ch)\n {\n-  return direction[readChar(ch) >> 7];\n+  return direction[0][readChar(ch) >> 7];\n }\n+\n+jbyte\n+java::lang::Character::getDirectionality(jint codePoint)\n+{\n+  jint plane = codePoint >> 16;\n+  if (plane > 2 && plane != 14)\n+    {\n+      if (plane > 14 && ((codePoint & 0xffff) < 0xfffe))\n+        return (jint) PRIVATE_DIRECTION;\n+      return (jint) UNASSIGNED_DIRECTION;\n+    }\n+  return direction[plane][readCodePoint(codePoint) >> 7];\n+}\n+\n+"}, {"sha": "49095352b3ce2426a7d5c62c56e6be8ab3ba8b35", "filename": "libjava/scripts/unicode-to-chartables.pl", "status": "added", "additions": 802, "deletions": 0, "changes": 802, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Fscripts%2Funicode-to-chartables.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792617a52abfb67c52c6bec3a431fdc193773786/libjava%2Fscripts%2Funicode-to-chartables.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fscripts%2Funicode-to-chartables.pl?ref=792617a52abfb67c52c6bec3a431fdc193773786", "patch": "@@ -0,0 +1,802 @@\n+#!/usr/bin/perl -w\n+# unicode-to-chartables.pl -- generate Unicode database for java.lang.Character\n+# Copyright (C) 1998, 2002, 2004, 2006  Free Software Foundation, Inc.\n+#\n+# This file is part of GNU Classpath.\n+#\n+# GNU Classpath is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+#\n+# GNU Classpath is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GNU Classpath; see the file COPYING.  If not, write to the\n+# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301 USA.\n+#\n+# Linking this library statically or dynamically with other modules is\n+# making a combined work based on this library.  Thus, the terms and\n+# conditions of the GNU General Public License cover the whole\n+# combination.\n+#\n+# As a special exception, the copyright holders of this library give you\n+# permission to link this library with independent modules to produce an\n+# executable, regardless of the license terms of these independent\n+# modules, and to copy and distribute the resulting executable under\n+# terms of your choice, provided that you also meet, for each linked\n+# independent module, the terms and conditions of the license of that\n+# module.  An independent module is a module which is not derived from\n+# or based on this library.  If you modify this library, you may extend\n+# this exception to your version of the library, but you are not\n+# obligated to do so.  If you do not wish to do so, delete this\n+# exception statement from your version.\n+\n+# Code for reading UnicodeData-4.0.0.txt and SpecialCasing-4.0.0.txt to generate\n+# the code for java-chartables.h. The relevant files can be found here:\n+#\n+#   http://www.unicode.org/Public/4.0-Update/UnicodeData-4.0.0.txt\n+#   http://www.unicode.org/Public/4.0-Update/SpecialCasing-4.0.0.txt\n+#\n+# Inspired by code from Jochen Hoenicke.\n+# author Eric Blake <ebb9@email.byu.edu>\n+# Unicode 4.0.0 support by Anthony Balkissoon <abalkiss@redhat.com>\n+#\n+# Usage: ./unicode-to-chartables.pl <UnicodeData> <SpecialCasing> <tables>\n+#   where <UnicodeData.txt> is obtained from www.unicode.org (named\n+#   UnicodeData-4.0.0.txt for Unicode version 4.0.0), <SpecialCasing>\n+#   is obtained from www.unicode too (named SpecialCasing-4.0.0.txt for Unicode\n+#   version 4.0.0), and <tables> is the final location for the header file\n+#   java-chartables.h. As of JDK 1.5, use Unicode version 4.0.0\n+#   for best results.\n+\n+\n+##\n+## Return the given variable interpreted as a 16 bit signed number.\n+##\n+sub cShort($) {\n+    my ($char) = @_;\n+    return unpack \"s\", pack \"I\", $char;\n+}\n+\n+##\n+## Convert the text UnicodeData file from www.unicode.org into a header file\n+## interface with arrays holding the compressed information.\n+##\n+my @TYPECODES = qw(Cn Lu Ll Lt Lm Lo Mn Me Mc Nd Nl No Zs Zl Zp Cc Cf\n+                   SKIPPED Co Cs Pd Ps Pe Pc Po Sm Sc Sk So Pi Pf);\n+my @DIRCODES = qw(L R AL EN ES ET AN CS NSM BN B S WS ON LRE LRO RLE RLO PDF);\n+\n+my $NOBREAK_FLAG  = 32;\n+my $MIRRORED_FLAG = 64;\n+\n+my %special = ();\n+\n+# infoArray is an array where each element is a list of character information\n+# for characters in a plane.  The index of each list is equal to the plane \n+# that it corresponds to even though most of these lists will currently be\n+# empty.  This is done so that that this script can be easily modified to \n+# accomodate future versions of Unicode.\n+my @infoArray = \\((), (), (), (), (), (), (), (), \n+    (), (), (), (), (), (), (), (), ());\n+\n+# info is a reference to one of the lists in infoArray, depending on which \n+# plane we're currently parsing.\n+my $info;\n+\n+# largeNums is an array of numerical values that are too large to fit \n+# into the 16 bit char where most numerical values are stored.  \n+# What is stored in the char then is a number N such that (-N - 3) is \n+# the index into largeNums where the numerical value can be found.\n+my @largeNums = ();\n+\n+my $titlecase = \"\";\n+my $count = 0;\n+my $range = 0;\n+\n+die \"Usage: $0 <UnicodeData.txt> <SpecialCasing.txt> <java-chartables.h>\"\n+    unless @ARGV == 3;\n+$| = 1;\n+print \"GNU Classpath Unicode Attribute Database Generator 2.1\\n\";\n+print \"Copyright (C) 1998, 2002 Free Software Foundation, Inc.\\n\";\n+\n+\n+################################################################################\n+################################################################################\n+# Stage 0: Parse the special casing file\n+print \"Parsing special casing file\\n\";\n+open (SPECIAL, \"< $ARGV[1]\") || die \"Can't open special casing file: $!\\n\";\n+while (<SPECIAL>) {\n+    next if /^\\#/;\n+    my ($ch, undef, undef, $upper) = split / *; */;\n+\n+    # This grabs only the special casing for multi-char uppercase. Note that\n+    # there are no multi-char lowercase, and that Sun ignores multi-char\n+    # titlecase rules. This script omits 3 special cases in Unicode 3.0.0,\n+    # which must be hardcoded in java.lang.String:\n+    #  \\u03a3 (Sun ignores this special case)\n+    #  \\u0049 - lowercases to \\u0131, but only in Turkish locale\n+    #  \\u0069 - uppercases to \\u0130, but only in Turkish locale\n+    next unless defined $upper and $upper =~ / /;\n+    $special{hex $ch} = [map {hex} split ' ', $upper];\n+}\n+\n+close SPECIAL;\n+\n+\n+################################################################################\n+################################################################################\n+## Stage 1: Parse the attribute file\n+print \"Parsing attributes file\";\n+open (UNICODE, \"< $ARGV[0]\") || die \"Can't open Unicode attribute file: $!\\n\";\n+while (<UNICODE>) {\n+    print \".\" unless $count++ % 1000;\n+    chomp;\n+    s/\\r//g;\n+    my ($ch, $name, $category, undef, $bidir, $decomp, undef, undef, $numeric,\n+        $mirrored, undef, undef, $upcase, $lowcase, $title) = split ';';\n+    $ch = hex($ch);\n+\n+    # plane tells us which Unicode code plane we're currently in and is an\n+    # index into infoArray.\n+    my $plane = int($ch / 0x10000);\n+    my $planeBase = $plane * 0x10000;\n+    $info = \\@{$infoArray[$plane]};\n+\n+    my ($type, $numValue, $upperchar, $lowerchar, $direction);\n+\n+    $type = 0;\n+    while ($category !~ /^$TYPECODES[$type]$/) {\n+        if (++$type == @TYPECODES) {\n+            die \"$ch: Unknown type: $category\";\n+        }\n+    }\n+    $type |= $NOBREAK_FLAG if ($decomp =~ /noBreak/);\n+    $type |= $MIRRORED_FLAG if ($mirrored =~ /Y/);\n+\n+    if ($numeric =~ /^[0-9]+$/) {\n+        $numValue = $numeric;\n+        # If numeric takes more than 16 bits to store we want to store that \n+\t# number in a separate array and store a number N in numValue such \n+\t# that (-N - 3) is the offset into the separate array containing the\n+\t# large numerical value.\n+\tif ($numValue >= 0x7fff) {\n+\t    $numValue = -3 - @largeNums;\n+\t    push @largeNums, $numeric;\t    \n+\t}\n+    } elsif ($numeric eq \"\") {\n+        # Special case sequences of 'a'-'z'\n+        if ($ch >= 0x0041 && $ch <= 0x005a) {\n+            $numValue = $ch - 0x0037;\n+        } elsif ($ch >= 0x0061 && $ch <= 0x007a) {\n+            $numValue = $ch - 0x0057;\n+        } elsif ($ch >= 0xff21 && $ch <= 0xff3a) {\n+            $numValue = $ch - 0xff17;\n+        } elsif ($ch >= 0xff41 && $ch <= 0xff5a) {\n+            $numValue = $ch - 0xff37;\n+        } else {\n+            $numValue = -1;\n+        }\n+    } else {\n+        $numValue = -2;\n+    }\n+\n+    $upperchar = $upcase ? hex($upcase) - $ch : 0;\n+    $lowerchar = $lowcase ? hex($lowcase) - $ch : 0;\n+    if ($title ne $upcase) {\n+        my $titlechar = $title ? hex($title) : $ch;\n+        $titlecase .= pack(\"n2\", $ch, $titlechar);\n+    }\n+\n+    $direction = 0;\n+    while ($bidir !~ /^$DIRCODES[$direction]$/) {\n+        if (++$direction == @DIRCODES) {\n+            $direction = -1;\n+            last;\n+        }\n+    }\n+    $direction <<= 2;\n+    $direction += $#{$special{$ch}} if defined $special{$ch};\n+\n+    if ($range) {\n+        die \"Expecting end of range at $ch\\n\" unless $name =~ /Last>$/;\n+        for ($range + 1 .. $ch - 1) {\n+            $info->[$_ - $planeBase] = pack(\"n5\", $type, $numValue, $upperchar,\n+                             $lowerchar, $direction);\n+        }\n+        $range = 0;\n+    } elsif ($name =~ /First>$/) {\n+        $range = $ch;\n+    }\n+    # Store all this parsed information into the element in infoArray that info\n+    # points to.\n+    $info->[$ch - $planeBase] = pack(\"n5\", $type, $numValue, $upperchar, $lowerchar,\n+                      $direction);\n+}\n+close UNICODE;\n+\n+\n+################################################################################\n+################################################################################\n+## Stage 2: Compress the data structures\n+printf \"\\nCompressing data structures\";\n+$count = 0;\n+\n+# data is a String that will be used to create the DATA String containing \n+# character information and offsets into the attribute tables.\n+my @data = ();\n+\n+# charhashArray is an array of hashtables used so that we can reuse character\n+# attributes when characters share the same attributes ... this makes our\n+# attribute tables smaller.  charhash is a pointer into this array.\n+my @charhashArray = ({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {});\n+my $charhash = ();\n+\n+# charinfoArray is an array of arrays, one per plane, for storing character \n+# information.  charinfo is a pointer into this array.\n+my @charinfoArray = \\((), (), (), (), (), (), (), (), \n+    (), (), (), (), (), (), (), (), ());\n+my $charinfo;\n+\n+# charlen is an array, one element per plane, that tells us how many unique\n+# character attributes there are for that plane.\n+my @charlen = ();\n+\n+for my $plane (0 .. 0x10) {\n+    $info = \\@{$infoArray[$plane]};\n+    my $planeBase = $plane * 0x10000;\n+    $charhash = \\%{$charhashArray[$plane]};\n+    $charinfo = \\@{$charinfoArray[$plane]};\n+\n+    for my $ch ($planeBase .. $planeBase + 0xffff) {\n+\tmy $index = $ch - $planeBase;\n+\tprint \".\" unless $count++ % 0x1000;\n+\t$info->[$index] = pack(\"n5\", 0, -1, 0, 0, -4) unless defined $info->[$index];\n+\t\n+\tmy ($type, $numVal, $upper, $lower, $direction) = unpack(\"n5\", $info->[$index]);\n+\tif (! exists $charhash->{$info->[$index]}) {\n+\t    # If we entered this loop that means the character we're looking at \n+\t    # now has attributes that are unique from those that we've looked\n+\t    # at so far for this plane.  So we push its attributes into charinfo\n+\t    # and store in charhash the offset into charinfo where these\n+\t    # attributes can later be found.\n+\t    push @{$charinfo}, [ $numVal, $upper, $lower, $direction ];\n+\t    $charhash->{$info->[$index]} = @{$charinfo} - 1;\n+\t    # When the file is generaged, the number we just stored in charhas\n+\t    # will be the upper 9 bits in the DATA String that are an offset\n+\t    # into the attribute tables.\n+\t}\n+\t$data[$plane] .= pack(\"n\", ($charhash->{$info->[$index]} << 7) | $type);\n+    }\n+    $charlen[$plane] = scalar(@{$charinfoArray[$plane]});\n+}\n+\n+# the shift that results in the best compression of the table.  This is an array\n+# because different shifts are better for the different tables for each plane.\n+my @bestshift;\n+\n+# an initial guess.\n+my $bestest = 1000000;\n+my @bestblkstr;\n+my @blksize = ();\n+\n+for my $plane (0 .. 0x10) {\n+    print \"\\n\\nplane: $plane\\n\";\n+    print \"Unique character entries: $charlen[$plane]\\n\";\n+    $bestest = 1000000;\n+    for my $i (3 .. 8) {\n+        my $blksize = 1 << $i;\n+        my %blocks = ();\n+        my @blkarray = ();\n+        my ($j, $k);\n+        print \"shift: $i\";\n+\n+        for ($j = 0; $j < 0x10000; $j += $blksize) {\n+            my $blkkey = substr $data[$plane], 2 * $j, 2 * $blksize;\n+            if (! exists $blocks{$blkkey}) {\n+\t        push @blkarray, $blkkey;\n+                $blocks{$blkkey} = $#blkarray;\n+            }\n+        }\n+\n+        my $blknum = @blkarray;\n+        my $blocklen = $blknum * $blksize;\n+        printf \" before %5d\", $blocklen;\n+\n+        # Now we try to pack the blkarray as tight as possible by finding matching\n+        # heads and tails.\n+        for ($j = $blksize - 1; $j > 0; $j--) {\n+            my %tails = ();\n+            for $k (0 .. $#blkarray) {\n+                next unless defined $blkarray[$k];\n+                my $len = length $blkarray[$k];\n+                my $tail = substr $blkarray[$k], $len - $j * 2;\n+                if (exists $tails{$tail}) {\n+                    push @{$tails{$tail}}, $k;\n+                } else {\n+                    $tails{$tail} = [ $k ];\n+                }\n+            }\n+\n+            # tails are calculated, now calculate the heads and merge.\n+          BLOCK:\n+            for $k (0 .. $#blkarray) {\n+                next unless defined $blkarray[$k];\n+                my $tomerge = $k;\n+                while (1) {\n+                    my $head = substr($blkarray[$tomerge], 0, $j * 2);\n+                    my $entry = $tails{$head};\n+                    next BLOCK unless defined $entry;\n+\n+                    my $other = shift @{$entry};\n+                    if ($other == $tomerge) {\n+                        if (@{$entry}) {\n+                            push @{$entry}, $other;\n+                            $other = shift @{$entry};\n+                        } else {\n+                            push @{$entry}, $other;\n+                            next BLOCK;\n+                        }\n+                    }\n+                    if (@{$entry} == 0) {\n+                        delete $tails{$head};\n+                    }\n+\n+                    # a match was found\n+                    my $merge = $blkarray[$other]\n+                        . substr($blkarray[$tomerge], $j * 2);\n+                    $blocklen -= $j;\n+                    $blknum--;\n+\n+                    if ($other < $tomerge) {\n+                        $blkarray[$tomerge] = undef;\n+                        $blkarray[$other] = $merge;\n+                        my $len = length $merge;\n+                        my $tail = substr $merge, $len - $j * 2;\n+                        $tails{$tail} = [ map { $_ == $tomerge ? $other : $_ }\n+                                          @{$tails{$tail}} ];\n+                        next BLOCK;\n+                    }\n+                    $blkarray[$tomerge] = $merge;\n+                    $blkarray[$other] = undef;\n+                }\n+            }\n+        }\n+        my $blockstr;\n+        for $k (0 .. $#blkarray) {\n+            $blockstr .= $blkarray[$k] if defined $blkarray[$k];\n+        }\n+\n+        die \"Unexpected $blocklen\" if length($blockstr) != 2 * $blocklen;\n+        my $estimate = 2 * $blocklen + (0x20000 >> $i);\n+  \n+        printf \" after merge %5d: %6d bytes\\n\", $blocklen, $estimate;\n+        if ($estimate < $bestest) {\n+            $bestest = $estimate;\n+            $bestshift[$plane] = $i;\n+            $bestblkstr[$plane] = $blockstr;\n+        }\n+    }\n+    $blksize[$plane] = 1 << $bestshift[$plane];\n+    print \"best shift: \", $bestshift[$plane];\n+    print \"     blksize: \", $blksize[$plane];\n+}\n+my @blocksArray = \\((), (), (), (), (), (), (), (), \n+    (), (), (), (), (), (), (), (), ());\n+\n+for my $plane (0 .. 0x10) {\n+    for (my $j = 0; $j < 0x10000; $j += $blksize[$plane]) {\n+\tmy $blkkey = substr $data[$plane], 2 * $j, 2 * $blksize[$plane];\n+        my $index = index $bestblkstr[$plane], $blkkey;\n+        while ($index & 1) {\n+            die \"not found: $j\" if $index == -1;\n+            $index = index $bestblkstr[$plane], $blkkey, $index + 1;\n+        }\n+        push @{$blocksArray[$plane]}, ($index / 2 - $j) & 0xffff;\n+    }\n+}\n+\n+\n+################################################################################\n+################################################################################\n+## Stage 3: Generate the file\n+for my $plane (0 .. 0x10) {\n+    die \"UTF-8 limit of blocks may be exceeded for plane $plane: \" . scalar(@{$blocksArray[$plane]}) . \"\\n\"\n+        if @{$blocksArray[$plane]} > 0xffff / 3;\n+    die \"UTF-8 limit of data may be exceeded for plane $plane: \" . length($bestblkstr[$plane]) . \"\\n\"\n+        if length($bestblkstr[$plane]) > 0xffff / 3;\n+}\n+\n+{\n+    print \"\\nGenerating $ARGV[2].\";\n+    my ($i, $j);\n+\n+    open OUTPUT, \"> $ARGV[2]\" or die \"Failed creating output file: $!\\n\";\n+    print OUTPUT <<EOF;\n+/* java-chartables.h -- Character tables for java.lang.Character -*- c++ -*-\n+   Copyright (C) 2002, 2006 Free Software Foundation, Inc.\n+   *** This file is generated by scripts/unicode-to-chartables.pl ***\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+#ifndef __JAVA_CHARTABLES_H__\n+#define __JAVA_CHARTABLES_H__\n+\n+// These tables are automatically generated by scripts/unicode_to_chartables.pl.\n+// The Unicode data comes from www.unicode.org; this header is based on\n+// UnicodeData-4.0.0.txt. JDK 1.5 uses Unicode version 4.0.0.\n+// DO NOT EDIT the tables.  Instead, fix the upstream scripts and run\n+// them again.\n+\n+// The data is stored in C style arrays of the appropriate CNI types, to\n+// guarantee that the data is constant and non-relocatable.  The field\n+// <code>blocks</code> stores the offset of a block of 2<sup>SHIFT</sup>\n+// characters within <code>data</code>. The data field, in turn, stores\n+// information about each character in the low order bits, and an offset\n+// into the attribute tables <code>upper</code>, <code>lower</code>,\n+// <code>numValue</code>, and <code>direction</code>.  Notice that the\n+// attribute tables are much smaller than 0xffff entries; as many characters\n+// in Unicode share common attributes.  Finally, there is a listing for\n+// <code>title</code> exceptions (most characters just have the same title\n+// case as upper case).\n+\n+// This file should only be included by natCharacter.cc\n+\n+/**\n+ * The array containing the numeric values that are too large to be stored as\n+ * chars in NUM_VALUE.  NUM_VALUE in this case will contain a negative integer\n+ * N such that LARGENUMS[-N - 3] contains the correct numeric value.\n+ */\n+EOF\n+  print OUTPUT \"static const jint largenums[] = {\\n    \";\n+  for ($i = 0; $i < @largeNums; $i++) {\n+      print OUTPUT $largeNums[$i], \", \";\n+  }\n+  print OUTPUT \"}\";\n+  print OUTPUT <<EOF;\n+;\n+\n+/**\n+ * The character shift amount to look up the block offset. In other words,\n+ * <code>(char) (blocks[p][off >> SHIFT[p]] + off)</code> is the index where\n+ * <code>ch</code> is described in <code>data</code>, where <code>off</code>\n+ * is ch & 0xffff and <code>p</code> is the plane the character belongs to.\n+ */\n+EOF\n+  print OUTPUT \"static const int shift[] = {\\n    \";\n+  for ($i = 0; $i < @bestshift; $i++) {\n+      print OUTPUT $bestshift[$i], \", \";\n+  }\n+  print OUTPUT \"}\";\n+  print OUTPUT <<EOF;\n+;\n+\n+/**\n+ * The mapping of character blocks to their location in <code>data</code>.\n+ * Each entry has been adjusted so that a modulo 16 sum with the desired\n+ * character gives the actual index into <code>data</code>.\n+ */\n+EOF\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      # The following if statement handles the cases of unassigned planes\n+      # specially so we don't waste space with unused Strings.  As of \n+      # Unicode version 4.0.0 only planes 0, 1, 2, and 14 are used.  If\n+      # you are updating this script to work with a later version of \n+      # Unicode you may have to alter this if statement.\n+      next if ($plane > 2 && $plane != 14) ;\n+      \n+      print OUTPUT \"static const jchar blocks\", $plane, \"[] = {\\n\";\n+      for ($i = 0; $i < @{$blocksArray[$plane]} / 10; $i++) {\n+\t  print OUTPUT \"    \";\n+\t  for $j (0 .. 9) {\n+\t      last if @{$blocksArray[$plane]} <= $i * 10 + $j;\n+\t      my $val = $blocksArray[$plane]->[$i * 10 + $j];\n+\t      print OUTPUT $val, \", \";\n+\t  }\n+\t  print OUTPUT \"\\n\";\n+      }\n+      print OUTPUT \"};\\n\\n\";\n+  }\n+  print OUTPUT \"static const int blocks_length[] = {\\n    \";\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      if ($plane > 2 && $plane != 14){\n+\t  print OUTPUT \"-1, \";\n+      }\n+      else {\n+\t  print OUTPUT scalar(@{$blocksArray[$plane]}), \", \";\n+      }\n+  }\n+  print OUTPUT \"};\\n\";\n+  print OUTPUT <<EOF;\n+static const jchar* blocks[] = {\n+    blocks0, blocks1, blocks2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \n+    NULL, NULL, NULL, NULL, blocks14, NULL, NULL};\n+\n+/**\n+ * Information about each character.  The low order 5 bits form the\n+ * character type, the next bit is a flag for non-breaking spaces, and the\n+ * next bit is a flag for mirrored directionality.  The high order 9 bits\n+ * form the offset into the attribute tables.  Note that this limits the\n+ * number of unique character attributes per plane to 512, which is not a \n+ * problem as of Unicode version 4.0.0, but may soon become one.\n+ */\n+EOF\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      # The following if statement handles the cases of unassigned planes\n+      # specially so we don't waste space with unused Strings.  As of \n+      # Unicode version 4.0.0 only planes 0, 1, 2, and 14 are used.  If\n+      # you are updating this script to work with a later version of \n+      # Unicode you may have to alter this if statement.\n+      next if ($plane > 2 && $plane != 14);\n+      \n+      print OUTPUT \"static const jchar data\", $plane, \"[] = {\\n\";\n+      my $len = length($bestblkstr[$plane]) / 2;\n+      for ($i = 0; $i < $len / 10; $i++) {\n+\t  print OUTPUT \"    \";\n+\t  for $j (0 .. 9) {\n+\t      last if $len <= $i * 10 + $j;\n+\t      my $val = unpack \"n\", substr($bestblkstr[$plane], 2 * ($i * 10 + $j), 2);\n+\t      print OUTPUT $val, \", \";\n+\t  }\n+\t  print OUTPUT \"\\n\";\n+      }\n+      print OUTPUT \"};\\n\\n\";\n+  }\n+  print OUTPUT \"static const int data_length[] = {\\n    \";\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      if ($plane > 2 && $plane != 14){\n+\t  print OUTPUT \"-1, \";\n+      }\n+      else {\n+\t  print OUTPUT length($bestblkstr[$plane]) / 2, \", \";\n+      }\n+  }\n+  print OUTPUT \"};\\n\";\n+  print OUTPUT <<EOF;\n+static const jchar* data[] = {\n+    data0, data1, data2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \n+    NULL, NULL, NULL, NULL, data14, NULL, NULL};\n+\n+\n+/**\n+ * This is the attribute table for computing the numeric value of a\n+ * character.  The value is -1 if Unicode does not define a value, -2\n+ * if the value is not a positive integer, otherwise it is the value.\n+ */\n+EOF\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      # The following if statement handles the cases of unassigned planes\n+      # specially so we don't waste space with unused Strings.  As of \n+      # Unicode version 4.0.0 only planes 0, 1, 2, and 14 are used.  If\n+      # you are updating this script to work with a later version of \n+      # Unicode you may have to alter this if statement.\n+      next if ($plane > 2 && $plane != 14);\n+      \n+      print OUTPUT \"static const jshort numValue\", $plane, \"[] = {\\n\";\n+      $len = @{$charinfoArray[$plane]};\n+      for ($i = 0; $i < $len / 13; $i++) {\n+\t  print OUTPUT \"    \";\n+\t  for $j (0 .. 12) {\n+\t      last if $len <= $i * 13 + $j;\n+\t      my $val = $charinfoArray[$plane]->[$i * 13 + $j][0];\n+\t      print OUTPUT cShort($val), \", \";\n+\t  }\n+\t  print OUTPUT \"\\n\";\n+      }\n+      print OUTPUT \"};\\n\\n\";\n+  }\n+  print OUTPUT \"static const int numValue_length[] = {\\n    \";\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      if ($plane > 2 && $plane != 14){\n+\t  print OUTPUT \"-1, \";\n+      }\n+      else {\n+\t  print OUTPUT scalar(@{$charinfoArray[$plane]}), \", \";\n+      }\n+  }\n+  print OUTPUT \"};\\n\";\n+  print OUTPUT <<EOF;\n+static const jshort* numValue[] = {\n+    numValue0, numValue1, numValue2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \n+    NULL, NULL, NULL, NULL, numValue14, NULL, NULL};\n+\n+\n+\n+/**\n+ * This is the attribute table for computing the uppercase representation\n+ * of a character.  The value is the difference between the character and\n+ * its uppercase version.\n+ */\n+EOF\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      # The following if statement handles the cases of unassigned planes\n+      # specially so we don't waste space with unused Strings.  As of \n+      # Unicode version 4.0.0 only planes 0, 1, 2, and 14 are used.  If\n+      # you are updating this script to work with a later version of \n+      # Unicode you may have to alter this if statement.\n+      next if ($plane > 2 && $plane != 14);\n+      \n+      print OUTPUT \"static const jshort upper\", $plane, \"[] = {\\n\";\n+      $len = @{$charinfoArray[$plane]};\n+      for ($i = 0; $i < $len / 13; $i++) {\n+\t  print OUTPUT \"    \";\n+\t  for $j (0 .. 12) {\n+\t      last if $len <= $i * 13 + $j;\n+\t      my $val = $charinfoArray[$plane]->[$i * 13 + $j][1];\n+\t      print OUTPUT cShort($val), \", \";\n+\t  }\n+\t  print OUTPUT \"\\n\";\n+      }\n+      print OUTPUT \"};\\n\\n\";\n+  }\n+  print OUTPUT \"static const int upper_length[] = {\\n    \";\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      if ($plane > 2 && $plane != 14){\n+\t  print OUTPUT \"-1, \";\n+      }\n+      else {\n+\t  print OUTPUT scalar(@{$charinfoArray[$plane]}), \", \";\n+      }\n+  }\n+  print OUTPUT \"};\\n\";\n+  print OUTPUT <<EOF;\n+static const jshort* upper[] = {\n+    upper0, upper1, upper2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \n+    NULL, NULL, NULL, NULL, upper14, NULL, NULL};\n+\n+\n+/**\n+ * This is the attribute table for computing the lowercase representation\n+ * of a character.  The value is the difference between the character and\n+ * its lowercase version.\n+ */\n+EOF\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      # The following if statement handles the cases of unassigned planes\n+      # specially so we don't waste space with unused Strings.  As of \n+      # Unicode version 4.0.0 only planes 0, 1, 2, and 14 are used.  If\n+      # you are updating this script to work with a later version of \n+      # Unicode you may have to alter this if statement.\n+      next if ($plane > 2 && $plane != 14);\n+      \n+      print OUTPUT \"static const jshort lower\", $plane, \"[] = {\\n\";\n+      $len = @{$charinfoArray[$plane]};\n+      for ($i = 0; $i < $len / 13; $i++) {\n+\t  print OUTPUT \"    \";\n+\t  for $j (0 .. 12) {\n+\t      last if $len <= $i * 13 + $j;\n+\t      my $val = $charinfoArray[$plane]->[$i * 13 + $j][2];\n+\t      print OUTPUT cShort($val), \", \";\n+\t  }\n+\t  print OUTPUT \"\\n\";\n+      }\n+      print OUTPUT \"};\\n\\n\";\n+  }\n+  print OUTPUT \"static const int lower_length[] = {\\n    \";\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      if ($plane > 2 && $plane != 14){\n+\t  print OUTPUT \"-1, \";\n+      }\n+      else {\n+\t  print OUTPUT scalar(@{$charinfoArray[$plane]}), \", \";\n+      }\n+  }\n+  print OUTPUT \"};\\n\";\n+  print OUTPUT <<EOF;\n+static const jshort* lower[] = {\n+    lower0, lower1, lower2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \n+    NULL, NULL, NULL, NULL, lower14, NULL, NULL};\n+\n+\n+/**\n+ * This is the attribute table for computing the directionality class\n+ * of a character.  At present, the value is in the range 0 - 18 if the\n+ * character has a direction, otherwise it is -1.\n+ */\n+EOF\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      # The following if statement handles the cases of unassigned planes\n+      # specially so we don't waste space with unused Strings.  As of \n+      # Unicode version 4.0.0 only planes 0, 1, 2, and 14 are used.  If\n+      # you are updating this script to work with a later version of \n+      # Unicode you may have to alter this if statement.\n+      next if ($plane > 2 && $plane != 14);\n+      \n+      print OUTPUT \"static const jbyte direction\", $plane, \"[] = {\\n\";\n+      $len = @{$charinfoArray[$plane]};\n+      for ($i = 0; $i < $len / 19; $i++) {\n+\t  print OUTPUT \"    \";\n+\t  for $j (0 .. 18) {\n+\t      last if $len <= $i * 19 + $j;\n+\t      my $val = $charinfoArray[$plane]->[$i * 19 + $j][3];\n+\t      $val >>= 2;\n+\t      if ($val < 0 || $val > 18){\n+\t\t  $val = -1;\n+\t      }\n+\t      print OUTPUT cShort($val), \", \";\n+\t  }\n+\t  print OUTPUT \"\\n\";\n+      }\n+      print OUTPUT \"};\\n\\n\";\n+  }\n+  print OUTPUT \"static const int direction_length[] = {\\n    \";\n+  for ($plane = 0; $plane <= 0x10; $plane++) {\n+      if ($plane > 2 && $plane != 14){\n+\t  print OUTPUT \"-1, \";\n+      }\n+      else {\n+\t  print OUTPUT scalar(@{$charinfoArray[$plane]}), \", \";\n+      }\n+  }\n+  print OUTPUT \"};\\n\";\n+  print OUTPUT <<EOF;\n+static const jbyte* direction[] = {\n+    direction0, direction1, direction2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \n+    NULL, NULL, NULL, NULL, direction14, NULL, NULL};\n+\n+\n+/**\n+ * This is the listing of titlecase special cases (all other character\n+ * can use <code>upper</code> to determine their titlecase).  The listing\n+ * is a sequence of character pairs; converting the first character of the\n+ * pair to titlecase produces the second character.\n+ */\n+static const jchar title[] = {\n+EOF\n+\n+  $len = length($titlecase) / 2;\n+  for ($i = 0; $i < $len / 10; $i++) {\n+      print OUTPUT $i ? \"\\n    \" : \"    \";\n+      for $j (0 .. 9) {\n+\t  last if $len <= $i * 10 + $j;\n+\t  my $val = unpack \"n\", substr($titlecase, 2 * ($i * 10 + $j), 2);\n+\t  print OUTPUT $val, \", \";\n+      }\n+  }\n+\n+  print OUTPUT \"\\n  };\";\n+  print OUTPUT \"\\n/** Length of title. */\\nstatic const int title_length = \", $len;\n+  print OUTPUT <<EOF;\n+;\n+\n+#endif /* __JAVA_CHARTABLES_H__ */\n+EOF\n+  close OUTPUT;\n+}\n+print \"\\nDone.\\n\";"}]}