{"sha": "6b55276ed95655f743db4b87a77495a348df946f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI1NTI3NmVkOTU2NTVmNzQzZGI0Yjg3YTc3NDk1YTM0OGRmOTQ2Zg==", "commit": {"author": {"name": "Craig Burley", "email": "craig@jcb-sc.com", "date": "1999-04-22T23:01:43Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-04-22T23:01:43Z"}, "message": "support array bounds checking\n\nFrom-SVN: r26592", "tree": {"sha": "ed504fe93b884fa5d3d588126ae1a0f5d90ffc7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed504fe93b884fa5d3d588126ae1a0f5d90ffc7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b55276ed95655f743db4b87a77495a348df946f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b55276ed95655f743db4b87a77495a348df946f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b55276ed95655f743db4b87a77495a348df946f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b55276ed95655f743db4b87a77495a348df946f/comments", "author": null, "committer": null, "parents": [{"sha": "01680a2591ffc5c5b508a3035ccfbac5b6e7075d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01680a2591ffc5c5b508a3035ccfbac5b6e7075d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01680a2591ffc5c5b508a3035ccfbac5b6e7075d"}], "stats": {"total": 510, "additions": 396, "deletions": 114}, "files": [{"sha": "1d163aca847eb4b7f1b28ce49c71cca94416948f", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -1,3 +1,24 @@\n+Fri Apr 23 01:48:28 1999  Craig Burley  <craig@jcb-sc.com>\n+\n+\tSupport new -fsubscript-check and -ff2c-subscript-check options:\n+\t* com-rt.def (FFECOM_gfrtRANGE): Describe s_rnge, in libf2c/libF77.\n+\t* com.c (ffecom_subscript_check_, ffecom_arrayref_): New functions.\n+\t(ffecom_char_args_x_): Use new ffecom_arrayref_ function for\n+\tFFEBLD_opARRAYREF case.\n+\tCompute character name, array type, and\tuse new\n+\tffecom_subscript_check_ function for FFEBLD_opSUBSTRING case.\n+\t(ffecom_expr_): Use new ffecom_arrayref_ function.\n+\t(ffecom_ptr_to_expr): Use new ffecom_arrayref_ function.\n+\t* g77.texi, news.texi: Document new options.\n+\t* top.c, top.h: Support new options.\n+\n+\t* news.texi: Fix up some items to not be in \"User-Visible Changes\".\n+\n+\t* ste.c (ffeste_R819B): Fix type for loop variable, to avoid\n+\twarnings.\n+\n+\t* version.c: Bump version.\n+\n Tue Apr 20 01:38:57 1999  Craig Burley  <craig@jcb-sc.com>\n \n \t* bugs.texi, news.texi: Clarify -malign-double situation."}, {"sha": "cb3a5f14e8e82e8269e8372778b666d51babcf7f", "filename": "gcc/f/com-rt.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fcom-rt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fcom-rt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom-rt.def?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -66,6 +66,7 @@ DEFGFRT (FFECOM_gfrtCMP, \"s_cmp\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE)\n DEFGFRT (FFECOM_gfrtCOPY, \"s_copy\", FFECOM_rttypeVOID_, 0, FALSE, FALSE)\n DEFGFRT (FFECOM_gfrtPAUSE, \"s_paus\", FFECOM_rttypeVOID_, 0, FALSE, FALSE)\n DEFGFRT (FFECOM_gfrtSTOP, \"s_stop\", FFECOM_rttypeVOID_, 0, TRUE, FALSE)\n+DEFGFRT (FFECOM_gfrtRANGE, \"s_rnge\", FFECOM_rttypeINTEGER_, 0, TRUE, FALSE)\n \n DEFGFRT (FFECOM_gfrtSRDUE, \"s_rdue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE)\n DEFGFRT (FFECOM_gfrtERDUE, \"e_rdue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE)"}, {"sha": "9d05bab93df9e281e926e40b7275f11f9daf5099", "filename": "gcc/f/com.c", "status": "modified", "additions": 264, "deletions": 97, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -745,6 +745,233 @@ static tree shadowed_labels;\n \n #endif /* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \f\n+/* Return the subscript expression, modified to do range-checking.\n+\n+   `array' is the array to be checked against.\n+   `element' is the subscript expression to check.\n+   `dim' is the dimension number (starting at 0).\n+   `total_dims' is the total number of dimensions (0 for CHARACTER substring).\n+*/\n+\n+static tree\n+ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n+\t\t\t char *array_name)\n+{\n+  tree low = TYPE_MIN_VALUE (TYPE_DOMAIN (array));\n+  tree high = TYPE_MAX_VALUE (TYPE_DOMAIN (array));\n+  tree cond;\n+  tree die;\n+  tree args;\n+\n+  if (element == error_mark_node)\n+    return element;\n+\n+  element = ffecom_save_tree (element);\n+  cond = ffecom_2 (LE_EXPR, integer_type_node,\n+\t\t   low,\n+\t\t   element);\n+  if (high)\n+    {\n+      cond = ffecom_2 (TRUTH_ANDIF_EXPR, integer_type_node,\n+\t\t       cond,\n+\t\t       ffecom_2 (LE_EXPR, integer_type_node,\n+\t\t\t\t element,\n+\t\t\t\t high));\n+    }\n+\n+  {\n+    int len;\n+    char *proc;\n+    char *var;\n+    tree arg3;\n+    tree arg2;\n+    tree arg1;\n+    tree arg4;\n+\n+    switch (total_dims)\n+      {\n+      case 0:\n+\tvar = xmalloc (strlen (array_name) + 20);\n+\tsprintf (&var[0], \"%s[%s-substring]\",\n+\t\t array_name,\n+\t\t dim ? \"end\" : \"start\");\n+\tlen = strlen (var) + 1;\n+\tbreak;\n+\n+      case 1:\n+\tlen = strlen (array_name) + 1;\n+\tvar = array_name;\n+\tbreak;\n+\n+      default:\n+\tvar = xmalloc (strlen (array_name) + 40);\n+\tsprintf (&var[0], \"%s[subscript-%d-of-%d]\",\n+\t\t array_name,\n+\t\t dim + 1, total_dims);\n+\tlen = strlen (var) + 1;\n+\tbreak;\n+      }\n+\n+    arg1 = build_string (len, var);\n+\n+    if (total_dims != 1)\n+      free (var);\n+\n+    TREE_TYPE (arg1)\n+      = build_type_variant (build_array_type (char_type_node,\n+\t\t\t\t\t      build_range_type\n+\t\t\t\t\t      (integer_type_node,\n+\t\t\t\t\t       integer_one_node,\n+\t\t\t\t\t       build_int_2 (len, 0))),\n+\t\t\t    1, 0);\n+    TREE_CONSTANT (arg1) = 1;\n+    TREE_STATIC (arg1) = 1;\n+    arg1 = ffecom_1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg1)),\n+\t\t     arg1);\n+\n+    /* s_rnge adds one to the element to print it, so bias against\n+       that -- want to print a faithful *subscript* value.  */\n+    arg2 = convert (ffecom_f2c_ftnint_type_node,\n+\t\t    ffecom_2 (MINUS_EXPR,\n+\t\t\t      TREE_TYPE (element),\n+\t\t\t      element,\n+\t\t\t      convert (TREE_TYPE (element),\n+\t\t\t\t       integer_one_node)));\n+\n+    proc = xmalloc ((len = strlen (input_filename)\n+\t\t     + IDENTIFIER_LENGTH (DECL_NAME (current_function_decl))\n+\t\t     + 2));\n+\n+    sprintf (&proc[0], \"%s/%s\",\n+\t     input_filename,\n+\t     IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+    arg3 = build_string (len, proc);\n+\n+    free (proc);\n+\n+    TREE_TYPE (arg3)\n+      = build_type_variant (build_array_type (char_type_node,\n+\t\t\t\t\t      build_range_type\n+\t\t\t\t\t      (integer_type_node,\n+\t\t\t\t\t       integer_one_node,\n+\t\t\t\t\t       build_int_2 (len, 0))),\n+\t\t\t    1, 0);\n+    TREE_CONSTANT (arg3) = 1;\n+    TREE_STATIC (arg3) = 1;\n+    arg3 = ffecom_1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg3)),\n+\t\t     arg3);\n+\n+    arg4 = convert (ffecom_f2c_ftnint_type_node,\n+\t\t    build_int_2 (lineno, 0));\n+\n+    arg1 = build_tree_list (NULL_TREE, arg1);\n+    arg2 = build_tree_list (NULL_TREE, arg2);\n+    arg3 = build_tree_list (NULL_TREE, arg3);\n+    arg4 = build_tree_list (NULL_TREE, arg4);\n+    TREE_CHAIN (arg3) = arg4;\n+    TREE_CHAIN (arg2) = arg3;\n+    TREE_CHAIN (arg1) = arg2;\n+\n+    args = arg1;\n+  }\n+  die = ffecom_call_gfrt (FFECOM_gfrtRANGE,\n+\t\t\t  args, NULL_TREE);\n+  TREE_SIDE_EFFECTS (die) = 1;\n+\n+  element = ffecom_3 (COND_EXPR,\n+\t\t      TREE_TYPE (element),\n+\t\t      cond,\n+\t\t      element,\n+\t\t      die);\n+\n+  return element;\n+}\n+\n+/* Return the computed element of an array reference.\n+\n+   `item' is the array or a pointer to the array.  It must be a pointer\n+     to the array if ffe_is_flat_arrays ().\n+   `expr' is the original opARRAYREF expression.\n+   `want_ptr' is non-zero if `item' is a pointer to the element, instead of\n+     the element itself, is to be returned.  */\n+\n+static tree\n+ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n+{\n+  ffebld dims[FFECOM_dimensionsMAX];\n+  int i;\n+  int total_dims;\n+  int flatten = 0 /* ~~~ ffe_is_flat_arrays () */;\n+  int need_ptr = want_ptr || flatten;\n+  tree array;\n+  tree element;\n+  char *array_name;\n+\n+  if (ffebld_op (ffebld_left (expr)) == FFEBLD_opSYMTER)\n+    array_name = ffesymbol_text (ffebld_symter (ffebld_left (expr)));\n+  else\n+    array_name = \"[expr?]\";\n+\n+  /* Build up ARRAY_REFs in reverse order (since we're column major\n+     here in Fortran land). */\n+\n+  for (i = 0, expr = ffebld_right (expr);\n+       expr != NULL;\n+       expr = ffebld_trail (expr))\n+    dims[i++] = ffebld_head (expr);\n+\n+  total_dims = i;\n+\n+  if (need_ptr)\n+    {\n+      for (--i, array = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item)));\n+\t   i >= 0;\n+\t   --i, array = TYPE_MAIN_VARIANT (TREE_TYPE (array)))\n+\t{\n+\t  element = ffecom_expr (dims[i]);\n+\t  if (ffe_is_subscript_check ())\n+\t    element = ffecom_subscript_check_ (array, element, i, total_dims,\n+\t\t\t\t\t       array_name);\n+\t  item = ffecom_2 (PLUS_EXPR,\n+\t\t\t   build_pointer_type (TREE_TYPE (array)),\n+\t\t\t   item,\n+\t\t\t   size_binop (MULT_EXPR,\n+\t\t\t\t       size_in_bytes (TREE_TYPE (array)),\n+\t\t\t\t       convert (sizetype,\n+\t\t\t\t\t\tfold (build (MINUS_EXPR,\n+\t\t\t\t\t\t\t     TREE_TYPE (TYPE_MIN_VALUE (TYPE_DOMAIN (array))),\n+\t\t\t\t\t\t\t     element,\n+\t\t\t\t\t\t\t     TYPE_MIN_VALUE (TYPE_DOMAIN (array)))))));\n+\t}\n+      if (! want_ptr)\n+\t{\n+\t  item = ffecom_1 (INDIRECT_REF,\n+\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item))),\n+\t\t\t   item);\n+\t}\n+    }\n+  else\n+    {\n+      for (--i;\n+\t   i >= 0;\n+\t   --i)\n+\t{\n+\t  array = TYPE_MAIN_VARIANT (TREE_TYPE (item));\n+\n+\t  element = ffecom_expr_ (dims[i], NULL, NULL, NULL, FALSE, TRUE);\n+\t  if (ffe_is_subscript_check ())\n+\t    element = ffecom_subscript_check_ (array, element, i, total_dims,\n+\t\t\t\t\t       array_name);\n+\t  item = ffecom_2 (ARRAY_REF,\n+\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item))),\n+\t\t\t   item,\n+\t\t\t   element);\n+\t}\n+    }\n+\n+  return item;\n+}\n+\n /* This is like gcc's stabilize_reference -- in fact, most of the code\n    comes from that -- but it handles the situation where the reference\n    is going to have its subparts picked at, and it shouldn't change\n@@ -1746,10 +1973,6 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \n     case FFEBLD_opARRAYREF:\n       {\n-\tffebld dims[FFECOM_dimensionsMAX];\n-\ttree array;\n-\tint i;\n-\n \tffecom_char_args_ (&item, length, ffebld_left (expr));\n \n \tif (item == error_mark_node || *length == error_mark_node)\n@@ -1758,26 +1981,7 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \t    break;\n \t  }\n \n-\t/* Build up ARRAY_REFs in reverse order (since we're column major\n-\t   here in Fortran land). */\n-\n-\tfor (i = 0, expr = ffebld_right (expr);\n-\t     expr != NULL;\n-\t     expr = ffebld_trail (expr))\n-\t  dims[i++] = ffebld_head (expr);\n-\n-\tfor (--i, array = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item)));\n-\t     i >= 0;\n-\t     --i, array = TYPE_MAIN_VARIANT (TREE_TYPE (array)))\n-\t  {\n-\t    item = ffecom_2 (PLUS_EXPR, build_pointer_type (TREE_TYPE (array)),\n-\t\t\t     item,\n-\t\t\t     size_binop (MULT_EXPR,\n-\t\t\t\t\t size_in_bytes (TREE_TYPE (array)),\n-\t\t\t\t\t size_binop (MINUS_EXPR,\n-\t\t\t\t\t\t     ffecom_expr (dims[i]),\n-\t\t\t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (array)))));\n-\t  }\n+\titem = ffecom_arrayref_ (item, expr, 1);\n       }\n       break;\n \n@@ -1788,13 +1992,26 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \tffebld thing = ffebld_right (expr);\n \ttree start_tree;\n \ttree end_tree;\n+\tchar *char_name;\n+\tffebld left_symter;\n+\ttree array;\n \n \tassert (ffebld_op (thing) == FFEBLD_opITEM);\n \tstart = ffebld_head (thing);\n \tthing = ffebld_trail (thing);\n \tassert (ffebld_trail (thing) == NULL);\n \tend = ffebld_head (thing);\n \n+\t/* Determine name for pretty-printing range-check errors.  */\n+\tfor (left_symter = ffebld_left (expr);\n+\t     left_symter && ffebld_op (left_symter) == FFEBLD_opARRAYREF;\n+\t     left_symter = ffebld_left (left_symter))\n+\t  ;\n+\tif (ffebld_op (left_symter) == FFEBLD_opSYMTER)\n+\t  char_name = ffesymbol_text (ffebld_symter (left_symter));\n+\telse\n+\t  char_name = \"[expr?]\";\n+\n \tffecom_char_args_ (&item, length, ffebld_left (expr));\n \n \tif (item == error_mark_node || *length == error_mark_node)\n@@ -1803,14 +2020,20 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \t    break;\n \t  }\n \n+\tarray = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item)));\n+\n \tif (start == NULL)\n \t  {\n \t    if (end == NULL)\n \t      ;\n \t    else\n \t      {\n+\t\tend_tree = ffecom_expr (end);\n+\t\tif (ffe_is_subscript_check ())\n+\t\t  end_tree = ffecom_subscript_check_ (array, end_tree, 1, 0,\n+\t\t\t\t\t\t      char_name);\n \t\tend_tree = convert (ffecom_f2c_ftnlen_type_node,\n-\t\t\t\t    ffecom_expr (end));\n+\t\t\t\t    end_tree);\n \n \t\tif (end_tree == error_mark_node)\n \t\t  {\n@@ -1823,8 +2046,12 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \t  }\n \telse\n \t  {\n+\t    start_tree = ffecom_expr (start);\n+\t    if (ffe_is_subscript_check ())\n+\t      start_tree = ffecom_subscript_check_ (array, start_tree, 0, 0,\n+\t\t\t\t\t\t    char_name);\n \t    start_tree = convert (ffecom_f2c_ftnlen_type_node,\n-\t\t\t\t  ffecom_expr (start));\n+\t\t\t\t  start_tree);\n \n \t    if (start_tree == error_mark_node)\n \t      {\n@@ -1852,8 +2079,12 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \t      }\n \t    else\n \t      {\n+\t\tend_tree = ffecom_expr (end);\n+\t\tif (ffe_is_subscript_check ())\n+\t\t  end_tree = ffecom_subscript_check_ (array, end_tree, 1, 0,\n+\t\t\t\t\t\t      char_name);\n \t\tend_tree = convert (ffecom_f2c_ftnlen_type_node,\n-\t\t\t\t    ffecom_expr (end));\n+\t\t\t\t    end_tree);\n \n \t\tif (end_tree == error_mark_node)\n \t\t  {\n@@ -2973,17 +3204,11 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n \n     case FFEBLD_opARRAYREF:\n       {\n-\tffebld dims[FFECOM_dimensionsMAX];\n-#if FFECOM_FASTER_ARRAY_REFS\n-\ttree array;\n-#endif\n-\tint i;\n+\tif (0 /* ~~~~~ ffe_is_flat_arrays () */)\n+\t  t = ffecom_ptr_to_expr (ffebld_left (expr));\n+\telse\n+\t  t = ffecom_expr (ffebld_left (expr));\n \n-#if FFECOM_FASTER_ARRAY_REFS\n-\tt = ffecom_ptr_to_expr (ffebld_left (expr));\n-#else\n-\tt = ffecom_expr (ffebld_left (expr));\n-#endif\n \tif (t == error_mark_node)\n \t  return t;\n \n@@ -2992,36 +3217,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n \t  return error_mark_node;\t/* Make sure non-const ref is to\n \t\t\t\t\t   non-reg. */\n \n-\t/* Build up ARRAY_REFs in reverse order (since we're column major\n-\t   here in Fortran land). */\n-\n-\tfor (i = 0, expr = ffebld_right (expr);\n-\t     expr != NULL;\n-\t     expr = ffebld_trail (expr))\n-\t  dims[i++] = ffebld_head (expr);\n-\n-#if FFECOM_FASTER_ARRAY_REFS\n-\tfor (--i, array = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (t)));\n-\t     i >= 0;\n-\t     --i, array = TYPE_MAIN_VARIANT (TREE_TYPE (array)))\n-\t  t = ffecom_2 (PLUS_EXPR,\n-\t\t\tbuild_pointer_type (TREE_TYPE (array)),\n-\t\t\tt,\n-\t\t\tsize_binop (MULT_EXPR,\n-\t\t\t\t    size_in_bytes (TREE_TYPE (array)),\n-\t\t\t\t    size_binop (MINUS_EXPR,\n-\t\t\t\t\t\tffecom_expr (dims[i]),\n-\t\t\t\t\t\tTYPE_MIN_VALUE (TYPE_DOMAIN (array)))));\n-\tt = ffecom_1 (INDIRECT_REF,\n-\t\t      TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (t))),\n-\t\t      t);\n-#else\n-\twhile (i > 0)\n-\t  t = ffecom_2 (ARRAY_REF,\n-\t\t\tTYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (t))),\n-\t\t\tt,\n-\t\t\tffecom_expr_ (dims[--i], NULL, NULL, NULL, FALSE, TRUE));\n-#endif\n+\tt = ffecom_arrayref_ (t, expr, 0);\n \n \treturn t;\n       }\n@@ -12522,10 +12718,6 @@ ffecom_ptr_to_expr (ffebld expr)\n \n     case FFEBLD_opARRAYREF:\n       {\n-\tffebld dims[FFECOM_dimensionsMAX];\n-\ttree array;\n-\tint i;\n-\n \titem = ffecom_ptr_to_expr (ffebld_left (expr));\n \n \tif (item == error_mark_node)\n@@ -12536,32 +12728,7 @@ ffecom_ptr_to_expr (ffebld expr)\n \t  return error_mark_node;\t/* Make sure non-const ref is to\n \t\t\t\t\t   non-reg. */\n \n-\t/* Build up ARRAY_REFs in reverse order (since we're column major\n-\t   here in Fortran land). */\n-\n-\tfor (i = 0, expr = ffebld_right (expr);\n-\t     expr != NULL;\n-\t     expr = ffebld_trail (expr))\n-\t  dims[i++] = ffebld_head (expr);\n-\n-\tfor (--i, array = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item)));\n-\t     i >= 0;\n-\t     --i, array = TYPE_MAIN_VARIANT (TREE_TYPE (array)))\n-\t  {\n-\t    /* The initial subtraction should happen in the original type so\n-\t       that (possible) negative values are handled appropriately.  */\n-\t    item\n-\t      = ffecom_2 (PLUS_EXPR,\n-\t\t\t  build_pointer_type (TREE_TYPE (array)),\n-\t\t\t  item,\n-\t\t\t  size_binop (MULT_EXPR,\n-\t\t\t\t      size_in_bytes (TREE_TYPE (array)),\n-\t\t\t\t      convert (sizetype,\n-\t\t\t\t\t       fold (build (MINUS_EXPR,\n-\t\t\t\t\t\t     TREE_TYPE (TYPE_MIN_VALUE (TYPE_DOMAIN (array))),\n-\t\t\t\t\t\t     ffecom_expr (dims[i]),\n-\t\t\t\t\t\t     TYPE_MIN_VALUE (TYPE_DOMAIN (array)))))));\n-\t  }\n+\titem = ffecom_arrayref_ (item, expr, 1);\n       }\n       return item;\n "}, {"sha": "9bd39283f1e68891448026572f865f9e4afdce37", "filename": "gcc/f/g77.texi", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fg77.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fg77.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77.texi?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -2,7 +2,7 @@\n @c %**start of header\n @setfilename g77.info\n \n-@set last-update 1999-04-17\n+@set last-update 1999-04-23\n @set copyrights-g77 1995-1999\n \n @include root.texi\n@@ -1471,6 +1471,7 @@ by type.  Explanations are in the following sections.\n -falias-check  -fargument-alias\n -fargument-noalias  -fno-argument-noalias-global\n -fno-globals\n+-fsubscript-check  -ff2c-subscript-check\n @end smallexample\n @end table\n \n@@ -3370,6 +3371,73 @@ and warns about similar disagreements\n that are currently believed to not\n likely to result in the compiler later crashing\n or producing incorrect code.\n+\n+@cindex -fsubscript-check option\n+@cindex -ff2c-subscript-check option\n+@item -fsubscript-check\n+@itemx -ff2c-subscript-check\n+@cindex bounds checking\n+@cindex range checking\n+@cindex array bounds checking\n+@cindex subscript checking\n+@cindex substring checking\n+@cindex checking subscripts\n+@cindex checking substrings\n+Enable generation of run-time checks for array subscripts\n+and substring start and end points\n+against the (locally) declared minimum and maximum values.\n+\n+The current implementation uses the @code{libf2c}\n+library routine @code{s_rnge} to print the diagnostic.\n+\n+However, whereas @code{f2c} generates a single check per\n+reference for a multi-dimensional array, of the computed\n+offset against the valid offset range (0 through the size of the array),\n+@code{g77} generates a single check per @emph{subscript} expression.\n+This catches some cases of potential bugs that @code{f2c} does not,\n+such as references to below the beginning of an assumed-size array.\n+\n+@code{g77} also generates checks for @code{CHARACTER} substring references,\n+something @code{f2c} currently does not do.\n+\n+Since a future version of @code{g77} might use a different implementation,\n+use the new @samp{-ff2c-subscript-check} option\n+if your application requires use of @code{s_rnge} or a compile-time diagnostic.\n+\n+@emph{Note:} To provide more detailed information on the offending subscript,\n+@code{g77} provides @code{s_rnge}\n+with somewhat differently-formatted information.\n+Here's a sample diagnostic:\n+\n+@smallexample\n+Subscript out of range on file line 4, procedure rnge.f/bf.\n+Attempt to access the -6-th element of variable b[subscript-2-of-2].\n+Aborted\n+@end smallexample\n+\n+The above message indicates that the offending source line is\n+line 4 of the file @file{rnge.f},\n+within the program unit (or statement function) named @samp{bf}.\n+The offended array is named @samp{b}.\n+The offended array dimension is the second for a two-dimensional array,\n+and the offending, computed subscript expression was @samp{-6}.\n+\n+For a @code{CHARACTER} substring reference, the second line has\n+this appearance:\n+\n+@smallexample\n+Attempt to access the 11-th element of variable a[start-substring].\n+@end smallexample\n+\n+This indicates that the offended @code{CHARACTER} variable or array\n+is named @samp{a},\n+the offended substring position is the starting (leftmost) position,\n+and the offending substring expression is @samp{11}.\n+\n+(Though the verbage of @code{s_rnge} is not ideal\n+for the purpose of the @code{g77} compiler,\n+the above information should provide adequate diagnostic abilities\n+to it users.)\n @end table\n \n @xref{Code Gen Options,,Options for Code Generation Conventions,\n@@ -11015,6 +11083,8 @@ themselves as @emph{visible} problems some time later.\n Overflowing the bounds of an array---usually by writing beyond\n the end of it---is one of two kinds of bug that often occurs\n in Fortran code.\n+(Compile your code with the @samp{-fsubscript-check} option\n+to catch many of these kinds of errors at program run time.)\n \n The other kind of bug is a mismatch between the actual arguments\n passed to a procedure and the dummy arguments as declared by that\n@@ -11028,11 +11098,13 @@ That is, these bugs can be quite sensitive to data, including\n data representing the placement of other data in memory (that is,\n pointers, such as the placement of stack frames in memory).\n \n-Plans call for improving @code{g77} so that it can offer the\n+@code{g77} now offers the\n ability to catch and report some of these problems at compile, link, or\n run time, such as by generating code to detect references to\n-beyond the bounds of an array, or checking for agreement between\n-calling and called procedures.\n+beyond the bounds of most arrays (except assumed-size arrays),\n+and checking for agreement between calling and called procedures.\n+Future improvements are likely to be made in the procedure-mismatch area,\n+at least.\n \n In the meantime, finding and fixing the programming\n bugs that lead to these behaviors is, ultimately, the user's\n@@ -11275,7 +11347,6 @@ Better diagnostics:\n \n Run-time facilities:\n * Uninitialized Variables at Run Time::\n-* Bounds Checking at Run Time::\n * Portable Unformatted Files::\n \n Debugging:\n@@ -12159,15 +12230,6 @@ some kinds of uninitialized variables at run time.\n Note that use of the options @samp{-O -Wuninitialized} can catch\n many such bugs at compile time.\n \n-@node Bounds Checking at Run Time\n-@subsection Bounds Checking at Run Time\n-\n-@code{g77} should offer run-time bounds-checking of array/subscript references\n-in a fashion similar to @code{f2c}.\n-\n-Note that @code{g77} already warns about references to out-of-bounds\n-elements of arrays when it detects these at compile time.\n-\n @node Portable Unformatted Files\n @subsection Portable Unformatted Files\n "}, {"sha": "4e98a309b0c45a2f78245462b19feb0d93f3a3aa", "filename": "gcc/f/lang-options.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flang-options.h?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -147,6 +147,10 @@ FTNOPT( \"-fglobals\", \"\" )\n FTNOPT( \"-fno-globals\", \"Disable fatal diagnostics about inter-procedural problems\" )\n FTNOPT( \"-ftypeless-boz\", \"Make prefix-radix non-decimal constants be typeless\" )\n FTNOPT( \"-fno-typeless-boz\", \"\" )\n+FTNOPT( \"-fsubscript-check\", \"Generate code to check array-subscript ranges\" )\n+FTNOPT( \"-fno-subscript-check\", \"\" )\n+FTNOPT( \"-ff2c-subscript-check\", \"Generate f2c-like code to check array-subscript ranges\")\n+FTNOPT( \"-fno-f2c-subscript-check\", \"\" )\n FTNOPT( \"-Wglobals\", \"\" )\n FTNOPT( \"-Wno-globals\", \"Disable warnings about inter-procedural problems\" )\n /*\"-Wimplicit\",*/"}, {"sha": "3c43cad5468db712960cab8fcaa9d6778a799af3", "filename": "gcc/f/news.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fnews.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fnews.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fnews.texi?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -9,7 +9,7 @@\n @c in the standalone derivations of this file (e.g. NEWS).\n @set copyrights-news 1995-1999\n \n-@set last-update-news 1999-04-20\n+@set last-update-news 1999-04-23\n \n @include root.texi\n \n@@ -187,6 +187,17 @@ The @samp{-ax} option is now obeyed when compiling Fortran programs.\n (It is passed to the @file{f771} driver.)\n @end ifclear\n \n+@item\n+The new @samp{-fsubscript-check} option\n+causes @code{g77} to compile run-time bounds checks\n+of array subscripts, as well as of substring start and end points.\n+\n+The current implementation uses the @code{libf2c}\n+library routine @code{s_rnge} to print the diagnostic.\n+Since a future version of @code{g77} might use a different implementation,\n+use the new @samp{-ff2c-subscript-check} option\n+if your application requires use of @code{s_rnge} or a compile-time diagnostic.\n+\n @item\n Source file names with the suffixes @samp{.FOR} and @samp{.FPP}\n now are recognized by @code{g77}\n@@ -224,12 +235,15 @@ The @samp{-malign-double} option\n now reliably aligns @emph{all} double-precision variables and arrays\n on Intel x86 targets.\n \n+@ifclear USERVISONLY\n @item\n Even without the @samp{-malign-double} option,\n @code{g77} reliably aligns local double-precision variables\n that are not in @code{EQUIVALENCE} areas\n and not @code{SAVE}'d.\n+@end ifclear\n \n+@ifclear USERVISONLY\n @item\n A substantial portion of the @code{g77} front end's code-generation component\n was rewritten.\n@@ -238,6 +252,7 @@ by the @code{gcc} back end.\n One effect of this rewrite is that some codes no longer produce\n a spurious ``label @var{lab} used before containing binding contour''\n message.\n+@end ifclear\n \n @item\n Support for the @samp{-fugly} option has been removed."}, {"sha": "2b018555b1e77880ffc14480c03134990faac6cf", "filename": "gcc/f/ste.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -3096,7 +3096,7 @@ ffeste_R819B (ffestw block, ffelab label UNUSED, ffebld expr)\n \n     if (expr)\n       {\n-\ttree loop;\n+\tstruct nesting *loop;\n \n \tresult = ffecom_make_tempvar (\"dowhile\", integer_type_node,\n \t\t\t\t      FFETARGET_charactersizeNONE, -1);"}, {"sha": "8603f011ea095e291e461122b8860df6c8751418", "filename": "gcc/f/top.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Ftop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Ftop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftop.c?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -82,6 +82,7 @@ bool ffe_is_mainprog_;\t\t/* TRUE if current prog unit known to be\n bool ffe_is_null_version_ = FALSE;\n bool ffe_is_onetrip_ = FALSE;\n bool ffe_is_silent_ = TRUE;\n+bool ffe_is_subscript_check_ = FALSE;\n bool ffe_is_typeless_boz_ = FALSE;\n bool ffe_is_pedantic_ = FFETARGET_defaultIS_PEDANTIC;\n bool ffe_is_saveall_;\t\t/* TRUE if mainprog or SAVE (no args) seen. */\n@@ -317,6 +318,14 @@ ffe_decode_option (argc, argv)\n \tffe_set_is_globals (TRUE);\n       else if (strcmp (&opt[2], \"no-globals\") == 0)\n \tffe_set_is_globals (FALSE);\n+      else if (strcmp (&opt[2], \"subscript-check\") == 0)\n+\tffe_set_is_subscript_check (TRUE);\n+      else if (strcmp (&opt[2], \"no-subscript-check\") == 0)\n+\tffe_set_is_subscript_check (FALSE);\n+      else if (strcmp (&opt[2], \"f2c-subscript-check\") == 0)\n+\tffe_set_is_subscript_check (TRUE);\n+      else if (strcmp (&opt[2], \"no-f2c-subscript-check\") == 0)\n+\tffe_set_is_subscript_check (FALSE);\n       else if (strcmp (&opt[2], \"typeless-boz\") == 0)\n \tffe_set_is_typeless_boz (TRUE);\n       else if (strcmp (&opt[2], \"no-typeless-boz\") == 0)"}, {"sha": "c03e1d6540039ea4f357a08180179f32461e5fd2", "filename": "gcc/f/top.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Ftop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Ftop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftop.h?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -97,6 +97,7 @@ extern bool ffe_is_mainprog_;\n extern bool ffe_is_null_version_;\n extern bool ffe_is_onetrip_;\n extern bool ffe_is_silent_;\n+extern bool ffe_is_subscript_check_;\n extern bool ffe_is_typeless_boz_;\n extern bool ffe_is_pedantic_;\n extern bool ffe_is_saveall_;\n@@ -188,6 +189,7 @@ void ffe_terminate_4 (void);\n #define ffe_is_saveall() ffe_is_saveall_\n #define ffe_is_second_underscore() ffe_is_second_underscore_\n #define ffe_is_silent() ffe_is_silent_\n+#define ffe_is_subscript_check() ffe_is_subscript_check_\n #define ffe_is_typeless_boz() ffe_is_typeless_boz_\n #define ffe_is_ugly_args() ffe_is_ugly_args_\n #define ffe_is_ugly_assign() ffe_is_ugly_assign_\n@@ -238,6 +240,7 @@ void ffe_terminate_4 (void);\n #define ffe_set_is_saveall(f) (ffe_is_saveall_ = (f))\n #define ffe_set_is_second_underscore(f) (ffe_is_second_underscore_ = (f))\n #define ffe_set_is_silent(f) (ffe_is_silent_ = (f))\n+#define ffe_set_is_subscript_check(f) (ffe_is_subscript_check_ = (f))\n #define ffe_set_is_typeless_boz(f) (ffe_is_typeless_boz_ = (f))\n #define ffe_set_is_ugly_args(f) (ffe_is_ugly_args_ = (f))\n #define ffe_set_is_ugly_assign(f) (ffe_is_ugly_assign_ = (f))"}, {"sha": "82ab0146a9289318e33f948ea05b92249302fd13", "filename": "gcc/f/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55276ed95655f743db4b87a77495a348df946f/gcc%2Ff%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fversion.c?ref=6b55276ed95655f743db4b87a77495a348df946f", "patch": "@@ -1 +1 @@\n-const char *ffe_version_string = \"0.5.24-19990420\";\n+const char *ffe_version_string = \"0.5.24-19990423\";"}]}