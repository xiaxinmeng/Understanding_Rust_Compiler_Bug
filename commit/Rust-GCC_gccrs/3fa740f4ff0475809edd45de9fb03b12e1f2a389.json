{"sha": "3fa740f4ff0475809edd45de9fb03b12e1f2a389", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZhNzQwZjRmZjA0NzU4MDllZGQ0NWRlOWZiMDNiMTJlMWYyYTM4OQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-10T14:17:19Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-12T21:39:45Z"}, "message": "Add TyTy::BaseType::can_eq method to tyty module\n\nWhen we are probing paths we dont want to unify types as we are testing\nto find something so a can_eq method simialr to unify but does not throw\nerrors allows for testing if types could be compatible.", "tree": {"sha": "eeecbfe6f14a49a0f7e471f86352da08e30834a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeecbfe6f14a49a0f7e471f86352da08e30834a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fa740f4ff0475809edd45de9fb03b12e1f2a389", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa740f4ff0475809edd45de9fb03b12e1f2a389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fa740f4ff0475809edd45de9fb03b12e1f2a389", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa740f4ff0475809edd45de9fb03b12e1f2a389/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c5a6af749de89d5e21a525e74b94b01b3f3b35f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5a6af749de89d5e21a525e74b94b01b3f3b35f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5a6af749de89d5e21a525e74b94b01b3f3b35f"}], "stats": {"total": 1017, "additions": 1006, "deletions": 11}, "files": [{"sha": "e2e0d08e9bc98f134ae51d1cd2841b4203870cc7", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "added", "additions": 812, "deletions": 0, "changes": 812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=3fa740f4ff0475809edd45de9fb03b12e1f2a389", "patch": "@@ -0,0 +1,812 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_CMP_H\n+#define RUST_TYTY_CMP_H\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseCmp : public TyVisitor\n+{\n+public:\n+  virtual bool can_eq (BaseType *other)\n+  {\n+    if (other->get_kind () == TypeKind::PARAM)\n+      {\n+\tParamType *p = static_cast<ParamType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+\n+    other->accept_vis (*this);\n+    return ok;\n+  }\n+\n+  virtual void visit (TupleType &) override { ok = false; }\n+\n+  virtual void visit (ADTType &) override { ok = false; }\n+\n+  virtual void visit (InferType &) override { ok = false; }\n+\n+  virtual void visit (FnType &) override { ok = false; }\n+\n+  virtual void visit (FnPtr &) override { ok = false; }\n+\n+  virtual void visit (ArrayType &) override { ok = false; }\n+\n+  virtual void visit (BoolType &) override { ok = false; }\n+\n+  virtual void visit (IntType &) override { ok = false; }\n+\n+  virtual void visit (UintType &) override { ok = false; }\n+\n+  virtual void visit (USizeType &) override { ok = false; }\n+\n+  virtual void visit (ISizeType &) override { ok = false; }\n+\n+  virtual void visit (FloatType &) override { ok = false; }\n+\n+  virtual void visit (ErrorType &) override { ok = false; }\n+\n+  virtual void visit (CharType &) override { ok = false; }\n+\n+  virtual void visit (ReferenceType &) override { ok = false; }\n+\n+  virtual void visit (ParamType &) override\n+  {\n+    // it is ok for types to can eq to a ParamType\n+    ok = true;\n+  }\n+\n+  virtual void visit (StrType &) override { ok = false; }\n+\n+protected:\n+  BaseCmp (BaseType *base)\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()), ok (false)\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n+  bool ok;\n+\n+private:\n+  /* Returns a pointer to the ty that created this rule. */\n+  virtual BaseType *get_base () = 0;\n+};\n+\n+class InferCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  InferCmp (InferType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (USizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ISizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tok = true;\n+\treturn;\n+\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (CharType &type) override\n+  {\n+    {\n+      bool is_valid\n+\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+      if (is_valid)\n+\t{\n+\t  ok = true;\n+\t  return;\n+\t}\n+\n+      BaseCmp::visit (type);\n+    }\n+  }\n+\n+  void visit (ReferenceType &type) override\n+\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  InferType *base;\n+};\n+\n+class FnCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FnCmp (FnType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tauto unified_param = a->unify (b);\n+\tif (unified_param == nullptr)\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    auto unified_return\n+      = base->get_return_type ()->unify (type.get_return_type ());\n+    if (unified_return == nullptr)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnType *base;\n+};\n+\n+class FnptrCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FnptrCmp (FnPtr *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (FnPtr &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i);\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i).second;\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnPtr *base;\n+};\n+\n+class ArrayCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ArrayCmp (ArrayType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (ArrayType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    // need to check the base types and capacity\n+    if (type.get_capacity () != base->get_capacity ())\n+      {\n+\tLocation locus = mappings->lookup_location (type.get_ref ());\n+\trust_error_at (locus, \"mismatch in array capacity\");\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ArrayType *base;\n+};\n+\n+class BoolCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  BoolCmp (BoolType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (BoolType &type) override { ok = true; }\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  BoolType *base;\n+};\n+\n+class IntCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  IntCmp (IntType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    ok = type.get_int_kind () == base->get_int_kind ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  IntType *base;\n+};\n+\n+class UintCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  UintCmp (UintType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    ok = type.get_uint_kind () == base->get_uint_kind ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  UintType *base;\n+};\n+\n+class FloatCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FloatCmp (FloatType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::INTEGRAL;\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    ok = type.get_float_kind () == base->get_float_kind ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FloatType *base;\n+};\n+\n+class ADTCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ADTCmp (ADTType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (ADTType &type) override\n+  {\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < type.num_fields (); ++i)\n+      {\n+\tTyTy::StructFieldType *base_field = base->get_field (i);\n+\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\n+\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\tif (!this_field_ty->can_eq (other_field_ty))\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ADTType *base;\n+};\n+\n+class TupleCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  TupleCmp (TupleType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (TupleType &type) override\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tBaseType *bo = base->get_field (i);\n+\tBaseType *fo = type.get_field (i);\n+\n+\tif (!bo->can_eq (fo))\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  TupleType *base;\n+};\n+\n+class USizeCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  USizeCmp (USizeType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (USizeType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  USizeType *base;\n+};\n+\n+class ISizeCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ISizeCmp (ISizeType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (ISizeType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ISizeType *base;\n+};\n+\n+class CharCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  CharCmp (CharType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+  void visit (CharType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  CharType *base;\n+};\n+\n+class ReferenceCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ReferenceCmp (ReferenceType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (ReferenceType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    ok = base_type->can_eq (other_base_type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ReferenceType *base;\n+};\n+\n+class ParamCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ParamCmp (ParamType *base) : BaseCmp (base), base (base) {}\n+\n+  // param types are a placeholder we shouldn't have cases where we unify\n+  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n+  //\n+  // foo<i32>{ a: 123 }.\n+  // Then this enforces the i32 type to be referenced on the\n+  // field via an hirid.\n+  //\n+  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n+  // to handle the typing of the struct\n+  bool can_eq (BaseType *other) override final\n+  {\n+    if (base->get_ref () == base->get_ty_ref ())\n+      return BaseCmp::can_eq (other);\n+\n+    auto context = Resolver::TypeCheckContext::get ();\n+    BaseType *lookup = nullptr;\n+    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n+    rust_assert (ok);\n+\n+    return lookup->can_eq (other);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    ok = base->get_symbol ().compare (type.get_symbol ()) == 0;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ParamType *base;\n+};\n+\n+class StrCmp : public BaseCmp\n+{\n+  // FIXME we will need a enum for the StrType like ByteBuf etc..\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  StrCmp (StrType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (StrType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  StrType *base;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_CMP_H"}, {"sha": "8f2faeccff67851d2d56386658137110d98f0d1d", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 122, "deletions": 2, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=3fa740f4ff0475809edd45de9fb03b12e1f2a389", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-tyty-rules.h\"\n+#include \"rust-tyty-cmp.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n \n@@ -91,6 +92,13 @@ InferType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+InferType::can_eq (BaseType *other)\n+{\n+  InferCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n InferType::clone ()\n {\n@@ -107,11 +115,13 @@ InferType::default_type (BaseType **type) const\n     {\n     case GENERAL:\n       return false;\n+\n       case INTEGRAL: {\n \tok = context->lookup_builtin (\"i32\", type);\n \trust_assert (ok);\n \treturn ok;\n       }\n+\n       case FLOAT: {\n \tok = context->lookup_builtin (\"f64\", type);\n \trust_assert (ok);\n@@ -139,6 +149,12 @@ ErrorType::unify (BaseType *other)\n   return this;\n }\n \n+bool\n+ErrorType::can_eq (BaseType *other)\n+{\n+  return get_kind () == other->get_kind ();\n+}\n+\n BaseType *\n ErrorType::clone ()\n {\n@@ -303,6 +319,13 @@ ADTType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ADTType::can_eq (BaseType *other)\n+{\n+  ADTCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n ADTType::is_equal (const BaseType &other) const\n {\n@@ -418,8 +441,7 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \tBaseType *concrete\n \t  = Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n \n-\tif (concrete == nullptr\n-\t    || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\tif (concrete->get_kind () == TyTy::TypeKind::ERROR)\n \t  {\n \t    rust_error_at (subst_mappings.get_locus (),\n \t\t\t   \"Failed to resolve field substitution type: %s\",\n@@ -469,6 +491,13 @@ TupleType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+TupleType::can_eq (BaseType *other)\n+{\n+  TupleCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n TupleType::is_equal (const BaseType &other) const\n {\n@@ -523,6 +552,13 @@ FnType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+FnType::can_eq (BaseType *other)\n+{\n+  FnCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n FnType::is_equal (const BaseType &other) const\n {\n@@ -712,6 +748,13 @@ FnPtr::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+FnPtr::can_eq (BaseType *other)\n+{\n+  FnptrCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n FnPtr::is_equal (const BaseType &other) const\n {\n@@ -766,6 +809,13 @@ ArrayType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ArrayType::can_eq (BaseType *other)\n+{\n+  ArrayCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n ArrayType::is_equal (const BaseType &other) const\n {\n@@ -814,6 +864,13 @@ BoolType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+BoolType::can_eq (BaseType *other)\n+{\n+  BoolCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n BoolType::clone ()\n {\n@@ -853,6 +910,13 @@ IntType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+IntType::can_eq (BaseType *other)\n+{\n+  IntCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n IntType::clone ()\n {\n@@ -903,6 +967,13 @@ UintType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+UintType::can_eq (BaseType *other)\n+{\n+  UintCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n UintType::clone ()\n {\n@@ -947,6 +1018,13 @@ FloatType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+FloatType::can_eq (BaseType *other)\n+{\n+  FloatCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n FloatType::clone ()\n {\n@@ -983,6 +1061,13 @@ USizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+USizeType::can_eq (BaseType *other)\n+{\n+  USizeCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n USizeType::clone ()\n {\n@@ -1008,6 +1093,13 @@ ISizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ISizeType::can_eq (BaseType *other)\n+{\n+  ISizeCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n ISizeType::clone ()\n {\n@@ -1033,6 +1125,13 @@ CharType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+CharType::can_eq (BaseType *other)\n+{\n+  CharCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n CharType::clone ()\n {\n@@ -1058,6 +1157,13 @@ ReferenceType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ReferenceType::can_eq (BaseType *other)\n+{\n+  ReferenceCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n ReferenceType::is_equal (const BaseType &other) const\n {\n@@ -1110,6 +1216,13 @@ ParamType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ParamType::can_eq (BaseType *other)\n+{\n+  ParamCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n ParamType::clone ()\n {\n@@ -1178,6 +1291,13 @@ StrType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+StrType::can_eq (BaseType *other)\n+{\n+  StrCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n StrType::is_equal (const BaseType &other) const\n {"}, {"sha": "c428c4c6c6cd7bd252063824eeb68b446a2f2373", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=3fa740f4ff0475809edd45de9fb03b12e1f2a389", "patch": "@@ -75,15 +75,20 @@ class BaseType\n \n   virtual std::string get_name () const = 0;\n \n-  /* Unify two types. Returns a pointer to the newly-created unified ty, or\n-     nullptr if the two ty cannot be unified. The caller is responsible for\n-     releasing the memory of the returned ty. */\n+  // Unify two types. Returns a pointer to the newly-created unified ty, or\n+  // nullptr if the two ty cannot be unified. The caller is responsible for\n+  // releasing the memory of the returned ty. using ignore_errors alows for a\n+  // can_eq style unification\n   virtual BaseType *unify (BaseType *other) = 0;\n \n-  /* Check value equality between two ty. Type inference rules are ignored. Two\n-     ty are considered equal if they're of the same kind, and\n-       1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n-       2. (For functions) have the same signature */\n+  // similar to unify but does not actually perform type unification but\n+  // determines whether they are compatible\n+  virtual bool can_eq (BaseType *other) = 0;\n+\n+  // Check value equality between two ty. Type inference rules are ignored. Two\n+  //   ty are considered equal if they're of the same kind, and\n+  //     1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n+  //     2. (For functions) have the same signature\n   virtual bool is_equal (const BaseType &other) const\n   {\n     return get_kind () == other.get_kind ();\n@@ -113,6 +118,8 @@ class BaseType\n     return supports_substitutions () && has_subsititions_defined ();\n   }\n \n+  virtual bool needs_generic_substitutions () const { return false; }\n+\n   std::string mappings_str () const\n   {\n     std::string buffer = \"Ref: \" + std::to_string (get_ref ())\n@@ -129,7 +136,11 @@ class BaseType\n     return as_string () + \":\" + mappings_str ();\n   }\n \n-  void debug () const { printf (\"%s\\n\", debug_str ().c_str ()); }\n+  void debug () const\n+  {\n+    printf (\"[%p] %s\\n\", static_cast<const void *> (this),\n+\t    debug_str ().c_str ());\n+  }\n \n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n@@ -188,6 +199,8 @@ class InferType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n+  bool can_eq (BaseType *other) override;\n+\n   BaseType *clone () final override;\n \n   InferTypeKind get_infer_kind () const { return infer_kind; }\n@@ -220,6 +233,7 @@ class ErrorType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -246,6 +260,7 @@ class ParamType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -316,6 +331,7 @@ class TupleType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -419,6 +435,12 @@ class SubstitutionArg\n \n   static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n \n+  bool is_conrete () const\n+  {\n+    return argument != nullptr && argument->get_kind () != TyTy::TypeKind::ERROR\n+\t   && argument->get_kind () != TyTy::TypeKind::PARAM;\n+  }\n+\n   std::string as_string () const\n   {\n     return param->as_string () + \":\" + argument->as_string ();\n@@ -473,6 +495,19 @@ class SubstitutionArgumentMappings\n     return false;\n   }\n \n+  // is_concrete means if the used args is non error, ie: non empty this will\n+  // verify if actual real types have been put in place of are they still\n+  // ParamTy\n+  bool is_concrete () const\n+  {\n+    for (auto &mapping : mappings)\n+      {\n+\tif (!mapping.is_conrete ())\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n   Location get_locus () { return locus; }\n \n   size_t size () const { return mappings.size (); }\n@@ -543,7 +578,8 @@ class SubstitutionRef\n \n   bool needs_substitution () const\n   {\n-    return has_substitutions () && used_arguments.is_error ();\n+    return has_substitutions ()\n+\t   && (used_arguments.is_error () || !used_arguments.is_concrete ());\n   }\n \n   bool was_substituted () const { return !needs_substitution (); }\n@@ -622,11 +658,14 @@ class ADTType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n   size_t num_fields () const { return fields.size (); }\n \n+  std::string get_identifier () const { return identifier; }\n+\n   std::string get_name () const override final\n   {\n     return identifier + subst_as_string ();\n@@ -671,6 +710,11 @@ class ADTType : public BaseType, public SubstitutionRef\n       }\n   }\n \n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n   bool supports_substitutions () const override final { return true; }\n \n   bool has_subsititions_defined () const override final\n@@ -716,6 +760,7 @@ class FnType : public BaseType, public SubstitutionRef\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -745,6 +790,11 @@ class FnType : public BaseType, public SubstitutionRef\n \n   BaseType *clone () final override;\n \n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n   bool supports_substitutions () const override final { return true; }\n \n   bool has_subsititions_defined () const override final\n@@ -788,6 +838,7 @@ class FnPtr : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -829,6 +880,7 @@ class ArrayType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -866,6 +918,7 @@ class BoolType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -898,6 +951,7 @@ class IntType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   IntKind get_int_kind () const { return int_kind; }\n \n@@ -937,6 +991,7 @@ class UintType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   UintKind get_uint_kind () const { return uint_kind; }\n \n@@ -974,6 +1029,7 @@ class FloatType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   FloatKind get_float_kind () const { return float_kind; }\n \n@@ -1013,6 +1069,7 @@ class USizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1045,6 +1102,7 @@ class ISizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1077,6 +1135,7 @@ class CharType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1113,6 +1172,7 @@ class ReferenceType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1150,6 +1210,7 @@ class StrType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n "}, {"sha": "67a33f41295f414f4f3297841b1ccd0bb2a42f33", "filename": "gcc/testsuite/rust.test/xfail_compile/tuple1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftuple1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftuple1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftuple1.rs?ref=3fa740f4ff0475809edd45de9fb03b12e1f2a389", "patch": "@@ -1,3 +1,4 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n fn main() {\n     let a: (i32, bool) = (123, 123); // { dg-error \"expected .bool. got .<integer>.\" }\n     let b;"}, {"sha": "53b49234b6a5f6f2ce7a92cc592121f5ef1a1a8b", "filename": "gcc/testsuite/rust.test/xfail_compile/type-alias1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftype-alias1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa740f4ff0475809edd45de9fb03b12e1f2a389/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftype-alias1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftype-alias1.rs?ref=3fa740f4ff0475809edd45de9fb03b12e1f2a389", "patch": "@@ -1,3 +1,4 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n type TypeAlias = (i32, u32);\n \n fn main() {"}]}