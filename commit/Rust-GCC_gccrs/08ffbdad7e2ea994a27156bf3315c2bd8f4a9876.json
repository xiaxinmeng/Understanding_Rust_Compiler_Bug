{"sha": "08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhmZmJkYWQ3ZTJlYTk5NGEyNzE1NmJmMzMxNWMyYmQ4ZjRhOTg3Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-01-13T21:00:39Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-01-13T21:00:39Z"}, "message": "* trans.c (call_to_gnu):Invoke the addressable_p predicate only\n\twhen necessary. \u00a0Merge some conditional statements. \u00a0Update comments.\n\tRename unchecked_convert_p local variable to suppress_type_conversion.\n\tDo not suppress conversions in the In case.\n\t(addressable_p) <VIEW_CONVERT_EXPR>: Do not take alignment issues\n\tinto account on non strict-alignment platforms.\n\nFrom-SVN: r131510", "tree": {"sha": "ccaa43f2838bf1a1c50299fdc2c0970775cd3b56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccaa43f2838bf1a1c50299fdc2c0970775cd3b56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/comments", "author": null, "committer": null, "parents": [{"sha": "2cb207f7f387df9b17fbebe76d09991e20d6e880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cb207f7f387df9b17fbebe76d09991e20d6e880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cb207f7f387df9b17fbebe76d09991e20d6e880"}], "stats": {"total": 204, "additions": 132, "deletions": 72}, "files": [{"sha": "02ba42a53eb8eca2ddab3d789016fbc334e1910e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "patch": "@@ -1,3 +1,12 @@\n+2008-01-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* trans.c (call_to_gnu):Invoke the addressable_p predicate only\n+\twhen necessary. \ufffdMerge some conditional statements. \ufffdUpdate comments.\n+\tRename unchecked_convert_p local variable to suppress_type_conversion.\n+\tDo not suppress conversions in the In case.\n+\t(addressable_p) <VIEW_CONVERT_EXPR>: Do not take alignment issues\n+\tinto account on non strict-alignment platforms.\n+\n 2008-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* utils.c (aggregate_type_contains_array_p): New predicate."}, {"sha": "b61afceb3ade6b6b31916098bcae841deb74c009", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -495,7 +495,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Out_Parameter:\n     case E_Variable:\n \n-      /* Simple variables, loop variables, OUT parameters, and exceptions.  */\n+      /* Simple variables, loop variables, Out parameters, and exceptions.  */\n     object:\n       {\n \tbool used_by_ref = false;\n@@ -3395,7 +3395,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n        Each parameter is first checked by calling must_pass_by_ref on its\n        type to determine if it is passed by reference.  For parameters which\n-       are copied in, if they are Ada IN OUT or OUT parameters, their return\n+       are copied in, if they are Ada In Out or Out parameters, their return\n        value becomes part of a record which becomes the return type of the\n        function (C function - note that this applies only to Ada procedures\n        so there is no Ada return type). Additional code to store back the\n@@ -3406,7 +3406,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n        equivalent source rewritings that follow:\n \n \t\t\t\t\t\tstruct temp {int a,b};\n-       procedure P (A,B: IN OUT ...) is\t\ttemp P (int A,B)\n+       procedure P (A,B: In Out ...) is\t\ttemp P (int A,B)\n        begin\t\t\t\t\t{\n \t ..\t\t\t\t\t  ..\n        end P;\t\t\t\t\t  return {A,B};\n@@ -3438,7 +3438,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   parameters.  */\n \ttree gnu_field_list = NULL_TREE;\n \t/* Non-null for subprograms containing parameters passed by copy-in\n-\t   copy-out (Ada IN OUT or OUT parameters not passed by reference),\n+\t   copy-out (Ada In Out or Out parameters not passed by reference),\n \t   in which case it is the list of nodes used to specify the values of\n \t   the in out/out parameters that are returned as a record upon\n \t   procedure return.  The TREE_PURPOSE of an element of this list is\n@@ -4545,7 +4545,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n \n   /* If we must pass or were requested to pass by reference, do so.\n      If we were requested to pass by copy, do so.\n-     Otherwise, for foreign conventions, pass IN OUT or OUT parameters\n+     Otherwise, for foreign conventions, pass In Out or Out parameters\n      or aggregates by reference.  For COBOL and Fortran, pass all\n      integer and FP types that way too.  For Convention Ada, use\n      the standard Ada default.  */\n@@ -4566,22 +4566,22 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n       by_ref = true;\n     }\n \n-  /* Pass IN OUT or OUT parameters using copy-in copy-out mechanism.  */\n+  /* Pass In Out or Out parameters using copy-in copy-out mechanism.  */\n   else if (!in_param)\n     *cico = true;\n \n   if (mech == By_Copy && (by_ref || by_component_ptr))\n     post_error (\"?cannot pass & by copy\", gnat_param);\n \n-  /* If this is an OUT parameter that isn't passed by reference and isn't\n+  /* If this is an Out parameter that isn't passed by reference and isn't\n      a pointer or aggregate, we don't make a PARM_DECL for it.  Instead,\n      it will be a VAR_DECL created when we process the procedure, so just\n      return its type.  For the special parameter of a valued procedure,\n      never pass it in.\n \n      An exception is made to cover the RM-6.4.1 rule requiring \"by copy\"\n-     OUT parameters with discriminants or implicit initial values to be\n-     handled like IN OUT parameters.  These type are normally built as\n+     Out parameters with discriminants or implicit initial values to be\n+     handled like In Out parameters.  These type are normally built as\n      aggregates, hence passed by reference, except for some packed arrays\n      which end up encoded in special integer types.\n "}, {"sha": "e41b0b2fcd1d284cddd064d5219c3d626511cf48", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -608,7 +608,7 @@ extern tree create_field_decl (tree field_name, tree field_type,\n \n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n    PARAM_TYPE is its type.  READONLY is true if the parameter is\n-   readonly (either an IN parameter or an address of a pass-by-ref\n+   readonly (either an In parameter or an address of a pass-by-ref\n    parameter). */\n extern tree create_param_decl (tree param_name, tree param_type,\n                                bool readonly);"}, {"sha": "c5828d79d177faaef4186849002b4185e2fc3131", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 73, "deletions": 58, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1110,7 +1110,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t/* Make sure any implicit dereference gets done.  */\n \tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n \tgnu_prefix = maybe_unconstrained_array (gnu_prefix);\n-\t/* We treat unconstrained array IN parameters specially.  */\n+\t/* We treat unconstrained array In parameters specially.  */\n \tif (Nkind (Prefix (gnat_node)) == N_Identifier\n \t    && !Is_Constrained (Etype (Prefix (gnat_node)))\n \t    && Ekind (Entity (Prefix (gnat_node))) == E_In_Parameter)\n@@ -1815,7 +1815,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   begin_subprog_body (gnu_subprog_decl);\n   gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n \n-  /* If there are OUT parameters, we need to ensure that the return statement\n+  /* If there are Out parameters, we need to ensure that the return statement\n      properly copies them out.  We do this by making a new block and converting\n      any inner return into a goto to a label at the end of the block.  */\n   push_stack (&gnu_return_label_stack, NULL_TREE,\n@@ -1826,7 +1826,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   gnat_pushlevel ();\n \n   /* See if there are any parameters for which we don't yet have GCC entities.\n-     These must be for OUT parameters for which we will be making VAR_DECL\n+     These must be for Out parameters for which we will be making VAR_DECL\n      nodes here.  Fill them in to TYPE_CI_CO_LIST, which must contain the empty\n      entry as well.  We can match up the entries because TYPE_CI_CO_LIST is in\n      the order of the parameters.  */\n@@ -1836,7 +1836,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     if (!present_gnu_tree (gnat_param))\n       {\n \t/* Skip any entries that have been already filled in; they must\n-\t   correspond to IN OUT parameters.  */\n+\t   correspond to In Out parameters.  */\n \tfor (; gnu_cico_list && TREE_VALUE (gnu_cico_list);\n \t     gnu_cico_list = TREE_CHAIN (gnu_cico_list))\n \t  ;\n@@ -1865,7 +1865,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n \n   /* Generate the code of the subprogram itself.  A return statement will be\n-     present and any OUT parameters will be handled there.  */\n+     present and any Out parameters will be handled there.  */\n   add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n   gnat_poplevel ();\n   gnu_result = end_stmt_group ();\n@@ -2065,7 +2065,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n   /* Create the list of the actual parameters as GCC expects it, namely a chain\n      of TREE_LIST nodes in which the TREE_VALUE field of each node is a\n-     parameter-expression and the TREE_PURPOSE field is null.  Skip OUT\n+     parameter-expression and the TREE_PURPOSE field is null.  Skip Out\n      parameters not passed by reference and don't need to be copied in.  */\n   for (gnat_actual = First_Actual (gnat_node);\n        Present (gnat_actual);\n@@ -2076,13 +2076,20 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t= (present_gnu_tree (gnat_formal)\n \t   ? get_gnu_tree (gnat_formal) : NULL_TREE);\n       tree gnu_formal_type = gnat_to_gnu_type (Etype (gnat_formal));\n-      /* We treat a conversion between aggregate types as if it is an\n-\t unchecked conversion.  */\n-      bool unchecked_convert_p\n-\t= (Nkind (gnat_actual) == N_Unchecked_Type_Conversion\n+      /* We must suppress conversions that can cause the creation of a\n+\t temporary in the Out or In Out case because we need the real\n+\t object in this case, either to pass its address if it's passed\n+\t by reference or as target of the back copy done after the call\n+\t if it uses the copy-in copy-out mechanism.  We do it in the In\n+\t case too, except for an unchecked conversion because it alone\n+\t can cause the actual to be misaligned and the addressability\n+\t test is applied to the real object.  */\n+      bool suppress_type_conversion\n+\t= ((Nkind (gnat_actual) == N_Unchecked_Type_Conversion\n+\t    && Ekind (gnat_formal) != E_In_Parameter)\n \t   || (Nkind (gnat_actual) == N_Type_Conversion\n \t       && Is_Composite_Type (Underlying_Type (Etype (gnat_formal)))));\n-      Node_Id gnat_name = (unchecked_convert_p\n+      Node_Id gnat_name = (suppress_type_conversion\n \t\t\t   ? Expression (gnat_actual) : gnat_actual);\n       tree gnu_name = gnat_to_gnu (gnat_name);\n       tree gnu_name_type = gnat_to_gnu_type (Etype (gnat_name));\n@@ -2091,7 +2098,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* If it's possible we may need to use this expression twice, make sure\n \t that any side-effects are handled via SAVE_EXPRs.  Likewise if we need\n \t to force side-effects before the call.\n-\n \t ??? This is more conservative than we need since we don't need to do\n \t this for pass-by-ref with no conversion.  */\n       if (Ekind (gnat_formal) != E_In_Parameter)\n@@ -2100,12 +2106,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* If we are passing a non-addressable parameter by reference, pass the\n \t address of a copy.  In the Out or In Out case, set up to copy back\n \t out after the call.  */\n-      if (!addressable_p (gnu_name)\n-\t  && gnu_formal\n+      if (gnu_formal\n \t  && (DECL_BY_REF_P (gnu_formal)\n \t      || (TREE_CODE (gnu_formal) == PARM_DECL\n \t\t  && (DECL_BY_COMPONENT_PTR_P (gnu_formal)\n-\t\t      || (DECL_BY_DESCRIPTOR_P (gnu_formal))))))\n+\t\t      || (DECL_BY_DESCRIPTOR_P (gnu_formal)))))\n+\t  && !addressable_p (gnu_name))\n \t{\n \t  tree gnu_copy = gnu_name, gnu_temp;\n \n@@ -2132,8 +2138,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t     gnat_formal);\n \t    }\n \n-\t  /* Remove any unpadding on the actual and make a copy.  But if\n-\t     the actual is a justified modular type, first convert to it.  */\n+\t  /* Remove any unpadding and make a copy.  But if it's a justified\n+\t     modular type, just convert to it.  */\n \t  if (TREE_CODE (gnu_name) == COMPONENT_REF\n \t      && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_name, 0)))\n \t\t   == RECORD_TYPE)\n@@ -2163,59 +2169,66 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    }\n \t}\n \n+      /* Start from the real object and build the actual.  */\n+      gnu_actual = gnu_name;\n+\n       /* If this was a procedure call, we may not have removed any padding.\n \t So do it here for the part we will use as an input, if any.  */\n-      gnu_actual = gnu_name;\n       if (Ekind (gnat_formal) != E_Out_Parameter\n \t  && TREE_CODE (TREE_TYPE (gnu_actual)) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_actual)))\n \tgnu_actual = convert (get_unpadded_type (Etype (gnat_actual)),\n \t\t\t      gnu_actual);\n \n-      /* Unless this is an In parameter, we must remove any LJM building\n-\t from GNU_NAME.  */\n-      if (Ekind (gnat_formal) != E_In_Parameter\n-\t  && TREE_CODE (gnu_name) == CONSTRUCTOR\n-\t  && TREE_CODE (TREE_TYPE (gnu_name)) == RECORD_TYPE\n-\t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (gnu_name)))\n-\tgnu_name = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_name))),\n-\t\t\t    gnu_name);\n-\n-      if (Ekind (gnat_formal) != E_Out_Parameter\n-\t  && !unchecked_convert_p\n-\t  && Do_Range_Check (gnat_actual))\n-\tgnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal));\n-\n-      /* Do any needed conversions.  We need only check for unchecked\n-\t conversion since normal conversions will be handled by just\n-\t converting to the formal type.  */\n-      if (unchecked_convert_p)\n+      /* Do any needed conversions for the actual and make sure that it is\n+\t in range of the formal's type.  */\n+      if (suppress_type_conversion)\n \t{\n+\t  /* Put back the conversion we suppressed above in the computation\n+\t     of the real object.  Note that we treat a conversion between\n+\t     aggregate types as if it is an unchecked conversion here.  */\n \t  gnu_actual\n \t    = unchecked_convert (gnat_to_gnu_type (Etype (gnat_actual)),\n \t\t\t\t gnu_actual,\n \t\t\t\t (Nkind (gnat_actual)\n \t\t\t\t  == N_Unchecked_Type_Conversion)\n \t\t\t\t && No_Truncation (gnat_actual));\n \n-\t  /* One we've done the unchecked conversion, we still must ensure that\n-\t     the object is in range of the formal's type.  */\n \t  if (Ekind (gnat_formal) != E_Out_Parameter\n \t      && Do_Range_Check (gnat_actual))\n-\t    gnu_actual = emit_range_check (gnu_actual,\n-\t\t\t\t\t   Etype (gnat_formal));\n+\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal));\n+\t}\n+      else\n+\t{\n+\t  if (Ekind (gnat_formal) != E_Out_Parameter\n+\t      && Do_Range_Check (gnat_actual))\n+\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal));\n+\n+\t  /* We may have suppressed a conversion to the Etype of the actual\n+\t     since the parent is a procedure call.  So put it back here.\n+\t     ??? We use the reverse order compared to the case above because\n+\t     of an awkward interaction with the check and actually don't put\n+\t     back the conversion at all if a check is emitted.  This is also\n+\t     done for the conversion to the formal's type just below.  */\n+\t  if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n+\t    gnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n+\t\t\t\t  gnu_actual);\n \t}\n-      else if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n-\t/* We may have suppressed a conversion to the Etype of the actual since\n-\t   the parent is a procedure call.  So add the conversion here.  */\n-\tgnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n-\t\t\t      gnu_actual);\n \n       if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n \tgnu_actual = convert (gnu_formal_type, gnu_actual);\n \n+      /* Unless this is an In parameter, we must remove any justified modular\n+\t building from GNU_NAME to get an lvalue.  */\n+      if (Ekind (gnat_formal) != E_In_Parameter\n+\t  && TREE_CODE (gnu_name) == CONSTRUCTOR\n+\t  && TREE_CODE (TREE_TYPE (gnu_name)) == RECORD_TYPE\n+\t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (gnu_name)))\n+\tgnu_name = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_name))),\n+\t\t\t    gnu_name);\n+\n       /* If we have not saved a GCC object for the formal, it means it is an\n-\t OUT parameter not passed by reference and that does not need to be\n+\t Out parameter not passed by reference and that does not need to be\n \t copied in. Otherwise, look at the PARM_DECL to see if it is passed by\n \t reference. */\n       if (gnu_formal\n@@ -2224,6 +2237,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t{\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n+\t      /* In Out or Out parameters passed by reference don't use the\n+\t\t copy-in copy-out mechanism so the address of the real object\n+\t\t must be passed to the function.  */\n \t      gnu_actual = gnu_name;\n \n \t      /* If we have a padded type, be sure we've removed padding.  */\n@@ -2437,7 +2453,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t       (get_gnu_tree (gnat_formal))))))))\n \t    && Ekind (gnat_formal) != E_In_Parameter)\n \t  {\n-\t    /* Get the value to assign to this OUT or IN OUT parameter.  It is\n+\t    /* Get the value to assign to this Out or In Out parameter.  It is\n \t       either the result of the function if there is only a single such\n \t       parameter or the appropriate field from the record returned.  */\n \t    tree gnu_result\n@@ -2462,9 +2478,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    /* If the actual is a type conversion, the real target object is\n \t       denoted by the inner Expression and we need to convert the\n \t       result to the associated type.\n-\n \t       We also need to convert our gnu assignment target to this type\n-\t       if the corresponding gnu_name was constructed from the GNAT\n+\t       if the corresponding GNU_NAME was constructed from the GNAT\n \t       conversion node and not from the inner Expression.  */\n \t    if (Nkind (gnat_actual) == N_Type_Conversion)\n \t      {\n@@ -2475,15 +2490,13 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t     Do_Range_Check (Expression (gnat_actual)),\n \t\t     Float_Truncate (gnat_actual));\n \n-\t\tif (!Is_Composite_Type\n-\t\t     (Underlying_Type (Etype (gnat_formal))))\n-\t\t  gnu_actual\n-\t\t    = convert (TREE_TYPE (gnu_result), gnu_actual);\n+\t\tif (!Is_Composite_Type (Underlying_Type (Etype (gnat_formal))))\n+\t\t  gnu_actual = convert (TREE_TYPE (gnu_result), gnu_actual);\n \t      }\n \n-\t    /* Unchecked conversions as actuals for out parameters are not\n+\t    /* Unchecked conversions as actuals for Out parameters are not\n \t       allowed in user code because they are not variables, but do\n-\t       occur in front-end expansions.  The associated gnu_name is\n+\t       occur in front-end expansions.  The associated GNU_NAME is\n \t       always obtained from the inner expression in such cases.  */\n \t    else if (Nkind (gnat_actual) == N_Unchecked_Type_Conversion)\n \t      gnu_result = unchecked_convert (TREE_TYPE (gnu_actual),\n@@ -6092,11 +6105,13 @@ addressable_p (tree gnu_expr)\n \ttree inner_type = TREE_TYPE (TREE_OPERAND (gnu_expr, 0));\n \n \treturn (((TYPE_MODE (type) == TYPE_MODE (inner_type)\n-\t\t  && (TYPE_ALIGN (type) <= TYPE_ALIGN (inner_type)\n+\t\t  && (!STRICT_ALIGNMENT\n+\t\t      || TYPE_ALIGN (type) <= TYPE_ALIGN (inner_type)\n \t\t      || TYPE_ALIGN (inner_type) >= BIGGEST_ALIGNMENT))\n \t\t || ((TYPE_MODE (type) == BLKmode\n \t\t      || TYPE_MODE (inner_type) == BLKmode)\n-\t\t     && (TYPE_ALIGN (type) <= TYPE_ALIGN (inner_type)\n+\t\t     && (!STRICT_ALIGNMENT\n+\t\t\t || TYPE_ALIGN (type) <= TYPE_ALIGN (inner_type)\n \t\t\t || TYPE_ALIGN (inner_type) >= BIGGEST_ALIGNMENT\n \t\t\t || TYPE_ALIGN_OK (type)\n \t\t\t || TYPE_ALIGN_OK (inner_type))))"}, {"sha": "1c975416b5fb0e5e8fdfcf27654cc0d111eb3edb", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1683,7 +1683,7 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n \f\n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n    PARAM_TYPE is its type.  READONLY is true if the parameter is\n-   readonly (either an IN parameter or an address of a pass-by-ref\n+   readonly (either an In parameter or an address of a pass-by-ref\n    parameter). */\n \n tree"}, {"sha": "eec7ddc0e44fcf02275e4177dbf0058bbe7cdf5f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "patch": "@@ -1,3 +1,7 @@\n+2008-01-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/unchecked_convert1.adb.\n+\n 2008-01-13  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/struct-ret-3.c: Adjust testcase to make stack"}, {"sha": "eb63d59a884d47e5ab3c5061ff0ca0eb67be8f4b", "filename": "gcc/testsuite/gnat.dg/unchecked_convert1.adb", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ffbdad7e2ea994a27156bf3315c2bd8f4a9876/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert1.adb?ref=08ffbdad7e2ea994a27156bf3315c2bd8f4a9876", "patch": "@@ -0,0 +1,32 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+\n+with Ada.Unchecked_Conversion;\n+\n+procedure Unchecked_Convert1 is\n+  type Byte is mod 2**8;\n+\n+  type Stream is array (Natural range <>) of Byte;\n+\n+  type Rec is record\n+    I1, I2 : Integer;\n+  end record;\n+\n+  function Do_Sum (R : Rec) return Integer is\n+  begin\n+    return R.I1 + R.I2;\n+  end;\n+\n+  function Sum (S : Stream) return Integer is\n+    subtype Chunk is Stream (1 .. Rec'Size / 8);\n+    function To_Chunk is new Ada.Unchecked_Conversion (Chunk, Rec);\n+  begin\n+    return Do_Sum (To_Chunk (S(S'First ..  S'First + Rec'Size / 8 - 1)));\n+  end;\n+\n+  A : Stream (1..9);\n+  I : Integer;\n+\n+begin\n+  I := Sum (A(1..8));\n+end;"}]}