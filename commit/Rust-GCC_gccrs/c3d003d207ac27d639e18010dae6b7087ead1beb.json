{"sha": "c3d003d207ac27d639e18010dae6b7087ead1beb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNkMDAzZDIwN2FjMjdkNjM5ZTE4MDEwZGFlNmI3MDg3ZWFkMWJlYg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2004-12-12T21:09:09Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-12-12T21:09:09Z"}, "message": "re PR fortran/16581 (gfortran F90 bit intrinsics don't work with integer*{1,2,8})\n\n2004-12-12  Steven G. Kargl  <kargls@comcast.net>\n\n\tPR fortran/16581\n\t* check.c (gfc_check_iand, gfc_check_ibclr, gfc_check_ibits,\n\tgfc_check_ibset, gfc_check_ieor, gfc_check_ior): Remove default\n\tinteger kind check; Issue error for -std=f95 when needed.\n\t* intrinsic.c (add_functions): Change ieor from GFC_STD_GNU to\n\tGFC_STD_F95.\n\t* iresolve.c (gfc_resolve_iand, gfc_resolve_ieor, gfc_resolve_ior):\n\tPromote arguments to same kind.\n\nFrom-SVN: r92063", "tree": {"sha": "45e9b6e52d2737fdf74257a64276a9514252ce15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45e9b6e52d2737fdf74257a64276a9514252ce15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3d003d207ac27d639e18010dae6b7087ead1beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d003d207ac27d639e18010dae6b7087ead1beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3d003d207ac27d639e18010dae6b7087ead1beb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d003d207ac27d639e18010dae6b7087ead1beb/comments", "author": null, "committer": null, "parents": [{"sha": "0736fd563fa409b16f4cf1c3a7e4c42051f8c6dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0736fd563fa409b16f4cf1c3a7e4c42051f8c6dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0736fd563fa409b16f4cf1c3a7e4c42051f8c6dc"}], "stats": {"total": 114, "additions": 88, "deletions": 26}, "files": [{"sha": "7c63b51b5c144999fb69def6b34dde7877ec1d7c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c3d003d207ac27d639e18010dae6b7087ead1beb", "patch": "@@ -1,3 +1,14 @@\n+2004-12-12  Steven G. Kargl  <kargls@comcast.net>\n+\n+\tPR fortran/16581\n+\t* check.c (gfc_check_iand, gfc_check_ibclr, gfc_check_ibits,\n+\tgfc_check_ibset, gfc_check_ieor, gfc_check_ior): Remove default\n+\tinteger kind check; Issue error for -std=f95 when needed.\n+\t* intrinsic.c (add_functions): Change ieor from GFC_STD_GNU to\n+\tGFC_STD_F95.\n+\t* iresolve.c (gfc_resolve_iand, gfc_resolve_ieor, gfc_resolve_ior):\n+\tPromote arguments to same kind.\n+\n 2004-12-12  Steven G. Kargl  <kargls@comcast.net>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "3d67b1c4d1a5107d9f01cbeda8f6570527081bd3", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=c3d003d207ac27d639e18010dae6b7087ead1beb", "patch": "@@ -809,13 +809,19 @@ try\n gfc_check_iand (gfc_expr * i, gfc_expr * j)\n {\n \n-  if (type_check (i, 0, BT_INTEGER) == FAILURE\n-      || type_check (j, 1, BT_INTEGER) == FAILURE)\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (same_type_check (i, 0, j, 1) == FAILURE)\n+  if (type_check (j, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n+                          &i->where) == FAILURE)\n+\treturn FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -824,9 +830,10 @@ try\n gfc_check_ibclr (gfc_expr * i, gfc_expr * pos)\n {\n \n-  if (type_check (i, 0, BT_INTEGER) == FAILURE\n-      || type_check (pos, 1, BT_INTEGER) == FAILURE\n-      || kind_value_check (pos, 1, gfc_default_integer_kind) == FAILURE)\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (pos, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -837,10 +844,13 @@ try\n gfc_check_ibits (gfc_expr * i, gfc_expr * pos, gfc_expr * len)\n {\n \n-  if (type_check (i, 0, BT_INTEGER) == FAILURE\n-      || type_check (pos, 1, BT_INTEGER) == FAILURE\n-      || kind_value_check (pos, 1, gfc_default_integer_kind) == FAILURE\n-      || type_check (len, 2, BT_INTEGER) == FAILURE)\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (pos, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (len, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -851,9 +861,10 @@ try\n gfc_check_ibset (gfc_expr * i, gfc_expr * pos)\n {\n \n-  if (type_check (i, 0, BT_INTEGER) == FAILURE\n-      || type_check (pos, 1, BT_INTEGER) == FAILURE\n-      || kind_value_check (pos, 1, gfc_default_integer_kind) == FAILURE)\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (pos, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -875,13 +886,19 @@ try\n gfc_check_ieor (gfc_expr * i, gfc_expr * j)\n {\n \n-  if (type_check (i, 0, BT_INTEGER) == FAILURE\n-      || type_check (j, 1, BT_INTEGER) == FAILURE)\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (same_type_check (i, 0, j, 1) == FAILURE)\n+  if (type_check (j, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n+                          &i->where) == FAILURE)\n+\treturn FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -924,13 +941,19 @@ try\n gfc_check_ior (gfc_expr * i, gfc_expr * j)\n {\n \n-  if (type_check (i, 0, BT_INTEGER) == FAILURE\n-      || type_check (j, 1, BT_INTEGER) == FAILURE)\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (same_type_check (i, 0, j, 1) == FAILURE)\n+  if (type_check (j, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n+                          &i->where) == FAILURE)\n+    return FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n "}, {"sha": "2aa3f294ac8507af988392b32e45676ec1fc5a73", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=c3d003d207ac27d639e18010dae6b7087ead1beb", "patch": "@@ -1375,11 +1375,11 @@ add_functions (void)\n \n   make_generic (\"ichar\", GFC_ISYM_ICHAR, GFC_STD_F77);\n \n-  add_sym_2 (\"ieor\", 1, 1, BT_INTEGER, di, GFC_STD_GNU,\n+  add_sym_2 (\"ieor\", 1, 1, BT_INTEGER, di, GFC_STD_F95,\n \t     gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,\n \t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n \n-  make_generic (\"ieor\", GFC_ISYM_IEOR, GFC_STD_GNU);\n+  make_generic (\"ieor\", GFC_ISYM_IEOR, GFC_STD_F95);\n \n   add_sym_3 (\"index\", 1, 1, BT_INTEGER, di, GFC_STD_F77,\n \t     gfc_check_index, gfc_simplify_index, NULL,"}, {"sha": "d942fdd36d409e56694be81964b1f0f57b567e82", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d003d207ac27d639e18010dae6b7087ead1beb/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=c3d003d207ac27d639e18010dae6b7087ead1beb", "patch": "@@ -619,8 +619,18 @@ gfc_resolve_getuid (gfc_expr * f)\n }\n \n void\n-gfc_resolve_iand (gfc_expr * f, gfc_expr * i, gfc_expr * j ATTRIBUTE_UNUSED)\n+gfc_resolve_iand (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n {\n+  /* If the kind of i and j are different, then g77 cross-promoted the\n+     kinds to the largest value.  The Fortran 95 standard requires the \n+     kinds to match.  */\n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (i->ts.kind == gfc_kind_max (i,j))\n+\tgfc_convert_type(j, &i->ts, 2);\n+      else\n+\tgfc_convert_type(i, &j->ts, 2);\n+    }\n \n   f->ts = i->ts;\n   f->value.function.name = gfc_get_string (\"__iand_%d\", i->ts.kind);\n@@ -676,19 +686,37 @@ gfc_resolve_idnint (gfc_expr * f, gfc_expr * a)\n \n \n void\n-gfc_resolve_ieor (gfc_expr * f, gfc_expr * i,\n-\t\t  gfc_expr * j ATTRIBUTE_UNUSED)\n+gfc_resolve_ieor (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n {\n+  /* If the kind of i and j are different, then g77 cross-promoted the\n+     kinds to the largest value.  The Fortran 95 standard requires the \n+     kinds to match.  */\n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (i->ts.kind == gfc_kind_max (i,j))\n+\tgfc_convert_type(j, &i->ts, 2);\n+      else\n+\tgfc_convert_type(i, &j->ts, 2);\n+    }\n \n   f->ts = i->ts;\n   f->value.function.name = gfc_get_string (\"__ieor_%d\", i->ts.kind);\n }\n \n \n void\n-gfc_resolve_ior (gfc_expr * f, gfc_expr * i,\n-\t\t gfc_expr * j ATTRIBUTE_UNUSED)\n+gfc_resolve_ior (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n {\n+  /* If the kind of i and j are different, then g77 cross-promoted the\n+     kinds to the largest value.  The Fortran 95 standard requires the \n+     kinds to match.  */\n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (i->ts.kind == gfc_kind_max (i,j))\n+\tgfc_convert_type(j, &i->ts, 2);\n+      else\n+\tgfc_convert_type(i, &j->ts, 2);\n+    }\n \n   f->ts = i->ts;\n   f->value.function.name = gfc_get_string (\"__ior_%d\", i->ts.kind);"}]}