{"sha": "c0f11672d760513256997f325da678016d13f677", "node_id": "C_kwDOANBUbNoAKGMwZjExNjcyZDc2MDUxMzI1Njk5N2YzMjVkYTY3ODAxNmQxM2Y2Nzc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-06-17T16:11:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-17T16:11:19Z"}, "message": "Merge #1317\n\n1317: AST for const generic arguments/const application r=CohenArthur a=CohenArthur\n\nThis commit adds a new type to the AST which contains const generic\r\narguments. The `GenericArgs` structure now also keeps a vector of them,\r\nand the parser was modified accordingly. We need to handle these extra\r\narguments in the various resolvers and type-checking phase.\r\n\r\nAs pointed out before, const generic arguments are ambiguous at the AST\r\nlevel. Which is why this \"sum type\" contains a \"Clear\" variant when\r\nthere is no ambiguity at all (`<5>`, `<{ 5 }>`, `<{ 5 + 15 }>` or\r\n`<{ N }>`) and an \"Ambiguous\" one if the value in question might be\r\nreferring to a type argument (`<N>`) instead of a const generic\r\nargument.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "ec8da7465f391924e34855f3f2ae812e6ad811e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec8da7465f391924e34855f3f2ae812e6ad811e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0f11672d760513256997f325da678016d13f677", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJirKenCRBK7hj4Ov3rIwAApdYIAFCCBsuZ1obzI3xrJK1Pz364\nyhpC6hxN3xCmA8eg+qjBHQMl/wmujLEKVJIb5Vb8sluECVyJNSuUsVrZosNH0vvr\n1smXCsqmFe1StyjDgtj1+bUQG3W06c0kWt77r+5frqUjM5aMdUiKPeVacypLWUQ2\nMMAjrl3bJGbht7jbZ9QyHc58FeTxfjhp6H39i75H98Li428dM+0bc6OP+Uc/3HYJ\nu946kpf9yjopo8z8h1ZPyiSNRLXWdHEnKqW0jv4SUrO7EuzfG0DIv8ENz1E29Mg1\nj1l811c2LNDQvat8RGE4utKVq4Z+ZuR1WVhts+H0CKWHvkt56VqEYkYeVHaML+4=\n=/jCE\n-----END PGP SIGNATURE-----\n", "payload": "tree ec8da7465f391924e34855f3f2ae812e6ad811e3\nparent b711799e3eb450463a9f3be3b082b3ced9356358\nparent 5f3c8286b225f3c87bed920f3c3e003a90d98722\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1655482279 +0000\ncommitter GitHub <noreply@github.com> 1655482279 +0000\n\nMerge #1317\n\n1317: AST for const generic arguments/const application r=CohenArthur a=CohenArthur\n\nThis commit adds a new type to the AST which contains const generic\r\narguments. The `GenericArgs` structure now also keeps a vector of them,\r\nand the parser was modified accordingly. We need to handle these extra\r\narguments in the various resolvers and type-checking phase.\r\n\r\nAs pointed out before, const generic arguments are ambiguous at the AST\r\nlevel. Which is why this \"sum type\" contains a \"Clear\" variant when\r\nthere is no ambiguity at all (`<5>`, `<{ 5 }>`, `<{ 5 + 15 }>` or\r\n`<{ N }>`) and an \"Ambiguous\" one if the value in question might be\r\nreferring to a type argument (`<N>`) instead of a const generic\r\nargument.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0f11672d760513256997f325da678016d13f677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0f11672d760513256997f325da678016d13f677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0f11672d760513256997f325da678016d13f677/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b711799e3eb450463a9f3be3b082b3ced9356358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b711799e3eb450463a9f3be3b082b3ced9356358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b711799e3eb450463a9f3be3b082b3ced9356358"}, {"sha": "5f3c8286b225f3c87bed920f3c3e003a90d98722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3c8286b225f3c87bed920f3c3e003a90d98722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f3c8286b225f3c87bed920f3c3e003a90d98722"}], "stats": {"total": 278, "additions": 205, "deletions": 73}, "files": [{"sha": "7f66ee45f6dde747600845e5b21a3440fff414a7", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=c0f11672d760513256997f325da678016d13f677", "patch": "@@ -2609,6 +2609,20 @@ GenericArgs::as_string () const\n \t}\n     }\n \n+  // const args\n+  if (!const_args.empty ())\n+    {\n+      auto i = const_args.begin ();\n+      auto e = const_args.end ();\n+\n+      for (; i != e; i++)\n+\t{\n+\t  args += i->as_string ();\n+\t  if (e != i + 1)\n+\t    args += \", \";\n+\t}\n+    }\n+\n   // binding args\n   if (!binding_args.empty ())\n     {"}, {"sha": "5642226afcec8898bb869883180c6f10f89d7b77", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 156, "deletions": 49, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=c0f11672d760513256997f325da678016d13f677", "patch": "@@ -22,6 +22,7 @@\n  * for virtually all AST-related functionality. */\n \n #include \"rust-ast.h\"\n+#include \"system.h\"\n \n namespace Rust {\n namespace AST {\n@@ -128,37 +129,137 @@ struct GenericArgsBinding\n   Identifier get_identifier () const { return identifier; }\n };\n \n+/* Class representing a const generic application */\n+class ConstGenericArg\n+{\n+public:\n+  /**\n+   * const generic arguments cannot always be differentiated with generic type\n+   * arguments during parsing, e.g:\n+   * ```rust\n+   * let a: Foo<N>;\n+   * ```\n+   *\n+   * Is N a type? A constant defined elsewhere? The parser cannot know, and must\n+   * not draw any conclusions. We must wait until later passes of the compiler\n+   * to decide whether this refers to a constant item or a type.\n+   *\n+   * On the other hand, simple expressions like literals or block expressions\n+   * will always be constant expressions: There is no ambiguity at all.\n+   */\n+  enum class Kind\n+  {\n+    Error,\n+    Clear,\n+    Ambiguous,\n+  };\n+\n+  static ConstGenericArg create_error ()\n+  {\n+    return ConstGenericArg (nullptr, \"\", Kind::Error);\n+  }\n+\n+  ConstGenericArg (std::unique_ptr<Expr> expression)\n+    : expression (std::move (expression)), path (\"\"), kind (Kind::Clear)\n+  {}\n+\n+  ConstGenericArg (Identifier path)\n+    : expression (nullptr), path (path), kind (Kind::Ambiguous)\n+  {}\n+\n+  ConstGenericArg (const ConstGenericArg &other)\n+    : path (other.path), kind (other.kind)\n+  {\n+    if (other.expression)\n+      expression = other.expression->clone_expr ();\n+  }\n+\n+  ConstGenericArg operator= (const ConstGenericArg &other)\n+  {\n+    kind = other.kind;\n+    path = other.path;\n+\n+    if (other.expression)\n+      expression = other.expression->clone_expr ();\n+\n+    return *this;\n+  }\n+\n+  bool is_error () const { return kind == Kind::Error; }\n+\n+  Kind get_kind () const { return kind; }\n+\n+  std::string as_string () const\n+  {\n+    switch (get_kind ())\n+      {\n+      case Kind::Error:\n+\tgcc_unreachable ();\n+      case Kind::Ambiguous:\n+\treturn \"Ambiguous: \" + path;\n+      case Kind::Clear:\n+\treturn \"Clear: { \" + expression->as_string () + \" }\";\n+      }\n+\n+    return \"\";\n+  }\n+\n+private:\n+  ConstGenericArg (std::unique_ptr<AST::Expr> expression, Identifier path,\n+\t\t   Kind kind)\n+    : expression (std::move (expression)), path (std::move (path)), kind (kind)\n+  {}\n+\n+  /**\n+   * Expression associated with a `Clear` const generic application\n+   * A null pointer here is allowed in the case that the const argument is\n+   * ambiguous.\n+   */\n+  std::unique_ptr<Expr> expression;\n+\n+  /**\n+   * Optional path which cannot be differentiated between a constant item and\n+   * a type. Only used for `Ambiguous` const generic arguments, otherwise\n+   * empty.\n+   */\n+  Identifier path;\n+\n+  /* Which kind of const generic application are we dealing with */\n+  Kind kind;\n+};\n+\n // Generic arguments allowed in each path expression segment - inline?\n struct GenericArgs\n {\n   std::vector<Lifetime> lifetime_args;\n   std::vector<std::unique_ptr<Type> > type_args;\n   std::vector<GenericArgsBinding> binding_args;\n-  // TODO: Handle const generics here as well.\n-  // We can probably keep a vector of `Expr`s for this.\n+  std::vector<ConstGenericArg> const_args;\n   Location locus;\n \n public:\n   // Returns true if there are any generic arguments\n   bool has_generic_args () const\n   {\n     return !(lifetime_args.empty () && type_args.empty ()\n-\t     && binding_args.empty ());\n+\t     && binding_args.empty () && const_args.empty ());\n   }\n \n   GenericArgs (std::vector<Lifetime> lifetime_args,\n \t       std::vector<std::unique_ptr<Type> > type_args,\n \t       std::vector<GenericArgsBinding> binding_args,\n+\t       std::vector<ConstGenericArg> const_args,\n \t       Location locus = Location ())\n     : lifetime_args (std::move (lifetime_args)),\n       type_args (std::move (type_args)),\n-      binding_args (std::move (binding_args)), locus (locus)\n+      binding_args (std::move (binding_args)),\n+      const_args (std::move (const_args)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   GenericArgs (GenericArgs const &other)\n     : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n-      locus (other.locus)\n+      const_args (other.const_args), locus (other.locus)\n   {\n     type_args.reserve (other.type_args.size ());\n     for (const auto &e : other.type_args)\n@@ -172,6 +273,7 @@ struct GenericArgs\n   {\n     lifetime_args = other.lifetime_args;\n     binding_args = other.binding_args;\n+    const_args = other.const_args;\n     locus = other.locus;\n \n     type_args.reserve (other.type_args.size ());\n@@ -190,7 +292,8 @@ struct GenericArgs\n   {\n     return GenericArgs (std::vector<Lifetime> (),\n \t\t\tstd::vector<std::unique_ptr<Type> > (),\n-\t\t\tstd::vector<GenericArgsBinding> ());\n+\t\t\tstd::vector<GenericArgsBinding> (),\n+\t\t\tstd::vector<ConstGenericArg> ());\n   }\n \n   std::string as_string () const;\n@@ -203,6 +306,8 @@ struct GenericArgs\n \n   std::vector<Lifetime> &get_lifetime_args () { return lifetime_args; };\n \n+  std::vector<ConstGenericArg> &get_const_args () { return const_args; };\n+\n   Location get_locus () { return locus; }\n };\n \n@@ -231,16 +336,14 @@ class PathExprSegment\n   /* Constructor for segment with generic arguments (from segment name and all\n    * args) */\n   PathExprSegment (std::string segment_name, Location locus,\n-\t\t   std::vector<Lifetime> lifetime_args\n-\t\t   = std::vector<Lifetime> (),\n-\t\t   std::vector<std::unique_ptr<Type> > type_args\n-\t\t   = std::vector<std::unique_ptr<Type> > (),\n-\t\t   std::vector<GenericArgsBinding> binding_args\n-\t\t   = std::vector<GenericArgsBinding> ())\n+\t\t   std::vector<Lifetime> lifetime_args = {},\n+\t\t   std::vector<std::unique_ptr<Type> > type_args = {},\n+\t\t   std::vector<GenericArgsBinding> binding_args = {},\n+\t\t   std::vector<ConstGenericArg> const_args = {})\n     : segment_name (PathIdentSegment (std::move (segment_name), locus)),\n-      generic_args (GenericArgs (std::move (lifetime_args),\n-\t\t\t\t std::move (type_args),\n-\t\t\t\t std::move (binding_args))),\n+      generic_args (\n+\tGenericArgs (std::move (lifetime_args), std::move (type_args),\n+\t\t     std::move (binding_args), std::move (const_args))),\n       locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n@@ -284,7 +387,8 @@ class PathExprSegment\n   }\n };\n \n-// AST node representing a pattern that involves a \"path\" - abstract base class\n+// AST node representing a pattern that involves a \"path\" - abstract base\n+// class\n class PathPattern : public Pattern\n {\n   std::vector<PathExprSegment> segments;\n@@ -297,8 +401,8 @@ class PathPattern : public Pattern\n   // Returns whether path has segments.\n   bool has_segments () const { return !segments.empty (); }\n \n-  /* Converts path segments to their equivalent SimplePath segments if possible,\n-   * and creates a SimplePath from them. */\n+  /* Converts path segments to their equivalent SimplePath segments if\n+   * possible, and creates a SimplePath from them. */\n   SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n \n   // Removes all segments of the path.\n@@ -320,8 +424,8 @@ class PathPattern : public Pattern\n   const std::vector<PathExprSegment> &get_segments () const { return segments; }\n };\n \n-/* AST node representing a path-in-expression pattern (path that allows generic\n- * arguments) */\n+/* AST node representing a path-in-expression pattern (path that allows\n+ * generic arguments) */\n class PathInExpression : public PathPattern, public PathExpr\n {\n   std::vector<Attribute> outer_attrs;\n@@ -356,9 +460,10 @@ class PathInExpression : public PathPattern, public PathExpr\n   SimplePath as_simple_path () const\n   {\n     /* delegate to parent class as can't access segments. however,\n-     * QualifiedPathInExpression conversion to simple path wouldn't make sense,\n-     * so the method in the parent class should be protected, not public. Have\n-     * to pass in opening scope resolution as parent class has no access to it.\n+     * QualifiedPathInExpression conversion to simple path wouldn't make\n+     * sense, so the method in the parent class should be protected, not\n+     * public. Have to pass in opening scope resolution as parent class has no\n+     * access to it.\n      */\n     return convert_to_simple_path (has_opening_scope_resolution);\n   }\n@@ -389,15 +494,15 @@ class PathInExpression : public PathPattern, public PathExpr\n   NodeId get_pattern_node_id () const override final { return get_node_id (); }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n   PathInExpression *clone_pattern_impl () const final override\n   {\n     return clone_path_in_expression_impl ();\n   }\n \n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n   PathInExpression *clone_expr_without_block_impl () const final override\n   {\n     return clone_path_in_expression_impl ();\n@@ -431,7 +536,8 @@ class TypePathSegment\n   bool has_separating_scope_resolution;\n   NodeId node_id;\n \n-  // Clone function implementation - not pure virtual as overrided by subclasses\n+  // Clone function implementation - not pure virtual as overrided by\n+  // subclasses\n   virtual TypePathSegment *clone_type_path_segment_impl () const\n   {\n     return new TypePathSegment (*this);\n@@ -465,8 +571,8 @@ class TypePathSegment\n \n   virtual std::string as_string () const { return ident_segment.as_string (); }\n \n-  /* Returns whether the type path segment is in an error state. May be virtual\n-   * in future. */\n+  /* Returns whether the type path segment is in an error state. May be\n+   * virtual in future. */\n   bool is_error () const { return ident_segment.is_error (); }\n \n   /* Returns whether segment is identifier only (as opposed to generic args or\n@@ -526,12 +632,13 @@ class TypePathSegmentGeneric : public TypePathSegment\n \t\t\t  std::vector<Lifetime> lifetime_args,\n \t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n \t\t\t  std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  std::vector<ConstGenericArg> const_args,\n \t\t\t  Location locus)\n     : TypePathSegment (std::move (segment_name),\n \t\t       has_separating_scope_resolution, locus),\n-      generic_args (GenericArgs (std::move (lifetime_args),\n-\t\t\t\t std::move (type_args),\n-\t\t\t\t std::move (binding_args)))\n+      generic_args (\n+\tGenericArgs (std::move (lifetime_args), std::move (type_args),\n+\t\t     std::move (binding_args), std::move (const_args)))\n   {}\n \n   std::string as_string () const override;\n@@ -709,16 +816,16 @@ class TypePath : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n   TypePath *clone_type_no_bounds_impl () const override\n   {\n     return new TypePath (*this);\n   }\n \n public:\n-  /* Returns whether the TypePath has an opening scope resolution operator (i.e.\n-   * is global path or crate-relative path, not module-relative) */\n+  /* Returns whether the TypePath has an opening scope resolution operator\n+   * (i.e. is global path or crate-relative path, not module-relative) */\n   bool has_opening_scope_resolution_op () const\n   {\n     return has_opening_scope_resolution;\n@@ -900,8 +1007,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n       _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n-  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n-   * as params */\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType\n+   * elements as params */\n \n   // Returns whether qualified path in expression is in an error state.\n   bool is_error () const { return path_type.is_error (); }\n@@ -944,15 +1051,15 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   NodeId get_pattern_node_id () const override final { return get_node_id (); }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n   QualifiedPathInExpression *clone_pattern_impl () const final override\n   {\n     return clone_qual_path_in_expression_impl ();\n   }\n \n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n   QualifiedPathInExpression *\n   clone_expr_without_block_impl () const final override\n   {\n@@ -966,8 +1073,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   }\n };\n \n-/* Represents a qualified path in a type; used for disambiguating trait function\n- * calls */\n+/* Represents a qualified path in a type; used for disambiguating trait\n+ * function calls */\n class QualifiedPathInType : public TypeNoBounds\n {\n   QualifiedPathType path_type;\n@@ -976,8 +1083,8 @@ class QualifiedPathInType : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n   QualifiedPathInType *clone_type_no_bounds_impl () const override\n   {\n     return new QualifiedPathInType (*this);\n@@ -994,8 +1101,8 @@ class QualifiedPathInType : public TypeNoBounds\n       segments (std::move (path_segments)), locus (locus)\n   {}\n \n-  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n-   * as params */\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType\n+   * elements as params */\n \n   // Copy constructor with vector clone\n   QualifiedPathInType (QualifiedPathInType const &other)"}, {"sha": "c2efd535ade1895cb58d9f3eea10acfc48235d08", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=c0f11672d760513256997f325da678016d13f677", "patch": "@@ -2878,25 +2878,28 @@ Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n \t  return nullptr;\n \n \t// optional default value\n-\tstd::unique_ptr<AST::Expr> default_expr = nullptr;\n+\tauto default_expr = AST::ConstGenericArg::create_error ();\n \tif (lexer.peek_token ()->get_id () == EQUAL)\n \t  {\n \t    lexer.skip_token ();\n \t    auto tok = lexer.peek_token ();\n \t    default_expr = parse_const_generic_expression ();\n \n-\t    if (!default_expr)\n+\t    if (default_expr.is_error ())\n \t      rust_error_at (tok->get_locus (),\n \t\t\t     \"invalid token for start of default value for \"\n \t\t\t     \"const generic parameter: expected %<block%>, \"\n \t\t\t     \"%<identifier%> or %<literal%>, got %qs\",\n \t\t\t     token_id_to_str (tok->get_id ()));\n+\n+\t    // TODO: At this point, we *know* that we are parsing a const\n+\t    // expression. We should figure out how to disambiguate the default\n+\t    // expr in the case of `const N: usize = M`\n \t  }\n \n \tparam = std::unique_ptr<AST::ConstGenericParam> (\n \t  new AST::ConstGenericParam (name_token->get_str (), std::move (type),\n-\t\t\t\t      std::move (default_expr),\n-\t\t\t\t      std::move (outer_attrs),\n+\t\t\t\t      nullptr, std::move (outer_attrs),\n \t\t\t\t      token->get_locus ()));\n \n \tbreak;\n@@ -6162,36 +6165,43 @@ Parser<ManagedTokenSource>::parse_type_path ()\n }\n \n template <typename ManagedTokenSource>\n-std::unique_ptr<AST::Expr>\n+AST::ConstGenericArg\n Parser<ManagedTokenSource>::parse_const_generic_expression ()\n {\n   auto tok = lexer.peek_token ();\n+  std::unique_ptr<AST::Expr> expr = nullptr;\n+\n   switch (tok->get_id ())\n     {\n-    case LEFT_CURLY:\n-      return parse_block_expr ();\n-      case IDENTIFIER: {\n-\tlexer.skip_token ();\n+    case IDENTIFIER:\n+      lexer.skip_token ();\n \n-\t// TODO: This is ambiguous with regular generic types. We probably need\n-\t// to differentiate later on during type checking, and thus keep a\n-\t// special variant here\n+      // TODO: This is ambiguous with regular generic types. We probably need\n+      // to differentiate later on during type checking, and thus keep a\n+      // special variant here\n \n-\t// return this\n-\treturn std::unique_ptr<AST::IdentifierExpr> (\n-\t  new AST::IdentifierExpr (tok->get_str (), {}, tok->get_locus ()));\n-      }\n+      // FIXME: We need locus here as well\n+      return AST::ConstGenericArg (tok->get_str ());\n+    case LEFT_CURLY:\n+      expr = parse_block_expr ();\n+      break;\n     case MINUS:\n     case STRING_LITERAL:\n     case CHAR_LITERAL:\n     case INT_LITERAL:\n     case FLOAT_LITERAL:\n     case TRUE_LITERAL:\n     case FALSE_LITERAL:\n-      return parse_literal_expr ();\n+      expr = parse_literal_expr ();\n+      break;\n     default:\n-      return nullptr;\n+      expr = nullptr;\n     }\n+\n+  if (!expr)\n+    return AST::ConstGenericArg::create_error ();\n+\n+  return AST::ConstGenericArg (std::move (expr));\n }\n \n // Parses the generic arguments in each path segment.\n@@ -6237,7 +6247,7 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n \n   // try to parse types second\n   std::vector<std::unique_ptr<AST::Type>> type_args;\n-  std::vector<std::unique_ptr<AST::Expr>> const_args;\n+  std::vector<AST::ConstGenericArg> const_args;\n \n   // TODO: Keep list of const expressions as well\n \n@@ -6261,10 +6271,10 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n       else\n \t{\n \t  auto const_generic_expr = parse_const_generic_expression ();\n-\t  if (const_generic_expr)\n-\t    const_args.emplace_back (std::move (const_generic_expr));\n-\t  else\n+\t  if (const_generic_expr.is_error ())\n \t    break;\n+\t  else\n+\t    const_args.emplace_back (std::move (const_generic_expr));\n \t}\n \n       // if next token isn't comma, then it must be end of list\n@@ -6315,7 +6325,8 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n   binding_args.shrink_to_fit ();\n \n   return AST::GenericArgs (std::move (lifetime_args), std::move (type_args),\n-\t\t\t   std::move (binding_args), locus);\n+\t\t\t   std::move (binding_args), std::move (const_args),\n+\t\t\t   locus);\n }\n \n // Parses a binding in a generic args path segment."}, {"sha": "fa88f8eff9d6d3ca28c2ea5096e4a9c655c73199", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0f11672d760513256997f325da678016d13f677/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=c0f11672d760513256997f325da678016d13f677", "patch": "@@ -177,7 +177,7 @@ template <typename ManagedTokenSource> class Parser\n   AST::TypePath parse_type_path ();\n   std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n   AST::PathIdentSegment parse_path_ident_segment ();\n-  std::unique_ptr<AST::Expr> parse_const_generic_expression ();\n+  AST::ConstGenericArg parse_const_generic_expression ();\n   AST::GenericArgs parse_path_generic_args ();\n   AST::GenericArgsBinding parse_generic_args_binding ();\n   AST::TypePathFunction parse_type_path_function (Location locus);"}]}