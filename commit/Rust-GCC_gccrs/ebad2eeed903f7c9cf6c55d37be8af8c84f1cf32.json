{"sha": "ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJhZDJlZWVkOTAzZjdjOWNmNmM1NWQzN2JlOGFmOGM4NGYxY2YzMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-10-23T18:22:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-23T18:22:40Z"}, "message": "lto-streamer-out.c (output_constructor): Push CTORS_OUT timevar.\n\n\t* lto-streamer-out.c (output_constructor): Push CTORS_OUT timevar.\n\t(cmp_symbol_files): New.\n\t(lto_output): Copy sections in file order.\n\t* lto-streamer.h (lto_file_decl_data): Add field order.\n\t* lto-common.c (lto_file_finalize): Add order attribute.\n\t(lto_create_files_from_ids): Pass order.\n\t(lto_file_read): UPdate call of lto_create_files_from_ids.\n\nFrom-SVN: r277346", "tree": {"sha": "4ce050da6801082f8214d6b6769954c0aa7d48a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ce050da6801082f8214d6b6769954c0aa7d48a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/comments", "author": null, "committer": null, "parents": [{"sha": "b5b6485f1cc54f21713b5b03c5d63d56839ca458", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b6485f1cc54f21713b5b03c5d63d56839ca458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5b6485f1cc54f21713b5b03c5d63d56839ca458"}], "stats": {"total": 136, "additions": 91, "deletions": 45}, "files": [{"sha": "d68bc8a5524bd5179ac54f6e69ac95d540a902d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "patch": "@@ -1,3 +1,10 @@\n+2019-10-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-streamer-out.c (output_constructor): Push CTORS_OUT timevar.\n+\t(cmp_symbol_files): New.\n+\t(lto_output): Copy sections in file order.\n+\t* lto-streamer.h (lto_file_decl_data): Add field order.\n+\n 2019-10-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-reference.h (ipa_reference_var_uid): Move offline."}, {"sha": "2c712926f32a5db8a67e16497a15dafc201dcbb8", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 68, "deletions": 41, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "patch": "@@ -2228,6 +2228,7 @@ output_constructor (struct varpool_node *node)\n     fprintf (streamer_dump_file, \"\\nStreaming constructor of %s\\n\",\n \t     node->name ());\n \n+  timevar_push (TV_IPA_LTO_CTORS_OUT);\n   ob = create_output_block (LTO_section_function_body);\n \n   clear_line_info (ob);\n@@ -2247,6 +2248,7 @@ output_constructor (struct varpool_node *node)\n   if (streamer_dump_file)\n     fprintf (streamer_dump_file, \"Finished streaming %s\\n\",\n \t     node->name ());\n+  timevar_pop (TV_IPA_LTO_CTORS_OUT);\n }\n \n \n@@ -2427,6 +2429,30 @@ produce_lto_section ()\n   destroy_output_block (ob);\n }\n \n+/* Compare symbols to get them sorted by filename (to optimize streaming)  */\n+\n+static int\n+cmp_symbol_files (const void *pn1, const void *pn2)\n+{\n+  const symtab_node *n1 = *(const symtab_node * const *)pn1;\n+  const symtab_node *n2 = *(const symtab_node * const *)pn2;\n+\n+  int file_order1 = n1->lto_file_data ? n1->lto_file_data->order : -1;\n+  int file_order2 = n2->lto_file_data ? n2->lto_file_data->order : -1;\n+\n+  /* Order files same way as they appeared in the command line to reduce\n+     seeking while copying sections.  */\n+  if (file_order1 != file_order2)\n+    return file_order1 - file_order2;\n+\n+  /* Order within static library.  */\n+  if (n1->lto_file_data && n1->lto_file_data->id != n2->lto_file_data->id)\n+    return n1->lto_file_data->id - n2->lto_file_data->id;\n+\n+  /* And finaly order by the definition order.  */\n+  return n1->order - n2->order;\n+}\n+\n /* Main entry point from the pass manager.  */\n \n void\n@@ -2435,8 +2461,9 @@ lto_output (void)\n   struct lto_out_decl_state *decl_state;\n   bitmap output = NULL;\n   bitmap_obstack output_obstack;\n-  int i, n_nodes;\n+  unsigned int i, n_nodes;\n   lto_symtab_encoder_t encoder = lto_get_out_decl_state ()->symtab_node_encoder;\n+  auto_vec<symtab_node *> symbols_to_copy;\n \n   prune_offload_funcs ();\n \n@@ -2452,32 +2479,17 @@ lto_output (void)\n   produce_lto_section ();\n \n   n_nodes = lto_symtab_encoder_size (encoder);\n-  /* Process only the functions with bodies.  */\n+  /* Prepare vector of functions to output and then sort it to optimize\n+     section copying.  */\n   for (i = 0; i < n_nodes; i++)\n     {\n       symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n+      if (snode->alias)\n+\tcontinue;\n       if (cgraph_node *node = dyn_cast <cgraph_node *> (snode))\n \t{\n-\t  if (lto_symtab_encoder_encode_body_p (encoder, node)\n-\t      && !node->alias)\n-\t    {\n-\t      if (flag_checking)\n-\t\tgcc_assert (bitmap_set_bit (output, DECL_UID (node->decl)));\n-\t      decl_state = lto_new_out_decl_state ();\n-\t      lto_push_out_decl_state (decl_state);\n-\t      if (gimple_has_body_p (node->decl)\n-\t\t  || (!flag_wpa\n-\t\t      && flag_incremental_link != INCREMENTAL_LINK_LTO)\n-\t\t  /* Thunks have no body but they may be synthetized\n-\t\t     at WPA time.  */\n-\t\t  || DECL_ARGUMENTS (node->decl))\n-\t\toutput_function (node);\n-\t      else\n-\t\tcopy_function_or_variable (node);\n-\t      gcc_assert (lto_get_out_decl_state () == decl_state);\n-\t      lto_pop_out_decl_state ();\n-\t      lto_record_function_out_decl_state (node->decl, decl_state);\n-\t    }\n+\t  if (lto_symtab_encoder_encode_body_p (encoder, node))\n+\t    symbols_to_copy.safe_push (node);\n \t}\n       else if (varpool_node *node = dyn_cast <varpool_node *> (snode))\n \t{\n@@ -2487,27 +2499,42 @@ lto_output (void)\n \t  if (ctor && !in_lto_p)\n \t    walk_tree (&ctor, wrap_refs, NULL, NULL);\n \t  if (get_symbol_initial_value (encoder, node->decl) == error_mark_node\n-\t      && lto_symtab_encoder_encode_initializer_p (encoder, node)\n-\t      && !node->alias)\n-\t    {\n-\t      timevar_push (TV_IPA_LTO_CTORS_OUT);\n-\t      if (flag_checking)\n-\t\tgcc_assert (bitmap_set_bit (output, DECL_UID (node->decl)));\n-\t      decl_state = lto_new_out_decl_state ();\n-\t      lto_push_out_decl_state (decl_state);\n-\t      if (DECL_INITIAL (node->decl) != error_mark_node\n-\t\t  || (!flag_wpa\n-\t\t      && flag_incremental_link != INCREMENTAL_LINK_LTO))\n-\t\toutput_constructor (node);\n-\t      else\n-\t\tcopy_function_or_variable (node);\n-\t      gcc_assert (lto_get_out_decl_state () == decl_state);\n-\t      lto_pop_out_decl_state ();\n-\t      lto_record_function_out_decl_state (node->decl, decl_state);\n-\t      timevar_pop (TV_IPA_LTO_CTORS_OUT);\n-\t    }\n+\t      && lto_symtab_encoder_encode_initializer_p (encoder, node))\n+\t    symbols_to_copy.safe_push (node);\n \t}\n     }\n+  symbols_to_copy.qsort (cmp_symbol_files);\n+  for (i = 0; i < symbols_to_copy.length (); i++)\n+    {\n+      symtab_node *snode = symbols_to_copy[i];\n+      cgraph_node *cnode;\n+      varpool_node *vnode;\n+\n+      if (flag_checking)\n+\tgcc_assert (bitmap_set_bit (output, DECL_UID (snode->decl)));\n+\n+      decl_state = lto_new_out_decl_state ();\n+      lto_push_out_decl_state (decl_state);\n+\n+      if ((cnode = dyn_cast <cgraph_node *> (snode))\n+\t  && (gimple_has_body_p (cnode->decl)\n+\t      || (!flag_wpa\n+\t\t  && flag_incremental_link != INCREMENTAL_LINK_LTO)\n+\t      /* Thunks have no body but they may be synthetized\n+\t\t at WPA time.  */\n+\t      || DECL_ARGUMENTS (cnode->decl)))\n+\toutput_function (cnode);\n+      else if ((vnode = dyn_cast <varpool_node *> (snode))\n+\t       && (DECL_INITIAL (vnode->decl) != error_mark_node\n+\t\t   || (!flag_wpa\n+\t\t       && flag_incremental_link != INCREMENTAL_LINK_LTO)))\n+\toutput_constructor (vnode);\n+      else\n+\tcopy_function_or_variable (snode);\n+      gcc_assert (lto_get_out_decl_state () == decl_state);\n+      lto_pop_out_decl_state ();\n+      lto_record_function_out_decl_state (snode->decl, decl_state);\n+    }\n \n   /* Emit the callgraph after emitting function bodies.  This needs to\n      be done now to make sure that all the statements in every function"}, {"sha": "3e4308aab15fad29deef10967b9526c2f0a69b41", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "patch": "@@ -603,6 +603,9 @@ struct GTY(()) lto_file_decl_data\n   /* Linked list used temporarily in reader */\n   struct lto_file_decl_data *next;\n \n+  /* Order in which the file appears on the command line.  */\n+  int order;\n+\n   /* Sub ID for merged objects. */\n   unsigned HOST_WIDE_INT id;\n "}, {"sha": "49c77e03242d6a5f0298c1fa92cf5c1049304bda", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "patch": "@@ -1,3 +1,9 @@\n+2019-10-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-common.c (lto_file_finalize): Add order attribute.\n+\t(lto_create_files_from_ids): Pass order.\n+\t(lto_file_read): UPdate call of lto_create_files_from_ids.\n+\n 2019-10-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-common.c (read_cgraph_and_symbols): Grow ggc memory use after"}, {"sha": "cdfc7b0771911d022c38bb70d362977148751371", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=ebad2eeed903f7c9cf6c55d37be8af8c84f1cf32", "patch": "@@ -2177,7 +2177,8 @@ create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n /* Read declarations and other initializations for a FILE_DATA.  */\n \n static void\n-lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n+lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file,\n+\t\t   int order)\n {\n   const char *data;\n   size_t len;\n@@ -2195,6 +2196,7 @@ lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n \n   file_data->renaming_hash_table = lto_create_renaming_table ();\n   file_data->file_name = file->filename;\n+  file_data->order = order;\n #ifdef ACCEL_COMPILER\n   lto_input_mode_table (file_data);\n #else\n@@ -2231,9 +2233,9 @@ lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n \n static int\n lto_create_files_from_ids (lto_file *file, struct lto_file_decl_data *file_data,\n-\t\t\t   int *count)\n+\t\t\t   int *count, int order)\n {\n-  lto_file_finalize (file_data, file);\n+  lto_file_finalize (file_data, file, order);\n   if (symtab->dump_file)\n     fprintf (symtab->dump_file,\n \t     \"Creating file %s with sub id \" HOST_WIDE_INT_PRINT_HEX \"\\n\",\n@@ -2285,9 +2287,10 @@ lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n   lto_resolution_read (file_ids, resolution_file, file);\n \n   /* Finalize each lto file for each submodule in the merged object.  */\n+  int order = 0;\n   for (file_data = file_list.first; file_data != NULL;\n        file_data = file_data->next)\n-    lto_create_files_from_ids (file, file_data, count);\n+    lto_create_files_from_ids (file, file_data, count, order++);\n \n   splay_tree_delete (file_ids);\n   htab_delete (section_hash_table);"}]}