{"sha": "d3492572d5a42d7cb1208050fd4a24d9972db141", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM0OTI1NzJkNWE0MmQ3Y2IxMjA4MDUwZmQ0YTI0ZDk5NzJkYjE0MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-09-11T12:17:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-09-11T12:17:22Z"}, "message": "toplev.c (dump_memory_report): Call dump_vec_loc_statistics.\n\n\t* toplev.c (dump_memory_report): Call dump_vec_loc_statistics.\n\t* vec.c: Include hashtab.h\n\t(vec_descriptor, ptr_hash_entry): New structures.\n\t(vec_desc_hash, vec_ptr_map): New static variables.\n\t(hash_descriptor, eq_descriptor, hash_ptr, eq_ptr, vec_descriptor,\n\tregister_overhead, free_overhead, vec_heap_free): New functions.\n\t(vec_gc_o_reserve_1): ggc_free when resizing to 0.\n\t(vec_heap_o_reserve_1): free when resizing to 0; add statistics.\n\t(cmp_statistic, add_statistics, dump_vec_loc_statistics): New functions.\n\nFrom-SVN: r140277", "tree": {"sha": "14c4bf95881bc903031bf52e1a33cc0a335081a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14c4bf95881bc903031bf52e1a33cc0a335081a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3492572d5a42d7cb1208050fd4a24d9972db141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3492572d5a42d7cb1208050fd4a24d9972db141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3492572d5a42d7cb1208050fd4a24d9972db141", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3492572d5a42d7cb1208050fd4a24d9972db141/comments", "author": null, "committer": null, "parents": [{"sha": "3c9dbe18eece0ad55ed8d8177d8061d445cf6fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9dbe18eece0ad55ed8d8177d8061d445cf6fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9dbe18eece0ad55ed8d8177d8061d445cf6fbc"}], "stats": {"total": 247, "additions": 245, "deletions": 2}, "files": [{"sha": "2c331749ac7ca729e2c2ef5285f5df572b64089d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3492572d5a42d7cb1208050fd4a24d9972db141", "patch": "@@ -1,3 +1,15 @@\n+2008-09-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* toplev.c (dump_memory_report): Call dump_vec_loc_statistics.\n+\t* vec.c: Include hashtab.h\n+\t(vec_descriptor, ptr_hash_entry): New structures.\n+\t(vec_desc_hash, vec_ptr_map): New static variables.\n+\t(hash_descriptor, eq_descriptor, hash_ptr, eq_ptr, vec_descriptor,\n+\tregister_overhead, free_overhead, vec_heap_free): New functions.\n+\t(vec_gc_o_reserve_1): ggc_free when resizing to 0.\n+\t(vec_heap_o_reserve_1): free when resizing to 0; add statistics.\n+\t(cmp_statistic, add_statistics, dump_vec_loc_statistics): New functions.\n+\n 2008-09-11  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/37474"}, {"sha": "24e4df770226a7f2914a7cdd00d2fb017c3dd71a", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d3492572d5a42d7cb1208050fd4a24d9972db141", "patch": "@@ -2120,6 +2120,7 @@ dump_memory_report (bool final)\n   dump_varray_statistics ();\n   dump_alloc_pool_statistics ();\n   dump_bitmap_statistics ();\n+  dump_vec_loc_statistics ();\n   dump_ggc_loc_statistics (final);\n }\n "}, {"sha": "cc8fb51684d07c10948d262f51179eeee780a2b3", "filename": "gcc/vec.c", "status": "modified", "additions": 227, "deletions": 2, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=d3492572d5a42d7cb1208050fd4a24d9972db141", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"coretypes.h\"\n #include \"toplev.h\"\n+#include \"hashtab.h\"\n \n struct vec_prefix \n {\n@@ -39,6 +40,135 @@ struct vec_prefix\n   void *vec[1];\n };\n \n+\n+#ifdef GATHER_STATISTICS\n+\n+/* Store information about each particular vector.  */\n+struct vec_descriptor\n+{\n+  const char *function;\n+  const char *file;\n+  int line;\n+  size_t allocated;\n+  size_t times;\n+  size_t peak;\n+};\n+\n+\n+/* Hashtable mapping vec addresses to descriptors.  */\n+static htab_t vec_desc_hash;\n+\n+/* Hashtable helpers.  */\n+static hashval_t\n+hash_descriptor (const void *p)\n+{\n+  const struct vec_descriptor *const d =\n+    (const struct vec_descriptor *) p;\n+  return htab_hash_pointer (d->file) + d->line;\n+}\n+static int\n+eq_descriptor (const void *p1, const void *p2)\n+{\n+  const struct vec_descriptor *const d = (const struct vec_descriptor *) p1;\n+  const struct vec_descriptor *const l = (const struct vec_descriptor *) p2;\n+  return d->file == l->file && d->function == l->function && d->line == l->line;\n+}\n+\n+/* Hashtable converting address of allocated field to loc descriptor.  */\n+static htab_t ptr_hash;\n+struct ptr_hash_entry\n+{\n+  void *ptr;\n+  struct vec_descriptor *loc;\n+  size_t allocated;\n+};\n+\n+/* Hash table helpers functions.  */\n+static hashval_t\n+hash_ptr (const void *p)\n+{\n+  const struct ptr_hash_entry *const d = (const struct ptr_hash_entry *) p;\n+\n+  return htab_hash_pointer (d->ptr);\n+}\n+\n+static int\n+eq_ptr (const void *p1, const void *p2)\n+{\n+  const struct ptr_hash_entry *const p = (const struct ptr_hash_entry *) p1;\n+\n+  return (p->ptr == p2);\n+}\n+\n+/* Return descriptor for given call site, create new one if needed.  */\n+static struct vec_descriptor *\n+vec_descriptor (const char *name, int line, const char *function)\n+{\n+  struct vec_descriptor loc;\n+  struct vec_descriptor **slot;\n+\n+  loc.file = name;\n+  loc.line = line;\n+  loc.function = function;\n+  if (!vec_desc_hash)\n+    vec_desc_hash = htab_create (10, hash_descriptor, eq_descriptor, NULL);\n+\n+  slot = (struct vec_descriptor **) htab_find_slot (vec_desc_hash, &loc, 1);\n+  if (*slot)\n+    return *slot;\n+  *slot = XCNEW (struct vec_descriptor);\n+  (*slot)->file = name;\n+  (*slot)->line = line;\n+  (*slot)->function = function;\n+  (*slot)->allocated = 0;\n+  (*slot)->peak = 0;\n+  return *slot;\n+}\n+\n+/* Account the overhead.  */\n+static void\n+register_overhead (struct vec_prefix *ptr, size_t size,\n+\t\t   const char *name, int line, const char *function)\n+{\n+  struct vec_descriptor *loc = vec_descriptor (name, line, function);\n+  struct ptr_hash_entry *p = XNEW (struct ptr_hash_entry);\n+  PTR *slot;\n+\n+  p->ptr = ptr;\n+  p->loc = loc;\n+  p->allocated = size;\n+  if (!ptr_hash)\n+    ptr_hash = htab_create (10, hash_ptr, eq_ptr, NULL);\n+  slot = htab_find_slot_with_hash (ptr_hash, ptr, htab_hash_pointer (ptr), INSERT);\n+  gcc_assert (!*slot);\n+  *slot = p;\n+\n+  loc->allocated += size;\n+  if (loc->peak < loc->allocated)\n+    loc->peak += loc->allocated;\n+  loc->times++;\n+}\n+\n+/* Notice that the pointer has been freed.  */\n+static void\n+free_overhead (struct vec_prefix *ptr)\n+{\n+  PTR *slot = htab_find_slot_with_hash (ptr_hash, ptr, htab_hash_pointer (ptr),\n+\t\t\t\t\tNO_INSERT);\n+  struct ptr_hash_entry *p = (struct ptr_hash_entry *) *slot;\n+  p->loc->allocated -= p->allocated;\n+  htab_clear_slot (ptr_hash, slot);\n+  free (p);\n+}\n+\n+void\n+vec_heap_free (void *ptr)\n+{\n+  free_overhead ((struct vec_prefix *)ptr);\n+  free (ptr);\n+}\n+#endif\n+\n /* Calculate the new ALLOC value, making sure that RESERVE slots are\n    free.  If EXACT grow exactly, otherwise grow exponentially.  */\n \n@@ -99,7 +229,11 @@ vec_gc_o_reserve_1 (void *vec, int reserve, size_t vec_offset, size_t elt_size,\n   unsigned alloc = alloc = calculate_allocation (pfx, reserve, exact);\n   \n   if (!alloc)\n-    return NULL;\n+    {\n+      if (pfx)\n+        ggc_free (pfx);\n+      return NULL;\n+    }\n   \n   vec = ggc_realloc_stat (vec, vec_offset + alloc * elt_size PASS_MEM_STAT);\n   ((struct vec_prefix *)vec)->alloc = alloc;\n@@ -171,12 +305,26 @@ vec_heap_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n   unsigned alloc = calculate_allocation (pfx, reserve, exact);\n \n   if (!alloc)\n-    return NULL;\n+    {\n+      if (pfx)\n+        vec_heap_free (pfx);\n+      return NULL;\n+    }\n+\n+#ifdef GATHER_STATISTICS\n+  if (vec)\n+    free_overhead (pfx);\n+#endif\n   \n   vec = xrealloc (vec, vec_offset + alloc * elt_size);\n   ((struct vec_prefix *)vec)->alloc = alloc;\n   if (!pfx)\n     ((struct vec_prefix *)vec)->num = 0;\n+#ifdef GATHER_STATISTICS\n+  if (vec)\n+    register_overhead ((struct vec_prefix *)vec,\n+    \t\t       vec_offset + alloc * elt_size PASS_MEM_STAT);\n+#endif\n   \n   return vec;\n }\n@@ -234,3 +382,80 @@ vec_assert_fail (const char *op, const char *struct_name,\n \t\t  struct_name, op, function, trim_filename (file), line);\n }\n #endif\n+\n+#ifdef GATHER_STATISTICS\n+/* Helper for qsort; sort descriptors by amount of memory consumed.  */\n+static int\n+cmp_statistic (const void *loc1, const void *loc2)\n+{\n+  const struct vec_descriptor *const l1 =\n+    *(const struct vec_descriptor *const *) loc1;\n+  const struct vec_descriptor *const l2 =\n+    *(const struct vec_descriptor *const *) loc2;\n+  long diff;\n+  diff = l1->allocated - l2->allocated;\n+  if (!diff)\n+    diff = l1->peak - l2->peak;\n+  if (!diff)\n+    diff = l1->times - l2->times;\n+  return diff > 0 ? 1 : diff < 0 ? -1 : 0;\n+}\n+/* Collect array of the descriptors from hashtable.  */\n+static struct vec_descriptor **loc_array;\n+static int\n+add_statistics (void **slot, void *b)\n+{\n+  int *n = (int *)b;\n+  loc_array[*n] = (struct vec_descriptor *) *slot;\n+  (*n)++;\n+  return 1;\n+}\n+\n+/* Dump per-site memory statistics.  */\n+#endif\n+void\n+dump_vec_loc_statistics (void)\n+{\n+#ifdef GATHER_STATISTICS\n+  int nentries = 0;\n+  char s[4096];\n+  size_t allocated = 0;\n+  size_t times = 0;\n+  int i;\n+\n+  loc_array = XCNEWVEC (struct vec_descriptor *, vec_desc_hash->n_elements);\n+  fprintf (stderr, \"Heap vectors:\\n\");\n+  fprintf (stderr, \"\\n%-48s %10s       %10s       %10s\\n\",\n+\t   \"source location\", \"Leak\", \"Peak\", \"Times\");\n+  fprintf (stderr, \"-------------------------------------------------------\\n\");\n+  htab_traverse (vec_desc_hash, add_statistics, &nentries);\n+  qsort (loc_array, nentries, sizeof (*loc_array), cmp_statistic);\n+  for (i = 0; i < nentries; i++)\n+    {\n+      struct vec_descriptor *d = loc_array[i];\n+      allocated += d->allocated;\n+      times += d->times;\n+    }\n+  for (i = 0; i < nentries; i++)\n+    {\n+      struct vec_descriptor *d = loc_array[i];\n+      const char *s1 = d->file;\n+      const char *s2;\n+      while ((s2 = strstr (s1, \"gcc/\")))\n+\ts1 = s2 + 4;\n+      sprintf (s, \"%s:%i (%s)\", s1, d->line, d->function);\n+      s[48] = 0;\n+      fprintf (stderr, \"%-48s %10li:%4.1f%% %10li      %10li:%4.1f%% \\n\", s,\n+\t       (long)d->allocated,\n+\t       (d->allocated) * 100.0 / allocated,\n+\t       (long)d->peak,\n+\t       (long)d->times,\n+\t       (d->times) * 100.0 / times);\n+    }\n+  fprintf (stderr, \"%-48s %10ld                        %10ld\\n\",\n+\t   \"Total\", (long)allocated, (long)times);\n+  fprintf (stderr, \"\\n%-48s %10s       %10s       %10s\\n\",\n+\t   \"source location\", \"Leak\", \"Peak\", \"Times\");\n+  fprintf (stderr, \"-------------------------------------------------------\\n\");\n+#endif\n+}"}, {"sha": "06d9f6e8ebe047c81ca278862252bde33da20911", "filename": "gcc/vec.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3492572d5a42d7cb1208050fd4a24d9972db141/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=d3492572d5a42d7cb1208050fd4a24d9972db141", "patch": "@@ -429,7 +429,12 @@ extern void *vec_heap_p_reserve_exact (void *, int MEM_STAT_DECL);\n extern void *vec_heap_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n extern void *vec_heap_o_reserve_exact (void *, int, size_t, size_t\n \t\t\t\t       MEM_STAT_DECL);\n+extern void dump_vec_loc_statistics (void);\n+#ifdef GATHER_STATISTICS\n+void vec_heap_free (void *);\n+#else\n #define vec_heap_free(V) free (V)\n+#endif\n \n #if ENABLE_CHECKING\n #define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__"}]}