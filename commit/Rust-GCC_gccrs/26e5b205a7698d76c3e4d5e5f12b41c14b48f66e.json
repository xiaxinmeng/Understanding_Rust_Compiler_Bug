{"sha": "26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZlNWIyMDVhNzY5OGQ3NmMzZTRkNWU1ZjEyYjQxYzE0YjQ4ZjY2ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-24T20:15:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-24T20:15:09Z"}, "message": "i386-protos.h (ix86_split_long_move): Return void.\n\n\t* i386-protos.h (ix86_split_long_move): Return void.\n\t* i386.c (ix86_split_to_parts): Handle 64bit target.\n\t(ix86_split_long_move): Likewise.\n\t* i386.md (all calls to ix86_split_long_move): Update.\n\nFrom-SVN: r40816", "tree": {"sha": "97afc9370997fc2836ac3fb7d9b965314c86536f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97afc9370997fc2836ac3fb7d9b965314c86536f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/comments", "author": null, "committer": null, "parents": [{"sha": "ddce8041e26509182aaa57ccce75b6755a634c1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddce8041e26509182aaa57ccce75b6755a634c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddce8041e26509182aaa57ccce75b6755a634c1c"}], "stats": {"total": 232, "additions": 161, "deletions": 71}, "files": [{"sha": "625ccfc192fd5f3672b2abb17f6a1425d9c9ca7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "patch": "@@ -1,3 +1,10 @@\n+Sat Mar 24 21:13:28 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386-protos.h (ix86_split_long_move): Return void.\n+\t* i386.c (ix86_split_to_parts): Handle 64bit target.\n+\t(ix86_split_long_move): Likewise.\n+\t* i386.md (all calls to ix86_split_long_move): Update.\n+\n 2001-03-23  Richard Henderson  <rth@redhat.com>\n \n \t* config/mips/iris4.h (ASM_OUTPUT_ASCII): Rename local variables"}, {"sha": "0cd90cdbf78d3fd4378186b264adba5c435db6a9", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "patch": "@@ -115,7 +115,7 @@ extern void ix86_expand_branch PARAMS ((enum rtx_code, rtx));\n extern int ix86_expand_setcc PARAMS ((enum rtx_code, rtx));\n extern int ix86_expand_int_movcc PARAMS ((rtx[]));\n extern int ix86_expand_fp_movcc PARAMS ((rtx[]));\n-extern int ix86_split_long_move PARAMS ((rtx[]));\n+extern void ix86_split_long_move PARAMS ((rtx[]));\n extern void ix86_split_ashldi PARAMS ((rtx *, rtx));\n extern void ix86_split_ashrdi PARAMS ((rtx *, rtx));\n extern void ix86_split_lshrdi PARAMS ((rtx *, rtx));"}, {"sha": "92f669bccc8b45dc301269295acf843b2e5516a5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 144, "deletions": 57, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "patch": "@@ -6599,7 +6599,12 @@ ix86_split_to_parts (operand, parts, mode)\n      rtx *parts;\n      enum machine_mode mode;\n {\n-  int size = mode == TFmode ? 3 : GET_MODE_SIZE (mode) / 4;\n+  int size;\n+\n+  if (!TARGET_64BIT)\n+    size = mode == TFmode ? 3 : (GET_MODE_SIZE (mode) / 4);\n+  else\n+    size = (GET_MODE_SIZE (mode) + 4) / 8;\n \n   if (GET_CODE (operand) == REG && MMX_REGNO_P (REGNO (operand)))\n     abort ();\n@@ -6620,10 +6625,11 @@ ix86_split_to_parts (operand, parts, mode)\n       if (! push_operand (operand, VOIDmode))\n \tabort ();\n \n-      PUT_MODE (operand, SImode);\n+      operand = copy_rtx (operand);\n+      PUT_MODE (operand, Pmode);\n       parts[0] = parts[1] = parts[2] = operand;\n     }\n-  else\n+  else if (!TARGET_64BIT)\n     {\n       if (mode == DImode)\n \tsplit_di (&operand, 1, &parts[0], &parts[1]);\n@@ -6640,7 +6646,7 @@ ix86_split_to_parts (operand, parts, mode)\n \t    }\n \t  else if (offsettable_memref_p (operand))\n \t    {\n-\t      PUT_MODE (operand, SImode);\n+\t      operand = change_address (operand, SImode, XEXP (operand, 0));\n \t      parts[0] = operand;\n \t      parts[1] = adj_offsettable_operand (operand, 4);\n \t      if (size == 3)\n@@ -6672,6 +6678,42 @@ ix86_split_to_parts (operand, parts, mode)\n \t    abort ();\n \t}\n     }\n+  else\n+    {\n+      if (mode == XFmode || mode == TFmode)\n+\t{\n+\t  if (REG_P (operand))\n+\t    {\n+\t      if (!reload_completed)\n+\t\tabort ();\n+\t      parts[0] = gen_rtx_REG (DImode, REGNO (operand) + 0);\n+\t      parts[1] = gen_rtx_REG (SImode, REGNO (operand) + 1);\n+\t    }\n+\t  else if (offsettable_memref_p (operand))\n+\t    {\n+\t      operand = change_address (operand, DImode, XEXP (operand, 0));\n+\t      parts[0] = operand;\n+\t      parts[1] = adj_offsettable_operand (operand, 8);\n+\t      parts[1] = change_address (parts[1], SImode, XEXP (operand, 0));\n+\t    }\n+\t  else if (GET_CODE (operand) == CONST_DOUBLE)\n+\t    {\n+\t      REAL_VALUE_TYPE r;\n+\t      long l[3];\n+\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operand);\n+\t      REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, l);\n+\t      /* Do not use shift by 32 to avoid warning on 32bit systems.  */\n+\t      if (HOST_BITS_PER_WIDE_INT >= 64)\n+\t        parts[0] = GEN_INT (l[0] + ((l[1] << 31) << 1));\n+\t      else\n+\t        parts[0] = immed_double_const (l[0], l[1], DImode);\n+\t      parts[1] = GEN_INT (l[2]);\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n \n   return size;\n }\n@@ -6681,19 +6723,36 @@ ix86_split_to_parts (operand, parts, mode)\n    insns have been emitted.  Operands 2-4 contain the input values\n    int the correct order; operands 5-7 contain the output values.  */\n \n-int\n-ix86_split_long_move (operands1)\n-     rtx operands1[];\n+void\n+ix86_split_long_move (operands)\n+     rtx operands[];\n {\n   rtx part[2][3];\n-  rtx operands[2];\n-  int size;\n+  int nparts;\n   int push = 0;\n   int collisions = 0;\n-\n-  /* Make our own copy to avoid clobbering the operands.  */\n-  operands[0] = copy_rtx (operands1[0]);\n-  operands[1] = copy_rtx (operands1[1]);\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+\n+  /* The DFmode expanders may ask us to move double.\n+     For 64bit target this is single move.  By hiding the fact\n+     here we simplify i386.md splitters.  */\n+  if (GET_MODE_SIZE (GET_MODE (operands[0])) == 8 && TARGET_64BIT)\n+    {\n+      /* Optimize constant pool reference to immediates.  This is used by fp moves,\n+\t that force all constants to memory to allow combining.  */\n+\n+      if (GET_CODE (operands[1]) == MEM\n+\t  && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+\t  && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0)))\n+\toperands[1] = get_pool_constant (XEXP (operands[1], 0));\n+      if (push_operand (operands[0], VOIDmode))\n+\toperands[0] = change_address (operands[0], DImode, XEXP (operands[0], 0));\n+      else\n+        operands[0] = gen_lowpart (DImode, operands[0]);\n+      operands[1] = gen_lowpart (DImode, operands[1]);\n+      emit_move_insn (operands[0], operands[1]);\n+      return;\n+    }\n \n   /* The only non-offsettable memory we handle is push.  */\n   if (push_operand (operands[0], VOIDmode))\n@@ -6702,14 +6761,14 @@ ix86_split_long_move (operands1)\n \t   && ! offsettable_memref_p (operands[0]))\n     abort ();\n \n-  size = ix86_split_to_parts (operands[0], part[0], GET_MODE (operands1[0]));\n-  ix86_split_to_parts (operands[1], part[1], GET_MODE (operands1[0]));\n+  nparts = ix86_split_to_parts (operands[1], part[1], GET_MODE (operands[0]));\n+  ix86_split_to_parts (operands[0], part[0], GET_MODE (operands[0]));\n \n   /* When emitting push, take care for source operands on the stack.  */\n   if (push && GET_CODE (operands[1]) == MEM\n       && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n     {\n-      if (size == 3)\n+      if (nparts == 3)\n \tpart[1][1] = part[1][2];\n       part[1][0] = part[1][1];\n     }\n@@ -6722,12 +6781,12 @@ ix86_split_long_move (operands1)\n \tcollisions++;\n       if (reg_overlap_mentioned_p (part[0][1], XEXP (part[1][0], 0)))\n \tcollisions++;\n-      if (size == 3\n+      if (nparts == 3\n \t  && reg_overlap_mentioned_p (part[0][2], XEXP (part[1][0], 0)))\n \tcollisions++;\n \n       /* Collision in the middle part can be handled by reordering.  */\n-      if (collisions == 1 && size == 3\n+      if (collisions == 1 && nparts == 3\n \t  && reg_overlap_mentioned_p (part[0][1], XEXP (part[1][0], 0)))\n \t{\n \t  rtx tmp;\n@@ -6740,79 +6799,107 @@ ix86_split_long_move (operands1)\n       else if (collisions > 1)\n \t{\n \t  collisions = 1;\n-\t  emit_insn (gen_rtx_SET (VOIDmode, part[0][size - 1],\n+\t  emit_insn (gen_rtx_SET (VOIDmode, part[0][nparts - 1],\n \t\t\t\t  XEXP (part[1][0], 0)));\n-\t  part[1][0] = change_address (part[1][0], SImode, part[0][size - 1]);\n-\t  part[1][1] = adj_offsettable_operand (part[1][0], 4);\n-\t  if (size == 3)\n+\t  part[1][0] = change_address (part[1][0],\n+\t\t\t\t       TARGET_64BIT ? DImode : SImode,\n+\t\t\t\t       part[0][nparts - 1]);\n+\t  part[1][1] = adj_offsettable_operand (part[1][0],\n+\t\t\t\t\t        UNITS_PER_WORD);\n+\t  part[1][1] = change_address (part[1][1], GET_MODE (part[0][1]),\n+\t\t\t \t       XEXP (part[1][1], 0));\n+\t  if (nparts == 3)\n \t    part[1][2] = adj_offsettable_operand (part[1][0], 8);\n \t}\n     }\n \n   if (push)\n     {\n-      if (size == 3)\n+      if (!TARGET_64BIT)\n \t{\n-\t  /* We use only first 12 bytes of TFmode value, but for pushing we\n-\t     are required to adjust stack as if we were pushing real 16byte\n-\t     value.  */\n-\t  if (GET_MODE (operands1[0]) == TFmode)\n-\t    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (-4)));\n-\t  emit_insn (gen_push (part[1][2]));\n+\t  if (nparts == 3)\n+\t    {\n+\t      /* We use only first 12 bytes of TFmode value, but for pushing we\n+\t\t are required to adjust stack as if we were pushing real 16byte\n+\t\t value.  */\n+\t      if (mode == TFmode && !TARGET_64BIT)\n+\t\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (-4)));\n+\t      emit_move_insn (part[0][2], part[1][2]);\n+\t    }\n \t}\n-      emit_insn (gen_push (part[1][1]));\n-      emit_insn (gen_push (part[1][0]));\n-      return 1;\n+      else\n+\t{\n+\t  /* In 64bit mode we don't have 32bit push available.  In case this is\n+\t     register, it is OK - we will just use larger counterpart.  We also\n+\t     retype memory - these comes from attempt to avoid REX prefix on\n+\t     moving of second half of TFmode value.  */\n+\t  if (GET_MODE (part[1][1]) == SImode)\n+\t    {\n+\t      if (GET_CODE (part[1][1]) == MEM)\n+\t\tpart[1][1] = change_address (part[1][1], DImode, XEXP (part[1][1], 0));\n+\t      else if (REG_P (part[1][1]))\n+\t\tpart[1][1] = gen_rtx_REG (DImode, REGNO (part[1][1]));\n+\t      else\n+\t\tabort();\n+\t    }\n+\t}\n+      emit_move_insn (part[0][1], part[1][1]);\n+      emit_move_insn (part[0][0], part[1][0]);\n+      return;\n     }\n \n   /* Choose correct order to not overwrite the source before it is copied.  */\n   if ((REG_P (part[0][0])\n        && REG_P (part[1][1])\n        && (REGNO (part[0][0]) == REGNO (part[1][1])\n-\t   || (size == 3\n+\t   || (nparts == 3\n \t       && REGNO (part[0][0]) == REGNO (part[1][2]))))\n       || (collisions > 0\n \t  && reg_overlap_mentioned_p (part[0][0], XEXP (part[1][0], 0))))\n     {\n-      if (size == 3)\n+      if (nparts == 3)\n \t{\n-\t  operands1[2] = part[0][2];\n-\t  operands1[3] = part[0][1];\n-\t  operands1[4] = part[0][0];\n-\t  operands1[5] = part[1][2];\n-\t  operands1[6] = part[1][1];\n-\t  operands1[7] = part[1][0];\n+\t  operands[2] = part[0][2];\n+\t  operands[3] = part[0][1];\n+\t  operands[4] = part[0][0];\n+\t  operands[5] = part[1][2];\n+\t  operands[6] = part[1][1];\n+\t  operands[7] = part[1][0];\n \t}\n       else\n \t{\n-\t  operands1[2] = part[0][1];\n-\t  operands1[3] = part[0][0];\n-\t  operands1[5] = part[1][1];\n-\t  operands1[6] = part[1][0];\n+\t  operands[2] = part[0][1];\n+\t  operands[3] = part[0][0];\n+\t  operands[5] = part[1][1];\n+\t  operands[6] = part[1][0];\n \t}\n     }\n   else\n     {\n-      if (size == 3)\n+      if (nparts == 3)\n \t{\n-\t  operands1[2] = part[0][0];\n-\t  operands1[3] = part[0][1];\n-\t  operands1[4] = part[0][2];\n-\t  operands1[5] = part[1][0];\n-\t  operands1[6] = part[1][1];\n-\t  operands1[7] = part[1][2];\n+\t  operands[2] = part[0][0];\n+\t  operands[3] = part[0][1];\n+\t  operands[4] = part[0][2];\n+\t  operands[5] = part[1][0];\n+\t  operands[6] = part[1][1];\n+\t  operands[7] = part[1][2];\n \t}\n       else\n \t{\n-\t  operands1[2] = part[0][0];\n-\t  operands1[3] = part[0][1];\n-\t  operands1[5] = part[1][0];\n-\t  operands1[6] = part[1][1];\n+\t  operands[2] = part[0][0];\n+\t  operands[3] = part[0][1];\n+\t  operands[5] = part[1][0];\n+\t  operands[6] = part[1][1];\n \t}\n     }\n+  emit_move_insn (operands[2], operands[5]);\n+  emit_move_insn (operands[3], operands[6]);\n+  if (nparts == 3)\n+    emit_move_insn (operands[4], operands[7]);\n \n-  return 0;\n+  return;\n }\n \n void"}, {"sha": "24e21b1ce241cea4f47ed40639f0e8824deafde4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "patch": "@@ -2421,17 +2421,16 @@\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed && ! MMX_REG_P (operands[1])\"\n   [(const_int 0)]\n-  \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n+  \"ix86_split_long_move (operands); DONE;\")\n \n ;; %%% This multiword shite has got to go.\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed && ! MMX_REG_P (operands[0])\n    && ! MMX_REG_P (operands[1])\"\n-  [(set (match_dup 2) (match_dup 5))\n-   (set (match_dup 3) (match_dup 6))]\n-  \"if (ix86_split_long_move (operands)) DONE;\")\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*movdi_1_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!m*y,!*y,*m,*Y\")\n@@ -2823,7 +2822,7 @@\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n+  \"ix86_split_long_move (operands); DONE;\")\n \n ;; Moving is usually shorter when only FP registers are used. This separate\n ;; movdf pattern avoids the use of integer registers for FP operations\n@@ -2957,9 +2956,8 @@\n    && ! (ANY_FP_REG_P (operands[1]) || \n \t (GET_CODE (operands[1]) == SUBREG\n \t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n-  [(set (match_dup 2) (match_dup 5))\n-   (set (match_dup 3) (match_dup 6))]\n-  \"if (ix86_split_long_move (operands)) DONE;\")\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*swapdf\"\n   [(set (match_operand:DF 0 \"register_operand\" \"+f\")\n@@ -3125,7 +3123,7 @@\n        || GET_MODE (operands[0]) == DFmode)\n    && (!REG_P (operands[1]) || !ANY_FP_REGNO_P (REGNO (operands[1])))\"\n   [(const_int 0)]\n-  \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n+  \"ix86_split_long_move (operands); DONE;\")\n \n (define_split\n   [(set (match_operand:XF 0 \"push_operand\" \"\")\n@@ -3351,10 +3349,8 @@\n    && ! (ANY_FP_REG_P (operands[1]) || \n \t (GET_CODE (operands[1]) == SUBREG\n \t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n-  [(set (match_dup 2) (match_dup 5))\n-   (set (match_dup 3) (match_dup 6))\n-   (set (match_dup 4) (match_dup 7))]\n-  \"if (ix86_split_long_move (operands)) DONE;\")\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n \n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")"}]}