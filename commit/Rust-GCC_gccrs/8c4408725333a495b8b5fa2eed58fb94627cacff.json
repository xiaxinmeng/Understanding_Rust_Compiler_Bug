{"sha": "8c4408725333a495b8b5fa2eed58fb94627cacff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM0NDA4NzI1MzMzYTQ5NWI4YjVmYTJlZWQ1OGZiOTQ2MjdjYWNmZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-30T16:04:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-30T16:04:24Z"}, "message": "h8300.c (byte_reg): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/h8300/h8300.c (byte_reg): Use gcc_assert and\n\tgcc_unreachable as appropriate.\n\t(split_adds_subs, cond_string, print_operand,\n\th8300_initial_elimination_offset, h8300_classify_operand,\n\th8300_unary_length, h8300_short_immediate_length,\n\th8300_bitfield_length, h8300_binary_length,\n\th8300_insn_length_from_table, compute_mov_length, output_plussi,\n\tcompute_plussi_length, compute_plussi_cc, output_logical_op,\n\tcompute_logical_op_length, compute_logical_op_cc,\n\toutput_h8sx_shift, get_shift_alg, h8300_shift_needs_scratch_p,\n\toutput_a_shift, compute_a_shift_length, compute_a_shift_cc,\n\toutput_a_rotate, compute_a_rotate_length, fix_bit_operand,\n\th8300_regs_ok_for_stm): Likewise.\n\t* config/h8300/h8300.md (*movsi_h8300, *movsf_h8300,\n\tmonitor_prologue): Likewise.\n\nFrom-SVN: r99037", "tree": {"sha": "3c0c8fe2ec71588339d3a99300712c5c866bb795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c0c8fe2ec71588339d3a99300712c5c866bb795"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c4408725333a495b8b5fa2eed58fb94627cacff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4408725333a495b8b5fa2eed58fb94627cacff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4408725333a495b8b5fa2eed58fb94627cacff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4408725333a495b8b5fa2eed58fb94627cacff/comments", "author": null, "committer": null, "parents": [{"sha": "edd954e6204fd9a4177696e580bb35a80593a365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd954e6204fd9a4177696e580bb35a80593a365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edd954e6204fd9a4177696e580bb35a80593a365"}], "stats": {"total": 513, "additions": 261, "deletions": 252}, "files": [{"sha": "c8c415c66aaaa270e25b51f0548de74aa2052a16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4408725333a495b8b5fa2eed58fb94627cacff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4408725333a495b8b5fa2eed58fb94627cacff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c4408725333a495b8b5fa2eed58fb94627cacff", "patch": "@@ -1,3 +1,21 @@\n+2005-04-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/h8300/h8300.c (byte_reg): Use gcc_assert and\n+\tgcc_unreachable as appropriate.\n+\t(split_adds_subs, cond_string, print_operand,\n+\th8300_initial_elimination_offset, h8300_classify_operand,\n+\th8300_unary_length, h8300_short_immediate_length,\n+\th8300_bitfield_length, h8300_binary_length,\n+\th8300_insn_length_from_table, compute_mov_length, output_plussi,\n+\tcompute_plussi_length, compute_plussi_cc, output_logical_op,\n+\tcompute_logical_op_length, compute_logical_op_cc,\n+\toutput_h8sx_shift, get_shift_alg, h8300_shift_needs_scratch_p,\n+\toutput_a_shift, compute_a_shift_length, compute_a_shift_cc,\n+\toutput_a_rotate, compute_a_rotate_length, fix_bit_operand,\n+\th8300_regs_ok_for_stm): Likewise.\n+\t* config/h8300/h8300.md (*movsi_h8300, *movsf_h8300,\n+\tmonitor_prologue): Likewise.\n+\n 2005-04-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* loop-invariant.c (invariants, create_new_invariant,"}, {"sha": "77a776856ff85a370ee91d1c547d071a3d2c7668", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 240, "deletions": 249, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4408725333a495b8b5fa2eed58fb94627cacff/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4408725333a495b8b5fa2eed58fb94627cacff/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=8c4408725333a495b8b5fa2eed58fb94627cacff", "patch": "@@ -481,8 +481,7 @@ byte_reg (rtx x, int b)\n     \"r4l\", \"r4h\", \"r5l\", \"r5h\", \"r6l\", \"r6h\", \"r7l\", \"r7h\"\n   };\n \n-  if (!REG_P (x))\n-    abort ();\n+  gcc_assert (REG_P (x));\n \n   return names_small[REGNO (x) * 2 + b];\n }\n@@ -1001,7 +1000,7 @@ split_adds_subs (enum machine_mode mode, rtx *operands)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Try different amounts in descending order.  */\n@@ -1366,7 +1365,7 @@ cond_string (enum rtx_code code)\n     case LTU:\n       return \"lo\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1391,7 +1390,7 @@ print_operand (FILE *file, rtx x, int code)\n \t  fprintf (file, \"#%ld\", (-INTVAL (x)) & 0xff);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n     case 'F':\n@@ -1404,12 +1403,11 @@ print_operand (FILE *file, rtx x, int code)\n \t  fprintf (file, \"#%ld\", ((-INTVAL (x)) & 0xff00) >> 8);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n     case 'G':\n-      if (GET_CODE (x) != CONST_INT)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n       fprintf (file, \"#%ld\", 0xff & (-INTVAL (x)));\n       break;\n     case 'S':\n@@ -1426,14 +1424,12 @@ print_operand (FILE *file, rtx x, int code)\n       break;\n     case 'V':\n       bitint = exact_log2 (INTVAL (x) & 0xff);\n-      if (bitint == -1)\n-\tabort ();\n+      gcc_assert (bitint >= 0);\n       fprintf (file, \"#%d\", bitint);\n       break;\n     case 'W':\n       bitint = exact_log2 ((~INTVAL (x)) & 0xff);\n-      if (bitint == -1)\n-\tabort ();\n+      gcc_assert (bitint >= 0);\n       fprintf (file, \"#%d\", bitint);\n       break;\n     case 'R':\n@@ -1444,8 +1440,7 @@ print_operand (FILE *file, rtx x, int code)\n \tgoto def;\n       break;\n     case 'Y':\n-      if (bitint == -1)\n-\tabort ();\n+      gcc_assert (bitint >= 0);\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s%c\", names_big[REGNO (x)], bitint > 7 ? 'h' : 'l');\n       else\n@@ -1497,7 +1492,7 @@ print_operand (FILE *file, rtx x, int code)\n \t    break;\n \t  }\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t  break;\n \t}\n       break;\n@@ -1527,7 +1522,7 @@ print_operand (FILE *file, rtx x, int code)\n \t    break;\n \t  }\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n     case 'j':\n@@ -1537,16 +1532,24 @@ print_operand (FILE *file, rtx x, int code)\n       fputs (cond_string (reverse_condition (GET_CODE (x))), file);\n       break;\n     case 'm':\n-      if (GET_CODE (x) != CONST_INT)\n-\tabort ();\n-      if (INTVAL (x) == 1)\n-\tfputs (\".b\", file);\n-      else if (INTVAL (x) == 2)\n-\tfputs (\".w\", file);\n-      else if (INTVAL (x) == 4)\n-\tfputs (\".l\", file);\n-      else\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n+      switch (INTVAL (x))\n+\t{\n+\tcase 1:\n+\t  fputs (\".b\", file);\n+\t  break;\n+\n+\tcase 2:\n+\t  fputs (\".w\", file);\n+\t  break;\n+\n+\tcase 4:\n+\t  fputs (\".l\", file);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       break;\n     case 'o':\n       print_operand_address (file, x);\n@@ -1612,7 +1615,7 @@ print_operand (FILE *file, rtx x, int code)\n \t      fprintf (file, \"%s\", names_extended[REGNO (x)]);\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  break;\n \n@@ -1846,8 +1849,9 @@ h8300_initial_elimination_offset (int from, int to)\n      pointer int account.  */\n   saved_regs_size -= fp_size;\n \n-  if (to == HARD_FRAME_POINTER_REGNUM)\n+  switch (to)\n     {\n+    case HARD_FRAME_POINTER_REGNUM:\n       switch (from)\n \t{\n \tcase ARG_POINTER_REGNUM:\n@@ -1857,11 +1861,10 @@ h8300_initial_elimination_offset (int from, int to)\n \tcase FRAME_POINTER_REGNUM:\n \t  return -saved_regs_size;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n-    }\n-  else if (to == STACK_POINTER_REGNUM)\n-    {\n+      break;\n+    case STACK_POINTER_REGNUM:\n       switch (from)\n \t{\n \tcase ARG_POINTER_REGNUM:\n@@ -1871,11 +1874,13 @@ h8300_initial_elimination_offset (int from, int to)\n \tcase FRAME_POINTER_REGNUM:\n \t  return frame_size;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n+  gcc_unreachable ();\n }\n \n /* Worker function for RETURN_ADDR_RTX.  */\n@@ -2196,12 +2201,9 @@ h8300_classify_operand (rtx op, int size, enum h8300_operand_class *class)\n \t  return 0;\n \t}\n     }\n-  else if (register_operand (op, VOIDmode))\n-    {\n-      *class = H8OP_REGISTER;\n-      return 0;\n-    }\n-  abort ();\n+  gcc_assert (register_operand (op, VOIDmode));\n+  *class = H8OP_REGISTER;\n+  return 0;\n }\n \n /* Return the length of the instruction described by TABLE given that\n@@ -2246,7 +2248,7 @@ h8300_unary_length (rtx op)\n       return operand_length + 6;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2272,7 +2274,7 @@ h8300_short_immediate_length (rtx op)\n       return 4 + operand_length;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2286,8 +2288,7 @@ h8300_bitfield_length (rtx op, rtx op2)\n \n   if (GET_CODE (op) == REG)\n     op = op2;\n-  if (GET_CODE (op) == REG)\n-    abort ();\n+  gcc_assert (GET_CODE (op) != REG);\n   \n   size = GET_MODE_SIZE (GET_MODE (op));\n   operand_length = h8300_classify_operand (op, size, &class);\n@@ -2300,7 +2301,7 @@ h8300_bitfield_length (rtx op, rtx op2)\n       return 4 + operand_length;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2312,18 +2313,18 @@ h8300_binary_length (rtx insn, const h8300_length_table *table)\n   rtx set;\n \n   set = single_set (insn);\n-  if (set == 0)\n-    abort ();\n+  gcc_assert (set);\n \n   if (BINARY_P (SET_SRC (set)))\n     return h8300_length_from_table (XEXP (SET_SRC (set), 0),\n \t\t\t\t    XEXP (SET_SRC (set), 1), table);\n-  else if (GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == RTX_TERNARY)\n-    return h8300_length_from_table (XEXP (XEXP (SET_SRC (set), 1), 0),\n-\t\t\t\t    XEXP (XEXP (SET_SRC (set), 1), 1),\n-\t\t\t\t    table);\n   else\n-    abort ();\n+    {\n+      gcc_assert (GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == RTX_TERNARY);\n+      return h8300_length_from_table (XEXP (XEXP (SET_SRC (set), 1), 0),\n+\t\t\t\t      XEXP (XEXP (SET_SRC (set), 1), 1),\n+\t\t\t\t      table);\n+    }\n }\n \n /* Subroutine of h8300_move_length.  Return true if OP is 1- or 2-byte\n@@ -2401,7 +2402,7 @@ h8300_insn_length_from_table (rtx insn, rtx * operands)\n   switch (get_attr_length_table (insn))\n     {\n     case LENGTH_TABLE_NONE:\n-      abort ();\n+      gcc_unreachable ();\n \n     case LENGTH_TABLE_ADDB:\n       return h8300_binary_length (insn, &addb_length_table);\n@@ -2444,9 +2445,10 @@ h8300_insn_length_from_table (rtx insn, rtx * operands)\n       \n     case LENGTH_TABLE_BITBRANCH:\n       return h8300_bitfield_length (operands[1], operands[2]) - 2;\n-      \n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \n /* Return true if LHS and RHS are memory references that can be mapped\n@@ -2711,7 +2713,7 @@ compute_mov_length (rtx *operands)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Adjust the length based on the addressing mode used.\n@@ -2831,7 +2833,7 @@ compute_mov_length (rtx *operands)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Adjust the length based on the addressing mode used.\n@@ -2875,8 +2877,7 @@ output_plussi (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n-  if (mode != SImode)\n-    abort ();\n+  gcc_assert (mode == SImode);\n \n   if (TARGET_H8300)\n     {\n@@ -2960,8 +2961,7 @@ compute_plussi_length (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n-  if (mode != SImode)\n-    abort ();\n+  gcc_assert (mode == SImode);\n \n   if (TARGET_H8300)\n     {\n@@ -3040,8 +3040,7 @@ compute_plussi_cc (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n-  if (mode != SImode)\n-    abort ();\n+  gcc_assert (mode == SImode);\n \n   if (TARGET_H8300)\n     {\n@@ -3135,7 +3134,7 @@ output_logical_op (enum machine_mode mode, rtx *operands)\n       opname = \"xor\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   switch (mode)\n@@ -3267,7 +3266,7 @@ output_logical_op (enum machine_mode mode, rtx *operands)\n \t}\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return \"\";\n }\n@@ -3413,7 +3412,7 @@ compute_logical_op_length (enum machine_mode mode, rtx *operands)\n \t}\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return length;\n }\n@@ -3495,7 +3494,7 @@ compute_logical_op_cc (enum machine_mode mode, rtx *operands)\n \t}\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return cc;\n }\n@@ -3633,7 +3632,7 @@ output_h8sx_shift (rtx *operands, int suffix, int optype)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   if (operands[2] == const1_rtx)\n     sprintf (buffer, \"%s.%c\\t%%%c0\", stem, suffix, optype);\n@@ -3914,7 +3913,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Fill in INFO.  Return unless we have SHIFT_SPECIAL.  */\n@@ -3953,12 +3952,9 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n     case QIshift:\n       /* For ASHIFTRT by 7 bits, the sign bit is simply replicated\n \t through the entire value.  */\n-      if (shift_type == SHIFT_ASHIFTRT && count == 7)\n-\t{\n-\t  info->special = \"shll\\t%X0\\n\\tsubx\\t%X0,%X0\";\n-\t  goto end;\n-\t}\n-      abort ();\n+      gcc_assert (shift_type == SHIFT_ASHIFTRT && count == 7);\n+      info->special = \"shll\\t%X0\\n\\tsubx\\t%X0,%X0\";\n+      goto end;\n \n     case HIshift:\n       if (count == 7)\n@@ -4040,7 +4036,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t\t  info->cc_special = CC_SET_ZNV;\n \t\t}\n \t      else /* TARGET_H8300S */\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      goto end;\n \t    }\n \t}\n@@ -4059,7 +4055,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    }\n \t}\n-      abort ();\n+      gcc_unreachable ();\n \n     case SIshift:\n       if (TARGET_H8300 && 8 <= count && count <= 9)\n@@ -4100,7 +4096,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t  switch (shift_type)\n \t    {\n \t    case SHIFT_ASHIFT:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    case SHIFT_LSHIFTRT:\n \t      info->special = \"bld\\t#7,%z0\\n\\tmov.w\\t%e0,%f0\\n\\txor\\t%y0,%y0\\n\\txor\\t%z0,%z0\\n\\trotxl\\t%w0\\n\\trotxl\\t%x0\\n\\trotxl\\t%y0\";\n \t      goto end;\n@@ -4122,7 +4118,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      info->cc_special = CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       else if ((TARGET_H8300 && 16 <= count && count <= 20)\n@@ -4227,7 +4223,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t\tinfo->special = \"sub.w\\t%f0,%f0\\n\\trotl.l\\t#2,%S0\\n\\trotl.l\\t#2,%S0\\n\\textu.l\\t%S0\";\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       else if (!TARGET_H8300 && count == 29)\n@@ -4253,7 +4249,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t\t}\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       else if (!TARGET_H8300 && count == 30)\n@@ -4273,7 +4269,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t\tinfo->special = \"sub.w\\t%f0,%f0\\n\\trotl.l\\t#2,%S0\\n\\textu.l\\t%S0\";\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       else if (count == 31)\n@@ -4312,10 +4308,10 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t\t}\n \t    }\n \t}\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n  end:\n@@ -4365,7 +4361,7 @@ h8300_shift_needs_scratch_p (int count, enum machine_mode mode)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* On H8/300H, count == 8 uses a scratch register.  */\n@@ -4385,6 +4381,7 @@ output_a_shift (rtx *operands)\n   enum shift_type shift_type;\n   enum shift_mode shift_mode;\n   struct shift_info info;\n+  int n;\n \n   loopend_lab++;\n \n@@ -4400,7 +4397,7 @@ output_a_shift (rtx *operands)\n       shift_mode = SIshift;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   switch (code)\n@@ -4415,115 +4412,117 @@ output_a_shift (rtx *operands)\n       shift_type = SHIFT_ASHIFT;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      /* This case must be taken care of by one of the two splitters\n-\t that convert a variable shift into a loop.  */\n-      abort ();\n-    }\n-  else\n+  /* This case must be taken care of by one of the two splitters\n+     that convert a variable shift into a loop.  */\n+  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n+  \n+  n = INTVAL (operands[2]);\n+\n+  /* If the count is negative, make it 0.  */\n+  if (n < 0)\n+    n = 0;\n+  /* If the count is too big, truncate it.\n+     ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n+     do the intuitive thing.  */\n+  else if ((unsigned int) n > GET_MODE_BITSIZE (mode))\n+    n = GET_MODE_BITSIZE (mode);\n+\n+  get_shift_alg (shift_type, shift_mode, n, &info);\n+  \n+  switch (info.alg)\n     {\n-      int n = INTVAL (operands[2]);\n-\n-      /* If the count is negative, make it 0.  */\n-      if (n < 0)\n-\tn = 0;\n-      /* If the count is too big, truncate it.\n-         ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n-\t do the intuitive thing.  */\n-      else if ((unsigned int) n > GET_MODE_BITSIZE (mode))\n-\tn = GET_MODE_BITSIZE (mode);\n+    case SHIFT_SPECIAL:\n+      output_asm_insn (info.special, operands);\n+      /* Fall through.  */\n \n-      get_shift_alg (shift_type, shift_mode, n, &info);\n+    case SHIFT_INLINE:\n+      n = info.remainder;\n \n-      switch (info.alg)\n+      /* Emit two bit shifts first.  */\n+      if (info.shift2 != NULL)\n \t{\n-\tcase SHIFT_SPECIAL:\n-\t  output_asm_insn (info.special, operands);\n-\t  /* Fall through.  */\n-\n-\tcase SHIFT_INLINE:\n-\t  n = info.remainder;\n-\n-\t  /* Emit two bit shifts first.  */\n-\t  if (info.shift2 != NULL)\n-\t    {\n-\t      for (; n > 1; n -= 2)\n-\t\toutput_asm_insn (info.shift2, operands);\n-\t    }\n-\n-\t  /* Now emit one bit shifts for any residual.  */\n-\t  for (; n > 0; n--)\n-\t    output_asm_insn (info.shift1, operands);\n-\t  return \"\";\n+\t  for (; n > 1; n -= 2)\n+\t    output_asm_insn (info.shift2, operands);\n+\t}\n \n-\tcase SHIFT_ROT_AND:\n+      /* Now emit one bit shifts for any residual.  */\n+      for (; n > 0; n--)\n+\toutput_asm_insn (info.shift1, operands);\n+      return \"\";\n+      \n+    case SHIFT_ROT_AND:\n+      {\n+\tint m = GET_MODE_BITSIZE (mode) - n;\n+\tconst int mask = (shift_type == SHIFT_ASHIFT\n+\t\t\t  ? ((1 << m) - 1) << n\n+\t\t\t  : (1 << m) - 1);\n+\tchar insn_buf[200];\n+\n+\t/* Not all possibilities of rotate are supported.  They shouldn't\n+\t   be generated, but let's watch for 'em.  */\n+\tgcc_assert (info.shift1);\n+\t\n+\t/* Emit two bit rotates first.  */\n+\tif (info.shift2 != NULL)\n \t  {\n-\t    int m = GET_MODE_BITSIZE (mode) - n;\n-\t    const int mask = (shift_type == SHIFT_ASHIFT\n-\t\t\t      ? ((1 << m) - 1) << n\n-\t\t\t      : (1 << m) - 1);\n-\t    char insn_buf[200];\n-\n-\t    /* Not all possibilities of rotate are supported.  They shouldn't\n-\t       be generated, but let's watch for 'em.  */\n-\t    if (info.shift1 == 0)\n-\t      abort ();\n-\n-\t    /* Emit two bit rotates first.  */\n-\t    if (info.shift2 != NULL)\n-\t      {\n-\t\tfor (; m > 1; m -= 2)\n-\t\t  output_asm_insn (info.shift2, operands);\n-\t      }\n+\t    for (; m > 1; m -= 2)\n+\t      output_asm_insn (info.shift2, operands);\n+\t  }\n+\t\n+\t/* Now single bit rotates for any residual.  */\n+\tfor (; m > 0; m--)\n+\t  output_asm_insn (info.shift1, operands);\n+\t\n+\t/* Now mask off the high bits.  */\n+\tswitch (mode)\n+\t  {\n+\t  case QImode:\n+\t    sprintf (insn_buf, \"and\\t#%d,%%X0\", mask);\n+\t    break;\n \n-\t    /* Now single bit rotates for any residual.  */\n-\t    for (; m > 0; m--)\n-\t      output_asm_insn (info.shift1, operands);\n+\t  case HImode:\n+\t    gcc_assert (TARGET_H8300H || TARGET_H8300S);\n+\t    sprintf (insn_buf, \"and.w\\t#%d,%%T0\", mask);\n+\t    break;\n \n-\t    /* Now mask off the high bits.  */\n-\t    if (mode == QImode)\n-\t      sprintf (insn_buf, \"and\\t#%d,%%X0\", mask);\n-\t    else if (mode == HImode && (TARGET_H8300H || TARGET_H8300S))\n-\t      sprintf (insn_buf, \"and.w\\t#%d,%%T0\", mask);\n-\t    else\n-\t      abort ();\n-\n-\t    output_asm_insn (insn_buf, operands);\n-\t    return \"\";\n+\t  default:\n+\t    gcc_unreachable ();\n \t  }\n \n-\tcase SHIFT_LOOP:\n-\t  /* A loop to shift by a \"large\" constant value.\n-\t     If we have shift-by-2 insns, use them.  */\n-\t  if (info.shift2 != NULL)\n-\t    {\n-\t      fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n / 2,\n-\t\t       names_big[REGNO (operands[4])]);\n-\t      fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n-\t      output_asm_insn (info.shift2, operands);\n-\t      output_asm_insn (\"add\t#0xff,%X4\", operands);\n-\t      fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n-\t      if (n % 2)\n-\t\toutput_asm_insn (info.shift1, operands);\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n,\n-\t\t       names_big[REGNO (operands[4])]);\n-\t      fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n-\t      output_asm_insn (info.shift1, operands);\n-\t      output_asm_insn (\"add\t#0xff,%X4\", operands);\n-\t      fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n-\t    }\n-\t  return \"\";\n+\toutput_asm_insn (insn_buf, operands);\n+\treturn \"\";\n+      }\n \n-\tdefault:\n-\t  abort ();\n+    case SHIFT_LOOP:\n+      /* A loop to shift by a \"large\" constant value.\n+\t If we have shift-by-2 insns, use them.  */\n+      if (info.shift2 != NULL)\n+\t{\n+\t  fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n / 2,\n+\t\t   names_big[REGNO (operands[4])]);\n+\t  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n+\t  output_asm_insn (info.shift2, operands);\n+\t  output_asm_insn (\"add\t#0xff,%X4\", operands);\n+\t  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n+\t  if (n % 2)\n+\t    output_asm_insn (info.shift1, operands);\n+\t}\n+      else\n+\t{\n+\t  fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n,\n+\t\t   names_big[REGNO (operands[4])]);\n+\t  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n+\t  output_asm_insn (info.shift1, operands);\n+\t  output_asm_insn (\"add\t#0xff,%X4\", operands);\n+\t  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n \t}\n+      return \"\";\n+      \n+    default:\n+      gcc_unreachable ();\n     }\n }\n \n@@ -4566,7 +4565,7 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n       shift_mode = SIshift;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   switch (code)\n@@ -4581,7 +4580,7 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n       shift_type = SHIFT_ASHIFT;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (GET_CODE (operands[2]) != CONST_INT)\n@@ -4639,8 +4638,7 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n \n \t    /* Not all possibilities of rotate are supported.  They shouldn't\n \t       be generated, but let's watch for 'em.  */\n-\t    if (info.shift1 == 0)\n-\t      abort ();\n+\t    gcc_assert (info.shift1);\n \n \t    if (info.shift2 != NULL)\n \t      {\n@@ -4660,12 +4658,11 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n \t\twlength += 2;\n \t\tbreak;\n \t      case SImode:\n-\t\tif (TARGET_H8300)\n-\t\t  abort ();\n+\t\tgcc_assert (!TARGET_H8300);\n \t\twlength += 3;\n \t\tbreak;\n \t      default:\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      }\n \t    return 2 * wlength;\n \t  }\n@@ -4686,7 +4683,7 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n \t  return 2 * wlength;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -4702,7 +4699,8 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n   enum shift_type shift_type;\n   enum shift_mode shift_mode;\n   struct shift_info info;\n-\n+  int n;\n+  \n   switch (mode)\n     {\n     case QImode:\n@@ -4715,7 +4713,7 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n       shift_mode = SIshift;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   switch (code)\n@@ -4730,58 +4728,53 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n       shift_type = SHIFT_ASHIFT;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      /* This case must be taken care of by one of the two splitters\n-\t that convert a variable shift into a loop.  */\n-      abort ();\n-    }\n-  else\n+  /* This case must be taken care of by one of the two splitters\n+     that convert a variable shift into a loop.  */\n+  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n+  \n+  n = INTVAL (operands[2]);\n+\n+  /* If the count is negative, make it 0.  */\n+  if (n < 0)\n+    n = 0;\n+  /* If the count is too big, truncate it.\n+     ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n+     do the intuitive thing.  */\n+  else if ((unsigned int) n > GET_MODE_BITSIZE (mode))\n+    n = GET_MODE_BITSIZE (mode);\n+  \n+  get_shift_alg (shift_type, shift_mode, n, &info);\n+  \n+  switch (info.alg)\n     {\n-      int n = INTVAL (operands[2]);\n-\n-      /* If the count is negative, make it 0.  */\n-      if (n < 0)\n-\tn = 0;\n-      /* If the count is too big, truncate it.\n-         ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n-\t do the intuitive thing.  */\n-      else if ((unsigned int) n > GET_MODE_BITSIZE (mode))\n-\tn = GET_MODE_BITSIZE (mode);\n+    case SHIFT_SPECIAL:\n+      if (info.remainder == 0)\n+\treturn info.cc_special;\n \n-      get_shift_alg (shift_type, shift_mode, n, &info);\n+      /* Fall through.  */\n \n-      switch (info.alg)\n+    case SHIFT_INLINE:\n+      return info.cc_inline;\n+      \n+    case SHIFT_ROT_AND:\n+      /* This case always ends with an and instruction.  */\n+      return CC_SET_ZNV;\n+      \n+    case SHIFT_LOOP:\n+      /* A loop to shift by a \"large\" constant value.\n+\t If we have shift-by-2 insns, use them.  */\n+      if (info.shift2 != NULL)\n \t{\n-\tcase SHIFT_SPECIAL:\n-\t  if (info.remainder == 0)\n-\t    return info.cc_special;\n-\n-\t  /* Fall through.  */\n-\n-\tcase SHIFT_INLINE:\n-\t  return info.cc_inline;\n-\n-\tcase SHIFT_ROT_AND:\n-\t  /* This case always ends with an and instruction.  */\n-\t  return CC_SET_ZNV;\n-\n-\tcase SHIFT_LOOP:\n-\t  /* A loop to shift by a \"large\" constant value.\n-\t     If we have shift-by-2 insns, use them.  */\n-\t  if (info.shift2 != NULL)\n-\t    {\n-\t      if (n % 2)\n-\t\treturn info.cc_inline;\n-\t    }\n-\t  return CC_CLOBBER;\n-\n-\tdefault:\n-\t  abort ();\n+\t  if (n % 2)\n+\t    return info.cc_inline;\n \t}\n+      return CC_CLOBBER;\n+      \n+    default:\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -4833,7 +4826,7 @@ expand_a_rotate (rtx operands[])\n \t  emit_insn (gen_rotlsi3_1 (dst, dst, const1_rtx));\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Decrement the counter by 1.  */\n@@ -4861,7 +4854,7 @@ expand_a_rotate (rtx operands[])\n \t  emit_insn (gen_rotlsi3_1 (dst, dst, rotate_amount));\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -4882,8 +4875,7 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n   int amount;\n   enum machine_mode mode = GET_MODE (dst);\n \n-  if (GET_CODE (rotate_amount) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (rotate_amount) == CONST_INT);\n \n   switch (mode)\n     {\n@@ -4897,7 +4889,7 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n       rotate_mode = SIshift;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   switch (code)\n@@ -4909,7 +4901,7 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n       rotate_type = SHIFT_LSHIFTRT;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   amount = INTVAL (rotate_amount);\n@@ -4953,7 +4945,7 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Adjust AMOUNT and flip the direction.  */\n@@ -4988,8 +4980,7 @@ compute_a_rotate_length (rtx *operands)\n   int amount;\n   unsigned int length = 0;\n \n-  if (GET_CODE (amount_rtx) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (amount_rtx) == CONST_INT);\n \n   amount = INTVAL (amount_rtx);\n \n@@ -5083,7 +5074,7 @@ fix_bit_operand (rtx *operands, enum rtx_code code)\n \temit_insn (gen_xorqi3_1 (res, operands[1], operands[2]));\n \tbreak;\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n     emit_insn (gen_movqi (operands[0], res));\n   }\n@@ -5598,9 +5589,9 @@ h8300_regs_ok_for_stm (int n, rtx operands[])\n \t      && REGNO (operands[1]) == 1\n \t      && REGNO (operands[2]) == 2\n \t      && REGNO (operands[3]) == 3);\n+    default:\n+      gcc_unreachable ();\n     }\n-\n-  abort ();\n }\n \n /* Return nonzero if register OLD_REG can be renamed to register NEW_REG.  */"}, {"sha": "0d3cd6e3a4658ec981ca2856c09aea95dc64a7c1", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4408725333a495b8b5fa2eed58fb94627cacff/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4408725333a495b8b5fa2eed58fb94627cacff/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=8c4408725333a495b8b5fa2eed58fb94627cacff", "patch": "@@ -423,7 +423,7 @@\n     case 5:\n       return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\"\n   [(set (attr \"length\")\n@@ -844,7 +844,7 @@\n     case 5:\n       return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\"\n   [(set (attr \"length\")\n@@ -2604,7 +2604,7 @@\n     return \\\"mov.l\\\\ter0,@-er7\\;stc\\\\tccr,r0l\\;mov.b\\\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\\\t#128,ccr\\\";\n   else if (TARGET_H8300S)\n     return \\\"stc\\texr,@-er7\\;mov.l\\\\ter0,@-er7\\;stc\\tccr,r0l\\;mov.b\\tr0l,@(6,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\t#128,ccr\\\";\n-    abort ();\n+  gcc_unreachable ();\n }\"\n   [(set_attr \"length\" \"20\")])\n \f"}]}