{"sha": "2e1e8c5d7a0816021f450fc158441452993e9477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxZThjNWQ3YTA4MTYwMjFmNDUwZmMxNTg0NDE0NTI5OTNlOTQ3Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-06-21T16:28:32Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-06-21T16:28:32Z"}, "message": "Makefile.in (build/genattrtab.o): Depend on vecprim.h.\n\n\t* Makefile.in (build/genattrtab.o): Depend on vecprim.h.\n\t* genattrtab.c: Include vecprim.h.\n\t(cached_attrs, cached_attr_count, attrs_seen_once,\n\tattrs_seen_more_than_once, attrs_to_cache, attrs_cached_inside,\n\tattrs_cached_after): New variables.\n\t(find_attrs_to_cache): New function.\n\t(FLG_BITWISE, FLG_AFTER, FLG_INSIDE, FLG_OUTSIDE_AND): Define.\n\t(write_test_expr): Add attrs_cached argument, return it too,\n\tattempt to cache non-const attributes used more than once in\n\ta single case handling.\n\t(write_attr_get): Use find_attrs_to_cache, for caching candidates\n\temit cached_* variables.  Adjust write_attr_set callers.\n\t(write_attr_set): Add attrs_cached attribute, use find_attrs_to_cache\n\tto find attributes that should be cached in this block.  Adjust\n\twrite_test_expr callers.\n\t(write_attr_case): Clear attrs_to_cache.  Adjust write_attr_set\n\tcallers.\n\t(make_automaton_attrs): Adjust write_test_expr caller.\n\nFrom-SVN: r161094", "tree": {"sha": "29f14e53c48d6489b20c741647254ece6ecda2ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29f14e53c48d6489b20c741647254ece6ecda2ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e1e8c5d7a0816021f450fc158441452993e9477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1e8c5d7a0816021f450fc158441452993e9477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1e8c5d7a0816021f450fc158441452993e9477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1e8c5d7a0816021f450fc158441452993e9477/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b21299c80f98e22732559357c4af025c2749283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b21299c80f98e22732559357c4af025c2749283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b21299c80f98e22732559357c4af025c2749283"}], "stats": {"total": 294, "additions": 257, "deletions": 37}, "files": [{"sha": "95491cc5a1f08268ff6ebbfa7006f67b81f77656", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1e8c5d7a0816021f450fc158441452993e9477/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1e8c5d7a0816021f450fc158441452993e9477/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e1e8c5d7a0816021f450fc158441452993e9477", "patch": "@@ -1,5 +1,24 @@\n 2010-06-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* Makefile.in (build/genattrtab.o): Depend on vecprim.h.\n+\t* genattrtab.c: Include vecprim.h.\n+\t(cached_attrs, cached_attr_count, attrs_seen_once,\n+\tattrs_seen_more_than_once, attrs_to_cache, attrs_cached_inside,\n+\tattrs_cached_after): New variables.\n+\t(find_attrs_to_cache): New function.\n+\t(FLG_BITWISE, FLG_AFTER, FLG_INSIDE, FLG_OUTSIDE_AND): Define.\n+\t(write_test_expr): Add attrs_cached argument, return it too,\n+\tattempt to cache non-const attributes used more than once in\n+\ta single case handling.\n+\t(write_attr_get): Use find_attrs_to_cache, for caching candidates\n+\temit cached_* variables.  Adjust write_attr_set callers.\n+\t(write_attr_set): Add attrs_cached attribute, use find_attrs_to_cache\n+\tto find attributes that should be cached in this block.  Adjust\n+\twrite_test_expr callers.\n+\t(write_attr_case): Clear attrs_to_cache.  Adjust write_attr_set\n+\tcallers.\n+\t(make_automaton_attrs): Adjust write_test_expr caller.\n+\n \t* Makefile.in (cfgexpand.o): Depend on $(INSN_ATTR_H).\n \t* genattrtab.c (check_tune_attr, find_tune_attr): New functions.\n \t(make_automaton_attrs): If find_tune_attr returns non-NULL,"}, {"sha": "8110318531a5a476e259474106a3746db30ae472", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1e8c5d7a0816021f450fc158441452993e9477/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1e8c5d7a0816021f450fc158441452993e9477/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2e1e8c5d7a0816021f450fc158441452993e9477", "patch": "@@ -3802,7 +3802,7 @@ build/genattr.o : genattr.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)\t\\\n-  $(READ_MD_H) gensupport.h\n+  $(READ_MD_H) gensupport.h vecprim.h\n build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(VEC_H)\t\\\n   $(HASHTAB_H) gensupport.h"}, {"sha": "a86332d49e3cafbb6e0cce1d5508f9f50f75363c", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 237, "deletions": 36, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1e8c5d7a0816021f450fc158441452993e9477/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1e8c5d7a0816021f450fc158441452993e9477/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2e1e8c5d7a0816021f450fc158441452993e9477", "patch": "@@ -113,6 +113,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"errors.h\"\n #include \"read-md.h\"\n #include \"gensupport.h\"\n+#include \"vecprim.h\"\n \n /* Flags for make_internal_attr's `special' parameter.  */\n #define ATTR_NONE\t\t0\n@@ -277,7 +278,7 @@ static void write_attr_valueq\t   (struct attr_desc *, const char *);\n static struct attr_value *find_most_used  (struct attr_desc *);\n static void write_attr_set\t   (struct attr_desc *, int, rtx,\n \t\t\t\t    const char *, const char *, rtx,\n-\t\t\t\t    int, int);\n+\t\t\t\t    int, int, unsigned int);\n static void write_attr_case\t   (struct attr_desc *, struct attr_value *,\n \t\t\t\t    int, const char *, const char *, int, rtx);\n static void write_attr_value\t   (struct attr_desc *, rtx);\n@@ -3126,16 +3127,98 @@ gen_delay (rtx def, int lineno)\n   delays = delay;\n }\n \n-/* Given a piece of RTX, print a C expression to test its truth value.\n-   We use AND and IOR both for logical and bit-wise operations, so\n-   interpret them as logical unless they are inside a comparison expression.\n-   The first bit of FLAGS will be nonzero in that case.\n+/* Names of attributes that could be possibly cached.  */\n+static const char *cached_attrs[32];\n+/* Number of such attributes.  */\n+static int cached_attr_count;\n+/* Bitmasks of possibly cached attributes.  */\n+static unsigned int attrs_seen_once, attrs_seen_more_than_once;\n+static unsigned int attrs_to_cache;\n+static unsigned int attrs_cached_inside, attrs_cached_after;\n \n-   Set the second bit of FLAGS to make references to attribute values use\n-   a cached local variable instead of calling a function.  */\n+/* Finds non-const attributes that could be possibly cached.\n+   When create is TRUE, fills in cached_attrs array.\n+   Computes ATTRS_SEEN_ONCE and ATTRS_SEEN_MORE_THAN_ONCE\n+   bitmasks.  */\n \n static void\n-write_test_expr (rtx exp, int flags)\n+find_attrs_to_cache (rtx exp, bool create)\n+{\n+  int i;\n+  const char *name;\n+  struct attr_desc *attr;\n+\n+  if (exp == NULL)\n+    return;\n+\n+  switch (GET_CODE (exp))\n+    {\n+    case NOT:\n+      if (GET_CODE (XEXP (exp, 0)) == EQ_ATTR)\n+\tfind_attrs_to_cache (XEXP (exp, 0), create);\n+      return;\n+\n+    case EQ_ATTR:\n+      name = XSTR (exp, 0);\n+      if (name == alternative_name)\n+\treturn;\n+      for (i = 0; i < cached_attr_count; i++)\n+\tif (name == cached_attrs[i])\n+\t  {\n+\t    if ((attrs_seen_once & (1U << i)) != 0)\n+\t      attrs_seen_more_than_once |= (1U << i);\n+\t    else\n+\t      attrs_seen_once |= (1U << i);\n+\t    return;\n+\t  }\n+      if (!create)\n+\treturn;\n+      attr = find_attr (&name, 0);\n+      gcc_assert (attr);\n+      if (attr->is_const)\n+\treturn;\n+      if (cached_attr_count == 32)\n+\treturn;\n+      cached_attrs[cached_attr_count] = XSTR (exp, 0);\n+      attrs_seen_once |= (1U << cached_attr_count);\n+      cached_attr_count++;\n+      return;\n+\n+    case AND:\n+    case IOR:\n+      find_attrs_to_cache (XEXP (exp, 0), create);\n+      find_attrs_to_cache (XEXP (exp, 1), create);\n+      return;\n+\n+    case COND:\n+      for (i = 0; i < XVECLEN (exp, 0); i += 2)\n+\tfind_attrs_to_cache (XVECEXP (exp, 0, i), create);\n+      return;\n+\n+    default:\n+      return;\n+    }\n+}\n+\n+/* Given a piece of RTX, print a C expression to test its truth value.\n+   We use AND and IOR both for logical and bit-wise operations, so\n+   interpret them as logical unless they are inside a comparison expression.  */\n+\n+/* Interpret AND/IOR as bit-wise operations instead of logical.  */\n+#define FLG_BITWISE\t\t1\n+/* Set if cached attribute will be known initialized in else block after\n+   this condition.  This is true for LHS of toplevel && and || and\n+   even for RHS of ||, but not for RHS of &&.  */\n+#define FLG_AFTER\t\t2\n+/* Set if cached attribute will be known initialized in then block after\n+   this condition.  This is true for LHS of toplevel && and || and\n+   even for RHS of &&, but not for RHS of ||.  */\n+#define FLG_INSIDE\t\t4\n+/* Cleared when an operand of &&.  */\n+#define FLG_OUTSIDE_AND\t\t8\n+\n+static unsigned int\n+write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n {\n   int comparison_operator = 0;\n   RTX_CODE code;\n@@ -3157,12 +3240,30 @@ write_test_expr (rtx exp, int flags)\n     case EQ: case NE:\n     case GE: case GT:\n     case LE: case LT:\n-      comparison_operator = 1;\n+      comparison_operator = FLG_BITWISE;\n \n     case PLUS:   case MINUS:  case MULT:     case DIV:      case MOD:\n     case AND:    case IOR:    case XOR:\n     case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n-      write_test_expr (XEXP (exp, 0), flags | comparison_operator);\n+      if ((code != AND && code != IOR) || (flags & FLG_BITWISE))\n+\t{\n+\t  flags &= ~(FLG_AFTER | FLG_INSIDE | FLG_OUTSIDE_AND);\n+\t  write_test_expr (XEXP (exp, 0), attrs_cached,\n+\t\t\t   flags | comparison_operator);\n+\t}\n+      else\n+\t{\n+\t  if (code == AND)\n+\t    flags &= ~FLG_OUTSIDE_AND;\n+\t  if (GET_CODE (XEXP (exp, 0)) == code\n+\t      || GET_CODE (XEXP (exp, 0)) == EQ_ATTR\n+\t      || (GET_CODE (XEXP (exp, 0)) == NOT\n+\t\t  && GET_CODE (XEXP (XEXP (exp, 0), 0)) == EQ_ATTR))\n+\t    attrs_cached\n+\t      = write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n+\t  else\n+\t    write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n+\t}\n       switch (code)\n \t{\n \tcase EQ:\n@@ -3211,13 +3312,13 @@ write_test_expr (rtx exp, int flags)\n \t  printf (\" %% \");\n \t  break;\n \tcase AND:\n-\t  if (flags & 1)\n+\t  if (flags & FLG_BITWISE)\n \t    printf (\" & \");\n \t  else\n \t    printf (\" && \");\n \t  break;\n \tcase IOR:\n-\t  if (flags & 1)\n+\t  if (flags & FLG_BITWISE)\n \t    printf (\" | \");\n \t  else\n \t    printf (\" || \");\n@@ -3236,15 +3337,49 @@ write_test_expr (rtx exp, int flags)\n \t  gcc_unreachable ();\n \t}\n \n-      write_test_expr (XEXP (exp, 1), flags | comparison_operator);\n+      if (code == AND)\n+\t{\n+\t  /* For if (something && (cached_x = get_attr_x (insn)) == X)\n+\t     cached_x is only known to be initialized in then block.  */\n+\t  flags &= ~FLG_AFTER;\n+\t}\n+      else if (code == IOR)\n+\t{\n+\t  if (flags & FLG_OUTSIDE_AND)\n+\t    /* For if (something || (cached_x = get_attr_x (insn)) == X)\n+\t       cached_x is only known to be initialized in else block\n+\t       and else if conditions.  */\n+\t    flags &= ~FLG_INSIDE;\n+\t  else\n+\t    /* For if ((something || (cached_x = get_attr_x (insn)) == X)\n+\t\t       && something_else)\n+\t       cached_x is not know to be initialized anywhere.  */\n+\t    flags &= ~(FLG_AFTER | FLG_INSIDE);\n+\t}\n+      if ((code == AND || code == IOR)\n+\t  && (GET_CODE (XEXP (exp, 1)) == code\n+\t      || GET_CODE (XEXP (exp, 1)) == EQ_ATTR\n+\t      || (GET_CODE (XEXP (exp, 1)) == NOT\n+\t\t  && GET_CODE (XEXP (XEXP (exp, 1), 0)) == EQ_ATTR)))\n+\tattrs_cached\n+\t  = write_test_expr (XEXP (exp, 1), attrs_cached, flags);\n+      else\n+\twrite_test_expr (XEXP (exp, 1), attrs_cached,\n+\t\t\t flags | comparison_operator);\n       break;\n \n     case NOT:\n       /* Special-case (not (eq_attrq \"alternative\" \"x\")) */\n-      if (! (flags & 1) && GET_CODE (XEXP (exp, 0)) == EQ_ATTR\n-\t  && XSTR (XEXP (exp, 0), 0) == alternative_name)\n+      if (! (flags & FLG_BITWISE) && GET_CODE (XEXP (exp, 0)) == EQ_ATTR)\n \t{\n-\t  printf (\"which_alternative != %s\", XSTR (XEXP (exp, 0), 1));\n+\t  if (XSTR (XEXP (exp, 0), 0) == alternative_name)\n+\t    {\n+\t      printf (\"which_alternative != %s\", XSTR (XEXP (exp, 0), 1));\n+\t      break;\n+\t    }\n+\n+\t  printf (\"! \");\n+\t  attrs_cached = write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n \t  break;\n \t}\n \n@@ -3255,7 +3390,7 @@ write_test_expr (rtx exp, int flags)\n       switch (code)\n \t{\n \tcase NOT:\n-\t  if (flags & 1)\n+\t  if (flags & FLG_BITWISE)\n \t    printf (\"~ \");\n \t  else\n \t    printf (\"! \");\n@@ -3270,14 +3405,15 @@ write_test_expr (rtx exp, int flags)\n \t  gcc_unreachable ();\n \t}\n \n-      write_test_expr (XEXP (exp, 0), flags);\n+      flags &= ~(FLG_AFTER | FLG_INSIDE | FLG_OUTSIDE_AND);\n+      write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n       break;\n \n     case EQ_ATTR_ALT:\n \t{\n \t  int set = XINT (exp, 0), bit = 0;\n \n-\t  if (flags & 1)\n+\t  if (flags & FLG_BITWISE)\n \t    fatal (\"EQ_ATTR_ALT not valid inside comparison\");\n \n \t  if (!set)\n@@ -3323,7 +3459,7 @@ write_test_expr (rtx exp, int flags)\n        have been removed by optimization.   Handle \"alternative\"\n        specially and give error if EQ_ATTR present inside a comparison.  */\n     case EQ_ATTR:\n-      if (flags & 1)\n+      if (flags & FLG_BITWISE)\n \tfatal (\"EQ_ATTR not valid inside comparison\");\n \n       if (XSTR (exp, 0) == alternative_name)\n@@ -3340,12 +3476,26 @@ write_test_expr (rtx exp, int flags)\n \t{\n \t  write_test_expr (evaluate_eq_attr (exp, attr,\n \t\t\t\t\t     attr->default_val->value, -2, -2),\n-\t\t\t   flags);\n+\t\t\t   attrs_cached, 0);\n \t}\n       else\n \t{\n-\t  if (flags & 2)\n-\t    printf (\"attr_%s\", attr->name);\n+\t  int i;\n+\t  for (i = 0; i < cached_attr_count; i++)\n+\t    if (attr->name == cached_attrs[i])\n+\t      break;\n+\t  if (i < cached_attr_count && (attrs_cached & (1U << i)) != 0)\n+\t    printf (\"cached_%s\", attr->name);\n+\t  else if (i < cached_attr_count && (attrs_to_cache & (1U << i)) != 0)\n+\t    {\n+\t      printf (\"(cached_%s = get_attr_%s (insn))\",\n+\t\t      attr->name, attr->name);\n+\t      if (flags & FLG_AFTER)\n+\t\tattrs_cached_after |= (1U << i);\n+\t      if (flags & FLG_INSIDE)\n+\t\tattrs_cached_inside |= (1U << i);\n+\t      attrs_cached |= (1U << i);\n+\t    }\n \t  else\n \t    printf (\"get_attr_%s (insn)\", attr->name);\n \t  printf (\" == \");\n@@ -3355,7 +3505,7 @@ write_test_expr (rtx exp, int flags)\n \n     /* Comparison test of flags for define_delays.  */\n     case ATTR_FLAG:\n-      if (flags & 1)\n+      if (flags & FLG_BITWISE)\n \tfatal (\"ATTR_FLAG not valid inside comparison\");\n       printf (\"(flags & ATTR_FLAG_%s) != 0\", XSTR (exp, 0));\n       break;\n@@ -3407,11 +3557,11 @@ write_test_expr (rtx exp, int flags)\n       break;\n \n     case IF_THEN_ELSE:\n-      write_test_expr (XEXP (exp, 0), flags & 2);\n+      write_test_expr (XEXP (exp, 0), attrs_cached, 0);\n       printf (\" ? \");\n-      write_test_expr (XEXP (exp, 1), flags | 1);\n+      write_test_expr (XEXP (exp, 1), attrs_cached, FLG_BITWISE);\n       printf (\" : \");\n-      write_test_expr (XEXP (exp, 2), flags | 1);\n+      write_test_expr (XEXP (exp, 2), attrs_cached, FLG_BITWISE);\n       break;\n \n     default:\n@@ -3420,6 +3570,7 @@ write_test_expr (rtx exp, int flags)\n     }\n \n   printf (\")\");\n+  return attrs_cached;\n }\n \n /* Given an attribute value, return the maximum CONST_STRING argument\n@@ -3624,6 +3775,7 @@ static void\n write_attr_get (struct attr_desc *attr)\n {\n   struct attr_value *av, *common_av;\n+  int i, j;\n \n   /* Find the most used attribute value.  Handle that as the `default' of the\n      switch we will generate.  */\n@@ -3653,16 +3805,48 @@ write_attr_get (struct attr_desc *attr)\n \tif (av->num_insns == 1)\n \t  write_attr_set (attr, 2, av->value, \"return\", \";\",\n \t\t\t  true_rtx, av->first_insn->def->insn_code,\n-\t\t\t  av->first_insn->def->insn_index);\n+\t\t\t  av->first_insn->def->insn_index, 0);\n \telse if (av->num_insns != 0)\n \t  write_attr_set (attr, 2, av->value, \"return\", \";\",\n-\t\t\t  true_rtx, -2, 0);\n+\t\t\t  true_rtx, -2, 0, 0);\n \n       printf (\"}\\n\\n\");\n       return;\n     }\n \n   printf (\"{\\n\");\n+\n+  /* Find attributes that are worth caching in the conditions.  */\n+  cached_attr_count = 0;\n+  attrs_seen_more_than_once = 0;\n+  for (av = attr->first_value; av; av = av->next)\n+    {\n+      attrs_seen_once = 0;\n+      find_attrs_to_cache (av->value, true);\n+    }\n+  /* Remove those that aren't worth caching from the array.  */\n+  for (i = 0, j = 0; i < cached_attr_count; i++)\n+    if ((attrs_seen_more_than_once & (1U << i)) != 0)\n+      {\n+\tconst char *name = cached_attrs[i];\n+\tstruct attr_desc *cached_attr;\n+\tif (i != j)\n+\t  cached_attrs[j] = name;\n+\tcached_attr = find_attr (&name, 0);\n+\tgcc_assert (cached_attr && cached_attr->is_const == 0);\n+\tif (cached_attr->enum_name)\n+\t  printf (\"  enum %s\", cached_attr->enum_name);\n+\telse if (!cached_attr->is_numeric)\n+\t  printf (\"  enum attr_%s\", cached_attr->name);\n+\telse\n+\t  printf (\"  int\");\n+\tprintf (\" cached_%s ATTRIBUTE_UNUSED;\\n\", name);\n+\tj++;\n+      }\n+  cached_attr_count = j;\n+  if (cached_attr_count)\n+    printf (\"\\n\");\n+\n   printf (\"  switch (recog_memoized (insn))\\n\");\n   printf (\"    {\\n\");\n \n@@ -3672,6 +3856,7 @@ write_attr_get (struct attr_desc *attr)\n \n   write_attr_case (attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n   printf (\"    }\\n}\\n\\n\");\n+  cached_attr_count = 0;\n }\n \n /* Given an AND tree of known true terms (because we are inside an `if' with\n@@ -3710,7 +3895,7 @@ eliminate_known_true (rtx known_true, rtx exp, int insn_code, int insn_index)\n static void\n write_attr_set (struct attr_desc *attr, int indent, rtx value,\n \t\tconst char *prefix, const char *suffix, rtx known_true,\n-\t\tint insn_code, int insn_index)\n+\t\tint insn_code, int insn_index, unsigned int attrs_cached)\n {\n   if (GET_CODE (value) == COND)\n     {\n@@ -3722,6 +3907,15 @@ write_attr_set (struct attr_desc *attr, int indent, rtx value,\n       int first_if = 1;\n       int i;\n \n+      if (cached_attr_count)\n+\t{\n+\t  attrs_seen_once = 0;\n+\t  attrs_seen_more_than_once = 0;\n+\t  for (i = 0; i < XVECLEN (value, 0); i += 2)\n+\t    find_attrs_to_cache (XVECEXP (value, 0, i), false);\n+\t  attrs_to_cache |= attrs_seen_more_than_once;\n+\t}\n+\n       for (i = 0; i < XVECLEN (value, 0); i += 2)\n \t{\n \t  rtx testexp;\n@@ -3752,17 +3946,22 @@ write_attr_set (struct attr_desc *attr, int indent, rtx value,\n \t  if (inner_true == false_rtx)\n \t    continue;\n \n+\t  attrs_cached_inside = attrs_cached;\n+\t  attrs_cached_after = attrs_cached;\n \t  write_indent (indent);\n \t  printf (\"%sif \", first_if ? \"\" : \"else \");\n \t  first_if = 0;\n-\t  write_test_expr (testexp, 0);\n+\t  write_test_expr (testexp, attrs_cached,\n+\t\t\t   (FLG_AFTER | FLG_INSIDE | FLG_OUTSIDE_AND));\n+\t  attrs_cached = attrs_cached_after;\n \t  printf (\"\\n\");\n \t  write_indent (indent + 2);\n \t  printf (\"{\\n\");\n \n \t  write_attr_set (attr, indent + 4,\n \t\t\t  XVECEXP (value, 0, i + 1), prefix, suffix,\n-\t\t\t  inner_true, insn_code, insn_index);\n+\t\t\t  inner_true, insn_code, insn_index,\n+\t\t\t  attrs_cached_inside);\n \t  write_indent (indent + 2);\n \t  printf (\"}\\n\");\n \t  our_known_true = newexp;\n@@ -3777,7 +3976,8 @@ write_attr_set (struct attr_desc *attr, int indent, rtx value,\n \t}\n \n       write_attr_set (attr, first_if ? indent : indent + 4, default_val,\n-\t\t      prefix, suffix, our_known_true, insn_code, insn_index);\n+\t\t      prefix, suffix, our_known_true, insn_code, insn_index,\n+\t\t      attrs_cached);\n \n       if (! first_if)\n \t{\n@@ -3858,13 +4058,14 @@ write_attr_case (struct attr_desc *attr, struct attr_value *av,\n       printf (\"extract_insn_cached (insn);\\n\");\n     }\n \n+  attrs_to_cache = 0;\n   if (av->num_insns == 1)\n     write_attr_set (attr, indent + 2, av->value, prefix, suffix,\n \t\t    known_true, av->first_insn->def->insn_code,\n-\t\t    av->first_insn->def->insn_index);\n+\t\t    av->first_insn->def->insn_index, 0);\n   else\n     write_attr_set (attr, indent + 2, av->value, prefix, suffix,\n-\t\t    known_true, -2, 0);\n+\t\t    known_true, -2, 0, 0);\n \n   if (strncmp (prefix, \"return\", 6))\n     {\n@@ -4547,7 +4748,7 @@ make_automaton_attrs (void)\n \t    }\n \t  else\n \t    printf (\"  else if (\");\n-\t  write_test_expr (test, 0);\n+\t  write_test_expr (test, 0, 0);\n \t  printf (\")\\n\");\n \t  printf (\"    {\\n\");\n \t  printf (\"      internal_dfa_insn_code\\n\");"}]}