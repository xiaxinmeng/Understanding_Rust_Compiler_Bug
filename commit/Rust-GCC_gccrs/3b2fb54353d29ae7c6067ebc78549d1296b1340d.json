{"sha": "3b2fb54353d29ae7c6067ebc78549d1296b1340d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyZmI1NDM1M2QyOWFlN2M2MDY3ZWJjNzg1NDlkMTI5NmIxMzQwZA==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2019-12-02T16:23:01Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-12-02T16:23:01Z"}, "message": "libstdc++: PR 78237 Add full steady_clock support to timed_mutex\n\nThe pthread_mutex_clocklock function is available in glibc since the\n2.30 release. If this function is available in the C library it can be\nused to fix PR libstdc++/78237 by supporting steady_clock properly with\ntimed_mutex.\n\nThis means that code using timed_mutex::try_lock_for or\ntimed_mutex::wait_until with steady_clock is no longer subject to timing\nout early or potentially waiting for much longer if the system clock is\nwarped at an inopportune moment.\n\nIf pthread_mutex_clocklock is available then steady_clock is deemed to\nbe the \"best\" clock available which means that it is used for the\nrelative try_lock_for calls and absolute try_lock_until calls using\nsteady_clock and user-defined clocks. Calls explicitly using\nsystem_clock (aka high_resolution_clock) continue to use CLOCK_REALTIME\nvia __gthread_cond_timedwait.\n\nIf pthread_mutex_clocklock is not available then system_clock is deemed\nto be the \"best\" clock available which means that the previous\nsuboptimal behaviour remains.\n\n2019-12-02  Mike Crowe  <mac@mcrowe.com>\n\n\tPR libstdc++/78237 Add full steady_clock support to timed_mutex\n\t* acinclude.m4 (GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK): Define to\n\tdetect presence of pthread_mutex_clocklock function.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* configure.ac: Call GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK.\n\t* include/std/mutex (__timed_mutex_impl): Remove unnecessary __clock_t.\n\t(__timed_mutex_impl::_M_try_lock_for): Use best clock to turn relative\n\ttimeout into absolute timeout.\n\t(__timed_mutex_impl::_M_try_lock_until): Keep existing implementation\n\tfor system_clock. Add new implementation for steady_clock that calls\n\t_M_clocklock. Modify overload for user-defined clock to use a relative\n\twait so that it automatically uses the best clock.\n\t[_GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK] (timed_mutex::_M_clocklock):\n\tNew member function.\n\t(recursive_timed_mutex::_M_clocklock): Likewise.\n\nFrom-SVN: r278901", "tree": {"sha": "3557a7cadb98bc8fb7c149ffce9100ffac6dc627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3557a7cadb98bc8fb7c149ffce9100ffac6dc627"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b2fb54353d29ae7c6067ebc78549d1296b1340d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2fb54353d29ae7c6067ebc78549d1296b1340d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b2fb54353d29ae7c6067ebc78549d1296b1340d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2fb54353d29ae7c6067ebc78549d1296b1340d/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49638674a46e58ff8bfb41c5346386dca9569375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49638674a46e58ff8bfb41c5346386dca9569375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49638674a46e58ff8bfb41c5346386dca9569375"}], "stats": {"total": 187, "additions": 179, "deletions": 8}, "files": [{"sha": "d39a06f962f5df72ae4f2235777f9fa69a7f7216", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3b2fb54353d29ae7c6067ebc78549d1296b1340d", "patch": "@@ -1,5 +1,22 @@\n 2019-12-02  Mike Crowe  <mac@mcrowe.com>\n \n+\tPR libstdc++/78237 Add full steady_clock support to timed_mutex\n+\t* acinclude.m4 (GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK): Define to\n+\tdetect presence of pthread_mutex_clocklock function.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* configure.ac: Call GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK.\n+\t* include/std/mutex (__timed_mutex_impl): Remove unnecessary __clock_t.\n+\t(__timed_mutex_impl::_M_try_lock_for): Use best clock to turn relative\n+\ttimeout into absolute timeout.\n+\t(__timed_mutex_impl::_M_try_lock_until): Keep existing implementation\n+\tfor system_clock. Add new implementation for steady_clock that calls\n+\t_M_clocklock. Modify overload for user-defined clock to use a relative\n+\twait so that it automatically uses the best clock.\n+\t[_GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK] (timed_mutex::_M_clocklock):\n+\tNew member function.\n+\t(recursive_timed_mutex::_M_clocklock): Likewise.\n+\n \t* testsuite/30_threads/recursive_timed_mutex/try_lock_until/3.cc:\n \tNew test. Ensure that timed_mutex::try_lock_until actually times out\n \tafter the specified time when using both system_clock and"}, {"sha": "7e685bb2f898171d56902a5381b5e0768cc47736", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=3b2fb54353d29ae7c6067ebc78549d1296b1340d", "patch": "@@ -4227,6 +4227,37 @@ AC_DEFUN([GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT], [\n   AC_LANG_RESTORE\n ])\n \n+dnl\n+dnl Check whether pthread_mutex_clocklock is available in <pthread.h> for std::timed_mutex to use,\n+dnl and define _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK.\n+dnl\n+AC_DEFUN([GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK], [\n+\n+  AC_LANG_SAVE\n+  AC_LANG_CPLUSPLUS\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+  ac_save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS -lpthread\"\n+\n+  AC_MSG_CHECKING([for pthread_mutex_clocklock])\n+  AC_CACHE_VAL(glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK, [\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [#include <pthread.h>],\n+      [pthread_mutex_t mutex; struct timespec ts; int n = pthread_mutex_clocklock(&mutex, CLOCK_REALTIME, &ts);],\n+      [glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK=yes],\n+      [glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK=no])\n+  ])\n+  if test $glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK = yes; then\n+    AC_DEFINE(_GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK, 1, [Define if pthread_mutex_clocklock is available in <pthread.h>.])\n+  fi\n+  AC_MSG_RESULT($glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK)\n+\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  LIBS=\"$ac_save_LIBS\"\n+  AC_LANG_RESTORE\n+])\n+\n dnl\n dnl Check whether sysctl is available in <pthread.h>, and define _GLIBCXX_USE_SYSCTL_HW_NCPU.\n dnl"}, {"sha": "3d515347396b5fb87ae506d2d161c19ca09c733a", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=3b2fb54353d29ae7c6067ebc78549d1296b1340d", "patch": "@@ -1002,6 +1002,9 @@\n /* Define if pthread_cond_clockwait is available in <pthread.h>. */\n #undef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n \n+/* Define if pthread_mutex_clocklock is available in <pthread.h>. */\n+#undef _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK\n+\n /* Define if POSIX read/write locks are available in <gthr.h>. */\n #undef _GLIBCXX_USE_PTHREAD_RWLOCK_T\n "}, {"sha": "a439bb86e6eed48b1d4bf46ad7f23ec922b44a8f", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=3b2fb54353d29ae7c6067ebc78549d1296b1340d", "patch": "@@ -21880,6 +21880,89 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n \n \n+# For pthread_mutex_clocklock\n+\n+\n+\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+  ac_save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS -lpthread\"\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for pthread_mutex_clocklock\" >&5\n+$as_echo_n \"checking for pthread_mutex_clocklock... \" >&6; }\n+  if ${glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+\n+    if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+int\n+main ()\n+{\n+pthread_mutex_t mutex; struct timespec ts; int n = pthread_mutex_clocklock(&mutex, CLOCK_REALTIME, &ts);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK=yes\n+else\n+  glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error $? \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+int\n+main ()\n+{\n+pthread_mutex_t mutex; struct timespec ts; int n = pthread_mutex_clocklock(&mutex, CLOCK_REALTIME, &ts);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK=yes\n+else\n+  glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+\n+  if test $glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK = yes; then\n+\n+$as_echo \"#define _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK 1\" >>confdefs.h\n+\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK\" >&5\n+$as_echo \"$glibcxx_cv_PTHREAD_MUTEX_CLOCKLOCK\" >&6; }\n+\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  LIBS=\"$ac_save_LIBS\"\n+  ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n+\n+\n \n   ac_fn_c_check_header_mongrel \"$LINENO\" \"locale.h\" \"ac_cv_header_locale_h\" \"$ac_includes_default\"\n if test \"x$ac_cv_header_locale_h\" = xyes; then :"}, {"sha": "c1ecc6705192e0334d8d348d0c08559ae901f08c", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=3b2fb54353d29ae7c6067ebc78549d1296b1340d", "patch": "@@ -225,6 +225,9 @@ GLIBCXX_CHECK_TMPNAM\n # For pthread_cond_clockwait\n GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT\n \n+# For pthread_mutex_clocklock\n+GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK\n+\n AC_LC_MESSAGES\n \n # For hardware_concurrency"}, {"sha": "26ee084b9793e48078e758610d515d5dc331b74c", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2fb54353d29ae7c6067ebc78549d1296b1340d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=3b2fb54353d29ae7c6067ebc78549d1296b1340d", "patch": "@@ -134,22 +134,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class __timed_mutex_impl\n     {\n     protected:\n-      typedef chrono::high_resolution_clock \t__clock_t;\n-\n       template<typename _Rep, typename _Period>\n \tbool\n \t_M_try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n \t{\n-\t  using chrono::steady_clock;\n-\t  auto __rt = chrono::duration_cast<steady_clock::duration>(__rtime);\n-\t  if (ratio_greater<steady_clock::period, _Period>())\n+#if _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK\n+\t  using __clock = chrono::steady_clock;\n+#else\n+\t  using __clock = chrono::system_clock;\n+#endif\n+\n+\t  auto __rt = chrono::duration_cast<__clock::duration>(__rtime);\n+\t  if (ratio_greater<__clock::period, _Period>())\n \t    ++__rt;\n-\t  return _M_try_lock_until(steady_clock::now() + __rt);\n+\t  return _M_try_lock_until(__clock::now() + __rt);\n \t}\n \n       template<typename _Duration>\n \tbool\n-\t_M_try_lock_until(const chrono::time_point<__clock_t,\n+\t_M_try_lock_until(const chrono::time_point<chrono::system_clock,\n \t\t\t\t\t\t   _Duration>& __atime)\n \t{\n \t  auto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n@@ -163,12 +166,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return static_cast<_Derived*>(this)->_M_timedlock(__ts);\n \t}\n \n+#ifdef _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK\n+      template<typename _Duration>\n+\tbool\n+\t_M_try_lock_until(const chrono::time_point<chrono::steady_clock,\n+\t\t\t\t\t\t   _Duration>& __atime)\n+\t{\n+\t  auto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\t  auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t  __gthread_time_t __ts = {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\t  return static_cast<_Derived*>(this)->_M_clocklock(CLOCK_MONOTONIC,\n+\t\t\t\t\t\t\t    __ts);\n+\t}\n+#endif\n+\n       template<typename _Clock, typename _Duration>\n \tbool\n \t_M_try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n \t{\n \t  auto __rtime = __atime - _Clock::now();\n-\t  return _M_try_lock_until(__clock_t::now() + __rtime);\n+\t  return _M_try_lock_for(__rtime);\n \t}\n     };\n \n@@ -229,6 +251,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_timedlock(const __gthread_time_t& __ts)\n       { return !__gthread_mutex_timedlock(&_M_mutex, &__ts); }\n+\n+#if _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK\n+      bool\n+      _M_clocklock(clockid_t clockid, const __gthread_time_t& __ts)\n+      { return !pthread_mutex_clocklock(&_M_mutex, clockid, &__ts); }\n+#endif\n   };\n \n   /// recursive_timed_mutex\n@@ -289,6 +317,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_timedlock(const __gthread_time_t& __ts)\n       { return !__gthread_recursive_mutex_timedlock(&_M_mutex, &__ts); }\n+\n+#ifdef _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK\n+      bool\n+      _M_clocklock(clockid_t clockid, const __gthread_time_t& __ts)\n+      { return !pthread_mutex_clocklock(&_M_mutex, clockid, &__ts); }\n+#endif\n   };\n \n #else // !_GTHREAD_USE_MUTEX_TIMEDLOCK"}]}