{"sha": "c4ddde1bbb802daac8daba71ce7344adc0afc63d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRkZGRlMWJiYjgwMmRhYWM4ZGFiYTcxY2U3MzQ0YWRjMGFmYzYzZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-03-02T14:58:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-03-02T14:58:55Z"}, "message": "re PR tree-optimization/52406 (likely wrong code bug)\n\n2012-03-02  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/52406\n\t* tree-data-ref.h: Update documentation about DR_BASE_OBJECT.\n\t(struct indices): Add unconstrained_base member.\n\t(struct dr_alias): Remove unused vops member.\n\t(DR_UNCONSTRAINED_BASE): New define.\n\t* tree-data-ref.c (dr_analyze_indices): For COMPONENT_REFs\n\tadd indices to allow their disambiguation.  Make DR_BASE_OBJECT\n\tbe an artificial access that covers the whole indexed object,\n\tor mark it with DR_UNCONSTRAINED_BASE if we cannot do so.  Canonicalize\n\tplain decl base-objects to their MEM_REF variant.\n\t(dr_may_alias_p): When the base-object of either data reference\n\thas unknown size use only points-to information.\n\t(compute_affine_dependence): Make dumps easier to read and\n\tmore verbose.\n\t* tree-vect-data-ref.c (vector_alignment_reachable_p): Use\n\tDR_REF when looking for packed references.\n\t(vect_supportable_dr_alignment): Likewise.\n\n\t* gcc.dg/torture/pr52406.c: New testcase.\n\nFrom-SVN: r184789", "tree": {"sha": "c3a4354f21d2707459cf46ca8b2154966b514eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3a4354f21d2707459cf46ca8b2154966b514eb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4ddde1bbb802daac8daba71ce7344adc0afc63d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ddde1bbb802daac8daba71ce7344adc0afc63d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ddde1bbb802daac8daba71ce7344adc0afc63d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ddde1bbb802daac8daba71ce7344adc0afc63d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ee65df3f19d975ab2272531cc50c5dfc96bbf65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee65df3f19d975ab2272531cc50c5dfc96bbf65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ee65df3f19d975ab2272531cc50c5dfc96bbf65"}], "stats": {"total": 219, "additions": 155, "deletions": 64}, "files": [{"sha": "d43069a8c1940ad4d64c556e9b975a3a8fe94e2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4ddde1bbb802daac8daba71ce7344adc0afc63d", "patch": "@@ -1,3 +1,23 @@\n+2012-03-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/52406\n+\t* tree-data-ref.h: Update documentation about DR_BASE_OBJECT.\n+\t(struct indices): Add unconstrained_base member.\n+\t(struct dr_alias): Remove unused vops member.\n+\t(DR_UNCONSTRAINED_BASE): New define.\n+\t* tree-data-ref.c (dr_analyze_indices): For COMPONENT_REFs\n+\tadd indices to allow their disambiguation.  Make DR_BASE_OBJECT\n+\tbe an artificial access that covers the whole indexed object,\n+\tor mark it with DR_UNCONSTRAINED_BASE if we cannot do so.  Canonicalize\n+\tplain decl base-objects to their MEM_REF variant.\n+\t(dr_may_alias_p): When the base-object of either data reference\n+\thas unknown size use only points-to information.\n+\t(compute_affine_dependence): Make dumps easier to read and\n+\tmore verbose.\n+\t* tree-vect-data-ref.c (vector_alignment_reachable_p): Use\n+\tDR_REF when looking for packed references.\n+\t(vect_supportable_dr_alignment): Likewise.\n+\n 2012-03-02  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n        * config/arm/arm-ldmstm.ml (write_ldm_commutative_peephole):"}, {"sha": "4be8f24565f53159561b08707d940ea01fac1883", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c4ddde1bbb802daac8daba71ce7344adc0afc63d", "patch": "@@ -1,3 +1,8 @@\n+2012-03-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/52406\n+\t* gcc.dg/torture/pr52406.c: New testcase.\n+\n 2012-03-02  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52325"}, {"sha": "5579d0943ae24e3a703597ccd7300436e229eca1", "filename": "gcc/testsuite/gcc.dg/torture/pr52406.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr52406.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr52406.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr52406.c?ref=c4ddde1bbb802daac8daba71ce7344adc0afc63d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+struct { int f1; } a[2];\n+\n+int *b, *const k = &a[1].f1;\n+static int **c = &b;\n+\n+int e, f, d;\n+\n+int\n+main ()\n+{\n+  int **l = &b;\n+  *l = k;\n+  for (; d <= 0; d++)\n+    {\n+      int *j = &e;\n+      **c = 1;\n+      *l = k;\n+      *k ^= 0;\n+      f = **l;\n+      *j = f;\n+    }\n+  if (e != 1)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "e7bb16fcbc2e0a5056b509477527dd734934f493", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 82, "deletions": 32, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=c4ddde1bbb802daac8daba71ce7344adc0afc63d", "patch": "@@ -856,7 +856,7 @@ static void\n dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n {\n   VEC (tree, heap) *access_fns = NULL;\n-  tree ref, *aref, op;\n+  tree ref, op;\n   tree base, off, access_fn;\n   basic_block before_loop;\n \n@@ -869,7 +869,7 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n       return;\n     }\n \n-  ref = unshare_expr (DR_REF (dr));\n+  ref = DR_REF (dr);\n   before_loop = block_before_loop (nest);\n \n   /* REALPART_EXPR and IMAGPART_EXPR can be handled like accesses\n@@ -887,61 +887,84 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n     }\n \n   /* Analyze access functions of dimensions we know to be independent.  */\n-  aref = &ref;\n-  while (handled_component_p (*aref))\n+  while (handled_component_p (ref))\n     {\n-      if (TREE_CODE (*aref) == ARRAY_REF)\n+      if (TREE_CODE (ref) == ARRAY_REF)\n \t{\n-\t  op = TREE_OPERAND (*aref, 1);\n+\t  op = TREE_OPERAND (ref, 1);\n \t  access_fn = analyze_scalar_evolution (loop, op);\n \t  access_fn = instantiate_scev (before_loop, loop, access_fn);\n \t  VEC_safe_push (tree, heap, access_fns, access_fn);\n-\t  /* For ARRAY_REFs the base is the reference with the index replaced\n-\t     by zero if we can not strip it as the outermost component.  */\n-\t  if (*aref == ref)\n-\t    {\n-\t      *aref = TREE_OPERAND (*aref, 0);\n-\t      continue;\n-\t    }\n-\t  else\n-\t    TREE_OPERAND (*aref, 1) = build_int_cst (TREE_TYPE (op), 0);\n \t}\n+      else if (TREE_CODE (ref) == COMPONENT_REF\n+\t       && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0))) == RECORD_TYPE)\n+\t{\n+\t  /* For COMPONENT_REFs of records (but not unions!) use the\n+\t     FIELD_DECL offset as constant access function so we can\n+\t     disambiguate a[i].f1 and a[i].f2.  */\n+\t  tree off = component_ref_field_offset (ref);\n+\t  off = size_binop (PLUS_EXPR,\n+\t\t\t    size_binop (MULT_EXPR,\n+\t\t\t\t\tfold_convert (bitsizetype, off),\n+\t\t\t\t\tbitsize_int (BITS_PER_UNIT)),\n+\t\t\t    DECL_FIELD_BIT_OFFSET (TREE_OPERAND (ref, 1)));\n+\t  VEC_safe_push (tree, heap, access_fns, off);\n+\t}\n+      else\n+\t/* If we have an unhandled component we could not translate\n+\t   to an access function stop analyzing.  We have determined\n+\t   our base object in this case.  */\n+\tbreak;\n \n-      aref = &TREE_OPERAND (*aref, 0);\n+      ref = TREE_OPERAND (ref, 0);\n     }\n \n   /* If the address operand of a MEM_REF base has an evolution in the\n      analyzed nest, add it as an additional independent access-function.  */\n-  if (TREE_CODE (*aref) == MEM_REF)\n+  if (TREE_CODE (ref) == MEM_REF)\n     {\n-      op = TREE_OPERAND (*aref, 0);\n+      op = TREE_OPERAND (ref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n       access_fn = instantiate_scev (before_loop, loop, access_fn);\n       if (TREE_CODE (access_fn) == POLYNOMIAL_CHREC)\n \t{\n \t  tree orig_type;\n+\t  tree memoff = TREE_OPERAND (ref, 1);\n \t  base = initial_condition (access_fn);\n \t  orig_type = TREE_TYPE (base);\n \t  STRIP_USELESS_TYPE_CONVERSION (base);\n \t  split_constant_offset (base, &base, &off);\n \t  /* Fold the MEM_REF offset into the evolutions initial\n \t     value to make more bases comparable.  */\n-\t  if (!integer_zerop (TREE_OPERAND (*aref, 1)))\n+\t  if (!integer_zerop (memoff))\n \t    {\n \t      off = size_binop (PLUS_EXPR, off,\n-\t\t\t\tfold_convert (ssizetype,\n-\t\t\t\t\t      TREE_OPERAND (*aref, 1)));\n-\t      TREE_OPERAND (*aref, 1)\n-\t\t= build_int_cst (TREE_TYPE (TREE_OPERAND (*aref, 1)), 0);\n+\t\t\t\tfold_convert (ssizetype, memoff));\n+\t      memoff = build_int_cst (TREE_TYPE (memoff), 0);\n \t    }\n \t  access_fn = chrec_replace_initial_condition\n \t      (access_fn, fold_convert (orig_type, off));\n-\t  *aref = fold_build2_loc (EXPR_LOCATION (*aref),\n-\t\t\t\t   MEM_REF, TREE_TYPE (*aref),\n-\t\t\t\t   base, TREE_OPERAND (*aref, 1));\n+\t  /* ???  This is still not a suitable base object for\n+\t     dr_may_alias_p - the base object needs to be an\n+\t     access that covers the object as whole.  With\n+\t     an evolution in the pointer this cannot be\n+\t     guaranteed.\n+\t     As a band-aid, mark the access so we can special-case\n+\t     it in dr_may_alias_p.  */\n+\t  ref = fold_build2_loc (EXPR_LOCATION (ref),\n+\t\t\t\t MEM_REF, TREE_TYPE (ref),\n+\t\t\t\t base, memoff);\n+\t  DR_UNCONSTRAINED_BASE (dr) = true;\n \t  VEC_safe_push (tree, heap, access_fns, access_fn);\n \t}\n     }\n+  else if (DECL_P (ref))\n+    {\n+      /* Canonicalize DR_BASE_OBJECT to MEM_REF form.  */\n+      ref = build2 (MEM_REF, TREE_TYPE (ref),\n+\t\t    build_fold_addr_expr (ref),\n+\t\t    build_int_cst (reference_alias_ptr_type (ref), 0));\n+    }\n \n   DR_BASE_OBJECT (dr) = ref;\n   DR_ACCESS_FNS (dr) = access_fns;\n@@ -1345,6 +1368,27 @@ dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,\n \treturn false;\n     }\n \n+  /* If we had an evolution in a MEM_REF BASE_OBJECT we do not know\n+     the size of the base-object.  So we cannot do any offset/overlap\n+     based analysis but have to rely on points-to information only.  */\n+  if (TREE_CODE (addr_a) == MEM_REF\n+      && DR_UNCONSTRAINED_BASE (a))\n+    {\n+      if (TREE_CODE (addr_b) == MEM_REF\n+\t  && DR_UNCONSTRAINED_BASE (b))\n+\treturn ptr_derefs_may_alias_p (TREE_OPERAND (addr_a, 0),\n+\t\t\t\t       TREE_OPERAND (addr_b, 0));\n+      else\n+\treturn ptr_derefs_may_alias_p (TREE_OPERAND (addr_a, 0),\n+\t\t\t\t       build_fold_addr_expr (addr_b));\n+    }\n+  else if (TREE_CODE (addr_b) == MEM_REF\n+\t   && DR_UNCONSTRAINED_BASE (b))\n+    return ptr_derefs_may_alias_p (build_fold_addr_expr (addr_a),\n+\t\t\t\t   TREE_OPERAND (addr_b, 0));\n+\n+  /* Otherwise DR_BASE_OBJECT is an access that covers the whole object\n+     that is being subsetted in the loop nest.  */\n   if (DR_IS_WRITE (a) && DR_IS_WRITE (b))\n     return refs_output_dependent_p (addr_a, addr_b);\n   else if (DR_IS_READ (a) && DR_IS_WRITE (b))\n@@ -4049,11 +4093,10 @@ compute_affine_dependence (struct data_dependence_relation *ddr,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"(compute_affine_dependence\\n\");\n-      fprintf (dump_file, \"  (stmt_a = \\n\");\n-      print_gimple_stmt (dump_file, DR_STMT (dra), 0, 0);\n-      fprintf (dump_file, \")\\n  (stmt_b = \\n\");\n-      print_gimple_stmt (dump_file, DR_STMT (drb), 0, 0);\n-      fprintf (dump_file, \")\\n\");\n+      fprintf (dump_file, \"  stmt_a: \");\n+      print_gimple_stmt (dump_file, DR_STMT (dra), 0, TDF_SLIM);\n+      fprintf (dump_file, \"  stmt_b: \");\n+      print_gimple_stmt (dump_file, DR_STMT (drb), 0, TDF_SLIM);\n     }\n \n   /* Analyze only when the dependence relation is not yet known.  */\n@@ -4129,7 +4172,14 @@ compute_affine_dependence (struct data_dependence_relation *ddr,\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \")\\n\");\n+    {\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\tfprintf (dump_file, \") -> no dependence\\n\");\n+      else if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+\tfprintf (dump_file, \") -> dependence analysis failed\\n\");\n+      else\n+\tfprintf (dump_file, \")\\n\");\n+    }\n }\n \n /* Compute in DEPENDENCE_RELATIONS the data dependence graph for all"}, {"sha": "d983c8cda45a640cdfb73f8ecac1650a0d4531e5", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=c4ddde1bbb802daac8daba71ce7344adc0afc63d", "patch": "@@ -60,16 +60,17 @@ struct innermost_loop_behavior\n };\n \n /* Describes the evolutions of indices of the memory reference.  The indices\n-   are indices of the ARRAY_REFs and the operands of INDIRECT_REFs.\n-   For ARRAY_REFs, BASE_OBJECT is the reference with zeroed indices\n-   (note that this reference does not have to be valid, if zero does not\n-   belong to the range of the array; hence it is not recommended to use\n-   BASE_OBJECT in any code generation).  For INDIRECT_REFs, the address is\n-   set to the loop-invariant part of the address of the object, except for\n-   the constant offset.  For the examples above,\n-\n-   base_object:        a[0].b[0][0]                   *(p + x + 4B * j_0)\n+   are indices of the ARRAY_REFs, indexes in artificial dimensions\n+   added for member selection of records and the operands of MEM_REFs.\n+   BASE_OBJECT is the part of the reference that is loop-invariant\n+   (note that this reference does not have to cover the whole object\n+   being accessed, in which case UNCONSTRAINED_BASE is set; hence it is\n+   not recommended to use BASE_OBJECT in any code generation).\n+   For the examples above,\n+\n+   base_object:        a                              *(p + x + 4B * j_0)\n    indices:            {j_0, +, 1}_2                  {16, +, 4}_2\n+\t\t       4\n \t\t       {i_0, +, 1}_1\n \t\t       {j_0, +, 1}_2\n */\n@@ -81,18 +82,17 @@ struct indices\n \n   /* A list of chrecs.  Access functions of the indices.  */\n   VEC(tree,heap) *access_fns;\n+\n+  /* Whether BASE_OBJECT is an access representing the whole object\n+     or whether the access could not be constrained.  */\n+  bool unconstrained_base;\n };\n \n struct dr_alias\n {\n   /* The alias information that should be used for new pointers to this\n-     location.  SYMBOL_TAG is either a DECL or a SYMBOL_MEMORY_TAG.  */\n+     location.  */\n   struct ptr_info_def *ptr_info;\n-\n-  /* The set of virtual operands corresponding to this memory reference,\n-     serving as a description of the alias information for the memory\n-     reference.  This could be eliminated if we had alias oracle.  */\n-  bitmap vops;\n };\n \n /* An integer vector.  A vector formally consists of an element of a vector\n@@ -201,6 +201,7 @@ struct data_reference\n #define DR_STMT(DR)                (DR)->stmt\n #define DR_REF(DR)                 (DR)->ref\n #define DR_BASE_OBJECT(DR)         (DR)->indices.base_object\n+#define DR_UNCONSTRAINED_BASE(DR)  (DR)->indices.unconstrained_base\n #define DR_ACCESS_FNS(DR)\t   (DR)->indices.access_fns\n #define DR_ACCESS_FN(DR, I)        VEC_index (tree, DR_ACCESS_FNS (DR), I)\n #define DR_NUM_DIMENSIONS(DR)      VEC_length (tree, DR_ACCESS_FNS (DR))"}, {"sha": "b458d624d64264f746c69eb76c60c5c180c0cd94", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddde1bbb802daac8daba71ce7344adc0afc63d/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c4ddde1bbb802daac8daba71ce7344adc0afc63d", "patch": "@@ -1141,11 +1141,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n   if (!known_alignment_for_access_p (dr))\n     {\n       tree type = (TREE_TYPE (DR_REF (dr)));\n-      tree ba = DR_BASE_OBJECT (dr);\n-      bool is_packed = false;\n-\n-      if (ba)\n-\tis_packed = contains_packed_reference (ba);\n+      bool is_packed = contains_packed_reference (DR_REF (dr));\n \n       if (compare_tree_int (TYPE_SIZE (type), TYPE_ALIGN (type)) > 0)\n \tis_packed = true;\n@@ -4672,12 +4668,7 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n \t    return dr_explicit_realign_optimized;\n \t}\n       if (!known_alignment_for_access_p (dr))\n-\t{\n-\t  tree ba = DR_BASE_OBJECT (dr);\n-\n-\t  if (ba)\n-\t    is_packed = contains_packed_reference (ba);\n-\t}\n+\tis_packed = contains_packed_reference (DR_REF (dr));\n \n       if (targetm.vectorize.\n \t  support_vector_misalignment (mode, type,\n@@ -4691,12 +4682,7 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n       tree type = (TREE_TYPE (DR_REF (dr)));\n \n       if (!known_alignment_for_access_p (dr))\n-\t{\n-\t  tree ba = DR_BASE_OBJECT (dr);\n-\n-\t  if (ba)\n-\t    is_packed = contains_packed_reference (ba);\n-\t}\n+\tis_packed = contains_packed_reference (DR_REF (dr));\n \n      if (targetm.vectorize.\n          support_vector_misalignment (mode, type,"}]}