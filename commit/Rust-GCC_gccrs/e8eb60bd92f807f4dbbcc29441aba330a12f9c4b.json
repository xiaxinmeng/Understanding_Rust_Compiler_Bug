{"sha": "e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlYjYwYmQ5MmY4MDdmNGRiYmNjMjk0NDFhYmEzMzBhMTJmOWM0Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-06-22T19:57:12Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-06-22T19:57:12Z"}, "message": "Makefile.am: Add alloc_traits.h headers.\n\n2011-06-22  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* include/Makefile.am: Add alloc_traits.h headers.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/memory: Include uses_allocator.h explicitly.\n\t* include/bits/allocator.h (allocator_traits): Move to ...\n\t* include/bits/alloc_traits.h: New header.\n\t* include/ext/alloc_traits.h (__alloc_traits): Extension to provide\n\ta common allocator interface for C++98 and C++0x.\n\t* include/bits/stl_construct.h: Use __alloc_traits.\n\t* include/bits/stl_uninitialized.h: Likewise.\n\nFrom-SVN: r175305", "tree": {"sha": "50ee7e36552a06e401135d68736fe944163a9683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50ee7e36552a06e401135d68736fe944163a9683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8499116aa30a46993deff5acf73985df6b16fb8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8499116aa30a46993deff5acf73985df6b16fb8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8499116aa30a46993deff5acf73985df6b16fb8b"}], "stats": {"total": 1070, "additions": 659, "deletions": 411}, "files": [{"sha": "0fc0f737ad1f90ea0f62b1af15abf721a46b0fcb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -1,3 +1,15 @@\n+2011-06-22  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/Makefile.am: Add alloc_traits.h headers.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/std/memory: Include uses_allocator.h explicitly.\n+\t* include/bits/allocator.h (allocator_traits): Move to ...\n+\t* include/bits/alloc_traits.h: New header.\n+\t* include/ext/alloc_traits.h (__alloc_traits): Extension to provide\n+\ta common allocator interface for C++98 and C++0x.\n+\t* include/bits/stl_construct.h: Use __alloc_traits.\n+\t* include/bits/stl_uninitialized.h: Likewise.\n+\n 2011-06-22  Daniel Krugler  <daniel.kruegler@googlemail.com>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "b6a0116872f47fc23c7b6c1273894beedcec766d", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -79,6 +79,7 @@ bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n         ${bits_srcdir}/algorithmfwd.h \\\n+\t${bits_srcdir}/alloc_traits.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n \t${bits_srcdir}/atomic_0.h \\\n@@ -493,6 +494,7 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/alloc_traits.h \\\n \t${ext_srcdir}/atomicity.h \\\n \t${ext_srcdir}/array_allocator.h \\\n \t${ext_srcdir}/bitmap_allocator.h \\"}, {"sha": "7fdf182f2d2272f889e19d206165c92b46e429db", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -330,6 +330,7 @@ bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n         ${bits_srcdir}/algorithmfwd.h \\\n+\t${bits_srcdir}/alloc_traits.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n \t${bits_srcdir}/atomic_0.h \\\n@@ -742,6 +743,7 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/alloc_traits.h \\\n \t${ext_srcdir}/atomicity.h \\\n \t${ext_srcdir}/array_allocator.h \\\n \t${ext_srcdir}/bitmap_allocator.h \\"}, {"sha": "9d2a472e5d3754b2d06287f072cefc92f2c06494", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -0,0 +1,499 @@\n+// Allocator traits -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _ALLOC_TRAITS_H\n+#define _ALLOC_TRAITS_H 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+\n+#include <bits/ptr_traits.h>\n+#include <ext/numeric_traits.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Alloc, typename _Tp>\n+    class __alloctr_rebind_helper\n+    {\n+      template<typename _Alloc2, typename _Tp2>\n+\tstatic constexpr bool\n+       \t_S_chk(typename _Alloc2::template rebind<_Tp2>::other*)\n+\t{ return true; }\n+\n+      template<typename, typename>\n+        static constexpr bool\n+       \t_S_chk(...)\n+       \t{ return false; }\n+\n+    public:\n+      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);\n+    };\n+\n+  template<typename _Alloc, typename _Tp,\n+           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>\n+    struct __alloctr_rebind;\n+\n+  template<typename _Alloc, typename _Tp>\n+    struct __alloctr_rebind<_Alloc, _Tp, true>\n+    {\n+      typedef typename _Alloc::template rebind<_Tp>::other __type;\n+    };\n+\n+  template<template<typename, typename...> class _Alloc, typename _Tp,\n+            typename _Up, typename... _Args>\n+    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>\n+    {\n+      typedef _Alloc<_Tp, _Args...> __type;\n+    };\n+\n+  /**\n+   * @brief  Uniform interface to all allocator types.\n+   * @ingroup allocators\n+  */\n+  template<typename _Alloc>\n+    struct allocator_traits\n+    {\n+      /// The allocator type\n+      typedef _Alloc allocator_type;\n+      /// The allocated type\n+      typedef typename _Alloc::value_type value_type;\n+\n+#define _GLIBCXX_ALLOC_TR_NESTED_TYPE(_NTYPE, _ALT) \\\n+  private: \\\n+  template<typename _Tp> \\\n+    static typename _Tp::_NTYPE _S_##_NTYPE##_helper(_Tp*); \\\n+  static _ALT _S_##_NTYPE##_helper(...); \\\n+    typedef decltype(_S_##_NTYPE##_helper((_Alloc*)0)) __##_NTYPE; \\\n+  public:\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(pointer, value_type*)\n+\n+      /**\n+       * @brief   The allocator's pointer type.\n+       *\n+       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n+      */\n+      typedef __pointer pointer;\n+\n+// TODO: Use pointer_traits::rebind alias template.\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_pointer,\n+  typename pointer_traits<pointer>::template __rebind<const value_type>::__type)\n+\n+      /**\n+       * @brief   The allocator's const pointer type.\n+       *\n+       * @c Alloc::const_pointer if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>\n+      */\n+      typedef __const_pointer const_pointer;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(void_pointer,\n+  typename pointer_traits<pointer>::template __rebind<void>::__type)\n+\n+      /**\n+       * @brief   The allocator's void pointer type.\n+       *\n+       * @c Alloc::void_pointer if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::rebind<void> </tt>\n+      */\n+      typedef __void_pointer void_pointer;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_void_pointer,\n+  typename pointer_traits<pointer>::template __rebind<const void>::__type)\n+\n+      /**\n+       * @brief   The allocator's const void pointer type.\n+       *\n+       * @c Alloc::const_void_pointer if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::rebind<const void> </tt>\n+      */\n+      typedef __const_void_pointer const_void_pointer;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,\n+                              typename pointer_traits<pointer>::difference_type)\n+\n+      /**\n+       * @brief   The allocator's difference type\n+       *\n+       * @c Alloc::difference_type if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::difference_type </tt>\n+      */\n+      typedef __difference_type difference_type;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,\n+                              typename make_unsigned<difference_type>::type)\n+\n+      /**\n+       * @brief   The allocator's size type\n+       *\n+       * @c Alloc::size_type if that type exists, otherwise\n+       * <tt> make_unsigned<difference_type>::type </tt>\n+      */\n+      typedef __size_type size_type;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,\n+                              false_type)\n+\n+      /**\n+       * @brief   How the allocator is propagated on copy assignment\n+       *\n+       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n+       * otherwise @c false_type\n+      */\n+      typedef __propagate_on_container_copy_assignment\n+       \tpropagate_on_container_copy_assignment;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,\n+                              false_type)\n+\n+      /**\n+       * @brief   How the allocator is propagated on move assignment\n+       *\n+       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n+       * otherwise @c false_type\n+      */\n+      typedef __propagate_on_container_move_assignment\n+       \tpropagate_on_container_move_assignment;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n+                              false_type)\n+\n+      /**\n+       * @brief   How the allocator is propagated on swap\n+       *\n+       * @c Alloc::propagate_on_container_swap if that type exists,\n+       * otherwise @c false_type\n+      */\n+      typedef __propagate_on_container_swap propagate_on_container_swap;\n+\n+#undef _GLIBCXX_ALLOC_TR_NESTED_TYPE\n+\n+      /* TODO: use template alias \n+      template<typename _Tp>\n+        using rebind_alloc = __alloctr_rebind<_Alloc, _Tp>::__type;\n+      template<typename _Tp>\n+        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n+      */\n+      template<typename _Tp>\n+        struct __rebind_alloc\n+\t{\n+  \t  typedef typename __alloctr_rebind<_Alloc, _Tp>::__type __type;\n+       \t};\n+\n+      template<typename _Tp>\n+        struct __rebind_traits\n+\t{\n+\t  typedef allocator_traits<typename __rebind_alloc<_Tp>::__type> __type;\n+\t};\n+\n+    private:\n+      template<typename _Alloc2>\n+\tstruct __allocate_helper\n+\t{\n+\t  template<typename _Alloc3,\n+\t    typename = decltype(std::declval<_Alloc3*>()->allocate(\n+\t\t  std::declval<size_type>(),\n+\t\t  std::declval<const_void_pointer>()))>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<__allocate_helper<_Alloc2>::value, pointer>::type\n+       \t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)\n+\t{ return __a.allocate(__n, __hint); }\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<!__allocate_helper<_Alloc2>::value, pointer>::type\n+       \t_S_allocate(_Alloc2& __a, size_type __n, ...)\n+\t{ return __a.allocate(__n); }\n+\n+      template<typename _Tp, typename... _Args>\n+\tstruct __construct_helper\n+\t{\n+\t  template<typename _Alloc2,\n+\t    typename = decltype(std::declval<_Alloc2*>()->construct(\n+\t\t  std::declval<_Tp*>(), std::declval<_Args>()...))>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Tp, typename... _Args>\n+\tstatic typename\n+       \tenable_if<__construct_helper<_Tp, _Args...>::value, void>::type\n+       \t_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n+\t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n+\n+      template<typename _Tp, typename... _Args>\n+\tstatic typename\n+       \tenable_if<!__construct_helper<_Tp, _Args...>::value, void>::type\n+       \t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n+\t{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Tp>\n+\tstruct __destroy_helper\n+\t{\n+\t  template<typename _Alloc2,\n+\t    typename = decltype(std::declval<_Alloc2*>()->destroy(\n+\t\t  std::declval<_Tp*>()))>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Tp>\n+\tstatic typename enable_if<__destroy_helper<_Tp>::value, void>::type\n+       \t_S_destroy(_Alloc& __a, _Tp* __p)\n+\t{ __a.destroy(__p); }\n+\n+      template<typename _Tp>\n+\tstatic typename enable_if<!__destroy_helper<_Tp>::value, void>::type\n+       \t_S_destroy(_Alloc&, _Tp* __p)\n+\t{ __p->~_Tp(); }\n+\n+      template<typename _Alloc2>\n+\tstruct __maxsize_helper\n+\t{\n+\t  template<typename _Alloc3,\n+\t    typename = decltype(std::declval<_Alloc3*>()->max_size())>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc2>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<__maxsize_helper<_Alloc2>::value, size_type>::type\n+       \t_S_max_size(_Alloc2& __a)\n+\t{ return __a.max_size(); }\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<!__maxsize_helper<_Alloc2>::value, size_type>::type\n+\t_S_max_size(_Alloc2&)\n+\t{ return __gnu_cxx::__numeric_traits<size_type>::__max; }\n+\n+      template<typename _Alloc2>\n+\tstruct __select_helper\n+\t{\n+\t  template<typename _Alloc3, typename\n+\t    = decltype(std::declval<_Alloc3*>()\n+\t\t->select_on_container_copy_construction())>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc2>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<__select_helper<_Alloc2>::value, _Alloc2>::type\n+       \t_S_select(_Alloc2& __a)\n+\t{ return __a.select_on_container_copy_construction(); }\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type\n+       \t_S_select(_Alloc2& __a)\n+\t{ return __a; }\n+\n+    public:\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  a  An allocator.\n+       *  @param  n  The number of objects to allocate space for.\n+       *\n+       *  Calls @c a.allocate(n)\n+      */\n+      static pointer\n+      allocate(_Alloc& __a, size_type __n)\n+      { return __a.allocate(__n); }\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  a  An allocator.\n+       *  @param  n  The number of objects to allocate space for.\n+       *  @param  hint Aid to locality.\n+       *  @return Memory of suitable size and alignment for @a n objects\n+       *          of type @c value_type\n+       *\n+       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is\n+       *  well-formed, otherwise returns @c a.allocate(n)\n+      */\n+      static pointer\n+      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)\n+      { return _S_allocate(__a, __n, __hint); }\n+\n+      /**\n+       *  @brief  Deallocate memory.\n+       *  @param  a  An allocator.\n+       *  @param  p  Pointer to the memory to deallocate.\n+       *  @param  n  The number of objects space was allocated for.\n+       *\n+       *  Calls <tt> a.deallocate(p, n) </tt>\n+      */\n+      static void deallocate(_Alloc& __a, pointer __p, size_type __n)\n+      { __a.deallocate(__p, __n); }\n+\n+      /**\n+       *  @brief  Construct an object of type @a Tp\n+       *  @param  a  An allocator.\n+       *  @param  p  Pointer to memory of suitable size and alignment for Tp\n+       *  @param  args Constructor arguments.\n+       *\n+       *  Calls <tt> a.construct(p, std::forward<Args>(args)...) </tt>\n+       *  if that expression is well-formed, otherwise uses placement-new\n+       *  to construct an object of type @a Tp at location @a p from the\n+       *  arguments @a args...\n+      */\n+      template<typename _Tp, typename... _Args>\n+\tstatic void construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n+\t{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief  Destroy an object of type @a Tp\n+       *  @param  a  An allocator.\n+       *  @param  p  Pointer to the object to destroy\n+       *\n+       *  Calls @c a.destroy(p) if that expression is well-formed,\n+       *  otherwise calls @c p->~Tp()\n+      */\n+      template <class _Tp>\n+\tstatic void destroy(_Alloc& __a, _Tp* __p)\n+\t{ _S_destroy(__a, __p); }\n+\n+      /**\n+       *  @brief  The maximum supported allocation size\n+       *  @param  a  An allocator.\n+       *  @return @c a.max_size() or @c numeric_limits<size_type>::max()\n+       *\n+       *  Returns @c a.max_size() if that expression is well-formed,\n+       *  otherwise returns @c numeric_limits<size_type>::max()\n+      */\n+      static size_type max_size(const _Alloc& __a)\n+      { return _S_max_size(__a); }\n+\n+      /**\n+       *  @brief  Obtain an allocator to use when copying a container.\n+       *  @param  rhs  An allocator.\n+       *  @return @c rhs.select_on_container_copy_construction() or @a rhs\n+       *\n+       *  Returns @c rhs.select_on_container_copy_construction() if that\n+       *  expression is well-formed, otherwise returns @a rhs\n+      */\n+      static _Alloc\n+      select_on_container_copy_construction(const _Alloc& __rhs)\n+      { return _S_select(__rhs); }\n+    };\n+\n+  template<typename _Alloc>\n+    inline void\n+    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)\n+    { __one = __two; }\n+\n+  template<typename _Alloc>\n+    inline void\n+    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)\n+    { }\n+\n+  template<typename _Alloc>\n+    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)\n+    {\n+      typedef allocator_traits<_Alloc> __traits;\n+      typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n+      __do_alloc_on_copy(__one, __two, __pocca());\n+    }\n+\n+  template<typename _Alloc>\n+    inline _Alloc __alloc_on_copy(const _Alloc& __a)\n+    {\n+      typedef allocator_traits<_Alloc> __traits;\n+      return __traits::select_on_container_copy_construction(__a);\n+    }\n+\n+  template<typename _Alloc>\n+    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)\n+    { __one = std::move(__two); }\n+\n+  template<typename _Alloc>\n+    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)\n+    { }\n+\n+  template<typename _Alloc>\n+    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)\n+    {\n+      typedef allocator_traits<_Alloc> __traits;\n+      typedef typename __traits::propagate_on_container_move_assignment __pocma;\n+      __do_alloc_on_move(__one, __two, __pocma());\n+    }\n+\n+  template<typename _Alloc>\n+    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)\n+    {\n+      using std::swap;\n+      swap(__one, __two);\n+    }\n+\n+  template<typename _Alloc>\n+    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)\n+    { }\n+\n+  template<typename _Alloc>\n+    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)\n+    {\n+      typedef allocator_traits<_Alloc> __traits;\n+      typedef typename __traits::propagate_on_container_swap __pocs;\n+      __do_alloc_on_swap(__one, __two, __pocs());\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif\n+#endif"}, {"sha": "76329b377ea8ab7349d3bc301bbf1b289eb937b5", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 9, "deletions": 405, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -47,12 +47,6 @@\n // Define the base class to std::allocator.\n #include <bits/c++allocator.h>\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#include <bits/ptr_traits.h>\n-#include <bits/uses_allocator.h>\n-#include <ext/numeric_traits.h>\n-#endif\n-\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -62,6 +56,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @ingroup memory\n    *\n    * Classes encapsulating memory operations.\n+   *\n+   * @{\n    */\n \n   template<typename _Tp>\n@@ -85,7 +81,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /**\n    * @brief  The @a standard allocator, as per [20.4].\n-   * @ingroup allocators\n    *\n    *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html\n    *  for further details.\n@@ -139,6 +134,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)\n     { return false; }\n \n+  /**\n+   * @}\n+   */\n+\n   // Inhibit implicit instantiations for required instantiations,\n   // which are defined via explicit instantiations elsewhere.\n #if _GLIBCXX_EXTERN_TEMPLATE\n@@ -207,404 +206,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n-  template<typename _Alloc, typename _Tp>\n-    class __alloctr_rebind_helper\n-    {\n-      template<typename _Alloc2, typename _Tp2>\n-\tstatic constexpr bool\n-       \t_S_chk(typename _Alloc2::template rebind<_Tp2>::other*)\n-\t{ return true; }\n-\n-      template<typename, typename>\n-        static constexpr bool\n-       \t_S_chk(...)\n-       \t{ return false; }\n-\n-    public:\n-      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);\n-    };\n-\n-  template<typename _Alloc, typename _Tp,\n-           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>\n-    struct __alloctr_rebind;\n-\n-  template<typename _Alloc, typename _Tp>\n-    struct __alloctr_rebind<_Alloc, _Tp, true>\n-    {\n-      typedef typename _Alloc::template rebind<_Tp>::other __type;\n-    };\n-\n-  template<template<typename, typename...> class _Alloc, typename _Tp,\n-            typename _Up, typename... _Args>\n-    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>\n-    {\n-      typedef _Alloc<_Tp, _Args...> __type;\n-    };\n-\n-  /**\n-   * @brief  Uniform interface to all allocator types.\n-   * @ingroup allocators\n-  */\n-  template<typename _Alloc>\n-    struct allocator_traits\n-    {\n-      /// The allocator type\n-      typedef _Alloc allocator_type;\n-      /// The allocated type\n-      typedef typename _Alloc::value_type value_type;\n-\n-#define _GLIBCXX_ALLOC_TR_NESTED_TYPE(_NTYPE, _ALT) \\\n-  private: \\\n-  template<typename _Tp> \\\n-    static typename _Tp::_NTYPE _S_##_NTYPE##_helper(_Tp*); \\\n-  static _ALT _S_##_NTYPE##_helper(...); \\\n-    typedef decltype(_S_##_NTYPE##_helper((_Alloc*)0)) __##_NTYPE; \\\n-  public:\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(pointer, value_type*)\n-\n-      /**\n-       * @brief   The allocator's pointer type.\n-       *\n-       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n-      */\n-      typedef __pointer pointer;\n-\n-// TODO: Use pointer_traits::rebind alias template.\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_pointer,\n-  typename pointer_traits<pointer>::template __rebind<const value_type>::__type)\n-\n-      /**\n-       * @brief   The allocator's const pointer type.\n-       *\n-       * @c Alloc::const_pointer if that type exists, otherwise\n-       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>\n-      */\n-      typedef __const_pointer const_pointer;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(void_pointer,\n-  typename pointer_traits<pointer>::template __rebind<void>::__type)\n-\n-      /**\n-       * @brief   The allocator's void pointer type.\n-       *\n-       * @c Alloc::void_pointer if that type exists, otherwise\n-       * <tt> pointer_traits<pointer>::rebind<void> </tt>\n-      */\n-      typedef __void_pointer void_pointer;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_void_pointer,\n-  typename pointer_traits<pointer>::template __rebind<const void>::__type)\n-\n-      /**\n-       * @brief   The allocator's const void pointer type.\n-       *\n-       * @c Alloc::const_void_pointer if that type exists, otherwise\n-       * <tt> pointer_traits<pointer>::rebind<const void> </tt>\n-      */\n-      typedef __const_void_pointer const_void_pointer;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,\n-                              typename pointer_traits<pointer>::difference_type)\n-\n-      /**\n-       * @brief   The allocator's difference type\n-       *\n-       * @c Alloc::difference_type if that type exists, otherwise\n-       * <tt> pointer_traits<pointer>::difference_type </tt>\n-      */\n-      typedef __difference_type difference_type;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,\n-                              typename make_unsigned<difference_type>::type)\n-\n-      /**\n-       * @brief   The allocator's size type\n-       *\n-       * @c Alloc::size_type if that type exists, otherwise\n-       * <tt> make_unsigned<difference_type>::type </tt>\n-      */\n-      typedef __size_type size_type;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,\n-                              false_type)\n-\n-      /**\n-       * @brief   How the allocator is propagated on copy assignment\n-       *\n-       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n-       * otherwise @c false_type\n-      */\n-      typedef __propagate_on_container_copy_assignment\n-       \tpropagate_on_container_copy_assignment;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,\n-                              false_type)\n-\n-      /**\n-       * @brief   How the allocator is propagated on move assignment\n-       *\n-       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n-       * otherwise @c false_type\n-      */\n-      typedef __propagate_on_container_move_assignment\n-       \tpropagate_on_container_move_assignment;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n-                              false_type)\n-\n-      /**\n-       * @brief   How the allocator is propagated on swap\n-       *\n-       * @c Alloc::propagate_on_container_swap if that type exists,\n-       * otherwise @c false_type\n-      */\n-      typedef __propagate_on_container_swap propagate_on_container_swap;\n-\n-#undef _GLIBCXX_ALLOC_TR_NESTED_TYPE\n-\n-      /* TODO: use template alias \n-      template<typename _Tp>\n-        using rebind_alloc = __alloctr_rebind<_Alloc, _Tp>::__type;\n-      template<typename _Tp>\n-        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n-      */\n-      template<typename _Tp>\n-        struct __rebind_alloc\n-\t{\n-  \t  typedef typename __alloctr_rebind<_Alloc, _Tp>::__type __type;\n-       \t};\n-\n-      template<typename _Tp>\n-        struct __rebind_traits\n-\t{\n-\t  typedef allocator_traits<typename __rebind_alloc<_Tp>::__type> __type;\n-\t};\n-\n-    private:\n-      template<typename _Alloc2>\n-\tstruct __allocate_helper\n-\t{\n-\t  template<typename _Alloc3,\n-\t    typename = decltype(std::declval<_Alloc3*>()->allocate(\n-\t\t  std::declval<size_type>(),\n-\t\t  std::declval<const_void_pointer>()))>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  typedef decltype(__test<_Alloc>(0)) type;\n-\t  static const bool value = type::value;\n-\t};\n-\n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<__allocate_helper<_Alloc2>::value, pointer>::type\n-       \t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)\n-\t{ return __a.allocate(__n, __hint); }\n-\n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<!__allocate_helper<_Alloc2>::value, pointer>::type\n-       \t_S_allocate(_Alloc2& __a, size_type __n, ...)\n-\t{ return __a.allocate(__n); }\n-\n-      template<typename _Tp, typename... _Args>\n-\tstruct __construct_helper\n-\t{\n-\t  template<typename _Alloc2,\n-\t    typename = decltype(std::declval<_Alloc2*>()->construct(\n-\t\t  std::declval<_Tp*>(), std::declval<_Args>()...))>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  typedef decltype(__test<_Alloc>(0)) type;\n-\t  static const bool value = type::value;\n-\t};\n-\n-      template<typename _Tp, typename... _Args>\n-\tstatic typename\n-       \tenable_if<__construct_helper<_Tp, _Args...>::value, void>::type\n-       \t_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n-\t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n-\n-      template<typename _Tp, typename... _Args>\n-\tstatic typename\n-       \tenable_if<!__construct_helper<_Tp, _Args...>::value, void>::type\n-       \t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n-\t{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n-\n-      template<typename _Tp>\n-\tstruct __destroy_helper\n-\t{\n-\t  template<typename _Alloc2,\n-\t    typename = decltype(std::declval<_Alloc2*>()->destroy(\n-\t\t  std::declval<_Tp*>()))>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  typedef decltype(__test<_Alloc>(0)) type;\n-\t  static const bool value = type::value;\n-\t};\n-\n-      template<typename _Tp>\n-\tstatic typename enable_if<__destroy_helper<_Tp>::value, void>::type\n-       \t_S_destroy(_Alloc& __a, _Tp* __p)\n-\t{ __a.destroy(__p); }\n-\n-      template<typename _Tp>\n-\tstatic typename enable_if<!__destroy_helper<_Tp>::value, void>::type\n-       \t_S_destroy(_Alloc&, _Tp* __p)\n-\t{ __p->~_Tp(); }\n-\n-      template<typename _Alloc2>\n-\tstruct __maxsize_helper\n-\t{\n-\t  template<typename _Alloc3,\n-\t    typename = decltype(std::declval<_Alloc3*>()->max_size())>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  typedef decltype(__test<_Alloc2>(0)) type;\n-\t  static const bool value = type::value;\n-\t};\n-\n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<__maxsize_helper<_Alloc2>::value, size_type>::type\n-       \t_S_max_size(_Alloc2& __a)\n-\t{ return __a.max_size(); }\n-\n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<!__maxsize_helper<_Alloc2>::value, size_type>::type\n-\t_S_max_size(_Alloc2&)\n-\t{ return __gnu_cxx::__numeric_traits<size_type>::__max; }\n-\n-      template<typename _Alloc2>\n-\tstruct __select_helper\n-\t{\n-\t  template<typename _Alloc3, typename\n-\t    = decltype(std::declval<_Alloc3*>()\n-\t\t->select_on_container_copy_construction())>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  typedef decltype(__test<_Alloc2>(0)) type;\n-\t  static const bool value = type::value;\n-\t};\n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<__select_helper<_Alloc2>::value, _Alloc2>::type\n-       \t_S_select(_Alloc2& __a)\n-\t{ return __a.select_on_container_copy_construction(); }\n-\n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type\n-       \t_S_select(_Alloc2& __a)\n-\t{ return __a; }\n-\n-    public:\n-\n-      /**\n-       *  @brief  Allocate memory.\n-       *  @param  a  An allocator.\n-       *  @param  n  The number of objects to allocate space for.\n-       *\n-       *  Calls @c a.allocate(n)\n-      */\n-      static pointer\n-      allocate(_Alloc& __a, size_type __n)\n-      { return __a.allocate(__n); }\n-\n-      /**\n-       *  @brief  Allocate memory.\n-       *  @param  a  An allocator.\n-       *  @param  n  The number of objects to allocate space for.\n-       *  @param  hint Aid to locality.\n-       *  @return Memory of suitable size and alignment for @a n objects\n-       *          of type @c value_type\n-       *\n-       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is\n-       *  well-formed, otherwise returns @c a.allocate(n)\n-      */\n-      static pointer\n-      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)\n-      { return _S_allocate(__a, __n, __hint); }\n-\n-      /**\n-       *  @brief  Deallocate memory.\n-       *  @param  a  An allocator.\n-       *  @param  p  Pointer to the memory to deallocate.\n-       *  @param  n  The number of objects space was allocated for.\n-       *\n-       *  Calls <tt> a.deallocate(p, n) </tt>\n-      */\n-      static void deallocate(_Alloc& __a, pointer __p, size_type __n)\n-      { __a.deallocate(__p, __n); }\n-\n-      /**\n-       *  @brief  Construct an object of type @a Tp\n-       *  @param  a  An allocator.\n-       *  @param  p  Pointer to memory of suitable size and alignment for Tp\n-       *  @param  args Constructor arguments.\n-       *\n-       *  Calls <tt> a.construct(p, std::forward<Args>(args)...) </tt>\n-       *  if that expression is well-formed, otherwise uses placement-new\n-       *  to construct an object of type @a Tp at location @a p from the\n-       *  arguments @a args...\n-      */\n-      template<typename _Tp, typename... _Args>\n-\tstatic void construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n-\t{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }\n-\n-      /**\n-       *  @brief  Destroy an object of type @a Tp\n-       *  @param  a  An allocator.\n-       *  @param  p  Pointer to the object to destroy\n-       *\n-       *  Calls @c a.destroy(p) if that expression is well-formed,\n-       *  otherwise calls @c p->~Tp()\n-      */\n-      template <class _Tp>\n-\tstatic void destroy(_Alloc& __a, _Tp* __p)\n-\t{ _S_destroy(__a, __p); }\n-\n-      /**\n-       *  @brief  The maximum supported allocation size\n-       *  @param  a  An allocator.\n-       *  @return @c a.max_size() or @c %numeric_limits<size_type>::max()\n-       *\n-       *  Returns @c a.max_size() if that expression is well-formed,\n-       *  otherwise returns @c %numeric_limits<size_type>::max()\n-      */\n-      static size_type max_size(const _Alloc& __a)\n-      { return _S_max_size(__a); }\n-\n-      /**\n-       *  @brief  Obtain an allocator to use when copying a container.\n-       *  @param  rhs  An allocator.\n-       *  @return @c rhs.select_on_container_copy_construction() or @a rhs\n-       *\n-       *  Returns @c rhs.select_on_container_copy_construction() if that\n-       *  expression is well-formed, otherwise returns @a rhs\n-      */\n-      static _Alloc\n-      select_on_container_copy_construction(const _Alloc& __rhs)\n-      { return _S_select(__rhs); }\n-    };\n-\n+  // Declare uses_allocator so it can be specialized in <queue> etc.\n+  template<typename, typename>\n+    struct uses_allocator;\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "c9090e55ac1b3115b3b7b64ad732ac907a55f605", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -60,6 +60,7 @@\n \n #include <new>\n #include <bits/move.h>\n+#include <ext/alloc_traits.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -141,8 +142,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n \t     _Allocator& __alloc)\n     {\n+      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n       for (; __first != __last; ++__first)\n-\t__alloc.destroy(std::__addressof(*__first));\n+\t__traits::destroy(__alloc, std::__addressof(*__first));\n     }\n \n   template<typename _ForwardIterator, typename _Tp>"}, {"sha": "ff0495b5800aeeb2f070f5d5febd62b805566ee2", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -241,8 +241,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _ForwardIterator __cur = __result;\n       __try\n \t{\n+\t  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n \t  for (; __first != __last; ++__first, ++__cur)\n-\t    __alloc.construct(std::__addressof(*__cur), *__first);\n+\t    __traits::construct(__alloc, std::__addressof(*__cur), *__first);\n \t  return __cur;\n \t}\n       __catch(...)\n@@ -290,8 +291,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _ForwardIterator __cur = __first;\n       __try\n \t{\n+\t  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n \t  for (; __cur != __last; ++__cur)\n-\t    __alloc.construct(std::__addressof(*__cur), __x);\n+\t    __traits::construct(__alloc, std::__addressof(*__cur), __x);\n \t}\n       __catch(...)\n \t{\n@@ -315,8 +317,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _ForwardIterator __cur = __first;\n       __try\n \t{\n+\t  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n \t  for (; __n > 0; --__n, ++__cur)\n-\t    __alloc.construct(std::__addressof(*__cur), __x);\n+\t    __traits::construct(__alloc, std::__addressof(*__cur), __x);\n \t}\n       __catch(...)\n \t{\n@@ -556,8 +559,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _ForwardIterator __cur = __first;\n       __try\n \t{\n+\t  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n \t  for (; __cur != __last; ++__cur)\n-\t    __alloc.construct(std::__addressof(*__cur));\n+\t    __traits::construct(__alloc, std::__addressof(*__cur));\n \t}\n       __catch(...)\n \t{\n@@ -585,8 +589,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _ForwardIterator __cur = __first;\n       __try\n \t{\n+\t  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n \t  for (; __n > 0; --__n, ++__cur)\n-\t    __alloc.construct(std::__addressof(*__cur));\n+\t    __traits::construct(__alloc, std::__addressof(*__cur));\n \t}\n       __catch(...)\n \t{"}, {"sha": "0d50fe173fc19c8e97d673a3e727eb14e1f68a29", "filename": "libstdc++-v3/include/ext/alloc_traits.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -0,0 +1,121 @@\n+// Allocator traits -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file ext/alloc_traits.h\n+ *  This file is a GNU extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _EXT_ALLOC_TRAITS_H\n+#define _EXT_ALLOC_TRAITS_H 1\n+\n+#pragma GCC system_header\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+# include <bits/alloc_traits.h>\n+#else\n+# include <bits/allocator.h>  // for __alloc_swap\n+#endif\n+\n+namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @brief  Uniform interface to C++98 and C++0x allocators.\n+   * @ingroup allocators\n+  */\n+template<typename _Alloc>\n+  struct __alloc_traits\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  : std::allocator_traits<_Alloc>\n+#endif\n+  {\n+    typedef _Alloc allocator_type;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    typedef std::allocator_traits<_Alloc>           _Base_type;\n+    typedef typename _Base_type::value_type         value_type;\n+    typedef typename _Base_type::pointer            pointer;\n+    typedef typename _Base_type::const_pointer      const_pointer;\n+    typedef typename _Base_type::size_type          size_type;\n+    // C++0x allocators do not define reference or const_reference\n+    typedef value_type&                             reference;\n+    typedef const value_type&                       const_reference;\n+    using _Base_type::allocate;\n+    using _Base_type::deallocate;\n+    using _Base_type::construct;\n+    using _Base_type::destroy;\n+\n+    static _Alloc _S_select_on_copy(const _Alloc& __a)\n+    { return _Base_type::select_on_container_copy_construction(__a); }\n+\n+    static void _S_on_swap(_Alloc& __a, _Alloc& __b)\n+    { std::__alloc_on_swap(__a, __b); }\n+\n+    static constexpr bool _S_propagate_on_copy_assign()\n+    { return _Base_type::propagate_on_container_copy_assignment::value; }\n+\n+    static constexpr bool _S_propagate_on_move_assign()\n+    { return _Base_type::propagate_on_container_move_assignment::value; }\n+\n+    static constexpr bool _S_propagate_on_swap()\n+    { return _Base_type::propagate_on_container_swap::value; }\n+\n+#else\n+\n+    typedef typename _Alloc::pointer                pointer;\n+    typedef typename _Alloc::const_pointer          const_pointer;\n+    typedef typename _Alloc::value_type             value_type;\n+    typedef typename _Alloc::reference              reference;\n+    typedef typename _Alloc::const_reference        const_reference;\n+    typedef typename _Alloc::size_type              size_type;\n+\n+    static pointer\n+    allocate(_Alloc& __a, size_type __n)\n+    { return __a.allocate(__n); }\n+\n+    static void deallocate(_Alloc& __a, pointer __p, size_type __n)\n+    { __a.deallocate(__p, __n); }\n+\n+    template<typename _Tp>\n+      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)\n+      { __a.construct(__p, __arg); }\n+\n+    static void destroy(_Alloc& __a, pointer __p)\n+    { __a.destroy(__p); }\n+\n+    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }\n+\n+    static void _S_on_swap(_Alloc& __a, _Alloc& __b)\n+    {\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);\n+    }\n+#endif\n+  };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif"}, {"sha": "e846eba489d36e85f0bdb67983d0d71ba84dbd35", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eb60bd92f807f4dbbcc29441aba330a12f9c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=e8eb60bd92f807f4dbbcc29441aba330a12f9c4b", "patch": "@@ -76,6 +76,7 @@\n #  include <ext/concurrence.h>\n #  include <bits/functexcept.h>\n #  include <bits/stl_function.h>  // std::less\n+#  include <bits/uses_allocator.h>\n #  include <type_traits>\n #  include <functional>\n #  include <debug/debug.h>"}]}