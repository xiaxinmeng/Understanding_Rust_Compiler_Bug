{"sha": "660584689a4397f18cda03b458703bbbf909dd12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYwNTg0Njg5YTQzOTdmMThjZGEwM2I0NTg3MDNiYmJmOTA5ZGQxMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-22T21:28:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-22T21:28:07Z"}, "message": "lto-symtab.c (lto_varpool_replace_node): Do not merge needed flags.\n\n\n\t* lto-symtab.c (lto_varpool_replace_node): Do not merge needed flags.\n\t* cgraphbuild.c (record_reference, record_type_list, mark_address,\n\tmark_load, mark_store): Do not mark varpool nodes as needed.\n\t* cgraph.c (cgraph_new_nodes): Remove.\n\t(cgraph_create_function_alias): Do not mark nodes as reachable.\n\t(cgraph_add_thunk): Likewise.\n\t(cgraph_mark_reachable_node): Do not manage the queue.\n\t* cgraph.h (cgraph_node): Remove next_needed.\n\t(varpool_nodes_queue): Remove next_needed and prev_needed.\n\t(x_cgraph_nodes_queue, x_cgraph_nodes_queue, cgraph_new_nodes): Remove.\n\t(cgraph_new_nodes): Declare.\n\t(x_varpool_nodes_queue, varpool_nodes_queue); Remove.\n\t(varpool_analyze_pending_decls): Remove.\n\t(varpool_analyze_node): New.\n\t(varpool_mark_needed_node): Remove.\n\t(varpool_first_variable, varpool_next_variable): New inlines.\n\t(varpool_first_static_initializer, varpool_next_static_initializer): Update.\n\t(FOR_EACH_STATIC_VARIABLE): Remove unused walker.\n\t(varpool_first_defined_variable): New inline.\n\t(varpool_next_defined_variable): New inline\n\t(FOR_EACH_VARIABLE): Reimplement.\n\t(FOR_EACH_DEFINED_VARIABLE): Reimplement.\n\t* toplev.c (wrapup_global_declaration_2): Use analyzed instead of\n\tneeded flag.\n\t* cgraphunit.c (cgraph_new_nodes): Declare here.\n\t(enqueue_node): New function.\n\t(cgraph_process_new_functions): update for new\n\tnode set; when constructing cgraph enqueue node for processing.\n\t(cgraph_add_new_function): Use new node set.\n\t(process_function_and_variable_attributes): Do not set varpool needed\n\tflags.\n\t(referred_to_p): New function.\n\t(varpool_finalize_decl): Move here from varpool.c; enqueue needed node\n\twhen varpool is in construction.\n\t(cgraph_analyze_functions): Rewrite.\n\t(cgraph_expand_all_functions): Update.\n\t(cgraph_output_in_order): Do not analyze pending decls; do not set needed flags.\n\t(cgraph_optimize): Do not analyze pending decls.\n\t* lto-cgraph.c (input_varpool_node): Clear analyzed flag for objects in other\n\tpartition; do not mark node as needed.\n\t* dwarf2out.c (reference_to_unused): Use analyzed flag.\n\t(premark_types_used_by_global_vars_helper): Likewise.\n\t* ipa.c (process_references): Do not call varpool_mark_needed_node.\n\t(cgraph_remove_unreachable_nodes): Do not rely on varpool and\n\tcgrpah queues.\n\t(function_and_variable_visibility): Do not mark node as needed.\n\t(whole_program_function_and_variable_visibility): Likewise.\n\t* Makefile.in (gt-varpool.h): No longer needed.\n\t* passes.c (execute_one_pass, execute_ipa_pass_list): Update.\n\t(ipa_write_summaries): Do not use needed flag.\n\t* varpool.c: Do not include gt-varpool.h\n\t(x_varpool_nodes_queue, x_varpool_last_needed_node,\n\tx_varpool_last_needed_node, x_varpool_first_unanalyzed_node,\n\tx_varpool_first_unanalyzed_node, varpool_assembled_nodes_queue):\n\tRemove.\n\t(varpool_remove_node): Do not update the lists.\n\t(dump_varpool_node): Do not dump needed flag.\n\t(varpool_enqueue_needed_node): Remove.\n\t(varpool_mark_needed_node): Remove.\n\t(varpool_reset_queue): Remove.\n\t(varpool_finalize_decl): Move to cgraphunit.c\n\t(varpool_analyze_node): New functions based on former\n\tvarpool_analyze_pending_decls.\n\t(varpool_analyze_pending_decls): Remove.\n\t(varpool_assemble_decl): Do not update the lists.\n\t(enqueue_node): New function.\n\t(varpool_remove_unreferenced_decls): Rewrite.\n\t(varpool_empty_needed_queue): Remove.\n\t(add_new_static_var): Do not mark node as needed.\n\t(varpool_create_variable_alias): Handle expansion state\n\tcreation.\n\t* except.c (output_ttype): Do not mark node as needed.\n\t* varasm.c (mark_decl_referenced): Do not use mark_needed_node.\n\t* tree-profile.c (init_ic_make_global_vars, init_ic_make_global_vars):\n\tLikewise.\n\t* tree-switch-conversion.c (build_one_array): Likewise.\n\n\t* class.c (build_utf8_ref): Do not mark varpool node as needed.\n\n\t* gcc-interface/utils.c (gnat_write_global_declarations): Do not mark\n\tneeded node.\n\n\t* lto-partition.c (partition_varpool_node_p): Do not use needed flag.\n\n\t* decl2.c (maybe_make_one_only): Mark keyed COMDATs as USED so they\n\tgets finalized.\n\nFrom-SVN: r186687", "tree": {"sha": "a4cd93cef18f73580dc0226c3ce10cbae70f9f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4cd93cef18f73580dc0226c3ce10cbae70f9f08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/660584689a4397f18cda03b458703bbbf909dd12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660584689a4397f18cda03b458703bbbf909dd12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/660584689a4397f18cda03b458703bbbf909dd12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660584689a4397f18cda03b458703bbbf909dd12/comments", "author": null, "committer": null, "parents": [{"sha": "f04e40afc115bcf2143f541baa9e4cccef19922a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f04e40afc115bcf2143f541baa9e4cccef19922a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f04e40afc115bcf2143f541baa9e4cccef19922a"}], "stats": {"total": 1059, "additions": 524, "deletions": 535}, "files": [{"sha": "88968a07b15ec6237aaaee406bd6c5df257e2738", "filename": "gcc/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -1,3 +1,82 @@\n+2012-04-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_varpool_replace_node): Do not merge needed flags.\n+\t* cgraphbuild.c (record_reference, record_type_list, mark_address,\n+\tmark_load, mark_store): Do not mark varpool nodes as needed.\n+\t* cgraph.c (cgraph_new_nodes): Remove.\n+\t(cgraph_create_function_alias): Do not mark nodes as reachable.\n+\t(cgraph_add_thunk): Likewise.\n+\t(cgraph_mark_reachable_node): Do not manage the queue.\n+\t* cgraph.h (cgraph_node): Remove next_needed.\n+\t(varpool_nodes_queue): Remove next_needed and prev_needed.\n+\t(x_cgraph_nodes_queue, x_cgraph_nodes_queue, cgraph_new_nodes): Remove.\n+\t(cgraph_new_nodes): Declare.\n+\t(x_varpool_nodes_queue, varpool_nodes_queue); Remove.\n+\t(varpool_analyze_pending_decls): Remove.\n+\t(varpool_analyze_node): New.\n+\t(varpool_mark_needed_node): Remove.\n+\t(varpool_first_variable, varpool_next_variable): New inlines.\n+\t(varpool_first_static_initializer, varpool_next_static_initializer): Update.\n+\t(FOR_EACH_STATIC_VARIABLE): Remove unused walker.\n+\t(varpool_first_defined_variable): New inline.\n+\t(varpool_next_defined_variable): New inline\n+\t(FOR_EACH_VARIABLE): Reimplement.\n+\t(FOR_EACH_DEFINED_VARIABLE): Reimplement.\n+\t* toplev.c (wrapup_global_declaration_2): Use analyzed instead of\n+\tneeded flag.\n+\t* cgraphunit.c (cgraph_new_nodes): Declare here.\n+\t(enqueue_node): New function.\n+\t(cgraph_process_new_functions): update for new\n+\tnode set; when constructing cgraph enqueue node for processing.\n+\t(cgraph_add_new_function): Use new node set.\n+\t(process_function_and_variable_attributes): Do not set varpool needed\n+\tflags.\n+\t(referred_to_p): New function.\n+\t(varpool_finalize_decl): Move here from varpool.c; enqueue needed node\n+\twhen varpool is in construction.\n+\t(cgraph_analyze_functions): Rewrite.\n+\t(cgraph_expand_all_functions): Update.\n+\t(cgraph_output_in_order): Do not analyze pending decls; do not set needed flags.\n+\t(cgraph_optimize): Do not analyze pending decls.\n+\t* lto-cgraph.c (input_varpool_node): Clear analyzed flag for objects in other\n+\tpartition; do not mark node as needed.\n+\t* dwarf2out.c (reference_to_unused): Use analyzed flag.\n+\t(premark_types_used_by_global_vars_helper): Likewise.\n+\t* ipa.c (process_references): Do not call varpool_mark_needed_node.\n+\t(cgraph_remove_unreachable_nodes): Do not rely on varpool and\n+\tcgrpah queues.\n+\t(function_and_variable_visibility): Do not mark node as needed.\n+\t(whole_program_function_and_variable_visibility): Likewise.\n+\t* Makefile.in (gt-varpool.h): No longer needed.\n+\t* passes.c (execute_one_pass, execute_ipa_pass_list): Update.\n+\t(ipa_write_summaries): Do not use needed flag.\n+\t* varpool.c: Do not include gt-varpool.h\n+\t(x_varpool_nodes_queue, x_varpool_last_needed_node,\n+\tx_varpool_last_needed_node, x_varpool_first_unanalyzed_node,\n+\tx_varpool_first_unanalyzed_node, varpool_assembled_nodes_queue):\n+\tRemove.\n+\t(varpool_remove_node): Do not update the lists.\n+\t(dump_varpool_node): Do not dump needed flag.\n+\t(varpool_enqueue_needed_node): Remove.\n+\t(varpool_mark_needed_node): Remove.\n+\t(varpool_reset_queue): Remove.\n+\t(varpool_finalize_decl): Move to cgraphunit.c\n+\t(varpool_analyze_node): New functions based on former\n+\tvarpool_analyze_pending_decls.\n+\t(varpool_analyze_pending_decls): Remove.\n+\t(varpool_assemble_decl): Do not update the lists.\n+\t(enqueue_node): New function.\n+\t(varpool_remove_unreferenced_decls): Rewrite.\n+\t(varpool_empty_needed_queue): Remove.\n+\t(add_new_static_var): Do not mark node as needed.\n+\t(varpool_create_variable_alias): Handle expansion state\n+\tcreation.\n+\t* except.c (output_ttype): Do not mark node as needed.\n+\t* varasm.c (mark_decl_referenced): Do not use mark_needed_node.\n+\t* tree-profile.c (init_ic_make_global_vars, init_ic_make_global_vars):\n+\tLikewise.\n+\t* tree-switch-conversion.c (build_one_array): Likewise.\n+\n 2012-04-22  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c/44774"}, {"sha": "97c8973d260c8c84e411f660a5c64b3d690bfe15", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -2934,7 +2934,7 @@ cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(CGRAPH_H) langhooks.h $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) \\\n    $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(GIMPLE_H) \\\n-   $(TREE_FLOW_H) gt-varpool.h\n+   $(TREE_FLOW_H) \n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(TIMEVAR_H) $(GIMPLE_H) $(GGC_H) pointer-set.h \\\n    $(IPA_UTILS_H)\n@@ -3719,7 +3719,6 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-scalar-evolution.c \\\n   $(srcdir)/tree-ssa-operands.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n-  $(srcdir)/varpool.c \\\n   $(srcdir)/tree-parloops.c \\\n   $(srcdir)/omp-low.c \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\"}, {"sha": "34144913fd96c3fcac79bc0e101f9a18e016c438", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -1,3 +1,8 @@\n+2012-04-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc-interface/utils.c (gnat_write_global_declarations): Do not mark\n+\tneeded node.\n+\n 2012-04-20  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc-interface/utils.c (gnat_write_global_declarations): Update for new"}, {"sha": "41f83bfbe8a134d9738256d3c8caeb4286e308dd", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -4860,7 +4860,6 @@ gnat_write_global_declarations (void)\n       TREE_ASM_WRITTEN (dummy_global) = 1;\n       node = varpool_node (dummy_global);\n       node->symbol.force_output = 1;\n-      varpool_mark_needed_node (node);\n \n       while (!VEC_empty (tree, types_used_by_cur_var_decl))\n \t{"}, {"sha": "ed4cdf64d08d6679b2dee00669df711364b1585b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -123,11 +123,6 @@ static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n symtab_node x_cgraph_nodes_queue;\n #define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n \n-/* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n-   secondary queue used during optimization to accommodate passes that\n-   may generate new functions that need to be optimized and expanded.  */\n-struct cgraph_node *cgraph_new_nodes;\n-\n /* Number of nodes in existence.  */\n int cgraph_n_nodes;\n \n@@ -141,7 +136,7 @@ int cgraph_edge_max_uid;\n bool cgraph_global_info_ready = false;\n \n /* What state callgraph is in right now.  */\n-enum cgraph_state cgraph_state = CGRAPH_STATE_CONSTRUCTION;\n+enum cgraph_state cgraph_state = CGRAPH_STATE_PARSING;\n \n /* Set when the cgraph is fully build and the basic flags are computed.  */\n bool cgraph_function_flags_ready = false;\n@@ -499,11 +494,6 @@ cgraph_create_function_alias (tree alias, tree decl)\n   alias_node->thunk.alias = decl;\n   alias_node->local.finalized = true;\n   alias_node->alias = 1;\n-\n-  if ((TREE_PUBLIC (alias) && !DECL_COMDAT (alias) && !DECL_EXTERNAL (alias))\n-      || (DECL_VIRTUAL_P (alias)\n-\t  && (DECL_COMDAT (alias) || DECL_EXTERNAL (alias))))\n-    cgraph_mark_reachable_node (alias_node);\n   return alias_node;\n }\n \n@@ -539,7 +529,7 @@ cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree ali\n \n struct cgraph_node *\n cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n-\t\t  tree alias, tree decl,\n+\t\t  tree alias, tree decl ATTRIBUTE_UNUSED,\n \t\t  bool this_adjusting,\n \t\t  HOST_WIDE_INT fixed_offset, HOST_WIDE_INT virtual_value,\n \t\t  tree virtual_offset,\n@@ -569,14 +559,6 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   node->thunk.thunk_p = true;\n   node->local.finalized = true;\n \n-  if (cgraph_decide_is_function_needed (node, decl))\n-    cgraph_mark_reachable_node (node);\n-\n-  if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-      || (DECL_VIRTUAL_P (decl)\n-\t  && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n-    cgraph_mark_reachable_node (node);\n-\n   return node;\n }\n \n@@ -1508,9 +1490,6 @@ cgraph_mark_reachable_node (struct cgraph_node *node)\n       else\n         notice_global_symbol (node->symbol.decl);\n       node->reachable = 1;\n-\n-      node->next_needed = cgraph_nodes_queue;\n-      x_cgraph_nodes_queue = (symtab_node)node;\n     }\n }\n "}, {"sha": "8e06fc1fc1b8253afc4becc3238389464e53ba86", "filename": "gcc/cgraph.h", "status": "modified", "additions": 54, "deletions": 43, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -215,10 +215,6 @@ struct GTY(()) cgraph_node {\n   struct cgraph_node *\n     GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n     next_nested;\n-  /* Pointer to the next function in cgraph_nodes_queue.  */\n-  struct cgraph_node *\n-    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n-    next_needed;\n   /* Pointer to the next clone.  */\n   struct cgraph_node *next_sibling_clone;\n   struct cgraph_node *prev_sibling_clone;\n@@ -419,13 +415,6 @@ struct GTY(()) varpool_node {\n   struct symtab_node_base symbol;\n   /* For aliases points to declaration DECL is alias of.  */\n   tree alias_of;\n-  /* Pointer to the next function in varpool_nodes_queue.  */\n-  struct varpool_node *\n-    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n-    next_needed;\n-  struct varpool_node *\n-    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n-    prev_needed;\n \n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n@@ -471,6 +460,8 @@ extern GTY(()) int cgraph_edge_max_uid;\n extern bool cgraph_global_info_ready;\n enum cgraph_state\n {\n+  /* Frontend is parsing and finalizing functions.  */\n+  CGRAPH_STATE_PARSING,\n   /* Callgraph is being constructed.  It is safe to add new functions.  */\n   CGRAPH_STATE_CONSTRUCTION,\n   /* Callgraph is built and IPA passes are being run.  */\n@@ -484,9 +475,7 @@ enum cgraph_state\n };\n extern enum cgraph_state cgraph_state;\n extern bool cgraph_function_flags_ready;\n-extern GTY(()) symtab_node x_cgraph_nodes_queue;\n-#define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n-extern GTY(()) struct cgraph_node *cgraph_new_nodes;\n+extern cgraph_node_set cgraph_new_nodes;\n \n extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n extern GTY(()) int symtab_order;\n@@ -687,9 +676,6 @@ bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n bool cgraph_optimize_for_size_p (struct cgraph_node *);\n \n /* In varpool.c  */\n-extern GTY(()) symtab_node x_varpool_nodes_queue;\n-#define varpool_nodes_queue ((struct varpool_node *)x_varpool_nodes_queue)\n-\n struct varpool_node *varpool_node (tree);\n struct varpool_node *varpool_node_for_asm (tree asmname);\n void varpool_mark_needed_node (struct varpool_node *);\n@@ -709,9 +695,8 @@ void varpool_remove_node (struct varpool_node *node);\n void varpool_finalize_named_section_flags (struct varpool_node *node);\n bool varpool_assemble_pending_decls (void);\n bool varpool_assemble_decl (struct varpool_node *node);\n-bool varpool_analyze_pending_decls (void);\n+void varpool_analyze_node (struct varpool_node *);\n void varpool_remove_unreferenced_decls (void);\n-void varpool_empty_needed_queue (void);\n struct varpool_node * varpool_extra_name_alias (tree, tree);\n struct varpool_node * varpool_create_variable_alias (tree, tree);\n void varpool_reset_queue (void);\n@@ -799,16 +784,48 @@ varpool_node_name(struct varpool_node *node)\n #define FOR_EACH_SYMBOL(node) \\\n    for ((node) = symtab_nodes; (node); (node) = (node)->symbol.next)\n \n+\n+/* Return first variable.  */\n+static inline struct varpool_node *\n+varpool_first_variable (void)\n+{\n+  symtab_node node;\n+  for (node = symtab_nodes; node; node = node->symbol.next)\n+    {\n+      if (symtab_variable_p (node))\n+\treturn varpool (node);\n+    }\n+  return NULL;\n+}\n+\n+/* Return next variable after NODE.  */\n+static inline struct varpool_node *\n+varpool_next_variable (struct varpool_node *node)\n+{\n+  symtab_node node1 = (symtab_node) node->symbol.next;\n+  for (; node1; node1 = node1->symbol.next)\n+    {\n+      if (symtab_variable_p (node1))\n+\treturn varpool (node1);\n+    }\n+  return NULL;\n+}\n+/* Walk all variables.  */\n+#define FOR_EACH_VARIABLE(node) \\\n+   for ((node) = varpool_first_variable (); \\\n+        (node); \\\n+\t(node) = varpool_next_variable ((node)))\n+\n /* Return first reachable static variable with initializer.  */\n static inline struct varpool_node *\n varpool_first_static_initializer (void)\n {\n-  struct varpool_node *node;\n-  for (node = varpool_nodes_queue; node; node = node->next_needed)\n+  symtab_node node;\n+  for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      gcc_checking_assert (TREE_CODE (node->symbol.decl) == VAR_DECL);\n-      if (DECL_INITIAL (node->symbol.decl))\n-\treturn node;\n+      if (symtab_variable_p (node)\n+\t  && DECL_INITIAL (node->symbol.decl))\n+\treturn varpool (node);\n     }\n   return NULL;\n }\n@@ -817,56 +834,50 @@ varpool_first_static_initializer (void)\n static inline struct varpool_node *\n varpool_next_static_initializer (struct varpool_node *node)\n {\n-  for (node = node->next_needed; node; node = node->next_needed)\n+  symtab_node node1 = (symtab_node) node->symbol.next;\n+  for (; node1; node1 = node1->symbol.next)\n     {\n-      gcc_checking_assert (TREE_CODE (node->symbol.decl) == VAR_DECL);\n-      if (DECL_INITIAL (node->symbol.decl))\n-\treturn node;\n+      if (symtab_variable_p (node1)\n+\t  && DECL_INITIAL (node1->symbol.decl))\n+\treturn varpool (node1);\n     }\n   return NULL;\n }\n \n-/* Walk all reachable static variables.  */\n-#define FOR_EACH_STATIC_VARIABLE(node) \\\n-   for ((node) = varpool_nodes_queue; (node); (node) = (node)->next_needed)\n /* Walk all static variables with initializer set.  */\n #define FOR_EACH_STATIC_INITIALIZER(node) \\\n    for ((node) = varpool_first_static_initializer (); (node); \\\n         (node) = varpool_next_static_initializer (node))\n \n-/* Return first variable.  */\n+/* Return first reachable static variable with initializer.  */\n static inline struct varpool_node *\n-varpool_first_variable (void)\n+varpool_first_defined_variable (void)\n {\n   symtab_node node;\n   for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      if (symtab_variable_p (node))\n+      if (symtab_variable_p (node) && varpool (node)->analyzed)\n \treturn varpool (node);\n     }\n   return NULL;\n }\n \n-/* Return next variable after NODE.  */\n+/* Return next reachable static variable with initializer after NODE.  */\n static inline struct varpool_node *\n-varpool_next_variable (struct varpool_node *node)\n+varpool_next_defined_variable (struct varpool_node *node)\n {\n   symtab_node node1 = (symtab_node) node->symbol.next;\n   for (; node1; node1 = node1->symbol.next)\n     {\n-      if (symtab_variable_p (node1))\n+      if (symtab_variable_p (node1) && varpool (node1)->analyzed)\n \treturn varpool (node1);\n     }\n   return NULL;\n }\n-/* Walk all variables.  */\n-#define FOR_EACH_VARIABLE(node) \\\n-   for ((node) = varpool_first_variable (); \\\n-        (node); \\\n-\t(node) = varpool_next_variable ((node)))\n /* Walk all variables with definitions in current unit.  */\n #define FOR_EACH_DEFINED_VARIABLE(node) \\\n-   for ((node) = varpool_nodes_queue; (node); (node) = (node)->next_needed)\n+   for ((node) = varpool_first_defined_variable (); (node); \\\n+        (node) = varpool_next_defined_variable (node))\n \n /* Return first function with body defined.  */\n static inline struct cgraph_node *"}, {"sha": "445a392110dce324636a4fe27c4d8e8b208641c8", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -87,7 +87,6 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  struct varpool_node *vnode = varpool_node (decl);\n \t  if (lang_hooks.callgraph.analyze_expr)\n \t    lang_hooks.callgraph.analyze_expr (&decl, walk_subtrees);\n-\t  varpool_mark_needed_node (vnode);\n \t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n \t\t\t\t(symtab_node)vnode,\n \t\t\t\tIPA_REF_ADDR, NULL);\n@@ -130,7 +129,6 @@ record_type_list (struct cgraph_node *node, tree list)\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n \t      struct varpool_node *vnode = varpool_node (type);\n-\t      varpool_mark_needed_node (vnode);\n \t      ipa_record_reference ((symtab_node)node,\n \t\t\t\t    (symtab_node)vnode,\n \t\t\t\t    IPA_REF_ADDR, NULL);\n@@ -245,7 +243,6 @@ mark_address (gimple stmt, tree addr, void *data)\n \n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&addr, &walk_subtrees);\n-      varpool_mark_needed_node (vnode);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_ADDR, stmt);\n@@ -278,7 +275,6 @@ mark_load (gimple stmt, tree t, void *data)\n \n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n-      varpool_mark_needed_node (vnode);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_LOAD, stmt);\n@@ -300,7 +296,6 @@ mark_store (gimple stmt, tree t, void *data)\n \n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n-      varpool_mark_needed_node (vnode);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_STORE, stmt);"}, {"sha": "409afa13da48e1242d99176d09a530963e2ef247", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 223, "deletions": 142, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -145,6 +145,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"regset.h\"     /* FIXME: For reg_obstack.  */\n \n+/* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n+   secondary queue used during optimization to accommodate passes that\n+   may generate new functions that need to be optimized and expanded.  */\n+cgraph_node_set cgraph_new_nodes;\n+\n static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n@@ -192,6 +197,23 @@ cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n   return false;\n }\n \n+/* Head of the queue of nodes to be processed while building callgraph */\n+\n+static symtab_node first = (symtab_node)(void *)1;\n+\n+/* Add NODE to queue starting at FIRST. \n+   The queue is linked via AUX pointers and terminated by pointer to 1.  */\n+\n+static void\n+enqueue_node (symtab_node node)\n+{\n+  if (node->symbol.aux)\n+    return;\n+  gcc_checking_assert (first);\n+  node->symbol.aux = first;\n+  first = node;\n+}\n+\n /* Process CGRAPH_NEW_FUNCTIONS and perform actions necessary to add these\n    functions into callgraph in a way so they look like ordinary reachable\n    functions inserted into callgraph already at construction time.  */\n@@ -202,26 +224,26 @@ cgraph_process_new_functions (void)\n   bool output = false;\n   tree fndecl;\n   struct cgraph_node *node;\n+  cgraph_node_set_iterator csi;\n \n-  varpool_analyze_pending_decls ();\n+  if (!cgraph_new_nodes)\n+    return false;\n   /*  Note that this queue may grow as its being processed, as the new\n       functions may generate new ones.  */\n-  while (cgraph_new_nodes)\n+  for (csi = csi_start (cgraph_new_nodes); !csi_end_p (csi); csi_next (&csi))\n     {\n-      node = cgraph_new_nodes;\n+      node = csi_node (csi);\n       fndecl = node->symbol.decl;\n-      cgraph_new_nodes = cgraph_new_nodes->next_needed;\n       switch (cgraph_state)\n \t{\n \tcase CGRAPH_STATE_CONSTRUCTION:\n \t  /* At construction time we just need to finalize function and move\n \t     it into reachable functions list.  */\n \n-\t  node->next_needed = NULL;\n \t  cgraph_finalize_function (fndecl, false);\n-\t  cgraph_mark_reachable_node (node);\n \t  output = true;\n           cgraph_call_function_insertion_hooks (node);\n+\t  enqueue_node ((symtab_node) node);\n \t  break;\n \n \tcase CGRAPH_STATE_IPA:\n@@ -262,8 +284,9 @@ cgraph_process_new_functions (void)\n \t  gcc_unreachable ();\n \t  break;\n \t}\n-      varpool_analyze_pending_decls ();\n     }\n+  free_cgraph_node_set (cgraph_new_nodes);\n+  cgraph_new_nodes = NULL;\n   return output;\n }\n \n@@ -372,13 +395,17 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n   struct cgraph_node *node;\n   switch (cgraph_state)\n     {\n+      case CGRAPH_STATE_PARSING:\n+\tcgraph_finalize_function (fndecl, false);\n+\tbreak;\n       case CGRAPH_STATE_CONSTRUCTION:\n \t/* Just enqueue function to be processed at nearest occurrence.  */\n \tnode = cgraph_create_node (fndecl);\n-\tnode->next_needed = cgraph_new_nodes;\n \tif (lowered)\n \t  node->lowered = true;\n-\tcgraph_new_nodes = node;\n+\tif (!cgraph_new_nodes)\n+\t  cgraph_new_nodes = cgraph_node_set_new ();\n+\tcgraph_node_set_add (cgraph_new_nodes, node);\n         break;\n \n       case CGRAPH_STATE_IPA:\n@@ -406,8 +433,9 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t  }\n \tif (lowered)\n \t  node->lowered = true;\n-\tnode->next_needed = cgraph_new_nodes;\n-\tcgraph_new_nodes = node;\n+\tif (!cgraph_new_nodes)\n+\t  cgraph_new_nodes = cgraph_node_set_new ();\n+\tcgraph_node_set_add (cgraph_new_nodes, node);\n         break;\n \n       case CGRAPH_STATE_FINISHED:\n@@ -1091,26 +1119,13 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n     {\n       tree decl = vnode->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n-\t{\n-\t  vnode->symbol.force_output = true;\n-\t  if (vnode->finalized)\n-\t    varpool_mark_needed_node (vnode);\n-\t}\n-      if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-\t  && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl))\n-\t  && TREE_PUBLIC (vnode->symbol.decl))\n-\t{\n-\t  if (vnode->finalized)\n-\t    varpool_mark_needed_node (vnode);\n-\t}\n+\tvnode->symbol.force_output = true;\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n \t  if (! TREE_PUBLIC (vnode->symbol.decl))\n \t    warning_at (DECL_SOURCE_LOCATION (vnode->symbol.decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n-\t  else if (vnode->finalized)\n-\t    varpool_mark_needed_node (vnode);\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n \t  && vnode->finalized\n@@ -1127,151 +1142,231 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n     }\n }\n \n-/* Process CGRAPH_NODES_NEEDED queue, analyze each function (and transitively\n-   each reachable functions) and build cgraph.\n-   The function can be called multiple times after inserting new nodes\n-   into beginning of queue.  Just the new part of queue is re-scanned then.  */\n+/* Return true when there are references to NODE.  */\n+\n+static bool\n+referred_to_p (symtab_node node)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref);\n+       i++)\n+    return true;\n+  if (symtab_function_p (node) && cgraph (node)->callers)\n+    return true;\n+  return false;\n+}\n+\n+/* Mark DECL as finalized.  By finalizing the declaration, frontend instruct the\n+   middle end to output the variable to asm file, if needed or externally\n+   visible.  */\n+\n+void\n+varpool_finalize_decl (tree decl)\n+{\n+  struct varpool_node *node = varpool_node (decl);\n+\n+  gcc_assert (TREE_STATIC (decl));\n+\n+  if (node->finalized)\n+    return;\n+  notice_global_symbol (decl);\n+  node->finalized = true;\n+  if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n+      /* Traditionally we do not eliminate static variables when not\n+\t optimizing and when not doing toplevel reoder.  */\n+      || (!flag_toplevel_reorder && !DECL_COMDAT (node->symbol.decl)\n+\t  && !DECL_ARTIFICIAL (node->symbol.decl)))\n+    node->symbol.force_output = true;\n+\n+  if (cgraph_state == CGRAPH_STATE_CONSTRUCTION\n+      && (decide_is_variable_needed (node, decl)\n+\t  || referred_to_p ((symtab_node)node)))\n+    enqueue_node ((symtab_node)node);\n+  if (cgraph_state >= CGRAPH_STATE_IPA_SSA)\n+    varpool_analyze_node (node);\n+}\n+\n+/* Discover all functions and variables that are trivially needed, analyze\n+   them as well as all functions and variables referred by them  */\n \n static void\n cgraph_analyze_functions (void)\n {\n   /* Keep track of already processed nodes when called multiple times for\n      intermodule optimization.  */\n   static struct cgraph_node *first_analyzed;\n-  struct cgraph_node *first_processed = first_analyzed;\n+  struct cgraph_node *first_handled = first_analyzed;\n   static struct varpool_node *first_analyzed_var;\n-  struct cgraph_node *node, *next;\n+  struct varpool_node *first_handled_var = first_analyzed_var;\n+\n+  symtab_node node, next;\n+  int i;\n+  struct ipa_ref *ref;\n+  bool changed = true;\n \n   bitmap_obstack_initialize (NULL);\n-  process_function_and_variable_attributes (first_processed,\n-\t\t\t\t\t    first_analyzed_var);\n-  first_processed = cgraph_first_function ();\n-  first_analyzed_var = varpool_first_variable ();\n-  varpool_analyze_pending_decls ();\n-  if (cgraph_dump_file)\n+  cgraph_state = CGRAPH_STATE_CONSTRUCTION;\n+\n+  /* Analysis adds static variables that in turn adds references to new functions.\n+     So we need to iterate the process until it stabilize.  */\n+  while (changed)\n     {\n-      fprintf (cgraph_dump_file, \"Initial entry points:\");\n-      for (node = cgraph_first_function (); node != first_analyzed;\n-\t   node = cgraph_next_function (node))\n-\tif (cgraph_decide_is_function_needed (node, node->symbol.decl))\n-\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n-      fprintf (cgraph_dump_file, \"\\n\");\n-    }\n-  cgraph_process_new_functions ();\n+      changed = false;\n+      process_function_and_variable_attributes (first_analyzed,\n+\t\t\t\t\t\tfirst_analyzed_var);\n \n-  /* Propagate reachability flag and lower representation of all reachable\n-     functions.  In the future, lowering will introduce new functions and\n-     new entry points on the way (by template instantiation and virtual\n-     method table generation for instance).  */\n-  while (cgraph_nodes_queue)\n-    {\n-      struct cgraph_edge *edge;\n-      tree decl = cgraph_nodes_queue->symbol.decl;\n-\n-      node = cgraph_nodes_queue;\n-      x_cgraph_nodes_queue = (symtab_node)cgraph_nodes_queue->next_needed;\n-      node->next_needed = NULL;\n-\n-      /* ??? It is possible to create extern inline function and later using\n-\t weak alias attribute to kill its body. See\n-\t gcc.c-torture/compile/20011119-1.c  */\n-      if (!DECL_STRUCT_FUNCTION (decl)\n-\t  && (!node->alias || !node->thunk.alias)\n-\t  && !node->thunk.thunk_p)\n+      /* First identify the trivially needed symbols.  */\n+      for (node = symtab_nodes;\n+\t   node != (symtab_node)first_analyzed\n+\t   && node != (symtab_node)first_analyzed_var; node = node->symbol.next)\n \t{\n-\t  cgraph_reset_node (node);\n-          node->local.redefined_extern_inline = true;\n-\t  continue;\n+\t  if ((symtab_function_p (node)\n+\t       && cgraph (node)->local.finalized\n+\t       && cgraph_decide_is_function_needed (cgraph (node), node->symbol.decl))\n+\t      || (symtab_variable_p (node)\n+\t\t  && varpool (node)->finalized\n+\t\t  && !DECL_EXTERNAL (node->symbol.decl)\n+\t\t  && decide_is_variable_needed (varpool (node), node->symbol.decl)))\n+\t    {\n+\t      enqueue_node (node);\n+\t      if (!changed && cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file, \"Trivially needed symbols:\");\n+\t      changed = true;\n+\t      if (cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file, \" %s\", symtab_node_asm_name (node));\n+\t    }\n+\t  if (node == (symtab_node)first_analyzed\n+\t      || node == (symtab_node)first_analyzed_var)\n+\t    break;\n \t}\n+      cgraph_process_new_functions ();\n+      first_analyzed_var = varpool_first_variable ();\n+      first_analyzed = cgraph_first_function ();\n \n-      if (!node->analyzed)\n-\tcgraph_analyze_function (node);\n-\n-      for (edge = node->callees; edge; edge = edge->next_callee)\n-\tif (!edge->callee->reachable)\n-\t  cgraph_mark_reachable_node (edge->callee);\n-      for (edge = node->callers; edge; edge = edge->next_caller)\n-\tif (!edge->caller->reachable && edge->caller->thunk.thunk_p)\n-\t  cgraph_mark_reachable_node (edge->caller);\n+      if (changed && dump_file)\n+\tfprintf (cgraph_dump_file, \"\\n\");\n \n-      if (node->symbol.same_comdat_group)\n+      /* Lower representation, build callgraph edges and references for all trivially\n+         needed symbols and all symbols referred by them.  */\n+      while (first != (symtab_node)(void *)1)\n \t{\n-\t  for (next = cgraph (node->symbol.same_comdat_group);\n-\t       next != node;\n-\t       next = cgraph (next->symbol.same_comdat_group))\n-\t    cgraph_mark_reachable_node (next);\n-\t}\n+\t  changed = true;\n+\t  node = first;\n+\t  first = (symtab_node)first->symbol.aux;\n+\t  if (symtab_function_p (node) && cgraph (node)->local.finalized)\n+\t    {\n+\t      struct cgraph_edge *edge;\n+\t      struct cgraph_node *cnode;\n+\t      tree decl;\n+\n+\t      cnode = cgraph (node);\n+\t      decl = cnode->symbol.decl;\n+\n+\t      /* ??? It is possible to create extern inline function and later using\n+\t\t weak alias attribute to kill its body. See\n+\t\t gcc.c-torture/compile/20011119-1.c  */\n+\t      if (!DECL_STRUCT_FUNCTION (decl)\n+\t\t  && (!cnode->alias || !cnode->thunk.alias)\n+\t\t  && !cnode->thunk.thunk_p)\n+\t\t{\n+\t\t  cgraph_reset_node (cnode);\n+\t\t  cnode->local.redefined_extern_inline = true;\n+\t\t  continue;\n+\t\t}\n \n-      /* If decl is a clone of an abstract function, mark that abstract\n-\t function so that we don't release its body. The DECL_INITIAL() of that\n-\t abstract function declaration will be later needed to output debug\n-\t info.  */\n-      if (DECL_ABSTRACT_ORIGIN (decl))\n-\t{\n-\t  struct cgraph_node *origin_node;\n-\t  origin_node = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));\n-\t  origin_node->abstract_and_needed = true;\n-\t}\n+\t      if (!cnode->analyzed)\n+\t\tcgraph_analyze_function (cnode);\n \n-      /* We finalize local static variables during constructing callgraph\n-         edges.  Process their attributes too.  */\n-      process_function_and_variable_attributes (first_processed,\n-\t\t\t\t\t\tfirst_analyzed_var);\n-      first_processed = cgraph_first_function ();\n-      first_analyzed_var = varpool_first_variable ();\n-      varpool_analyze_pending_decls ();\n-      cgraph_process_new_functions ();\n+\t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n+\t\t{\n+\t\t  cgraph_mark_reachable_node (edge->callee);\n+\t\t  if (edge->callee->local.finalized)\n+\t\t    enqueue_node ((symtab_node)edge->callee);\n+\t\t}\n+\n+\t      /* If decl is a clone of an abstract function, mark that abstract\n+\t\t function so that we don't release its body. The DECL_INITIAL() of that\n+\t\t abstract function declaration will be later needed to output debug\n+\t\t info.  */\n+\t      if (DECL_ABSTRACT_ORIGIN (decl))\n+\t\t{\n+\t\t  struct cgraph_node *origin_node;\n+\t\t  origin_node = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));\n+\t\t  origin_node->abstract_and_needed = true;\n+\t\t}\n+\n+\t    }\n+\t  else if (symtab_variable_p (node)\n+\t\t   && varpool (node)->finalized)\n+\t    {\n+\t      varpool_analyze_node (varpool (node));\n+\t    }\n+\n+\t  if (node->symbol.same_comdat_group)\n+\t    {\n+\t      symtab_node next;\n+\t      for (next = node->symbol.same_comdat_group;\n+\t\t   next != node;\n+\t\t   next = next->symbol.same_comdat_group)\n+\t\tenqueue_node (next);\n+\t    }\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+\t    if ((symtab_function_p (ref->referred) && cgraph (ref->referred)->local.finalized)\n+\t\t|| (symtab_variable_p (ref->referred) && varpool (ref->referred)->finalized))\n+\t      enqueue_node (ref->referred);\n+          cgraph_process_new_functions ();\n+\t}\n     }\n \n   /* Collect entry points to the unit.  */\n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Unit entry points:\");\n-      for (node = cgraph_first_function (); node != first_analyzed;\n-\t   node = cgraph_next_function (node))\n-\tif (cgraph_decide_is_function_needed (node, node->symbol.decl))\n-\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n       dump_symtab (cgraph_dump_file);\n     }\n \n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\nReclaiming functions:\");\n+    fprintf (cgraph_dump_file, \"\\nRemoving unused symbols:\");\n \n-  for (node = cgraph_first_function (); node != first_analyzed;\n-       node = next)\n+  for (node = symtab_nodes;\n+       node != (symtab_node)first_handled\n+       && node != (symtab_node)first_handled_var; node = next)\n     {\n-      tree decl = node->symbol.decl;\n-      next = cgraph_next_function (node);\n-\n-      if (node->local.finalized && !gimple_has_body_p (decl)\n-\t  && (!node->alias || !node->thunk.alias)\n-\t  && !node->thunk.thunk_p)\n-\tcgraph_reset_node (node);\n-\n-      if (!node->reachable\n-\t  && (gimple_has_body_p (decl) || node->thunk.thunk_p\n-\t      || (node->alias && node->thunk.alias)))\n+      next = node->symbol.next;\n+      if (!node->symbol.aux && !referred_to_p (node))\n \t{\n \t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n-\t  cgraph_remove_node (node);\n+\t    fprintf (cgraph_dump_file, \" %s\", symtab_node_name (node));\n+\t  symtab_remove_node (node);\n \t  continue;\n \t}\n-      else\n-\tnode->next_needed = NULL;\n-      gcc_assert (!node->local.finalized || node->thunk.thunk_p\n-\t\t  || node->alias\n-\t\t  || gimple_has_body_p (decl));\n-      gcc_assert (node->analyzed == node->local.finalized);\n+      if (symtab_function_p (node))\n+\t{\n+\t  tree decl = node->symbol.decl;\n+\t  struct cgraph_node *cnode = cgraph (node);\n+\n+\t  if (cnode->local.finalized && !gimple_has_body_p (decl)\n+\t      && (!cnode->alias || !cnode->thunk.alias)\n+\t      && !cnode->thunk.thunk_p)\n+\t    cgraph_reset_node (cnode);\n+\n+\t  gcc_assert (!cnode->local.finalized || cnode->thunk.thunk_p\n+\t\t      || cnode->alias\n+\t\t      || gimple_has_body_p (decl));\n+\t  gcc_assert (cnode->analyzed == cnode->local.finalized);\n+\t}\n+      node->symbol.aux = NULL;\n     }\n+  first_analyzed = cgraph_first_function ();\n+  first_analyzed_var = varpool_first_variable ();\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"\\n\\nReclaimed \");\n       dump_symtab (cgraph_dump_file);\n     }\n   bitmap_obstack_release (NULL);\n-  first_analyzed = cgraph_first_function ();\n   ggc_collect ();\n }\n \n@@ -2041,8 +2136,6 @@ cgraph_output_in_order (void)\n   max = symtab_order;\n   nodes = XCNEWVEC (struct cgraph_order_sort, max);\n \n-  varpool_analyze_pending_decls ();\n-\n   FOR_EACH_DEFINED_FUNCTION (pf)\n     {\n       if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n@@ -2071,14 +2164,6 @@ cgraph_output_in_order (void)\n     }\n \n   /* In toplevel reorder mode we output all statics; mark them as needed.  */\n-  for (i = 0; i < max; ++i)\n-    {\n-      if (nodes[i].kind == ORDER_VAR)\n-        {\n-\t  varpool_mark_needed_node (nodes[i].u.v);\n-\t}\n-    }\n-  varpool_empty_needed_queue ();\n \n   for (i = 0; i < max; ++i)\n     if (nodes[i].kind == ORDER_VAR)\n@@ -2614,10 +2699,6 @@ cgraph_optimize (void)\n   verify_symtab ();\n #endif\n \n-  /* Frontend may output common variables after the unit has been finalized.\n-     It is safe to deal with them here as they are always zero initialized.  */\n-  varpool_analyze_pending_decls ();\n-\n   timevar_push (TV_CGRAPHOPT);\n   if (pre_ipa_mem_report)\n     {"}, {"sha": "69c5916cfaf46fb1cd179464b843888d7680f73f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -1,3 +1,8 @@\n+2012-04-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (maybe_make_one_only): Mark keyed COMDATs as USED so they\n+\tgets finalized.\n+\n 2012-04-22  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c/44774"}, {"sha": "34c969c31fcce83ec5afb9bb66600813a82ee85a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -1677,6 +1677,7 @@ maybe_make_one_only (tree decl)\n \t  DECL_COMDAT (decl) = 1;\n \t  /* Mark it needed so we don't forget to emit it.  */\n \t  mark_decl_referenced (decl);\n+\t  TREE_USED (decl) = 1;\n \t}\n     }\n }"}, {"sha": "1240ddb563789280b22c0c99a23909628d0fa08d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -14572,7 +14572,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n   else if (TREE_CODE (*tp) == VAR_DECL)\n     {\n       struct varpool_node *node = varpool_get_node (*tp);\n-      if (!node || !node->needed)\n+      if (!node || !node->analyzed)\n \treturn *tp;\n     }\n   else if (TREE_CODE (*tp) == FUNCTION_DECL\n@@ -17057,7 +17057,7 @@ premark_types_used_by_global_vars_helper (void **slot,\n       /* Ask cgraph if the global variable really is to be emitted.\n          If yes, then we'll keep the DIE of ENTRY->TYPE.  */\n       struct varpool_node *node = varpool_get_node (entry->var_decl);\n-      if (node && node->needed)\n+      if (node && node->analyzed)\n \t{\n \t  die->die_perennial_p = 1;\n \t  /* Keep the parent DIEs as well.  */"}, {"sha": "254dd8c32aefb07613e24424614eefdb2bb2d223", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -2814,8 +2814,6 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n     value = const0_rtx;\n   else\n     {\n-      struct varpool_node *node;\n-\n       /* FIXME lto.  pass_ipa_free_lang_data changes all types to\n \t runtime types so TYPE should already be a runtime type\n \t reference.  When pass_ipa_free_lang data is made a default\n@@ -2834,12 +2832,7 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n \t{\n \t  type = TREE_OPERAND (type, 0);\n \t  if (TREE_CODE (type) == VAR_DECL)\n-\t    {\n-\t      node = varpool_node (type);\n-\t      if (node)\n-\t\tvarpool_mark_needed_node (node);\n-\t      is_public = TREE_PUBLIC (type);\n-\t    }\n+\t    is_public = TREE_PUBLIC (type);\n \t}\n       else\n \tgcc_assert (TREE_CODE (type) == INTEGER_CST);"}, {"sha": "34b58e857d7d1317e7511c9e79ad2503ecd80d92", "filename": "gcc/ipa.c", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -107,7 +107,7 @@ process_references (struct ipa_ref_list *list,\n \t  struct varpool_node *node = ipa_ref_varpool_node (ref);\n \t  if (!node->needed)\n \t    {\n-\t      varpool_mark_needed_node (node);\n+\t      node->needed = true;\n \t      enqueue_varpool_node (node, first_varpool);\n \t    }\n \t}\n@@ -187,7 +187,6 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   FOR_EACH_VARIABLE (vnode)\n     gcc_assert (!vnode->symbol.aux);\n #endif\n-  varpool_reset_queue ();\n   /* Mark functions whose bodies are obviously needed.\n      This is mostly when they can be referenced externally.  Inline clones\n      are special since their declarations are shared with master clone and thus\n@@ -213,13 +212,10 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   /* Mark variables that are obviously needed.  */\n   FOR_EACH_VARIABLE (vnode)\n     {\n-      vnode->next_needed = NULL;\n-      vnode->prev_needed = NULL;\n       if ((vnode->analyzed || vnode->symbol.force_output)\n \t  && !varpool_can_remove_if_no_refs (vnode))\n \t{\n-\t  vnode->needed = false;\n-\t  varpool_mark_needed_node (vnode);\n+\t  vnode->needed = true;\n \t  enqueue_varpool_node (vnode, &first_varpool);\n \t}\n       else\n@@ -315,7 +311,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t   next = varpool (next->symbol.same_comdat_group))\n \t\tif (!next->needed)\n \t\t  {\n-\t\t    varpool_mark_needed_node (next);\n+\t\t    next->needed = true;\n \t\t    enqueue_varpool_node (next, &first_varpool);\n \t\t  }\n \t    }\n@@ -794,8 +790,6 @@ function_and_variable_visibility (bool whole_program)\n \t       && !DECL_EXTERNAL (vnode->symbol.decl))\n         {\n \t  vnode->symbol.force_output = 1;\n-\t  varpool_mark_needed_node (vnode);\n-\t  gcc_assert (vnode->needed);\n \t  pointer_set_insert (aliased_vnodes, vnode);\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  varpool node %s\",\n@@ -933,10 +927,9 @@ function_and_variable_visibility (bool whole_program)\n     {\n       if (!vnode->finalized)\n         continue;\n-      if (vnode->needed\n-\t  && varpool_externally_visible_p\n-\t      (vnode, \n-\t       pointer_set_contains (aliased_vnodes, vnode)))\n+      if (varpool_externally_visible_p\n+\t    (vnode, \n+\t     pointer_set_contains (aliased_vnodes, vnode)))\n \tvnode->symbol.externally_visible = true;\n       else\n         vnode->symbol.externally_visible = false;\n@@ -1018,25 +1011,13 @@ static unsigned int\n whole_program_function_and_variable_visibility (void)\n {\n   struct cgraph_node *node;\n-  struct varpool_node *vnode;\n \n   function_and_variable_visibility (flag_whole_program);\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if ((node->symbol.externally_visible && !DECL_COMDAT (node->symbol.decl))\n         && node->local.finalized)\n       cgraph_mark_reachable_node (node);\n-  FOR_EACH_DEFINED_VARIABLE (vnode)\n-    if (vnode->symbol.externally_visible && !DECL_COMDAT (vnode->symbol.decl))\n-      varpool_mark_needed_node (vnode);\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nNeeded variables:\");\n-      FOR_EACH_DEFINED_VARIABLE (vnode)\n-\tif (vnode->needed)\n-\t  fprintf (dump_file, \" %s\", varpool_node_name (vnode));\n-      fprintf (dump_file, \"\\n\\n\");\n-    }\n   if (optimize)\n     ipa_discover_readonly_nonaddressable_vars ();\n   return 0;"}, {"sha": "532a6bf26ee8b1bfed20c9bc138955d11a232627", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -1,3 +1,7 @@\n+2012-04-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* class.c (build_utf8_ref): Do not mark varpool node as needed.\n+\n 2012-04-20  Jan Hubicka  <jh@suse.cz>\n \n \t* class.c (make_local_function_alias): Do not mark symbol referenced."}, {"sha": "33a399980345e4e23e5347aa6909f6f04f90bdcc", "filename": "gcc/java/class.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -1001,7 +1001,6 @@ build_utf8_ref (tree name)\n   DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (ctype);\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, global_bindings_p (), 0);\n-  varpool_mark_needed_node (varpool_node (decl));\n   ref = build1 (ADDR_EXPR, utf8const_ptr_type, decl);\n   IDENTIFIER_UTF8_REF (name) = ref;\n   return ref;"}, {"sha": "2563489904784de9274b32ba806d896f736c56f8", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -571,7 +571,6 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp_pack_value (&bp, node->alias, 1);\n   bp_pack_value (&bp, node->alias_of != NULL, 1);\n   gcc_assert (node->finalized || !node->analyzed);\n-  gcc_assert (node->needed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n@@ -1079,16 +1078,14 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->finalized = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n   non_null_aliasof = bp_unpack_value (&bp, 1);\n-  node->analyzed = node->finalized; \n   node->symbol.used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->symbol.in_other_partition = bp_unpack_value (&bp, 1);\n+  node->analyzed = (node->finalized && (!node->alias || !node->symbol.in_other_partition)); \n   if (node->symbol.in_other_partition)\n     {\n       DECL_EXTERNAL (node->symbol.decl) = 1;\n       TREE_STATIC (node->symbol.decl) = 0;\n     }\n-  if (node->finalized)\n-    varpool_mark_needed_node (node);\n   if (non_null_aliasof)\n     {\n       decl_index = streamer_read_uhwi (ib);\n@@ -1457,6 +1454,8 @@ input_cgraph (void)\n   unsigned int j = 0;\n   struct cgraph_node *node;\n \n+  cgraph_state = CGRAPH_STATE_IPA_SSA;\n+\n   while ((file_data = file_data_vec[j++]))\n     {\n       const char *data;"}, {"sha": "f1424447d0fa9e56657677e0fba2363a2693fa12", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -262,12 +262,6 @@ static void\n lto_varpool_replace_node (struct varpool_node *vnode,\n \t\t\t  struct varpool_node *prevailing_node)\n {\n-  /* Merge node flags.  */\n-  if (vnode->needed)\n-    {\n-      gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n-      varpool_mark_needed_node (prevailing_node);\n-    }\n   gcc_assert (!vnode->finalized || prevailing_node->finalized);\n   gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n "}, {"sha": "e2aa595b502f0d1d460453d852894116de8af084", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -283,7 +283,7 @@ partition_cgraph_node_p (struct cgraph_node *node)\n static bool\n partition_varpool_node_p (struct varpool_node *vnode)\n {\n-  if (vnode->alias || !vnode->needed)\n+  if (vnode->alias || !vnode->analyzed)\n     return false;\n   /* Constant pool and comdat are always only in partitions they are needed.  */\n   if (DECL_IN_CONSTANT_POOL (vnode->symbol.decl)"}, {"sha": "4724f80b0e8181cd1e3d55c77684a1b337f93631", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -2342,8 +2342,8 @@ ipa_write_summaries (void)\n     }\n   vset = varpool_node_set_new ();\n \n-  FOR_EACH_VARIABLE (vnode)\n-    if (vnode->needed && (!vnode->alias || vnode->alias_of))\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n+    if ((!vnode->alias || vnode->alias_of))\n       varpool_node_set_add (vset, vnode);\n \n   ipa_write_summaries_1 (set, vset);"}, {"sha": "975fdef89b1614b618d1c54a9d1db5cc3f178281", "filename": "gcc/symtab.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -429,6 +429,11 @@ dump_symtab_base (FILE *f, symtab_node node)\n \n   if (node->symbol.address_taken)\n     fprintf (f, \"  Address is taken.\\n\");\n+  if (node->symbol.aux)\n+    {\n+      fprintf (f, \"  Aux:\");\n+      dump_addr (f, \" @\", (void *)node->symbol.aux);\n+    }\n \n   fprintf (f, \"  References: \");\n   ipa_dump_references (f, &node->symbol.ref_list);"}, {"sha": "574af3bc1608e1fa799e77246076d8247dc552bd", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -413,7 +413,7 @@ wrapup_global_declaration_2 (tree decl)\n \t       && (TREE_USED (decl)\n \t\t   || TREE_USED (DECL_ASSEMBLER_NAME (decl))))\n \t/* needed */;\n-      else if (node && node->needed)\n+      else if (node && node->analyzed)\n \t/* needed */;\n       else if (DECL_COMDAT (decl))\n \tneeded = false;\n@@ -581,6 +581,7 @@ compile_file (void)\n      basically finished.  */\n   if (in_lto_p || !flag_lto || flag_fat_lto_objects)\n     {\n+      varpool_remove_unreferenced_decls ();\n       varpool_assemble_pending_decls ();\n       finish_aliases_2 ();\n "}, {"sha": "55ea0fa8a22587dd8e8c2397a7a5878924ac5622", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -87,7 +87,6 @@ init_ic_make_global_vars (void)\n       decl_default_tls_model (ic_void_ptr_var);\n \n   varpool_finalize_decl (ic_void_ptr_var);\n-  varpool_mark_needed_node (varpool_node (ic_void_ptr_var));\n \n   gcov_type_ptr = build_pointer_type (get_gcov_type ());\n   ic_gcov_type_ptr_var\n@@ -103,7 +102,6 @@ init_ic_make_global_vars (void)\n       decl_default_tls_model (ic_gcov_type_ptr_var);\n \n   varpool_finalize_decl (ic_gcov_type_ptr_var);\n-  varpool_mark_needed_node (varpool_node (ic_gcov_type_ptr_var));\n }\n \n void"}, {"sha": "95c8bd805e12f04df6b56ecf1b5113c5da74e87b", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -625,7 +625,6 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n       TREE_CONSTANT (decl) = 1;\n       TREE_READONLY (decl) = 1;\n       add_referenced_var (decl);\n-      varpool_mark_needed_node (varpool_node (decl));\n       varpool_finalize_decl (decl);\n \n       fetch = build4 (ARRAY_REF, value_type, decl, tidx, NULL_TREE,"}, {"sha": "c3d289eb91a057324ea97af9612c3a5f6756e0e1", "filename": "gcc/varasm.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -2254,7 +2254,6 @@ mark_decl_referenced (tree decl)\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       struct varpool_node *node = varpool_node (decl);\n-      varpool_mark_needed_node (node);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n       node->symbol.force_output = true;"}, {"sha": "7c8d1fd8c9fb7ce35b2bb803bedc7db74c666417", "filename": "gcc/varpool.c", "status": "modified", "additions": 128, "deletions": 265, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660584689a4397f18cda03b458703bbbf909dd12/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=660584689a4397f18cda03b458703bbbf909dd12", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph handling code.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n@@ -48,32 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n     All variables supposed to be output into final file needs to be\n     explicitly marked by frontend via VARPOOL_FINALIZE_DECL function.  */\n \n-/* Queue of cgraph nodes scheduled to be lowered and output.\n-   The queue is maintained via mark_needed_node, linked via node->next_needed\n-   pointer.\n-\n-   LAST_NEEDED_NODE points to the end of queue, so it can be\n-   maintained in forward order.  GTY is needed to make it friendly to\n-   PCH.\n-\n-   During compilation we construct the queue of needed variables\n-   twice: first time it is during cgraph construction, second time it is at the\n-   end of compilation in VARPOOL_REMOVE_UNREFERENCED_DECLS so we can avoid\n-   optimized out variables being output.\n-\n-   Each variable is thus first analyzed and then later possibly output.\n-   FIRST_UNANALYZED_NODE points to first node in queue that was not analyzed\n-   yet and is moved via VARPOOL_ANALYZE_PENDING_DECLS.  */\n-\n-symtab_node x_varpool_nodes_queue;\n-static GTY(()) symtab_node x_varpool_last_needed_node;\n-#define varpool_last_needed_node ((struct varpool_node *)x_varpool_last_needed_node)\n-static GTY(()) symtab_node x_varpool_first_unanalyzed_node;\n-#define varpool_first_unanalyzed_node ((struct varpool_node *)x_varpool_first_unanalyzed_node)\n-\n-/* Lists all assembled variables to be sent to debugger output later on.  */\n-static GTY(()) struct varpool_node *varpool_assembled_nodes_queue;\n-\n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n struct varpool_node *\n varpool_node (tree decl)\n@@ -95,24 +69,7 @@ varpool_node (tree decl)\n void\n varpool_remove_node (struct varpool_node *node)\n {\n-  gcc_assert (!varpool_assembled_nodes_queue);\n   symtab_unregister_node ((symtab_node)node);\n-  if (varpool_first_unanalyzed_node == node)\n-    x_varpool_first_unanalyzed_node = (symtab_node)node->next_needed;\n-  if (node->next_needed)\n-    node->next_needed->prev_needed = node->prev_needed;\n-  else if (node->prev_needed)\n-    {\n-      gcc_assert (varpool_last_needed_node);\n-      x_varpool_last_needed_node = (symtab_node)node->prev_needed;\n-    }\n-  if (node->prev_needed)\n-    node->prev_needed->next_needed = node->next_needed;\n-  else if (node->next_needed)\n-    {\n-      gcc_assert (varpool_nodes_queue == node);\n-      x_varpool_nodes_queue = (symtab_node)node->next_needed;\n-    }\n   ggc_free (node);\n }\n \n@@ -128,8 +85,6 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n   fprintf (f, \"  Varpool flags:\");\n   if (DECL_INITIAL (node->symbol.decl))\n     fprintf (f, \" initialized\");\n-  if (node->needed)\n-    fprintf (f, \" needed\");\n   if (node->analyzed)\n     fprintf (f, \" analyzed\");\n   if (node->finalized)\n@@ -168,45 +123,6 @@ varpool_node_for_asm (tree asmname)\n   return NULL;\n }\n \n-/* Helper function for finalization code - add node into lists so it will\n-   be analyzed and compiled.  */\n-static void\n-varpool_enqueue_needed_node (struct varpool_node *node)\n-{\n-  if (varpool_last_needed_node)\n-    {\n-      varpool_last_needed_node->next_needed = node;\n-      node->prev_needed = varpool_last_needed_node;\n-    }\n-  x_varpool_last_needed_node = (symtab_node)node;\n-  node->next_needed = NULL;\n-  if (!varpool_nodes_queue)\n-    x_varpool_nodes_queue = (symtab_node)node;\n-  if (!varpool_first_unanalyzed_node)\n-    x_varpool_first_unanalyzed_node = (symtab_node)node;\n-  notice_global_symbol (node->symbol.decl);\n-}\n-\n-/* Notify finalize_compilation_unit that given node is reachable\n-   or needed.  */\n-void\n-varpool_mark_needed_node (struct varpool_node *node)\n-{\n-  if (!node->needed && node->finalized\n-      && !TREE_ASM_WRITTEN (node->symbol.decl))\n-    varpool_enqueue_needed_node (node);\n-  node->needed = 1;\n-}\n-\n-/* Reset the queue of needed nodes.  */\n-void\n-varpool_reset_queue (void)\n-{\n-  x_varpool_last_needed_node = NULL;\n-  x_varpool_nodes_queue = NULL;\n-  x_varpool_first_unanalyzed_node = NULL;\n-}\n-\n /* Determine if variable DECL is needed.  That is, visible to something\n    either outside this translation unit, something magic in the system\n    configury */\n@@ -270,42 +186,6 @@ const_value_known_p (tree decl)\n   return true;\n }\n \n-/* Mark DECL as finalized.  By finalizing the declaration, frontend instruct the\n-   middle end to output the variable to asm file, if needed or externally\n-   visible.  */\n-void\n-varpool_finalize_decl (tree decl)\n-{\n-  struct varpool_node *node = varpool_node (decl);\n-\n-  gcc_assert (TREE_STATIC (decl));\n-\n-  /* The first declaration of a variable that comes through this function\n-     decides whether it is global (in C, has external linkage)\n-     or local (in C, has internal linkage).  So do nothing more\n-     if this function has already run.  */\n-  if (node->finalized)\n-    {\n-      if (cgraph_global_info_ready)\n-\tvarpool_assemble_pending_decls ();\n-      return;\n-    }\n-  if (node->needed)\n-    varpool_enqueue_needed_node (node);\n-  node->finalized = true;\n-  if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n-      /* Traditionally we do not eliminate static variables when not\n-\t optimizing and when not doing toplevel reoder.  */\n-      || (!flag_toplevel_reorder && !DECL_COMDAT (node->symbol.decl)\n-\t  && !DECL_ARTIFICIAL (node->symbol.decl)))\n-    node->symbol.force_output = true;\n-\n-  if (decide_is_variable_needed (node, decl))\n-    varpool_mark_needed_node (node);\n-  if (cgraph_global_info_ready)\n-    varpool_assemble_pending_decls ();\n-}\n-\n /* Add the variable DECL to the varpool.\n    Unlike varpool_finalize_decl function is intended to be used\n    by middle end and allows insertion of new variable at arbitrary point\n@@ -338,93 +218,69 @@ cgraph_variable_initializer_availability (struct varpool_node *node)\n   return AVAIL_AVAILABLE;\n }\n \n-/* Walk the decls we marked as necessary and see if they reference new\n-   variables or functions and add them into the worklists.  */\n-bool\n-varpool_analyze_pending_decls (void)\n+void\n+varpool_analyze_node (struct varpool_node *node)\n {\n-  bool changed = false;\n+  tree decl = node->symbol.decl;\n \n-  timevar_push (TV_VARPOOL);\n-  while (varpool_first_unanalyzed_node)\n+  /* When reading back varpool at LTO time, we re-construct the queue in order\n+     to have \"needed\" list right by inserting all needed nodes into varpool.\n+     We however don't want to re-analyze already analyzed nodes.  */\n+  if (!node->analyzed)\n     {\n-      struct varpool_node *node = varpool_first_unanalyzed_node, *next;\n-      tree decl = node->symbol.decl;\n-      bool analyzed = node->analyzed;\n-\n-      varpool_first_unanalyzed_node->analyzed = true;\n-\n-      x_varpool_first_unanalyzed_node = (symtab_node)varpool_first_unanalyzed_node->next_needed;\n-\n-      /* When reading back varpool at LTO time, we re-construct the queue in order\n-         to have \"needed\" list right by inserting all needed nodes into varpool.\n-\t We however don't want to re-analyze already analyzed nodes.  */\n-      if (!analyzed)\n-\t{\n-\t  gcc_assert (!in_lto_p || cgraph_function_flags_ready);\n-          /* Compute the alignment early so function body expanders are\n-\t     already informed about increased alignment.  */\n-          align_variable (decl, 0);\n-\t}\n-      if (node->alias && node->alias_of)\n+      gcc_assert (!in_lto_p || cgraph_function_flags_ready);\n+      /* Compute the alignment early so function body expanders are\n+\t already informed about increased alignment.  */\n+      align_variable (decl, 0);\n+    }\n+  if (node->alias && node->alias_of)\n+    {\n+      struct varpool_node *tgt = varpool_node (node->alias_of);\n+      struct varpool_node *n;\n+\n+      for (n = tgt; n && n->alias;\n+\t   n = n->analyzed ? varpool_alias_aliased_node (n) : NULL)\n+\tif (n == node)\n+\t  {\n+\t    error (\"variable %q+D part of alias cycle\", node->symbol.decl);\n+\t    node->alias = false;\n+\t    continue;\n+\t  }\n+      if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n+\tipa_record_reference ((symtab_node)node, (symtab_node)tgt, IPA_REF_ALIAS, NULL);\n+      /* C++ FE sometimes change linkage flags after producing same body aliases.  */\n+      if (node->extra_name_alias)\n \t{\n-\t  struct varpool_node *tgt = varpool_node (node->alias_of);\n-          struct varpool_node *n;\n-\n-\t  for (n = tgt; n && n->alias;\n-\t       n = n->analyzed ? varpool_alias_aliased_node (n) : NULL)\n-\t    if (n == node)\n-\t      {\n-\t\terror (\"variable %q+D part of alias cycle\", node->symbol.decl);\n-\t\tnode->alias = false;\n-\t\tcontinue;\n-\t      }\n-\t  if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n-\t    ipa_record_reference ((symtab_node)node, (symtab_node)tgt, IPA_REF_ALIAS, NULL);\n-\t  /* C++ FE sometimes change linkage flags after producing same body aliases.  */\n-\t  if (node->extra_name_alias)\n+\t  DECL_WEAK (node->symbol.decl) = DECL_WEAK (node->alias_of);\n+\t  TREE_PUBLIC (node->symbol.decl) = TREE_PUBLIC (node->alias_of);\n+\t  DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (node->alias_of);\n+\t  DECL_VISIBILITY (node->symbol.decl) = DECL_VISIBILITY (node->alias_of);\n+\t  if (TREE_PUBLIC (node->symbol.decl))\n \t    {\n-\t      DECL_WEAK (node->symbol.decl) = DECL_WEAK (node->alias_of);\n-\t      TREE_PUBLIC (node->symbol.decl) = TREE_PUBLIC (node->alias_of);\n-\t      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (node->alias_of);\n-\t      DECL_VISIBILITY (node->symbol.decl) = DECL_VISIBILITY (node->alias_of);\n-\t      if (TREE_PUBLIC (node->symbol.decl))\n+\t      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (node->alias_of);\n+\t      DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (node->alias_of);\n+\t      if (DECL_ONE_ONLY (node->alias_of)\n+\t\t  && !node->symbol.same_comdat_group)\n \t\t{\n-\t\t  DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (node->alias_of);\n-\t\t  DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (node->alias_of);\n-\t\t  if (DECL_ONE_ONLY (node->alias_of)\n-\t\t      && !node->symbol.same_comdat_group)\n+\t\t  node->symbol.same_comdat_group = (symtab_node)tgt;\n+\t\t  if (!tgt->symbol.same_comdat_group)\n+\t\t    tgt->symbol.same_comdat_group = (symtab_node)node;\n+\t\t  else\n \t\t    {\n-\t\t      node->symbol.same_comdat_group = (symtab_node)tgt;\n-\t\t      if (!tgt->symbol.same_comdat_group)\n-\t\t\ttgt->symbol.same_comdat_group = (symtab_node)node;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  symtab_node n;\n-\t\t\t  for (n = tgt->symbol.same_comdat_group;\n-\t\t\t       n->symbol.same_comdat_group != (symtab_node)tgt;\n-\t\t\t       n = n->symbol.same_comdat_group)\n-\t\t\t    ;\n-\t\t\t  n->symbol.same_comdat_group = (symtab_node)node;\n-\t\t\t}\n+\t\t      symtab_node n;\n+\t\t      for (n = tgt->symbol.same_comdat_group;\n+\t\t\t   n->symbol.same_comdat_group != (symtab_node)tgt;\n+\t\t\t   n = n->symbol.same_comdat_group)\n+\t\t\t;\n+\t\t      n->symbol.same_comdat_group = (symtab_node)node;\n \t\t    }\n \t\t}\n \t    }\n-   \t  varpool_mark_needed_node (tgt);\n-\t}\n-      else if (DECL_INITIAL (decl))\n-\trecord_references_in_initializer (decl, analyzed);\n-      if (node->symbol.same_comdat_group)\n-\t{\n-\t  for (next = varpool (node->symbol.same_comdat_group);\n-\t       next != node;\n-\t       next = varpool (next->symbol.same_comdat_group))\n-\t    varpool_mark_needed_node (next);\n \t}\n-      changed = true;\n     }\n-  timevar_pop (TV_VARPOOL);\n-  return changed;\n+  else if (DECL_INITIAL (decl))\n+    record_references_in_initializer (decl, node->analyzed);\n+  node->analyzed = true;\n }\n \n /* Assemble thunks and aliases asociated to NODE.  */\n@@ -459,11 +315,6 @@ varpool_assemble_decl (struct varpool_node *node)\n       assemble_variable (decl, 0, 1, 0);\n       if (TREE_ASM_WRITTEN (decl))\n \t{\n-\t  node->next_needed = varpool_assembled_nodes_queue;\n-\t  node->prev_needed = NULL;\n-\t  if (varpool_assembled_nodes_queue)\n-\t    varpool_assembled_nodes_queue->prev_needed = node;\n-\t  varpool_assembled_nodes_queue = node;\n \t  node->finalized = 1;\n \t  assemble_aliases (node);\n \t  return true;\n@@ -473,40 +324,85 @@ varpool_assemble_decl (struct varpool_node *node)\n   return false;\n }\n \n+/* Add NODE to queue starting at FIRST. \n+   The queue is linked via AUX pointers and terminated by pointer to 1.  */\n+\n+static void\n+enqueue_node (struct varpool_node *node, struct varpool_node **first)\n+{\n+  if (node->symbol.aux)\n+    return;\n+  gcc_checking_assert (*first);\n+  node->symbol.aux = *first;\n+  *first = node;\n+}\n+\n /* Optimization of function bodies might've rendered some variables as\n-   unnecessary so we want to avoid these from being compiled.\n+   unnecessary so we want to avoid these from being compiled.  Re-do\n+   reachability starting from variables that are either externally visible\n+   or was referred from the asm output routines.  */\n \n-   This is done by pruning the queue and keeping only the variables that\n-   really appear needed (ie they are either externally visible or referenced\n-   by compiled function). Re-doing the reachability analysis on variables\n-   brings back the remaining variables referenced by these.  */\n void\n varpool_remove_unreferenced_decls (void)\n {\n-  struct varpool_node *next, *node = varpool_nodes_queue;\n-\n-  varpool_reset_queue ();\n+  struct varpool_node *next, *node;\n+  struct varpool_node *first = (struct varpool_node *)(void *)1;\n+  int i;\n+  struct ipa_ref *ref;\n \n   if (seen_error ())\n     return;\n \n-  while (node)\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Trivially needed variables:\");\n+  finish_aliases_1 ();\n+  FOR_EACH_DEFINED_VARIABLE (node)\n     {\n-      next = node->next_needed;\n-      node->needed = 0;\n-\n       if (node->analyzed\n \t  && (!varpool_can_remove_if_no_refs (node)\n \t      /* We just expanded all function bodies.  See if any of\n \t\t them needed the variable.  */\n \t      || DECL_RTL_SET_P (node->symbol.decl)))\n-\tvarpool_mark_needed_node (node);\n+\t{\n+\t  enqueue_node (node, &first);\n+          if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \" %s\", varpool_node_asm_name (node));\n+\t}\n+    }\n+  while (first != (struct varpool_node *)(void *)1)\n+    {\n+      node = first;\n+      first = (struct varpool_node *)first->symbol.aux;\n \n-      node = next;\n+      if (node->symbol.same_comdat_group)\n+\t{\n+\t  symtab_node next;\n+\t  for (next = node->symbol.same_comdat_group;\n+\t       next != (symtab_node)node;\n+\t       next = next->symbol.same_comdat_group)\n+\t    if (symtab_variable_p (next)\n+\t\t&& varpool (next)->analyzed)\n+\t      enqueue_node (varpool (next), &first);\n+\t}\n+      for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+\tif (symtab_variable_p (ref->referred)\n+\t    && varpool (ref->referred)->analyzed)\n+\t  enqueue_node (varpool (ref->referred), &first);\n     }\n-  /* Make sure we mark alias targets as used targets.  */\n-  finish_aliases_1 ();\n-  varpool_analyze_pending_decls ();\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\nRemoving variables:\");\n+  for (node = varpool_first_defined_variable (); node; node = next)\n+    {\n+      next = varpool_next_defined_variable (node);\n+      if (!node->symbol.aux)\n+\t{\n+          if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \" %s\", varpool_node_asm_name (node));\n+\t  varpool_remove_node (node);\n+\t}\n+    }\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\n\");\n }\n \n /* For variables in named sections make sure get_variable_section\n@@ -537,55 +433,17 @@ varpool_assemble_pending_decls (void)\n     return false;\n \n   timevar_push (TV_VAROUT);\n-  /* EH might mark decls as needed during expansion.  This should be safe since\n-     we don't create references to new function, but it should not be used\n-     elsewhere.  */\n-  varpool_analyze_pending_decls ();\n \n   FOR_EACH_DEFINED_VARIABLE (node)\n     varpool_finalize_named_section_flags (node);\n \n-  while (varpool_nodes_queue)\n-    {\n-      struct varpool_node *node = varpool_nodes_queue;\n-\n-      x_varpool_nodes_queue = (symtab_node)(varpool_nodes_queue->next_needed);\n-      if (varpool_assemble_decl (node))\n-\tchanged = true;\n-      else\n-\t{\n-\t  node->prev_needed = NULL;\n-          node->next_needed = NULL;\n-\t}\n-    }\n-  /* varpool_nodes_queue is now empty, clear the pointer to the last element\n-     in the queue.  */\n-  x_varpool_last_needed_node = NULL;\n+  FOR_EACH_DEFINED_VARIABLE (node)\n+    if (varpool_assemble_decl (node))\n+      changed = true;\n   timevar_pop (TV_VAROUT);\n   return changed;\n }\n \n-/* Remove all elements from the queue so we can re-use it for debug output.  */\n-void\n-varpool_empty_needed_queue (void)\n-{\n-  /* EH might mark decls as needed during expansion.  This should be safe since\n-     we don't create references to new function, but it should not be used\n-     elsewhere.  */\n-  varpool_analyze_pending_decls ();\n-\n-  while (varpool_nodes_queue)\n-    {\n-      struct varpool_node *node = varpool_nodes_queue;\n-      x_varpool_nodes_queue = (symtab_node)varpool_nodes_queue->next_needed;\n-      node->next_needed = NULL;\n-      node->prev_needed = NULL;\n-    }\n-  /* varpool_nodes_queue is now empty, clear the pointer to the last element\n-     in the queue.  */\n-  x_varpool_last_needed_node = NULL;\n-}\n-\n /* Create a new global variable of type TYPE.  */\n tree\n add_new_static_var (tree type)\n@@ -603,7 +461,6 @@ add_new_static_var (tree type)\n   lang_hooks.dup_lang_specific_decl (new_decl);\n   create_var_ann (new_decl);\n   new_node = varpool_node (new_decl);\n-  varpool_mark_needed_node (new_node);\n   add_referenced_var (new_decl);\n   varpool_finalize_decl (new_decl);\n \n@@ -624,10 +481,17 @@ varpool_create_variable_alias (tree alias, tree decl)\n   alias_node->alias = 1;\n   alias_node->finalized = 1;\n   alias_node->alias_of = decl;\n-  if ((!DECL_EXTERNAL (alias)\n-       && decide_is_variable_needed (alias_node, alias))\n-      || alias_node->needed)\n-    varpool_mark_needed_node (alias_node);\n+\n+  /* Extra name alias mechanizm creates aliases really late\n+     via DECL_ASSEMBLER_NAME mechanizm.\n+     This is unfortunate because they are not going through the\n+     standard channels.  Ensure they get output.  */\n+  if (cgraph_state >= CGRAPH_STATE_IPA)\n+    {\n+      varpool_analyze_node (alias_node);\n+      if (TREE_PUBLIC (alias))\n+\talias_node->symbol.externally_visible = true;\n+    }\n   return alias_node;\n }\n \n@@ -688,4 +552,3 @@ varpool_for_node_and_aliases (struct varpool_node *node,\n       }\n   return false;\n }\n-#include \"gt-varpool.h\""}]}