{"sha": "006df05d5cc462545336d5a439afbf10732acd16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA2ZGYwNWQ1Y2M0NjI1NDUzMzZkNWE0MzlhZmJmMTA3MzJhY2QxNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-01-14T21:54:16Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-01-14T21:54:16Z"}, "message": "Revert 2016-01-13 change.\n\nFrom-SVN: r232392", "tree": {"sha": "6c5ad22d953bc4051bc345514a82be88f1a50de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c5ad22d953bc4051bc345514a82be88f1a50de5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/006df05d5cc462545336d5a439afbf10732acd16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006df05d5cc462545336d5a439afbf10732acd16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/006df05d5cc462545336d5a439afbf10732acd16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006df05d5cc462545336d5a439afbf10732acd16/comments", "author": null, "committer": null, "parents": [{"sha": "cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001"}], "stats": {"total": 1584, "additions": 64, "deletions": 1520}, "files": [{"sha": "f5ba8f02fc867a644634bcb84e4feba31b303499", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -1,3 +1,11 @@\n+2016-01-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-builtin.def: Revert 2016-01-13 change.\n+\t* gcc/config/rs6000/rs6000.c: Likewise.\n+\t* gcc/config/rs6000/rs6000.h: Likewise.\n+\t* gcc/config/rs6000/rs6000.md: Likewise.\n+\t* gcc/doc/extend.texi: Likewsie.\n+\n 2016-01-14  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-dom.c (ssa_name_has_boolean_range): Fix comment"}, {"sha": "709992b37728967715c07725f598ffaf9451ee56", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -647,15 +647,6 @@\n \t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n-/* __float128 floating point builtins.  */\n-#define BU_FLOAT128_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n-  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n-\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n-\t\t    RS6000_BTM_FLOAT128,\t\t/* MASK */\t\\\n-\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n-\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n-\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n-\n #endif\n \n /* Insure 0 is not a legitimate index.  */\n@@ -1651,9 +1642,6 @@ BU_DFP_MISC_2 (UNPACK_TD,\t\"unpack_dec128\",\tCONST,\tunpacktd)\n BU_LDBL128_2 (PACK_TF,\t\t\"pack_longdouble\",\tCONST,\tpacktf)\n BU_LDBL128_2 (UNPACK_TF,\t\"unpack_longdouble\",\tCONST,\tunpacktf)\n \n-BU_FLOAT128_2 (PACK_IF,\t\t\"pack_ibm128\",\t\tCONST,\tpackif)\n-BU_FLOAT128_2 (UNPACK_IF,\t\"unpack_ibm128\",\tCONST,\tunpackif)\n-\n BU_P7_MISC_2 (PACK_V1TI,\t\"pack_vector_int128\",\tCONST,\tpackv1ti)\n BU_P7_MISC_2 (UNPACK_V1TI,\t\"unpack_vector_int128\",\tCONST,\tunpackv1ti)\n "}, {"sha": "4cd6a1b58cd8bcc484eeb8508c6b3948df0a6f0a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -3521,8 +3521,7 @@ rs6000_builtin_mask_calculate (void)\n \t  | ((TARGET_HTM)\t\t    ? RS6000_BTM_HTM\t   : 0)\n \t  | ((TARGET_DFP)\t\t    ? RS6000_BTM_DFP\t   : 0)\n \t  | ((TARGET_HARD_FLOAT)\t    ? RS6000_BTM_HARD_FLOAT : 0)\n-\t  | ((TARGET_LONG_DOUBLE_128)\t    ? RS6000_BTM_LDBL128   : 0)\n-\t  | ((TARGET_FLOAT128)\t\t    ? RS6000_BTM_FLOAT128  : 0));\n+\t  | ((TARGET_LONG_DOUBLE_128)\t    ? RS6000_BTM_LDBL128 : 0));\n }\n \n /* Implement TARGET_MD_ASM_ADJUST.  All asm statements are considered\n@@ -14606,8 +14605,6 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)\n \t   \" -mlong-double-128 options\", name);\n   else if ((fnmask & RS6000_BTM_HARD_FLOAT) != 0)\n     error (\"Builtin function %s requires the -mhard-float option\", name);\n-  else if ((fnmask & RS6000_BTM_FLOAT128) != 0)\n-    error (\"Builtin function %s requires the -mfloat128 options\", name);\n   else\n     error (\"Builtin function %s is not supported with the current options\",\n \t   name);\n@@ -14897,21 +14894,19 @@ rs6000_init_builtins (void)\n      IFmode is the IBM extended 128-bit format that is a pair of doubles.\n      TFmode will be either IEEE 128-bit floating point or the IBM double-double\n      format that uses a pair of doubles, depending on the switches and\n-     defaults.  Always create the types even if we don't register the keywords\n-     to allow built-in functions using these types to be created.  */\n-\n-  ibm128_float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (ibm128_float_type_node) = 128;\n-  layout_type (ibm128_float_type_node);\n-  SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n-\n-  ieee128_float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (ieee128_float_type_node) = 128;\n-  layout_type (ieee128_float_type_node);\n-  SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n-\n+     defaults.  */\n   if (TARGET_FLOAT128)\n     {\n+      ibm128_float_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (ibm128_float_type_node) = 128;\n+      layout_type (ibm128_float_type_node);\n+      SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n+\n+      ieee128_float_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (ieee128_float_type_node) = 128;\n+      layout_type (ieee128_float_type_node);\n+      SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n+\n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__float128\");\n \n@@ -34228,7 +34223,6 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n   { \"hard-dfp\",\t\t RS6000_BTM_DFP,\tfalse, false },\n   { \"hard-float\",\t RS6000_BTM_HARD_FLOAT,\tfalse, false },\n   { \"long-double-128\",\t RS6000_BTM_LDBL128,\tfalse, false },\n-  { \"float128\",\t\t RS6000_BTM_FLOAT128,\tfalse, false },\n };\n \n /* Option variables that we want to support inside attribute((target)) and"}, {"sha": "6b0e64e693d3526b8716890d5a7a7f4e2ee0262b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -605,7 +605,6 @@ extern int rs6000_vector_align[];\n #define MASK_DLMZB\t\t\tOPTION_MASK_DLMZB\n #define MASK_EABI\t\t\tOPTION_MASK_EABI\n #define MASK_FPRND\t\t\tOPTION_MASK_FPRND\n-#define MASK_FLOAT128\t\t\tOPTION_MASK_FLOAT128\n #define MASK_P8_FUSION\t\t\tOPTION_MASK_P8_FUSION\n #define MASK_HARD_FLOAT\t\t\tOPTION_MASK_HARD_FLOAT\n #define MASK_HTM\t\t\tOPTION_MASK_HTM\n@@ -2671,7 +2670,6 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_DFP\t\tMASK_DFP\t/* Decimal floating point.  */\n #define RS6000_BTM_HARD_FLOAT\tMASK_SOFT_FLOAT\t/* Hardware floating point.  */\n #define RS6000_BTM_LDBL128\tMASK_MULTIPLE\t/* 128-bit long double.  */\n-#define RS6000_BTM_FLOAT128\tMASK_FLOAT128\t/* IEEE 128-bit fp.  */\n \n #define RS6000_BTM_COMMON\t(RS6000_BTM_ALTIVEC\t\t\t\\\n \t\t\t\t | RS6000_BTM_VSX\t\t\t\\\n@@ -2686,8 +2684,7 @@ extern int frame_pointer_needed;\n \t\t\t\t | RS6000_BTM_CELL\t\t\t\\\n \t\t\t\t | RS6000_BTM_DFP\t\t\t\\\n \t\t\t\t | RS6000_BTM_HARD_FLOAT\t\t\\\n-\t\t\t\t | RS6000_BTM_LDBL128\t\t\t\\\n-\t\t\t\t | RS6000_BTM_FLOAT128)\n+\t\t\t\t | RS6000_BTM_LDBL128)\n \n /* Define builtin enum index.  */\n "}, {"sha": "dbcf583475d58abc31fda806e4cfb9171d6450ed", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -469,9 +469,6 @@\n ; Definitions for 64-bit access to ISA 3.0 (power9) vector\n (define_mode_attr f64_p9  [(DF \"wb\") (DD \"wn\")])\n \n-; Definitions for 128-bit IBM extended double word pack/unpack\n-(define_mode_attr f128_vsx [(TF \"ws\") (IF \"ws\") (TD \"d\")])\n-\n ; These modes do not fit in integer registers in 32-bit mode.\n ; but on e500v2, the gpr are 64 bit registers\n (define_mode_iterator DIFD [DI (DF \"!TARGET_E500_DOUBLE\") DD])\n@@ -13112,16 +13109,16 @@\n (define_expand \"unpack<mode>\"\n   [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"\")\n \t(unspec:<FP128_64>\n-\t [(match_operand:FMOVE128_FPR 1 \"register_operand\" \"\")\n+\t [(match_operand:FMOVE128 1 \"register_operand\" \"\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"\")]\n \t UNSPEC_UNPACK_128BIT))]\n   \"FLOAT128_2REG_P (<MODE>mode)\"\n   \"\")\n \n-(define_insn_and_split \"*unpack<mode>_dm\"\n-  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=<f128_vsx>,m,<f128_vsx>,r,m\")\n+(define_insn_and_split \"unpack<mode>_dm\"\n+  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=d,m,d,r,m\")\n \t(unspec:<FP128_64>\n-\t [(match_operand:FMOVE128_FPR 1 \"register_operand\" \"d,d,r,d,r\")\n+\t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d,r,d,r\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i,i,i,i\")]\n \t UNSPEC_UNPACK_128BIT))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && FLOAT128_2REG_P (<MODE>mode)\"\n@@ -13142,10 +13139,10 @@\n   [(set_attr \"type\" \"fp,fpstore,mffgpr,mftgpr,store\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn_and_split \"*unpack<mode>_nodm\"\n-  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=<f128_vsx>,m\")\n+(define_insn_and_split \"unpack<mode>_nodm\"\n+  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=d,m\")\n \t(unspec:<FP128_64>\n-\t [(match_operand:FMOVE128_FPR 1 \"register_operand\" \"d,d\")\n+\t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i\")]\n \t UNSPEC_UNPACK_128BIT))]\n   \"(!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE) && FLOAT128_2REG_P (<MODE>mode)\"\n@@ -13167,31 +13164,30 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn_and_split \"pack<mode>\"\n-  [(set (match_operand:FMOVE128_FPR 0 \"register_operand\" \"=&d,&d,&d,&d\")\n-\t(unspec:FMOVE128_FPR\n-\t [(match_operand:<FP128_64> 1 \"input_operand\" \"<f128_vsx>,<f128_vsx>,m,m\")\n-\t  (match_operand:<FP128_64> 2 \"input_operand\" \"<f128_vsx>,m,<f128_vsx>,m\")]\n+  [(set (match_operand:FMOVE128 0 \"register_operand\" \"=d,&d\")\n+\t(unspec:FMOVE128\n+\t [(match_operand:<FP128_64> 1 \"register_operand\" \"0,d\")\n+\t  (match_operand:<FP128_64> 2 \"register_operand\" \"d,d\")]\n \t UNSPEC_PACK_128BIT))]\n   \"FLOAT128_2REG_P (<MODE>mode)\"\n-  \"#\"\n-  \"&& reload_completed\"\n+  \"@\n+   fmr %L0,%2\n+   #\"\n+  \"&& reload_completed && REGNO (operands[0]) != REGNO (operands[1])\"\n   [(set (match_dup 3) (match_dup 1))\n    (set (match_dup 4) (match_dup 2))]\n {\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  rtx op2 = operands[2];\n-  unsigned dest_hi = REGNO (op0);\n+  unsigned dest_hi = REGNO (operands[0]);\n   unsigned dest_lo = dest_hi + 1;\n \n-  gcc_assert (!REG_P (op1) || !IN_RANGE (REGNO (op1), dest_hi, dest_lo));\n-  gcc_assert (!REG_P (op2) || !IN_RANGE (REGNO (op2), dest_hi, dest_lo));\n+  gcc_assert (!IN_RANGE (REGNO (operands[1]), dest_hi, dest_lo));\n+  gcc_assert (!IN_RANGE (REGNO (operands[2]), dest_hi, dest_lo));\n \n   operands[3] = gen_rtx_REG (<FP128_64>mode, dest_hi);\n   operands[4] = gen_rtx_REG (<FP128_64>mode, dest_lo);\n }\n-  [(set_attr \"type\" \"fp,fpload,fpload,fpload\")\n-   (set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"fp,fp\")\n+   (set_attr \"length\" \"4,8\")])\n \n (define_insn \"unpack<mode>\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")"}, {"sha": "b85c34cf9a9c9c9ef56c09854f5958452d7ece0c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -13538,8 +13538,6 @@ uint64_t __builtin_ppc_get_timebase ();\n unsigned long __builtin_ppc_mftb ();\n double __builtin_unpack_longdouble (long double, int);\n long double __builtin_pack_longdouble (double, double);\n-double __builtin_unpack_ibm128 (__ibm128, int);\n-__ibm128 __builtin_pack_ibm128 (double, double);\n @end smallexample\n \n The @code{vec_rsqrt}, @code{__builtin_rsqrt}, and"}, {"sha": "ec943f407424ade02fa3efa8c7a9cdf938248e8b", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -1,3 +1,23 @@\n+2016-01-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* libgcc/config/rs6000/extendkftf2-sw.c: Revert 2016-01-13 change.\n+\t* libgcc/config/rs6000/fixkfti.c: Likewise.\n+\t* libgcc/config/rs6000/fixunskfti.c: Likewise.\n+\t* libgcc/config/rs6000/float128-hw.c: Likewise.\n+\t* libgcc/config/rs6000/float128-ifunc.c: Likewise.\n+\t* libgcc/config/rs6000/float128-sed: Likewise.\n+\t* libgcc/config/rs6000/floattikf.c: Likewise.\n+\t* libgcc/config/rs6000/floatuntikf.c: Likewise.\n+\t* libgcc/config/rs6000/quad-float128.h: Likewise.\n+\t* libgcc/config/rs6000/sfp-exceptions.c: Likewise.\n+\t* libgcc/config/rs6000/sfp-machine.h: Likewise.\n+\t* libgcc/config/rs6000/t-float128: Likewise.\n+\t* libgcc/config/rs6000/t-float128-hw: Likewise.\n+\t* libgcc/config/rs6000/trunctfkf2-sw.c: Likewise.\n+\t* libgcc/config.host: Likewise.\n+\t* libgcc/configure: Likewise.\n+\t* libgcc/configure.ac: Likewise.\n+\n 2016-01-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \t    Steven Munroe <munroesj@linux.vnet.ibm.com>\n \t    Tulio Magno Quites Machado Filho <tulioqm@br.ibm.com>"}, {"sha": "f58ee4555f5b1d206a0594f8f68d73681f3160b3", "filename": "libgcc/config.host", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -1063,15 +1063,6 @@ powerpc*-*-linux*)\n \t\texit 1\n \t\t;;\n \tesac\n-\n-\tif test $libgcc_cv_powerpc_float128 = yes; then\n-\t\ttmake_file=\"${tmake_file} rs6000/t-float128\"\n-\tfi\n-\n-\tif test $libgcc_cv_powerpc_float128_hw = yes; then\n-\t\ttmake_file=\"${tmake_file} rs6000/t-float128-hw\"\n-\tfi\n-\n \textra_parts=\"$extra_parts ecrti.o ecrtn.o ncrti.o ncrtn.o\"\n \tmd_unwind_header=rs6000/linux-unwind.h\n \t;;"}, {"sha": "2418a392c56e0fd2b2438b94d13617f9031994fa", "filename": "libgcc/config/rs6000/extendkftf2-sw.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,49 +0,0 @@\n-/* Software IEEE 128-bit floating-point emulation for PowerPC.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-\tRichard Henderson (rth@cygnus.com) and\n-\tJakub Jelinek (jj@ultra.linux.cz).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Convert IEEE 128-bit floating point to IBM long double.  */\n-\n-#ifdef __FLOAT128_HARDWARE__\n-#error \"This module must not be compiled with IEEE 128-bit hardware support\"\n-#endif\n-\n-#include \"soft-fp.h\"\n-#include \"quad-float128.h\"\n-\n-__ibm128\n-__extendkftf2_sw (__float128 value)\n-{\n-  __ibm128 ret;\n-\n-  CVT_FLOAT128_TO_IBM128 (ret, value);\n-  return ret;\n-}"}, {"sha": "80e10f078c0678798356ddf10b9a57d5c945c796", "filename": "libgcc/config/rs6000/fixkfti.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffixkfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffixkfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffixkfti.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,51 +0,0 @@\n-/* Software floating-point emulation, convert IEEE quad to 128bit signed\n-   integer.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-   \t   Uros Bizjak (ubizjak@gmail.com).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifdef _ARCH_PPC64\n-#include \"soft-fp.h\"\n-#include \"quad-float128.h\"\n-\n-TItype\n-__fixkfti (TFtype a)\n-{\n-  FP_DECL_EX;\n-  FP_DECL_Q (A);\n-  UTItype r;\n-\n-  FP_INIT_EXCEPTIONS;\n-  FP_UNPACK_RAW_Q (A, a);\n-  FP_TO_INT_Q (r, A, TI_BITS, 1);\n-  FP_HANDLE_EXCEPTIONS;\n-\n-  return r;\n-}\n-#endif"}, {"sha": "56c36716120f0b3d0a1ab05e05f8c4ec8e2557c7", "filename": "libgcc/config/rs6000/fixunskfti.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffixunskfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffixunskfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffixunskfti.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,51 +0,0 @@\n-/* Software floating-point emulation, convert IEEE quad to 128bit unsigned\n-   integer.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-   \t   Uros Bizjak (ubizjak@gmail.com).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifdef _ARCH_PPC64\n-#include \"soft-fp.h\"\n-#include \"quad-float128.h\"\n-\n-UTItype\n-__fixunskfti (TFtype a)\n-{\n-  FP_DECL_EX;\n-  FP_DECL_Q (A);\n-  UTItype r;\n-\n-  FP_INIT_EXCEPTIONS;\n-  FP_UNPACK_RAW_Q (A, a);\n-  FP_TO_INT_Q (r, A, TI_BITS, 0);\n-  FP_HANDLE_EXCEPTIONS;\n-\n-  return r;\n-}\n-#endif"}, {"sha": "da2fbbcafd1c83f345ca153b6dea968d4f1adb03", "filename": "libgcc/config/rs6000/float128-hw.c", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloat128-hw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloat128-hw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloat128-hw.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,207 +0,0 @@\n-/* Automatic switching between software and hardware IEEE 128-bit\n-   floating-point emulation for PowerPC.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-\tRichard Henderson (rth@cygnus.com) and\n-\tJakub Jelinek (jj@ultra.linux.cz).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <soft-fp.h>\n-#include <quad-float128.h>\n-\n-#ifndef __FLOAT128_HARDWARE__\n-#error \"This module must be compiled with IEEE 128-bit hardware support\"\n-#endif\n-\n-TFtype\n-__addkf3_hw (TFtype a, TFtype b)\n-{\n-  return a + b;\n-}\n-\n-TFtype\n-__subkf3_hw (TFtype a, TFtype b)\n-{\n-  return a - b;\n-}\n-\n-TFtype\n-__mulkf3_hw (TFtype a, TFtype b)\n-{\n-  return a * b;\n-}\n-\n-TFtype\n-__divkf3_hw (TFtype a, TFtype b)\n-{\n-  return a / b;\n-}\n-\n-TFtype\n-__negkf2_hw (TFtype a)\n-{\n-  return -a;\n-}\n-\n-TFtype\n-__floatsikf_hw (SItype_ppc a)\n-{\n-  return (TFtype) a;\n-}\n-\n-TFtype\n-__floatunsikf_hw (USItype_ppc a)\n-{\n-  return (TFtype) a;\n-}\n-\n-TFtype\n-__floatdikf_hw (DItype_ppc a)\n-{\n-  return (TFtype) a;\n-}\n-\n-TFtype\n-__floatundikf_hw (UDItype_ppc a)\n-{\n-  return (TFtype) a;\n-}\n-\n-SItype_ppc\n-__fixkfsi_hw (TFtype a)\n-{\n-  return (SItype_ppc) a;\n-}\n-\n-USItype_ppc\n-__fixunskfsi_hw (TFtype a)\n-{\n-  return (USItype_ppc) a;\n-}\n-\n-DItype_ppc\n-__fixkfdi_hw (TFtype a)\n-{\n-  return (DItype_ppc) a;\n-}\n-\n-UDItype_ppc\n-__fixunskfdi_hw (TFtype a)\n-{\n-  return (UDItype_ppc) a;\n-}\n-\n-TFtype\n-__extendsfkf2_hw (float a)\n-{\n-  return (TFtype) a;\n-}\n-\n-TFtype\n-__extenddfkf2_hw (double a)\n-{\n-  return (TFtype) a;\n-}\n-\n-float\n-__trunckfsf2_hw (TFtype a)\n-{\n-  return (float) a;\n-}\n-\n-double\n-__trunckfdf2_hw (TFtype a)\n-{\n-  return (double) a;\n-}\n-\n-/* __eqkf2 returns 0 if equal, or 1 if not equal or NaN.  */\n-CMPtype\n-__eqkf2_hw (TFtype a, TFtype b)\n-{\n-  return (a != b);\n-}\n-\n-/* __gekf2 returns -1 if a < b, 0 if a == b, +1 if a > b, or -2 if NaN.  */\n-CMPtype\n-__gekf2_hw (TFtype a, TFtype b)\n-{\n-  if (a < b)\n-    return -1;\n-\n-  else if (__builtin_isunordered (a, b))\n-    return -2;\n-\n-  else if (a == b)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* __lekf2 returns -1 if a < b, 0 if a == b, +1 if a > b, or +2 if NaN.  */\n-CMPtype\n-__lekf2_hw (TFtype a, TFtype b)\n-{\n-  if (a < b)\n-    return -1;\n-\n-  else if (__builtin_isunordered (a, b))\n-    return 2;\n-\n-  else if (a == b)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* __unordkf2 returns 1 if NaN or 0 otherwise.  */\n-CMPtype\n-__unordkf2_hw (TFtype a, TFtype b)\n-{\n-  return (__builtin_isunordered (a, b)) ? 1 : 0;\n-}\n-\n-/* Convert __float128 to __ibm128.  */\n-__ibm128\n-__extendkftf2_hw (TFtype value)\n-{\n-  __ibm128 ret;\n-\n-  CVT_FLOAT128_TO_IBM128 (ret, value);\n-  return ret;\n-}\n-\n-/* Convert __ibm128 to __float128.  */\n-TFtype\n-__trunctfkf2_hw (__ibm128 value)\n-{\n-  TFtype ret;\n-\n-  CVT_IBM128_TO_FLOAT128 (ret, value);\n-  return ret;\n-}"}, {"sha": "6e14608d3a7d3856754820698e93f94cbea05c9e", "filename": "libgcc/config/rs6000/float128-ifunc.c", "status": "removed", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloat128-ifunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloat128-ifunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloat128-ifunc.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,358 +0,0 @@\n-/* Automatic switching between software and hardware IEEE 128-bit\n-   floating-point emulation for PowerPC.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-\tRichard Henderson (rth@cygnus.com) and\n-\tJakub Jelinek (jj@ultra.linux.cz).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <soft-fp.h>\n-#include <quad-float128.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <ctype.h>\n-\n-#ifdef FLOAT128_HW_INSNS\n-#include <sys/auxv.h>\n-\n-/* Use the namespace clean version of getauxval.  However, not all versions of\n-   sys/auxv.h declare it, so declare it here.  This code is intended to be\n-   temporary until a suitable version of __builtin_cpu_supports is added that\n-   allows us to tell quickly if the machine supports IEEE 128-bit hardware.  */\n-extern unsigned long __getauxval (unsigned long);\n-\n-static int\n-have_ieee_hw_p (void)\n-{\n-  static int ieee_hw_p = -1;\n-\n-  if (ieee_hw_p < 0)\n-    {\n-      char *p = (char *) __getauxval (AT_PLATFORM);\n-\n-      ieee_hw_p = 0;\n-\n-      /* Don't use atoi/strtol/strncmp/etc.  These may require the normal\n-\t environment to be setup to set errno to 0, and the ifunc resolvers run\n-\t before the whole glibc environment is initialized.  */\n-      if (p && p[0] == 'p' && p[1] == 'o' && p[2] == 'w' && p[3] == 'e'\n-\t  && p[4] == 'r')\n-\t{\n-\t  long n = 0;\n-\t  char ch;\n-\n-\t  p += 5;\n-\t  while ((ch = *p++) >= '0' && (ch <= '9'))\n-\t    n = (n * 10) + (ch - '0');\n-\n-\t  if (n >= 9)\n-\t    ieee_hw_p = 1;\n-\t}\n-    }\n-\n-  return ieee_hw_p;\n-}\n-\n-#define SW_OR_HW(SW, HW) (have_ieee_hw_p () ? HW : SW)\n-#else\n-#define SW_OR_HW(SW, HW) (SW)\n-#endif\t/* ISA 3.0 hardware available.  */\n-\n-/* Resolvers.  */\n-\n-/* We do not provide ifunc resolvers for __fixkfti, __fixunskfti, __floattikf,\n-   and __floatuntikf.  There is no ISA 3.0 instruction that converts between\n-   128-bit integer types and 128-bit IEEE floating point, or vice versa.  So\n-   use the emulator functions for these conversions.  */\n-\n-static void *__addkf3_resolve (void);\n-static void *__subkf3_resolve (void);\n-static void *__mulkf3_resolve (void);\n-static void *__divkf3_resolve (void);\n-static void *__negkf2_resolve (void);\n-static void *__eqkf2_resolve (void);\n-static void *__nekf2_resolve (void);\n-static void *__gekf2_resolve (void);\n-static void *__gtkf2_resolve (void);\n-static void *__lekf2_resolve (void);\n-static void *__ltkf2_resolve (void);\n-static void *__unordkf2_resolve (void);\n-static void *__extendsfkf2_resolve (void);\n-static void *__extenddfkf2_resolve (void);\n-static void *__trunckfsf2_resolve (void);\n-static void *__trunckfdf2_resolve (void);\n-static void *__fixkfsi_resolve (void);\n-static void *__fixkfdi_resolve (void);\n-static void *__fixunskfsi_resolve (void);\n-static void *__fixunskfdi_resolve (void);\n-static void *__floatsikf_resolve (void);\n-static void *__floatdikf_resolve (void);\n-static void *__floatunsikf_resolve (void);\n-static void *__floatundikf_resolve (void);\n-static void *__extendkftf2_resolve (void);\n-static void *__trunctfkf2_resolve (void);\n-\n-static void *\n-__addkf3_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__addkf3_sw, __addkf3_hw);\n-}\n-\n-static void *\n-__subkf3_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__subkf3_sw, __subkf3_hw);\n-}\n-\n-static void *\n-__mulkf3_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__mulkf3_sw, __mulkf3_hw);\n-}\n-\n-static void *\n-__divkf3_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__divkf3_sw, __divkf3_hw);\n-}\n-\n-static void *\n-__negkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__negkf2_sw, __negkf2_hw);\n-}\n-\n-static void *\n-__floatsikf_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__floatsikf_sw, __floatsikf_hw);\n-}\n-\n-static void *\n-__floatdikf_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__floatdikf_sw, __floatdikf_hw);\n-}\n-\n-static void *\n-__floatunsikf_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__floatunsikf_sw, __floatunsikf_hw);\n-}\n-\n-static void *\n-__floatundikf_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__floatundikf_sw, __floatundikf_hw);\n-}\n-\n-static void *\n-__fixkfsi_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__fixkfsi_sw, __fixkfsi_hw);\n-}\n-\n-static void *\n-__fixkfdi_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__fixkfdi_sw, __fixkfdi_hw);\n-}\n-\n-static void *\n-__fixunskfsi_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__fixunskfsi_sw, __fixunskfsi_hw);\n-}\n-\n-static void *\n-__fixunskfdi_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__fixunskfdi_sw, __fixunskfdi_hw);\n-}\n-\n-static void *\n-__extendsfkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__extendsfkf2_sw, __extendsfkf2_hw);\n-}\n-\n-static void *\n-__extenddfkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__extenddfkf2_sw, __extenddfkf2_hw);\n-}\n-\n-static void *\n-__trunckfsf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__trunckfsf2_sw, __trunckfsf2_hw);\n-}\n-\n-static void *\n-__trunckfdf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__trunckfdf2_sw, __trunckfdf2_hw);\n-}\n-\n-static void *\n-__extendkftf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__extendkftf2_sw, __extendkftf2_hw);\n-}\n-\n-static void *\n-__trunctfkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__trunctfkf2_sw, __trunctfkf2_hw);\n-}\n-\n-static void *\n-__eqkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__eqkf2_sw, __eqkf2_hw);\n-}\n-\n-static void *\n-__gekf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__gekf2_sw, __gekf2_hw);\n-}\n-\n-static void *\n-__lekf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__lekf2_sw, __lekf2_hw);\n-}\n-\n-static void *\n-__unordkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__unordkf2_sw, __unordkf2_hw);\n-}\n-\n-/* Resolve __nekf2, __gtkf2, __ltkf2 like __eqkf2, __gekf2, and __lekf2, since\n-   the functions return the same values.  */\n-\n-static void *\n-__nekf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__eqkf2_sw, __eqkf2_hw);\n-}\n-\n-static void *\n-__gtkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__gekf2_sw, __gekf2_hw);\n-}\n-\n-static void *\n-__ltkf2_resolve (void)\n-{\n-  return (void *) SW_OR_HW (__lekf2_sw, __lekf2_hw);\n-}\n-\n-\n-\f\n-/* Ifunc definitions.  */\n-TFtype __addkf3 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__addkf3_resolve\")));\n-\n-TFtype __subkf3 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__subkf3_resolve\")));\n-\n-TFtype __mulkf3 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__mulkf3_resolve\")));\n-\n-TFtype __divkf3 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__divkf3_resolve\")));\n-\n-TFtype __negkf2 (TFtype)\n-  __attribute__ ((__ifunc__ (\"__negkf2_resolve\")));\n-\n-CMPtype __eqkf2 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__eqkf2_resolve\")));\n-\n-CMPtype __nekf2 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__nekf2_resolve\")));\n-\n-CMPtype __gekf2 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__gekf2_resolve\")));\n-\n-CMPtype __gtkf2 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__gtkf2_resolve\")));\n-\n-CMPtype __lekf2 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__lekf2_resolve\")));\n-\n-CMPtype __ltkf2 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__ltkf2_resolve\")));\n-\n-CMPtype __unordkf2 (TFtype, TFtype)\n-  __attribute__ ((__ifunc__ (\"__unordkf2_resolve\")));\n-\n-TFtype __extendsfkf2 (float)\n-  __attribute__ ((__ifunc__ (\"__extendsfkf2_resolve\")));\n-\n-TFtype __extenddfkf2 (double)\n-  __attribute__ ((__ifunc__ (\"__extenddfkf2_resolve\")));\n-\n-float __trunckfsf2 (TFtype)\n-  __attribute__ ((__ifunc__ (\"__trunckfsf2_resolve\")));\n-\n-double __trunckfdf2 (TFtype)\n-  __attribute__ ((__ifunc__ (\"__trunckfdf2_resolve\")));\n-\n-SItype_ppc __fixkfsi (TFtype)\n-  __attribute__ ((__ifunc__ (\"__fixkfsi_resolve\")));\n-\n-DItype_ppc __fixkfdi (TFtype)\n-  __attribute__ ((__ifunc__ (\"__fixkfdi_resolve\")));\n-\n-USItype_ppc __fixunskfsi (TFtype)\n-  __attribute__ ((__ifunc__ (\"__fixunskfsi_resolve\")));\n-\n-UDItype_ppc __fixunskfdi (TFtype)\n-  __attribute__ ((__ifunc__ (\"__fixunskfdi_resolve\")));\n-\n-TFtype __floatsikf (SItype_ppc)\n-  __attribute__ ((__ifunc__ (\"__floatsikf_resolve\")));\n-\n-TFtype __floatdikf (DItype_ppc)\n-  __attribute__ ((__ifunc__ (\"__floatdikf_resolve\")));\n-\n-TFtype __floatunsikf (USItype_ppc)\n-  __attribute__ ((__ifunc__ (\"__floatunsikf_resolve\")));\n-\n-TFtype __floatundikf (UDItype_ppc)\n-  __attribute__ ((__ifunc__ (\"__floatundikf_resolve\")));\n-\n-__ibm128 __extendkftf2 (TFtype)\n-  __attribute__ ((__ifunc__ (\"__extendkftf2_resolve\")));\n-\n-TFtype __trunctfkf2 (__ibm128)\n-  __attribute__ ((__ifunc__ (\"__trunctfkf2_resolve\")));"}, {"sha": "acf36b0c17dd9e1cbd6a5899469fc7559a7d02a8", "filename": "libgcc/config/rs6000/float128-sed", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloat128-sed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloat128-sed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloat128-sed?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,25 +0,0 @@\n-s/__addtf3/__addkf3_sw/g\n-s/__divtf3/__divkf3_sw/g\n-s/__eqtf2/__eqkf2_sw/g\n-s/__extenddftf2/__extenddfkf2_sw/g\n-s/__extendsftf2/__extendsfkf2_sw/g\n-s/__fixtfdi/__fixkfdi_sw/g\n-s/__fixtfsi/__fixkfsi_sw/g\n-s/__fixunstfdi/__fixunskfdi_sw/g\n-s/__fixunstfsi/__fixunskfsi_sw/g\n-s/__floatditf/__floatdikf_sw/g\n-s/__floatsitf/__floatsikf_sw/g\n-s/__floatunditf/__floatundikf_sw/g\n-s/__floatunsitf/__floatunsikf_sw/g\n-s/__getf2/__gekf2_sw/g\n-s/__gttf2/__gtkf2_sw/g\n-s/__letf2/__lekf2_sw/g\n-s/__lttf2/__ltkf2_sw/g\n-s/__multf3/__mulkf3_sw/g\n-s/__negtf2/__negkf2_sw/g\n-s/__netf2/__nekf2_sw/g\n-s/quad[.]h/quad-float128.h/g\n-s/__subtf3/__subkf3_sw/g\n-s/__trunctfdf2/__trunckfdf2_sw/g\n-s/__trunctfsf2/__trunckfsf2_sw/g\n-s/__unordtf2/__unordkf2_sw/g"}, {"sha": "4c652308158994233e9daa618a3203ef9883fa0c", "filename": "libgcc/config/rs6000/floattikf.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloattikf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloattikf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloattikf.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,51 +0,0 @@\n-/* Software floating-point emulation, convert a 128bit signed integer to IEEE\n-   quad.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-   \t   Uros Bizjak (ubizjak@gmail.com).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifdef _ARCH_PPC64\n-#include \"soft-fp.h\"\n-#include \"quad-float128.h\"\n-\n-TFtype\n-__floattikf (TItype i)\n-{\n-  FP_DECL_EX;\n-  FP_DECL_Q (A);\n-  TFtype a;\n-\n-  FP_INIT_ROUNDMODE;\n-  FP_FROM_INT_Q (A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_Q (a, A);\n-  FP_HANDLE_EXCEPTIONS;\n-\n-  return a;\n-}\n-#endif"}, {"sha": "6dabf7b33bd8af3ee909c8541b453a8914d1b56e", "filename": "libgcc/config/rs6000/floatuntikf.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloatuntikf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ffloatuntikf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloatuntikf.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,51 +0,0 @@\n-/* Software floating-point emulation, convert a 128bit unsigned integer to IEEE\n-   quad.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-   \t   Uros Bizjak (ubizjak@gmail.com).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifdef _ARCH_PPC64\n-#include \"soft-fp.h\"\n-#include \"quad-float128.h\"\n-\n-TFtype\n-__floatuntikf (UTItype i)\n-{\n-  FP_DECL_EX;\n-  FP_DECL_Q (A);\n-  TFtype a;\n-\n-  FP_INIT_ROUNDMODE;\n-  FP_FROM_INT_Q (A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_Q (a, A);\n-  FP_HANDLE_EXCEPTIONS;\n-\n-  return a;\n-}\n-#endif"}, {"sha": "423cb05d9ea54e619a89169876d0a033626e9f86", "filename": "libgcc/config/rs6000/quad-float128.h", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,203 +0,0 @@\n-/* Software floating-point emulation.\n-   Definitions for IEEE Quad Precision on the PowerPC.\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* quad.h defines the TFtype type by:\n-   typedef float TFtype __attribute__ ((mode (TF)));\n-\n-   This define forces it to use KFmode (aka, ieee 128-bit floating point).  */\n-#define TF KF\n-\n-/* Force the use of the VSX instruction set.  */\n-#if defined(_ARCH_PPC) && (!defined(__VSX__) || !defined(__FLOAT128__))\n-#pragma GCC target (\"vsx,float128\")\n-#endif\n-\n-#include <quad.h>\n-\n-/* Add prototypes of the library functions created.  In case the appropriate\n-   int/long types are not declared in scope by the time quad.h is included,\n-   provide our own version.  */\n-typedef int\t SItype_ppc  __attribute__ ((__mode__ (__SI__)));\n-typedef int\t DItype_ppc  __attribute__ ((__mode__ (__DI__)));\n-typedef unsigned USItype_ppc __attribute__ ((__mode__ (__SI__)));\n-typedef unsigned UDItype_ppc __attribute__ ((__mode__ (__DI__)));\n-\n-#ifdef _ARCH_PPC64\n-typedef int\t TItype_ppc  __attribute__ ((__mode__ (__TI__)));\n-typedef unsigned UTItype_ppc __attribute__ ((__mode__ (__TI__)));\n-#endif\n-\n-/* Software emulation functions.  */\n-extern TFtype __addkf3_sw (TFtype, TFtype);\n-extern TFtype __subkf3_sw (TFtype, TFtype);\n-extern TFtype __mulkf3_sw (TFtype, TFtype);\n-extern TFtype __divkf3_sw (TFtype, TFtype);\n-extern TFtype __negkf2_sw (TFtype);\n-extern CMPtype __eqkf2_sw (TFtype, TFtype);\n-extern CMPtype __gekf2_sw (TFtype, TFtype);\n-extern CMPtype __lekf2_sw (TFtype, TFtype);\n-extern CMPtype __unordkf2_sw (TFtype, TFtype);\n-extern TFtype __extendsfkf2_sw (float);\n-extern TFtype __extenddfkf2_sw (double);\n-extern float __trunckfsf2_sw (TFtype);\n-extern double __trunckfdf2_sw (TFtype);\n-extern SItype_ppc __fixkfsi_sw (TFtype);\n-extern DItype_ppc __fixkfdi_sw (TFtype);\n-extern USItype_ppc __fixunskfsi_sw (TFtype);\n-extern UDItype_ppc __fixunskfdi_sw (TFtype);\n-extern TFtype __floatsikf_sw (SItype_ppc);\n-extern TFtype __floatdikf_sw (DItype_ppc);\n-extern TFtype __floatunsikf_sw (USItype_ppc);\n-extern TFtype __floatundikf_sw (UDItype_ppc);\n-extern __ibm128 __extendkftf2_sw (TFtype);\n-extern TFtype __trunctfkf2_sw (__ibm128);\n-\n-#ifdef _ARCH_PPC64\n-/* We do not provide ifunc resolvers for __fixkfti, __fixunskfti, __floattikf,\n-   and __floatuntikf.  There is no ISA 3.0 instruction that converts between\n-   128-bit integer types and 128-bit IEEE floating point, or vice versa.  So\n-   use the emulator functions for these conversions.  */\n-\n-extern TItype_ppc __fixkfti (TFtype);\n-extern UTItype_ppc __fixunskfti (TFtype);\n-extern TFtype __floattikf (TItype_ppc);\n-extern TFtype __floatuntikf (UTItype_ppc);\n-#endif\n-\n-/* Functions using the ISA 3.0 hardware support.  If the code is compiled with\n-   -mcpu=power9, it will not use these functions, but if it was compiled with\n-   -mcpu=power7 or -mcpu=power8 and run on a ISA 3.0 system, it will use the\n-   hardware instruction.  */\n-extern TFtype __addkf3_hw (TFtype, TFtype);\n-extern TFtype __subkf3_hw (TFtype, TFtype);\n-extern TFtype __mulkf3_hw (TFtype, TFtype);\n-extern TFtype __divkf3_hw (TFtype, TFtype);\n-extern TFtype __negkf2_hw (TFtype);\n-extern CMPtype __eqkf2_hw (TFtype, TFtype);\n-extern CMPtype __gekf2_hw (TFtype, TFtype);\n-extern CMPtype __lekf2_hw (TFtype, TFtype);\n-extern CMPtype __unordkf2_hw (TFtype, TFtype);\n-extern TFtype __extendsfkf2_hw (float);\n-extern TFtype __extenddfkf2_hw (double);\n-extern float __trunckfsf2_hw (TFtype);\n-extern double __trunckfdf2_hw (TFtype);\n-extern SItype_ppc __fixkfsi_hw (TFtype);\n-extern DItype_ppc __fixkfdi_hw (TFtype);\n-extern USItype_ppc __fixunskfsi_hw (TFtype);\n-extern UDItype_ppc __fixunskfdi_hw (TFtype);\n-extern TFtype __floatsikf_hw (SItype_ppc);\n-extern TFtype __floatdikf_hw (DItype_ppc);\n-extern TFtype __floatunsikf_hw (USItype_ppc);\n-extern TFtype __floatundikf_hw (UDItype_ppc);\n-extern __ibm128 __extendkftf2_hw (TFtype);\n-extern TFtype __trunctfkf2_hw (__ibm128);\n-\n-/* Ifunc function declarations, to automatically switch between software\n-   emulation and hardware support.  */\n-extern TFtype __addkf3 (TFtype, TFtype);\n-extern TFtype __subkf3 (TFtype, TFtype);\n-extern TFtype __mulkf3 (TFtype, TFtype);\n-extern TFtype __divkf3 (TFtype, TFtype);\n-extern TFtype __negkf2 (TFtype);\n-extern CMPtype __eqkf2 (TFtype, TFtype);\n-extern CMPtype __nekf2 (TFtype, TFtype);\n-extern CMPtype __gekf2 (TFtype, TFtype);\n-extern CMPtype __gtkf2 (TFtype, TFtype);\n-extern CMPtype __lekf2 (TFtype, TFtype);\n-extern CMPtype __ltkf2 (TFtype, TFtype);\n-extern CMPtype __unordkf2 (TFtype, TFtype);\n-extern TFtype __extendsfkf2 (float);\n-extern TFtype __extenddfkf2 (double);\n-extern float __trunckfsf2 (TFtype);\n-extern double __trunckfdf2 (TFtype);\n-extern SItype_ppc __fixkfsi (TFtype);\n-extern DItype_ppc __fixkfdi (TFtype);\n-extern USItype_ppc __fixunskfsi (TFtype);\n-extern UDItype_ppc __fixunskfdi (TFtype);\n-extern TFtype __floatsikf (SItype_ppc);\n-extern TFtype __floatdikf (DItype_ppc);\n-extern TFtype __floatunsikf (USItype_ppc);\n-extern TFtype __floatundikf (UDItype_ppc);\n-extern __ibm128 __extendkftf2 (TFtype);\n-extern TFtype __trunctfkf2 (__ibm128);\n-\n-#ifdef __LITTLE_ENDIAN__\n-#define HIGH_WORD\t1\n-#define LOW_WORD\t0\n-#else\n-#define HIGH_WORD\t0\n-#define LOW_WORD\t1\n-#endif\n-\n-/* Implementation of conversions between __ibm128 and __float128, to allow the\n-   same code to be used on systems with IEEE 128-bit emulation and with IEEE\n-   128-bit hardware support.  */\n-\n-#define CVT_FLOAT128_TO_IBM128(RESULT, VALUE)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  double __high, __low;\t\t\t\t\t\t\t\\\n-  __float128 __value = (VALUE);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  __high = (double) __value;\t\t\t\t\t\t\\\n-  if (__builtin_isnan (__high) || __builtin_isinf (__high))\t\t\\\n-    __low = 0.0;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      double __high_temp;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      __low = (double) (__value - (__float128) __high);\t\t\t\\\n-      /* Renormalize low/high and move them into canonical IBM long\t\\\n-\t double form.  */\t\t\t\t\t\t\\\n-      __high_temp = __high + __low;\t\t\t\t\t\\\n-      __low = (__high - __high_temp) + __low;\t\t\t\t\\\n-      __high = __high_temp;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  RESULT = __builtin_pack_ibm128 (__high, __low);\t\t\t\\\n-}\n-\n-#define CVT_IBM128_TO_FLOAT128(RESULT, VALUE)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  __ibm128 __value = (VALUE);\t\t\t\t\t\t\\\n-  double __high = __builtin_unpack_ibm128 (__value, HIGH_WORD);\t\t\\\n-  double __low = __builtin_unpack_ibm128 (__value, LOW_WORD);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* Handle the special cases of NAN and infinity.  */\t\t\t\\\n-  if (__builtin_isnan (__high) || __builtin_isinf (__high))\t\t\\\n-    RESULT = (__float128) __high;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* If low is 0.0, there no need to do the add.  In addition,\t\t\\\n-     avoiding the add produces the correct sign if high is -0.0.  */\t\\\n-  else if (__low == 0.0)\t\t\t\t\t\t\\\n-    RESULT = (__float128) __high;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    RESULT = ((__float128) __high) + ((__float128) __low);\t\t\\\n-}"}, {"sha": "efd21da53205d7f677e694b5970826a5cf6ea5c3", "filename": "libgcc/config/rs6000/sfp-exceptions.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Fsfp-exceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Fsfp-exceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fsfp-exceptions.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,72 +0,0 @@\n-/* Copyright (C) 2016 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 3, or (at your option) any\n-   later version.\n-\n-   This file is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"sfp-machine.h\"\n-\n-/* Only provide exception support if we have hardware floating point and we can\n-   execute the mtfsf instruction.  This would only be true if we are using the\n-   emulation routines for IEEE 128-bit floating point on pre-ISA 3.0 machines\n-   without the IEEE 128-bit floating point support.  */\n-\n-#ifndef __NO_FPRS__ \n-\n-void\n-__sfp_handle_exceptions (int _fex)\n-{\n-  const double fp_max = __DBL_MAX__;\n-  const double fp_min = __DBL_MIN__;\n-  const double fp_zero = (double) 0.0;\n-  const double fp_one = 1.0;\n-  double tmp;\n-\n-  if (_fex & FP_EX_INVALID)\n-    {\n-      __asm__ __volatile__ (\"fdiv %0, %1, %1\"\n-\t\t\t    : \"=f\" (tmp)\n-\t\t\t    : \"f\" (fp_zero));\n-    }\n-  if (_fex & FP_EX_DIVZERO)\n-    {\n-      __asm__ __volatile__ (\"fdiv %0, %1, %2\"\n-\t\t\t    : \"=f\" (tmp)\n-\t\t\t    : \"f\" (fp_one), \"f\" (fp_zero));\n-    }\n-  if (_fex & FP_EX_OVERFLOW)\n-    {\n-      __asm__ __volatile__ (\"fadd %0, %1, %1\"\n-\t\t\t    : \"=f\" (tmp)\n-\t\t\t    : \"f\" (fp_max));\n-    }\n-  if (_fex & FP_EX_UNDERFLOW)\n-    {\n-      __asm__ __volatile__ (\"fmul %0, %1, %1\"\n-\t\t\t    : \"=f\" (tmp)\n-\t\t\t    : \"f\" (fp_min));\n-    }\n-  if (_fex & FP_EX_INEXACT)\n-    {\n-      __asm__ __volatile__ (\"fsub %0, %1, %2\"\n-\t\t\t    : \"=f\" (tmp)\n-\t\t\t    : \"f\" (fp_max), \"f\" (fp_one));\n-    }\n-}\n-\n-#endif\t/* !__NO_FPRS__   */"}, {"sha": "40436337ffbb8818ae657ef80d893e95cd5ab661", "filename": "libgcc/config/rs6000/sfp-machine.h", "status": "modified", "additions": 3, "deletions": 91, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfig%2Frs6000%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfig%2Frs6000%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fsfp-machine.h?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -1,26 +1,7 @@\n-/* Decide whether to use 64 or 32-bit types to do the emulation.  If we are\n-   doing IEEE-128 with VSX, use 64-bit emulation even if we are compiling for a\n-   32-bit target.  */\n-\n-#if defined(_ARCH_PPC64) || defined(__VSX__) || defined(__FLOAT128__)\n-#define _FP_W_TYPE_SIZE\t\t64\n-#define _FP_W_TYPE\t\tunsigned long long\n-#define _FP_WS_TYPE\t\tsigned long long\n-#define _FP_I_TYPE\t\tlong long\n-\n-#ifdef _ARCH_PPC64\n-typedef int TItype __attribute__ ((mode (TI)));\n-typedef unsigned int UTItype __attribute__ ((mode (TI)));\n-\n-#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n-#endif\n-\n-#else\t/* 32-bits  */\n #define _FP_W_TYPE_SIZE\t\t32\n-#define _FP_W_TYPE\t\tunsigned int\n-#define _FP_WS_TYPE\t\tsigned int\n-#define _FP_I_TYPE\t\tint\n-#endif\t/* 32-bits  */\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n \n /* The type of the result of a floating point comparison.  This must\n    match `__libgcc_cmp_return__' in GCC for the target.  */\n@@ -29,39 +10,18 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n \n #define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n-\n-#if (_FP_W_TYPE_SIZE==64)\n-#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n-#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n-#else\n #define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n #define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n-#endif\n \n #define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n-\n-#if (_FP_W_TYPE_SIZE==64)\n-#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_1_udiv(D,R,X,Y)\n-#define _FP_DIV_MEAT_Q(R,X,Y)   _FP_DIV_MEAT_2_udiv(Q,R,X,Y)\n-#else\n #define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n #define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n-#endif\n \n #define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n-\n-#if (_FP_W_TYPE_SIZE==64)\n-#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1)\n-#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1\n-#else\n #define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n #define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1\n-#endif\n-\n #define _FP_NANSIGN_S\t\t0\n #define _FP_NANSIGN_D\t\t0\n #define _FP_NANSIGN_Q\t\t0\n@@ -104,54 +64,6 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n # endif\n #endif\n \n-/* Only provide exception support if we have hardware floating point using\n-   floating point registers and we can execute the mtfsf instruction.  This\n-   would only be true if we are using the emulation routines for IEEE 128-bit\n-   floating point on pre-ISA 3.0 machines without the IEEE 128-bit floating\n-   point support.  */\n-\n-#ifndef ___NO_FPRS__\n-#define ISA_BIT(x) (1LL << (63 - x))\n-\n-/* Use the same bits of the FPSCR.  */\n-# define FP_EX_INVALID\t\tISA_BIT(34)\n-# define FP_EX_OVERFLOW\t\tISA_BIT(35)\n-# define FP_EX_UNDERFLOW\tISA_BIT(36)\n-# define FP_EX_DIVZERO\t\tISA_BIT(37)\n-# define FP_EX_INEXACT\t\tISA_BIT(38)\n-# define FP_EX_ALL\t\t(FP_EX_INVALID | FP_EX_OVERFLOW \t\\\n-\t\t\t\t | FP_EX_UNDERFLOW | FP_EX_DIVZERO\t\\\n-\t\t\t\t | FP_EX_INEXACT)\n-\n-void __sfp_handle_exceptions (int);\n-\n-# define FP_HANDLE_EXCEPTIONS\t\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    if (__builtin_expect (_fex, 0))\t\t\\\n-      __sfp_handle_exceptions (_fex);\t\t\\\n-  } while (0);\n-/* A set bit indicates an exception is masked and a clear bit indicates it is\n-   trapping.  */\n-# define FP_TRAPPING_EXCEPTIONS (~_fpscr & (FP_EX_ALL >> 22))\n-\n-# define FP_RND_NEAREST\t0x0\n-# define FP_RND_ZERO\t0x1\n-# define FP_RND_PINF\t0x2\n-# define FP_RND_MINF\t0x3\n-# define FP_RND_MASK\t0x3\n-\n-# define _FP_DECL_EX \\\n-  unsigned long long _fpscr __attribute__ ((unused)) = FP_RND_NEAREST\n-\n-#define FP_INIT_ROUNDMODE\t\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    __asm__ __volatile__ (\"mtfsf 255, %0\"\t\\\n-\t\t\t  :\t\t\t\\\n-\t\t\t  : \"f\" (_fpscr));\t\\\n-  } while (0)\n-\n-# define FP_ROUNDMODE\t(_fpscr & FP_RND_MASK)\n-#endif\t/* !__NO_FPRS__ */\n \n /* Define ALIASNAME as a strong alias for NAME.  */\n # define strong_alias(name, aliasname) _strong_alias(name, aliasname)"}, {"sha": "4145c57417492a80516818d464037814d280d0f4", "filename": "libgcc/config/rs6000/t-float128", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ft-float128", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ft-float128", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-float128?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,95 +0,0 @@\n-# Support for adding __float128 to the powerpc.\n-\n-# The standard 128-bit floating point support functions are TFmode.  Most\n-# PowerPC targets use a long double format that has a pair of doubles to give\n-# you more precision, but no extra expoenent range.  This long double format is\n-# mostly compatible with the format used by the IBM XL compilers.  Some of the\n-# names used by the IBM double-double format use TF in them, so we rename\n-# all of the functions provided for the new IEEE 128-bit support.\n-#\n-# We use the TF functions in soft-fp for 128-bit floating point support, using\n-# sed to transform the names in the files from TF names to KF names.\n-\n-# Emulator functions from the soft-fp directory\n-fp128_softfp_funcs\t= addkf3 subkf3 mulkf3 divkf3 negkf2 \\\n-\t\t\t  unordkf2 eqkf2 gekf2 lekf2 \\\n-\t\t\t  extendsfkf2 extenddfkf2 trunckfsf2 trunckfdf2 \\\n-\t\t\t  fixkfsi fixkfdi fixunskfsi fixunskfdi \\\n-\t\t\t  floatsikf floatdikf floatunsikf floatundikf\n-\n-fp128_softfp_src\t= $(addsuffix -sw.c,$(fp128_softfp_funcs))\n-fp128_softfp_static_obj\t= $(addsuffix -sw$(objext),$(fp128_softfp_funcs))\n-fp128_softfp_shared_obj\t= $(addsuffix -sw_s$(objext),$(fp128_softfp_funcs))\n-fp128_softfp_obj\t= $(fp128_softfp_static_obj) $(fp128_softfp_shared_obj)\n-\n-# New functions for software emulation\n-fp128_ppc_funcs\t\t= floattikf floatuntikf fixkfti fixunskfti \\\n-\t\t\t  extendkftf2-sw trunctfkf2-sw \\\n-\t\t\t  sfp-exceptions float128-ifunc\n-\n-fp128_ppc_src\t\t= $(addprefix $(srcdir)/config/rs6000/,$(addsuffix \\\n-\t\t\t\t.c,$(fp128_ppc_funcs)))\n-fp128_ppc_static_obj\t= $(addsuffix $(objext),$(fp128_ppc_funcs))\n-fp128_ppc_shared_obj\t= $(addsuffix _s$(objext),$(fp128_ppc_funcs))\n-fp128_ppc_obj\t\t= $(fp128_ppc_static_obj) $(fp128_ppc_shared_obj)\n-\n-# All functions\n-fp128_funcs\t\t= $(fp128_softfp_funcs) $(fp128_ppc_funcs) \\\n-\t\t\t  $(fp128_hw_funcs)\n-\n-fp128_src\t\t= $(fp128_softfp_src) $(fp128_ppc_src) \\\n-\t\t\t  $(fp128_hw_src)\n-\n-fp128_obj\t\t= $(fp128_softfp_obj) $(fp128_ppc_obj) \\\n-\t\t\t  $(fp128_hw_obj)\n-\n-fp128_sed\t\t= $(srcdir)/config/rs6000/float128-sed\n-fp128_dep\t\t= $(fp128_sed) $(srcdir)/config/rs6000/t-float128\n-\n-fp128_includes\t\t= $(srcdir)/soft-fp/double.h \\\n-\t\t\t  $(srcdir)/soft-fp/op-1.h \\\n-\t\t\t  $(srcdir)/soft-fp/op-4.h \\\n-\t\t\t  $(srcdir)/soft-fp/op-common.h \\\n-\t\t\t  $(srcdir)/soft-fp/single.h \\\n-\t\t\t  $(srcdir)/soft-fp/extended.h \\\n-\t\t\t  $(srcdir)/soft-fp/op-2.h \\\n-\t\t\t  $(srcdir)/soft-fp/op-8.h \\\n-\t\t\t  $(srcdir)/soft-fp/quad.h \\\n-\t\t\t  $(srcdir)/soft-fp/soft-fp.h\n-\n-# Build the emulator without ISA 3.0 hardware support.\n-FP128_CFLAGS_SW\t\t = -Wno-type-limits -mvsx -mfloat128 \\\n-\t\t\t   -mno-float128-hardware \\\n-\t\t\t   -I$(srcdir)/soft-fp \\\n-\t\t\t   -I$(srcdir)/config/rs6000 \\\n-\t\t\t   $(FLOAT128_HW_INSNS)\n-\n-$(fp128_softfp_obj)\t : INTERNAL_CFLAGS += $(FP128_CFLAGS_SW)\n-$(fp128_ppc_obj)\t : INTERNAL_CFLAGS += $(FP128_CFLAGS_SW)\n-$(fp128_obj)\t\t : $(fp128_includes)\n-$(fp128_obj)\t\t : $(srcdir)/config/rs6000/quad-float128.h\n-\n-$(fp128_softfp_src) : $(srcdir)/soft-fp/$(subst -sw,,$(subst kf,tf,$@)) $(fp128_dep)\n-\t@src=\"$(srcdir)/soft-fp/$(subst -sw,,$(subst kf,tf,$@))\"; \\\n-\techo \"Create $@\"; \\\n-\t(echo \"/* file created from $$src */\"; \\\n-\t echo; \\\n-\t sed -f $(fp128_sed) < $$src) > $@\n-\n-.PHONY: test clean-float128\n-\n-test:\n-\t@echo \"fp128_src:\"; \\\n-\tfor x in $(fp128_src); do echo \"    $$x\"; done; \\\n-\techo; \\\n-\techo \"fp128_obj:\"; \\\n-\tfor x in $(fp128_obj); do echo \"    $$x\"; done;\n-\n-clean-float128:\n-\trm -rf $(fp128_softfp_src)\n-\t@$(MULTICLEAN) multi-clean DO=clean-float128\n-\n-# For now, only put it in the static library\n-# LIB2ADD += $(fp128_src)\n-\n-LIB2ADD_ST += $(fp128_src)"}, {"sha": "daae802189dbfdf7d9fbcf3eaaab946febc54b39", "filename": "libgcc/config/rs6000/t-float128-hw", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,24 +0,0 @@\n-# Support for adding __float128 hardware support to the powerpc.\n-# Tell the float128 functions that the ISA 3.0 hardware support can\n-# be compiled it to be selected via IFUNC functions.\n-\n-FLOAT128_HW_INSNS\t= -DFLOAT128_HW_INSNS\n-\n-# New functions for hardware support\n-fp128_hw_funcs\t\t= float128-hw\n-fp128_hw_src\t\t= $(srcdir)/config/rs6000/float128-hw.c\n-fp128_hw_static_obj\t= float128-hw$(objext)\n-fp128_hw_shared_obj\t= float128-hw_s$(objext)\n-fp128_hw_obj\t\t= $(fp128_hw_static_obj) $(fp128_hw_shared_obj)\n-\n-# Build the hardware support functions with appropriate hardware support\n-FP128_CFLAGS_HW\t\t = -Wno-type-limits -mvsx -mfloat128 \\\n-\t\t\t   -mpower8-vector -mpower9-vector \\\n-\t\t\t   -mfloat128-hardware \\\n-\t\t\t   -I$(srcdir)/soft-fp \\\n-\t\t\t   -I$(srcdir)/config/rs6000 \\\n-\t\t\t   $(FLOAT128_HW_INSNS)\n-\n-$(fp128_hw_obj)\t\t : INTERNAL_CFLAGS += $(FP128_CFLAGS_HW)\n-$(fp128_hw_obj)\t\t : $(srcdir)/config/rs6000/t-float128-hw\n-"}, {"sha": "653866337f53c4b588e3eb82d638ea8ca6d96d65", "filename": "libgcc/config/rs6000/trunctfkf2-sw.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf73ed7b40cfd6dc0b41fa9a5781088e998a0001/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c?ref=cf73ed7b40cfd6dc0b41fa9a5781088e998a0001", "patch": "@@ -1,49 +0,0 @@\n-/* Software IEEE 128-bit floating-point emulation for PowerPC.\n-\n-   Copyright (C) 2016 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n-   Code is based on the main soft-fp library written by:\n-\tRichard Henderson (rth@cygnus.com) and\n-\tJakub Jelinek (jj@ultra.linux.cz).\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   In addition to the permissions in the GNU Lesser General Public\n-   License, the Free Software Foundation gives you unlimited\n-   permission to link the compiled version of this file into\n-   combinations with other programs, and to distribute those\n-   combinations without any restriction coming from the use of this\n-   file.  (The Lesser General Public License restrictions do apply in\n-   other respects; for example, they cover modification of the file,\n-   and distribution when not linked into a combine executable.)\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Convert IBM long double to IEEE 128-bit floating point.  */\n-\n-#ifdef __FLOAT128_HARDWARE__\n-#error \"This module must not be compiled with IEEE 128-bit hardware support\"\n-#endif\n-\n-#include \"soft-fp.h\"\n-#include \"quad-float128.h\"\n-\n-__float128\n-__trunctfkf2_sw (__ibm128 value)\n-{\n-  __float128 ret;\n-\n-  CVT_IBM128_TO_FLOAT128 (ret, value);\n-  return ret;\n-}"}, {"sha": "78708c7f407778d2b633fe538abbf61e2743f7d7", "filename": "libgcc/configure", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -4766,55 +4766,6 @@ esac\n ;;\n esac\n \n-case ${host} in\n-powerpc*-*-linux*)\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the PowerPC compiler can do __float128\" >&5\n-$as_echo_n \"checking whether the PowerPC compiler can do __float128... \" >&6; }\n-if test \"${libgcc_cv_powerpc_float128+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#pragma GCC target (\"vsx,float128\")\n-     __float128 add (__float128 *a) { return *a + *(a+1); }\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  libgcc_cv_powerpc_float128=yes\n-else\n-  libgcc_cv_powerpc_float128=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgcc_cv_powerpc_float128\" >&5\n-$as_echo \"$libgcc_cv_powerpc_float128\" >&6; }\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the PowerPC compiler can do hardware __float128\" >&5\n-$as_echo_n \"checking whether the PowerPC compiler can do hardware __float128... \" >&6; }\n-if test \"${libgcc_cv_powerpc_float128_hw+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#pragma GCC target (\"cpu=power9,float128,float128-hardware\")\n-     #include <sys/auxv.h>\n-     __float128 add (__float128 a, __float128 b)\n-     {\n-       __float128 ret;\n-       __asm__ (\"xsaddqp %0,%1,%2\" : \"=v\" (ret) : \"v\" (a), \"v\" (b));\n-       return ret;\n-     }\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  libgcc_cv_powerpc_float128_hw=yes\n-else\n-  libgcc_cv_powerpc_float128_hw=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgcc_cv_powerpc_float128_hw\" >&5\n-$as_echo \"$libgcc_cv_powerpc_float128_hw\" >&6; }\n-esac\n-\n # Collect host-machine-specific information.\n . ${srcdir}/config.host\n "}, {"sha": "9d831a769971954c58f8b85323d4ed697d5dfd5b", "filename": "libgcc/configure.ac", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006df05d5cc462545336d5a439afbf10732acd16/libgcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure.ac?ref=006df05d5cc462545336d5a439afbf10732acd16", "patch": "@@ -373,31 +373,6 @@ esac\n ;;\n esac\n \n-case ${host} in\n-powerpc*-*-linux*)\n-  AC_CACHE_CHECK([whether the PowerPC compiler can do __float128],\n-\t\t [libgcc_cv_powerpc_float128],\n-\t\t [AC_COMPILE_IFELSE(\n-    [#pragma GCC target (\"vsx,float128\")\n-     __float128 add (__float128 *a) { return *a + *(a+1); }],\n-    [libgcc_cv_powerpc_float128=yes],\n-    [libgcc_cv_powerpc_float128=no])])\n-\n-  AC_CACHE_CHECK([whether the PowerPC compiler can do hardware __float128],\n-\t\t [libgcc_cv_powerpc_float128_hw],\n-\t\t [AC_COMPILE_IFELSE(\n-    [#pragma GCC target (\"cpu=power9,float128,float128-hardware\")\n-     #include <sys/auxv.h>\n-     __float128 add (__float128 a, __float128 b)\n-     {\n-       __float128 ret;\n-       __asm__ (\"xsaddqp %0,%1,%2\" : \"=v\" (ret) : \"v\" (a), \"v\" (b));\n-       return ret;\n-     }],\n-    [libgcc_cv_powerpc_float128_hw=yes],\n-    [libgcc_cv_powerpc_float128_hw=no])])\n-esac\n-\n # Collect host-machine-specific information.\n . ${srcdir}/config.host\n "}]}