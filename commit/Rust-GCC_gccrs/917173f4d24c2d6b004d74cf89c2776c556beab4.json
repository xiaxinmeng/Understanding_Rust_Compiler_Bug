{"sha": "917173f4d24c2d6b004d74cf89c2776c556beab4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE3MTczZjRkMjRjMmQ2YjAwNGQ3NGNmODljMjc3NmM1NTZiZWFiNA==", "commit": {"author": {"name": "Archit Shah", "email": "ashah@redhat.com", "date": "2006-04-05T09:53:08Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2006-04-05T09:53:08Z"}, "message": "re PR libgcj/25414 (should update rmic)\n\n2006-04-05  Archit Shah  <ashah@redhat.com>\n\n        PR java/25414\n        * gnu/java/rmi/rmic/CompilerProcess.java (computeTypicalArguments):\n        Add classpath argument.\n        * gnu/java/rmi/rmic/Compile_gcj.java (computeArguments): Adjust\n        caller.\n        * gnu/java/rmi/rmic/Compile_jikes.java (computeArguments): Likewise.\n        * gnu/java/rmi/rmic/Compile_kjc.java (computeArguments): Likewise.\n        * gnu/java/rmi/rmic/Compiler.java (getClasspath, setClasspath): New.\n        * gnu/java/rmi/rmic/RMIC.java: Set classpath for compiler, call\n        mkdirs for destination directory, correct handling of superclasses\n        and interfaces of the remote class, correct handling of exceptions\n        declared by remote methods.\n\nFrom-SVN: r112699", "tree": {"sha": "1fb2f0f405b16b7bd558d6735496d8532b5b84d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fb2f0f405b16b7bd558d6735496d8532b5b84d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/917173f4d24c2d6b004d74cf89c2776c556beab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917173f4d24c2d6b004d74cf89c2776c556beab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917173f4d24c2d6b004d74cf89c2776c556beab4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917173f4d24c2d6b004d74cf89c2776c556beab4/comments", "author": null, "committer": null, "parents": [{"sha": "6eee98936968c67edc8d9190b215819498840b57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eee98936968c67edc8d9190b215819498840b57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eee98936968c67edc8d9190b215819498840b57"}], "stats": {"total": 383, "additions": 293, "deletions": 90}, "files": [{"sha": "0134d2a2a72d801adcea0bb7d305dd3669d77a8c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=917173f4d24c2d6b004d74cf89c2776c556beab4", "patch": "@@ -1,3 +1,18 @@\n+2006-04-05  Archit Shah  <ashah@redhat.com>\n+\n+\tPR java/25414\n+\t* gnu/java/rmi/rmic/CompilerProcess.java (computeTypicalArguments):\n+\tAdd classpath argument.\n+\t* gnu/java/rmi/rmic/Compile_gcj.java (computeArguments): Adjust\n+\tcaller.\n+\t* gnu/java/rmi/rmic/Compile_jikes.java (computeArguments): Likewise.\n+\t* gnu/java/rmi/rmic/Compile_kjc.java (computeArguments): Likewise.\n+\t* gnu/java/rmi/rmic/Compiler.java (getClasspath, setClasspath): New.\n+\t* gnu/java/rmi/rmic/RMIC.java: Set classpath for compiler, call\n+\tmkdirs for destination directory, correct handling of superclasses\n+\tand interfaces of the remote class, correct handling of exceptions\n+\tdeclared by remote methods.\n+\n 2006-04-04  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/26990:"}, {"sha": "e22611bb3ad49ba6ddf712bec30ee530032f9f0d", "filename": "libjava/gnu/java/rmi/rmic/Compile_gcj.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_gcj.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_gcj.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_gcj.java?ref=917173f4d24c2d6b004d74cf89c2776c556beab4", "patch": "@@ -49,6 +49,7 @@ public class Compile_gcj extends CompilerProcess\n   public String[] computeArguments (String filename)\n   {\n     return computeTypicalArguments(COMPILER_ARGS,\n+                                   getClasspath(),\n \t\t\t\t   getDestination(),\n \t\t\t\t   filename);\n   }"}, {"sha": "e70b50c910bbd87033eab6480afd143b15180974", "filename": "libjava/gnu/java/rmi/rmic/Compile_jikes.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_jikes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_jikes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_jikes.java?ref=917173f4d24c2d6b004d74cf89c2776c556beab4", "patch": "@@ -50,6 +50,7 @@ public class Compile_jikes extends CompilerProcess\n   public String[] computeArguments (String filename)\r\n   {\r\n     return computeTypicalArguments(COMPILER_ARGS,\r\n+\t\t\t\t   getClasspath(),\r\n \t\t\t\t   getDestination(),\r\n \t\t\t\t   filename);\r\n   }\r"}, {"sha": "79f1a845c36308a83174f50c1e88a71bf869d5fd", "filename": "libjava/gnu/java/rmi/rmic/Compile_kjc.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_kjc.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_kjc.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_kjc.java?ref=917173f4d24c2d6b004d74cf89c2776c556beab4", "patch": "@@ -50,6 +50,7 @@ public class Compile_kjc extends CompilerProcess\n   public String[] computeArguments (String filename)\r\n   {\r\n     return computeTypicalArguments(COMPILER_ARGS,\r\n+\t\t\t\t   getClasspath(),\r\n \t\t\t\t   getDestination(),\r\n \t\t\t\t   filename);\r\n   }\r"}, {"sha": "fc1f8464fa64a0280fbbee3d16f2cd1c070ecc1b", "filename": "libjava/gnu/java/rmi/rmic/Compiler.java", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompiler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompiler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompiler.java?ref=917173f4d24c2d6b004d74cf89c2776c556beab4", "patch": "@@ -82,12 +82,27 @@ public void setDestination (String dest)\n     this.dest = dest;\n   }\n \n+   /** Get the classpath for compilation.  */\n+   public String getClasspath ()\n+   {\n+     return classpath;\n+   }\n+\n+  /** Set the classpath for compilation.  */\n+  public void setClasspath (String classpath)\n+  {\n+    this.classpath = classpath;\n+  }\n+\n   /** Compile the given file.  Throws exception on error.  */\n   public abstract void compile (String name) throws Exception;\n \n   /** The destination directory, or null if none set.  */\n   protected String dest;\n \n+  /** The classpath directory, or null if none set.  */\n+  private String classpath;\n+\n   /** Class prefix used when trying to find instance.  */\n   private static final String classPrefix = \"gnu.java.rmi.rmic.Compile_\";\n }"}, {"sha": "d7b299876636d24b77f18f991b86d8d87f4a53b6", "filename": "libjava/gnu/java/rmi/rmic/CompilerProcess.java", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompilerProcess.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompilerProcess.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompilerProcess.java?ref=917173f4d24c2d6b004d74cf89c2776c556beab4", "patch": "@@ -58,24 +58,47 @@ public abstract class CompilerProcess extends Compiler\n     */\n    public static String[] computeTypicalArguments(String[] compilerArgs,\n \tString destination, String filename)\n+   {\n+     return computeTypicalArguments(compilerArgs, null, destination, filename);\n+   }\n+   /**\n+    * This is used to compute the command line for the process.\n+    * Most compilers typically arrange their arguments as in\n+    * &lt;compiler name and arguments&gt; &lt;optional destination&gt; &lt;filename&gt;.\n+    * This method builds an argument array out that. It should be used\n+    * to define computeArguments for those compilers that follow the\n+    * argument convention described above.\n+    */\n+   public static String[] computeTypicalArguments(String[] compilerArgs,\n+                                                  String classpath,\n+                                                  String destination,\n+                                                  String filename)\n    {\n      /* length of compiler specific arguments */\n-     final int len = compilerArgs.length;\n+     int len = compilerArgs.length;\n \n      /* length of returned array of arguments */\n-     final int arglen = len + (destination == null ? 0 : 2) + 1;\n+     final int arglen = len + (classpath == null ? 0 : 2) +\n+       (destination == null ? 0 : 2) + 1;\n \n      /* Allocate String array for computed arguments. */\n      String [] args = new String[arglen];\n \n      /* Fill in compiler arguments. */\n      System.arraycopy(compilerArgs, 0, args, 0, len);\n \n+     /* Fill in classpath argument if necessary. */\n+     if (classpath != null)\n+       {\n+         args[len++] = \"-classpath\";\n+         args[len++] = classpath;\n+       }\n+\n      /* Fill in destination argument if necessary. */\n      if (destination != null)\n       {\n-\targs[len] = \"-d\";\n-\targs[len + 1] = destination;\n+\targs[len++] = \"-d\";\n+\targs[len++] = destination;\n       }\n \n      /* Fill in filename */"}, {"sha": "33ec9935b6246fb746cd306d80ba267a5eaae8cf", "filename": "libjava/gnu/java/rmi/rmic/RMIC.java", "status": "modified", "additions": 233, "deletions": 86, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917173f4d24c2d6b004d74cf89c2776c556beab4/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java?ref=917173f4d24c2d6b004d74cf89c2776c556beab4", "patch": "@@ -46,11 +46,18 @@\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.rmi.Remote;\n import java.rmi.RemoteException;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Set;\n+import java.util.StringTokenizer;\n \n \n public class RMIC\n@@ -69,11 +76,15 @@\n   private Class clazz;\n   private String classname;\n   private String fullclassname;\n+  private String fullstubname;\n+  private String fullskelname;\n   private MethodRef[] remotemethods;\n   private String stubname;\n   private String skelname;\n+  private ClassLoader loader;\n+  private String classpath;\n   private int errorCount = 0;\n-  private Class mRemoteInterface;\n+  private List mRemoteInterfaces;\n \n   public RMIC(String[] a)\n   {\n@@ -115,27 +126,39 @@ public boolean run()\n     return (true);\n   }\n \n-  private boolean processClass(String classname) throws Exception\n+  private boolean processClass(String cls) throws Exception\n   {\n+    // reset class specific vars\n+    clazz = null;\n+    classname = null;\n+    fullclassname = null;\n+    remotemethods = null;\n+    stubname = null;\n+    fullstubname = null;\n+    skelname = null;\n+    fullskelname = null;\n+    mRemoteInterfaces = new ArrayList();\n+\n     errorCount = 0;\n-    analyzeClass(classname);\n+\n+    analyzeClass(cls);\n+\n     if (errorCount > 0)\n       System.exit(1);\n     generateStub();\n     if (need11Stubs)\n       generateSkel();\n     if (compile)\n       {\n-\tcompile(stubname.replace('.', File.separatorChar) + \".java\");\n+\tcompile(fullstubname);\n \tif (need11Stubs)\n-\t  compile(skelname.replace('.', File.separatorChar) + \".java\");\n+\t  compile(fullskelname);\n       }\n     if (! keep)\n       {\n-\t(new File(stubname.replace('.', File.separatorChar) + \".java\")).delete();\n+\t(new File(fullstubname)).delete();\n \tif (need11Stubs)\n-\t  (new File(skelname.replace('.', File.separatorChar) + \".java\"))\n-\t  .delete();\n+\t  (new File(fullskelname)).delete();\n       }\n     return (true);\n   }\n@@ -151,40 +174,8 @@ private void analyzeClass(String cname) throws Exception\n       classname = cname;\n     fullclassname = cname;\n \n-    HashSet rmeths = new HashSet();\n     findClass();\n-\n-    // get the remote interface\n-    mRemoteInterface = getRemoteInterface(clazz);\n-    if (mRemoteInterface == null)\n-      return;\n-    if (verbose)\n-      System.out.println(\"[implements \" + mRemoteInterface.getName() + \"]\");\n-\n-    // check if the methods of the remote interface declare RemoteExceptions\n-    Method[] meths = mRemoteInterface.getDeclaredMethods();\n-    for (int i = 0; i < meths.length; i++)\n-      {\n-\tClass[] exceptions = meths[i].getExceptionTypes();\n-\tint index = 0;\n-\tfor (; index < exceptions.length; index++)\n-\t  {\n-\t    if (exceptions[index].equals(RemoteException.class))\n-\t      break;\n-\t  }\n-\tif (index < exceptions.length)\n-\t  rmeths.add(meths[i]);\n-\telse\n-\t  logError(\"Method \" + meths[i]\n-\t           + \" does not throw a java.rmi.RemoteException\");\n-      }\n-\n-    // Convert into a MethodRef array and sort them\n-    remotemethods = new MethodRef[rmeths.size()];\n-    int c = 0;\n-    for (Iterator i = rmeths.iterator(); i.hasNext();)\n-      remotemethods[c++] = new MethodRef((Method) i.next());\n-    Arrays.sort(remotemethods);\n+    findRemoteMethods();\n   }\n \n   public Exception getException()\n@@ -194,21 +185,42 @@ public Exception getException()\n \n   private void findClass() throws ClassNotFoundException\n   {\n-    clazz =\n-      Class.forName(fullclassname, true, ClassLoader.getSystemClassLoader());\n+    try\n+      {\n+        ClassLoader cl = (loader == null\n+                          ? ClassLoader.getSystemClassLoader()\n+                          : loader);\n+        clazz = Class.forName(fullclassname, false, cl);\n+      }\n+    catch (ClassNotFoundException cnfe)\n+      {\n+        System.err.println(fullclassname + \" not found in \" + classpath);\n+        throw new RuntimeException(cnfe);\n+      }\n+\n+    if (! Remote.class.isAssignableFrom(clazz))\n+      {\n+        logError(\"Class \" + clazz.getName() + \" is not a remote object. \"\n+                 + \"It does not implement an interface that is a \"\n+                 + \"java.rmi.Remote-interface.\");\n+        throw new RuntimeException\n+          (\"Class \" + clazz.getName() + \" is not a remote object. \"\n+           + \"It does not implement an interface that is a \"\n+           + \"java.rmi.Remote-interface.\");\n+      }\n   }\n \n   private void generateStub() throws IOException\n   {\n     stubname = fullclassname + \"_Stub\";\n     String stubclassname = classname + \"_Stub\";\n+    fullstubname = (destination == null ? \"\" : destination + File.separator)\n+      + stubname.replace('.', File.separatorChar) + \".java\";\n+    File file = new File(fullstubname);\n+    if (file.getParentFile() != null)\n+      file.getParentFile().mkdirs();\n     ctrl =\n-      new TabbedWriter(new FileWriter((destination == null ? \"\"\n-                                                           : destination\n-                                                           + File.separator)\n-                                      + stubname.replace('.',\n-                                                         File.separatorChar)\n-                                      + \".java\"));\n+      new TabbedWriter(new FileWriter(file));\n     out = new PrintWriter(ctrl);\n \n     if (verbose)\n@@ -230,16 +242,7 @@ private void generateStub() throws IOException\n \n     // Output interfaces we implement\n     out.print(\"implements \");\n-    /* Scan implemented interfaces, and only print remote interfaces. */\n-    Class[] ifaces = clazz.getInterfaces();\n-    Set remoteIfaces = new HashSet();\n-    for (int i = 0; i < ifaces.length; i++)\n-      {\n-\tClass iface = ifaces[i];\n-\tif (java.rmi.Remote.class.isAssignableFrom(iface))\n-\t  remoteIfaces.add(iface);\n-      }\n-    Iterator iter = remoteIfaces.iterator();\n+    Iterator iter = mRemoteInterfaces.iterator();\n     while (iter.hasNext())\n       {\n \t/* Print remote interface. */\n@@ -328,7 +331,7 @@ private void generateStub() throws IOException\n \t  {\n \t    Method m = remotemethods[i].meth;\n \t    out.print(\"$method_\" + m.getName() + \"_\" + i + \" = \");\n-\t    out.print(mRemoteInterface.getName() + \".class.getMethod(\\\"\"\n+\t    out.print(m.getDeclaringClass().getName() + \".class.getMethod(\\\"\"\n \t              + m.getName() + \"\\\"\");\n \t    out.print(\", new java.lang.Class[] {\");\n \t    // Output signature\n@@ -631,13 +634,13 @@ private void generateSkel() throws IOException\n   {\n     skelname = fullclassname + \"_Skel\";\n     String skelclassname = classname + \"_Skel\";\n+    fullskelname = (destination == null ? \"\" : destination + File.separator)\n+      + skelname.replace('.', File.separatorChar) + \".java\";\n+    File file = new File(fullskelname);\n+    if (file.getParentFile() != null)\n+      file.getParentFile().mkdirs();\n     ctrl =\n-      new TabbedWriter(new FileWriter((destination == null ? \"\"\n-                                                           : destination\n-                                                           + File.separator)\n-                                      + skelname.replace('.',\n-                                                         File.separatorChar)\n-                                      + \".java\"));\n+      new TabbedWriter(new FileWriter(file));\n     out = new PrintWriter(ctrl);\n \n     if (verbose)\n@@ -882,6 +885,8 @@ private void compile(String name) throws Exception\n     if (verbose)\n       System.out.println(\"[Compiling class \" + name + \"]\");\n     comp.setDestination(destination);\n+    if (classpath != null)\n+      comp.setClasspath(classpath);\n     comp.compile(name);\n   }\n \n@@ -970,7 +975,27 @@ else if (arg.equals(\"-verbose\"))\n \telse if (arg.equals(\"-nocompile\"))\n \t  compile = false;\n \telse if (arg.equals(\"-classpath\"))\n-\t  next++;\n+          {\n+            classpath = args[next];\n+            next++;\n+            StringTokenizer st =\n+              new StringTokenizer(classpath, File.pathSeparator);\n+            URL[] u = new URL[st.countTokens()];\n+            for (int i = 0; i < u.length; i++)\n+              {\n+                String path = st.nextToken();\n+                File f = new File(path);\n+                try\n+                  {\n+                    u[i] = f.toURL();\n+                  }\n+                catch (MalformedURLException mue)\n+                  {\n+                    error(\"malformed classpath component \" + path);\n+                  }\n+              }\n+            loader = new URLClassLoader(u);\n+          }\n \telse if (arg.equals(\"-help\"))\n \t  usage();\n \telse if (arg.equals(\"-version\"))\n@@ -996,22 +1021,75 @@ else if (arg.charAt(1) == 'J')\n       }\n   }\n \n-/**\n- * Looks for the java.rmi.Remote interface that that is implemented by theClazz.\n- * @param theClazz the class to look in\n- * @return the Remote interface of theClazz or null if theClazz does not implement a Remote interface\n- */\n-  private Class getRemoteInterface(Class theClazz)\n-  {\n-    Class[] interfaces = theClazz.getInterfaces();\n-    for (int i = 0; i < interfaces.length; i++)\n+  private void findRemoteMethods() {\n+    List rmeths = new ArrayList();\n+    for (Class cur = clazz; cur != null; cur = cur.getSuperclass())\n+      {\n+        Class[] interfaces = cur.getInterfaces();\n+        for (int i = 0; i < interfaces.length; i++)\n+          {\n+            if (java.rmi.Remote.class.isAssignableFrom(interfaces[i]))\n+              {\n+                Class remoteInterface = interfaces[i];\n+                if (verbose)\n+                  System.out.println\n+                    (\"[implements \" + remoteInterface.getName() + \"]\");\n+\n+                // check if the methods declare RemoteExceptions\n+                Method[] meths = remoteInterface.getMethods();\n+                for (int j = 0; j < meths.length; j++)\n+                  {\n+                    Method m = meths[j];\n+                    Class[] exs = m.getExceptionTypes();\n+\n+                    boolean throwsRemote = false;\n+                    for (int k = 0; k < exs.length; k++)\n+                      {\n+                        if (exs[k].isAssignableFrom(RemoteException.class))\n+                          throwsRemote = true;\n+                      }\n+\n+                    if (! throwsRemote)\n+                      {\n+                        logError(\"Method \" + m\n+                                 + \" does not throw a RemoteException\");\n+                        continue;\n+                      }\n+\n+                    rmeths.add(m);\n+                  }\n+\n+                mRemoteInterfaces.add(remoteInterface);\n+              }\n+          }\n+      }\n+\n+    // intersect exceptions for doubly inherited methods\n+    boolean[] skip = new boolean[rmeths.size()];\n+    for (int i = 0; i < skip.length; i++)\n+      skip[i] = false;\n+    List methrefs = new ArrayList();\n+    for (int i = 0; i < rmeths.size(); i++)\n       {\n-\tif (java.rmi.Remote.class.isAssignableFrom(interfaces[i]))\n-\t  return interfaces[i];\n+        if (skip[i]) continue;\n+        Method current = (Method) rmeths.get(i);\n+        MethodRef ref = new MethodRef(current);\n+        for (int j = i+1; j < rmeths.size(); j++)\n+          {\n+            Method other = (Method) rmeths.get(j);\n+            if (ref.isMatch(other))\n+              {\n+                ref.intersectExceptions(other);\n+                skip[j] = true;\n+              }\n+          }\n+        methrefs.add(ref);\n       }\n-    logError(\"Class \" + theClazz.getName()\n-             + \" is not a remote object. It does not implement an interface that is a java.rmi.Remote-interface.\");\n-    return null;\n+\n+    // Convert into a MethodRef array and sort them\n+    remotemethods = (MethodRef[])\n+      methrefs.toArray(new MethodRef[methrefs.size()]);\n+    Arrays.sort(remotemethods);\n   }\n \n /**\n@@ -1054,25 +1132,94 @@ private static void usage()\n     System.exit(0);\n   }\n \n-  static class MethodRef\n+  private static class MethodRef\n     implements Comparable\n   {\n     Method meth;\n-    String sig;\n     long hash;\n+    List exceptions;\n+    private String sig;\n \n     MethodRef(Method m)\n     {\n       meth = m;\n-      // We match on the name - but what about overloading? - XXX\n-      sig = m.getName();\n+      sig = m.getName(); // XXX should be full signature used to compute hash\n       hash = RMIHashes.getMethodHash(m);\n+      // add exceptions removing subclasses\n+      exceptions = removeSubclasses(m.getExceptionTypes());\n     }\n \n     public int compareTo(Object obj)\n     {\n       MethodRef that = (MethodRef) obj;\n-      return (this.sig.compareTo(that.sig));\n+      int name = this.meth.getName().compareTo(that.meth.getName());\n+      if (name == 0) {\n+        return this.sig.compareTo(that.sig);\n+      }\n+      return name;\n+    }\n+\n+    public boolean isMatch(Method m)\n+    {\n+      if (!meth.getName().equals(m.getName()))\n+        return false;\n+\n+      Class[] params1 = meth.getParameterTypes();\n+      Class[] params2 = m.getParameterTypes();\n+      if (params1.length != params2.length)\n+        return false;\n+\n+      for (int i = 0; i < params1.length; i++)\n+        if (!params1[i].equals(params2[i])) return false;\n+\n+      return true;\n+    }\n+\n+    private static List removeSubclasses(Class[] classes)\n+    {\n+      List list = new ArrayList();\n+      for (int i = 0; i < classes.length; i++)\n+        {\n+          Class candidate = classes[i];\n+          boolean add = true;\n+          for (int j = 0; j < classes.length; j++)\n+            {\n+              if (classes[j].equals(candidate))\n+                continue;\n+              else if (classes[j].isAssignableFrom(candidate))\n+                add = false;\n+            }\n+          if (add) list.add(candidate);\n+        }\n+\n+      return list;\n+    }\n+\n+    public void intersectExceptions(Method m)\n+    {\n+      List incoming = removeSubclasses(m.getExceptionTypes());\n+\n+      List updated = new ArrayList();\n+\n+      for (int i = 0; i < exceptions.size(); i++)\n+        {\n+          Class outer = (Class) exceptions.get(i);\n+          boolean addOuter = false;\n+          for (int j = 0; j < incoming.size(); j++)\n+            {\n+              Class inner = (Class) incoming.get(j);\n+\n+              if (inner.equals(outer) || inner.isAssignableFrom(outer))\n+                addOuter = true;\n+              else if (outer.isAssignableFrom(inner))\n+                updated.add(inner);\n+            }\n+\n+          if (addOuter)\n+            updated.add(outer);\n+        }\n+\n+      exceptions = updated;\n     }\n   }\n }"}]}