{"sha": "653cc74afc6785458eee2791fde774fb23ec3d8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzY2M3NGFmYzY3ODU0NThlZWUyNzkxZmRlNzc0ZmIyM2VjM2Q4Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-09-25T18:56:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-25T18:56:40Z"}, "message": "Handle multi-level typenames and implicit typename in base list.\n\n\t* parse.y (typename_sub{,[0-2]}): New rules.\n\t(structsp, rule TYPENAME_KEYWORD): Use typename_sub.\n\t(nonnested_type): New rule.\n\t(complete_type_name): Use it.\n\t(base_class.1): Use typename_sub and nonnested_type.\n\t(nested_name_specifier): Don't elide std:: here.\n\t* decl.c (make_typename_type): Handle getting a type for NAME.\n\t(lookup_name_real): Turn std:: into :: here.\n\n\tRvalue conversions were removed in London.\n\t* call.c (is_subseq): Don't consider lvalue transformations.\n\t(build_conv): LVALUE_CONV and RVALUE_CONV get IDENTITY_RANK.\n\t(joust): Reenable ?: kludge.\n\nFrom-SVN: r15715", "tree": {"sha": "0e2ab47b18732e9a6b88e92e405a180726d99a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e2ab47b18732e9a6b88e92e405a180726d99a24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/653cc74afc6785458eee2791fde774fb23ec3d8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653cc74afc6785458eee2791fde774fb23ec3d8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/653cc74afc6785458eee2791fde774fb23ec3d8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653cc74afc6785458eee2791fde774fb23ec3d8f/comments", "author": null, "committer": null, "parents": [{"sha": "6d4312ddbf30f452fd9c93254e0be63c4fcbda9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4312ddbf30f452fd9c93254e0be63c4fcbda9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d4312ddbf30f452fd9c93254e0be63c4fcbda9a"}], "stats": {"total": 129, "additions": 104, "deletions": 25}, "files": [{"sha": "c5e34ac4b241d513a2461b4e45b2351d4360af70", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=653cc74afc6785458eee2791fde774fb23ec3d8f", "patch": "@@ -1,3 +1,20 @@\n+Thu Sep 25 11:11:13 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tHandle multi-level typenames and implicit typename in base list.\n+\t* parse.y (typename_sub{,[0-2]}): New rules.\n+\t(structsp, rule TYPENAME_KEYWORD): Use typename_sub.\n+\t(nonnested_type): New rule.\n+\t(complete_type_name): Use it.\n+\t(base_class.1): Use typename_sub and nonnested_type.\n+\t(nested_name_specifier): Don't elide std:: here.\n+\t* decl.c (make_typename_type): Handle getting a type for NAME.\n+\t(lookup_name_real): Turn std:: into :: here.\n+\n+\tRvalue conversions were removed in London.\n+\t* call.c (is_subseq): Don't consider lvalue transformations.\n+\t(build_conv): LVALUE_CONV and RVALUE_CONV get IDENTITY_RANK.\n+\t(joust): Reenable ?: kludge.\n+\n 1997-09-22  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* decl.c (start_function): Up warning of no return type to be a"}, {"sha": "6855181cef4c50ecea13a381973bf740bbf8a49b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=653cc74afc6785458eee2791fde774fb23ec3d8f", "patch": "@@ -3021,9 +3021,7 @@ build_conv (code, type, from)\n \trank = STD_RANK;\n       break;\n \n-    case LVALUE_CONV:\n     case QUAL_CONV:\n-    case RVALUE_CONV:\n       if (rank < EXACT_RANK)\n \trank = EXACT_RANK;\n \n@@ -5649,6 +5647,11 @@ static int\n is_subseq (ics1, ics2)\n      tree ics1, ics2;\n {\n+  /* Do not consider lvalue transformations here.  */\n+  if (TREE_CODE (ics2) == RVALUE_CONV\n+      || TREE_CODE (ics2) == LVALUE_CONV)\n+    return 0;\n+\n   for (;; ics2 = TREE_OPERAND (ics2, 0))\n     {\n       if (TREE_CODE (ics2) == TREE_CODE (ics1)\n@@ -6084,10 +6087,10 @@ joust (cand1, cand2)\n \t  break;\n       if (i == TREE_VEC_LENGTH (cand1->convs))\n \treturn 1;\n-#if 0\n+\n       /* Kludge around broken overloading rules whereby\n-\t bool ? void *const & : void *const & is ambiguous.  */\n-      /* Huh?  Explain the problem better.  */\n+\t Integer a, b; test ? a : b; is ambiguous, since there's a builtin\n+\t that takes references and another that takes values.  */\n       if (cand1->fn == ansi_opname[COND_EXPR])\n \t{\n \t  tree c1 = TREE_VEC_ELT (cand1->convs, 1);\n@@ -6103,7 +6106,6 @@ joust (cand1, cand2)\n \t\treturn -1;\n \t    }\n \t}\n-#endif\n     }\n \n tweak:"}, {"sha": "df8066b107805c3f2927153fdec6b6bdeaf14081", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=653cc74afc6785458eee2791fde774fb23ec3d8f", "patch": "@@ -4317,7 +4317,9 @@ make_typename_type (context, name)\n {\n   tree t, d;\n \n-  if (TREE_CODE (name) == TYPE_DECL)\n+  if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+    name = TYPE_IDENTIFIER (name);\n+  else if (TREE_CODE (name) == TYPE_DECL)\n     name = DECL_NAME (name);\n   else if (TREE_CODE (name) != IDENTIFIER_NODE)\n     my_friendly_abort (2000);\n@@ -4378,6 +4380,10 @@ lookup_name_real (name, prefer_type, nonclass)\n       yylex = 1;\n       prefer_type = looking_for_typename;\n \n+      /* std:: becomes :: for now.  */\n+      if (got_scope == std_node)\n+\tgot_scope = void_type_node;\n+\n       if (got_scope)\n \ttype = got_scope;\n       else if (got_object != error_mark_node)"}, {"sha": "16e5db9916035adf5fcf6c65118b691451023962", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 72, "deletions": 18, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653cc74afc6785458eee2791fde774fb23ec3d8f/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=653cc74afc6785458eee2791fde774fb23ec3d8f", "patch": "@@ -258,12 +258,12 @@ empty_parms ()\n %type <ttype> template_type template_arg_list template_arg\n %type <ttype> condition xcond paren_cond_or_null\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n-%type <ttype> complete_type_name notype_identifier\n+%type <ttype> complete_type_name notype_identifier nonnested_type\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n %type <ttype> new_initializer new_placement\n %type <ttype> using_decl .poplevel\n-\n+%type <ttype> typename_sub typename_sub0 typename_sub1 typename_sub2\n /* in order to recognize aggr tags as defining and thus shadowing.  */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n %type <ttype> named_class_head_sans_basetype_defn\n@@ -2190,11 +2190,8 @@ structsp:\n \t| ENUM complex_type_name\n \t\t{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); \n \t\t  $$.new_type_flag = 0; }\n-\t| TYPENAME_KEYWORD nested_name_specifier identifier\n-\t\t{ $$.t = make_typename_type ($2, $3); \n-\t\t  $$.new_type_flag = 0; }\n-\t| TYPENAME_KEYWORD global_scope nested_name_specifier identifier\n-\t\t{ $$.t = make_typename_type ($3, $4); \n+\t| TYPENAME_KEYWORD typename_sub\n+\t\t{ $$.t = $2;\n \t\t  $$.new_type_flag = 0; }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly opt.component_decl_list '}' maybe_attribute\n@@ -2437,11 +2434,8 @@ base_class:\n \t;\n \n base_class.1:\n-\t  complete_type_name\n-\t| TYPENAME_KEYWORD nested_name_specifier identifier\n-\t\t{ $$ = TYPE_MAIN_DECL (make_typename_type ($2, $3)); }\n-\t| TYPENAME_KEYWORD global_scope nested_name_specifier identifier\n-\t\t{ $$ = TYPE_MAIN_DECL (make_typename_type ($3, $4)); }\n+\t  typename_sub\n+\t| nonnested_type\n \t| SIGOF '(' expr ')'\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n@@ -2945,7 +2939,7 @@ after_type_declarator:\n \t| direct_after_type_declarator\n \t;\n \n-complete_type_name:\n+nonnested_type:\n \t  type_name  %prec EMPTY\n \t\t{\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n@@ -2974,6 +2968,10 @@ complete_type_name:\n \t\t    $$ = $2;\n \t\t  got_scope = NULL_TREE;\n \t\t}\n+\t;\n+\n+complete_type_name:\n+\t  nonnested_type\n \t| nested_type\n \t| global_scope nested_type\n \t\t{ $$ = $2; }\n@@ -3119,11 +3117,7 @@ nested_name_specifier_1:\n \t\t{\n \t\t  if (TREE_CODE ($$) == IDENTIFIER_NODE)\n \t\t    $$ = lastiddecl;\n-\t\t  if (TREE_CODE ($$) == NAMESPACE_DECL\n-\t\t      && DECL_NAME ($$) == get_identifier (\"std\"))\n-\t\t    got_scope = void_type_node;\n-\t\t  else\n-\t\t    got_scope = $$;\n+\t\t  got_scope = $$;\n \t\t}\n \t| template_type SCOPE\n \t\t{ got_scope = $$ = complete_type (TREE_TYPE ($1)); }\n@@ -3139,6 +3133,66 @@ nested_name_specifier_1:\n \t\t{ goto failed_scope; } */\n \t;\n \n+typename_sub:\n+\t  typename_sub0\n+\t| global_scope typename_sub0\n+\t\t{ $$ = $2; }\n+\t;\n+\n+typename_sub0:\n+\t  typename_sub1 identifier\n+\t\t{\n+\t\t  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')\n+\t\t    $$ = make_typename_type ($1, $2);\n+\t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n+\t\t    cp_error (\"`%T' is not a class or namespace\", $2);\n+\t\t  else\n+\t\t    $$ = $2;\n+\t\t}\n+\t;\n+\n+typename_sub1:\n+\t  typename_sub2\n+\t\t{\n+\t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n+\t\t    cp_error (\"`%T' is not a class or namespace\", $1);\n+\t\t}\n+\t| typename_sub1 typename_sub2\n+\t\t{\n+\t\t  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')\n+\t\t    $$ = make_typename_type ($1, $2);\n+\t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n+\t\t    cp_error (\"`%T' is not a class or namespace\", $2);\n+\t\t  else\n+\t\t    $$ = $2;\n+\t\t}\n+\t;\n+\n+typename_sub2:\n+\t  TYPENAME SCOPE\n+\t\t{\n+\t\t  if (TREE_CODE ($1) != IDENTIFIER_NODE)\n+\t\t    $$ = lastiddecl;\n+\t\t  got_scope = $$ = complete_type (TREE_TYPE ($$));\n+\t\t}\n+\t| SELFNAME SCOPE\n+\t\t{\n+\t\t  if (TREE_CODE ($1) != IDENTIFIER_NODE)\n+\t\t    $$ = lastiddecl;\n+\t\t  got_scope = $$ = complete_type (TREE_TYPE ($$));\n+\t\t}\n+\t| template_type SCOPE\n+\t\t{ got_scope = $$ = complete_type (TREE_TYPE ($$)); }\n+\t| PTYPENAME SCOPE\n+\t| IDENTIFIER SCOPE\n+\t| NSNAME SCOPE\n+\t\t{\n+\t\t  if (TREE_CODE ($$) == IDENTIFIER_NODE)\n+\t\t    $$ = lastiddecl;\n+\t\t  got_scope = $$;\n+\t\t}\n+\t;\n+\n complex_type_name:\n \t  global_scope type_name\n \t\t{"}]}