{"sha": "677cc14d2d379a47a489cbbe14380983efe36884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc3Y2MxNGQyZDM3OWE0N2E0ODljYmJlMTQzODA5ODNlZmUzNjg4NA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-01-31T13:50:06Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-31T13:50:06Z"}, "message": "cfgloop.h: Include vec-prim.h.\n\n\t* cfgloop.h: Include vec-prim.h.\n\t(enum li_flags): Remove LI_ONLY_OLD.\n\t(loop_iterator): Changed.\n\t(fel_next, fel_init): Iterate over loop tree.\n\t(FOR_EACH_LOOP_BREAK): New macro.\n\t* loop-unswitch.c (unswitch_loops): Do not pass LI_ONLY_OLD to\n\tFOR_EACH_LOOP.\n\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops): Ditto.\n\t* modulo-sched.c (sms_schedule): Ditto.\n\t* tree-vectorizer.c (vectorize_loops): Ditto.\n\t* doc/loop.texi: Update information on loop numbering and behavior of\n\tFOR_EACH_LOOP wrto new loops.\n\t* tree-scalar-evolution.c (compute_overall_effect_of_inner_loop,\n\tadd_to_evolution_1): Test nestedness of loops instead of comparing\n\ttheir numbers.\n\t* tree-chrec.c (chrec_fold_plus_poly_poly,\n\tchrec_fold_multiply_poly_poly, chrec_evaluate,\n\thide_evolution_in_other_loops_than_loop, chrec_component_in_loop_num,\n\treset_evolution_in_loop): Ditto.\n\t* Makefile.in (CFGLOOP_H): Add vecprim.h dependency.\n\nFrom-SVN: r121422", "tree": {"sha": "946e9668080a203091ce6a81aea398fc4b6ce57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/946e9668080a203091ce6a81aea398fc4b6ce57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/677cc14d2d379a47a489cbbe14380983efe36884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677cc14d2d379a47a489cbbe14380983efe36884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/677cc14d2d379a47a489cbbe14380983efe36884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677cc14d2d379a47a489cbbe14380983efe36884/comments", "author": null, "committer": null, "parents": [{"sha": "e7917d06e81b8ec0b763bd479861cb60e029bbb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7917d06e81b8ec0b763bd479861cb60e029bbb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7917d06e81b8ec0b763bd479861cb60e029bbb9"}], "stats": {"total": 250, "additions": 178, "deletions": 72}, "files": [{"sha": "78f2b6e841343c07830a1fb9202738e59a115eba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -1,3 +1,26 @@\n+2007-01-31  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* cfgloop.h: Include vec-prim.h.\n+\t(enum li_flags): Remove LI_ONLY_OLD.\n+\t(loop_iterator): Changed.\n+\t(fel_next, fel_init): Iterate over loop tree.\n+\t(FOR_EACH_LOOP_BREAK): New macro.\n+\t* loop-unswitch.c (unswitch_loops): Do not pass LI_ONLY_OLD to\n+\tFOR_EACH_LOOP.\n+\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops): Ditto.\n+\t* modulo-sched.c (sms_schedule): Ditto.\n+\t* tree-vectorizer.c (vectorize_loops): Ditto.\n+\t* doc/loop.texi: Update information on loop numbering and behavior of\n+\tFOR_EACH_LOOP wrto new loops.\n+\t* tree-scalar-evolution.c (compute_overall_effect_of_inner_loop,\n+\tadd_to_evolution_1): Test nestedness of loops instead of comparing\n+\ttheir numbers.\n+\t* tree-chrec.c (chrec_fold_plus_poly_poly,\n+\tchrec_fold_multiply_poly_poly, chrec_evaluate,\n+\thide_evolution_in_other_loops_than_loop, chrec_component_in_loop_num,\n+\treset_evolution_in_loop): Ditto.\n+\t* Makefile.in (CFGLOOP_H): Add vecprim.h dependency.\n+\n 2007-01-31  Dirk Mueller  <dmueller@suse.de>\n \n \t* c-common.c (warn_about_parentheses): Separate warning about"}, {"sha": "f5cc3a8f590913b5e48e5aab843662133f4e7c3b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -749,7 +749,7 @@ RESOURCE_H = resource.h hard-reg-set.h\n SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H)\n INTEGRATE_H = integrate.h $(VARRAY_H)\n CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)\n-CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H)\n+CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H) vecprim.h\n IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H) \n IPA_REFERENCE_H = ipa-reference.h bitmap.h $(TREE_H)  \n IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)  "}, {"sha": "4223a39c45f31db08b8bc877db75b3d3045d55a8", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 86, "deletions": 42, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"basic-block.h\"\n /* For rtx_code.  */\n #include \"rtl.h\"\n+#include \"vecprim.h\"\n \n /* Structure to hold decision about unrolling/peeling.  */\n enum lpt_dec\n@@ -425,84 +426,127 @@ number_of_loops (void)\n \n enum li_flags\n {\n-  LI_INCLUDE_ROOT = 1,\t/* Include the fake root of the loop tree.  */\n-  LI_FROM_INNERMOST = 2,/* Iterate over the loops in the reverse order,\n-\t\t\t   starting from innermost ones.  */\n-  LI_ONLY_INNERMOST = 4,/* Iterate only over innermost loops.  */\n-  LI_ONLY_OLD = 8\t/* Do not traverse the loops created during the\n-\t\t\t   traversal (this is the default behavior with\n-\t\t\t   LI_FROM_INNERMOST).  */\n+  LI_INCLUDE_ROOT = 1,\t\t/* Include the fake root of the loop tree.  */\n+  LI_FROM_INNERMOST = 2,\t/* Iterate over the loops in the reverse order,\n+\t\t\t\t   starting from innermost ones.  */\n+  LI_ONLY_INNERMOST = 4\t\t/* Iterate only over innermost loops.  */\n };\n \n /* The iterator for loops.  */\n \n typedef struct\n {\n-  int idx;\t\t/* Index of the actual loop.  */\n-  int end;\t\t/* Only loops before end should be traversed.  */\n+  /* The list of loops to visit.  */\n+  VEC(int,heap) *to_visit;\n+\n+  /* The index of the actual loop.  */\n+  unsigned idx;\n } loop_iterator;\n \n static inline void\n-fel_next (loop_iterator *li, loop_p *loop, unsigned flags)\n+fel_next (loop_iterator *li, loop_p *loop)\n {\n-  if (flags & LI_FROM_INNERMOST)\n-    {\n-      li->idx--;\n-      for (; li->idx > li->end; li->idx--)\n-\t{\n-\t  *loop = VEC_index (loop_p, current_loops->larray, li->idx);\n-\t  if (*loop\n-\t      && (!(flags & LI_ONLY_INNERMOST)\n-\t\t  || (*loop)->inner == NULL))\n-\t    return;\n-\t}\n-    }\n-  else\n+  int anum;\n+\n+  while (VEC_iterate (int, li->to_visit, li->idx, anum))\n     {\n-      if (!(flags & LI_ONLY_OLD))\n-\tli->end = number_of_loops ();\n       li->idx++;\n-      for (; li->idx < li->end; li->idx++)\n-\t{\n-\t  *loop = VEC_index (loop_p, current_loops->larray, li->idx);\n-\t  if (*loop\n-\t      && (!(flags & LI_ONLY_INNERMOST)\n-\t\t  || (*loop)->inner == NULL))\n-\t    return;\n-\t}\n+      *loop = get_loop (anum);\n+      if (*loop)\n+\treturn;\n     }\n \n+  VEC_free (int, heap, li->to_visit);\n   *loop = NULL;\n }\n \n static inline void\n fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n {\n+  struct loop *aloop;\n+  unsigned i;\n+  int mn;\n+\n+  li->idx = 0;\n   if (!current_loops)\n     {\n-      li->idx = 0;\n-      li->end = 0;\n+      li->to_visit = NULL;\n       *loop = NULL;\n       return;\n     }\n \n-  if (flags & LI_FROM_INNERMOST)\n+  li->to_visit = VEC_alloc (int, heap, number_of_loops ());\n+  mn = (flags & LI_INCLUDE_ROOT) ? 0 : 1;\n+\n+  if (flags & LI_ONLY_INNERMOST)\n+    {\n+      for (i = 0; VEC_iterate (loop_p, current_loops->larray, i, aloop); i++)\n+\tif (aloop != NULL\n+\t    && aloop->inner == NULL\n+\t    && aloop->num >= mn)\n+\t  VEC_quick_push (int, li->to_visit, aloop->num);\n+    }\n+  else if (flags & LI_FROM_INNERMOST)\n     {\n-      li->idx = number_of_loops ();\n-      li->end = (flags & LI_INCLUDE_ROOT) ? -1 : 0;\n+      /* Push the loops to LI->TO_VISIT in postorder.  */\n+      for (aloop = current_loops->tree_root;\n+\t   aloop->inner != NULL;\n+\t   aloop = aloop->inner)\n+\tcontinue;\n+\n+      while (1)\n+\t{\n+\t  if (aloop->num >= mn)\n+\t    VEC_quick_push (int, li->to_visit, aloop->num);\n+\n+\t  if (aloop->next)\n+\t    {\n+\t      for (aloop = aloop->next;\n+\t\t   aloop->inner != NULL;\n+\t\t   aloop = aloop->inner)\n+\t\tcontinue;\n+\t    }\n+\t  else if (!aloop->outer)\n+\t    break;\n+\t  else\n+\t    aloop = aloop->outer;\n+\t}\n     }\n   else\n     {\n-      li->idx = (flags & LI_INCLUDE_ROOT) ? -1 : 0;\n-      li->end = number_of_loops ();\n+      /* Push the loops to LI->TO_VISIT in preorder.  */\n+      aloop = current_loops->tree_root;\n+      while (1)\n+\t{\n+\t  if (aloop->num >= mn)\n+\t    VEC_quick_push (int, li->to_visit, aloop->num);\n+\n+\t  if (aloop->inner != NULL)\n+\t    aloop = aloop->inner;\n+\t  else\n+\t    {\n+\t      while (aloop != NULL && aloop->next == NULL)\n+\t\taloop = aloop->outer;\n+\t      if (aloop == NULL)\n+\t\tbreak;\n+\t      aloop = aloop->next;\n+\t    }\n+\t}\n     }\n-  fel_next (li, loop, flags);\n+\n+  fel_next (li, loop);\n }\n \n #define FOR_EACH_LOOP(LI, LOOP, FLAGS) \\\n   for (fel_init (&(LI), &(LOOP), FLAGS); \\\n        (LOOP); \\\n-       fel_next (&(LI), &(LOOP), FLAGS))\n+       fel_next (&(LI), &(LOOP)))\n+\n+#define FOR_EACH_LOOP_BREAK(LI) \\\n+  { \\\n+    VEC_free (int, heap, (LI)->to_visit); \\\n+    break; \\\n+  }\n \n /* The properties of the target.  */\n "}, {"sha": "e486b0c5d10ad68e09698c5657cf761157b0a9c1", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -64,17 +64,24 @@ function.  Each of the loops is represented in a @code{struct loop}\n structure.  Each loop is assigned an index (@code{num} field of the\n @code{struct loop} structure), and the pointer to the loop is stored in\n the corresponding field of the @code{larray} vector in the loops\n-structure.  Index of a sub-loop is always greater than the index of its\n-super-loop.  The indices do not have to be continuous, there may be\n+structure.  The indices do not have to be continuous, there may be\n empty (@code{NULL}) entries in the @code{larray} created by deleting\n-loops.  The index of a loop never changes.\n+loops.  Also, there is no guarantee on the relative order of a loop\n+and its subloops in the numbering.  The index of a loop never changes.\n \n The entries of the @code{larray} field should not be accessed directly.\n The function @code{get_loop} returns the loop description for a loop with\n the given index.  @code{number_of_loops} function returns number of\n loops in the function.  To traverse all loops, use @code{FOR_EACH_LOOP}\n macro.  The @code{flags} argument of the macro is used to determine\n-the direction of traversal and the set of loops visited.\n+the direction of traversal and the set of loops visited.  Each loop is\n+guaranteed to be visited exactly once, regardless of the changes to the\n+loop tree, and the loops may be removed during the traversal.  The newly\n+created loops are never traversed, if they need to be visited, this\n+must be done separately after their creation.  The @code{FOR_EACH_LOOP}\n+macro allocates temporary variables.  If the @code{FOR_EACH_LOOP} loop\n+were ended using break or goto, they would not be released;\n+@code{FOR_EACH_LOOP_BREAK} macro must be used instead.\n \n Each basic block contains the reference to the innermost loop it belongs\n to (@code{loop_father}).  For this reason, it is only possible to have"}, {"sha": "8eb21d6ec2b8036ee71df7f65100dd01587e87b8", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -143,7 +143,7 @@ unswitch_loops (void)\n \n   /* Go through inner loops (only original ones).  */\n \n-  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD | LI_ONLY_INNERMOST)\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n     {\n       unswitch_single_loop (loop, NULL_RTX, 0);\n #ifdef ENABLE_CHECKING"}, {"sha": "228c3f985cc63eccdabe9353e4eeba7de6ead895", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -1028,7 +1028,7 @@ sms_schedule (void)\n   df = NULL;\n \n   /* We don't want to perform SMS on new loops - created by versioning.  */\n-  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n       rtx head, tail;\n       rtx count_reg, count_init;"}, {"sha": "ae95fc8c49606e4fdda785aa7882be9989207e18", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -99,6 +99,8 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n \t\t\t   tree poly1)\n {\n   tree left, right;\n+  struct loop *loop0 = get_chrec_loop (poly0);\n+  struct loop *loop1 = get_chrec_loop (poly1);\n \n   gcc_assert (poly0);\n   gcc_assert (poly1);\n@@ -111,7 +113,7 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n     {a, +, b}_1 + {c, +, d}_2  ->  {{a, +, b}_1 + c, +, d}_2,\n     {a, +, b}_2 + {c, +, d}_1  ->  {{c, +, d}_1 + a, +, b}_2,\n     {a, +, b}_x + {c, +, d}_x  ->  {a+c, +, b+d}_x.  */\n-  if (CHREC_VARIABLE (poly0) < CHREC_VARIABLE (poly1))\n+  if (flow_loop_nested_p (loop0, loop1))\n     {\n       if (code == PLUS_EXPR)\n \treturn build_polynomial_chrec \n@@ -128,7 +130,7 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n \t\t\t\t: build_int_cst_type (type, -1)));\n     }\n   \n-  if (CHREC_VARIABLE (poly0) > CHREC_VARIABLE (poly1))\n+  if (flow_loop_nested_p (loop1, loop0))\n     {\n       if (code == PLUS_EXPR)\n \treturn build_polynomial_chrec \n@@ -141,7 +143,11 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n \t   chrec_fold_minus (type, CHREC_LEFT (poly0), poly1),\n \t   CHREC_RIGHT (poly0));\n     }\n-  \n+ \n+  /* This function should never be called for chrecs of loops that\n+     do not belong to the same loop nest.  */\n+  gcc_assert (loop0 == loop1);\n+\n   if (code == PLUS_EXPR)\n     {\n       left = chrec_fold_plus \n@@ -175,6 +181,8 @@ chrec_fold_multiply_poly_poly (tree type,\n {\n   tree t0, t1, t2;\n   int var;\n+  struct loop *loop0 = get_chrec_loop (poly0);\n+  struct loop *loop1 = get_chrec_loop (poly1);\n \n   gcc_assert (poly0);\n   gcc_assert (poly1);\n@@ -186,20 +194,22 @@ chrec_fold_multiply_poly_poly (tree type,\n   /* {a, +, b}_1 * {c, +, d}_2  ->  {c*{a, +, b}_1, +, d}_2,\n      {a, +, b}_2 * {c, +, d}_1  ->  {a*{c, +, d}_1, +, b}_2,\n      {a, +, b}_x * {c, +, d}_x  ->  {a*c, +, a*d + b*c + b*d, +, 2*b*d}_x.  */\n-  if (CHREC_VARIABLE (poly0) < CHREC_VARIABLE (poly1))\n+  if (flow_loop_nested_p (loop0, loop1))\n     /* poly0 is a constant wrt. poly1.  */\n     return build_polynomial_chrec \n       (CHREC_VARIABLE (poly1), \n        chrec_fold_multiply (type, CHREC_LEFT (poly1), poly0),\n        CHREC_RIGHT (poly1));\n   \n-  if (CHREC_VARIABLE (poly1) < CHREC_VARIABLE (poly0))\n+  if (flow_loop_nested_p (loop1, loop0))\n     /* poly1 is a constant wrt. poly0.  */\n     return build_polynomial_chrec \n       (CHREC_VARIABLE (poly0), \n        chrec_fold_multiply (type, CHREC_LEFT (poly0), poly1),\n        CHREC_RIGHT (poly0));\n-  \n+ \n+  gcc_assert (loop0 == loop1);\n+\n   /* poly0 and poly1 are two polynomials in the same variable,\n      {a, +, b}_x * {c, +, d}_x  ->  {a*c, +, a*d + b*c + b*d, +, 2*b*d}_x.  */\n       \n@@ -492,9 +502,10 @@ chrec_evaluate (unsigned var, tree chrec, tree n, unsigned int k)\n {\n   tree arg0, arg1, binomial_n_k;\n   tree type = TREE_TYPE (chrec);\n+  struct loop *var_loop = get_loop (var);\n \n   while (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n-\t && CHREC_VARIABLE (chrec) > var)\n+\t && flow_loop_nested_p (var_loop, get_chrec_loop (chrec)))\n     chrec = CHREC_LEFT (chrec);\n \n   if (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n@@ -631,26 +642,32 @@ tree\n hide_evolution_in_other_loops_than_loop (tree chrec, \n \t\t\t\t\t unsigned loop_num)\n {\n+  struct loop *loop = get_loop (loop_num), *chloop;\n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n   \n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      if (CHREC_VARIABLE (chrec) == loop_num)\n+      chloop = get_chrec_loop (chrec);\n+\n+      if (chloop == loop)\n \treturn build_polynomial_chrec \n \t  (loop_num, \n \t   hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec), \n \t\t\t\t\t\t    loop_num), \n \t   CHREC_RIGHT (chrec));\n       \n-      else if (CHREC_VARIABLE (chrec) < loop_num)\n+      else if (flow_loop_nested_p (chloop, loop))\n \t/* There is no evolution in this loop.  */\n \treturn initial_condition (chrec);\n       \n       else\n-\treturn hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec), \n-\t\t\t\t\t\t\tloop_num);\n+\t{\n+\t  gcc_assert (flow_loop_nested_p (loop, chloop));\n+\t  return hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec), \n+\t\t\t\t\t\t\t  loop_num);\n+\t}\n       \n     default:\n       return chrec;\n@@ -666,14 +683,17 @@ chrec_component_in_loop_num (tree chrec,\n \t\t\t     bool right)\n {\n   tree component;\n+  struct loop *loop = get_loop (loop_num), *chloop;\n \n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n   \n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      if (CHREC_VARIABLE (chrec) == loop_num)\n+      chloop = get_chrec_loop (chrec);\n+\n+      if (chloop == loop)\n \t{\n \t  if (right)\n \t    component = CHREC_RIGHT (chrec);\n@@ -693,14 +713,17 @@ chrec_component_in_loop_num (tree chrec,\n \t       component);\n \t}\n       \n-      else if (CHREC_VARIABLE (chrec) < loop_num)\n+      else if (flow_loop_nested_p (chloop, loop))\n \t/* There is no evolution part in this loop.  */\n \treturn NULL_TREE;\n       \n       else\n-\treturn chrec_component_in_loop_num (CHREC_LEFT (chrec), \n-\t\t\t\t\t    loop_num, \n-\t\t\t\t\t    right);\n+\t{\n+\t  gcc_assert (flow_loop_nested_p (loop, chloop));\n+\t  return chrec_component_in_loop_num (CHREC_LEFT (chrec), \n+\t\t\t\t\t      loop_num, \n+\t\t\t\t\t      right);\n+\t}\n       \n      default:\n       if (right)\n@@ -742,10 +765,12 @@ reset_evolution_in_loop (unsigned loop_num,\n \t\t\t tree chrec, \n \t\t\t tree new_evol)\n {\n+  struct loop *loop = get_loop (loop_num);\n+\n   gcc_assert (chrec_type (chrec) == chrec_type (new_evol));\n \n   if (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n-      && CHREC_VARIABLE (chrec) > loop_num)\n+      && flow_loop_nested_p (loop, get_chrec_loop (chrec)))\n     {\n       tree left = reset_evolution_in_loop (loop_num, CHREC_LEFT (chrec),\n \t\t\t\t\t   new_evol);"}, {"sha": "43a5e27ddba01df415849bf6e705909665775a0a", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -465,9 +465,11 @@ compute_overall_effect_of_inner_loop (struct loop *loop, tree evolution_fn)\n \n   else if (TREE_CODE (evolution_fn) == POLYNOMIAL_CHREC)\n     {\n-      if (CHREC_VARIABLE (evolution_fn) >= (unsigned) loop->num)\n+      struct loop *inner_loop = get_chrec_loop (evolution_fn);\n+\n+      if (inner_loop == loop\n+\t  || flow_loop_nested_p (loop, inner_loop))\n \t{\n-\t  struct loop *inner_loop = get_chrec_loop (evolution_fn);\n \t  tree nb_iter = number_of_latch_executions (inner_loop);\n \n \t  if (nb_iter == chrec_dont_know)\n@@ -646,18 +648,21 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \t\t    tree at_stmt)\n {\n   tree type, left, right;\n+  struct loop *loop = get_loop (loop_nb), *chloop;\n \n   switch (TREE_CODE (chrec_before))\n     {\n     case POLYNOMIAL_CHREC:\n-      if (CHREC_VARIABLE (chrec_before) <= loop_nb)\n+      chloop = get_chrec_loop (chrec_before);\n+      if (chloop == loop\n+\t  || flow_loop_nested_p (chloop, loop))\n \t{\n \t  unsigned var;\n \n \t  type = chrec_type (chrec_before);\n \t  \n \t  /* When there is no evolution part in this loop, build it.  */\n-\t  if (CHREC_VARIABLE (chrec_before) < loop_nb)\n+\t  if (chloop != loop)\n \t    {\n \t      var = loop_nb;\n \t      left = chrec_before;\n@@ -679,6 +684,8 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \t}\n       else\n \t{\n+\t  gcc_assert (flow_loop_nested_p (loop, chloop));\n+\n \t  /* Search the evolution in LOOP_NB.  */\n \t  left = add_to_evolution_1 (loop_nb, CHREC_LEFT (chrec_before),\n \t\t\t\t     to_add, at_stmt);"}, {"sha": "b9bd3724ba9a1a79f09ffd16677b17d5f8b4bc89", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -88,7 +88,7 @@ tree_ssa_unswitch_loops (void)\n   bool changed = false;\n \n   /* Go through inner loops (only original ones).  */\n-  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD | LI_ONLY_INNERMOST)\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n     {\n       changed |= tree_unswitch_single_loop (loop, 0);\n     }"}, {"sha": "870163df754ede26733610ec3440c46137343548", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677cc14d2d379a47a489cbbe14380983efe36884/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=677cc14d2d379a47a489cbbe14380983efe36884", "patch": "@@ -2175,7 +2175,7 @@ vectorize_loops (void)\n      than all previously defined loops. This fact allows us to run \n      only over initial loops skipping newly generated ones.  */\n   vect_loops_num = number_of_loops ();\n-  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n       loop_vec_info loop_vinfo;\n "}]}