{"sha": "5ab9749e294898d1185384624f312ec32b4ba9f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFiOTc0OWUyOTQ4OThkMTE4NTM4NDYyNGYzMTJlYzMyYjRiYTlmMQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2008-12-04T10:11:50Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2008-12-04T10:11:50Z"}, "message": "stormy16.md: Remove extraneous spaces and quotes.\n\n        * config/stormy16/stormy16.md: Remove extraneous spaces and\n        quotes.\n        * config/stormy16/stormy16.c: Remove extraneous spaces and fix up\n        formatting of quotes.\n\nFrom-SVN: r142431", "tree": {"sha": "cdd14c4f8bc00c06f286058e0b39d4596bbb5065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdd14c4f8bc00c06f286058e0b39d4596bbb5065"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ab9749e294898d1185384624f312ec32b4ba9f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab9749e294898d1185384624f312ec32b4ba9f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab9749e294898d1185384624f312ec32b4ba9f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab9749e294898d1185384624f312ec32b4ba9f1/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5cf9684138627fae7433f862e80aaf0ddc8e2425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf9684138627fae7433f862e80aaf0ddc8e2425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cf9684138627fae7433f862e80aaf0ddc8e2425"}], "stats": {"total": 656, "additions": 336, "deletions": 320}, "files": [{"sha": "a887db195e1b80218592846e17b8794384484770", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ab9749e294898d1185384624f312ec32b4ba9f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ab9749e294898d1185384624f312ec32b4ba9f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ab9749e294898d1185384624f312ec32b4ba9f1", "patch": "@@ -1,3 +1,10 @@\n+2008-12-04  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/stormy16/stormy16.md: Remove extraneous spaces and\n+\tquotes.\n+\t* config/stormy16/stormy16.c: Remove extraneous spaces and fix up\n+\tformatting of quotes.\n+\n 2008-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/38371"}, {"sha": "343153d4a142eee88a52bb6163164bad1235dc38", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 216, "deletions": 203, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ab9749e294898d1185384624f312ec32b4ba9f1/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ab9749e294898d1185384624f312ec32b4ba9f1/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=5ab9749e294898d1185384624f312ec32b4ba9f1", "patch": "@@ -3,21 +3,21 @@\n    2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -91,7 +91,7 @@ xstormy16_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      *total = COSTS_N_INSNS(2);\n+      *total = COSTS_N_INSNS (2);\n       return true;\n \n     case MULT:\n@@ -120,7 +120,7 @@ xstormy16_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n       natively, so the appropriate pattern is emitted directly.\n \n    2. SImode EQ and NE.  These are emitted as pairs of HImode\n-      compare-and-branches.      \n+      compare-and-branches.\n \n    3. SImode LT, GE, LTU and GEU.  These are emitted as a sequence\n       of a SImode subtract followed by a branch (not a compare-and-branch),\n@@ -134,8 +134,7 @@ xstormy16_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n       sbc\n       blt\n       or\n-      bne\n-*/\n+      bne.  */\n \n /* Emit a branch of kind CODE to location LOC.  */\n \n@@ -147,7 +146,7 @@ xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n   rtx condition_rtx, loc_ref, branch, cy_clobber;\n   rtvec vec;\n   enum machine_mode mode;\n-  \n+\n   mode = GET_MODE (op0);\n   gcc_assert (mode == HImode || mode == SImode);\n \n@@ -157,7 +156,7 @@ xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n       int unsigned_p = (code == GTU || code == LEU);\n       int gt_p = (code == GT || code == GTU);\n       rtx lab = NULL_RTX;\n-      \n+\n       if (gt_p)\n \tlab = gen_label_rtx ();\n       xstormy16_emit_cbranch (unsigned_p ? LTU : LT, gt_p ? lab : loc);\n@@ -168,28 +167,28 @@ xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n \temit_label (lab);\n       return;\n     }\n-  else if (mode == SImode \n+  else if (mode == SImode\n \t   && (code == NE || code == EQ)\n \t   && op1 != const0_rtx)\n     {\n       rtx lab = NULL_RTX;\n       int num_words = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n       int i;\n-      \n+\n       if (code == EQ)\n \tlab = gen_label_rtx ();\n-      \n+\n       for (i = 0; i < num_words - 1; i++)\n \t{\n-\t  xstormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode, \n+\t  xstormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode,\n \t\t\t\t\t\t      i * UNITS_PER_WORD);\n-\t  xstormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode, \n+\t  xstormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode,\n \t\t\t\t\t\t      i * UNITS_PER_WORD);\n \t  xstormy16_emit_cbranch (NE, code == EQ ? lab : loc);\n \t}\n-      xstormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode, \n+      xstormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode,\n \t\t\t\t\t\t  i * UNITS_PER_WORD);\n-      xstormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode, \n+      xstormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode,\n \t\t\t\t\t\t  i * UNITS_PER_WORD);\n       xstormy16_emit_cbranch (code, loc);\n \n@@ -246,7 +245,7 @@ xstormy16_split_cbranch (enum machine_mode mode, rtx label, rtx comparison,\n   rtx op1 = XEXP (comparison, 1);\n   rtx seq, last_insn;\n   rtx compare;\n-  \n+\n   start_sequence ();\n   xstormy16_expand_arith (mode, COMPARE, dest, op0, op1);\n   seq = get_insns ();\n@@ -286,7 +285,7 @@ xstormy16_output_cbranch_hi (rtx op, const char *label, int reversed, rtx insn)\n   const char *templ;\n   const char *operands;\n   enum rtx_code code;\n-  \n+\n   if (! op)\n     {\n       if (need_longbranch)\n@@ -323,7 +322,7 @@ xstormy16_output_cbranch_hi (rtx op, const char *label, int reversed, rtx insn)\n     case LTU:  ccode = \"c\";   break;\n     case GTU:  ccode = \"hi\";  break;\n     case LEU:  ccode = \"ls\";  break;\n-      \n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -333,7 +332,7 @@ xstormy16_output_cbranch_hi (rtx op, const char *label, int reversed, rtx insn)\n   else\n     templ = \"b%s %s,%s\";\n   sprintf (string, templ, ccode, operands, label);\n-  \n+\n   return string;\n }\n \n@@ -357,7 +356,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n   const char *templ;\n   char prevop[16];\n   enum rtx_code code;\n-  \n+\n   code = GET_CODE (op);\n \n   /* Work out which way this really branches.  */\n@@ -383,9 +382,9 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n     case EQ: case NE:\n       {\n \tint regnum;\n-\t\n+\n \tgcc_assert (GET_CODE (XEXP (op, 0)) == REG);\n-      \n+\n \tregnum = REGNO (XEXP (op, 0));\n \tsprintf (prevop, \"or %s,%s\", reg_names[regnum], reg_names[regnum+1]);\n       }\n@@ -404,7 +403,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n   else\n     templ = \"%s | b%s %s\";\n   sprintf (string, templ, prevop, ccode, label);\n-  \n+\n   return string;\n }\n \f\n@@ -489,6 +488,7 @@ xstormy16_preferred_reload_class (rtx x, enum reg_class rclass)\n \n /* Predicate for symbols and addresses that reflect special 8-bit\n    addressing.  */\n+\n int\n xstormy16_below100_symbol (rtx x,\n \t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n@@ -514,6 +514,7 @@ xstormy16_below100_symbol (rtx x,\n \n /* Likewise, but only for non-volatile MEMs, for patterns where the\n    MEM will get split into smaller sized accesses.  */\n+\n int\n xstormy16_splittable_below100_operand (rtx x, enum machine_mode mode)\n {\n@@ -524,6 +525,7 @@ xstormy16_splittable_below100_operand (rtx x, enum machine_mode mode)\n \n /* Expand an 8-bit IOR.  This either detects the one case we can\n    actually do, or uses a 16-bit IOR.  */\n+\n void\n xstormy16_expand_iorqi3 (rtx *operands)\n {\n@@ -564,7 +566,9 @@ xstormy16_expand_iorqi3 (rtx *operands)\n     emit_move_insn (operands[0], out);\n }\n \n-/* Likewise, for AND.  */\n+/* Expand an 8-bit AND.  This either detects the one case we can\n+   actually do, or uses a 16-bit AND.  */\n+\n void\n xstormy16_expand_andqi3 (rtx *operands)\n {\n@@ -630,20 +634,20 @@ xstormy16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n       if (GET_CODE (x) == CONST_INT)\n \treturn 0;\n     }\n-  \n+\n   if ((GET_CODE (x) == PRE_MODIFY\n        && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT)\n       || GET_CODE (x) == POST_INC\n       || GET_CODE (x) == PRE_DEC)\n     x = XEXP (x, 0);\n-  \n+\n   if (GET_CODE (x) == REG && REGNO_OK_FOR_BASE_P (REGNO (x))\n       && (! strict || REGNO (x) < FIRST_PSEUDO_REGISTER))\n     return 1;\n \n   if (xstormy16_below100_symbol (x, mode))\n     return 1;\n-  \n+\n   return 0;\n }\n \n@@ -657,19 +661,20 @@ xstormy16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n    operand being addressed.  Some machines have other mode-dependent addresses.\n    Many RISC machines have no mode-dependent addresses.\n \n-   You may assume that ADDR is a valid address for the machine.  \n-   \n+   You may assume that ADDR is a valid address for the machine.\n+\n    On this chip, this is true if the address is valid with an offset\n    of 0 but not of 6, because in that case it cannot be used as an\n    address for DImode or DFmode, or if the address is a post-increment\n    or pre-decrement address.  */\n+\n int\n xstormy16_mode_dependent_address_p (rtx x)\n {\n   if (LEGITIMATE_ADDRESS_CONST_INT_P (x, 0)\n       && ! LEGITIMATE_ADDRESS_CONST_INT_P (x, 6))\n     return 1;\n-  \n+\n   if (GET_CODE (x) == PLUS\n       && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (x, 1), 0)\n       && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (x, 1), 6))\n@@ -679,7 +684,6 @@ xstormy16_mode_dependent_address_p (rtx x)\n     x = XEXP (x, 0);\n \n   /* Auto-increment addresses are now treated generically in recog.c.  */\n-\n   return 0;\n }\n \n@@ -690,6 +694,7 @@ xstormy16_mode_dependent_address_p (rtx x)\n    target machine, it should return 1 if VALUE corresponds to the operand type\n    represented by the constraint letter C.  If C is not defined as an extra\n    constraint, the value returned should be 0 regardless of VALUE.  */\n+\n int\n xstormy16_extra_constraint_p (rtx x, int c)\n {\n@@ -750,10 +755,9 @@ short_memory_operand (rtx x, enum machine_mode mode)\n    by hardware.  Emit insns to copy a value of mode MODE from SRC to\n    DEST.\n \n-   This function is only called when reload_completed.\n-   */\n+   This function is only called when reload_completed.  */\n \n-void \n+void\n xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n {\n   int num_words = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n@@ -764,7 +768,7 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n   int dest_volatile = 0;\n   rtx mem_operand;\n   rtx auto_inc_reg_rtx = NULL_RTX;\n-  \n+\n   /* Check initial conditions.  */\n   gcc_assert (reload_completed\n \t      && mode != QImode && mode != HImode\n@@ -779,14 +783,14 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \n   /* The general idea is to copy by words, offsetting the source and\n      destination.  Normally the least-significant word will be copied\n-     first, but for pre-dec operations it's better to copy the \n+     first, but for pre-dec operations it's better to copy the\n      most-significant word first.  Only one operand can be a pre-dec\n-     or post-inc operand.  \n+     or post-inc operand.\n \n      It's also possible that the copy overlaps so that the direction\n      must be reversed.  */\n   direction = 1;\n-  \n+\n   if (GET_CODE (dest) == MEM)\n     {\n       mem_operand = XEXP (dest, 0);\n@@ -825,20 +829,20 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \tdirection = -1;\n     }\n   else if (GET_CODE (mem_operand) == PRE_DEC\n-      || (GET_CODE (mem_operand) == PLUS \n+      || (GET_CODE (mem_operand) == PLUS\n \t  && GET_CODE (XEXP (mem_operand, 0)) == PRE_DEC))\n     direction = -1;\n   else if (GET_CODE (src) == MEM\n \t   && reg_overlap_mentioned_p (dest, src))\n     {\n       int regno;\n-      \n+\n       gcc_assert (GET_CODE (dest) == REG);\n       regno = REGNO (dest);\n-      \n+\n       gcc_assert (refers_to_regno_p (regno, regno + num_words,\n \t\t\t\t     mem_operand, 0));\n-      \n+\n       if (refers_to_regno_p (regno, regno + 1, mem_operand, 0))\n \tdirection = -1;\n       else if (refers_to_regno_p (regno + num_words - 1, regno + num_words,\n@@ -866,15 +870,15 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n       if (dest_modifies)\n \tw_dest = gen_rtx_MEM (word_mode, mem_operand);\n       else\n-\tw_dest = simplify_gen_subreg (word_mode, dest, mode, \n+\tw_dest = simplify_gen_subreg (word_mode, dest, mode,\n \t\t\t\t      i * UNITS_PER_WORD);\n       if (dest_volatile)\n \tMEM_VOLATILE_P (w_dest) = 1;\n-      \n+\n       /* The simplify_subreg calls must always be able to simplify.  */\n       gcc_assert (GET_CODE (w_src) != SUBREG\n \t\t  && GET_CODE (w_dest) != SUBREG);\n-      \n+\n       insn = emit_insn (gen_rtx_SET (VOIDmode, w_dest, w_src));\n       if (auto_inc_reg_rtx)\n         REG_NOTES (insn) = alloc_EXPR_LIST (REG_INC,\n@@ -886,7 +890,7 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n /* Expander for the 'move' patterns.  Emit insns to copy a value of\n    mode MODE from SRC to DEST.  */\n \n-void \n+void\n xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n {\n   if ((GET_CODE (dest) == MEM) && (GET_CODE (XEXP (dest, 0)) == PRE_MODIFY))\n@@ -896,7 +900,7 @@ xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n       rtx dest_mod = XEXP (pmv, 1);\n       rtx set      = gen_rtx_SET (Pmode, dest_reg, dest_mod);\n       rtx clobber  = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (BImode, CARRY_REGNUM));\n-    \n+\n       dest = gen_rtx_MEM (mode, dest_reg);\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n     }\n@@ -907,11 +911,11 @@ xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n       rtx src_mod = XEXP (pmv, 1);\n       rtx set     = gen_rtx_SET (Pmode, src_reg, src_mod);\n       rtx clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (BImode, CARRY_REGNUM));\n-    \n+\n       src = gen_rtx_MEM (mode, src_reg);\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n     }\n-   \n+\n   /* There are only limited immediate-to-memory move instructions.  */\n   if (! reload_in_progress\n       && ! reload_completed\n@@ -930,10 +934,9 @@ xstormy16_expand_move (enum machine_mode mode, rtx dest, rtx src)\n       xstormy16_split_move (mode, dest, src);\n       return;\n     }\n-  \n+\n   emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n }\n-\n \f\n /* Stack Layout:\n \n@@ -977,54 +980,56 @@ struct xstormy16_stack_layout\n        && (df_regs_ever_live_p (REGNUM) || ! current_function_is_leaf)))\n \n /* Compute the stack layout.  */\n-struct xstormy16_stack_layout \n+\n+struct xstormy16_stack_layout\n xstormy16_compute_stack_layout (void)\n {\n   struct xstormy16_stack_layout layout;\n   int regno;\n   const int ifun = xstormy16_interrupt_function_p ();\n \n   layout.locals_size = get_frame_size ();\n-  \n+\n   layout.register_save_size = 0;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (REG_NEEDS_SAVE (regno, ifun))\n       layout.register_save_size += UNITS_PER_WORD;\n-  \n+\n   if (cfun->stdarg)\n     layout.stdarg_save_size = NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD;\n   else\n     layout.stdarg_save_size = 0;\n-  \n-  layout.frame_size = (layout.locals_size \n-\t\t       + layout.register_save_size \n+\n+  layout.frame_size = (layout.locals_size\n+\t\t       + layout.register_save_size\n \t\t       + layout.stdarg_save_size);\n-  \n+\n   if (crtl->args.size <= 2048 && crtl->args.size != -1)\n     {\n-      if (layout.frame_size - INCOMING_FRAME_SP_OFFSET \n+      if (layout.frame_size - INCOMING_FRAME_SP_OFFSET\n \t  + crtl->args.size <= 2048)\n \tlayout.fp_minus_ap = layout.frame_size - INCOMING_FRAME_SP_OFFSET;\n       else\n \tlayout.fp_minus_ap = 2048 - crtl->args.size;\n     }\n   else\n-    layout.fp_minus_ap = (layout.stdarg_save_size \n+    layout.fp_minus_ap = (layout.stdarg_save_size\n \t\t\t  + layout.register_save_size\n \t\t\t  - INCOMING_FRAME_SP_OFFSET);\n-  layout.sp_minus_fp = (layout.frame_size - INCOMING_FRAME_SP_OFFSET \n+  layout.sp_minus_fp = (layout.frame_size - INCOMING_FRAME_SP_OFFSET\n \t\t\t- layout.fp_minus_ap);\n   layout.first_local_minus_ap = layout.sp_minus_fp - layout.locals_size;\n   return layout;\n }\n \n /* Determine how all the special registers get eliminated.  */\n+\n int\n xstormy16_initial_elimination_offset (int from, int to)\n {\n   struct xstormy16_stack_layout layout;\n   int result;\n-  \n+\n   layout = xstormy16_compute_stack_layout ();\n \n   if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n@@ -1045,7 +1050,7 @@ static rtx\n emit_addhi3_postreload (rtx dest, rtx src0, rtx src1)\n {\n   rtx set, clobber, insn;\n-  \n+\n   set = gen_rtx_SET (VOIDmode, dest, gen_rtx_PLUS (HImode, src0, src1));\n   clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (BImode, CARRY_REGNUM));\n   insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n@@ -1062,6 +1067,7 @@ emit_addhi3_postreload (rtx dest, rtx src0, rtx src1)\n \n    Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1\n    so that the debug info generation code can handle them properly.  */\n+\n void\n xstormy16_expand_prologue (void)\n {\n@@ -1070,18 +1076,18 @@ xstormy16_expand_prologue (void)\n   rtx insn;\n   rtx mem_push_rtx;\n   const int ifun = xstormy16_interrupt_function_p ();\n-  \n+\n   mem_push_rtx = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n   mem_push_rtx = gen_rtx_MEM (HImode, mem_push_rtx);\n-    \n+\n   layout = xstormy16_compute_stack_layout ();\n \n   if (layout.locals_size >= 32768)\n     error (\"local variable memory requirements exceed capacity\");\n \n   /* Save the argument registers if necessary.  */\n   if (layout.stdarg_save_size)\n-    for (regno = FIRST_ARGUMENT_REGISTER; \n+    for (regno = FIRST_ARGUMENT_REGISTER;\n \t regno < FIRST_ARGUMENT_REGISTER + NUM_ARGUMENT_REGISTERS;\n \t regno++)\n       {\n@@ -1092,7 +1098,7 @@ xstormy16_expand_prologue (void)\n \tRTX_FRAME_RELATED_P (insn) = 1;\n \n \tdwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (2));\n-\t\n+\n \tXVECEXP (dwarf, 0, 0) = gen_rtx_SET (VOIDmode,\n \t\t\t\t\t     gen_rtx_MEM (Pmode, stack_pointer_rtx),\n \t\t\t\t\t     reg);\n@@ -1105,7 +1111,7 @@ xstormy16_expand_prologue (void)\n \tRTX_FRAME_RELATED_P (XVECEXP (dwarf, 0, 0)) = 1;\n \tRTX_FRAME_RELATED_P (XVECEXP (dwarf, 0, 1)) = 1;\n       }\n-  \n+\n   /* Push each of the registers to save.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (REG_NEEDS_SAVE (regno, ifun))\n@@ -1117,7 +1123,7 @@ xstormy16_expand_prologue (void)\n \tRTX_FRAME_RELATED_P (insn) = 1;\n \n \tdwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (2));\n-\t\n+\n \tXVECEXP (dwarf, 0, 0) = gen_rtx_SET (VOIDmode,\n \t\t\t\t\t     gen_rtx_MEM (Pmode, stack_pointer_rtx),\n \t\t\t\t\t     reg);\n@@ -1164,10 +1170,11 @@ xstormy16_expand_prologue (void)\n }\n \n /* Do we need an epilogue at all?  */\n+\n int\n direct_return (void)\n {\n-  return (reload_completed \n+  return (reload_completed\n \t  && xstormy16_compute_stack_layout ().frame_size == 0);\n }\n \n@@ -1186,10 +1193,10 @@ xstormy16_expand_epilogue (void)\n   rtx mem_pop_rtx, insn;\n   int regno;\n   const int ifun = xstormy16_interrupt_function_p ();\n-  \n+\n   mem_pop_rtx = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n   mem_pop_rtx = gen_rtx_MEM (HImode, mem_pop_rtx);\n-  \n+\n   layout = xstormy16_compute_stack_layout ();\n \n   /* Pop the stack for the locals.  */\n@@ -1206,7 +1213,7 @@ xstormy16_expand_epilogue (void)\n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n     if (REG_NEEDS_SAVE (regno, ifun))\n       emit_move_insn (gen_rtx_REG (HImode, regno), mem_pop_rtx);\n-  \n+\n   /* Pop the stack for the stdarg save area.  */\n   if (layout.stdarg_save_size)\n     emit_addhi3_postreload (stack_pointer_rtx, stack_pointer_rtx,\n@@ -1235,7 +1242,6 @@ xstormy16_function_profiler (void)\n {\n   sorry (\"function_profiler support\");\n }\n-\n \f\n /* Return an updated summarizer variable CUM to advance past an\n    argument in the argument list.  The values MODE, TYPE and NAMED\n@@ -1248,6 +1254,7 @@ xstormy16_function_profiler (void)\n    stack space used for arguments without any special help.  However,\n    it makes life easier for xstormy16_build_va_list if it does update\n    the word count.  */\n+\n CUMULATIVE_ARGS\n xstormy16_function_arg_advance (CUMULATIVE_ARGS cum, enum machine_mode mode,\n \t\t\t\ttree type, int named ATTRIBUTE_UNUSED)\n@@ -1258,9 +1265,9 @@ xstormy16_function_arg_advance (CUMULATIVE_ARGS cum, enum machine_mode mode,\n   if (cum < NUM_ARGUMENT_REGISTERS\n       && cum + XSTORMY16_WORD_SIZE (type, mode) > NUM_ARGUMENT_REGISTERS)\n     cum = NUM_ARGUMENT_REGISTERS;\n-  \n+\n   cum += XSTORMY16_WORD_SIZE (type, mode);\n-  \n+\n   return cum;\n }\n \n@@ -1272,7 +1279,7 @@ xstormy16_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n     return const0_rtx;\n   if (targetm.calls.must_pass_in_stack (mode, type)\n       || cum + XSTORMY16_WORD_SIZE (type, mode) > NUM_ARGUMENT_REGISTERS)\n-    return 0;\n+    return NULL_RTX;\n   return gen_rtx_REG (mode, cum + 2);\n }\n \n@@ -1281,7 +1288,7 @@ xstormy16_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n    For this chip, va_list is a record containing a counter and a pointer.\n    The counter is of type 'int' and indicates how many bytes\n    have been used to date.  The pointer indicates the stack position\n-   for arguments that have not been passed in registers.  \n+   for arguments that have not been passed in registers.\n    To keep the layout nice, the pointer is first in the structure.  */\n \n static tree\n@@ -1294,7 +1301,7 @@ xstormy16_build_builtin_va_list (void)\n \n   f_1 = build_decl (FIELD_DECL, get_identifier (\"base\"),\n \t\t      ptr_type_node);\n-  f_2 = build_decl (FIELD_DECL, get_identifier (\"count\"), \n+  f_2 = build_decl (FIELD_DECL, get_identifier (\"count\"),\n \t\t      unsigned_type_node);\n \n   DECL_FIELD_CONTEXT (f_1) = record;\n@@ -1314,6 +1321,7 @@ xstormy16_build_builtin_va_list (void)\n    is stdarg.h instead of varargs.h.  VALIST is the tree of the va_list\n    variable to initialize.  NEXTARG is the machine independent notion of the\n    'next' argument after the variable arguments.  */\n+\n static void\n xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n {\n@@ -1323,10 +1331,10 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   if (xstormy16_interrupt_function_p ())\n     error (\"cannot use va_start in interrupt function\");\n-  \n+\n   f_base = TYPE_FIELDS (va_list_type_node);\n   f_count = TREE_CHAIN (f_base);\n-  \n+\n   base = build3 (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n   count = build3 (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n \t\t  NULL_TREE);\n@@ -1339,7 +1347,7 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build2 (MODIFY_EXPR, TREE_TYPE (count), count, \n+  t = build2 (MODIFY_EXPR, TREE_TYPE (count), count,\n \t      build_int_cst (NULL_TREE,\n \t\t\t     crtl->args.info * UNITS_PER_WORD));\n   TREE_SIDE_EFFECTS (t) = 1;\n@@ -1349,7 +1357,7 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n /* Implement the stdarg/varargs va_arg macro.  VALIST is the variable\n    of type va_list as a tree, TYPE is the type passed to va_arg.\n    Note:  This algorithm is documented in stormy-abi.  */\n-   \n+\n static tree\n xstormy16_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t\t\t\tgimple_seq *post_p ATTRIBUTE_UNUSED)\n@@ -1363,15 +1371,15 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \n   f_base = TYPE_FIELDS (va_list_type_node);\n   f_count = TREE_CHAIN (f_base);\n-  \n+\n   base = build3 (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n   count = build3 (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n \t\t  NULL_TREE);\n \n   must_stack = targetm.calls.must_pass_in_stack (TYPE_MODE (type), type);\n   size_tree = round_up (size_in_bytes (type), UNITS_PER_WORD);\n   gimplify_expr (&size_tree, pre_p, NULL, is_gimple_val, fb_rvalue);\n-  \n+\n   size_of_reg_args = NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD;\n \n   count_tmp = get_initialized_tmp_var (count, pre_p, NULL);\n@@ -1401,7 +1409,7 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       t = build1 (LABEL_EXPR, void_type_node, lab_fromstack);\n       gimplify_and_add (t, pre_p);\n     }\n-  \n+\n   /* Arguments larger than a word might need to skip over some\n      registers, since arguments are either passed entirely in\n      registers or entirely on the stack.  */\n@@ -1436,7 +1444,7 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   t = fold_convert (TREE_TYPE (count), size_tree);\n   t = build2 (PLUS_EXPR, TREE_TYPE (count), count_tmp, t);\n   gimplify_assign (count, t, pre_p);\n-  \n+\n   addr = fold_convert (build_pointer_type (type), addr);\n   return build_va_arg_indirect_ref (addr);\n }\n@@ -1445,6 +1453,7 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n    the address of the trampoline; FNADDR is an RTX for the address of\n    the nested function; STATIC_CHAIN is an RTX for the static chain\n    value that should be passed to the function when it is called.  */\n+\n void\n xstormy16_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n {\n@@ -1454,7 +1463,7 @@ xstormy16_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n   rtx reg_addr_mem;\n \n   reg_addr_mem = gen_rtx_MEM (HImode, reg_addr);\n-    \n+\n   emit_move_insn (reg_addr, addr);\n   emit_move_insn (temp, GEN_INT (0x3130 | STATIC_CHAIN_REGNUM));\n   emit_move_insn (reg_addr_mem, temp);\n@@ -1517,11 +1526,11 @@ xstormy16_asm_output_mi_thunk (FILE *file,\n \t\t\t       tree function)\n {\n   int regnum = FIRST_ARGUMENT_REGISTER;\n-  \n+\n   /* There might be a hidden first argument for a returned structure.  */\n   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     regnum += 1;\n-  \n+\n   fprintf (file, \"\\tadd %s,#0x%x\\n\", reg_names[regnum], (int) delta & 0xFFFF);\n   fputs (\"\\tjmpf \", file);\n   assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n@@ -1534,6 +1543,7 @@ xstormy16_asm_output_mi_thunk (FILE *file,\n    .bss_below100.  We can't just use a section override (like we do\n    for .data_below100), because that makes them initialized rather\n    than uninitialized.  */\n+\n void\n xstormy16_asm_output_aligned_common (FILE *stream,\n \t\t\t\t     tree decl,\n@@ -1544,7 +1554,7 @@ xstormy16_asm_output_aligned_common (FILE *stream,\n {\n   rtx mem = DECL_RTL (decl);\n   rtx symbol;\n-    \n+\n   if (mem != NULL_RTX\n       && GET_CODE (mem) == MEM\n       && GET_CODE (symbol = XEXP (mem, 0)) == SYMBOL_REF\n@@ -1607,18 +1617,19 @@ xstormy16_encode_section_info (tree decl, rtx r, int first)\n \t  || lookup_attribute (\"BELOW100\", DECL_ATTRIBUTES (decl))))\n     {\n       rtx symbol = XEXP (r, 0);\n-      \n+\n       gcc_assert (GET_CODE (symbol) == SYMBOL_REF);\n       SYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_XSTORMY16_BELOW100;\n     }\n }\n \n-/* Output constructors and destructors.  Just like \n-   default_named_section_asm_out_* but don't set the sections writable.  */\n #undef  TARGET_ASM_CONSTRUCTOR\n-#define TARGET_ASM_CONSTRUCTOR xstormy16_asm_out_constructor\n+#define TARGET_ASM_CONSTRUCTOR  xstormy16_asm_out_constructor\n #undef  TARGET_ASM_DESTRUCTOR\n-#define TARGET_ASM_DESTRUCTOR xstormy16_asm_out_destructor\n+#define TARGET_ASM_DESTRUCTOR   xstormy16_asm_out_destructor\n+\n+/* Output constructors and destructors.  Just like\n+   default_named_section_asm_out_* but don't set the sections writable.  */\n \n static void\n xstormy16_asm_out_destructor (rtx symbol, int priority)\n@@ -1665,6 +1676,7 @@ xstormy16_asm_out_constructor (rtx symbol, int priority)\n }\n \f\n /* Print a memory address as an operand to reference that memory location.  */\n+\n void\n xstormy16_print_operand_address (FILE *file, rtx address)\n {\n@@ -1677,17 +1689,15 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (address) & 0xFFFF);\n       return;\n     }\n-  \n+\n   if (CONSTANT_P (address) || GET_CODE (address) == CODE_LABEL)\n     {\n       output_addr_const (file, address);\n       return;\n     }\n-  \n-  /* Otherwise, it's hopefully something of the form \n-     (plus:HI (pre_dec:HI (reg:HI ...)) (const_int ...))\n-  */\n \n+  /* Otherwise, it's hopefully something of the form\n+     (plus:HI (pre_dec:HI (reg:HI ...)) (const_int ...)).  */\n   if (GET_CODE (address) == PLUS)\n     {\n       gcc_assert (GET_CODE (XEXP (address, 1)) == CONST_INT);\n@@ -1701,7 +1711,7 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n   post_inc = (GET_CODE (address) == POST_INC);\n   if (pre_dec || post_inc)\n     address = XEXP (address, 0);\n-  \n+\n   gcc_assert (GET_CODE (address) == REG);\n \n   fputc ('(', file);\n@@ -1716,6 +1726,7 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n }\n \n /* Print an operand to an assembler instruction.  */\n+\n void\n xstormy16_print_operand (FILE *file, rtx x, int code)\n {\n@@ -1733,7 +1744,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \t  xx = INTVAL (x);\n \telse\n \t  output_operand_lossage (\"'B' operand is not constant\");\n-\t\n+\n \t/* GCC sign-extends masks with the MSB set, so we have to\n \t   detect all the cases that differ only in sign extension\n \t   beyond the bits we care about.  Normally, the predicates\n@@ -1760,7 +1771,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \n \tif (l == -1)\n \t  output_operand_lossage (\"'B' operand has multiple bits set\");\n-\t\n+\n \tfprintf (file, IMMEDIATE_PREFIX HOST_WIDE_INT_PRINT_DEC, l);\n \treturn;\n       }\n@@ -1777,19 +1788,19 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \n     case 'o':\n     case 'O':\n-      /* Print the immediate operand less one, preceded by '#'.  \n+      /* Print the immediate operand less one, preceded by '#'.\n          For 'O', negate it first.  */\n       {\n \tHOST_WIDE_INT xx = 0;\n-\t\n+\n \tif (GET_CODE (x) == CONST_INT)\n \t  xx = INTVAL (x);\n \telse\n \t  output_operand_lossage (\"'o' operand is not constant\");\n-\t\n+\n \tif (code == 'O')\n \t  xx = -xx;\n-\t\n+\n \tfprintf (file, IMMEDIATE_PREFIX HOST_WIDE_INT_PRINT_DEC, xx - 1);\n \treturn;\n       }\n@@ -1804,9 +1815,9 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \t  xx = INTVAL (x);\n \telse\n \t  output_operand_lossage (\"'B' operand is not constant\");\n-\t\n+\n \tl = 7 - xx;\n-\t\n+\n \tfputs (IMMEDIATE_PREFIX, file);\n \tfprintf (file, HOST_WIDE_INT_PRINT_DEC, l);\n \treturn;\n@@ -1815,7 +1826,7 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n     case 0:\n       /* Handled below.  */\n       break;\n-      \n+\n     default:\n       output_operand_lossage (\"xstormy16_print_operand: unknown code\");\n       return;\n@@ -1841,7 +1852,6 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n \n   return;\n }\n-\n \f\n /* Expander for the `casesi' pattern.\n    INDEX is the index of the switch statement.\n@@ -1850,10 +1860,9 @@ xstormy16_print_operand (FILE *file, rtx x, int code)\n    RANGE is the number of table entries.\n    TABLE is an ADDR_VEC that is the jump table.\n    DEFAULT_LABEL is the address to branch to if INDEX is outside the\n-     range LOWER_BOUND to LOWER_BOUND+RANGE-1.\n-*/\n+     range LOWER_BOUND to LOWER_BOUND + RANGE - 1.  */\n \n-void \n+void\n xstormy16_expand_casesi (rtx index, rtx lower_bound, rtx range,\n \t\t\t rtx table, rtx default_label)\n {\n@@ -1863,7 +1872,7 @@ xstormy16_expand_casesi (rtx index, rtx lower_bound, rtx range,\n   /* This code uses 'br', so it can deal only with tables of size up to\n      8192 entries.  */\n   if (range_i >= 8192)\n-    sorry (\"switch statement of size %lu entries too large\", \n+    sorry (\"switch statement of size %lu entries too large\",\n \t   (unsigned long) range_i);\n \n   index = expand_binop (SImode, sub_optab, index, lower_bound, NULL_RTX, 0,\n@@ -1885,9 +1894,9 @@ xstormy16_expand_casesi (rtx index, rtx lower_bound, rtx range,\n \n void\n xstormy16_output_addr_vec (FILE *file, rtx label ATTRIBUTE_UNUSED, rtx table)\n-{ \n+{\n   int vlen, idx;\n-  \n+\n   switch_to_section (current_function_section ());\n \n   vlen = XVECLEN (table, 0);\n@@ -1898,7 +1907,6 @@ xstormy16_output_addr_vec (FILE *file, rtx label ATTRIBUTE_UNUSED, rtx table)\n       fputc ('\\n', file);\n     }\n }\n-\n \f\n /* Expander for the `call' patterns.\n    INDEX is the index of the switch statement.\n@@ -1907,10 +1915,9 @@ xstormy16_output_addr_vec (FILE *file, rtx label ATTRIBUTE_UNUSED, rtx table)\n    RANGE is the number of table entries.\n    TABLE is an ADDR_VEC that is the jump table.\n    DEFAULT_LABEL is the address to branch to if INDEX is outside the\n-     range LOWER_BOUND to LOWER_BOUND+RANGE-1.\n-*/\n+     range LOWER_BOUND to LOWER_BOUND + RANGE - 1.  */\n \n-void \n+void\n xstormy16_expand_call (rtx retval, rtx dest, rtx counter)\n {\n   rtx call, temp;\n@@ -1922,7 +1929,7 @@ xstormy16_expand_call (rtx retval, rtx dest, rtx counter)\n   if (! CONSTANT_P (dest)\n       && GET_CODE (dest) != REG)\n     dest = force_reg (Pmode, dest);\n-  \n+\n   if (retval == NULL)\n     mode = VOIDmode;\n   else\n@@ -1932,16 +1939,16 @@ xstormy16_expand_call (rtx retval, rtx dest, rtx counter)\n \t\t       counter);\n   if (retval)\n     call = gen_rtx_SET (VOIDmode, retval, call);\n-  \n+\n   if (! CONSTANT_P (dest))\n     {\n       temp = gen_reg_rtx (HImode);\n       emit_move_insn (temp, const0_rtx);\n     }\n   else\n     temp = const0_rtx;\n-  \n-  call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, call, \n+\n+  call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, call,\n \t\t\t\t\t\tgen_rtx_USE (VOIDmode, temp)));\n   emit_call_insn (call);\n }\n@@ -1951,11 +1958,11 @@ xstormy16_expand_call (rtx retval, rtx dest, rtx counter)\n /* Expander for arithmetic operations; emit insns to compute\n \n    (set DEST (CODE:MODE SRC0 SRC1))\n-   \n+\n    When CODE is COMPARE, a branch template is generated\n    (this saves duplicating code in xstormy16_split_cbranch).  */\n \n-void \n+void\n xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \t\t\trtx dest, rtx src0, rtx src1)\n {\n@@ -1965,13 +1972,13 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \n   if (code == NEG)\n     emit_move_insn (src0, const0_rtx);\n-  \n+\n   for (i = 0; i < num_words; i++)\n     {\n       rtx w_src0, w_src1, w_dest;\n       rtx insn;\n-      \n-      w_src0 = simplify_gen_subreg (word_mode, src0, mode, \n+\n+      w_src0 = simplify_gen_subreg (word_mode, src0, mode,\n \t\t\t\t    i * UNITS_PER_WORD);\n       w_src1 = simplify_gen_subreg (word_mode, src1, mode, i * UNITS_PER_WORD);\n       w_dest = simplify_gen_subreg (word_mode, dest, mode, i * UNITS_PER_WORD);\n@@ -1982,7 +1989,7 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \t  if (firstloop\n \t      && GET_CODE (w_src1) == CONST_INT && INTVAL (w_src1) == 0)\n \t    continue;\n-\t  \n+\n \t  if (firstloop)\n \t    insn = gen_addchi4 (w_dest, w_src0, w_src1);\n \t  else\n@@ -1995,8 +2002,8 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \t  if (code == COMPARE && i == num_words - 1)\n \t    {\n \t      rtx branch, sub, clobber, sub_1;\n-\t      \n-\t      sub_1 = gen_rtx_MINUS (HImode, w_src0, \n+\n+\t      sub_1 = gen_rtx_MINUS (HImode, w_src0,\n \t\t\t\t     gen_rtx_ZERO_EXTEND (HImode, gen_rtx_REG (BImode, CARRY_REGNUM)));\n \t      sub = gen_rtx_SET (VOIDmode, w_dest,\n \t\t\t\t gen_rtx_MINUS (HImode, sub_1, w_src1));\n@@ -2024,10 +2031,10 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \tcase IOR:\n \tcase XOR:\n \tcase AND:\n-\t  if (GET_CODE (w_src1) == CONST_INT \n+\t  if (GET_CODE (w_src1) == CONST_INT\n \t      && INTVAL (w_src1) == -(code == AND))\n \t    continue;\n-\t  \n+\n \t  insn = gen_rtx_SET (VOIDmode, w_dest, gen_rtx_fmt_ee (code, mode,\n \t\t\t\t\t\t\t\tw_src0, w_src1));\n \t  break;\n@@ -2039,7 +2046,7 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      \n+\n       firstloop = 0;\n       emit (insn);\n     }\n@@ -2051,12 +2058,12 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n }\n \n /* The shift operations are split at output time for constant values;\n-   variable-width shifts get handed off to a library routine.  \n+   variable-width shifts get handed off to a library routine.\n \n    Generate an output string to do (set X (CODE:MODE X SIZE_R))\n    SIZE_R will be a CONST_INT, X will be a hard register.  */\n \n-const char * \n+const char *\n xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n \t\t\trtx x, rtx size_r, rtx temp)\n {\n@@ -2093,7 +2100,7 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n \t}\n       return r;\n     }\n-  \n+\n   /* For large shifts, there are easy special cases.  */\n   if (size == 16)\n     {\n@@ -2118,15 +2125,15 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n       switch (code)\n \t{\n \tcase ASHIFT:\n-\t  sprintf (r, \"mov %s,%s | mov %s,#0 | shl %s,#%d\", \n+\t  sprintf (r, \"mov %s,%s | mov %s,#0 | shl %s,#%d\",\n \t\t   r1, r0, r0, r1, (int) size - 16);\n \t  break;\n \tcase ASHIFTRT:\n-\t  sprintf (r, \"mov %s,%s | asr %s,#15 | asr %s,#%d\", \n+\t  sprintf (r, \"mov %s,%s | asr %s,#15 | asr %s,#%d\",\n \t\t   r0, r1, r1, r0, (int) size - 16);\n \t  break;\n \tcase LSHIFTRT:\n-\t  sprintf (r, \"mov %s,%s | mov %s,#0 | shr %s,#%d\", \n+\t  sprintf (r, \"mov %s,%s | mov %s,#0 | shr %s,#%d\",\n \t\t   r0, r1, r1, r0, (int) size - 16);\n \t  break;\n \tdefault:\n@@ -2141,21 +2148,21 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n   switch (code)\n     {\n     case ASHIFT:\n-      sprintf (r, \n-\t       \"mov %s,%s | shl %s,#%d | shl %s,#%d | shr %s,#%d | or %s,%s\", \n-\t       rt, r0, r0, (int) size, r1, (int) size, rt, (int) (16-size),\n+      sprintf (r,\n+\t       \"mov %s,%s | shl %s,#%d | shl %s,#%d | shr %s,#%d | or %s,%s\",\n+\t       rt, r0, r0, (int) size, r1, (int) size, rt, (int) (16 - size),\n \t       r1, rt);\n       break;\n     case ASHIFTRT:\n-      sprintf (r, \n-\t       \"mov %s,%s | asr %s,#%d | shr %s,#%d | shl %s,#%d | or %s,%s\", \n-\t       rt, r1, r1, (int) size, r0, (int) size, rt, (int) (16-size),\n+      sprintf (r,\n+\t       \"mov %s,%s | asr %s,#%d | shr %s,#%d | shl %s,#%d | or %s,%s\",\n+\t       rt, r1, r1, (int) size, r0, (int) size, rt, (int) (16 - size),\n \t       r0, rt);\n       break;\n     case LSHIFTRT:\n-      sprintf (r, \n-\t       \"mov %s,%s | shr %s,#%d | shr %s,#%d | shl %s,#%d | or %s,%s\", \n-\t       rt, r1, r1, (int) size, r0, (int) size, rt, (int) (16-size),\n+      sprintf (r,\n+\t       \"mov %s,%s | shr %s,#%d | shr %s,#%d | shl %s,#%d | or %s,%s\",\n+\t       rt, r1, r1, (int) size, r0, (int) size, rt, (int) (16 - size),\n \t       r0, rt);\n       break;\n     default:\n@@ -2167,11 +2174,12 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n /* Attribute handling.  */\n \n /* Return nonzero if the function is an interrupt function.  */\n+\n int\n xstormy16_interrupt_function_p (void)\n {\n   tree attributes;\n-  \n+\n   /* The dwarf2 mechanism asks for INCOMING_FRAME_SP_OFFSET before\n      any functions are declared, which is demonstrably wrong, but\n      it is worked around here.  FIXME.  */\n@@ -2182,16 +2190,17 @@ xstormy16_interrupt_function_p (void)\n   return lookup_attribute (\"interrupt\", attributes) != NULL_TREE;\n }\n \n-#undef TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE xstormy16_attribute_table\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE  xstormy16_attribute_table\n+\n static tree xstormy16_handle_interrupt_attribute\n   (tree *, tree, tree, int, bool *);\n static tree xstormy16_handle_below100_attribute\n   (tree *, tree, tree, int, bool *);\n \n static const struct attribute_spec xstormy16_attribute_table[] =\n {\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  /* name, min_len, max_len, decl_req, type_req, fn_type_req, handler.  */\n   { \"interrupt\", 0, 0, false, true,  true,  xstormy16_handle_interrupt_attribute },\n   { \"BELOW100\",  0, 0, false, false, false, xstormy16_handle_below100_attribute },\n   { \"below100\",  0, 0, false, false, false, xstormy16_handle_below100_attribute },\n@@ -2200,6 +2209,7 @@ static const struct attribute_spec xstormy16_attribute_table[] =\n \n /* Handle an \"interrupt\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n+\n static tree\n xstormy16_handle_interrupt_attribute (tree *node, tree name,\n \t\t\t\t      tree args ATTRIBUTE_UNUSED,\n@@ -2218,6 +2228,7 @@ xstormy16_handle_interrupt_attribute (tree *node, tree name,\n \n /* Handle an \"below\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n+\n static tree\n xstormy16_handle_below100_attribute (tree *node,\n \t\t\t\t     tree name ATTRIBUTE_UNUSED,\n@@ -2242,26 +2253,29 @@ xstormy16_handle_below100_attribute (tree *node,\n \t  *no_add_attrs = true;\n \t}\n     }\n-  \n+\n   return NULL_TREE;\n }\n \f\n-#undef TARGET_INIT_BUILTINS\n-#define TARGET_INIT_BUILTINS xstormy16_init_builtins\n-#undef TARGET_EXPAND_BUILTIN\n-#define TARGET_EXPAND_BUILTIN xstormy16_expand_builtin\n-\n-static struct {\n-  const char *name;\n-  int md_code;\n-  const char *arg_ops; /* 0..9, t for temp register, r for return value */\n-  const char *arg_types; /* s=short,l=long, upper case for unsigned */\n-} s16builtins[] = {\n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS   xstormy16_init_builtins\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN  xstormy16_expand_builtin\n+\n+static struct\n+{\n+  const char * name;\n+  int          md_code;\n+  const char * arg_ops;   /* 0..9, t for temp register, r for return value.  */\n+  const char * arg_types; /* s=short,l=long, upper case for unsigned.  */\n+}\n+  s16builtins[] =\n+{\n   { \"__sdivlh\", CODE_FOR_sdivlh, \"rt01\", \"sls\" },\n   { \"__smodlh\", CODE_FOR_sdivlh, \"tr01\", \"sls\" },\n   { \"__udivlh\", CODE_FOR_udivlh, \"rt01\", \"SLS\" },\n   { \"__umodlh\", CODE_FOR_udivlh, \"tr01\", \"SLS\" },\n-  { 0, 0, 0, 0 }\n+  { NULL, 0, NULL, NULL }\n };\n \n static void\n@@ -2272,10 +2286,10 @@ xstormy16_init_builtins (void)\n \n   ret_type = void_type_node;\n \n-  for (i=0; s16builtins[i].name; i++)\n+  for (i = 0; s16builtins[i].name; i++)\n     {\n       args = void_list_node;\n-      for (a=strlen (s16builtins[i].arg_types)-1; a>=0; a--)\n+      for (a = strlen (s16builtins[i].arg_types) - 1; a >= 0; a--)\n \t{\n \t  switch (s16builtins[i].arg_types[a])\n \t    {\n@@ -2363,10 +2377,10 @@ xstormy16_expand_builtin (tree exp, rtx target,\n   return retval;\n }\n \f\n-\n /* Look for combinations of insns that can be converted to BN or BP\n    opcodes.  This is, unfortunately, too complex to do with MD\n    patterns.  */\n+\n static void\n combine_bnp (rtx insn)\n {\n@@ -2421,7 +2435,7 @@ combine_bnp (rtx insn)\n \t      && rtx_equal_p (SET_DEST (PATTERN (and)), reg)\n \t      && rtx_equal_p (XEXP (SET_SRC (PATTERN (and)), 0), qireg))\n \t    break;\n-\t\n+\n \t  if (and_code == CODE_FOR_movhi_internal\n \t      && rtx_equal_p (SET_DEST (PATTERN (and)), reg))\n \t    {\n@@ -2447,7 +2461,7 @@ combine_bnp (rtx insn)\n \t      && rtx_equal_p (SET_DEST (PATTERN (and)), reg)\n \t      && rtx_equal_p (XEXP (SET_SRC (PATTERN (and)), 0), reg))\n \t    break;\n-\t\n+\n \t  if (reg_mentioned_p (reg, and))\n \t    return;\n \n@@ -2465,15 +2479,15 @@ combine_bnp (rtx insn)\n                           (clobber (reg:BI carry))]\n \n                (set (reg:HI r7) (and:HI (reg:HI r7) (const_int 1)))\n-\t      \n+\n \t     Attempt to detect this here.  */\n \t  for (shift = prev_real_insn (and); shift; shift = prev_real_insn (shift))\n \t    {\n \t      if (recog_memoized (shift) == CODE_FOR_lshrhi3\n \t\t  && rtx_equal_p (SET_DEST (XVECEXP (PATTERN (shift), 0, 0)), reg)\n \t\t  && rtx_equal_p (XEXP (SET_SRC (XVECEXP (PATTERN (shift), 0, 0)), 0), reg))\n \t\tbreak;\n-\t\t\n+\n \t      if (reg_mentioned_p (reg, shift)\n \t\t  || (GET_CODE (shift) != NOTE\n \t\t      && GET_CODE (shift) != INSN))\n@@ -2591,7 +2605,6 @@ xstormy16_reorg (void)\n       combine_bnp (insn);\n     }\n }\n-\n \f\n /* Worker function for TARGET_RETURN_IN_MEMORY.  */\n \n@@ -2602,45 +2615,45 @@ xstormy16_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   return (size == -1 || size > UNITS_PER_WORD * NUM_ARGUMENT_REGISTERS);\n }\n \f\n-#undef TARGET_ASM_ALIGNED_HI_OP\n+#undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n-#undef TARGET_ASM_ALIGNED_SI_OP\n+#undef  TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n-#undef TARGET_ENCODE_SECTION_INFO\n+#undef  TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO xstormy16_encode_section_info\n \n-/* select_section doesn't handle .bss_below100.  */\n+/* Select_section doesn't handle .bss_below100.  */\n #undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n #define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n \n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#undef  TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK xstormy16_asm_output_mi_thunk\n-#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n-#undef TARGET_RTX_COSTS\n+#undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS xstormy16_rtx_costs\n-#undef TARGET_ADDRESS_COST\n+#undef  TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST xstormy16_address_cost\n \n-#undef TARGET_BUILD_BUILTIN_VA_LIST\n+#undef  TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST xstormy16_build_builtin_va_list\n-#undef TARGET_EXPAND_BUILTIN_VA_START\n+#undef  TARGET_EXPAND_BUILTIN_VA_START\n #define TARGET_EXPAND_BUILTIN_VA_START xstormy16_expand_builtin_va_start\n-#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#undef  TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR xstormy16_gimplify_va_arg_expr\n \n-#undef TARGET_PROMOTE_FUNCTION_ARGS\n+#undef  TARGET_PROMOTE_FUNCTION_ARGS\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_const_tree_true\n-#undef TARGET_PROMOTE_FUNCTION_RETURN\n+#undef  TARGET_PROMOTE_FUNCTION_RETURN\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_const_tree_true\n-#undef TARGET_PROMOTE_PROTOTYPES\n+#undef  TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n \n-#undef TARGET_RETURN_IN_MEMORY\n+#undef  TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY xstormy16_return_in_memory\n \n-#undef TARGET_MACHINE_DEPENDENT_REORG\n+#undef  TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG xstormy16_reorg\n \n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "285a82f5dcae36a7a941fedc759b20d197ab5c67", "filename": "gcc/config/stormy16/stormy16.md", "status": "modified", "additions": 113, "deletions": 117, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ab9749e294898d1185384624f312ec32b4ba9f1/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ab9749e294898d1185384624f312ec32b4ba9f1/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.md?ref=5ab9749e294898d1185384624f312ec32b4ba9f1", "patch": "@@ -49,8 +49,6 @@\n     (CARRY_REG 16)\n   ]\n )\n-\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -59,11 +57,11 @@\n ;; ::::::::::::::::::::\n \n ; Categorize branches for the conditional in the length attribute.\n-(define_attr \"branch_class\" \"notdirectbranch,br12,bcc12,bcc8p2,bcc8p4\" \n+(define_attr \"branch_class\" \"notdirectbranch,br12,bcc12,bcc8p2,bcc8p4\"\n     (const_string \"notdirectbranch\"))\n \n ; The length of an instruction, used for branch shortening.\n-(define_attr \"length\" \"\" \n+(define_attr \"length\" \"\"\n   (cond\n    [(eq_attr \"branch_class\" \"br12\")\n      (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2046))\n@@ -135,7 +133,9 @@\n   [(set (match_operand:QI 0 \"nonimmediate_nonstack_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"{ xstormy16_expand_move (QImode, operands[0], operands[1]); DONE; }\")\n+  { xstormy16_expand_move (QImode, operands[0], operands[1]);\n+    DONE;\n+  })\n \n (define_insn \"movqi_internal\"\n   [(set (match_operand:QI 0 \"nonimmediate_nonstack_operand\" \"=r,m,e,e,T,r,S,W,e\")\n@@ -151,7 +151,7 @@\n    mov.b %0,%1\n    mov.b %0,%1\n    mov.b %0,%1\"\n-  [(set_attr_alternative \"length\" \n+  [(set_attr_alternative \"length\"\n \t     [(const_int 2)\n \t      (if_then_else (match_operand:QI 0 \"short_memory_operand\" \"\")\n \t\t\t    (const_int 2)\n@@ -187,7 +187,9 @@\n   [(set (match_operand:HI 0 \"nonimmediate_nonstack_operand\" \"\")\n \t(match_operand:HI 1 \"xs_hi_general_operand\" \"\"))]\n   \"\"\n-  \"{ xstormy16_expand_move (HImode, operands[0], operands[1]); DONE; }\")\n+  { xstormy16_expand_move (HImode, operands[0], operands[1]);\n+    DONE;\n+  })\n \n (define_insn \"movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_nonstack_operand\" \"=r,m,e,e,T,r,S,W,e\")\n@@ -203,7 +205,7 @@\n    mov.w %0,%1\n    mov.w %0,%1\n    mov.w %0,%1\"\n-  [(set_attr_alternative \"length\" \n+  [(set_attr_alternative \"length\"\n \t     [(const_int 2)\n \t      (if_then_else (match_operand:QI 0 \"short_memory_operand\" \"\")\n \t\t\t    (const_int 2)\n@@ -223,7 +225,9 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"{ xstormy16_expand_move (SImode, operands[0], operands[1]); DONE; }\")\n+  { xstormy16_expand_move (SImode, operands[0], operands[1]);\n+    DONE;\n+  })\n \n (define_insn_and_split \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,Q,r,m,e,&e,e,r,S\")\n@@ -232,8 +236,10 @@\n   \"#\"\n   \"reload_completed\"\n   [(pc)]\n-  \"{ xstormy16_split_move (SImode, operands[0], operands[1]); DONE; }\"\n-  [(set_attr_alternative \"length\" \n+  { xstormy16_split_move (SImode, operands[0], operands[1]);\n+    DONE;\n+  }\n+  [(set_attr_alternative \"length\"\n \t     [(const_int 4)\n \t      (const_int 4)\n \t      (const_int 4)\n@@ -249,7 +255,6 @@\n \t      (const_int 4)\n \t      (const_int 8)\n \t      (const_int 8)])])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -274,7 +279,6 @@\n    (set_attr_alternative \"length\"\n \t     [(const_int 4)\n \t      (const_int 8)])])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -352,8 +356,8 @@\n \t(plus:HI (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n \t\t\t  (zero_extend:HI (reg:BI CARRY_REG)))\n \t\t (match_operand:HI 2 \"xs_hi_nonmemory_operand\" \"L,Ir,i\")))\n-   (set (reg:BI CARRY_REG) \n-        (truncate:BI (lshiftrt:SI (plus:SI (plus:SI \n+   (set (reg:BI CARRY_REG)\n+        (truncate:BI (lshiftrt:SI (plus:SI (plus:SI\n \t\t\t\t\t    (zero_extend:SI (match_dup 1))\n \t\t\t\t\t    (zero_extend:SI (reg:BI CARRY_REG)))\n \t\t\t\t\t   (zero_extend:SI (match_dup 2)))\n@@ -391,7 +395,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n \t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0,0\")\n \t\t  (match_operand:HI 2 \"xs_hi_nonmemory_operand\" \"L,Ir,i\")))\n-   (set (reg:BI CARRY_REG) \n+   (set (reg:BI CARRY_REG)\n         (truncate:BI (lshiftrt:SI (minus:SI (zero_extend:SI (match_dup 1))\n \t\t\t\t\t    (zero_extend:SI (match_dup 2)))\n \t\t\t\t  (const_int 16))))]\n@@ -405,10 +409,10 @@\n (define_insn \"subchi5\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n \t(minus:HI (minus:HI (match_operand:HI 1 \"register_operand\" \"0,0,0\")\n-\t\t\t  (zero_extend:HI (reg:BI CARRY_REG))) \n+\t\t\t  (zero_extend:HI (reg:BI CARRY_REG)))\n \t\t (match_operand:HI 2 \"xs_hi_nonmemory_operand\" \"L,Ir,i\")))\n-   (set (reg:BI CARRY_REG) \n-        (truncate:BI (lshiftrt:SI (minus:SI (minus:SI \n+   (set (reg:BI CARRY_REG)\n+        (truncate:BI (lshiftrt:SI (minus:SI (minus:SI\n \t\t\t\t\t     (zero_extend:SI (match_dup 1))\n \t\t\t\t\t     (zero_extend:SI (reg:BI CARRY_REG)))\n \t\t\t\t\t    (zero_extend:SI (match_dup 2)))\n@@ -500,7 +504,6 @@\n \t      (clobber (reg:BI CARRY_REG))])]\n   \"\"\n   \"\")\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -534,7 +537,6 @@\n    (clobber (reg:BI CARRY_REG))]\n   \"\"\n   \"shr %0,%2\")\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -564,13 +566,12 @@\n   [(set (match_dup 3)\n \t(and:QI (match_dup 4)\n \t\t(match_dup 5)))]\n-  \"{ int s = ((INTVAL (operands[2]) & 0xff) == 0xff) ? 1 : 0;\n-     operands[3] = simplify_gen_subreg (QImode, operands[0], HImode, s);\n-     operands[4] = simplify_gen_subreg (QImode, operands[1], HImode, s);\n-     operands[5] = simplify_gen_subreg (QImode, operands[2], HImode, s);\n-     operands[5] = GEN_INT (INTVAL (operands[5]) | ~(HOST_WIDE_INT)0xff);\n-   }\n-\")\n+  { int s = ((INTVAL (operands[2]) & 0xff) == 0xff) ? 1 : 0;\n+    operands[3] = simplify_gen_subreg (QImode, operands[0], HImode, s);\n+    operands[4] = simplify_gen_subreg (QImode, operands[1], HImode, s);\n+    operands[5] = simplify_gen_subreg (QImode, operands[2], HImode, s);\n+    operands[5] = GEN_INT (INTVAL (operands[5]) | ~ (HOST_WIDE_INT) 0xff);\n+  })\n \n ;; Inclusive OR, 16-bit integers\n (define_insn \"iorhi3\"\n@@ -594,13 +595,12 @@\n   [(set (match_dup 3)\n \t(ior:QI (match_dup 4)\n \t\t(match_dup 5)))]\n-  \"{ int s = ((INTVAL (operands[2]) & 0xff) == 0x00) ? 1 : 0;\n-     operands[3] = simplify_gen_subreg (QImode, operands[0], HImode, s);\n-     operands[4] = simplify_gen_subreg (QImode, operands[1], HImode, s);\n-     operands[5] = simplify_gen_subreg (QImode, operands[2], HImode, s);\n-     operands[5] = GEN_INT (INTVAL (operands[5]) & 0xff);\n-   }\n-\")\n+  { int s = ((INTVAL (operands[2]) & 0xff) == 0x00) ? 1 : 0;\n+    operands[3] = simplify_gen_subreg (QImode, operands[0], HImode, s);\n+    operands[4] = simplify_gen_subreg (QImode, operands[1], HImode, s);\n+    operands[5] = simplify_gen_subreg (QImode, operands[2], HImode, s);\n+    operands[5] = GEN_INT (INTVAL (operands[5]) & 0xff);\n+  })\n \n ;; Exclusive OR, 16-bit integers\n (define_insn \"xorhi3\"\n@@ -620,7 +620,6 @@\n \t(not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n   \"\"\n   \"not %0\")\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -638,8 +637,10 @@\n   \"#\"\n   \"reload_completed\"\n   [(pc)]\n-  \"{ xstormy16_expand_arith (SImode, PLUS, operands[0], operands[1],\n-\t\t\t    operands[2]); DONE; } \"\n+  { xstormy16_expand_arith (SImode, PLUS, operands[0], operands[1],\n+\t\t\t    operands[2]);\n+    DONE;\n+  }\n   [(set_attr \"length\" \"4\")])\n \n ;; Subtraction\n@@ -652,16 +653,18 @@\n   \"#\"\n   \"reload_completed\"\n   [(pc)]\n-  \"{ xstormy16_expand_arith (SImode, MINUS, operands[0], operands[1],\n-\t\t\t    operands[2]); DONE; } \"\n+  { xstormy16_expand_arith (SImode, MINUS, operands[0], operands[1],\n+\t\t\t    operands[2]);\n+    DONE;\n+  }\n   [(set_attr \"length\" \"4\")])\n \n (define_expand \"negsi2\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (neg:SI (match_operand:SI 1 \"register_operand\" \"\")))\n \t      (clobber (reg:BI CARRY_REG))])]\n   \"\"\n-  \"{ operands[2] = gen_reg_rtx (HImode); }\")\n+  { operands[2] = gen_reg_rtx (HImode); })\n \n (define_insn_and_split \"*negsi2_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n@@ -671,8 +674,10 @@\n   \"#\"\n   \"reload_completed\"\n   [(pc)]\n-  \"{ xstormy16_expand_arith (SImode, NEG, operands[0], operands[0],\n-\t\t\t    operands[1]); DONE; }\")\n+  { xstormy16_expand_arith (SImode, NEG, operands[0], operands[0],\n+\t\t\t    operands[1]);\n+    DONE;\n+  })\n \n ;; ::::::::::::::::::::\n ;; ::\n@@ -688,9 +693,10 @@\n \t      (clobber (reg:BI CARRY_REG))\n \t      (clobber (match_dup 3))])]\n   \"\"\n-  \" if (! const_int_operand (operands[2], SImode))\n+  { if (! const_int_operand (operands[2], SImode))\n       FAIL;\n-   operands[3] = gen_reg_rtx (HImode); \")\n+    operands[3] = gen_reg_rtx (HImode);\n+  })\n \n ;; Arithmetic Shift Right\n (define_expand \"ashrsi3\"\n@@ -700,9 +706,10 @@\n \t      (clobber (reg:BI CARRY_REG))\n \t      (clobber (match_dup 3))])]\n   \"\"\n-  \" if (! const_int_operand (operands[2], SImode))\n+  { if (! const_int_operand (operands[2], SImode))\n       FAIL;\n-  operands[3] = gen_reg_rtx (HImode); \")\n+    operands[3] = gen_reg_rtx (HImode);\n+  })\n \n ;; Logical Shift Right\n (define_expand \"lshrsi3\"\n@@ -712,9 +719,10 @@\n \t      (clobber (reg:BI CARRY_REG))\n \t      (clobber (match_dup 3))])]\n   \"\"\n-  \" if (! const_int_operand (operands[2], SImode))\n+  { if (! const_int_operand (operands[2], SImode))\n       FAIL;\n-   operands[3] = gen_reg_rtx (HImode); \")\n+    operands[3] = gen_reg_rtx (HImode);\n+  })\n \n (define_insn \"*shiftsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -724,11 +732,10 @@\n    (clobber (reg:BI CARRY_REG))\n    (clobber (match_operand:HI 3 \"\" \"=X,r\"))]\n   \"\"\n-  \"* return xstormy16_output_shift (SImode, GET_CODE (operands[4]), \n+  \"* return xstormy16_output_shift (SImode, GET_CODE (operands[4]),\n \t\t\t\t    operands[0], operands[2], operands[3]);\"\n   [(set_attr \"length\" \"6,10\")\n    (set_attr \"psw_operand\" \"clobber,clobber\")])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -745,12 +752,11 @@\n         (compare (match_operand:HI 0 \"register_operand\" \"\")\n   \t\t (match_operand:HI 1 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  xstormy16_compare_op0 = operands[0];\n-  xstormy16_compare_op1 = operands[1];\n-  DONE;\n-}\")\n+  {\n+    xstormy16_compare_op0 = operands[0];\n+    xstormy16_compare_op1 = operands[1];\n+    DONE;\n+  })\n \n ; There are no real SImode comparisons, but some can be emulated\n ; by performing a SImode subtract and looking at the condition flags.\n@@ -759,13 +765,11 @@\n         (compare (match_operand:SI 0 \"register_operand\" \"\")\n   \t\t (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  xstormy16_compare_op0 = operands[0];\n-  xstormy16_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n+  {\n+    xstormy16_compare_op0 = operands[0];\n+    xstormy16_compare_op1 = operands[1];\n+    DONE;\n+  })\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -776,58 +780,57 @@\n (define_expand \"beq\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (EQ, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (EQ, operands[0]); DONE; })\n \n (define_expand \"bne\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (NE, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (NE, operands[0]); DONE; })\n \n (define_expand \"bge\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (GE, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (GE, operands[0]); DONE; })\n \n (define_expand \"bgt\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (GT, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (GT, operands[0]); DONE; })\n \n (define_expand \"ble\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (LE, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (LE, operands[0]); DONE; })\n \n (define_expand \"blt\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (LT, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (LT, operands[0]); DONE; })\n \n (define_expand \"bgeu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (GEU, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (GEU, operands[0]); DONE; })\n \n (define_expand \"bgtu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (GTU, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (GTU, operands[0]); DONE; })\n \n (define_expand \"bleu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (LEU, operands[0]); DONE; }\")\n+  { xstormy16_emit_cbranch (LEU, operands[0]); DONE; })\n \n (define_expand \"bltu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"{ xstormy16_emit_cbranch (LTU, operands[0]); DONE; }\")\n-\n+  { xstormy16_emit_cbranch (LTU, operands[0]); DONE; })\n \n (define_insn \"cbranchhi\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (match_operator:HI 1 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\" \n+\t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\"\n \t\t\t\t\t\"r,e,L\")\n \t\t\t\t       (match_operand:HI 3 \"nonmemory_operand\"\n \t\t\t\t\t\t      \"r,L,e\")])\n@@ -843,9 +846,9 @@\n    (set_attr \"psw_operand\" \"0,0,1\")])\n \n (define_insn \"cbranchhi_neg\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (match_operator:HI 1 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\" \n+\t\t\t\t      [(match_operand:HI 2 \"nonmemory_operand\"\n \t\t\t\t\t\t\t \"r,e,L\")\n \t\t\t\t       (match_operand:HI 3 \"nonmemory_operand\"\n \t\t\t\t\t\t\t \"r,L,e\")])\n@@ -863,7 +866,7 @@\n (define_insn \"*eqbranchsi\"\n   [(set (pc)\n \t(if_then_else (match_operator:SI 1 \"equality_operator\"\n-\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\"\n \t\t\t\t\t\t\t \"r\")\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n@@ -880,9 +883,9 @@\n (define_insn_and_split \"*ineqbranchsi\"\n   [(set (pc)\n \t(if_then_else (match_operator:SI 1 \"xstormy16_ineqsi_operator\"\n-\t\t\t\t      [(match_operand:SI 2 \"register_operand\" \n+\t\t\t\t      [(match_operand:SI 2 \"register_operand\"\n \t\t\t\t\t\t\t \"r\")\n-\t\t\t\t       (match_operand:SI 3 \"nonmemory_operand\" \n+\t\t\t\t       (match_operand:SI 3 \"nonmemory_operand\"\n \t\t\t\t\t\t\t \"ri\")])\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))\n@@ -892,7 +895,7 @@\n   \"#\"\n   \"reload_completed\"\n   [(pc)]\n-  \"{ xstormy16_split_cbranch (SImode, operands[0], operands[1], operands[2]); DONE; }\"\n+  { xstormy16_split_cbranch (SImode, operands[0], operands[1], operands[2]); DONE; }\n   [(set_attr \"length\" \"8\")])\n \n (define_insn \"*ineqbranch_1\"\n@@ -914,7 +917,6 @@\n }\"\n   [(set_attr \"branch_class\" \"bcc8p2,bcc8p2,bcc8p4\")\n    (set_attr \"psw_operand\" \"2,2,2\")])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -1039,13 +1041,12 @@\n }\")\n \n (define_insn \"tablejump_pcrel\"\n-  [(set (pc) (mem:HI (plus:HI (pc) \n+  [(set (pc) (mem:HI (plus:HI (pc)\n \t\t\t      (match_operand:HI 0 \"register_operand\" \"r\"))))\n    (use (label_ref:SI (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"br %0\"\n   [(set_attr \"psw_operand\" \"nop\")])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -1063,11 +1064,10 @@\n (define_expand \"prologue\"\n   [(const_int 1)]\n   \"\"\n-  \"\n-{\n-  xstormy16_expand_prologue ();\n-  DONE;\n-}\")\n+  {\n+    xstormy16_expand_prologue ();\n+    DONE;\n+  })\n \n ;; Called after register allocation to add any instructions needed for\n ;; the epilogue.  Using an epilogue insn is favored compared to putting\n@@ -1079,12 +1079,10 @@\n (define_expand \"epilogue\"\n   [(const_int 2)]\n   \"\"\n-  \"\n-{\n-  xstormy16_expand_epilogue ();\n-  DONE;\n-}\")\n-\n+  {\n+    xstormy16_expand_epilogue ();\n+    DONE;\n+  })\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -1115,11 +1113,10 @@\n    (match_operand:QI 1 \"xstormy16_below100_or_register\" \"\")\n    (match_operand:QI 2 \"nonmemory_operand\" \"\")]\n   \"\"\n-  \"\n-{\n-  xstormy16_expand_iorqi3 (operands);\n-  DONE;\n-}\")\n+  {\n+    xstormy16_expand_iorqi3 (operands);\n+    DONE;\n+  })\n \n (define_insn \"iorqi3_internal\"\n   [(set (match_operand:QI 0 \"xstormy16_below100_or_register\" \"=Wr\")\n@@ -1155,11 +1152,10 @@\n    (match_operand:QI 1 \"xstormy16_below100_or_register\" \"\")\n    (match_operand:QI 2 \"nonmemory_operand\" \"\")]\n   \"\"\n-  \"\n-{\n-  xstormy16_expand_andqi3 (operands);\n-  DONE;\n-}\")\n+  {\n+    xstormy16_expand_andqi3 (operands);\n+    DONE;\n+  })\n \n (define_insn \"andqi3_internal\"\n   [(set (match_operand:QI 0 \"xstormy16_below100_or_register\" \"=Wr\")\n@@ -1209,7 +1205,7 @@\n ;; we have to code those separately.\n \n (define_insn \"*bclrx\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (eq:HI (and:QI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\")\n \t\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n \t\t\t     (const_int 0))\n@@ -1222,7 +1218,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bclrx2\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (zero_extract:HI\n \t\t       (xor:HI (subreg:HI\n \t\t\t\t(match_operand:QI 1 \"xstormy16_below100_operand\" \"W\") 0)\n@@ -1238,7 +1234,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bclrx3\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (eq:HI (and:HI (zero_extend:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\"))\n \t\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n \t\t\t     (const_int 0))\n@@ -1251,7 +1247,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bclr7\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (xor:HI (lshiftrt:HI (subreg:HI\n \t\t\t\t\t    (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\") 0)\n \t\t\t\t\t   (const_int 7))\n@@ -1265,7 +1261,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bclr15\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (ge:HI (sign_extend:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\"))\n \t\t\t     (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n@@ -1277,7 +1273,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bsetx\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (ne:HI (and:QI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\")\n \t\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n \t\t\t     (const_int 0))\n@@ -1290,7 +1286,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bsetx2\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (zero_extract:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\")\n \t\t\t\t       (const_int 1)\n \t\t\t\t       (match_operand:HI 2 \"immediate_operand\" \"i\"))\n@@ -1303,7 +1299,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bsetx3\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (ne:HI (and:HI (zero_extend:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\"))\n \t\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n \t\t\t     (const_int 0))\n@@ -1316,7 +1312,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bset7\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (lshiftrt:HI (subreg:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\") 0)\n \t\t\t\t   (const_int 7))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n@@ -1328,7 +1324,7 @@\n    (set_attr \"psw_operand\" \"nop\")])\n \n (define_insn \"*bset15\"\n-  [(set (pc) \n+  [(set (pc)\n \t(if_then_else (lt:HI (sign_extend:HI (match_operand:QI 1 \"xstormy16_below100_operand\" \"W\"))\n \t\t\t     (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))"}]}