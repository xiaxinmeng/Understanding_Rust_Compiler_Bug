{"sha": "e362a897655e3b92949b65a2b53e00fb3ab8ded0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM2MmE4OTc2NTVlM2I5Mjk0OWI2NWEyYjUzZTAwZmIzYWI4ZGVkMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-07-03T16:10:25Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-07-03T16:31:04Z"}, "message": "Extend store merging to STRING_CST\n\nThe GIMPLE store merging pass doesn't merge STRING_CSTs in the general\ncase, although they are accepted by native_encode_expr; the reason is\nthat the pass only works with integral modes, i.e. with chunks whose\nsize is a power of two.\n\nThere are two possible ways of extending it to handle STRING_CSTs:\n1) lift the condition of integral modes and treat STRING_CSTs as\nother _CST nodes but with arbitrary size; 2) implement a specific\nand separate handling for STRING_CSTs.\n\nThe attached patch implements 2) for the following reasons: on the\none hand, even in Ada where character strings are first-class citizens,\ncases where merging STRING_CSTs with other *_CST nodes would be possible\nare quite rare in practice; on the other hand, string concatenations\nhappen more naturally and frequently thanks to the \"&\" operator, giving\nrise to merging opportunities.\n\ngcc/ChangeLog:\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Fold calls that\n\twere initially created for the assignment of a variable-sized\n\tobject and whose source is now a string constant.\n\t* gimple-ssa-store-merging.c (struct merged_store_group): Document\n\tSTRING_CST for rhs_code field.\n\tAdd string_concatenation boolean field.\n\t(merged_store_group::merged_store_group): Initialize it as well as\n\tbit_insertion here.\n\t(merged_store_group::do_merge): Set it upon seeing a STRING_CST.\n\tAlso set bit_insertion here upon seeing a BIT_INSERT_EXPR.\n\t(merged_store_group::apply_stores): Clear it for small regions.\n\tDo not create a power-of-2-sized buffer if it is still true.\n\tAnd do not set bit_insertion here again.\n\t(encode_tree_to_bitpos): Deal with BLKmode for the expression.\n\t(merged_store_group::can_be_merged_into): Deal with STRING_CST.\n\t(imm_store_chain_info::coalesce_immediate_stores): Set bit_insertion\n\tto true after changing MEM_REF stores into BIT_INSERT_EXPR stores.\n\t(count_multiple_uses): Return 0 for STRING_CST.\n\t(split_group): Do not split the group for a string concatenation.\n\t(imm_store_chain_info::output_merged_store): Constify and rename\n\tsome local variables.  Build an array type as destination type\n\tfor a string concatenation, as well as a zero mask, and call\n\tbuild_string to build the source.\n\t(lhs_valid_for_store_merging_p): Return true for VIEW_CONVERT_EXPR.\n\t(pass_store_merging::process_store): Accept STRING_CST on the RHS.\n\t* gimple.h (gimple_call_alloca_for_var_p): New accessor function.\n\t* gimplify.c (gimplify_modify_expr_to_memcpy): Set alloca_for_var.\n\t* tree.h (CALL_ALLOCA_FOR_VAR_P): Document it for BUILT_IN_MEMCPY.\n\ngcc/testsuite/ChangeLog:\n\t* gnat.dg/opt87.adb: New test.\n\t* gnat.dg/opt87_pkg.ads: New helper.\n\t* gnat.dg/opt87_pkg.adb: Likewise.", "tree": {"sha": "4a6123efd03f9969c0a3124c6add9061e421a983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a6123efd03f9969c0a3124c6add9061e421a983"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e362a897655e3b92949b65a2b53e00fb3ab8ded0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e362a897655e3b92949b65a2b53e00fb3ab8ded0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e362a897655e3b92949b65a2b53e00fb3ab8ded0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e362a897655e3b92949b65a2b53e00fb3ab8ded0/comments", "author": null, "committer": null, "parents": [{"sha": "b9a15a8325ba89b926e3c437b7961829a6b2fa2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a15a8325ba89b926e3c437b7961829a6b2fa2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a15a8325ba89b926e3c437b7961829a6b2fa2b"}], "stats": {"total": 290, "additions": 205, "deletions": 85}, "files": [{"sha": "72c5e43300ab3a0a9d883d4e3462b7ff4ffc00b3", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -700,7 +700,6 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n   gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n   tree len = gimple_call_arg (stmt, 2);\n-  tree destvar, srcvar;\n   location_t loc = gimple_location (stmt);\n \n   /* If the LEN parameter is a constant zero or in range where\n@@ -741,7 +740,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n     }\n   else\n     {\n-      tree srctype, desttype;\n+      tree srctype, desttype, destvar, srcvar, srcoff;\n       unsigned int src_align, dest_align;\n       tree off0;\n       const char *tmp_str;\n@@ -991,7 +990,9 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n       /* Choose between src and destination type for the access based\n          on alignment, whether the access constitutes a register access\n \t and whether it may actually expose a declaration for SSA rewrite\n-\t or SRA decomposition.  */\n+\t or SRA decomposition.  Also try to expose a string constant, we\n+\t might be able to concatenate several of them later into a single\n+\t string store.  */\n       destvar = NULL_TREE;\n       srcvar = NULL_TREE;\n       if (TREE_CODE (dest) == ADDR_EXPR\n@@ -1008,7 +1009,16 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t       && (is_gimple_reg_type (srctype)\n \t\t   || dest_align >= TYPE_ALIGN (srctype)))\n \tsrcvar = fold_build2 (MEM_REF, srctype, src, off0);\n-      if (srcvar == NULL_TREE && destvar == NULL_TREE)\n+      /* FIXME: Don't transform copies from strings with known original length.\n+\t As soon as strlenopt tests that rely on it for passing are adjusted,\n+\t this hack can be removed.  */\n+      else if (gimple_call_alloca_for_var_p (stmt)\n+\t       && (srcvar = string_constant (src, &srcoff, NULL, NULL))\n+\t       && integer_zerop (srcoff)\n+\t       && tree_int_cst_equal (TYPE_SIZE_UNIT (TREE_TYPE (srcvar)), len)\n+\t       && dest_align >= TYPE_ALIGN (TREE_TYPE (srcvar)))\n+\tsrctype = TREE_TYPE (srcvar);\n+      else\n \treturn false;\n \n       /* Now that we chose an access type express the other side in\n@@ -1071,19 +1081,29 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t  goto set_vop_and_replace;\n \t}\n \n-      /* We get an aggregate copy.  Use an unsigned char[] type to\n-\t perform the copying to preserve padding and to avoid any issues\n-\t with TREE_ADDRESSABLE types or float modes behavior on copying.  */\n-      desttype = build_array_type_nelts (unsigned_char_type_node,\n-\t\t\t\t\t tree_to_uhwi (len));\n-      srctype = desttype;\n-      if (src_align > TYPE_ALIGN (srctype))\n-\tsrctype = build_aligned_type (srctype, src_align);\n+      /* We get an aggregate copy.  If the source is a STRING_CST, then\n+\t directly use its type to perform the copy.  */\n+      if (TREE_CODE (srcvar) == STRING_CST)\n+\t  desttype = srctype;\n+\n+      /* Or else, use an unsigned char[] type to perform the copy in order\n+\t to preserve padding and to avoid any issues with TREE_ADDRESSABLE\n+\t types or float modes behavior on copying.  */\n+      else\n+\t{\n+\t  desttype = build_array_type_nelts (unsigned_char_type_node,\n+\t\t\t\t\t     tree_to_uhwi (len));\n+\t  srctype = desttype;\n+\t  if (src_align > TYPE_ALIGN (srctype))\n+\t    srctype = build_aligned_type (srctype, src_align);\n+\t  srcvar = fold_build2 (MEM_REF, srctype, src, off0);\n+\t}\n+\n       if (dest_align > TYPE_ALIGN (desttype))\n \tdesttype = build_aligned_type (desttype, dest_align);\n-      new_stmt\n-\t= gimple_build_assign (fold_build2 (MEM_REF, desttype, dest, off0),\n-\t\t\t       fold_build2 (MEM_REF, srctype, src, off0));\n+      destvar = fold_build2 (MEM_REF, desttype, dest, off0);\n+      new_stmt = gimple_build_assign (destvar, srcvar);\n+\n set_vop_and_replace:\n       gimple_move_vops (new_stmt, stmt);\n       if (!lhs)"}, {"sha": "8c195584eed84d8664630fad85e42aab72db93e6", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 129, "deletions": 69, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -1366,9 +1366,9 @@ class store_immediate_info\n   unsigned HOST_WIDE_INT bitregion_end;\n   gimple *stmt;\n   unsigned int order;\n-  /* INTEGER_CST for constant stores, MEM_REF for memory copy,\n-     BIT_*_EXPR for logical bitwise operation, BIT_INSERT_EXPR\n-     for bit insertion.\n+  /* INTEGER_CST for constant store, STRING_CST for string store,\n+     MEM_REF for memory copy, BIT_*_EXPR for logical bitwise operation,\n+     BIT_INSERT_EXPR for bit insertion.\n      LROTATE_EXPR if it can be only bswap optimized and\n      ops are not really meaningful.\n      NOP_EXPR if bswap optimization detected identity, ops\n@@ -1444,6 +1444,7 @@ class merged_store_group\n   unsigned int first_order;\n   unsigned int last_order;\n   bool bit_insertion;\n+  bool string_concatenation;\n   bool only_constants;\n   unsigned int first_nonmergeable_order;\n   int lp_nr;\n@@ -1654,7 +1655,10 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n     {\n       fixed_size_mode mode\n \t= as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (expr)));\n-      byte_size = GET_MODE_SIZE (mode);\n+      byte_size\n+\t= mode == BLKmode\n+\t? tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (expr)))\n+\t: GET_MODE_SIZE (mode);\n     }\n   /* Allocate an extra byte so that we have space to shift into.  */\n   byte_size++;\n@@ -1811,7 +1815,8 @@ merged_store_group::merged_store_group (store_immediate_info *info)\n      width has been finalized.  */\n   val = NULL;\n   mask = NULL;\n-  bit_insertion = false;\n+  bit_insertion = info->rhs_code == BIT_INSERT_EXPR;\n+  string_concatenation = info->rhs_code == STRING_CST;\n   only_constants = info->rhs_code == INTEGER_CST;\n   first_nonmergeable_order = ~0U;\n   lp_nr = info->lp_nr;\n@@ -1864,12 +1869,12 @@ merged_store_group::can_be_merged_into (store_immediate_info *info)\n   if (info->rhs_code == stores[0]->rhs_code)\n     return true;\n \n-  /* BIT_INSERT_EXPR is compatible with INTEGER_CST.  */\n+  /* BIT_INSERT_EXPR is compatible with INTEGER_CST if no STRING_CST.  */\n   if (info->rhs_code == BIT_INSERT_EXPR && stores[0]->rhs_code == INTEGER_CST)\n-    return true;\n+    return !string_concatenation;\n \n   if (stores[0]->rhs_code == BIT_INSERT_EXPR && info->rhs_code == INTEGER_CST)\n-    return true;\n+    return !string_concatenation;\n \n   /* We can turn MEM_REF into BIT_INSERT_EXPR for bit-field stores, but do it\n      only for small regions since this can generate a lot of instructions.  */\n@@ -1879,15 +1884,26 @@ merged_store_group::can_be_merged_into (store_immediate_info *info)\n       && info->bitregion_start == stores[0]->bitregion_start\n       && info->bitregion_end == stores[0]->bitregion_end\n       && info->bitregion_end - info->bitregion_start <= MAX_FIXED_MODE_SIZE)\n-    return true;\n+    return !string_concatenation;\n \n   if (stores[0]->rhs_code == MEM_REF\n       && (info->rhs_code == INTEGER_CST\n \t  || info->rhs_code == BIT_INSERT_EXPR)\n       && info->bitregion_start == stores[0]->bitregion_start\n       && info->bitregion_end == stores[0]->bitregion_end\n       && info->bitregion_end - info->bitregion_start <= MAX_FIXED_MODE_SIZE)\n-    return true;\n+    return !string_concatenation;\n+\n+  /* STRING_CST is compatible with INTEGER_CST if no BIT_INSERT_EXPR.  */\n+  if (info->rhs_code == STRING_CST\n+      && stores[0]->rhs_code == INTEGER_CST\n+      && stores[0]->bitsize == CHAR_BIT)\n+    return !bit_insertion;\n+\n+  if (stores[0]->rhs_code == STRING_CST\n+      && info->rhs_code == INTEGER_CST\n+      && info->bitsize == CHAR_BIT)\n+    return !bit_insertion;\n \n   return false;\n }\n@@ -1936,6 +1952,21 @@ merged_store_group::do_merge (store_immediate_info *info)\n       first_order = info->order;\n       first_stmt = stmt;\n     }\n+\n+  /* We need to use extraction if there is any bit-field.  */\n+  if (info->rhs_code == BIT_INSERT_EXPR)\n+    {\n+      bit_insertion = true;\n+      gcc_assert (!string_concatenation);\n+    }\n+\n+  /* We need to use concatenation if there is any string.  */\n+  if (info->rhs_code == STRING_CST)\n+    {\n+      string_concatenation = true;\n+      gcc_assert (!bit_insertion);\n+    }\n+\n   if (info->rhs_code != INTEGER_CST)\n     only_constants = false;\n }\n@@ -1976,23 +2007,33 @@ merged_store_group::merge_overlapping (store_immediate_info *info)\n bool\n merged_store_group::apply_stores ()\n {\n+  store_immediate_info *info;\n+  unsigned int i;\n+\n   /* Make sure we have more than one store in the group, otherwise we cannot\n      merge anything.  */\n   if (bitregion_start % BITS_PER_UNIT != 0\n       || bitregion_end % BITS_PER_UNIT != 0\n       || stores.length () == 1)\n     return false;\n \n-  stores.qsort (sort_by_order);\n-  store_immediate_info *info;\n-  unsigned int i;\n+  buf_size = (bitregion_end - bitregion_start) / BITS_PER_UNIT;\n+\n+  /* Really do string concatenation for large strings only.  */\n+  if (buf_size <= MOVE_MAX)\n+    string_concatenation = false;\n+\n   /* Create a power-of-2-sized buffer for native_encode_expr.  */\n-  buf_size = 1 << ceil_log2 ((bitregion_end - bitregion_start) / BITS_PER_UNIT);\n+  if (!string_concatenation)\n+    buf_size = 1 << ceil_log2 (buf_size);\n+\n   val = XNEWVEC (unsigned char, 2 * buf_size);\n   mask = val + buf_size;\n   memset (val, 0, buf_size);\n   memset (mask, ~0U, buf_size);\n \n+  stores.qsort (sort_by_order);\n+\n   FOR_EACH_VEC_ELT (stores, i, info)\n     {\n       unsigned int pos_in_buffer = info->bitpos - bitregion_start;\n@@ -2004,14 +2045,9 @@ merged_store_group::apply_stores ()\n       else\n \tcst = NULL_TREE;\n       bool ret = true;\n-      if (cst)\n-\t{\n-\t  if (info->rhs_code == BIT_INSERT_EXPR)\n-\t    bit_insertion = true;\n-\t  else\n-\t    ret = encode_tree_to_bitpos (cst, val, info->bitsize,\n-\t\t\t\t\t pos_in_buffer, buf_size);\n-\t}\n+      if (cst && info->rhs_code != BIT_INSERT_EXPR)\n+\tret = encode_tree_to_bitpos (cst, val, info->bitsize, pos_in_buffer,\n+\t\t\t\t     buf_size);\n       unsigned char *m = mask + (pos_in_buffer / BITS_PER_UNIT);\n       if (BYTES_BIG_ENDIAN)\n \tclear_bit_region_be (m, (BITS_PER_UNIT - 1\n@@ -2033,6 +2069,8 @@ merged_store_group::apply_stores ()\n \t      dump_char_array (dump_file, mask, buf_size);\n \t      if (bit_insertion)\n \t\tfputs (\"  bit insertion is required\\n\", dump_file);\n+\t      if (string_concatenation)\n+\t\tfputs (\"  string concatenation is required\\n\", dump_file);\n \t    }\n \t  else\n \t    fprintf (dump_file, \"Failed to merge stores\\n\");\n@@ -2920,6 +2958,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\t      infoj->ops[0].val = gimple_assign_rhs1 (infoj->stmt);\n \t\t      infoj->ops[0].base_addr = NULL_TREE;\n \t\t    }\n+\t\t  merged_store->bit_insertion = true;\n \t\t}\n \t      if ((infof->ops[0].base_addr\n \t\t   ? compatible_load_p (merged_store, info, base_addr, 0)\n@@ -3147,6 +3186,7 @@ count_multiple_uses (store_immediate_info *info)\n   switch (info->rhs_code)\n     {\n     case INTEGER_CST:\n+    case STRING_CST:\n       return 0;\n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n@@ -3242,13 +3282,14 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \n   gcc_assert ((size % BITS_PER_UNIT == 0) && (pos % BITS_PER_UNIT == 0));\n \n+  /* For bswap framework using sets of stores, all the checking has been done\n+     earlier in try_coalesce_bswap and the result always needs to be emitted\n+     as a single store.  Likewise for string concatenation,  */\n   if (group->stores[0]->rhs_code == LROTATE_EXPR\n-      || group->stores[0]->rhs_code == NOP_EXPR)\n+      || group->stores[0]->rhs_code == NOP_EXPR\n+      || group->string_concatenation)\n     {\n       gcc_assert (!bzero_first);\n-      /* For bswap framework using sets of stores, all the checking\n-\t has been done earlier in try_coalesce_bswap and needs to be\n-\t emitted as a single store.  */\n       if (total_orig)\n \t{\n \t  /* Avoid the old/new stmt count heuristics.  It should be\n@@ -3662,16 +3703,12 @@ invert_op (split_store *split_store, int idx, tree int_type, tree &mask)\n bool\n imm_store_chain_info::output_merged_store (merged_store_group *group)\n {\n-  split_store *split_store;\n-  unsigned int i;\n-  unsigned HOST_WIDE_INT start_byte_pos\n+  const unsigned HOST_WIDE_INT start_byte_pos\n     = group->bitregion_start / BITS_PER_UNIT;\n-\n   unsigned int orig_num_stmts = group->stores.length ();\n   if (orig_num_stmts < 2)\n     return false;\n \n-  auto_vec<class split_store *, 32> split_stores;\n   bool allow_unaligned_store\n     = !STRICT_ALIGNMENT && param_store_merging_allow_unaligned;\n   bool allow_unaligned_load = allow_unaligned_store;\n@@ -3680,6 +3717,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   unsigned int num_clobber_stmts = 0;\n   if (group->stores[0]->rhs_code == INTEGER_CST)\n     {\n+      unsigned int i;\n       FOR_EACH_VEC_ELT (group->stores, i, store)\n \tif (gimple_clobber_p (store->stmt))\n \t  num_clobber_stmts++;\n@@ -3729,7 +3767,10 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n       if ((pass_min & 2) == 0)\n \tbzero_first = false;\n     }\n-  unsigned total_orig, total_new;\n+\n+  auto_vec<class split_store *, 32> split_stores;\n+  split_store *split_store;\n+  unsigned total_orig, total_new, i;\n   split_group (group, allow_unaligned_store, allow_unaligned_load, bzero_first,\n \t       &split_stores, &total_orig, &total_new);\n \n@@ -3944,12 +3985,14 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \n   FOR_EACH_VEC_ELT (split_stores, i, split_store)\n     {\n-      unsigned HOST_WIDE_INT try_size = split_store->size;\n-      unsigned HOST_WIDE_INT try_pos = split_store->bytepos;\n-      unsigned HOST_WIDE_INT try_bitpos = try_pos * BITS_PER_UNIT;\n-      unsigned HOST_WIDE_INT align = split_store->align;\n+      const unsigned HOST_WIDE_INT try_size = split_store->size;\n+      const unsigned HOST_WIDE_INT try_pos = split_store->bytepos;\n+      const unsigned HOST_WIDE_INT try_bitpos = try_pos * BITS_PER_UNIT;\n+      const unsigned HOST_WIDE_INT try_align = split_store->align;\n+      const unsigned HOST_WIDE_INT try_offset = try_pos - start_byte_pos;\n       tree dest, src;\n       location_t loc;\n+\n       if (split_store->orig)\n \t{\n \t  /* If there is just a single non-clobber constituent store\n@@ -3976,12 +4019,20 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t    orig_stmts.safe_push (info->stmt);\n \t  tree offset_type\n \t    = get_alias_type_for_stmts (orig_stmts, false, &clique, &base);\n+\t  tree dest_type;\n \t  loc = get_location_for_stmts (orig_stmts);\n \t  orig_stmts.truncate (0);\n \n-\t  tree int_type = build_nonstandard_integer_type (try_size, UNSIGNED);\n-\t  int_type = build_aligned_type (int_type, align);\n-\t  dest = fold_build2 (MEM_REF, int_type, addr,\n+\t  if (group->string_concatenation)\n+\t    dest_type\n+\t      = build_array_type_nelts (char_type_node,\n+\t\t\t\t\ttry_size / BITS_PER_UNIT);\n+\t  else\n+\t    {\n+\t      dest_type = build_nonstandard_integer_type (try_size, UNSIGNED);\n+\t      dest_type = build_aligned_type (dest_type, try_align);\n+\t    }\n+\t  dest = fold_build2 (MEM_REF, dest_type, addr,\n \t\t\t      build_int_cst (offset_type, try_pos));\n \t  if (TREE_CODE (dest) == MEM_REF)\n \t    {\n@@ -3990,12 +4041,11 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t    }\n \n \t  tree mask;\n-\t  if (bswap_res)\n+\t  if (bswap_res || group->string_concatenation)\n \t    mask = integer_zero_node;\n \t  else\n-\t    mask = native_interpret_expr (int_type,\n-\t\t\t\t\t  group->mask + try_pos\n-\t\t\t\t\t  - start_byte_pos,\n+\t    mask = native_interpret_expr (dest_type,\n+\t\t\t\t\t  group->mask + try_offset,\n \t\t\t\t\t  group->buf_size);\n \n \t  tree ops[2];\n@@ -4006,6 +4056,12 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t      store_operand_info &op = split_store->orig_stores[0]->ops[j];\n \t      if (bswap_res)\n \t\tops[j] = bswap_res;\n+\t      else if (group->string_concatenation)\n+\t\t{\n+\t\t  ops[j] = build_string (try_size / BITS_PER_UNIT,\n+\t\t\t\t\t (const char *) group->val + try_offset);\n+\t\t  TREE_TYPE (ops[j]) = dest_type;\n+\t\t}\n \t      else if (op.base_addr)\n \t\t{\n \t\t  FOR_EACH_VEC_ELT (split_store->orig_stores, k, info)\n@@ -4047,8 +4103,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t       warnings in that case.  */\n \t\t    TREE_NO_WARNING (ops[j]) = 1;\n \n-\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n-\t\t\t\t\t      ops[j]);\n+\t\t  stmt = gimple_build_assign (make_ssa_name (dest_type), ops[j]);\n \t\t  gimple_set_location (stmt, load_loc);\n \t\t  if (gsi_bb (load_gsi[j]))\n \t\t    {\n@@ -4063,10 +4118,10 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t  ops[j] = gimple_assign_lhs (stmt);\n \t\t  tree xor_mask;\n \t\t  enum tree_code inv_op\n-\t\t    = invert_op (split_store, j, int_type, xor_mask);\n+\t\t    = invert_op (split_store, j, dest_type, xor_mask);\n \t\t  if (inv_op != NOP_EXPR)\n \t\t    {\n-\t\t      stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t      stmt = gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t\t\t  inv_op, ops[j], xor_mask);\n \t\t      gimple_set_location (stmt, load_loc);\n \t\t      ops[j] = gimple_assign_lhs (stmt);\n@@ -4079,9 +4134,8 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t    }\n \t\t}\n \t      else\n-\t\tops[j] = native_interpret_expr (int_type,\n-\t\t\t\t\t\tgroup->val + try_pos\n-\t\t\t\t\t\t- start_byte_pos,\n+\t\tops[j] = native_interpret_expr (dest_type,\n+\t\t\t\t\t\tgroup->val + try_offset,\n \t\t\t\t\t\tgroup->buf_size);\n \t    }\n \n@@ -4100,7 +4154,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t      orig_stmts.truncate (0);\n \n \t      stmt\n-\t\t= gimple_build_assign (make_ssa_name (int_type),\n+\t\t= gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t       split_store->orig_stores[0]->rhs_code,\n \t\t\t\t       ops[0], ops[1]);\n \t      gimple_set_location (stmt, bit_loc);\n@@ -4119,10 +4173,10 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t      src = gimple_assign_lhs (stmt);\n \t      tree xor_mask;\n \t      enum tree_code inv_op;\n-\t      inv_op = invert_op (split_store, 2, int_type, xor_mask);\n+\t      inv_op = invert_op (split_store, 2, dest_type, xor_mask);\n \t      if (inv_op != NOP_EXPR)\n \t\t{\n-\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t  stmt = gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t\t      inv_op, src, xor_mask);\n \t\t  gimple_set_location (stmt, bit_loc);\n \t\t  if (load_addr[1] == NULL_TREE && gsi_bb (load_gsi[0]))\n@@ -4142,17 +4196,17 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t  gimple_seq_add_stmt_without_update (&seq, stmt);\n \t\t  src = gimple_assign_lhs (stmt);\n \t\t}\n-\t      if (!useless_type_conversion_p (int_type, TREE_TYPE (src)))\n+\t      if (!useless_type_conversion_p (dest_type, TREE_TYPE (src)))\n \t\t{\n-\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t  stmt = gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t\t      NOP_EXPR, src);\n \t\t  gimple_seq_add_stmt_without_update (&seq, stmt);\n \t\t  src = gimple_assign_lhs (stmt);\n \t\t}\n-\t      inv_op = invert_op (split_store, 2, int_type, xor_mask);\n+\t      inv_op = invert_op (split_store, 2, dest_type, xor_mask);\n \t      if (inv_op != NOP_EXPR)\n \t\t{\n-\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t  stmt = gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t\t      inv_op, src, xor_mask);\n \t\t  gimple_set_location (stmt, loc);\n \t\t  gimple_seq_add_stmt_without_update (&seq, stmt);\n@@ -4210,18 +4264,18 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t    tem = gimple_build (&seq, loc,\n \t\t\t\t\tRSHIFT_EXPR, TREE_TYPE (tem), tem,\n \t\t\t\t\tbuild_int_cst (NULL_TREE, -shift));\n-\t\t  tem = gimple_convert (&seq, loc, int_type, tem);\n+\t\t  tem = gimple_convert (&seq, loc, dest_type, tem);\n \t\t  if (shift > 0)\n \t\t    tem = gimple_build (&seq, loc,\n-\t\t\t\t\tLSHIFT_EXPR, int_type, tem,\n+\t\t\t\t\tLSHIFT_EXPR, dest_type, tem,\n \t\t\t\t\tbuild_int_cst (NULL_TREE, shift));\n \t\t  src = gimple_build (&seq, loc,\n-\t\t\t\t      BIT_IOR_EXPR, int_type, tem, src);\n+\t\t\t\t      BIT_IOR_EXPR, dest_type, tem, src);\n \t\t}\n \n \t  if (!integer_zerop (mask))\n \t    {\n-\t      tree tem = make_ssa_name (int_type);\n+\t      tree tem = make_ssa_name (dest_type);\n \t      tree load_src = unshare_expr (dest);\n \t      /* The load might load some or all bits uninitialized,\n \t\t avoid -W*uninitialized warnings in that case.\n@@ -4237,28 +4291,28 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \n \t      /* FIXME: If there is a single chunk of zero bits in mask,\n \t\t perhaps use BIT_INSERT_EXPR instead?  */\n-\t      stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t      stmt = gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t\t  BIT_AND_EXPR, tem, mask);\n \t      gimple_set_location (stmt, loc);\n \t      gimple_seq_add_stmt_without_update (&seq, stmt);\n \t      tem = gimple_assign_lhs (stmt);\n \n \t      if (TREE_CODE (src) == INTEGER_CST)\n-\t\tsrc = wide_int_to_tree (int_type,\n+\t\tsrc = wide_int_to_tree (dest_type,\n \t\t\t\t\twi::bit_and_not (wi::to_wide (src),\n \t\t\t\t\t\t\t wi::to_wide (mask)));\n \t      else\n \t\t{\n \t\t  tree nmask\n-\t\t    = wide_int_to_tree (int_type,\n+\t\t    = wide_int_to_tree (dest_type,\n \t\t\t\t\twi::bit_not (wi::to_wide (mask)));\n-\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t  stmt = gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t\t      BIT_AND_EXPR, src, nmask);\n \t\t  gimple_set_location (stmt, loc);\n \t\t  gimple_seq_add_stmt_without_update (&seq, stmt);\n \t\t  src = gimple_assign_lhs (stmt);\n \t\t}\n-\t      stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t      stmt = gimple_build_assign (make_ssa_name (dest_type),\n \t\t\t\t\t  BIT_IOR_EXPR, tem, src);\n \t      gimple_set_location (stmt, loc);\n \t      gimple_seq_add_stmt_without_update (&seq, stmt);\n@@ -4455,6 +4509,7 @@ lhs_valid_for_store_merging_p (tree lhs)\n     case BIT_FIELD_REF:\n     case COMPONENT_REF:\n     case MEM_REF:\n+    case VIEW_CONVERT_EXPR:\n       return true;\n     default:\n       return false;\n@@ -4705,14 +4760,17 @@ pass_store_merging::process_store (gimple *stmt)\n   store_operand_info ops[2];\n   if (invalid)\n     ;\n+  else if (TREE_CODE (rhs) == STRING_CST)\n+    {\n+      rhs_code = STRING_CST;\n+      ops[0].val = rhs;\n+    }\n   else if (rhs_valid_for_store_merging_p (rhs))\n     {\n       rhs_code = INTEGER_CST;\n       ops[0].val = rhs;\n     }\n-  else if (TREE_CODE (rhs) != SSA_NAME)\n-    invalid = true;\n-  else\n+  else if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (rhs), *def_stmt1, *def_stmt2;\n       if (!is_gimple_assign (def_stmt))\n@@ -4824,6 +4882,8 @@ pass_store_merging::process_store (gimple *stmt)\n \t  invalid = false;\n \t}\n     }\n+  else\n+    invalid = true;\n \n   unsigned HOST_WIDE_INT const_bitsize, const_bitpos;\n   unsigned HOST_WIDE_INT const_bitregion_start, const_bitregion_end;"}, {"sha": "d64c47a7d0dd464d3fcf4d96ec77f33028d865f7", "filename": "gcc/gimple.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -3472,6 +3472,13 @@ gimple_call_alloca_for_var_p (gcall *s)\n   return (s->subcode & GF_CALL_ALLOCA_FOR_VAR) != 0;\n }\n \n+static inline bool\n+gimple_call_alloca_for_var_p (gimple *s)\n+{\n+  const gcall *gc = GIMPLE_CHECK2<gcall *> (s);\n+  return (gc->subcode & GF_CALL_ALLOCA_FOR_VAR) != 0;\n+}\n+\n /* If BY_DESCRIPTOR_P is true, GIMPLE_CALL S is an indirect call for which\n    pointers to nested function are descriptors instead of trampolines.  */\n "}, {"sha": "09a30cf69a5c2abb47ee856099244741e220cad1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -4329,6 +4329,7 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n   t = builtin_decl_implicit (BUILT_IN_MEMCPY);\n \n   gs = gimple_build_call (t, 3, to_ptr, from_ptr, size);\n+  gimple_call_set_alloca_for_var (gs, true);\n \n   if (want_value)\n     {"}, {"sha": "eb228dce6ccb7eb0a19471537a4dd8ee01ecff8c", "filename": "gcc/testsuite/gnat.dg/opt87.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87.adb?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-require-effective-target store_merge }\n+-- { dg-options \"-O2 -gnatn -fdump-tree-store-merging\" }\n+\n+with Opt87_Pkg; use Opt87_Pkg;\n+\n+procedure Opt87 is\n+begin\n+  Print (\"problem detected\", \"level 1\");\n+end;\n+\n+-- { dg-final { scan-tree-dump \"1 stores to replace old one of 6 stores\" \"store-merging\" } }"}, {"sha": "4bfdd0a8eff5d861d7ab7cb5d6ec6ffebc73d5b1", "filename": "gcc/testsuite/gnat.dg/opt87_pkg.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87_pkg.adb?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -0,0 +1,12 @@\n+with Text_IO; use Text_IO;\n+\n+package body Opt87_Pkg is\n+\n+  procedure Print (Msg : String; Location : String) is\n+    Final_Msg : constant String :=\n+      Ascii.Cr & \"info: \" & Msg & \" (\" & Location & \")\" & Ascii.Cr;\n+  begin\n+    Put_Line (Final_Msg);\n+  end;\n+\n+end Opt87_Pkg;"}, {"sha": "9b3462fe7b9bfe46985084bc72670b90cccf6a40", "filename": "gcc/testsuite/gnat.dg/opt87_pkg.ads", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt87_pkg.ads?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -0,0 +1,6 @@\n+package Opt87_Pkg is\n+\n+  procedure Print (Msg : String; Location : String);\n+  pragma Inline (Print);\n+\n+end Opt87_Pkg;"}, {"sha": "cf546ed9491309b57bd0f170af2987caaa7b43bd", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e362a897655e3b92949b65a2b53e00fb3ab8ded0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e362a897655e3b92949b65a2b53e00fb3ab8ded0", "patch": "@@ -925,7 +925,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n \n /* In a CALL_EXPR, if the function being called is BUILT_IN_ALLOCA, means that\n-   it has been built for the declaration of a variable-sized object.  */\n+   it has been built for the declaration of a variable-sized object and, if the\n+   function being called is BUILT_IN_MEMCPY, means that it has been built for\n+   the assignment of a variable-sized object.  */\n #define CALL_ALLOCA_FOR_VAR_P(NODE) \\\n   (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n "}]}