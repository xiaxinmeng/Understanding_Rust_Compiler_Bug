{"sha": "65739a688542b637b6a9f99aed2de84d9b84460c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU3MzlhNjg4NTQyYjYzN2I2YTlmOTlhZWQyZGU4NGQ5Yjg0NDYwYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-04-13T08:59:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-04-13T08:59:05Z"}, "message": "re PR tree-optimization/82965 (gcc.dg/vect/pr79347.c starts failing after r254379)\n\n\tPR tree-optimization/82965\n\tPR tree-optimization/83991\n\t* cfgloopanal.c (expected_loop_iterations_unbounded): Add\n\tby_profile_only parameter.\n\t* cfgloopmanip.c (scale_loop_profile): Further scale loop's profile\n        information if the loop was predicted to iterate too many times.\n\t* cfgloop.h (expected_loop_iterations_unbounded): Update prototype\n\nCo-Authored-By: Bin Cheng <bin.cheng@arm.com>\n\nFrom-SVN: r259368", "tree": {"sha": "bd43bc965dff5590c78fb5d6d802b3cbda1f4332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd43bc965dff5590c78fb5d6d802b3cbda1f4332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65739a688542b637b6a9f99aed2de84d9b84460c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65739a688542b637b6a9f99aed2de84d9b84460c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65739a688542b637b6a9f99aed2de84d9b84460c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65739a688542b637b6a9f99aed2de84d9b84460c/comments", "author": null, "committer": null, "parents": [{"sha": "2fdb5a23a3a65f949de21bdc3256a72029fd290d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fdb5a23a3a65f949de21bdc3256a72029fd290d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fdb5a23a3a65f949de21bdc3256a72029fd290d"}], "stats": {"total": 175, "additions": 116, "deletions": 59}, "files": [{"sha": "d28ab178bb5ac418e37271748548ccc222851b55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65739a688542b637b6a9f99aed2de84d9b84460c", "patch": "@@ -1,3 +1,14 @@\n+2018-04-13  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/82965\n+\tPR tree-optimization/83991\n+\t* cfgloopanal.c (expected_loop_iterations_unbounded): Add\n+\tby_profile_only parameter.\n+\t* cfgloopmanip.c (scale_loop_profile): Further scale loop's profile\n+        information if the loop was predicted to iterate too many times.\n+\t* cfgloop.h (expected_loop_iterations_unbounded): Update prototype\n+\n 2018-04-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/71991"}, {"sha": "af9bfabe094c31bfc7393c31a3f1698ae783c38d", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=65739a688542b637b6a9f99aed2de84d9b84460c", "patch": "@@ -388,7 +388,7 @@ extern void verify_loop_structure (void);\n /* Loop analysis.  */\n extern bool just_once_each_iteration_p (const struct loop *, const_basic_block);\n gcov_type expected_loop_iterations_unbounded (const struct loop *,\n-\t\t\t\t\t      bool *read_profile_p = NULL);\n+\t\t\t\t\t      bool *read_profile_p = NULL, bool by_profile_only = false);\n extern unsigned expected_loop_iterations (struct loop *);\n extern rtx doloop_condition_get (rtx_insn *);\n "}, {"sha": "3af0b2dbe72194abdefd2856822fab6f4d83e4d1", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=65739a688542b637b6a9f99aed2de84d9b84460c", "patch": "@@ -230,12 +230,17 @@ average_num_loop_insns (const struct loop *loop)\n }\n \n /* Returns expected number of iterations of LOOP, according to\n-   measured or guessed profile.  No bounding is done on the\n-   value.  */\n+   measured or guessed profile.\n+\n+   This functions attempts to return \"sane\" value even if profile\n+   information is not good enough to derive osmething.\n+   If BY_PROFILE_ONLY is set, this logic is bypassed and function\n+   return -1 in those scenarios.  */\n \n gcov_type\n expected_loop_iterations_unbounded (const struct loop *loop,\n-\t\t\t\t    bool *read_profile_p)\n+\t\t\t\t    bool *read_profile_p,\n+\t\t\t\t    bool by_profile_only)\n {\n   edge e;\n   edge_iterator ei;\n@@ -246,7 +251,11 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n \n   /* If we have no profile at all, use AVG_LOOP_NITER.  */\n   if (profile_status_for_fn (cfun) == PROFILE_ABSENT)\n-    expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+    {\n+      if (by_profile_only)\n+\treturn -1;\n+      expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+    }\n   else if (loop->latch && (loop->latch->count.initialized_p ()\n \t\t\t   || loop->header->count.initialized_p ()))\n     {\n@@ -260,9 +269,17 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n \t  count_in += e->count ();\n \n       if (!count_latch.initialized_p ())\n-\texpected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+\t{\n+          if (by_profile_only)\n+\t    return -1;\n+\t  expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+\t}\n       else if (!count_in.nonzero_p ())\n-\texpected = count_latch.to_gcov_type () * 2;\n+\t{\n+          if (by_profile_only)\n+\t    return -1;\n+\t  expected = count_latch.to_gcov_type () * 2;\n+\t}\n       else\n \t{\n \t  expected = (count_latch.to_gcov_type () + count_in.to_gcov_type ()\n@@ -273,11 +290,18 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n \t}\n     }\n   else\n-    expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+    {\n+      if (by_profile_only)\n+\treturn -1;\n+      expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+    }\n \n-  HOST_WIDE_INT max = get_max_loop_iterations_int (loop);\n-  if (max != -1 && max < expected)\n-    return max;\n+  if (!by_profile_only)\n+    {\n+      HOST_WIDE_INT max = get_max_loop_iterations_int (loop);\n+      if (max != -1 && max < expected)\n+        return max;\n+    }\n  \n   return expected;\n }"}, {"sha": "74c39dbe8faa812fb3db8072d65c7bb7cdf0f751", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65739a688542b637b6a9f99aed2de84d9b84460c/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=65739a688542b637b6a9f99aed2de84d9b84460c", "patch": "@@ -502,96 +502,118 @@ scale_loop_frequencies (struct loop *loop, profile_probability p)\n \n /* Scale profile in LOOP by P.\n    If ITERATION_BOUND is non-zero, scale even further if loop is predicted\n-   to iterate too many times.  */\n+   to iterate too many times.\n+   Before caling this function, preheader block profile should be already\n+   scaled to final count.  This is necessary because loop iterations are\n+   determined by comparing header edge count to latch ege count and thus\n+   they need to be scaled synchronously.  */\n \n void\n scale_loop_profile (struct loop *loop, profile_probability p,\n \t\t    gcov_type iteration_bound)\n {\n-  gcov_type iterations = expected_loop_iterations_unbounded (loop);\n-  edge e;\n+  edge e, preheader_e;\n   edge_iterator ei;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \";; Scaling loop %i with scale \",\n \t       loop->num);\n       p.dump (dump_file);\n-      fprintf (dump_file, \" bounding iterations to %i from guessed %i\\n\",\n-\t       (int)iteration_bound, (int)iterations);\n+      fprintf (dump_file, \" bounding iterations to %i\\n\",\n+\t       (int)iteration_bound);\n+    }\n+\n+  /* Scale the probabilities.  */\n+  scale_loop_frequencies (loop, p);\n+\n+  if (iteration_bound == 0)\n+    return;\n+\n+  gcov_type iterations = expected_loop_iterations_unbounded (loop, NULL, true);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \";; guessed iterations after scaling %i\\n\",\n+\t       (int)iterations);\n     }\n \n   /* See if loop is predicted to iterate too many times.  */\n-  if (iteration_bound && iterations > 0\n-      && p.apply (iterations) > iteration_bound)\n+  if (iterations <= iteration_bound)\n+    return;\n+\n+  preheader_e = loop_preheader_edge (loop);\n+\n+  /* We could handle also loops without preheaders, but bounding is\n+     currently used only by optimizers that have preheaders constructed.  */\n+  gcc_checking_assert (preheader_e);\n+  profile_count count_in = preheader_e->count ();\n+\n+  if (count_in > profile_count::zero ()\n+      && loop->header->count.initialized_p ())\n     {\n-      /* Fixing loop profile for different trip count is not trivial; the exit\n-\t probabilities has to be updated to match and frequencies propagated down\n-\t to the loop body.\n+      profile_count count_delta = profile_count::zero ();\n \n-\t We fully update only the simple case of loop with single exit that is\n-\t either from the latch or BB just before latch and leads from BB with\n-\t simple conditional jump.   This is OK for use in vectorizer.  */\n       e = single_exit (loop);\n       if (e)\n \t{\n \t  edge other_e;\n-\t  profile_count count_delta;\n-\n-          FOR_EACH_EDGE (other_e, ei, e->src->succs)\n+\t  FOR_EACH_EDGE (other_e, ei, e->src->succs)\n \t    if (!(other_e->flags & (EDGE_ABNORMAL | EDGE_FAKE))\n \t\t&& e != other_e)\n \t      break;\n \n \t  /* Probability of exit must be 1/iterations.  */\n \t  count_delta = e->count ();\n \t  e->probability = profile_probability::always ()\n-\t\t\t\t.apply_scale (1, iteration_bound);\n+\t\t\t\t    .apply_scale (1, iteration_bound);\n \t  other_e->probability = e->probability.invert ();\n-\t  count_delta -= e->count ();\n \n-\t  /* If latch exists, change its count, since we changed\n-\t     probability of exit.  Theoretically we should update everything from\n-\t     source of exit edge to latch, but for vectorizer this is enough.  */\n-\t  if (loop->latch\n-\t      && loop->latch != e->src)\n+\t  /* In code below we only handle the following two updates.  */\n+\t  if (other_e->dest != loop->header\n+\t      && other_e->dest != loop->latch\n+\t      && (dump_file && (dump_flags & TDF_DETAILS)))\n \t    {\n-\t      loop->latch->count += count_delta;\n+\t      fprintf (dump_file, \";; giving up on update of paths from \"\n+\t\t       \"exit condition to latch\\n\");\n \t    }\n \t}\n+      else\n+        if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \";; Loop has multiple exit edges; \"\n+\t      \t\t      \"giving up on exit condition update\\n\");\n \n       /* Roughly speaking we want to reduce the loop body profile by the\n \t difference of loop iterations.  We however can do better if\n \t we look at the actual profile, if it is available.  */\n-      p = p.apply_scale (iteration_bound, iterations);\n-\n-      if (loop->header->count.initialized_p ())\n-\t{\n-\t  profile_count count_in = profile_count::zero ();\n-\n-\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\t    if (e->src != loop->latch)\n-\t      count_in += e->count ();\n+      p = profile_probability::always ();\n \n-\t  if (count_in > profile_count::zero () )\n-\t    {\n-\t      p = count_in.probability_in (loop->header->count.apply_scale\n-\t\t\t\t\t\t (iteration_bound, 1));\n-\t    }\n-\t}\n+      count_in = count_in.apply_scale (iteration_bound, 1);\n+      p = count_in.probability_in (loop->header->count);\n       if (!(p > profile_probability::never ()))\n \tp = profile_probability::very_unlikely ();\n-    }\n \n-  if (p >= profile_probability::always ()\n-      || !p.initialized_p ())\n-    return;\n+      if (p == profile_probability::always ()\n+\t  || !p.initialized_p ())\n+\treturn;\n \n-  /* Scale the actual probabilities.  */\n-  scale_loop_frequencies (loop, p);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \";; guessed iterations are now %i\\n\",\n-\t     (int)expected_loop_iterations_unbounded (loop));\n+      /* If latch exists, change its count, since we changed\n+\t probability of exit.  Theoretically we should update everything from\n+\t source of exit edge to latch, but for vectorizer this is enough.  */\n+      if (loop->latch && loop->latch != e->src)\n+\tloop->latch->count += count_delta;\n+\n+      /* Scale the probabilities.  */\n+      scale_loop_frequencies (loop, p);\n+\n+      /* Change latch's count back.  */\n+      if (loop->latch && loop->latch != e->src)\n+\tloop->latch->count -= count_delta;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \";; guessed iterations are now %i\\n\",\n+\t\t (int)expected_loop_iterations_unbounded (loop, NULL, true));\n+    }\n }\n \n /* Recompute dominance information for basic blocks outside LOOP.  */"}]}