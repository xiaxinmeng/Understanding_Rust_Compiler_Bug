{"sha": "b502ba3c7b960e353e9226b69847adf368293009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUwMmJhM2M3Yjk2MGUzNTNlOTIyNmI2OTg0N2FkZjM2ODI5MzAwOQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2015-05-22T10:30:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-22T10:30:37Z"}, "message": "atree.adb, [...]: Change name Needs_Actuals_Check to Check_Actuals.\n\n2015-05-22  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.adb, atree.ads, treepr.adb: Change name Needs_Actuals_Check to\n\tCheck_Actuals.\n\t* exp_ch4.adb (Expand_N_Op_Expon): Optimize 2**x in modular\n\tand overflow cases.\n\nFrom-SVN: r223538", "tree": {"sha": "b6bc7de2c27d87c0027c62ac94e2fb7165874082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6bc7de2c27d87c0027c62ac94e2fb7165874082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b502ba3c7b960e353e9226b69847adf368293009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b502ba3c7b960e353e9226b69847adf368293009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b502ba3c7b960e353e9226b69847adf368293009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b502ba3c7b960e353e9226b69847adf368293009/comments", "author": null, "committer": null, "parents": [{"sha": "fd9574340563929af49f53a7911aaac882dc81f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd9574340563929af49f53a7911aaac882dc81f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd9574340563929af49f53a7911aaac882dc81f1"}], "stats": {"total": 216, "additions": 162, "deletions": 54}, "files": [{"sha": "346fb54550b3fb57f4b2c7e3cee738c3e4bce3f5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b502ba3c7b960e353e9226b69847adf368293009", "patch": "@@ -1,3 +1,10 @@\n+2015-05-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.adb, atree.ads, treepr.adb: Change name Needs_Actuals_Check to\n+\tCheck_Actuals.\n+\t* exp_ch4.adb (Expand_N_Op_Expon): Optimize 2**x in modular\n+\tand overflow cases.\n+\n 2015-05-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_pakd.adb (Install_PAT): Propagate representation aspects"}, {"sha": "870d7ffa79e2f9317c0e20b993a0bc5a473216ea", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=b502ba3c7b960e353e9226b69847adf368293009", "patch": "@@ -594,9 +594,9 @@ package body Atree is\n          Set_Is_Ignored_Ghost_Node (New_Id);\n       end if;\n \n-      --  Clear Needs_Actual_Check to False\n+      --  Clear Check_Actuals to False\n \n-      Set_Needs_Actuals_Check (New_Id, False);\n+      Set_Check_Actuals (New_Id, False);\n \n       --  Specifically copy Paren_Count to deal with creating new table entry\n       --  if the parentheses count is at the maximum possible value already.\n@@ -655,6 +655,15 @@ package body Atree is\n           (Nodes.Table (E + 2).Field12'Unrestricted_Access)).Convention := Val;\n    end Basic_Set_Convention;\n \n+   -------------------\n+   -- Check_Actuals --\n+   -------------------\n+\n+   function Check_Actuals (N : Node_Id) return Boolean is\n+   begin\n+      return Flags.Table (N).Check_Actuals;\n+   end Check_Actuals;\n+\n    --------------------------\n    -- Check_Error_Detected --\n    --------------------------\n@@ -1493,15 +1502,6 @@ package body Atree is\n       Nodes.Table (New_Node).Rewrite_Ins := True;\n    end Mark_Rewrite_Insertion;\n \n-   -------------------------\n-   -- Needs_Actuals_Check --\n-   -------------------------\n-\n-   function Needs_Actuals_Check (N : Node_Id) return Boolean is\n-   begin\n-      return Flags.Table (N).Needs_Actuals_Check;\n-   end Needs_Actuals_Check;\n-\n    --------------\n    -- New_Copy --\n    --------------\n@@ -2053,6 +2053,15 @@ package body Atree is\n       Nodes.Table (N).Analyzed := Val;\n    end Set_Analyzed;\n \n+   -----------------------\n+   -- Set_Check_Actuals --\n+   -----------------------\n+\n+   procedure Set_Check_Actuals (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      Flags.Table (N).Check_Actuals := Val;\n+   end Set_Check_Actuals;\n+\n    ---------------------------\n    -- Set_Comes_From_Source --\n    ---------------------------\n@@ -2110,15 +2119,6 @@ package body Atree is\n       Flags.Table (N).Is_Ignored_Ghost_Node := Val;\n    end Set_Is_Ignored_Ghost_Node;\n \n-   -----------------------------\n-   -- Set_Needs_Actuals_Check --\n-   -----------------------------\n-\n-   procedure Set_Needs_Actuals_Check (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      Flags.Table (N).Needs_Actuals_Check := Val;\n-   end Set_Needs_Actuals_Check;\n-\n    -----------------------\n    -- Set_Original_Node --\n    -----------------------"}, {"sha": "e217ca0f462f436ade3c0903de52e12f5bef1cfb", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=b502ba3c7b960e353e9226b69847adf368293009", "patch": "@@ -608,6 +608,9 @@ package Atree is\n    function Analyzed                     (N : Node_Id) return Boolean;\n    pragma Inline (Analyzed);\n \n+   function Check_Actuals                (N : Node_Id) return Boolean;\n+   pragma Inline (Check_Actuals);\n+\n    function Comes_From_Source            (N : Node_Id) return Boolean;\n    pragma Inline (Comes_From_Source);\n \n@@ -620,9 +623,6 @@ package Atree is\n    function Is_Ignored_Ghost_Node        (N : Node_Id) return Boolean;\n    pragma Inline (Is_Ignored_Ghost_Node);\n \n-   function Needs_Actuals_Check          (N : Node_Id) return Boolean;\n-   pragma Inline (Needs_Actuals_Check);\n-\n    function Nkind                        (N : Node_Id) return Node_Kind;\n    pragma Inline (Nkind);\n \n@@ -898,6 +898,9 @@ package Atree is\n    procedure Set_Analyzed              (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Analyzed);\n \n+   procedure Set_Check_Actuals         (N : Node_Id; Val : Boolean := True);\n+   pragma Inline (Set_Check_Actuals);\n+\n    procedure Set_Comes_From_Source     (N : Node_Id; Val : Boolean);\n    pragma Inline (Set_Comes_From_Source);\n    --  Note that this routine is very rarely used, since usually the default\n@@ -914,9 +917,6 @@ package Atree is\n    procedure Set_Is_Ignored_Ghost_Node (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Is_Ignored_Ghost_Node);\n \n-   procedure Set_Needs_Actuals_Check   (N : Node_Id; Val : Boolean := True);\n-   pragma Inline (Set_Needs_Actuals_Check);\n-\n    procedure Set_Original_Node         (N : Node_Id; Val : Node_Id);\n    pragma Inline (Set_Original_Node);\n    --  Note that this routine is used only in very peculiar cases. In normal\n@@ -4142,7 +4142,7 @@ package Atree is\n          --  policy Ignore. The name of the flag should be Flag4, however this\n          --  requires changing the names of all remaining 300+ flags.\n \n-         Needs_Actuals_Check : Boolean;\n+         Check_Actuals : Boolean;\n          --  Flag set to indicate that the marked node is subject to the check\n          --  for writable actuals. See xxx for more details. Again it would be\n          --  more uniform to use some Flagx here, but that would be disruptive."}, {"sha": "b6326fc8613d7b2db333b73370381908036e106c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 126, "deletions": 25, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b502ba3c7b960e353e9226b69847adf368293009", "patch": "@@ -7653,42 +7653,47 @@ package body Exp_Ch4 is\n          end if;\n       end if;\n \n-      --  Case of (2 ** expression) appearing as an argument of an integer\n-      --  multiplication, or as the right argument of a division of a non-\n-      --  negative integer. In such cases we leave the node untouched, setting\n-      --  the flag Is_Natural_Power_Of_2_for_Shift set, then the expansion\n-      --  of the higher level node converts it into a shift.\n-\n-      --  Another case is 2 ** N in any other context. We simply convert\n-      --  this to 1 * 2 ** N, and then the above transformation applies.\n-\n-      --  Note: this transformation is not applicable for a modular type with\n-      --  a non-binary modulus in the multiplication case, since we get a wrong\n-      --  result if the shift causes an overflow before the modular reduction.\n+      --  Deal with optimizing 2 ** expression to shift where possible\n \n       --  Note: we used to check that Exptyp was an unsigned type. But that is\n       --  an unnecessary check, since if Exp is negative, we have a run-time\n       --  error that is either caught (so we get the right result) or we have\n       --  suppressed the check, in which case the code is erroneous anyway.\n \n-      if Nkind (Base) = N_Integer_Literal\n+      if Is_Integer_Type (Rtyp)\n+\n+        --  The base value must be safe, compile-time known, and exactly 2\n+\n+        and then Nkind (Base) = N_Integer_Literal\n         and then CRT_Safe_Compile_Time_Known_Value (Base)\n         and then Expr_Value (Base) = Uint_2\n+\n+        --  We only handle cases where the right type is a integer\n+\n         and then Is_Integer_Type (Root_Type (Exptyp))\n         and then Esize (Root_Type (Exptyp)) <= Esize (Standard_Integer)\n-        and then not Ovflo\n+\n+        --  This transformation is not applicable for a modular type with a\n+        --  nonbinary modulus because we do not handle modular reduction in\n+        --  a correct manner if we attempt this transformation in this case.\n+\n+        and then not Non_Binary_Modulus (Typ)\n       then\n-         --  First the multiply and divide cases\n+         --  Handle the cases where our parent is a division or multiplication\n+         --  specially. In these cases we can convert to using a shift at the\n+         --  parent level if we are not doing overflow checking, since it is\n+         --  too tricky to combine the overflow check at the parent level.\n \n-         if Nkind_In (Parent (N), N_Op_Divide, N_Op_Multiply) then\n+         if not Ovflo\n+           and then Nkind_In (Parent (N), N_Op_Divide, N_Op_Multiply)\n+         then\n             declare\n                P : constant Node_Id := Parent (N);\n                L : constant Node_Id := Left_Opnd (P);\n                R : constant Node_Id := Right_Opnd (P);\n \n             begin\n                if (Nkind (P) = N_Op_Multiply\n-                    and then not Non_Binary_Modulus (Typ)\n                     and then\n                       ((Is_Integer_Type (Etype (L)) and then R = N)\n                           or else\n@@ -7707,15 +7712,111 @@ package body Exp_Ch4 is\n                end if;\n             end;\n \n-         --  Now the other cases where we convert to 1 * (2 ** K)\n+         --  Here we just have 2 ** N on its own, so we can convert this to a\n+         --  shift node. We are prepared to deal with overflow here, and we\n+         --  also have to handle proper modular reduction for binary modular.\n \n-         elsif not Non_Binary_Modulus (Typ) then\n-            Rewrite (N,\n-              Make_Op_Multiply (Loc,\n-                Left_Opnd  => Make_Integer_Literal (Loc, 1),\n-                Right_Opnd => Relocate_Node (N)));\n-            Analyze_And_Resolve (N, Typ);\n-            return;\n+         else\n+            declare\n+               OK : Boolean;\n+               Lo : Uint;\n+               Hi : Uint;\n+\n+               MaxS : Uint;\n+               --  Maximum shift count with no overflow\n+\n+               TestS : Boolean;\n+               --  Set True if we must test the shift count\n+\n+            begin\n+               --  Compute maximum shift based on the underlying size. For a\n+               --  modular type this is one less than the size.\n+\n+               if Is_Modular_Integer_Type (Typ) then\n+\n+                  --  For modular integer types, this is the size of the value\n+                  --  being shifted minus one. Any larger values will cause\n+                  --  modular reduction to a result of zero. Note that we do\n+                  --  want the RM_Size here (e.g. mod 2 ** 7, we want a result\n+                  --  of 6, since 2**7 should be reduced to zero).\n+\n+                  MaxS := RM_Size (Rtyp) - 1;\n+\n+                  --  For signed integer types, we use the size of the value\n+                  --  being shifted minus 2. Larger values cause overflow.\n+\n+               else\n+                  MaxS := Esize (Rtyp) - 2;\n+               end if;\n+\n+               --  Determine range to see if it can be larger than MaxS\n+\n+               Determine_Range\n+                 (Right_Opnd (N), OK, Lo, Hi, Assume_Valid => True);\n+               TestS := (not OK) or else Hi > MaxS;\n+\n+               --  Signed integer case\n+\n+               if Is_Signed_Integer_Type (Typ) then\n+\n+                  --  Generate overflow check if overflow is active. Note that\n+                  --  we can simply ignore the possibility of overflow if the\n+                  --  flag is not set (means that overflow cannot happen or\n+                  --  that overflow checks are suppressed).\n+\n+                  if Ovflo and TestS then\n+                     Insert_Action (N,\n+                       Make_Raise_Constraint_Error (Loc,\n+                         Condition =>\n+                           Make_Op_Gt (Loc,\n+                             Left_Opnd  => Duplicate_Subexpr (Right_Opnd (N)),\n+                             Right_Opnd => Make_Integer_Literal (Loc, MaxS)),\n+                         Reason    => CE_Overflow_Check_Failed));\n+                  end if;\n+\n+                  --  Now rewrite node as Shift_Left (1, right-operand)\n+\n+                  Rewrite (N,\n+                    Make_Op_Shift_Left (Loc,\n+                      Left_Opnd  => Make_Integer_Literal (Loc, Uint_1),\n+                      Right_Opnd => Right_Opnd (N)));\n+\n+               --  Modular integer case\n+\n+               else pragma Assert (Is_Modular_Integer_Type (Typ));\n+\n+                  --  If shift count can be greater than MaxS, we need to wrap\n+                  --  the shift in a test that will reduce the result value to\n+                  --  zero if this shift count is exceeded.\n+\n+                  if TestS then\n+                     Rewrite (N,\n+                       Make_If_Expression (Loc,\n+                         Expressions => New_List (\n+                           Make_Op_Gt (Loc,\n+                             Left_Opnd  => Duplicate_Subexpr (Right_Opnd (N)),\n+                             Right_Opnd => Make_Integer_Literal (Loc, MaxS)),\n+\n+                           Make_Integer_Literal (Loc, Uint_0),\n+\n+                           Make_Op_Shift_Left (Loc,\n+                             Left_Opnd  => Make_Integer_Literal (Loc, Uint_1),\n+                             Right_Opnd => Right_Opnd (N)))));\n+\n+                  --  If we know shift count cannot be greater than MaxS, then\n+                  --  it is safe to just rewrite as a shift with no test.\n+\n+                  else\n+                     Rewrite (N,\n+                       Make_Op_Shift_Left (Loc,\n+                         Left_Opnd  => Make_Integer_Literal (Loc, Uint_1),\n+                         Right_Opnd => Right_Opnd (N)));\n+                  end if;\n+               end if;\n+\n+               Analyze_And_Resolve (N, Typ);\n+               return;\n+            end;\n          end if;\n       end if;\n "}, {"sha": "8ad81b9ed1c8fc6a526eeb64f337ba9723930777", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b502ba3c7b960e353e9226b69847adf368293009/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=b502ba3c7b960e353e9226b69847adf368293009", "patch": "@@ -1382,8 +1382,8 @@ package body Treepr is\n          Print_Header_Flag (\"ignored ghost\");\n       end if;\n \n-      if Needs_Actuals_Check (N) then\n-         Print_Header_Flag (\"needs actuals check\");\n+      if Check_Actuals (N) then\n+         Print_Header_Flag (\"check actuals\");\n       end if;\n \n       if Enumerate then"}]}