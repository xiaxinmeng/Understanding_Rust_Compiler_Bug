{"sha": "4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMyYTRiOTA3ZGMzZDc5MjU5NzQ3YjZmMjFiMTYzM2Q4ZTRjOTlhYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-12-29T01:30:32Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-12-29T01:30:32Z"}, "message": "re PR c++/13009 (Implicitly-defined assignment operator writes to wrong memory)\n\n\tPR c++/13009\n\t* call.c (build_special_member_call): Do not assume that we have a\n\tpointer to the complete object in an assignment operator.\n\n\tPR c++/13009\n\t* g++.dg/init/assign1.C: New test.\n\nFrom-SVN: r75189", "tree": {"sha": "95eb9b436bb199f883158f9eaef78ea125c612bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95eb9b436bb199f883158f9eaef78ea125c612bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/comments", "author": null, "committer": null, "parents": [{"sha": "6c5d63c80bb05f372f695a37e96b9a409793fed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5d63c80bb05f372f695a37e96b9a409793fed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5d63c80bb05f372f695a37e96b9a409793fed3"}], "stats": {"total": 62, "additions": 56, "deletions": 6}, "files": [{"sha": "3f85d7bcb89027b1ae63b67f861e687a7e3a450c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "patch": "@@ -1,3 +1,9 @@\n+2003-12-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/13009\n+\t* call.c (build_special_member_call): Do not assume that we have a\n+\tpointer to the complete object in an assignment operator.\n+\n 2003-12-28  Roger Sayle  <roger@eyesopen.com>\n \n \tPR c++/13070"}, {"sha": "5e75925901512c6f19f31aa117de8e37684843e6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "patch": "@@ -4865,14 +4865,23 @@ build_special_member_call (tree instance, tree name, tree args,\n \t  || name == deleting_dtor_identifier)\n \tmy_friendly_assert (args == NULL_TREE, 20020712);\n \n-      /* We must perform the conversion here so that we do not\n-\t subsequently check to see whether BINFO is an accessible\n-\t base.  (It is OK for a constructor to call a constructor in\n-\t an inaccessible base as long as the constructor being called\n-\t is accessible.)  */\n+      /* Convert to the base class, if necessary.  */\n       if (!same_type_ignoring_top_level_qualifiers_p \n \t  (TREE_TYPE (instance), BINFO_TYPE (binfo)))\n-\tinstance = convert_to_base_statically (instance, binfo);\n+\t{\n+\t  if (name != ansi_assopname (NOP_EXPR))\n+\t    /* For constructors and destructors, either the base is\n+\t       non-virtual, or it is virtual but we are doing the\n+\t       conversion from a constructor or destructor for the\n+\t       complete object.  In either case, we can convert\n+\t       statically.  */\n+\t    instance = convert_to_base_statically (instance, binfo);\n+\t  else\n+\t    /* However, for assignment operators, we must convert\n+\t       dynamically if the base is virtual.  */\n+\t    instance = build_base_path (PLUS_EXPR, instance,\n+\t\t\t\t\tbinfo, /*nonnull=*/1);\n+\t}\n     }\n   \n   my_friendly_assert (instance != NULL_TREE, 20020712);"}, {"sha": "0c13a2477a46d9f4d7082e4e9e7da823321ee672", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "patch": "@@ -1,3 +1,8 @@\n+2003-12-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/13009\n+\t* g++.dg/init/assign1.C: New test.\n+\n 2003-12-28  Roger Sayle  <roger@eyesopen.com>\n \n \tPR c++/13070"}, {"sha": "690a481910a39c2c9d6fa232697ad3ee5eec2339", "filename": "gcc/testsuite/g++.dg/init/assign1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fassign1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2a4b907dc3d79259747b6f21b1633d8e4c99aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fassign1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fassign1.C?ref=4c2a4b907dc3d79259747b6f21b1633d8e4c99aa", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/13009\n+// { dg-do run }\n+\n+struct A {\n+  char a;\n+};\n+\n+struct B: public virtual A {\n+  #if 0 // this piece of code works around the problem\n+  B& operator= (const B& other)\n+  {\n+    A::operator= (other);\n+  }\n+  #endif\n+};\n+\n+struct C: public B {\n+  char c;\n+};\n+\n+int main() {\n+  B b;\n+  b.a = 'b';\n+  C c;\n+  c.a = c.c = 'c';\n+  \n+  c.B::operator= (b);\n+  if (c.a != 'b' || c.c != 'c')\n+    return 1;\n+}"}]}