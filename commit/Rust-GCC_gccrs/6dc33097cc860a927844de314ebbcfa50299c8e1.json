{"sha": "6dc33097cc860a927844de314ebbcfa50299c8e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjMzMwOTdjYzg2MGE5Mjc4NDRkZTMxNGViYmNmYTUwMjk5YzhlMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2014-07-27T07:22:47Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2014-07-27T07:22:47Z"}, "message": "libgcov-driver.c (struct gcov_filename_aux): Rename ...\n\n\t* libgcov-driver.c (struct gcov_filename_aux): Rename ...\n\t(struct gcov_filename): ... here.  Include buffer and max length\n\tfields.\n\t(gcov_max_filename): Remove.\n\t(gi_filename): Remove.\n\t(gcov_exit_compute_summary): Compute max filename here.\n\t(gcov_exit_merge_gcda): Add filename parm, adjust.\n\t(gcov_exit_merge_summary): Likewise.\n\t(gcov_exit_dump_gcov): Adjust for struct gcov_filename changes.\n\t(gcov_exit): Likewise.\n\t(__gcov_init): Don't calculate max length here.\n\t* libgcov_util.c (max_filename_len): Remove.\n\t(read_gcda_file): Don't calculate max length here.\n\t(gcov_read_profile_dir): Don't propagate here.\n\t* libgcov-driver-system.c (alloc_filename_struct): Adjust for\n\tstruct gcov_filename changes.\n\t(gcov_exit_open_gcda_file): Likewise.\n\nFrom-SVN: r213092", "tree": {"sha": "becbbcae849b178f3b6e158a2dff934f7cfeb6fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/becbbcae849b178f3b6e158a2dff934f7cfeb6fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dc33097cc860a927844de314ebbcfa50299c8e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc33097cc860a927844de314ebbcfa50299c8e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc33097cc860a927844de314ebbcfa50299c8e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc33097cc860a927844de314ebbcfa50299c8e1/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "98fa5ef355d6b2a9700980760d940d8c66435bd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98fa5ef355d6b2a9700980760d940d8c66435bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98fa5ef355d6b2a9700980760d940d8c66435bd1"}], "stats": {"total": 232, "additions": 112, "deletions": 120}, "files": [{"sha": "60b857b5abce5c642700eaee448058989acda26a", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=6dc33097cc860a927844de314ebbcfa50299c8e1", "patch": "@@ -1,3 +1,23 @@\n+2014-07-27  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libgcov-driver.c (struct gcov_filename_aux): Rename ...\n+\t(struct gcov_filename): ... here.  Include buffer and max length\n+\tfields.\n+\t(gcov_max_filename): Remove.\n+\t(gi_filename): Remove.\n+\t(gcov_exit_compute_summary): Compute max filename here.\n+\t(gcov_exit_merge_gcda): Add filename parm, adjust.\n+\t(gcov_exit_merge_summary): Likewise.\n+\t(gcov_exit_dump_gcov): Adjust for struct gcov_filename changes.\n+\t(gcov_exit): Likewise.\n+\t(__gcov_init): Don't calculate max length here.\n+\t* libgcov_util.c (max_filename_len): Remove.\n+\t(read_gcda_file): Don't calculate max length here.\n+\t(gcov_read_profile_dir): Don't propagate here.\n+\t* libgcov-driver-system.c (alloc_filename_struct): Adjust for\n+\tstruct gcov_filename changes.\n+\t(gcov_exit_open_gcda_file): Likewise.\n+\n 2014-07-25  Nathan Sidwell  <nathan@acm.org>\n \n \t* libgcov-driver.c (set_gcov_dump_complete,"}, {"sha": "2f59f800262ebcf123f48c43e116687491505b0b", "filename": "libgcc/libgcov-driver-system.c", "status": "modified", "additions": 46, "deletions": 59, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2Flibgcov-driver-system.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2Flibgcov-driver-system.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver-system.c?ref=6dc33097cc860a927844de314ebbcfa50299c8e1", "patch": "@@ -83,118 +83,105 @@ create_file_directory (char *filename)\n }\n \n static void\n-allocate_filename_struct (struct gcov_filename_aux *gf)\n+allocate_filename_struct (struct gcov_filename *gf)\n {\n   const char *gcov_prefix;\n-  int gcov_prefix_strip = 0;\n   size_t prefix_length;\n-  char *gi_filename_up;\n+  int strip = 0;\n \n-  gcc_assert (gf);\n   {\n     /* Check if the level of dirs to strip off specified. */\n     char *tmp = getenv(\"GCOV_PREFIX_STRIP\");\n     if (tmp)\n       {\n-        gcov_prefix_strip = atoi (tmp);\n+        strip = atoi (tmp);\n         /* Do not consider negative values. */\n-        if (gcov_prefix_strip < 0)\n-          gcov_prefix_strip = 0;\n+        if (strip < 0)\n+          strip = 0;\n       }\n   }\n+  gf->strip = strip;\n \n   /* Get file name relocation prefix.  Non-absolute values are ignored. */\n   gcov_prefix = getenv(\"GCOV_PREFIX\");\n-  if (gcov_prefix)\n-    {\n-      prefix_length = strlen(gcov_prefix);\n-\n-      /* Remove an unnecessary trailing '/' */\n-      if (IS_DIR_SEPARATOR (gcov_prefix[prefix_length - 1]))\n-        prefix_length--;\n-    }\n-  else\n-    prefix_length = 0;\n+  prefix_length = gcov_prefix ? strlen (gcov_prefix) : 0;\n+  \n+  /* Remove an unnecessary trailing '/' */\n+  if (prefix_length && IS_DIR_SEPARATOR (gcov_prefix[prefix_length - 1]))\n+    prefix_length--;\n \n   /* If no prefix was specified and a prefix stip, then we assume\n      relative.  */\n-  if (gcov_prefix_strip != 0 && prefix_length == 0)\n+  if (!prefix_length && gf->strip)\n     {\n       gcov_prefix = \".\";\n       prefix_length = 1;\n     }\n-  /* Allocate and initialize the filename scratch space plus one.  */\n-  gi_filename = (char *) xmalloc (prefix_length + gcov_max_filename + 2);\n-  if (prefix_length)\n-    memcpy (gi_filename, gcov_prefix, prefix_length);\n-  gi_filename_up = gi_filename + prefix_length;\n+  gf->prefix = prefix_length;\n \n-  gf->gi_filename_up = gi_filename_up;\n-  gf->prefix_length = prefix_length;\n-  gf->gcov_prefix_strip = gcov_prefix_strip;\n+  /* Allocate and initialize the filename scratch space.  */\n+  gf->filename = (char *) xmalloc (gf->max_length + prefix_length + 2);\n+  if (prefix_length)\n+    memcpy (gf->filename, gcov_prefix, prefix_length);\n }\n \n /* Open a gcda file specified by GI_FILENAME.\n    Return -1 on error.  Return 0 on success.  */\n \n static int\n-gcov_exit_open_gcda_file (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf)\n+gcov_exit_open_gcda_file (struct gcov_info *gi_ptr,\n+\t\t\t  struct gcov_filename *gf)\n {\n-  int gcov_prefix_strip;\n-  size_t prefix_length;\n-  char *gi_filename_up;\n-  const char *fname, *s;\n+  const char *fname = gi_ptr->filename;\n+  char *dst = gf->filename + gf->prefix;\n \n-  gcov_prefix_strip = gf->gcov_prefix_strip;\n-  gi_filename_up = gf->gi_filename_up;\n-  prefix_length = gf->prefix_length;\n   fname = gi_ptr->filename;\n \n-  /* Avoid to add multiple drive letters into combined path.  */\n-  if (prefix_length != 0 && HAS_DRIVE_SPEC(fname))\n-    fname += 2;\n-\n   /* Build relocated filename, stripping off leading\n      directories from the initial filename if requested. */\n-  if (gcov_prefix_strip > 0)\n+  if (gf->strip > 0)\n     {\n-      int level = 0;\n+      const char *probe = fname;\n+      int level;\n \n-      s = fname;\n-      if (IS_DIR_SEPARATOR(*s))\n-        ++s;\n+      /* Remove a leading separator, without counting it.  */\n+      if (IS_DIR_SEPARATOR (*probe))\n+\tprobe++;\n \n-      /* Skip selected directory levels. */\n-      for (; (*s != '\\0') && (level < gcov_prefix_strip); s++)\n-        if (IS_DIR_SEPARATOR(*s))\n+      /* Skip selected directory levels.  If we fall off the end, we\n+\t keep the final part.  */\n+      for (level = gf->strip; *probe && level; probe++)\n+        if (IS_DIR_SEPARATOR (*probe))\n           {\n-            fname = s;\n-            level++;\n+            fname = probe;\n+            level--;\n           }\n     }\n \n   /* Update complete filename with stripped original. */\n-  if (prefix_length != 0 && !IS_DIR_SEPARATOR (*fname))\n+  if (gf->prefix)\n     {\n-      /* If prefix is given, add directory separator.  */\n-      strcpy (gi_filename_up, \"/\");\n-      strcpy (gi_filename_up + 1, fname);\n+      /* Avoid to add multiple drive letters into combined path.  */\n+      if (HAS_DRIVE_SPEC(fname))\n+\tfname += 2;\n+\n+      if (!IS_DIR_SEPARATOR (*fname))\n+\t*dst++ = '/';\n     }\n-  else\n-    strcpy (gi_filename_up, fname);\n+  strcpy (dst, fname);\n \n-  if (!gcov_open (gi_filename))\n+  if (!gcov_open (gf->filename))\n     {\n       /* Open failed likely due to missed directory.\n          Create directory and retry to open file. */\n-      if (create_file_directory (gi_filename))\n+      if (create_file_directory (gf->filename))\n         {\n-          fprintf (stderr, \"profiling:%s:Skip\\n\", gi_filename);\n+          fprintf (stderr, \"profiling:%s:Skip\\n\", gf->filename);\n           return -1;\n         }\n-      if (!gcov_open (gi_filename))\n+      if (!gcov_open (gf->filename))\n         {\n-          fprintf (stderr, \"profiling:%s:Cannot open\\n\", gi_filename);\n+          fprintf (stderr, \"profiling:%s:Cannot open\\n\", gf->filename);\n           return -1;\n         }\n     }"}, {"sha": "5e239ce64273eb1119410cfb0fd9609903144683", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=6dc33097cc860a927844de314ebbcfa50299c8e1", "patch": "@@ -66,20 +66,24 @@ struct gcov_summary_buffer\n   struct gcov_summary summary;\n };\n \n+/* A struct that bundles all the related information about the\n+   gcda filename.  */\n+\n+struct gcov_filename\n+{\n+  char *filename;  /* filename buffer */\n+  size_t max_length;  /* maximum filename length */\n+  int strip; /* leading chars to strip from filename */\n+  size_t prefix; /* chars to prepend to filename */\n+};\n+\n /* Chain of per-object gcov structures.  */\n #ifndef IN_GCOV_TOOL\n /* We need to expose this static variable when compiling for gcov-tool.  */\n static\n #endif\n struct gcov_info *gcov_list;\n \n-/* Size of the longest file name. */\n-/* We need to expose this static variable when compiling for gcov-tool.  */\n-#ifndef IN_GCOV_TOOL\n-static\n-#endif\n-size_t gcov_max_filename = 0;\n-\n /* Flag when the profile has already been dumped via __gcov_dump().  */\n static int gcov_dump_complete;\n \n@@ -275,8 +279,6 @@ gcov_compute_histogram (struct gcov_summary *sum)\n     }\n }\n \n-/* gcda filename.  */\n-static char *gi_filename;\n /* buffer for the fn_data from another program.  */\n static struct gcov_fn_buffer *fn_buffer;\n /* buffer for summary from other programs to be written out. */\n@@ -286,11 +288,13 @@ static struct gcov_summary_buffer *sum_buffer;\n    functions executed once may mistakely become cold.  */\n static int run_accounted = 0;\n \n-/* This funtions computes the program level summary and the histo-gram.\n-   It computes and returns CRC32 and stored summary in THIS_PRG.  */\n+/* This function computes the program level summary and the histo-gram.\n+   It computes and returns CRC32 and stored summary in THIS_PRG.\n+   Also determines the longest filename length of the info files.  */\n \n static gcov_unsigned_t\n-gcov_exit_compute_summary (struct gcov_summary *this_prg)\n+gcov_exit_compute_summary (struct gcov_summary *this_prg,\n+\t\t\t   size_t *max_length)\n {\n   struct gcov_info *gi_ptr;\n   const struct gcov_fn_info *gfi_ptr;\n@@ -303,8 +307,13 @@ gcov_exit_compute_summary (struct gcov_summary *this_prg)\n \n   /* Find the totals for this execution.  */\n   memset (this_prg, 0, sizeof (*this_prg));\n+  *max_length = 0;\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n+      size_t len = strlen (gi_ptr->filename);\n+      if (len > *max_length)\n+\t*max_length = len;\n+      \n       crc32 = crc32_unsigned (crc32, gi_ptr->stamp);\n       crc32 = crc32_unsigned (crc32, gi_ptr->n_functions);\n \n@@ -345,14 +354,6 @@ gcov_exit_compute_summary (struct gcov_summary *this_prg)\n   return crc32;\n }\n \n-/* A struct that bundles all the related information about the\n-   gcda filename.  */\n-struct gcov_filename_aux{\n-  char *gi_filename_up;\n-  int gcov_prefix_strip;\n-  size_t prefix_length;\n-};\n-\n /* Including system dependent components. */\n #include \"libgcov-driver-system.c\"\n \n@@ -361,7 +362,8 @@ struct gcov_filename_aux{\n    Return -1 on error. In this case, caller will goto read_fatal.  */\n \n static int\n-gcov_exit_merge_gcda (struct gcov_info *gi_ptr,\n+gcov_exit_merge_gcda (const char *filename,\n+\t\t      struct gcov_info *gi_ptr,\n                       struct gcov_summary *prg_p,\n                       struct gcov_summary *this_prg,\n                       gcov_position_t *summary_pos_p,\n@@ -376,7 +378,7 @@ gcov_exit_merge_gcda (struct gcov_info *gi_ptr,\n   struct gcov_summary_buffer **sum_tail = &sum_buffer;\n \n   length = gcov_read_unsigned ();\n-  if (!gcov_version (gi_ptr, length, gi_filename))\n+  if (!gcov_version (gi_ptr, length, filename))\n     return -1;\n \n   length = gcov_read_unsigned ();\n@@ -451,8 +453,7 @@ gcov_exit_merge_gcda (struct gcov_info *gi_ptr,\n              it back out -- we'll be inserting data before\n              this point, so cannot simply keep the data in the\n              file.  */\n-          fn_tail = buffer_fn_data (gi_filename,\n-                                    gi_ptr, fn_tail, f_ix);\n+          fn_tail = buffer_fn_data (filename, gi_ptr, fn_tail, f_ix);\n           if (!fn_tail)\n             goto read_mismatch;\n           continue;\n@@ -494,14 +495,14 @@ gcov_exit_merge_gcda (struct gcov_info *gi_ptr,\n     {\n     read_mismatch:;\n       gcov_error (\"profiling:%s:Merge mismatch for %s %u\\n\",\n-                  gi_filename, f_ix >= 0 ? \"function\" : \"summary\",\n+                  filename, f_ix >= 0 ? \"function\" : \"summary\",\n                   f_ix < 0 ? -1 - f_ix : f_ix);\n       return -1;\n     }\n   return 0;\n \n read_error:\n-  gcov_error (\"profiling:%s:%s merging\\n\", gi_filename,\n+  gcov_error (\"profiling:%s:%s merging\\n\", filename,\n               error < 0 ? \"Overflow\": \"Error\");\n   return -1;\n }\n@@ -606,7 +607,8 @@ gcov_exit_write_gcda (const struct gcov_info *gi_ptr,\n    Return -1 on error. Return 0 on success.  */\n \n static int\n-gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *prg,\n+gcov_exit_merge_summary (const char *filename,\n+\t\t\t const struct gcov_info *gi_ptr, struct gcov_summary *prg,\n                          struct gcov_summary *this_prg, gcov_unsigned_t crc32,\n \t\t\t struct gcov_summary *all_prg __attribute__ ((unused)))\n {\n@@ -644,7 +646,7 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n       else if (cs_prg->runs)\n         {\n           gcov_error (\"profiling:%s:Merge mismatch for summary.\\n\",\n-                      gi_filename);\n+                      filename);\n           return -1;\n         }\n #if !GCOV_LOCKED\n@@ -670,7 +672,7 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n              {\n                gcov_error (\"profiling:%s:Data file mismatch - some \"\n                            \"data files may have been concurrently \"\n-                           \"updated without locking support\\n\", gi_filename);\n+                           \"updated without locking support\\n\", filename);\n                all_prg->checksum = ~0u;\n              }\n #endif\n@@ -689,7 +691,7 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n    summaries separate.  */\n \n static void\n-gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf,\n+gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n \t\t     gcov_unsigned_t crc32, struct gcov_summary *all_prg,\n                      struct gcov_summary *this_prg)\n {\n@@ -712,11 +714,11 @@ gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf,\n       /* Merge data from file.  */\n       if (tag != GCOV_DATA_MAGIC)\n         {\n-          gcov_error (\"profiling:%s:Not a gcov data file\\n\", gi_filename);\n+          gcov_error (\"profiling:%s:Not a gcov data file\\n\", gf->filename);\n           goto read_fatal;\n         }\n-      error = gcov_exit_merge_gcda (gi_ptr, &prg, this_prg, &summary_pos, &eof_pos,\n-\t\t\t\t    crc32);\n+      error = gcov_exit_merge_gcda (gf->filename, gi_ptr, &prg, this_prg,\n+\t\t\t\t    &summary_pos, &eof_pos, crc32);\n       if (error == -1)\n         goto read_fatal;\n     }\n@@ -729,7 +731,8 @@ gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf,\n       summary_pos = eof_pos;\n     }\n \n-  error = gcov_exit_merge_summary (gi_ptr, &prg, this_prg, crc32, all_prg);\n+  error = gcov_exit_merge_summary (gf->filename, gi_ptr, &prg, this_prg,\n+\t\t\t\t   crc32, all_prg);\n   if (error == -1)\n     goto read_fatal;\n \n@@ -744,7 +747,7 @@ read_fatal:;\n     gcov_error (error  < 0 ?\n                 \"profiling:%s:Overflow writing\\n\" :\n                 \"profiling:%s:Error writing\\n\",\n-                gi_filename);\n+                gf->filename);\n }\n \n \n@@ -756,7 +759,7 @@ void\n gcov_exit (void)\n {\n   struct gcov_info *gi_ptr;\n-  struct gcov_filename_aux gf;\n+  struct gcov_filename gf;\n   gcov_unsigned_t crc32;\n   struct gcov_summary all_prg;\n   struct gcov_summary this_prg;\n@@ -767,8 +770,8 @@ gcov_exit (void)\n     return;\n \n   gcov_dump_complete = 1;\n-  \n-  crc32 = gcov_exit_compute_summary (&this_prg);\n+\n+  crc32 = gcov_exit_compute_summary (&this_prg, &gf.max_length);\n \n   allocate_filename_struct (&gf);\n #if !GCOV_LOCKED\n@@ -780,8 +783,7 @@ gcov_exit (void)\n     gcov_exit_dump_gcov (gi_ptr, &gf, crc32, &all_prg, &this_prg);\n   run_accounted = 1;\n \n-  if (gi_filename)\n-    free (gi_filename);\n+  free (gf.filename);\n }\n \n /* Reset all counters to zero.  */\n@@ -826,12 +828,6 @@ __gcov_init (struct gcov_info *info)\n     return;\n   if (gcov_version (info, info->version, 0))\n     {\n-      size_t filename_length = strlen(info->filename);\n-\n-      /* Refresh the longest file name information */\n-      if (filename_length > gcov_max_filename)\n-        gcov_max_filename = filename_length;\n-\n       if (!gcov_list)\n         atexit (gcov_exit);\n "}, {"sha": "e46ae06ea5a5e6dfb15f51f2c660a0ea1b3e47b5", "filename": "libgcc/libgcov-util.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2Flibgcov-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc33097cc860a927844de314ebbcfa50299c8e1/libgcc%2Flibgcov-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-util.c?ref=6dc33097cc860a927844de314ebbcfa50299c8e1", "patch": "@@ -38,7 +38,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n extern gcov_position_t gcov_position();\n extern int gcov_is_error();\n-extern size_t gcov_max_filename;\n \n /* Verbose mode for debug.  */\n static int verbose;\n@@ -78,8 +77,6 @@ static int k_ctrs_mask[GCOV_COUNTERS];\n static struct gcov_ctr_info k_ctrs[GCOV_COUNTERS];\n /* Number of kind of counters that have been seen.  */\n static int k_ctrs_types;\n-/* The longest length of all the filenames.  */\n-static int max_filename_len;\n \n /* Merge functions for counters.  */\n #define DEF_GCOV_COUNTER(COUNTER, NAME, FN_TYPE) __gcov_merge ## FN_TYPE,\n@@ -301,13 +298,11 @@ read_gcda_file (const char *filename)\n   num_fn_info = 0;\n   curr_fn_info = 0;\n   {\n-    char *str_dup = (char*) xmalloc (strlen (filename) + 1);\n-    int len;\n+    size_t len = strlen (filename) + 1;\n+    char *str_dup = (char*) xmalloc (len);\n \n-    strcpy (str_dup, filename);\n+    memcpy (str_dup, filename, len);\n     obj_info->filename = str_dup;\n-    if ((len = strlen (filename)) > max_filename_len)\n-      max_filename_len = len;\n   }\n \n   /* Read stamp.  */\n@@ -433,8 +428,7 @@ read_profile_dir_init (void)\n \n /* Driver for read a profile directory and convert into gcov_info list in memory.\n    Return NULL on error,\n-   Return the head of gcov_info list on success.\n-   Note the file static variable GCOV_MAX_FILENAME is also set.  */\n+   Return the head of gcov_info list on success.  */\n \n struct gcov_info *\n gcov_read_profile_dir (const char* dir_name, int recompute_summary ATTRIBUTE_UNUSED)\n@@ -462,11 +456,6 @@ gcov_read_profile_dir (const char* dir_name, int recompute_summary ATTRIBUTE_UNU\n   free (pwd);\n \n \n-  /* gcov_max_filename is defined in libgcov.c that records the\n-     max filename len. We need to set it here to allocate the\n-     array for dumping.  */\n-  gcov_max_filename = max_filename_len;\n-\n   return gcov_info_head;;\n }\n "}]}