{"sha": "4c437f02c24d896b08267b39cd8c8216da3bce4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM0MzdmMDJjMjRkODk2YjA4MjY3YjM5Y2Q4YzgyMTZkYTNiY2U0ZQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2014-01-08T17:25:38Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2014-01-08T17:25:38Z"}, "message": "re PR middle-end/57748 (ICE when expanding assignment to unaligned zero-sized array)\n\n2014-01-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR middle-end/57748\n        * expr.h (expand_expr_real, expand_expr_real_1): Add new parameter\n        inner_reference_p.\n        (expand_expr, expand_normal): Adjust.\n        * expr.c (expand_expr_real, expand_expr_real_1): Add new parameter\n        inner_reference_p. Use inner_reference_p to expand inner references.\n        (store_expr): Adjust.\n        * cfgexpand.c (expand_call_stmt): Adjust.\n\ntestsuite:\n2014-01-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR middle-end/57748\n        * gcc.dg/torture/pr57748-3.c: New test.\n        * gcc.dg/torture/pr57748-4.c: New test.\n\nFrom-SVN: r206437", "tree": {"sha": "499113f371f2643e026cc3b0aa0d39e87de14525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/499113f371f2643e026cc3b0aa0d39e87de14525"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c437f02c24d896b08267b39cd8c8216da3bce4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c437f02c24d896b08267b39cd8c8216da3bce4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c437f02c24d896b08267b39cd8c8216da3bce4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c437f02c24d896b08267b39cd8c8216da3bce4e/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40d6b7535cdc6b2fbe02ba7dc3335a14bf343ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d6b7535cdc6b2fbe02ba7dc3335a14bf343ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40d6b7535cdc6b2fbe02ba7dc3335a14bf343ea3"}], "stats": {"total": 262, "additions": 190, "deletions": 72}, "files": [{"sha": "7c1edb58dea4fa2caeb3267ec9df2b86993e94d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c437f02c24d896b08267b39cd8c8216da3bce4e", "patch": "@@ -1,3 +1,14 @@\n+2014-01-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR middle-end/57748\n+\t* expr.h (expand_expr_real, expand_expr_real_1): Add new parameter\n+\tinner_reference_p.\n+\t(expand_expr, expand_normal): Adjust.\n+\t* expr.c (expand_expr_real, expand_expr_real_1): Add new parameter\n+\tinner_reference_p. Use inner_reference_p to expand inner references.\n+\t(store_expr): Adjust.\n+\t* cfgexpand.c (expand_call_stmt): Adjust.\n+\n 2014-01-08  Rong Xu  <xur@google.com> \n \n \t* gcov-io.c (gcov_var): Move from gcov-io.h."}, {"sha": "0008be93d54da94146766926b83c952ceb47d7da", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=4c437f02c24d896b08267b39cd8c8216da3bce4e", "patch": "@@ -2253,7 +2253,7 @@ expand_call_stmt (gimple stmt)\n   if (lhs)\n     expand_assignment (lhs, exp, false);\n   else\n-    expand_expr_real_1 (exp, const0_rtx, VOIDmode, EXPAND_NORMAL, NULL);\n+    expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   mark_transaction_restart_calls (stmt);\n }"}, {"sha": "400a152ce56417e8b842430b051cbc9f7c86d00c", "filename": "gcc/expr.c", "status": "modified", "additions": 86, "deletions": 66, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4c437f02c24d896b08267b39cd8c8216da3bce4e", "patch": "@@ -5325,7 +5325,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n       temp = expand_expr_real (exp, tmp_target, GET_MODE (target),\n \t\t\t       (call_param_p\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL),\n-\t\t\t       &alt_rtl);\n+\t\t\t       &alt_rtl, false);\n     }\n \n   /* If TEMP is a VOIDmode constant and the mode of the type of EXP is not\n@@ -7911,11 +7911,21 @@ expand_constructor (tree exp, rtx target, enum expand_modifier modifier,\n    address, and ALT_RTL is non-NULL, then *ALT_RTL is set to the\n    DECL_RTL of the VAR_DECL.  *ALT_RTL is also set if EXP is a\n    COMPOUND_EXPR whose second argument is such a VAR_DECL, and so on\n-   recursively.  */\n+   recursively.\n+\n+   If INNER_REFERENCE_P is true, we are expanding an inner reference.\n+   In this case, we don't adjust a returned MEM rtx that wouldn't be\n+   sufficiently aligned for its mode; instead, it's up to the caller\n+   to deal with it afterwards.  This is used to make sure that unaligned\n+   base objects for which out-of-bounds accesses are supported, for\n+   example record types with trailing arrays, aren't realigned behind\n+   the back of the caller.\n+   The normal operating mode is to pass FALSE for this parameter.  */\n \n rtx\n expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n-\t\t  enum expand_modifier modifier, rtx *alt_rtl)\n+\t\t  enum expand_modifier modifier, rtx *alt_rtl,\n+\t\t  bool inner_reference_p)\n {\n   rtx ret;\n \n@@ -7927,7 +7937,8 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n       return ret ? ret : const0_rtx;\n     }\n \n-  ret = expand_expr_real_1 (exp, target, tmode, modifier, alt_rtl);\n+  ret = expand_expr_real_1 (exp, target, tmode, modifier, alt_rtl,\n+\t\t\t    inner_reference_p);\n   return ret;\n }\n \n@@ -9232,7 +9243,8 @@ stmt_is_replaceable_p (gimple stmt)\n \n rtx\n expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n-\t\t    enum expand_modifier modifier, rtx *alt_rtl)\n+\t\t    enum expand_modifier modifier, rtx *alt_rtl,\n+\t\t    bool inner_reference_p)\n {\n   rtx op0, op1, temp, decl_rtl;\n   tree type;\n@@ -9378,7 +9390,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  set_curr_insn_location (gimple_location (g));\n \t  r = expand_expr_real (gimple_assign_rhs_to_tree (g), target,\n-\t\t\t\ttmode, modifier, NULL);\n+\t\t\t\ttmode, modifier, NULL, inner_reference_p);\n \t  set_curr_insn_location (saved_loc);\n \t  if (REG_P (r) && !REG_EXPR (r))\n \t    set_reg_attrs_for_decl_rtl (SSA_NAME_VAR (exp), r);\n@@ -9597,7 +9609,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case SAVE_EXPR:\n       {\n \ttree val = treeop0;\n-\trtx ret = expand_expr_real_1 (val, target, tmode, modifier, alt_rtl);\n+\trtx ret = expand_expr_real_1 (val, target, tmode, modifier, alt_rtl,\n+\t\t\t\t      inner_reference_p);\n \n \tif (!SAVE_EXPR_RESOLVED_P (exp))\n \t  {\n@@ -9735,6 +9748,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  MEM_VOLATILE_P (temp) = 1;\n \tif (modifier != EXPAND_WRITE\n \t    && modifier != EXPAND_MEMORY\n+\t    && !inner_reference_p\n \t    && mode != BLKmode\n \t    && align < GET_MODE_ALIGNMENT (mode))\n \t  {\n@@ -9960,15 +9974,16 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n \torig_op0 = op0\n-\t  = expand_expr (tem,\n-\t\t\t (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n-\t\t\t  && COMPLETE_TYPE_P (TREE_TYPE (tem))\n-\t\t\t  && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n-\t\t\t      != INTEGER_CST)\n-\t\t\t  && modifier != EXPAND_STACK_PARM\n-\t\t\t  ? target : NULL_RTX),\n-\t\t\t VOIDmode,\n-\t\t\t modifier == EXPAND_SUM ? EXPAND_NORMAL : modifier);\n+\t  = expand_expr_real (tem,\n+\t\t\t      (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n+\t\t\t       && COMPLETE_TYPE_P (TREE_TYPE (tem))\n+\t\t\t       && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n+\t\t\t\t   != INTEGER_CST)\n+\t\t\t       && modifier != EXPAND_STACK_PARM\n+\t\t\t       ? target : NULL_RTX),\n+\t\t\t      VOIDmode,\n+\t\t\t      modifier == EXPAND_SUM ? EXPAND_NORMAL : modifier,\n+\t\t\t      NULL, true);\n \n \t/* If the field has a mode, we want to access it in the\n \t   field's mode, not the computed mode.\n@@ -10325,14 +10340,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  {\n \t    /* See the normal_inner_ref case for the rationale.  */\n \t    orig_op0\n-\t      = expand_expr (tem,\n-\t\t\t     (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n-\t\t\t      && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n-\t\t\t\t  != INTEGER_CST)\n-\t\t\t      && modifier != EXPAND_STACK_PARM\n-\t\t\t      ? target : NULL_RTX),\n-\t\t\t     VOIDmode,\n-\t\t\t     modifier == EXPAND_SUM ? EXPAND_NORMAL : modifier);\n+\t      = expand_expr_real (tem,\n+\t\t\t\t  (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n+\t\t\t\t   && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n+\t\t\t\t       != INTEGER_CST)\n+\t\t\t\t   && modifier != EXPAND_STACK_PARM\n+\t\t\t\t   ? target : NULL_RTX),\n+\t\t\t\t  VOIDmode,\n+\t\t\t\t  modifier == EXPAND_SUM ? EXPAND_NORMAL : modifier,\n+\t\t\t\t  NULL, true);\n \n \t    if (MEM_P (orig_op0))\n \t      {\n@@ -10359,7 +10375,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       }\n \n       if (!op0)\n-\top0 = expand_expr (treeop0, NULL_RTX, VOIDmode, modifier);\n+\top0 = expand_expr_real (treeop0, NULL_RTX, VOIDmode, modifier,\n+\t\t\t\tNULL, inner_reference_p);\n \n       /* If the input and output modes are both the same, we are done.  */\n       if (mode == GET_MODE (op0))\n@@ -10426,50 +10443,53 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      op0 = copy_rtx (op0);\n \t      set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));\n \t    }\n-\t  else if (mode != BLKmode\n-\t\t   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode)\n-\t\t   /* If the target does have special handling for unaligned\n-\t\t      loads of mode then use them.  */\n-\t\t   && ((icode = optab_handler (movmisalign_optab, mode))\n-\t\t       != CODE_FOR_nothing))\n-\t    {\n-\t      rtx reg, insn;\n-\n-\t      op0 = adjust_address (op0, mode, 0);\n-\t      /* We've already validated the memory, and we're creating a\n-\t\t new pseudo destination.  The predicates really can't\n-\t\t fail.  */\n-\t      reg = gen_reg_rtx (mode);\n-\n-\t      /* Nor can the insn generator.  */\n-\t      insn = GEN_FCN (icode) (reg, op0);\n-\t      emit_insn (insn);\n-\t      return reg;\n-\t    }\n-\t  else if (STRICT_ALIGNMENT\n+\t  else if (modifier != EXPAND_WRITE\n+\t\t   && modifier != EXPAND_MEMORY\n+\t\t   && !inner_reference_p\n \t\t   && mode != BLKmode\n \t\t   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode))\n \t    {\n-\t      tree inner_type = TREE_TYPE (treeop0);\n-\t      HOST_WIDE_INT temp_size\n-\t\t= MAX (int_size_in_bytes (inner_type),\n-\t\t       (HOST_WIDE_INT) GET_MODE_SIZE (mode));\n-\t      rtx new_rtx\n-\t\t= assign_stack_temp_for_type (mode, temp_size, type);\n-\t      rtx new_with_op0_mode\n-\t\t= adjust_address (new_rtx, GET_MODE (op0), 0);\n-\n-\t      gcc_assert (!TREE_ADDRESSABLE (exp));\n-\n-\t      if (GET_MODE (op0) == BLKmode)\n-\t\temit_block_move (new_with_op0_mode, op0,\n-\t\t\t\t GEN_INT (GET_MODE_SIZE (mode)),\n-\t\t\t\t (modifier == EXPAND_STACK_PARM\n-\t\t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n-\t      else\n-\t\temit_move_insn (new_with_op0_mode, op0);\n+\t      /* If the target does have special handling for unaligned\n+\t\t loads of mode then use them.  */\n+\t      if ((icode = optab_handler (movmisalign_optab, mode))\n+\t\t  != CODE_FOR_nothing)\n+\t\t{\n+\t\t  rtx reg, insn;\n+\n+\t\t  op0 = adjust_address (op0, mode, 0);\n+\t\t  /* We've already validated the memory, and we're creating a\n+\t\t     new pseudo destination.  The predicates really can't\n+\t\t     fail.  */\n+\t\t  reg = gen_reg_rtx (mode);\n+\n+\t\t  /* Nor can the insn generator.  */\n+\t\t  insn = GEN_FCN (icode) (reg, op0);\n+\t\t  emit_insn (insn);\n+\t\t  return reg;\n+\t\t}\n+\t      else if (STRICT_ALIGNMENT)\n+\t\t{\n+\t\t  tree inner_type = TREE_TYPE (treeop0);\n+\t\t  HOST_WIDE_INT temp_size\n+\t\t    = MAX (int_size_in_bytes (inner_type),\n+\t\t\t   (HOST_WIDE_INT) GET_MODE_SIZE (mode));\n+\t\t  rtx new_rtx\n+\t\t    = assign_stack_temp_for_type (mode, temp_size, type);\n+\t\t  rtx new_with_op0_mode\n+\t\t    = adjust_address (new_rtx, GET_MODE (op0), 0);\n+\n+\t\t  gcc_assert (!TREE_ADDRESSABLE (exp));\n+\n+\t\t  if (GET_MODE (op0) == BLKmode)\n+\t\t    emit_block_move (new_with_op0_mode, op0,\n+\t\t\t\t     GEN_INT (GET_MODE_SIZE (mode)),\n+\t\t\t\t     (modifier == EXPAND_STACK_PARM\n+\t\t\t\t      ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n+\t\t  else\n+\t\t    emit_move_insn (new_with_op0_mode, op0);\n \n-\t      op0 = new_rtx;\n+\t\t  op0 = new_rtx;\n+\t\t}\n \t    }\n \n \t  op0 = adjust_address (op0, mode, 0);\n@@ -10569,7 +10589,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* WITH_SIZE_EXPR expands to its first argument.  The caller should\n \t have pulled out the size to use in whatever context it needed.  */\n       return expand_expr_real (treeop0, original_target, tmode,\n-\t\t\t       modifier, alt_rtl);\n+\t\t\t       modifier, alt_rtl, inner_reference_p);\n \n     default:\n       return expand_expr_real_2 (&ops, target, tmode, modifier);"}, {"sha": "da5d4a6d56fdbeaf438a9631e281bfff1f655894", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=4c437f02c24d896b08267b39cd8c8216da3bce4e", "patch": "@@ -41,7 +41,8 @@ along with GCC; see the file COPYING3.  If not see\n     is a constant that is not a legitimate address.\n    EXPAND_WRITE means we are only going to write to the resulting rtx.\n    EXPAND_MEMORY means we are interested in a memory result, even if\n-    the memory is constant and we could have propagated a constant value.  */\n+    the memory is constant and we could have propagated a constant value,\n+    or the memory is unaligned on a STRICT_ALIGNMENT target.  */\n enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM, EXPAND_SUM,\n \t\t      EXPAND_CONST_ADDRESS, EXPAND_INITIALIZER, EXPAND_WRITE,\n \t\t      EXPAND_MEMORY};\n@@ -437,9 +438,9 @@ extern rtx force_operand (rtx, rtx);\n \n /* Work horses for expand_expr.  */\n extern rtx expand_expr_real (tree, rtx, enum machine_mode,\n-\t\t\t     enum expand_modifier, rtx *);\n+\t\t\t     enum expand_modifier, rtx *, bool);\n extern rtx expand_expr_real_1 (tree, rtx, enum machine_mode,\n-\t\t\t       enum expand_modifier, rtx *);\n+\t\t\t       enum expand_modifier, rtx *, bool);\n extern rtx expand_expr_real_2 (sepops, rtx, enum machine_mode,\n \t\t\t       enum expand_modifier);\n \n@@ -450,13 +451,13 @@ static inline rtx\n expand_expr (tree exp, rtx target, enum machine_mode mode,\n \t     enum expand_modifier modifier)\n {\n-  return expand_expr_real (exp, target, mode, modifier, NULL);\n+  return expand_expr_real (exp, target, mode, modifier, NULL, false);\n }\n \n static inline rtx\n expand_normal (tree exp)\n {\n-  return expand_expr_real (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL, NULL);\n+  return expand_expr_real (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL, NULL, false);\n }\n \n /* At the start of a function, record that we have no previously-pushed"}, {"sha": "827b482c55ca6ba39710204927162bbf8d0e3a55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c437f02c24d896b08267b39cd8c8216da3bce4e", "patch": "@@ -1,3 +1,9 @@\n+2014-01-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR middle-end/57748\n+\t* gcc.dg/torture/pr57748-3.c: New test.\n+\t* gcc.dg/torture/pr57748-4.c: New test.\n+\n 2014-01-08  Marek Polacek  <polacek@redhat.com>\n \n \tPR middle-end/59669"}, {"sha": "5ddb6099c2cd57f2acdc852affb55b7b94aebbeb", "filename": "gcc/testsuite/gcc.dg/torture/pr57748-3.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57748-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57748-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57748-3.c?ref=4c437f02c24d896b08267b39cd8c8216da3bce4e", "patch": "@@ -0,0 +1,40 @@\n+/* PR middle-end/57748 */\n+/* { dg-do run } */\n+/* wrong code in expand_expr_real_1.  */\n+\n+#include <stdlib.h>\n+\n+extern void abort (void);\n+\n+typedef long long V\n+  __attribute__ ((vector_size (2 * sizeof (long long)), may_alias));\n+\n+typedef struct S { V a; V b[0]; } P __attribute__((aligned (1)));\n+\n+struct __attribute__((packed)) T { char c; P s; };\n+\n+void __attribute__((noinline, noclone))\n+check (P *p)\n+{\n+  if (p->b[0][0] != 3 || p->b[0][1] != 4)\n+    abort ();\n+}\n+\n+void __attribute__((noinline, noclone))\n+foo (struct T *t)\n+{\n+  V a = { 3, 4 };\n+  t->s.b[0] = a;\n+}\n+\n+int\n+main ()\n+{\n+  struct T *t = (struct T *) calloc (128, 1);\n+\n+  foo (t);\n+  check (&t->s);\n+\n+  free (t);\n+  return 0;\n+}"}, {"sha": "455cb3d3278be998a4d7961a1140f65a5f2ccfc4", "filename": "gcc/testsuite/gcc.dg/torture/pr57748-4.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57748-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c437f02c24d896b08267b39cd8c8216da3bce4e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57748-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57748-4.c?ref=4c437f02c24d896b08267b39cd8c8216da3bce4e", "patch": "@@ -0,0 +1,40 @@\n+/* PR middle-end/57748 */\n+/* { dg-do run } */\n+/* wrong code in expand_expr_real_1.  */\n+\n+#include <stdlib.h>\n+\n+extern void abort (void);\n+\n+typedef long long V\n+  __attribute__ ((vector_size (2 * sizeof (long long)), may_alias));\n+\n+typedef struct S { V b[1]; } P __attribute__((aligned (1)));\n+\n+struct __attribute__((packed)) T { char c; P s; };\n+\n+void __attribute__((noinline, noclone))\n+check (P *p)\n+{\n+  if (p->b[1][0] != 3 || p->b[1][1] != 4)\n+    abort ();\n+}\n+\n+void __attribute__((noinline, noclone))\n+foo (struct T *t)\n+{\n+  V a = { 3, 4 };\n+  t->s.b[1] = a;\n+}\n+\n+int\n+main ()\n+{\n+  struct T *t = (struct T *) calloc (128, 1);\n+\n+  foo (t);\n+  check (&t->s);\n+\n+  free (t);\n+  return 0;\n+}"}]}