{"sha": "b76c90cf74d37b7865a3df6cdc6026838e5934d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc2YzkwY2Y3NGQzN2I3ODY1YTNkZjZjZGM2MDI2ODM4ZTU5MzRkMg==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gnu.org", "date": "1998-04-09T23:38:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-09T23:38:47Z"}, "message": "i386.md (movqi+1): Handle invalid QI register.\n\n        * i386.md (movqi+1): Handle invalid QI register.\n        (movsf_push-1): Likewise.\n\nFrom-SVN: r19073", "tree": {"sha": "30bb1d309d23dd93dc1e5314176d504810c65b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30bb1d309d23dd93dc1e5314176d504810c65b64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b76c90cf74d37b7865a3df6cdc6026838e5934d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b76c90cf74d37b7865a3df6cdc6026838e5934d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b76c90cf74d37b7865a3df6cdc6026838e5934d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b76c90cf74d37b7865a3df6cdc6026838e5934d2/comments", "author": null, "committer": null, "parents": [{"sha": "fcad5cf5e8bb2fc25e7971cf9f706581904f2a3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcad5cf5e8bb2fc25e7971cf9f706581904f2a3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcad5cf5e8bb2fc25e7971cf9f706581904f2a3e"}], "stats": {"total": 148, "additions": 110, "deletions": 38}, "files": [{"sha": "5cfcacaac0f5ec99c4bc655cf2b31fbdf2d00c10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b76c90cf74d37b7865a3df6cdc6026838e5934d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b76c90cf74d37b7865a3df6cdc6026838e5934d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b76c90cf74d37b7865a3df6cdc6026838e5934d2", "patch": "@@ -1,3 +1,8 @@\n+Fri Apr 10 00:36:31 1998  H.J. Lu  (hjl@gnu.org)\n+\n+\t* i386.md (movqi+1): Handle invalid QI register.\n+\t(movsf_push-1): Likewise.\n+\n Thu Apr  9 16:53:59 1998  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/m32r/m32r.c: call_address_operand(): Only accept symbolic"}, {"sha": "85a7ae0f755b4bb54ddbb1d148f48ca955e39b7b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 105, "deletions": 38, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b76c90cf74d37b7865a3df6cdc6026838e5934d2/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b76c90cf74d37b7865a3df6cdc6026838e5934d2/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b76c90cf74d37b7865a3df6cdc6026838e5934d2", "patch": "@@ -1105,7 +1105,6 @@\n     return AS2 (xor%L0,%k0,%k0);\n \n   if (operands[1] == const1_rtx\n-      && !NON_QI_REG_P (operands[0])\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n       && ! INSN_DELETED_P (XEXP (link, 0))\n@@ -1114,8 +1113,14 @@\n       && no_labels_between_p (XEXP (link, 0), insn)\n       /* Make sure the reg hasn't been clobbered.  */\n       && ! reg_set_between_p (operands[0], XEXP (link, 0), insn))\n-    /* Fastest way to change a 0 to a 1.  */\n-    return AS1 (inc%B0,%0);\n+    {\n+      /* Fastest way to change a 0 to a 1.\n+\t If inc%B0 isn't allowed, use inc%L0.  */\n+      if (NON_QI_REG_P (operands[0]))\n+\treturn AS1 (inc%L0,%0);\n+      else\n+\treturn AS1 (inc%B0,%0);\n+    }\n \n   /* If mov%B0 isn't allowed for one of these regs, use mov%L0.  */\n   if (NON_QI_REG_P (operands[0]) || NON_QI_REG_P (operands[1]))\n@@ -1160,6 +1165,7 @@\n     return AS2 (xor%B0,%0,%0);\n \n   if (operands[1] == const1_rtx\n+      && ! NON_QI_REG_P (operands[0])\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n       && ! INSN_DELETED_P (XEXP (link, 0))\n@@ -7212,10 +7218,11 @@ byte_xor_operation:\n \n (define_expand \"movsicc\"\n   [(match_dup 4)\n-   (set (match_operand 0 \"register_operand\" \"\")\n+   (parallel [(set (match_operand 0 \"register_operand\" \"\")\n \t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"\")))]\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))\n+   (clobber (match_scratch:SI 4 \"=&r\"))])]\n   \"TARGET_CMOVE\"\n   \"\n {\n@@ -7224,78 +7231,138 @@ byte_xor_operation:\n \n (define_expand \"movhicc\"\n   [(match_dup 4)\n-   (set (match_operand 0 \"register_operand\" \"\")\n+   (parallel [(set (match_operand 0 \"register_operand\" \"\")\n \t(if_then_else:HI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:HI 2 \"nonimmediate_operand\" \"\")\n-\t\t\t (match_operand:HI 3 \"nonimmediate_operand\" \"\")))]\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 3 \"general_operand\" \"\")))\n+   (clobber (match_scratch:SI 4 \"=&r\"))])]\n   \"TARGET_CMOVE\"\n   \"\n {\n   operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n }\")\n \n (define_insn \"movsicc_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,&r\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,&r,rm\")\n \t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n-\t\t\t\t\t [(cc0) (const_int 0)])\n-\t\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n-\t\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:SI 2 \"general_operand\" \"rm,0,rm,g\")\n+\t\t      (match_operand:SI 3 \"general_operand\" \"0,rm,rm,g\")))\n+   (clobber (match_scratch:SI 4 \"X,X,X,=&r\"))]\n   \"TARGET_CMOVE\"\n   \"*\n {\n-  switch (which_alternative)\n+  if (which_alternative == 0)\n     {\n-    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      break;\n-\n-    case 1:\n+    }\n+  else if (which_alternative == 1)\n+    {\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n-\n-    case 2:\n+    }\n+  else if (which_alternative == 2)\n+    {\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n     }\n-\n+  else if (which_alternative == 3)\n+    {\n+      /* r <- cond ? arg1 : arg2 */\n+    rtx xops[3];\n+\n+    xops[0] = gen_label_rtx ();\n+    xops[1] = gen_label_rtx ();\n+    xops[2] = operands[1];\n+\n+    output_asm_insn (\\\"j%c2 %l0\\\", xops);\n+    if (! rtx_equal_p (operands[0], operands[2]))\n+       if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[2]) == MEM)\n+         {\n+           output_asm_insn (AS2 (mov%z2,%2,%4), operands);\n+           output_asm_insn (AS2 (mov%z2,%4,%0), operands);\n+         }\n+       else\n+      output_asm_insn (AS2 (mov%z0,%2,%0), operands);\n+    output_asm_insn (\\\"jmp %l1\\\", xops);\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n+    if (! rtx_equal_p (operands[0], operands[3]))\n+      {\n+        if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[3]) == MEM)\n+          {\n+            output_asm_insn (AS2 (mov%z3,%3,%4), operands);\n+            output_asm_insn (AS2 (mov%z3,%4,%0), operands);\n+          }\n+        else\n+      output_asm_insn (AS2 (mov%z0,%3,%0), operands);\n+      }\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n+    }  \n   RET;\n }\")\n \n (define_insn \"movhicc_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,&r\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,&r,rm\")\n \t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n-\t\t\t\t\t [(cc0) (const_int 0)])\n-\t\t\t (match_operand:HI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n-\t\t\t (match_operand:HI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:HI 2 \"general_operand\" \"rm,0,rm,g\")\n+\t\t      (match_operand:HI 3 \"general_operand\" \"0,rm,rm,g\")))\n+   (clobber (match_scratch:SI 4 \"X,X,X,=&r\"))]\n   \"TARGET_CMOVE\"\n   \"*\n {\n-  switch (which_alternative)\n+  if (which_alternative == 0)\n     {\n-    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      break;\n-\n-    case 1:\n+    }\n+  else if (which_alternative == 1)\n+    {\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n-\n-    case 2:\n+    }\n+  else if (which_alternative == 2)\n+    {\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n     }\n-\n+  else if (which_alternative == 3)\n+    {\n+      /* r <- cond ? arg1 : arg2 */\n+    rtx xops[3];\n+\n+    xops[0] = gen_label_rtx ();\n+    xops[1] = gen_label_rtx ();\n+    xops[2] = operands[1];\n+\n+    output_asm_insn (\\\"j%c2 %l0\\\", xops);\n+    if (! rtx_equal_p (operands[0], operands[2]))\n+       if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[2]) == MEM)\n+         {\n+           output_asm_insn (AS2 (mov%z2,%2,%4), operands);\n+           output_asm_insn (AS2 (mov%z2,%4,%0), operands);\n+         }\n+       else\n+      output_asm_insn (AS2 (mov%z0,%2,%0), operands);\n+    output_asm_insn (\\\"jmp %l1\\\", xops);\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n+    if (! rtx_equal_p (operands[0], operands[3]))\n+      {\n+        if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[3]) == MEM)\n+          {\n+            output_asm_insn (AS2 (mov%z3,%3,%4), operands);\n+            output_asm_insn (AS2 (mov%z3,%4,%0), operands);\n+          }\n+        else\n+      output_asm_insn (AS2 (mov%z0,%3,%0), operands);\n+      }\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n+    }  \n   RET;\n }\")\n-\n ;; We need to disable the FP forms of these since they do not support\n ;; memory as written, but no input reloads are permitted for insns\n ;; that use cc0.  Also, movxfcc is not present."}]}