{"sha": "f3949a2e785eb387d7e25d5ab06f4662d643d8fc", "node_id": "C_kwDOANBUbNoAKGYzOTQ5YTJlNzg1ZWIzODdkN2UyNWQ1YWIwNmY0NjYyZDY0M2Q4ZmM", "commit": {"author": {"name": "Julien Bortolussi", "email": "bortolussi@adacore.com", "date": "2022-04-21T09:11:26Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-06-01T08:43:16Z"}, "message": "[Ada] Add reference counting in functional containers\n\nThis patch adds reference counting to dynamically allocated pointers\non arrays and elements used by the functional container. This is done\nby making both the arrays and the elements controlled.\n\ngcc/ada/\n\n\t* libgnat/a-cofuba.ads, libgnat/a-cofuba.adb: Add reference\n\tcounting.", "tree": {"sha": "c7de906cb048c13b2fb16c3d0a6b6cdbd7d980f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7de906cb048c13b2fb16c3d0a6b6cdbd7d980f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3949a2e785eb387d7e25d5ab06f4662d643d8fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3949a2e785eb387d7e25d5ab06f4662d643d8fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3949a2e785eb387d7e25d5ab06f4662d643d8fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3949a2e785eb387d7e25d5ab06f4662d643d8fc/comments", "author": {"login": "JulienBortolussiAda", "id": 103429088, "node_id": "U_kgDOBioz4A", "avatar_url": "https://avatars.githubusercontent.com/u/103429088?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulienBortolussiAda", "html_url": "https://github.com/JulienBortolussiAda", "followers_url": "https://api.github.com/users/JulienBortolussiAda/followers", "following_url": "https://api.github.com/users/JulienBortolussiAda/following{/other_user}", "gists_url": "https://api.github.com/users/JulienBortolussiAda/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulienBortolussiAda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulienBortolussiAda/subscriptions", "organizations_url": "https://api.github.com/users/JulienBortolussiAda/orgs", "repos_url": "https://api.github.com/users/JulienBortolussiAda/repos", "events_url": "https://api.github.com/users/JulienBortolussiAda/events{/privacy}", "received_events_url": "https://api.github.com/users/JulienBortolussiAda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1379eeec11098cf8ec006bc0d3ac95beb2ad273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1379eeec11098cf8ec006bc0d3ac95beb2ad273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1379eeec11098cf8ec006bc0d3ac95beb2ad273"}], "stats": {"total": 279, "additions": 227, "deletions": 52}, "files": [{"sha": "68cf2ae585729b71dbecbc2614571bb53852f0d5", "filename": "gcc/ada/libgnat/a-cofuba.adb", "status": "modified", "additions": 148, "deletions": 41, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3949a2e785eb387d7e25d5ab06f4662d643d8fc/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3949a2e785eb387d7e25d5ab06f4662d643d8fc/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb?ref=f3949a2e785eb387d7e25d5ab06f4662d643d8fc", "patch": "@@ -52,6 +52,24 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    --  Resize the underlying array if needed so that it can contain one more\n    --  element.\n \n+   function Elements (C : Container) return Element_Array_Access is\n+     (C.Controlled_Base.Base.Elements)\n+   with\n+     Global => null,\n+     Pre    =>\n+       C.Controlled_Base.Base /= null\n+       and then C.Controlled_Base.Base.Elements /= null;\n+\n+   function Get\n+     (C_E : Element_Array_Access;\n+      I   : Count_Type)\n+      return Element_Access\n+   is\n+     (C_E (I).Ref.E_Access)\n+   with\n+     Global => null,\n+     Pre    => C_E /= null and then C_E (I).Ref /= null;\n+\n    ---------\n    -- \"=\" --\n    ---------\n@@ -61,9 +79,8 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       if C1.Length /= C2.Length then\n          return False;\n       end if;\n-\n       for I in 1 .. C1.Length loop\n-         if C1.Base.Elements (I).all /= C2.Base.Elements (I).all then\n+         if Get (Elements (C1), I).all /= Get (Elements (C2), I).all then\n             return False;\n          end if;\n       end loop;\n@@ -78,7 +95,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    function \"<=\" (C1 : Container; C2 : Container) return Boolean is\n    begin\n       for I in 1 .. C1.Length loop\n-         if Find (C2, C1.Base.Elements (I)) = 0 then\n+         if Find (C2, Get (Elements (C1), I)) = 0 then\n             return False;\n          end if;\n       end loop;\n@@ -95,58 +112,146 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       I : Index_Type;\n       E : Element_Type) return Container\n    is\n+      C_B : Array_Base_Access renames C.Controlled_Base.Base;\n    begin\n-      if To_Count (I) = C.Length + 1 and then C.Length = C.Base.Max_Length then\n-         Resize (C.Base);\n-         C.Base.Max_Length := C.Base.Max_Length + 1;\n-         C.Base.Elements (C.Base.Max_Length) := new Element_Type'(E);\n+      if To_Count (I) = C.Length + 1 and then C.Length = C_B.Max_Length then\n+         Resize (C_B);\n+         C_B.Max_Length := C_B.Max_Length + 1;\n+         C_B.Elements (C_B.Max_Length) := Element_Init (E);\n \n-         return Container'(Length => C.Base.Max_Length, Base => C.Base);\n+         return Container'(Length          => C_B.Max_Length,\n+                           Controlled_Base => C.Controlled_Base);\n       else\n          declare\n-            A : constant Array_Base_Access := Content_Init (C.Length);\n+            A : constant Array_Base_Controlled_Access :=\n+              Content_Init (C.Length);\n             P : Count_Type := 0;\n          begin\n-            A.Max_Length := C.Length + 1;\n+            A.Base.Max_Length := C.Length + 1;\n             for J in 1 .. C.Length + 1 loop\n                if J /= To_Count (I) then\n                   P := P + 1;\n-                  A.Elements (J) := C.Base.Elements (P);\n+                  A.Base.Elements (J) := C_B.Elements (P);\n                else\n-                  A.Elements (J) := new Element_Type'(E);\n+                  A.Base.Elements (J) := Element_Init (E);\n                end if;\n             end loop;\n \n-            return Container'(Length => A.Max_Length,\n-                              Base   => A);\n+            return Container'(Length           => A.Base.Max_Length,\n+                              Controlled_Base  => A);\n          end;\n       end if;\n    end Add;\n \n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Controlled_Base : in out Array_Base_Controlled_Access) is\n+      C_B : Array_Base_Access renames Controlled_Base.Base;\n+   begin\n+      if C_B /= null then\n+         C_B.Reference_Count := C_B.Reference_Count + 1;\n+      end if;\n+   end Adjust;\n+\n+   procedure Adjust (Ctrl_E : in out Controlled_Element_Access) is\n+   begin\n+      if Ctrl_E.Ref /= null then\n+         Ctrl_E.Ref.Reference_Count := Ctrl_E.Ref.Reference_Count + 1;\n+      end if;\n+   end Adjust;\n+\n    ------------------\n    -- Content_Init --\n    ------------------\n \n-   function Content_Init (L : Count_Type := 0) return Array_Base_Access\n+   function Content_Init\n+     (L : Count_Type := 0) return Array_Base_Controlled_Access\n    is\n       Max_Init : constant Count_Type := 100;\n       Size     : constant Count_Type :=\n         (if L < Count_Type'Last - Max_Init then L + Max_Init\n          else Count_Type'Last);\n+\n+      --  The Access in the array will be initialized to null\n+\n       Elements : constant Element_Array_Access :=\n         new Element_Array'(1 .. Size => <>);\n+      B        : constant Array_Base_Access :=\n+        new Array_Base'(Reference_Count => 1,\n+                        Max_Length      => 0,\n+                        Elements        => Elements);\n    begin\n-      return new Array_Base'(Max_Length => 0, Elements => Elements);\n+      return (Ada.Finalization.Controlled with Base => B);\n    end Content_Init;\n \n+   ------------------\n+   -- Element_Init --\n+   ------------------\n+\n+   function Element_Init (E : Element_Type) return Controlled_Element_Access\n+   is\n+      Refcounted_E : constant Refcounted_Element_Access :=\n+        new Refcounted_Element'(Reference_Count => 1,\n+                                E_Access        => new Element_Type'(E));\n+   begin\n+      return (Ada.Finalization.Controlled with Ref => Refcounted_E);\n+   end Element_Init;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Controlled_Base : in out Array_Base_Controlled_Access)\n+   is\n+      procedure Unchecked_Free_Base is new Ada.Unchecked_Deallocation\n+        (Object => Array_Base,\n+         Name   => Array_Base_Access);\n+      procedure Unchecked_Free_Array is new Ada.Unchecked_Deallocation\n+        (Object => Element_Array,\n+         Name   => Element_Array_Access);\n+\n+      C_B : Array_Base_Access renames Controlled_Base.Base;\n+   begin\n+      if C_B /= null then\n+         C_B.Reference_Count := C_B.Reference_Count - 1;\n+         if C_B.Reference_Count = 0 then\n+            Unchecked_Free_Array (Controlled_Base.Base.Elements);\n+            Unchecked_Free_Base (Controlled_Base.Base);\n+         end if;\n+         C_B := null;\n+      end if;\n+   end Finalize;\n+\n+   procedure Finalize (Ctrl_E : in out Controlled_Element_Access) is\n+      procedure Unchecked_Free_Ref is new Ada.Unchecked_Deallocation\n+        (Object => Refcounted_Element,\n+         Name   => Refcounted_Element_Access);\n+\n+      procedure Unchecked_Free_Element is new Ada.Unchecked_Deallocation\n+        (Object => Element_Type,\n+         Name   => Element_Access);\n+\n+   begin\n+      if Ctrl_E.Ref /= null then\n+         Ctrl_E.Ref.Reference_Count := Ctrl_E.Ref.Reference_Count - 1;\n+         if Ctrl_E.Ref.Reference_Count = 0 then\n+            Unchecked_Free_Element (Ctrl_E.Ref.E_Access);\n+            Unchecked_Free_Ref (Ctrl_E.Ref);\n+         end if;\n+         Ctrl_E.Ref := null;\n+      end if;\n+   end Finalize;\n+\n    ----------\n    -- Find --\n    ----------\n \n    function Find (C : Container; E : access Element_Type) return Count_Type is\n    begin\n       for I in 1 .. C.Length loop\n-         if C.Base.Elements (I).all = E.all then\n+         if Get (Elements (C), I).all = E.all then\n             return I;\n          end if;\n       end loop;\n@@ -162,27 +267,27 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    ---------\n \n    function Get (C : Container; I : Index_Type) return Element_Type is\n-     (C.Base.Elements (To_Count (I)).all);\n+      (Get (Elements (C), To_Count (I)).all);\n \n    ------------------\n    -- Intersection --\n    ------------------\n \n    function Intersection (C1 : Container; C2 : Container) return Container is\n       L : constant Count_Type := Num_Overlaps (C1, C2);\n-      A : constant Array_Base_Access := Content_Init (L);\n+      A : constant Array_Base_Controlled_Access := Content_Init (L);\n       P : Count_Type := 0;\n \n    begin\n-      A.Max_Length := L;\n+      A.Base.Max_Length := L;\n       for I in 1 .. C1.Length loop\n-         if Find (C2, C1.Base.Elements (I)) > 0 then\n+         if Find (C2, Get (Elements (C1), I)) > 0 then\n             P := P + 1;\n-            A.Elements (P) := C1.Base.Elements (I);\n+            A.Base.Elements (P) := Elements (C1) (I);\n          end if;\n       end loop;\n \n-      return Container'(Length => P, Base => A);\n+      return Container'(Length => P, Controlled_Base => A);\n    end Intersection;\n \n    ------------\n@@ -199,7 +304,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n    begin\n       for I in 1 .. C1.Length loop\n-         if Find (C2, C1.Base.Elements (I)) > 0 then\n+         if Find (C2, Get (Elements (C1), I)) > 0 then\n             P := P + 1;\n          end if;\n       end loop;\n@@ -214,21 +319,23 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    function Remove (C : Container; I : Index_Type) return Container is\n    begin\n       if To_Count (I) = C.Length then\n-         return Container'(Length => C.Length - 1, Base => C.Base);\n+         return Container'(Length          => C.Length - 1,\n+                           Controlled_Base => C.Controlled_Base);\n       else\n          declare\n-            A : constant Array_Base_Access := Content_Init (C.Length - 1);\n+            A : constant Array_Base_Controlled_Access\n+              := Content_Init (C.Length - 1);\n             P : Count_Type := 0;\n          begin\n-            A.Max_Length := C.Length - 1;\n+            A.Base.Max_Length := C.Length - 1;\n             for J in 1 .. C.Length loop\n                if J /= To_Count (I) then\n                   P := P + 1;\n-                  A.Elements (P) := C.Base.Elements (J);\n+                  A.Base.Elements (P) := Elements (C) (J);\n                end if;\n             end loop;\n \n-            return Container'(Length => C.Length - 1, Base => A);\n+            return Container'(Length => C.Length - 1, Controlled_Base => A);\n          end;\n       end if;\n    end Remove;\n@@ -277,13 +384,14 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       E : Element_Type) return Container\n    is\n       Result : constant Container :=\n-                 Container'(Length => C.Length,\n-                            Base => Content_Init (C.Length));\n+                 Container'(Length          => C.Length,\n+                            Controlled_Base => Content_Init (C.Length));\n+      R_Base : Array_Base_Access renames Result.Controlled_Base.Base;\n \n    begin\n-      Result.Base.Max_Length := C.Length;\n-      Result.Base.Elements (1 .. C.Length) := C.Base.Elements (1 .. C.Length);\n-      Result.Base.Elements (To_Count (I)) := new Element_Type'(E);\n+      R_Base.Max_Length := C.Length;\n+      R_Base.Elements (1 .. C.Length) := Elements (C) (1 .. C.Length);\n+      R_Base.Elements (To_Count (I)) := Element_Init (E);\n       return Result;\n    end Set;\n \n@@ -305,20 +413,19 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n       declare\n          L : constant Count_Type := Length (C1) - N + Length (C2);\n-         A : constant Array_Base_Access := Content_Init (L);\n+         A : constant Array_Base_Controlled_Access := Content_Init (L);\n          P : Count_Type := Length (C1);\n-\n       begin\n-         A.Max_Length := L;\n-         A.Elements (1 .. C1.Length) := C1.Base.Elements (1 .. C1.Length);\n+         A.Base.Max_Length := L;\n+         A.Base.Elements (1 .. C1.Length) := Elements (C1) (1 .. C1.Length);\n          for I in 1 .. C2.Length loop\n-            if Find (C1, C2.Base.Elements (I)) = 0 then\n+            if Find (C1, Get (Elements (C2), I)) = 0 then\n                P := P + 1;\n-               A.Elements (P) := C2.Base.Elements (I);\n+               A.Base.Elements (P) := Elements (C2) (I);\n             end if;\n          end loop;\n \n-         return Container'(Length => L, Base => A);\n+         return Container'(Length => L, Controlled_Base => A);\n       end;\n    end Union;\n "}, {"sha": "8a99a433837427edcb157bf8a384a5376c9cc67e", "filename": "gcc/ada/libgnat/a-cofuba.ads", "status": "modified", "additions": 79, "deletions": 11, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3949a2e785eb387d7e25d5ab06f4662d643d8fc/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3949a2e785eb387d7e25d5ab06f4662d643d8fc/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads?ref=f3949a2e785eb387d7e25d5ab06f4662d643d8fc", "patch": "@@ -34,6 +34,10 @@\n \n pragma Ada_2012;\n \n+--  To allow reference counting on the base container\n+\n+private with Ada.Finalization;\n+\n private generic\n    type Index_Type is (<>);\n    --  To avoid Constraint_Error being raised at run time, Index_Type'Base\n@@ -98,33 +102,97 @@ package Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n private\n \n+   --  Theoretically, each operation on a functional container implies the\n+   --  creation of a new container i.e. the copy of the array itself and all\n+   --  the elements in it. In the implementation, most of these copies are\n+   --  avoided by sharing between the containers.\n+   --\n+   --  A container stores its last used index. So, when adding an\n+   --  element at the end of the container, the exact same array can be reused.\n+   --  As a functionnal container cannot be modifed once created, there is no\n+   --  risk of unwanted modifications.\n+   --\n+   --                 _1_2_3_\n+   --  S             :    end       => [1, 2, 3]\n+   --                      |\n+   --                 |1|2|3|4|.|.|\n+   --                        |\n+   --  Add (S, 4, 4) :      end     => [1, 2, 3, 4]\n+   --\n+   --  The elements are also shared between containers as much as possible. For\n+   --  example, when something is added in the middle, the array is changed but\n+   --  the elementes are reused.\n+   --\n+   --                  _1_2_3_4_\n+   --  S             : |1|2|3|4|    => [1, 2, 3, 4]\n+   --                   |  \\ \\ \\\n+   --  Add (S, 2, 5) : |1|5|2|3|4|  => [1, 5, 2, 3, 4]\n+   --\n+   --  To make this sharing possible, both the elements and the arrays are\n+   --  stored inside dynamically allocated access types which shall be\n+   --  deallocated when they are no longer used. The memory is managed using\n+   --  reference counting both at the array and at the element level.\n+\n    subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n \n+   type Reference_Count_Type is new Natural;\n+\n    type Element_Access is access all Element_Type;\n \n+   type Refcounted_Element is record\n+      Reference_Count : Reference_Count_Type;\n+      E_Access        : Element_Access;\n+   end record;\n+\n+   type Refcounted_Element_Access is access Refcounted_Element;\n+\n+   type Controlled_Element_Access is new Ada.Finalization.Controlled\n+   with record\n+      Ref : Refcounted_Element_Access := null;\n+   end record;\n+\n+   function Element_Init (E : Element_Type) return Controlled_Element_Access;\n+   --  Use to initialize a refcounted element\n+\n    type Element_Array is\n-     array (Positive_Count_Type range <>) of Element_Access;\n+     array (Positive_Count_Type range <>) of Controlled_Element_Access;\n \n    type Element_Array_Access_Base is access Element_Array;\n \n-   subtype Element_Array_Access is not null Element_Array_Access_Base;\n-\n-   Empty_Element_Array_Access : constant Element_Array_Access :=\n-     new Element_Array'(1 .. 0 => null);\n+   subtype Element_Array_Access is Element_Array_Access_Base;\n \n    type Array_Base is record\n-     Max_Length : Count_Type;\n-     Elements   : Element_Array_Access;\n+     Reference_Count : Reference_Count_Type;\n+     Max_Length      : Count_Type;\n+     Elements        : Element_Array_Access;\n+   end record;\n+\n+   type Array_Base_Access is access Array_Base;\n+\n+   type Array_Base_Controlled_Access is new Ada.Finalization.Controlled\n+   with record\n+      Base : Array_Base_Access;\n    end record;\n \n-   type Array_Base_Access is not null access Array_Base;\n+   overriding procedure Adjust\n+     (Controlled_Base : in out Array_Base_Controlled_Access);\n+\n+   overriding procedure Finalize\n+     (Controlled_Base : in out Array_Base_Controlled_Access);\n+\n+   overriding procedure Adjust\n+     (Ctrl_E : in out Controlled_Element_Access);\n+\n+   overriding procedure Finalize\n+     (Ctrl_E : in out Controlled_Element_Access);\n \n-   function Content_Init (L : Count_Type := 0) return Array_Base_Access;\n+   function Content_Init (L : Count_Type := 0)\n+                          return Array_Base_Controlled_Access;\n    --  Used to initialize the content of an array base with length L\n \n    type Container is record\n-      Length : Count_Type := 0;\n-      Base   : Array_Base_Access := Content_Init;\n+      Length          : Count_Type := 0;\n+      Controlled_Base : Array_Base_Controlled_Access := Content_Init;\n    end record;\n \n end Ada.Containers.Functional_Base;"}]}