{"sha": "01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiZWVjNjVkOGIwNmY5MzYxZTcwNDQyZjE0YmNmMmQ5OWQ0YjRhYQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2001-05-03T19:56:46Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2001-05-03T19:56:46Z"}, "message": "Report fixes from 3_0-branch made on 2001-03-04:\n\n\t* config/m68hc11/larith.asm (__mulqi3): Fix multiplication of two\n\tnegative numbers.\n\t(___subdi3, ___adddi3): Use x instead of y as index register.\n\t(__init_bss_section, __map_data_section): Optimize for 68HC12.\n\t(__memset, __memcpy): Likewise.\n\t(regs): Put the soft registers in bss for 68HC12.\n\t(abort): Use trap to abort for 68hc12.\n\t(__mulhi3, __mulhi32): Use emul for 68hc12.\n\t(__mulsi3): Avoid to use the tmp soft register for 68hc12.\n\t* config/m68hc11/m68hc11.h (LIMIT_RELOAD_CLASS): Don't define.\n\t* config/m68hc11/m68hc11-protos.h (limit_reload_class): Remove.\n\t* config/m68hc11/m68hc11.c (limit_reload_class): Remove.\n\t(m68hc11_override_options): Remove setting of flag_no_nonansi_builtin.\n\tSet 68HC12 min offset to -65536.\n\t(print_operand): Put parenthesis arround the operand if it refers\n\tto a symbol having the same name as a register.\n\t(m68hc11_z_replacement): When z register is replaced by its\n\tequivalent soft register, force the insn to be re-recognized.\n\t(m68hc11_check_z_replacement): Fix the test when destination is\n\tthe index register and z dies in the insn.\n\t(m68hc11_reorg): Remove the REG_DEAD notes beforce recomputing them.\n\t* config/m68hc11/m68hc11.c (m68hc11_override_options): Initialize\n\tcosts according to processor variant.\n\t(m68hc11_shift_cost): New function to compute shift costs.\n\t(m68hc11_rtx_costs): Define costs according to processor variant.\n\t(m6811_cost): Costs for 68HC11.\n\t(m6812_cost): Costs for 68HC12.\n\t(COSTS_N_INSNS): Remove.\n\n\t* config/m68hc11/m68hc11.h (RTX_COSTS): New.\n\t(DEFAULT_RTX_COSTS): Remove.\n\t(CONST_COSTS): Define costs according to OUTER_CODE.\n\t(processor_costs): New struct to define costs.\n\t(m68hc11_cost): Pointer to current costs.\n\n\t* config/m68hc11/m68hc11.md (*addhi3_68hc12): Fix generation\n\tand use m68hc11_notice_keep_cc when using leax/leay.\n\t(addhi3 split): Reject split if the insn is handled by\n\tleax/leay above.\n\t* config/m68hc11/m68hc11.c (m68hc11_split_move): For 68HC12 the\n\tpush must be handled in a special way if the source operand uses\n\tsp as index register.\n\t(m68hc11_notice_keep_cc): New function.\n\t(m68hc11_gen_movhi): Use it when an insn changes a register but\n\tnot the flags.\n\t(m68hc11_gen_movqi): Fix move for 68HC12.\n\t* config/m68hc11/m68hc11-protos.h (m68hc11_notice_keep_cc): Declare.\n\n\t* config/m68hc11/m68hc11.c (m68hc11_emit_libcall): Use LCT_CONST\n\tand don't pass operands[0] to emit_library_call_value.\n\n\t* config/m68hc11/m68hc11.md (tsthi_1): Use cpd for 68HC12.\n\t(zero_extendsi split): Simplify and use (zero_extendhi).\n\t(*addhi3): Remove 'w' constraint since stack pointer is handled\n\tby (addhi3_sp).\n\t(*ashlhi3_2): Operand 2 is clobbered use '+' for its constraint.\n\t(*ashlhi3, *ashrhi3, *lshrhi3): Likewise.\n\t(*ashrhi3_const): Fix shift by 7.\n\t(*lshrsi3_const16): Fix template.\n\t(call, call_value): Fix constraint and predicate.\n\n\t* config/m68hc11/m68hc11.md (X_REGNUM, D_REGNUM): New constant.\n\t(Y_REGNUM, SP_REGNUM, PC_REGNUM, A_REGNUM, B_REGNUM): Likewise.\n\t(CC_REGNUM): Likewise.\n\t(*unnamed splits): Use above constants instead of hard coded numbers.\n\t(*adcq, *subcq, *addsi_carry, *rotlqi3_with_carry): Likewise.\n\t(*rotlhi3_with_carry, *rotrhi3_with_carry): Likewise.\n\t(*return_16bit, *unnamed peepholes): Likewise.\n\nFrom-SVN: r41802", "tree": {"sha": "6878bddf505ac0298cfac4e8e82ecf1d38d6e45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6878bddf505ac0298cfac4e8e82ecf1d38d6e45a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/comments", "author": null, "committer": null, "parents": [{"sha": "6e26f4aa9ffe42bf905bed5e50b29414bd2cf28d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e26f4aa9ffe42bf905bed5e50b29414bd2cf28d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e26f4aa9ffe42bf905bed5e50b29414bd2cf28d"}], "stats": {"total": 1129, "additions": 764, "deletions": 365}, "files": [{"sha": "8d5c1e73bb7d0b1328b5666957bf773e5e1cbb36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "patch": "@@ -1,3 +1,88 @@\n+2001-05-03  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/larith.asm (__mulqi3): Fix multiplication of two\n+\tnegative numbers.\n+\t(___subdi3, ___adddi3): Use x instead of y as index register.\n+\t(__init_bss_section, __map_data_section): Optimize for 68HC12.\n+\t(__memset, __memcpy): Likewise.\n+\t(regs): Put the soft registers in bss for 68HC12.\n+\t(abort): Use trap to abort for 68hc12.\n+\t(__mulhi3, __mulhi32): Use emul for 68hc12.\n+\t(__mulsi3): Avoid to use the tmp soft register for 68hc12.\n+\n+2001-05-03  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.h (LIMIT_RELOAD_CLASS): Don't define.\n+\t* config/m68hc11/m68hc11-protos.h (limit_reload_class): Remove.\n+\t* config/m68hc11/m68hc11.c (limit_reload_class): Remove.\n+\t(m68hc11_override_options): Remove setting of flag_no_nonansi_builtin.\n+\tSet 68HC12 min offset to -65536.\n+\t(print_operand): Put parenthesis arround the operand if it refers \n+\tto a symbol having the same name as a register.\n+\t(m68hc11_z_replacement): When z register is replaced by its \n+\tequivalent soft register, force the insn to be re-recognized.\n+\t(m68hc11_check_z_replacement): Fix the test when destination is\n+\tthe index register and z dies in the insn.\n+\t(m68hc11_reorg): Remove the REG_DEAD notes beforce recomputing them.\n+\n+2001-05-03  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.c (m68hc11_override_options): Initialize\n+\tcosts according to processor variant.\n+\t(m68hc11_shift_cost): New function to compute shift costs.\n+\t(m68hc11_rtx_costs): Define costs according to processor variant.\n+\t(m6811_cost): Costs for 68HC11.\n+\t(m6812_cost): Costs for 68HC12.\n+\t(COSTS_N_INSNS): Remove.\n+\n+\t* config/m68hc11/m68hc11.h (RTX_COSTS): New.\n+\t(DEFAULT_RTX_COSTS): Remove.\n+\t(CONST_COSTS): Define costs according to OUTER_CODE.\n+\t(processor_costs): New struct to define costs.\n+\t(m68hc11_cost): Pointer to current costs.\n+\n+2001-05-03  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.md (*addhi3_68hc12): Fix generation\n+\tand use m68hc11_notice_keep_cc when using leax/leay.\n+\t(addhi3 split): Reject split if the insn is handled by \n+\tleax/leay above.\n+\t* config/m68hc11/m68hc11.c (m68hc11_split_move): For 68HC12 the\n+\tpush must be handled in a special way if the source operand uses\n+\tsp as index register.\n+\t(m68hc11_notice_keep_cc): New function.\n+\t(m68hc11_gen_movhi): Use it when an insn changes a register but \n+\tnot the flags.\n+\t(m68hc11_gen_movqi): Fix move for 68HC12.\n+\t* config/m68hc11/m68hc11-protos.h (m68hc11_notice_keep_cc): Declare.\n+\n+2001-05-03  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.c (m68hc11_emit_libcall): Use LCT_CONST\n+\tand don't pass operands[0] to emit_library_call_value.\n+\n+2001-05-03  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.md (tsthi_1): Use cpd for 68HC12.\n+\t(zero_extendsi split): Simplify and use (zero_extendhi).\n+\t(*addhi3): Remove 'w' constraint since stack pointer is handled \n+\tby (addhi3_sp).\n+\t(*ashlhi3_2): Operand 2 is clobbered use '+' for its constraint.\n+\t(*ashlhi3, *ashrhi3, *lshrhi3): Likewise.\n+\t(*ashrhi3_const): Fix shift by 7.\n+\t(*lshrsi3_const16): Fix template.\n+\t(call, call_value): Fix constraint and predicate.\n+\n+2001-05-03  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.md (X_REGNUM, D_REGNUM): New constant.\n+\t(Y_REGNUM, SP_REGNUM, PC_REGNUM, A_REGNUM, B_REGNUM): Likewise.\n+\t(CC_REGNUM): Likewise.\n+\t(*unnamed splits): Use above constants instead of hard coded numbers.\n+\t(*adcq, *subcq, *addsi_carry, *rotlqi3_with_carry): Likewise.\n+\t(*rotlhi3_with_carry, *rotrhi3_with_carry): Likewise.\n+\t(*return_16bit, *unnamed peepholes): Likewise.\n+\n 2001-05-03  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config.gcc(rs6000-ibm-aix|powerpc-ibm-aix):  Do not include"}, {"sha": "fe707025b63a0bd04717d8fb2bc820af0d507565", "filename": "gcc/config/m68hc11/larith.asm", "status": "modified", "additions": 92, "deletions": 19, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Flarith.asm?ref=01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "patch": "@@ -1,5 +1,5 @@\n-/* libgcc1 routines for M68HC11.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* libgcc1 routines for M68HC11 & M68HC12.\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -47,7 +47,11 @@ NAME:\t.word 0;\t\t\t\\\n /* Pseudo hard registers used by gcc.\n    They must be located in page0. \n    They will normally appear at the end of .page0 section.  */\n+#ifdef mc68hc12\n+\t.sect .bss\n+#else\n \t.sect .page0\n+#endif\n \t.globl _.tmp,_.frame\n \t.globl _.z,_.xy\n REG(_.tmp)\n@@ -61,7 +65,11 @@ REG(_.frame)\n /* Pseudo hard registers used by gcc.\n    They must be located in page0. \n    They will normally appear at the end of .page0 section.  */\n+#ifdef mc68hc12\n+\t.sect .bss\n+#else\n \t.sect .page0\n+#endif\n \t.globl _.d1,_.d2,_.d3,_.d4,_.d5,_.d6\n \t.globl _.d7,_.d8\n REG(_.d1)\n@@ -97,7 +105,11 @@ REG(_.d16)\n /* Pseudo hard registers used by gcc.\n    They must be located in page0. \n    They will normally appear at the end of .page0 section.  */\n+#ifdef mc68hc12\n+\t.sect .bss\n+#else\n \t.sect .page0\n+#endif\n \t.globl _.d17,_.d18,_.d19,_.d20,_.d21,_.d22\n \t.globl _.d23,_.d24,_.d25,_.d26,_.d27,_.d28\n \t.globl _.d29,_.d30,_.d31,_.d32\n@@ -157,8 +169,12 @@ fatal:\n \t.globl abort\n abort:\n \tldd\t#255\t\t; \n+#ifdef mc68hc12\n+\ttrap\t#0x30\n+#else\n \t.byte 0xCD\t\t; Generate an illegal instruction trap\n \t.byte 0x03\t\t; The simulator catches this and stops.\n+#endif\n \tjmp _exit\n #endif\n \t\n@@ -189,6 +205,23 @@ _cleanup:\n ;;; \n __memcpy:\n memcpy:\n+#ifdef mc68hc12\n+\tldx\t2,sp\n+\tldy\t4,sp\n+\tpshd\n+\txgdy\n+\tlsrd\n+\tbcc\tStart\n+\tmovb\t1,x+,1,y+\n+Start:\n+\tbeq\tDone\n+Loop:\n+\tmovw\t2,x+,2,y+\n+\tdbne\td,Loop\n+Done:\n+\tpuld\n+\trts\n+#else\n \txgdy\n \ttsx\n \tldd\t4,x\n@@ -214,6 +247,7 @@ End:\n \txgdy\n \trts\n #endif\n+#endif\n \n #ifdef L_memset\n \t.sect .text\n@@ -237,6 +271,19 @@ End:\n #endif\n __memset:\n memset:\n+#ifdef mc68hc12\n+\txgdx\n+\tldab\tval,sp\n+\tldy\tsize,sp\n+\tpshx\n+\tbeq\tEnd\n+Loop:\n+\tstab\t1,x+\n+\tdbne\ty,Loop\n+End:\n+\tpuld\n+\trts\n+#else\n \txgdx\n \ttsy\n \tldab\tval,y\n@@ -253,36 +300,36 @@ End:\n \txgdx\n \trts\n #endif\n+#endif\n \t\t\n #ifdef L_adddi3\n \t.sect .text\n \t.globl ___adddi3\n \n ___adddi3:\n \ttsx\n-\ttsy\n \tpshb\n \tpsha\n \tldd\t8,x\n-\taddd\t16,y\n+\taddd\t16,x\n \tpshb\n \tpsha\n \n \tldd\t6,x\n-\tadcb\t15,y\n-\tadca\t14,y\n+\tadcb\t15,x\n+\tadca\t14,x\n \tpshb\n \tpsha\n \n \tldd\t4,x\n-\tadcb\t13,y\n-\tadca\t12,y\n+\tadcb\t13,x\n+\tadca\t12,x\n \tpshb\n \tpsha\n \t\n \tldd\t2,x\n-\tadcb\t11,y\n-\tadca\t10,y\n+\tadcb\t11,x\n+\tadca\t10,x\n \ttsx\n \tldy\t6,x\n \n@@ -303,29 +350,28 @@ ___adddi3:\n \n ___subdi3:\n \ttsx\n-\ttsy\n \tpshb\n \tpsha\n \tldd\t8,x\n-\tsubd\t16,y\n+\tsubd\t16,x\n \tpshb\n \tpsha\n \n \tldd\t6,x\n-\tsbcb\t15,y\n-\tsbca\t14,y\n+\tsbcb\t15,x\n+\tsbca\t14,x\n \tpshb\n \tpsha\n \n \tldd\t4,x\n-\tsbcb\t13,y\n-\tsbca\t12,y\n+\tsbcb\t13,x\n+\tsbca\t12,x\n \tpshb\n \tpsha\n \t\n \tldd\t2,x\n-\tsbcb\t11,y\n-\tsbca\t10,y\n+\tsbcb\t11,x\n+\tsbca\t10,x\n \t\n \ttsx\n \tldy\t6,x\n@@ -681,7 +727,6 @@ A_or_B_neg:\n \taddd\t#1\n \trts\n AB_neg:\n-\tnega\n \tnegb\n \tmul\n \trts\n@@ -699,6 +744,13 @@ AB_neg:\n ;\tb = register X\n ;\n ___mulhi3:\n+#ifdef mc68hc12\n+\tpshx\t\t\t; Preserve X\n+\texg\tx,y\n+\temul\n+\texg\tx,y\n+\tpulx\n+#else\n \tstx\t*_.tmp\n \tpshb\n \tldab\t*_.tmp+1\n@@ -714,6 +766,7 @@ ___mulhi3:\n \tpulb\n \tmul\t\t\t; A.low * B.low\n \tadda\t*_.tmp\n+#endif\n \trts\n #endif\n \n@@ -750,6 +803,11 @@ ___mulhi3:\n ;      <A-high>   0,x\n ;\n __mulhi32:\n+#ifdef mc68hc12\n+\tldy\t2,sp\n+\temul\n+\texg\tx,y\n+#else\n \tpshb\n \tpsha\n \ttsx\n@@ -781,6 +839,7 @@ N:\n Ret:\n \tpshy\n \tpulx\n+#endif\n \trts\n \t\n #endif\n@@ -823,7 +882,11 @@ __mulsi3:\n ;\n ; If A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)\n ;\n+#ifdef mc68hc12\n+\tcpx\t#0\n+#else\n \tstx\t*_.tmp\n+#endif\n \tbeq\tA_high_zero\n \tbsr\t___mulhi3\t\t; A.high * B.low\n ;\n@@ -933,6 +996,10 @@ __map_data_section:\n \tldx\t#__data_image\n \tldy\t#__data_section_start\n Loop:\n+#ifdef mc68hc12\n+\tmovb\t1,x+,1,y+\n+\tdbne\td,Loop\n+#else\n \tpsha\n \tldaa\t0,x\n \tstaa\t0,y\n@@ -941,6 +1008,7 @@ Loop:\n \tiny\n \tsubd\t#1\n \tbne\tLoop\n+#endif\n Done:\n \n #endif\n@@ -955,10 +1023,15 @@ __init_bss_section:\n \tbeq\tDone\n \tldx\t#__bss_start\n Loop:\n+#ifdef mc68hc12\n+\tclr\t1,x+\n+\tdbne\td,Loop\n+#else\n \tclr\t0,x\n \tinx\n \tsubd\t#1\n \tbne\tLoop\n+#endif\n Done:\n \n #endif"}, {"sha": "8aaa76ce9bf8c156ab133351d40ba1587bbda30a", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for exported functions defined in m68hc11.c\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Stephane Carrez (stcarrez@worldnet.fr)\n \n This file is part of GNU CC.\n@@ -70,6 +70,7 @@ extern int m68hc11_go_if_legitimate_address PARAMS((rtx,\n extern int m68hc11_legitimize_address PARAMS((rtx*, rtx, enum machine_mode));\n \n extern void m68hc11_notice_update_cc PARAMS((rtx, rtx));\n+extern void m68hc11_notice_keep_cc PARAMS((rtx));\n \n extern void m68hc11_reorg PARAMS((rtx));\n \n@@ -137,8 +138,6 @@ extern int hard_reg_operand PARAMS((rtx, enum machine_mode));\n extern int soft_reg_operand PARAMS((rtx, enum machine_mode));\n extern int reg_or_some_mem_operand PARAMS((rtx, enum machine_mode));\n \n-extern enum reg_class limit_reload_class PARAMS((enum machine_mode, enum reg_class));\n-\n #if defined TREE_CODE\n extern void m68hc11_init_cumulative_args PARAMS((CUMULATIVE_ARGS*,\n                                                  tree,"}, {"sha": "99baa51a102762ff5f0101c9b2ba3b7818083929", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 289, "deletions": 127, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "patch": "@@ -62,7 +62,7 @@ static int go_if_legitimate_address_internal PARAMS((rtx, enum machine_mode,\n static int register_indirect_p PARAMS((rtx, enum machine_mode, int));\n static rtx m68hc11_expand_compare PARAMS((enum rtx_code, rtx, rtx));\n static int must_parenthesize PARAMS ((rtx));\n-\n+static int m68hc11_shift_cost PARAMS ((enum machine_mode, rtx, int));\n static int m68hc11_auto_inc_p PARAMS ((rtx));\n \n void create_regs_rtx PARAMS ((void));\n@@ -120,6 +120,78 @@ rtx m68hc11_compare_op0;\n rtx m68hc11_compare_op1;\n \f\n \n+struct processor_costs *m68hc11_cost;\n+\n+/* Costs for a 68HC11.  */\n+struct processor_costs m6811_cost = {\n+  /* add */\n+  COSTS_N_INSNS (2),\n+  /* logical */\n+  COSTS_N_INSNS (2),\n+  /* non-constant shift */\n+  COSTS_N_INSNS (20),\n+  /* shiftQI const */\n+  { COSTS_N_INSNS (0), COSTS_N_INSNS (1), COSTS_N_INSNS (2),\n+    COSTS_N_INSNS (3), COSTS_N_INSNS (4), COSTS_N_INSNS (3),\n+    COSTS_N_INSNS (2), COSTS_N_INSNS (1) },\n+\n+  /* shiftHI const */\n+  { COSTS_N_INSNS (0), COSTS_N_INSNS (2), COSTS_N_INSNS (4),\n+    COSTS_N_INSNS (6), COSTS_N_INSNS (8), COSTS_N_INSNS (6),\n+    COSTS_N_INSNS (4), COSTS_N_INSNS (2),\n+    COSTS_N_INSNS (2), COSTS_N_INSNS (4),\n+    COSTS_N_INSNS (6), COSTS_N_INSNS (8), COSTS_N_INSNS (10),\n+    COSTS_N_INSNS (8), COSTS_N_INSNS (6), COSTS_N_INSNS (4)\n+  },\n+  /* mulQI */\n+  COSTS_N_INSNS (20),\n+  /* mulHI */\n+  COSTS_N_INSNS (20 * 4),\n+  /* mulSI */\n+  COSTS_N_INSNS (20 * 16),\n+  /* divQI */\n+  COSTS_N_INSNS (20),\n+  /* divHI */\n+  COSTS_N_INSNS (80),\n+  /* divSI */\n+  COSTS_N_INSNS (100)\n+};\n+\n+/* Costs for a 68HC12.  */\n+struct processor_costs m6812_cost = {\n+  /* add */\n+  COSTS_N_INSNS (1),\n+  /* logical */\n+  COSTS_N_INSNS (1),\n+  /* non-constant shift */\n+  COSTS_N_INSNS (20),\n+  /* shiftQI const */\n+  { COSTS_N_INSNS (0), COSTS_N_INSNS (1), COSTS_N_INSNS (2),\n+    COSTS_N_INSNS (3), COSTS_N_INSNS (4), COSTS_N_INSNS (3),\n+    COSTS_N_INSNS (2), COSTS_N_INSNS (1) },\n+\n+  /* shiftHI const */\n+  { COSTS_N_INSNS (0), COSTS_N_INSNS (2), COSTS_N_INSNS (4),\n+    COSTS_N_INSNS (6), COSTS_N_INSNS (8), COSTS_N_INSNS (6),\n+    COSTS_N_INSNS (4), COSTS_N_INSNS (2),\n+    COSTS_N_INSNS (2), COSTS_N_INSNS (4), COSTS_N_INSNS (6),\n+    COSTS_N_INSNS (8), COSTS_N_INSNS (10), COSTS_N_INSNS (8),\n+    COSTS_N_INSNS (6), COSTS_N_INSNS (4)\n+  },\n+  /* mulQI */\n+  COSTS_N_INSNS (3),\n+  /* mulHI */\n+  COSTS_N_INSNS (3),\n+  /* mulSI */\n+  COSTS_N_INSNS (3 * 4),\n+  /* divQI */\n+  COSTS_N_INSNS (12),\n+  /* divHI */\n+  COSTS_N_INSNS (12),\n+  /* divSI */\n+  COSTS_N_INSNS (100)\n+};\n+\n /* Machine specific options */\n \n const char *m68hc11_regparm_string;\n@@ -130,24 +202,11 @@ static void m68hc11_add_gc_roots PARAMS ((void));\n \n static int nb_soft_regs;\n \n-/* Flag defined in c-decl.c\n-\n-   Nonzero means don't recognize the non-ANSI builtin functions.\n-   -ansi sets this.\n-\n-   It is set by 'm68hc11_override_options' to ensure that bcmp() and\n-   bzero() are not defined.  Their prototype are wrong and they\n-   conflict with newlib definition.  Don't define as external to\n-   avoid a link problem for f77.  */\n-int flag_no_nonansi_builtin;\n-\n int\n m68hc11_override_options ()\n {\n   m68hc11_add_gc_roots ();\n \n-  flag_no_nonansi_builtin = 1;\n-  \n   memset (m68hc11_reg_valid_for_index, 0,\n \t  sizeof (m68hc11_reg_valid_for_index));\n   memset (m68hc11_reg_valid_for_base, 0, sizeof (m68hc11_reg_valid_for_base));\n@@ -159,7 +218,8 @@ m68hc11_override_options ()\n          a -m68hc11 option was specified on the command line.  */\n       if (TARGET_DEFAULT != MASK_M6811)\n         target_flags &= ~TARGET_DEFAULT;\n-      \n+\n+      m68hc11_cost = &m6811_cost;\n       m68hc11_min_offset = 0;\n       m68hc11_max_offset = 256;\n       m68hc11_index_reg_class = NO_REGS;\n@@ -176,7 +236,8 @@ m68hc11_override_options ()\n   /* Configure for a 68hc12 processor.  */\n   if (TARGET_M6812)\n     {\n-      m68hc11_min_offset = 0;\n+      m68hc11_cost = &m6812_cost;\n+      m68hc11_min_offset = -65536;\n       m68hc11_max_offset = 65536;\n       m68hc11_index_reg_class = D_REGS;\n       m68hc11_base_reg_class = A_OR_SP_REGS;\n@@ -277,29 +338,6 @@ hard_regno_mode_ok (regno, mode)\n     }\n }\n \n-enum reg_class\n-limit_reload_class (mode, class)\n-     enum machine_mode mode;\n-     enum reg_class class;\n-{\n-  if (mode == Pmode)\n-    {\n-      if (class == m68hc11_base_reg_class || class == SP_REGS\n-\t  || class == Y_REGS || class == X_REGS\n-\t  || class == X_OR_SP_REGS || class == Y_OR_S_REGS\n-\t  || class == A_OR_SP_REGS)\n-\treturn class;\n-\n-      if (debug_m6811)\n-\t{\n-\t  printf (\"Forcing to A_REGS\\n\");\n-\t  fflush (stdout);\n-\t}\n-      return m68hc11_base_reg_class;\n-    }\n-  return class;\n-}\n-\n enum reg_class\n preferred_reload_class (operand, class)\n      rtx operand;\n@@ -733,13 +771,14 @@ m68hc11_emit_libcall (name, code, dmode, smode, noperands, operands)\n   switch (noperands)\n     {\n     case 2:\n-      ret = emit_library_call_value (libcall, NULL_RTX, 1, dmode, 1,\n-                                     operands[1], smode);\n+      ret = emit_library_call_value (libcall, NULL_RTX, LCT_CONST,\n+                                     dmode, 1, operands[1], smode);\n       equiv = gen_rtx (code, dmode, operands[1]);\n       break;\n \n     case 3:\n-      ret = emit_library_call_value (libcall, operands[0], 1, dmode, 2,\n+      ret = emit_library_call_value (libcall, NULL_RTX,\n+                                     LCT_CONST, dmode, 2,\n                                      operands[1], smode, operands[2],\n                                      smode);\n       equiv = gen_rtx (code, dmode, operands[1], operands[2]);\n@@ -2125,9 +2164,19 @@ print_operand (file, op, letter)\n     }\n   else\n     {\n+      int need_parenthesize = 0;\n+\n       if (letter != 'i')\n \tasm_fprintf (file, \"%0I\");\n+      else\n+        need_parenthesize = must_parenthesize (op);\n+\n+      if (need_parenthesize)\n+        asm_fprintf (file, \"(\");\n+\n       output_addr_const (file, op);\n+      if (need_parenthesize)\n+        asm_fprintf (file, \")\");\n     }\n }\n \n@@ -2508,6 +2557,7 @@ m68hc11_split_move (to, from, scratch)\n   rtx low_to, low_from;\n   rtx high_to, high_from;\n   enum machine_mode mode;\n+  int offset = 0;\n \n   mode = GET_MODE (to);\n   if (GET_MODE_SIZE (mode) == 8)\n@@ -2517,6 +2567,22 @@ m68hc11_split_move (to, from, scratch)\n   else\n     mode = QImode;\n \n+  if (TARGET_M6812\n+      && IS_STACK_PUSH (to)\n+      && reg_mentioned_p (gen_rtx (REG, HImode, HARD_SP_REGNUM), from))\n+    {\n+      if (mode == SImode)\n+        {\n+          offset = 4;\n+        }\n+      else if (mode == HImode)\n+        {\n+          offset = 2;\n+        }\n+      else\n+        offset = 0;\n+    }\n+\n   low_to = m68hc11_gen_lowpart (mode, to);\n   high_to = m68hc11_gen_highpart (mode, to);\n \n@@ -2531,6 +2597,11 @@ m68hc11_split_move (to, from, scratch)\n   else\n     high_from = m68hc11_gen_highpart (mode, from);\n \n+  if (offset)\n+    {\n+      high_from = adj_offsettable_operand (high_from, offset);\n+      low_from = high_from;\n+    }\n   if (mode == SImode)\n     {\n       m68hc11_split_move (low_to, low_from, scratch);\n@@ -2823,6 +2894,7 @@ m68hc11_gen_movhi (insn, operands)\n     {\n       if (IS_STACK_PUSH (operands[0]) && H_REG_P (operands[1]))\n \t{\n+          cc_status = cc_prev_status;\n \t  switch (REGNO (operands[1]))\n \t    {\n \t    case HARD_X_REGNUM:\n@@ -2837,6 +2909,7 @@ m68hc11_gen_movhi (insn, operands)\n \t}\n       if (IS_STACK_POP (operands[1]) && H_REG_P (operands[0]))\n \t{\n+          cc_status = cc_prev_status;\n \t  switch (REGNO (operands[0]))\n \t    {\n \t    case HARD_X_REGNUM:\n@@ -2851,6 +2924,7 @@ m68hc11_gen_movhi (insn, operands)\n \t}\n       if (H_REG_P (operands[0]) && H_REG_P (operands[1]))\n \t{\n+          m68hc11_notice_keep_cc (operands[0]);\n \t  output_asm_insn (\"tfr\\t%1,%0\", operands);\n \t}\n       else if (H_REG_P (operands[0]))\n@@ -2892,6 +2966,7 @@ m68hc11_gen_movhi (insn, operands)\n \t      else\n \t\t{\n \t\t  /* !!!! SCz wrong here.  */\n+                  fatal_insn (\"Move insn not handled\", insn);\n \t\t}\n \t    }\n \t  else\n@@ -2903,6 +2978,7 @@ m68hc11_gen_movhi (insn, operands)\n \t\t}\n \t      else\n \t\t{\n+                  m68hc11_notice_keep_cc (operands[0]);\n \t\t  output_asm_insn (\"movw\\t%1,%0\", operands);\n \t\t}\n \t    }\n@@ -2912,6 +2988,7 @@ m68hc11_gen_movhi (insn, operands)\n \n   if (IS_STACK_POP (operands[1]) && H_REG_P (operands[0]))\n     {\n+      cc_status = cc_prev_status;\n       switch (REGNO (operands[0]))\n \t{\n \tcase HARD_X_REGNUM:\n@@ -2947,7 +3024,7 @@ m68hc11_gen_movhi (insn, operands)\n \t\t}\n \t      else\n \t\t{\n-\t\t  cc_status = cc_prev_status;\n+                  m68hc11_notice_keep_cc (operands[0]);\n \t\t  output_asm_insn (\"pshx\\n\\tpula\\n\\tpulb\", operands);\n \t\t}\n \t    }\n@@ -3002,7 +3079,7 @@ m68hc11_gen_movhi (insn, operands)\n \t\t}\n \t      else\n \t\t{\n-\t\t  cc_status = cc_prev_status;\n+\t\t  m68hc11_notice_keep_cc (operands[0]);\n \t\t  output_asm_insn (\"pshb\", operands);\n \t\t  output_asm_insn (\"psha\", operands);\n \t\t  output_asm_insn (\"pulx\", operands);\n@@ -3058,7 +3135,7 @@ m68hc11_gen_movhi (insn, operands)\n \tcase HARD_SP_REGNUM:\n \t  if (D_REG_P (operands[1]))\n \t    {\n-\t      cc_status = cc_prev_status;\n+\t      m68hc11_notice_keep_cc (operands[0]);\n \t      output_asm_insn (\"xgdx\", operands);\n \t      output_asm_insn (\"txs\", operands);\n \t      output_asm_insn (\"xgdx\", operands);\n@@ -3099,6 +3176,7 @@ m68hc11_gen_movhi (insn, operands)\n \n   if (IS_STACK_PUSH (operands[0]) && H_REG_P (operands[1]))\n     {\n+      cc_status = cc_prev_status;\n       switch (REGNO (operands[1]))\n \t{\n \tcase HARD_X_REGNUM:\n@@ -3182,25 +3260,26 @@ m68hc11_gen_movqi (insn, operands)\n \n       if (H_REG_P (operands[0]) && H_REG_P (operands[1]))\n \t{\n+          m68hc11_notice_keep_cc (operands[0]);\n \t  output_asm_insn (\"tfr\\t%1,%0\", operands);\n \t}\n       else if (H_REG_P (operands[0]))\n \t{\n \t  if (Q_REG_P (operands[0]))\n-\t    output_asm_insn (\"lda%0\\t%1\", operands);\n+\t    output_asm_insn (\"lda%0\\t%b1\", operands);\n \t  else if (D_REG_P (operands[0]))\n-\t    output_asm_insn (\"ldab\\t%1\", operands);\n+\t    output_asm_insn (\"ldab\\t%b1\", operands);\n \t  else\n-\t    output_asm_insn (\"ld%0\\t%1\", operands);\n+\t    goto m6811_move;\n \t}\n       else if (H_REG_P (operands[1]))\n \t{\n \t  if (Q_REG_P (operands[1]))\n-\t    output_asm_insn (\"sta%1\\t%0\", operands);\n+\t    output_asm_insn (\"sta%1\\t%b0\", operands);\n \t  else if (D_REG_P (operands[1]))\n-\t    output_asm_insn (\"staa\\t%0\", operands);\n+\t    output_asm_insn (\"stab\\t%b0\", operands);\n \t  else\n-\t    output_asm_insn (\"st%1\\t%0\", operands);\n+\t    goto m6811_move;\n \t}\n       else\n \t{\n@@ -3227,6 +3306,7 @@ m68hc11_gen_movqi (insn, operands)\n \t      else\n \t\t{\n \t\t  /* !!!! SCz wrong here.  */\n+                  fatal_insn (\"Move insn not handled\", insn);\n \t\t}\n \t    }\n \t  else\n@@ -3237,13 +3317,15 @@ m68hc11_gen_movqi (insn, operands)\n \t\t}\n \t      else\n \t\t{\n-\t\t  output_asm_insn (\"movb\\t%1,%0\", operands);\n+                  m68hc11_notice_keep_cc (operands[0]);\n+\t\t  output_asm_insn (\"movb\\t%b1,%b0\", operands);\n \t\t}\n \t    }\n \t}\n       return;\n     }\n \n+ m6811_move:\n   if (H_REG_P (operands[0]))\n     {\n       switch (REGNO (operands[0]))\n@@ -3618,6 +3700,24 @@ m68hc11_notice_update_cc (exp, insn)\n       && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n     cc_status.value2 = 0;\n }\n+\n+/* The current instruction does not affect the flags but changes\n+   the register 'reg'.  See if the previous flags can be kept for the\n+   next instruction to avoid a comparison.  */\n+void\n+m68hc11_notice_keep_cc (reg)\n+     rtx reg;\n+{\n+  if (reg == 0\n+      || cc_prev_status.value1 == 0\n+      || rtx_equal_p (reg, cc_prev_status.value1)\n+      || (cc_prev_status.value2\n+          && reg_mentioned_p (reg, cc_prev_status.value2)))\n+    CC_STATUS_INIT;\n+  else\n+    cc_status = cc_prev_status;\n+}\n+\n \f\n \n /* Machine Specific Reorg. */\n@@ -3911,7 +4011,7 @@ m68hc11_check_z_replacement (insn, info)\n \t    }\n \t  info->x_used = 1;\n \t  if (z_dies_here && !reg_mentioned_p (src, ix_reg)\n-\t      && GET_CODE (src) == REG && REGNO (src) == HARD_X_REGNUM)\n+\t      && GET_CODE (dst) == REG && REGNO (dst) == HARD_X_REGNUM)\n \t    {\n \t      info->need_save_z = 0;\n \t      info->z_died = 1;\n@@ -3982,7 +4082,7 @@ m68hc11_check_z_replacement (insn, info)\n \t    }\n \t  info->y_used = 1;\n \t  if (z_dies_here && !reg_mentioned_p (src, iy_reg)\n-\t      && GET_CODE (src) == REG && REGNO (src) == HARD_Y_REGNUM)\n+\t      && GET_CODE (dst) == REG && REGNO (dst) == HARD_Y_REGNUM)\n \t    {\n \t      info->need_save_z = 0;\n \t      info->z_died = 1;\n@@ -4356,6 +4456,8 @@ m68hc11_z_replacement (insn)\n \t       && INTVAL (src) == 0)\n \t{\n \t  XEXP (body, 0) = gen_rtx (REG, GET_MODE (dst), SOFT_Z_REGNUM);\n+          /* Force it to be re-recognized.  */\n+          INSN_CODE (insn) = -1;\n \t  return;\n \t}\n     }\n@@ -4577,6 +4679,7 @@ m68hc11_reorg (first)\n      rtx first;\n {\n   int split_done = 0;\n+  rtx insn;\n \n   z_replacement_completed = 0;\n   z_reg = gen_rtx (REG, HImode, HARD_Z_REGNUM);\n@@ -4602,6 +4705,28 @@ m68hc11_reorg (first)\n      description to use the best assembly directives.  */\n   if (optimize)\n     {\n+      /* Before recomputing the REG_DEAD notes, remove all of them.\n+         This is necessary because the reload_cse_regs() pass can\n+         have replaced some (MEM) with a register.  In that case,\n+         the REG_DEAD that could exist for that register may become\n+         wrong.  */\n+      for (insn = first; insn; insn = NEXT_INSN (insn))\n+        {\n+          if (INSN_P (insn))\n+            {\n+              rtx *pnote;\n+\n+              pnote = &REG_NOTES (insn);\n+              while (*pnote != 0)\n+                {\n+                  if (REG_NOTE_KIND (*pnote) == REG_DEAD)\n+                    *pnote = XEXP (*pnote, 1);\n+                  else\n+                    pnote = &XEXP (*pnote, 1);\n+                }\n+            }\n+        }\n+\n       find_basic_blocks (first, max_reg_num (), 0);\n       life_analysis (first, 0, PROP_REG_INFO | PROP_DEATH_NOTES);\n     }\n@@ -4651,8 +4776,6 @@ m68hc11_reorg (first)\n \n /* Cost functions.  */\n \n-#define COSTS_N_INSNS(N) ((N) * 4 - 2)\n-\n /* Cost of moving memory. */\n int\n m68hc11_memory_move_cost (mode, class, in)\n@@ -4783,103 +4906,142 @@ m68hc11_address_cost (addr)\n   return cost;\n }\n \n+static int\n+m68hc11_shift_cost (mode, x, shift)\n+     enum machine_mode mode;\n+     rtx x;\n+     int shift;\n+{\n+  int total;\n+\n+  total = rtx_cost (x, SET);\n+  if (mode == QImode)\n+    total += m68hc11_cost->shiftQI_const[shift % 8];\n+  else if (mode == HImode)\n+    total += m68hc11_cost->shiftHI_const[shift % 16];\n+  else if (shift == 8 || shift == 16 || shift == 32)\n+    total += m68hc11_cost->shiftHI_const[8];\n+  else if (shift != 0 && shift != 16 && shift != 32)\n+    {\n+      total += m68hc11_cost->shiftHI_const[1] * shift;\n+    }\n+\n+  /* For SI and others, the cost is higher.  */\n+  if (GET_MODE_SIZE (mode) > 2)\n+    total *= GET_MODE_SIZE (mode) / 2;\n+\n+  /* When optimizing for size, make shift more costly so that\n+     multiplications are prefered.  */\n+  if (optimize_size && (shift % 8) != 0)\n+    total *= 2;\n+  \n+  return total;\n+}\n+\n int\n m68hc11_rtx_costs (x, code, outer_code)\n      rtx x;\n-     enum rtx_code code, outer_code;\n+     enum rtx_code code;\n+     enum rtx_code outer_code ATTRIBUTE_UNUSED;\n {\n   enum machine_mode mode = GET_MODE (x);\n   int extra_cost = 0;\n   int total;\n \n   switch (code)\n     {\n-    case MEM:\n-      return m68hc11_address_cost (XEXP (x, 0)) + 4;\n-\n     case ROTATE:\n     case ROTATERT:\n     case ASHIFT:\n     case LSHIFTRT:\n     case ASHIFTRT:\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n-\t  int val = INTVAL (XEXP (x, 1));\n-\t  int cost;\n-\n-\t  /* 8 or 16 shift instructions are fast.\n-\t     Others are proportional to the shift counter.  */\n-\t  if (val == 8 || val == 16 || val == -8 || val == -16)\n-\t    {\n-\t      val = 0;\n-\t    }\n-\t  cost = COSTS_N_INSNS (val + 1);\n-\t  cost += rtx_cost (XEXP (x, 0), outer_code);\n-\t  if (GET_MODE_SIZE (mode) >= 4 && val)\n-\t    {\n-\t      cost *= 4;\n-\t    }\n-\t  return cost;\n-\t}\n-      total = rtx_cost (XEXP (x, 0), outer_code);\n-      if (GET_MODE_SIZE (mode) >= 4)\n-\t{\n-\t  total += COSTS_N_INSNS (16);\n-\t}\n-      else\n-\t{\n-\t  total += COSTS_N_INSNS (8);\n+          return m68hc11_shift_cost (mode, XEXP (x, 0), INTVAL (XEXP (x, 1)));\n \t}\n+\n+      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      total += m68hc11_cost->shift_var;\n       return total;\n \n-    case MINUS:\n-    case PLUS:\n     case AND:\n     case XOR:\n     case IOR:\n-      extra_cost = 0;\n+      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      total += m68hc11_cost->logical;\n \n-      total = rtx_cost (XEXP (x, 0), outer_code)\n-\t+ rtx_cost (XEXP (x, 1), outer_code);\n-      if (GET_MODE_SIZE (mode) <= 2)\n-\t{\n-\t  total += COSTS_N_INSNS (2);\n-\t}\n-      else\n+      /* Logical instructions are byte instructions only.  */\n+      total *= GET_MODE_SIZE (mode);\n+      return total;\n+\n+    case MINUS:\n+    case PLUS:\n+      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      total += m68hc11_cost->add;\n+      if (GET_MODE_SIZE (mode) > 2)\n \t{\n-\t  total += COSTS_N_INSNS (4);\n+\t  total *= GET_MODE_SIZE (mode) / 2;\n \t}\n       return total;\n \n+    case UDIV:\n     case DIV:\n     case MOD:\n-      if (mode == QImode || mode == HImode)\n-\t{\n-\t  return 30;\n-\t}\n-      else if (mode == SImode)\n-\t{\n-\t  return 100;\n-\t}\n-      else\n-\t{\n-\t  return 150;\n-\t}\n-\n+      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      switch (mode)\n+        {\n+        case QImode:\n+          total += m68hc11_cost->divQI;\n+          break;\n+\n+        case HImode:\n+          total += m68hc11_cost->divHI;\n+          break;\n+\n+        case SImode:\n+        default:\n+          total += m68hc11_cost->divSI;\n+          break;\n+        }\n+      return total;\n+      \n     case MULT:\n-      if (mode == QImode)\n-\t{\n-\t  return TARGET_OP_TIME ? 10 : 2;\n-\t}\n-      if (mode == HImode)\n-\t{\n-\t  return TARGET_OP_TIME ? 30 : 4;\n-\t}\n-      if (mode == SImode)\n-\t{\n-\t  return TARGET_OP_TIME ? 100 : 20;\n-\t}\n-      return 150;\n+      /* mul instruction produces 16-bit result.  */\n+      if (mode == HImode && GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n+          && GET_CODE (XEXP (x, 1)) == ZERO_EXTEND)\n+        return m68hc11_cost->multQI\n+          + rtx_cost (XEXP (XEXP (x, 0), 0), code)\n+          + rtx_cost (XEXP (XEXP (x, 1), 0), code);\n+\n+      /* emul instruction produces 32-bit result for 68HC12.  */\n+      if (TARGET_M6812 && mode == SImode\n+          && GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n+          && GET_CODE (XEXP (x, 1)) == ZERO_EXTEND)\n+        return m68hc11_cost->multHI\n+          + rtx_cost (XEXP (XEXP (x, 0), 0), code)\n+          + rtx_cost (XEXP (XEXP (x, 1), 0), code);\n+\n+      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      switch (mode)\n+        {\n+        case QImode:\n+          total += m68hc11_cost->multQI;\n+          break;\n+\n+        case HImode:\n+          total += m68hc11_cost->multHI;\n+          break;\n+\n+        case SImode:\n+          if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+              && INTVAL (XEXP (x, 1)) == 65536)\n+            break;\n+\n+        default:\n+          total += m68hc11_cost->multSI;\n+          break;\n+        }\n+      return total;\n \n     case NEG:\n     case SIGN_EXTEND:\n@@ -4890,20 +5052,20 @@ m68hc11_rtx_costs (x, code, outer_code)\n     case COMPARE:\n     case ABS:\n     case ZERO_EXTEND:\n-      total = rtx_cost (XEXP (x, 0), outer_code);\n+      total = extra_cost + rtx_cost (XEXP (x, 0), code);\n       if (mode == QImode)\n \t{\n-\t  return total + extra_cost + COSTS_N_INSNS (1);\n+\t  return total + COSTS_N_INSNS (1);\n \t}\n       if (mode == HImode)\n \t{\n-\t  return total + extra_cost + COSTS_N_INSNS (2);\n+\t  return total + COSTS_N_INSNS (2);\n \t}\n       if (mode == SImode)\n \t{\n-\t  return total + extra_cost + COSTS_N_INSNS (4);\n+\t  return total + COSTS_N_INSNS (4);\n \t}\n-      return total + extra_cost + COSTS_N_INSNS (8);\n+      return total + COSTS_N_INSNS (8);\n \n     case IF_THEN_ELSE:\n       if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)"}, {"sha": "475bf9ccd20530a6bd6eb1740bbb5ab32dc82e35", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "patch": "@@ -207,6 +207,25 @@ extern const char *m68hc11_soft_reg_count;\n    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n #define OVERRIDE_OPTIONS\tm68hc11_override_options ();\n+\n+\f\n+/* Define cost parameters for a given processor variant.  */\n+struct processor_costs {\n+  int add;\t\t/* cost of an add instruction */\n+  int logical;          /* cost of a logical instruction */\n+  int shift_var;\n+  int shiftQI_const[8];\n+  int shiftHI_const[16];\n+  int multQI;\n+  int multHI;\n+  int multSI;\n+  int divQI;\n+  int divHI;\n+  int divSI;\n+};\n+\n+/* Costs for the current processor.  */\n+extern struct processor_costs *m68hc11_cost;\n \f\n \n /* target machine storage layout */\n@@ -769,9 +788,6 @@ extern enum reg_class m68hc11_tmp_regs_class;\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\tpreferred_reload_class(X,CLASS)\n \n-\n-#define LIMIT_RELOAD_CLASS(MODE, CLASS) limit_reload_class(MODE,CLASS)\n-\n #define SMALL_REGISTER_CLASSES 1\n \n /* A C expression whose value is nonzero if pseudos that have been\n@@ -1456,22 +1472,52 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n \n /* Compute the cost of computing a constant rtl expression RTX whose rtx-code\n    is CODE.  The body of this macro is a portion of a switch statement.  If\n-   the code is computed here, return it with a return statement. Otherwise,\n-   break from the switch.  */\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n- case CONST_INT:\t\t\t \\\n-    if (RTX == const0_rtx) return 0;\t \\\n- case CONST:\t\t\t\t \\\n-    return 0;                            \\\n- case LABEL_REF:\t\t\t \\\n- case SYMBOL_REF:\t\t\t \\\n-   return 1;\t\t\t\t \\\n- case CONST_DOUBLE:\t\t\t \\\n+   the code is computed here, return it with a return statement.  Otherwise,\n+   break from the switch.\n+\n+   Constants are cheap.  Moving them in registers must be avoided\n+   because most instructions do not handle two register operands.  */\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\\\n+ case CONST_INT:\t\t\t\t\t\t\\\n+     /* Logical and arithmetic operations with a constant  */\t\\\n+     /* operand are better because they are not supported  */\t\\\n+     /* with two registers.  */\t\t\t\t\t\\\n+     /* 'clr' is slow */\t\t\t\t\t\\\n+   if ((OUTER_CODE) == SET && (RTX) == const0_rtx)\t\t\\\n+     return 1;\t\t\t\t\t\t\t\\\n+   else\t\t\t\t\t\t\t\t\\\n+     return 0;\t\t\t\t\t\t\t\\\n+ case CONST:\t\t\t\t\t\t\t\\\n+ case LABEL_REF:\t\t\t\t\t\t\\\n+ case SYMBOL_REF:\t\t\t\t\t\t\\\n+   if ((OUTER_CODE) == SET)\t\t\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\\\n+   return 0;\t\t\t\t\t\t\t\\\n+ case CONST_DOUBLE:\t\t\t\t\t\t\\\n    return 0;\n \n-#define DEFAULT_RTX_COSTS(X,CODE,OUTER_CODE)\t\t\\\n-    return m68hc11_rtx_costs (X, CODE, OUTER_CODE);\n-\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\\\n+ case ROTATE:\t\t\t\t\t\t\t\\\n+ case ROTATERT:\t\t\t\t\t\t\t\\\n+ case ASHIFT:\t\t\t\t\t\t\t\\\n+ case LSHIFTRT:\t\t\t\t\t\t\t\\\n+ case ASHIFTRT:\t\t\t\t\t\t\t\\\n+ case MINUS:\t\t\t\t\t\t\t\\\n+ case PLUS:\t\t\t\t\t\t\t\\\n+ case AND:\t\t\t\t\t\t\t\\\n+ case XOR:\t\t\t\t\t\t\t\\\n+ case IOR:\t\t\t\t\t\t\t\\\n+ case UDIV:\t\t\t\t\t\t\t\\\n+ case DIV:\t\t\t\t\t\t\t\\\n+ case MOD:\t\t\t\t\t\t\t\\\n+ case MULT:\t\t\t\t\t\t\t\\\n+ case NEG:\t\t\t\t\t\t\t\\\n+ case SIGN_EXTEND:\t\t\t\t\t\t\\\n+ case NOT:\t\t\t\t\t\t\t\\\n+ case COMPARE:\t\t\t\t\t\t\t\\\n+ case ZERO_EXTEND:\t\t\t\t\t\t\\\n+ case IF_THEN_ELSE:\t\t\t\t\t\t\\\n+   return m68hc11_rtx_costs (X, CODE, OUTER_CODE);\n \n /* An expression giving the cost of an addressing mode that contains\n    ADDRESS.  If not defined, the cost is computed from the ADDRESS"}, {"sha": "ec6956eafb505e3958f0c51c3b8a3322ea56a837", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 233, "deletions": 199, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01beec65d8b06f9361e70442f14bcf2d99d4b4aa/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=01beec65d8b06f9361e70442f14bcf2d99d4b4aa", "patch": "@@ -115,6 +115,24 @@\n ;;   Such split pattern must also be valid when z_replacement_completed == 2\n ;;   because flow/cse is not aware that D is composed of {a, b}.\n ;;\n+;; o Split patterns that generate a (mem:QI (symbol_reg _.dx)) to access\n+;;   the high part of a soft register must be expanded after z_replacement\n+;;   pass.\n+;;\n+;;---------------------------------------------------------------------------\n+;; Constants\n+\n+(define_constants [\n+   ;; Register numbers\n+   (X_REGNUM\t    0)\t\t; Index X register\n+   (D_REGNUM\t    1)\t\t; Data register\n+   (Y_REGNUM        2)\t\t; Index Y register\n+   (SP_REGNUM       3)          ; Stack pointer\n+   (PC_REGNUM\t    4)\t\t; Program counter\n+   (A_REGNUM        5)\t\t; A (high part of D)\n+   (B_REGNUM        6)\t\t; B (low part of D)\n+   (CC_REGNUM       7)\t\t; Condition code register\n+])\n \n ;;--------------------------------------------------------------------\n ;;-  Test\n@@ -156,7 +174,7 @@\n   \"\"\n   \"*\n {\n-   if (D_REG_P (operands[0]))\n+   if (D_REG_P (operands[0]) && !TARGET_M6812)\n      return \\\"std\\\\t%t0\\\";\n    else\n      return \\\"cp%0\\\\t#0\\\";\n@@ -222,10 +240,10 @@\n    (use (match_operand:HI 1 \"hard_reg_operand\" \"dxy\"))\n    (use (reg:HI 11))]\n   \"z_replacement_completed == 2\"\n-  [(set (mem:HI (pre_dec:HI (reg:HI 3))) (match_dup 1))\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 1))\n    (set (match_dup 1) (match_dup 2))\n    (set (cc0) (match_dup 0))\n-   (set (match_dup 1) (mem:HI (post_inc:HI (reg:HI 3))))]\n+   (set (match_dup 1) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n   \"operands[2] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n \n \n@@ -313,10 +331,10 @@\n    (use (match_operand:HI 2 \"hard_reg_operand\" \"dxy\"))\n    (use (reg:HI 11))]\n   \"z_replacement_completed == 2\"\n-  [(set (mem:HI (pre_dec:HI (reg:HI 3))) (match_dup 2))\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))\n    (set (match_dup 2) (match_dup 3))\n    (set (cc0) (compare (match_dup 0) (match_dup 1)))\n-   (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI 3))))]\n+   (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n   \"operands[3] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n \n ;;\n@@ -330,12 +348,12 @@\n \t(compare (match_operand:QI 0 \"hard_addr_reg_operand\" \"xy\")\n \t\t (match_operand:QI 1 \"cmp_operand\" \"uimA\")))]\n   \"z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode\"\n-  [(parallel [(set (reg:HI 1) (match_dup 3))\n-              (set (match_dup 3) (reg:HI 1))])\n+  [(parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n+              (set (match_dup 3) (reg:HI D_REGNUM))])\n    (set (cc0)\n-        (compare (reg:QI 1) (match_dup 1)))\n-   (parallel [(set (reg:HI 1) (match_dup 3))\n-              (set (match_dup 3) (reg:HI 1))])]\n+        (compare (reg:QI D_REGNUM) (match_dup 1)))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n+              (set (match_dup 3) (reg:HI D_REGNUM))])]\n   \"operands[3] = gen_rtx (REG, HImode, REGNO (operands[0]));\")\n \n (define_split\n@@ -392,10 +410,10 @@\n    (use (match_operand:HI 2 \"hard_reg_operand\" \"dxy\"))\n    (use (reg:HI 11))]\n   \"z_replacement_completed == 2\"\n-  [(set (mem:HI (pre_dec:HI (reg:HI 3))) (match_dup 2))\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))\n    (set (match_dup 2) (match_dup 3))\n    (set (cc0) (compare (match_dup 0) (match_dup 1)))\n-   (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI 3))))]\n+   (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n   \"operands[3] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n \n (define_expand \"cmpdf\"\n@@ -703,11 +721,11 @@\n   \"z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode\n    && !reg_mentioned_p (operands[0], operands[1])\n    && !D_REG_P (operands[1])\"\n-  [(parallel [(set (reg:HI 1) (match_dup 2))\n-              (set (match_dup 2) (reg:HI 1))])\n-   (set (reg:QI 1) (match_dup 1))\n-   (parallel [(set (reg:HI 1) (match_dup 2))\n-              (set (match_dup 2) (reg:HI 1))])]\n+  [(parallel [(set (reg:HI D_REGNUM) (match_dup 2))\n+              (set (match_dup 2) (reg:HI D_REGNUM))])\n+   (set (reg:QI D_REGNUM) (match_dup 1))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 2))\n+              (set (match_dup 2) (reg:HI D_REGNUM))])]\n   \"operands[2] = gen_rtx (REG, HImode, REGNO (operands[0]));\")\n \n ;;\n@@ -719,11 +737,11 @@\n   \"z_replacement_completed == 2 && GET_MODE (operands[1]) == QImode\n    && !reg_mentioned_p (operands[1], operands[0])\n    && !D_REG_P (operands[0])\"\n-  [(parallel [(set (reg:HI 1) (match_dup 2))\n-              (set (match_dup 2) (reg:HI 1))])\n-   (set (match_dup 0) (reg:QI 1))\n-   (parallel [(set (reg:HI 1) (match_dup 2))\n-              (set (match_dup 2) (reg:HI 1))])]\n+  [(parallel [(set (reg:HI D_REGNUM) (match_dup 2))\n+              (set (match_dup 2) (reg:HI D_REGNUM))])\n+   (set (match_dup 0) (reg:QI D_REGNUM))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 2))\n+              (set (match_dup 2) (reg:HI D_REGNUM))])]\n   \"operands[2] = gen_rtx (REG, HImode, REGNO (operands[1]));\")\n \n (define_insn \"*movqi2_push\"\n@@ -1048,15 +1066,11 @@\n   [(set (match_operand:SI 0 \"non_push_operand\" \"=mu\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"dxy\")))]\n   \"reload_completed && !X_REG_P (operands[0])\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (const_int 0))\n-   (set (match_dup 5) (const_int 0))]\n+  [(set (match_dup 2) (zero_extend:HI (match_dup 1)))\n+   (set (match_dup 3) (const_int 0))]\n   \"\n    operands[2] = m68hc11_gen_lowpart (HImode, operands[0]);\n-   operands[3] = gen_rtx (REG, HImode, REGNO (operands[1]));\n-   operands[4] = m68hc11_gen_lowpart (HImode, operands[0]);\n-   operands[4] = m68hc11_gen_highpart (QImode, operands[4]);\n-   operands[5] = m68hc11_gen_highpart (HImode, operands[0]);\")\n+   operands[3] = m68hc11_gen_highpart (HImode, operands[0]);\")\n \n (define_split \n   [(set (match_operand:SI 0 \"hard_reg_operand\" \"=D\")\n@@ -1320,8 +1334,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n \t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"A\")))]\n   \"reload_completed && (Y_REG_P (operands[1]) || Z_REG_P (operands[1]))\"\n-  [(set (reg:HI 1) (match_dup 1))\n-   (set (match_dup 0) (sign_extend:SI (reg:HI 1)))]\n+  [(set (reg:HI D_REGNUM) (match_dup 1))\n+   (set (match_dup 0) (sign_extend:SI (reg:HI D_REGNUM)))]\n   \"\")\n \n (define_insn \"extendhisi2\"\n@@ -1409,13 +1423,13 @@\n \t\t (match_dup 0)))\n    (clobber (match_scratch:HI 1 \"=X\"))]\n   \"reload_completed && z_replacement_completed == 2\"\n-  [(set (reg:HI 1) (ashift:HI (reg:HI 1) (const_int 1)))\n-   (parallel [(set (reg:HI 1) (reg:HI 0))\n-              (set (reg:HI 0) (reg:HI 1))])\n-   (set (reg:QI 6) (rotate:QI (reg:QI 6) (reg:QI 7)))\n-   (set (reg:QI 5) (rotate:QI (reg:QI 5) (reg:QI 7)))\n-   (parallel [(set (reg:HI 1) (reg:HI 0))\n-              (set (reg:HI 0) (reg:HI 1))])]\n+  [(set (reg:HI D_REGNUM) (ashift:HI (reg:HI D_REGNUM) (const_int 1)))\n+   (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n+              (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])\n+   (set (reg:QI B_REGNUM) (rotate:QI (reg:QI B_REGNUM) (reg:QI CC_REGNUM)))\n+   (set (reg:QI A_REGNUM) (rotate:QI (reg:QI A_REGNUM) (reg:QI CC_REGNUM)))\n+   (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n+              (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])]\n   \"\")\n \n \n@@ -1472,9 +1486,9 @@\n \t\t (match_operand:SI 2 \"memory_operand\" \"m,m\")))\n    (clobber (match_scratch:HI 3 \"=X,X\"))]\n   \"reload_completed\"\n-  [(set (reg:HI 1) (zero_extend:HI (match_dup 1)))\n+  [(set (reg:HI D_REGNUM) (zero_extend:HI (match_dup 1)))\n    (parallel [(set (match_dup 0) \n-\t\t   (plus:SI (zero_extend:SI (reg:HI 1)) (match_dup 2)))\n+\t\t   (plus:SI (zero_extend:SI (reg:HI D_REGNUM)) (match_dup 2)))\n \t      (clobber (match_dup 3))])]\n   \"\")\n \n@@ -1658,7 +1672,7 @@\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && ((INTVAL (operands[2]) & 0x0FFFF) == 0)\"\n-  [(set (reg:HI 0) (plus:HI (reg:HI 0) (match_dup 3)))]\n+  [(set (reg:HI X_REGNUM) (plus:HI (reg:HI X_REGNUM) (match_dup 3)))]\n   \"operands[3] = m68hc11_gen_highpart (HImode, operands[2]);\")\n \n (define_split\n@@ -1669,13 +1683,13 @@\n   \"reload_completed && z_replacement_completed == 2\n    && (GET_CODE (operands[2]) != CONST_INT || \n         (!(INTVAL (operands[2]) >= -65536 && INTVAL (operands[2]) <= 65535)))\"\n-  [(set (reg:HI 1) (plus:HI (reg:HI 1) (match_dup 3)))\n-   (parallel [(set (reg:HI 1) (reg:HI 0))\n-              (set (reg:HI 0) (reg:HI 1))])\n-   (set (reg:QI 6) (plus:QI (plus:QI (reg:QI 7) (reg:QI 6)) (match_dup 4)))\n-   (set (reg:QI 5) (plus:QI (plus:QI (reg:QI 7) (reg:QI 5)) (match_dup 5)))\n-   (parallel [(set (reg:HI 1) (reg:HI 0))\n-              (set (reg:HI 0) (reg:HI 1))])]\n+  [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))\n+   (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n+              (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])\n+   (set (reg:QI B_REGNUM) (plus:QI (plus:QI (reg:QI CC_REGNUM) (reg:QI B_REGNUM)) (match_dup 4)))\n+   (set (reg:QI A_REGNUM) (plus:QI (plus:QI (reg:QI CC_REGNUM) (reg:QI A_REGNUM)) (match_dup 5)))\n+   (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n+              (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])]\n   \"operands[3] = m68hc11_gen_lowpart (HImode, operands[2]);\n    operands[4] = m68hc11_gen_highpart (HImode, operands[2]);\n    operands[5] = m68hc11_gen_highpart (QImode, operands[4]);\n@@ -1689,7 +1703,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=x\")\n            (plus:HI (plus:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t             (const_int 0)) \n-\t\t    (reg:HI 7)))]\n+\t\t    (reg:HI CC_REGNUM)))]\n   \"\"\n   \"*\n {\n@@ -1746,25 +1760,39 @@\n   \"\")\n \n (define_insn \"*addhi3_68hc12\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,A*w,A*w\")\n-        (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,Aw\")\n-                 (match_operand:HI 2 \"general_operand\" \"imA*wu,id,id\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=*d,A*w,A*w,A\")\n+        (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,Aw,0\")\n+                 (match_operand:HI 2 \"general_operand\" \"imA*wu,id,id,!muA\")))]\n   \"TARGET_M6812\"\n   \"*\n {\n   int val;\n   const char* insn_code;\n \n+  if (which_alternative >= 3)\n+    {\n+      if (A_REG_P (operands[2]))\n+        {\n+\t  CC_STATUS_INIT;\n+\t  output_asm_insn (\\\"xgd%2\\\", operands);\n+\t  output_asm_insn (\\\"lea%0 d,%0\\\", operands);\n+\t  return \\\"xgd%2\\\";\n+\t}\n+      return \\\"#\\\";\n+    }\n+\n   if (D_REG_P (operands[0]))\n     {\n       if (X_REG_P (operands[2]))\n \t{\n+\t  m68hc11_notice_keep_cc (operands[0]);\n \t  output_asm_insn (\\\"xgdx\\\", operands);\n \t  output_asm_insn (\\\"leax\\\\td,%2\\\", operands);\n \t  return \\\"xgdx\\\";\n \t}\n       else if (Y_REG_P (operands[2]))\n \t{\n+\t  m68hc11_notice_keep_cc (operands[0]);\n \t  output_asm_insn (\\\"xgdy\\\", operands);\n \t  output_asm_insn (\\\"leay\\\\td,%2\\\", operands);\n \t  return \\\"xgdy\\\";\n@@ -1784,7 +1812,7 @@\n \n   if (val != -1 || val != 1 || !rtx_equal_p (operands[0], operands[1]))\n     {\n-      cc_status = cc_prev_status;\n+      m68hc11_notice_keep_cc (operands[0]);\n       switch (REGNO (operands[0]))\n \t{\n \tcase HARD_X_REGNUM:\n@@ -1922,9 +1950,9 @@\n   \"\")\n \n (define_insn \"*addhi3\"\n-  [(set (match_operand:HI 0 \"hard_reg_operand\" \"=A,d,!A,d*A,!d,!w\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0,0,0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"N,i,I,umi*A*d,!*d*w,i\")))]\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"=A,d,!A,d*A,!d\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"N,i,I,umi*A*d,!*d*w\")))]\n   \"TARGET_M6811\"\n   \"*\n {\n@@ -2110,7 +2138,7 @@\n ;;\n (define_insn \"*adcq\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-        (plus:QI (plus:QI (reg:QI 7)\n+        (plus:QI (plus:QI (reg:QI CC_REGNUM)\n                           (match_operand:QI 1 \"register_operand\" \"%0\"))\n                  (match_operand:QI 2 \"general_operand\" \"ium\")))]\n   \"\"\n@@ -2201,13 +2229,13 @@\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && X_REG_P (operands[1])\"\n-  [(set (reg:HI 1) (minus:HI (reg:HI 1) (match_dup 3)))\n-   (parallel [(set (reg:HI 0) (reg:HI 1))\n-              (set (reg:HI 1) (reg:HI 0))])\n-   (set (reg:QI 6) (minus:QI (minus:QI (reg:QI 7) (reg:QI 6)) (match_dup 4)))\n-   (set (reg:QI 5) (minus:QI (minus:QI (reg:QI 7) (reg:QI 5)) (match_dup 5)))\n-   (parallel [(set (reg:HI 0) (reg:HI 1))\n-              (set (reg:HI 1) (reg:HI 0))])]\n+  [(set (reg:HI D_REGNUM) (minus:HI (reg:HI D_REGNUM) (match_dup 3)))\n+   (parallel [(set (reg:HI X_REGNUM) (reg:HI D_REGNUM))\n+              (set (reg:HI D_REGNUM) (reg:HI X_REGNUM))])\n+   (set (reg:QI B_REGNUM) (minus:QI (minus:QI (reg:QI CC_REGNUM) (reg:QI B_REGNUM)) (match_dup 4)))\n+   (set (reg:QI A_REGNUM) (minus:QI (minus:QI (reg:QI CC_REGNUM) (reg:QI A_REGNUM)) (match_dup 5)))\n+   (parallel [(set (reg:HI X_REGNUM) (reg:HI D_REGNUM))\n+              (set (reg:HI D_REGNUM) (reg:HI X_REGNUM))])]\n   \"operands[3] = m68hc11_gen_lowpart (HImode, operands[2]);\n    operands[4] = m68hc11_gen_highpart (HImode, operands[2]);\n    operands[5] = m68hc11_gen_highpart (QImode, operands[4]);\n@@ -2220,13 +2248,13 @@\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"reload_completed && z_replacement_completed == 2\n    && X_REG_P (operands[2])\"\n-  [(set (reg:HI 1) (minus:HI (reg:HI 1) (match_dup 3)))\n-   (parallel [(set (reg:HI 0) (reg:HI 1))\n-              (set (reg:HI 1) (reg:HI 0))])\n-   (set (reg:QI 6) (minus:QI (minus:QI (reg:QI 7) (reg:QI 6)) (match_dup 4)))\n-   (set (reg:QI 5) (minus:QI (minus:QI (reg:QI 7) (reg:QI 5)) (match_dup 5)))\n-   (parallel [(set (reg:HI 0) (reg:HI 1))\n-              (set (reg:HI 1) (reg:HI 0))])\n+  [(set (reg:HI D_REGNUM) (minus:HI (reg:HI D_REGNUM) (match_dup 3)))\n+   (parallel [(set (reg:HI X_REGNUM) (reg:HI D_REGNUM))\n+              (set (reg:HI D_REGNUM) (reg:HI X_REGNUM))])\n+   (set (reg:QI B_REGNUM) (minus:QI (minus:QI (reg:QI CC_REGNUM) (reg:QI B_REGNUM)) (match_dup 4)))\n+   (set (reg:QI A_REGNUM) (minus:QI (minus:QI (reg:QI CC_REGNUM) (reg:QI A_REGNUM)) (match_dup 5)))\n+   (parallel [(set (reg:HI X_REGNUM) (reg:HI D_REGNUM))\n+              (set (reg:HI D_REGNUM) (reg:HI X_REGNUM))])\n    (set (reg:SI 0) (neg:SI (reg:SI 0)))]\n   \"operands[3] = m68hc11_gen_lowpart (HImode, operands[1]);\n    operands[4] = m68hc11_gen_highpart (HImode, operands[1]);\n@@ -2365,7 +2393,7 @@\n ;;\n (define_insn \"*subcq\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-        (minus:QI (minus:QI (reg:QI 7)\n+        (minus:QI (minus:QI (reg:QI CC_REGNUM)\n                             (match_operand:QI 1 \"register_operand\" \"0\"))\n                   (match_operand:QI 2 \"general_operand\" \"ium\")))]\n   \"\"\n@@ -2927,10 +2955,10 @@\n \t\t     (match_operand:QI 1 \"general_operand\" \"dxy,imu\"))\n \t\t  (match_operand:SI 2 \"general_operand\" \"imuD,imuD\")]))]\n   \"z_replacement_completed == 2\"\n-  [(set (reg:QI 5) (match_dup 4))\n-   (set (reg:QI 1) (match_dup 7))\n-   (set (reg:QI 6) (match_op_dup 3 [(reg:QI 6) (match_dup 5)]))\n-   (set (reg:HI 0) (match_dup 6))]\n+  [(set (reg:QI A_REGNUM) (match_dup 4))\n+   (set (reg:QI D_REGNUM) (match_dup 7))\n+   (set (reg:QI B_REGNUM) (match_op_dup 3 [(reg:QI B_REGNUM) (match_dup 5)]))\n+   (set (reg:HI X_REGNUM) (match_dup 6))]\n   \"PUT_MODE (operands[3], QImode);\n    if (X_REG_P (operands[2]))\n      {\n@@ -2957,9 +2985,9 @@\n \t\t     (match_operand:HI 1 \"general_operand\" \"dA,imu\"))\n \t\t  (match_operand:SI 2 \"general_operand\" \"imuD,imuD\")]))]\n   \"reload_completed\"\n-  [(set (reg:HI 1) (match_dup 4))\n-   (set (reg:HI 1) (match_op_dup 3 [(reg:HI 1) (match_dup 5)]))\n-   (set (reg:HI 0) (match_dup 6))]\n+  [(set (reg:HI D_REGNUM) (match_dup 4))\n+   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))\n+   (set (reg:HI X_REGNUM) (match_dup 6))]\n   \"PUT_MODE (operands[3], HImode);\n    if (X_REG_P (operands[2]))\n      {\n@@ -3003,9 +3031,9 @@\n \t\t     (match_operand:QI 1 \"general_operand\" \"imud\"))\n \t\t (match_operand:HI 2 \"general_operand\" \"dimu\")]))]\n   \"z_replacement_completed == 2\"\n-  [(set (reg:QI 6) (match_dup 6))\n-   (set (reg:QI 5) (match_dup 4))\n-   (set (reg:QI 6) (match_op_dup 3 [(reg:QI 6) (match_dup 5)]))]\n+  [(set (reg:QI B_REGNUM) (match_dup 6))\n+   (set (reg:QI A_REGNUM) (match_dup 4))\n+   (set (reg:QI B_REGNUM) (match_op_dup 3 [(reg:QI B_REGNUM) (match_dup 5)]))]\n   \"\n    PUT_MODE (operands[3], QImode);\n    if (D_REG_P (operands[2]))\n@@ -3034,8 +3062,8 @@\n \t\t     (match_operand:HI 2 \"general_operand\" \"dimu\")\n \t\t     (const_int 8))]))]\n   \"z_replacement_completed == 2\"\n-  [(set (reg:QI 6) (match_dup 5))\n-   (set (reg:QI 5) (match_dup 4))]\n+  [(set (reg:QI A_REGNUM) (match_dup 4))\n+   (set (reg:QI B_REGNUM) (match_dup 5))]\n   \"\n    if (GET_CODE (operands[3]) == AND)\n      {\n@@ -3074,9 +3102,9 @@\n \t\t\t(const_int 16))\n \t\t (match_operand:SI 2 \"general_operand\" \"uim,0\")]))]\n   \"reload_completed\"\n-  [(set (reg:HI 1) (match_dup 4))\n-   (set (reg:HI 1) (match_op_dup 3 [(reg:HI 1) (match_dup 5)]))\n-   (set (reg:HI 0) (match_dup 6))]\n+  [(set (reg:HI D_REGNUM) (match_dup 4))\n+   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))\n+   (set (reg:HI X_REGNUM) (match_dup 6))]\n   \"operands[5] = m68hc11_gen_highpart (HImode, operands[1]);\n    if (X_REG_P (operands[2]))\n      {\n@@ -3110,11 +3138,11 @@\n \t\t\t(const_int 16))\n \t\t (match_operand:SI 2 \"general_operand\" \"0,0\")]))]\n   \"z_replacement_completed == 2\"\n-  [(parallel [(set (reg:HI 1) (reg:HI 0))\n-              (set (reg:HI 0) (reg:HI 1))])\n-  (set (reg:HI 1) (match_op_dup 3 [(reg:HI 1) (match_dup 4)]))\n-  (parallel [(set (reg:HI 1) (reg:HI 0))\n-             (set (reg:HI 0) (reg:HI 1))])]\n+  [(parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n+              (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])\n+  (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 4)]))\n+  (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n+             (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])]\n   \"operands[4] = m68hc11_gen_lowpart (HImode, operands[1]);\n    PUT_MODE (operands[3], HImode);\")\n \n@@ -3177,17 +3205,19 @@\n    /* If we are adding a small constant to X or Y, it's\n      better to use one or several inx/iny instructions. */\n    && !(GET_CODE (operands[3]) == PLUS \n-        && (TARGET_M6812\n+        && ((TARGET_M6812 \n+\t     && (immediate_operand (operands[2], HImode)\n+\t\t || hard_reg_operand (operands[2], HImode)))\n             || (GET_CODE (operands[2]) == CONST_INT\n \t        && INTVAL (operands[2]) >= -4\n \t        && INTVAL (operands[2]) <= 4)))\"\n   [(set (match_dup 4) (match_dup 5))\n    (set (match_dup 8) (match_dup 7))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:HI 1) (match_op_dup 3 [(reg:HI 1) (match_dup 6)]))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])]\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 6)]))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"\n    /* Save the operand2 in a temporary location and use it. */\n    if (H_REG_P (operands[2])\n@@ -3224,16 +3254,18 @@\n    /* If we are adding a small constant to X or Y, it's\n      better to use one or several inx/iny instructions. */\n    && !(GET_CODE (operands[3]) == PLUS \n-        && (TARGET_M6812\n+        && ((TARGET_M6812 \n+\t    && (immediate_operand (operands[2], HImode)\n+\t\t|| hard_reg_operand (operands[2], HImode)))\n             || (GET_CODE (operands[2]) == CONST_INT\n \t        && INTVAL (operands[2]) >= -4\n \t        && INTVAL (operands[2]) <= 4)))\"\n   [(set (match_dup 0) (match_dup 1))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:HI 1) (match_op_dup 3 [(reg:HI 1) (match_dup 2)]))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])]\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 2)]))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"\n    \")\n \n@@ -3283,11 +3315,11 @@\n             [(match_operand 1 \"general_operand\" \"uim*d*A\")]))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 4) (match_dup 5))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:HI 1) (match_op_dup 2 [(match_dup 3)]))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])]\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:HI D_REGNUM) (match_op_dup 2 [(match_dup 3)]))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"\n {\n   if ((H_REG_P (operands[1])\n@@ -3331,11 +3363,11 @@\n         && GET_CODE (operands[2]) == CONST_INT\n         && (INTVAL (operands[2]) == 1 || INTVAL (operands[2]) == -1))\"\n   [(set (match_dup 5) (match_dup 6))\n-   (parallel [(set (reg:HI 1) (match_dup 4))\n-              (set (match_dup 4) (reg:HI 1))])\n-   (set (reg:QI 1) (match_op_dup 3 [(reg:QI 1) (match_dup 7)]))\n-   (parallel [(set (reg:HI 1) (match_dup 4))\n-              (set (match_dup 4) (reg:HI 1))])]\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 4))\n+              (set (match_dup 4) (reg:HI D_REGNUM))])\n+   (set (reg:QI D_REGNUM) (match_op_dup 3 [(reg:QI D_REGNUM) (match_dup 7)]))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 4))\n+              (set (match_dup 4) (reg:HI D_REGNUM))])]\n   \"operands[4] = gen_rtx (REG, HImode, REGNO (operands[0]));\n \n    /* For the second operand is a hard register or if the address\n@@ -3410,11 +3442,11 @@\n             [(match_operand:QI 1 \"general_operand\" \"uim*d*x*y\")]))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 4) (match_dup 5))\n-   (parallel [(set (reg:HI 1) (match_dup 3))\n-              (set (match_dup 3) (reg:HI 1))])\n-   (set (reg:QI 1) (match_op_dup 2 [(match_dup 6)]))\n-   (parallel [(set (reg:HI 1) (match_dup 3))\n-              (set (match_dup 3) (reg:HI 1))])]\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n+              (set (match_dup 3) (reg:HI D_REGNUM))])\n+   (set (reg:QI D_REGNUM) (match_op_dup 2 [(match_dup 6)]))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n+              (set (match_dup 3) (reg:HI D_REGNUM))])]\n   \"\n {\n   operands[3] = gen_rtx (REG, HImode, REGNO (operands[0]));\n@@ -3530,12 +3562,12 @@\n \t(not:SI (match_operand:SI 1 \"non_push_operand\" \"0\")))]\n   \"z_replacement_completed == 2\n    && (!D_REG_P (operands[0]) || (optimize && optimize_size == 0))\"\n-  [(set (reg:HI 1) (not:HI (reg:HI 1)))\n-   (parallel [(set (reg:HI 0) (reg:HI 1))\n-              (set (reg:HI 1) (reg:HI 0))])\n-   (set (reg:HI 1) (not:HI (reg:HI 1)))\n-   (parallel [(set (reg:HI 0) (reg:HI 1))\n-              (set (reg:HI 1) (reg:HI 0))])]\n+  [(set (reg:HI D_REGNUM) (not:HI (reg:HI D_REGNUM)))\n+   (parallel [(set (reg:HI X_REGNUM) (reg:HI D_REGNUM))\n+              (set (reg:HI D_REGNUM) (reg:HI X_REGNUM))])\n+   (set (reg:HI D_REGNUM) (not:HI (reg:HI D_REGNUM)))\n+   (parallel [(set (reg:HI X_REGNUM) (reg:HI D_REGNUM))\n+              (set (reg:HI D_REGNUM) (reg:HI X_REGNUM))])]\n   \"\n {\n   /* The result pattern only works for D register.\n@@ -3623,15 +3655,15 @@\n     (set (match_dup 4) (match_dup 2))\n \n     (set (match_dup 2) (match_dup 5))\n-    (set (match_dup 2) (rotate:HI (match_dup 2) (reg:HI 7)))\n+    (set (match_dup 2) (rotate:HI (match_dup 2) (reg:HI CC_REGNUM)))\n     (set (match_dup 6) (match_dup 2))\n \n     (set (match_dup 2) (match_dup 7))\n-    (set (match_dup 2) (rotate:HI (match_dup 2) (reg:HI 7)))\n+    (set (match_dup 2) (rotate:HI (match_dup 2) (reg:HI CC_REGNUM)))\n     (set (match_dup 8) (match_dup 2))\n \n     (set (match_dup 2) (match_dup 9))\n-    (set (match_dup 2) (rotate:HI (match_dup 2) (reg:HI 7)))\n+    (set (match_dup 2) (rotate:HI (match_dup 2) (reg:HI CC_REGNUM)))\n     (set (match_dup 10) (match_dup 2))]\n    \"operands[3] = m68hc11_gen_lowpart (SImode, operands[1]);\n     operands[5] = m68hc11_gen_highpart (HImode, operands[3]);\n@@ -3663,8 +3695,8 @@\n \t\t\t\t(const_int 16))\n \t\t   (match_operand:SI 2 \"general_operand\" \"0\")))]\n   \"z_replacement_completed == 2\"\n-  [(set (reg:HI 1) (plus:HI (reg:HI 1) (match_dup 3)))\n-   (set (reg:HI 0) (plus:HI (plus:HI (reg:HI 0) (const_int 0)) (reg:HI 7)))]\n+  [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))\n+   (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM) (const_int 0)) (reg:HI CC_REGNUM)))]\n   \"operands[3] = m68hc11_gen_highpart (HImode, operands[1]);\")\n \n (define_insn \"addsi_ashift16\"\n@@ -3685,7 +3717,7 @@\n \t\t   (match_operand:SI 1 \"general_operand\" \"0\")))\n    (clobber (match_scratch:HI 3 \"=X\"))]\n   \"0 && reload_completed && z_replacement_completed == 2\"\n-  [(set (reg:HI 0) (plus:HI (reg:HI 0) (match_dup 4)))]\n+  [(set (reg:HI X_REGNUM) (plus:HI (reg:HI X_REGNUM) (match_dup 4)))]\n   \"\n {\n   operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);\n@@ -3705,8 +3737,8 @@\n \t\t\t   (const_int 65535))\n \t\t   (match_operand:SI 2 \"general_operand\" \"0\")))]\n   \"z_replacement_completed == 2\"\n-  [(set (reg:HI 1) (plus:HI (reg:HI 1) (match_dup 3)))\n-   (set (reg:HI 0) (plus:HI (plus:HI (reg:HI 0) (const_int 0)) (reg:HI 7)))]\n+  [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))\n+   (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM) (const_int 0)) (reg:HI CC_REGNUM)))]\n   \"operands[3] = m68hc11_gen_lowpart (HImode, operands[1]);\")\n \n ;;\n@@ -3766,8 +3798,8 @@\n \t           (const_int 16)))\n    (clobber (match_scratch:HI 2 \"=X\"))]\n    \"reload_completed\"\n-   [(set (reg:HI 0) (match_dup 1))\n-    (set (reg:HI 1) (const_int 0))]\n+   [(set (reg:HI X_REGNUM) (match_dup 1))\n+    (set (reg:HI D_REGNUM) (const_int 0))]\n    \"\")\n \n (define_insn \"*ashlsi3_const1\"\n@@ -3910,7 +3942,7 @@\n (define_insn \"*ashlhi3_2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-                   (match_operand:HI 2 \"register_operand\" \"x\")))\n+                   (match_operand:HI 2 \"register_operand\" \"+x\")))\n    (clobber (match_dup 2))]\n   \"\"\n   \"*\n@@ -3919,10 +3951,10 @@\n   return \\\"bsr\\\\t___lshlhi3\\\";\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ashlhi3\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n \t(ashift:HI (match_dup 0)\n-\t\t   (match_operand:HI 1 \"register_operand\" \"x\")))\n+\t\t   (match_operand:HI 1 \"register_operand\" \"+x\")))\n    (clobber (match_dup 1))]\n   \"\"\n   \"*\n@@ -4177,9 +4209,9 @@\n       output_asm_insn (\\\"rolb\\\", operands);\n       output_asm_insn (\\\"rola\\\", operands);\n       output_asm_insn (\\\"tab\\\", operands);\n-      output_asm_insn (\\\"anda\\\\t#1\\\", operands);\n+      output_asm_insn (\\\"anda\\\\t#0\\\", operands);\n       output_asm_insn (\\\"bcc\\\\t%l0\\\", ops);\n-      output_asm_insn (\\\"oraa\\\\t#0xFE\\\", ops);\n+      output_asm_insn (\\\"coma\\\", ops);\n \n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n \t\t\t\t CODE_LABEL_NUMBER (ops[0]));\n@@ -4199,7 +4231,7 @@\n (define_insn \"*ashrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,x\")\n \t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t             (match_operand:HI 2 \"register_operand\" \"x,d\")))\n+\t             (match_operand:HI 2 \"register_operand\" \"+x,+d\")))\n    (clobber (match_dup 2))]\n   \"\"\n   \"*\n@@ -4387,14 +4419,14 @@\n \t\t     (match_operand:DI 2 \"const_int_operand\" \"\")))\n    (clobber (match_scratch:HI 3 \"=d\"))]\n    \"z_replacement_completed && INTVAL (operands[2]) >= 56\"\n-   [(set (reg:QI 1) (match_dup 9))\n-    (set (reg:QI 1) (lshiftrt:QI (reg:QI 1) (match_dup 8)))\n-    (set (reg:HI 1) (zero_extend:HI (reg:QI 1)))\n-    (set (match_dup 4) (reg:HI 1))\n-    (set (reg:QI 1) (const_int 0))\n-    (set (match_dup 5) (reg:HI 1))\n-    (set (match_dup 6) (reg:HI 1))\n-    (set (match_dup 7) (reg:HI 1))]\n+   [(set (reg:QI D_REGNUM) (match_dup 9))\n+    (set (reg:QI D_REGNUM) (lshiftrt:QI (reg:QI D_REGNUM) (match_dup 8)))\n+    (set (reg:HI D_REGNUM) (zero_extend:HI (reg:QI D_REGNUM)))\n+    (set (match_dup 4) (reg:HI D_REGNUM))\n+    (set (reg:QI D_REGNUM) (const_int 0))\n+    (set (match_dup 5) (reg:HI D_REGNUM))\n+    (set (match_dup 6) (reg:HI D_REGNUM))\n+    (set (match_dup 7) (reg:HI D_REGNUM))]\n    \"operands[8] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 56);\n     operands[4] = m68hc11_gen_lowpart (SImode, operands[0]);\n     operands[5] = m68hc11_gen_highpart (HImode, operands[4]);\n@@ -4415,13 +4447,13 @@\n    (clobber (match_scratch:HI 3 \"=d\"))]\n    \"z_replacement_completed && INTVAL (operands[2]) >= 48 \n     && INTVAL (operands[2]) < 56\"\n-   [(set (reg:HI 1) (match_dup 9))\n-    (set (reg:HI 1) (lshiftrt:HI (reg:HI 1) (match_dup 8)))\n-    (set (match_dup 4) (reg:HI 1))\n-    (set (reg:HI 1) (const_int 0))\n-    (set (match_dup 5) (reg:HI 1))\n-    (set (match_dup 6) (reg:HI 1))\n-    (set (match_dup 7) (reg:HI 1))]\n+   [(set (reg:HI D_REGNUM) (match_dup 9))\n+    (set (reg:HI D_REGNUM) (lshiftrt:HI (reg:HI D_REGNUM) (match_dup 8)))\n+    (set (match_dup 4) (reg:HI D_REGNUM))\n+    (set (reg:HI D_REGNUM) (const_int 0))\n+    (set (match_dup 5) (reg:HI D_REGNUM))\n+    (set (match_dup 6) (reg:HI D_REGNUM))\n+    (set (match_dup 7) (reg:HI D_REGNUM))]\n    \"operands[8] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 48);\n     operands[4] = m68hc11_gen_lowpart (SImode, operands[0]);\n     operands[5] = m68hc11_gen_highpart (HImode, operands[4]);\n@@ -4452,15 +4484,15 @@\n     (set (match_dup 4) (match_dup 2))\n \n     (set (match_dup 2) (match_dup 5))\n-    (set (match_dup 2) (rotatert:HI (match_dup 2) (reg:HI 7)))\n+    (set (match_dup 2) (rotatert:HI (match_dup 2) (reg:HI CC_REGNUM)))\n     (set (match_dup 6) (match_dup 2))\n \n     (set (match_dup 2) (match_dup 7))\n-    (set (match_dup 2) (rotatert:HI (match_dup 2) (reg:HI 7)))\n+    (set (match_dup 2) (rotatert:HI (match_dup 2) (reg:HI CC_REGNUM)))\n     (set (match_dup 8) (match_dup 2))\n \n     (set (match_dup 2) (match_dup 9))\n-    (set (match_dup 2) (rotatert:HI (match_dup 2) (reg:HI 7)))\n+    (set (match_dup 2) (rotatert:HI (match_dup 2) (reg:HI CC_REGNUM)))\n     (set (match_dup 10) (match_dup 2))]\n    \"operands[3] = m68hc11_gen_highpart (SImode, operands[1]);\n     operands[5] = m68hc11_gen_lowpart (HImode, operands[3]);\n@@ -4508,8 +4540,10 @@\n \t             (const_int 16)))\n    (clobber (match_scratch:HI 2 \"=X,X,X,X\"))]\n    \"\"\n-   \"#\n+   \"@\n+    #\n     xgdx\\\\n\\\\tldx\\\\t#0\n+    #\n     #\")\n \n (define_insn \"*lshrsi3_const1\"\n@@ -4727,7 +4761,7 @@\n (define_insn \"*lshrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,x\")\n \t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t\t     (match_operand:HI 2 \"register_operand\" \"x,d\")))\n+\t\t     (match_operand:HI 2 \"register_operand\" \"+x,+d\")))\n    (clobber (match_dup 2))]\n   \"\"\n   \"*\n@@ -4868,7 +4902,7 @@\n (define_insn \"*rotlqi3_with_carry\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d,!q\")\n \t(rotate:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n-\t\t   (reg:QI 7)))]\n+\t\t   (reg:QI CC_REGNUM)))]\n   \"\"\n   \"*\n {\n@@ -4881,7 +4915,7 @@\n (define_insn \"*rotlhi3_with_carry\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(rotate:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t   (reg:HI 7)))]\n+\t\t   (reg:HI CC_REGNUM)))]\n   \"\"\n   \"*\n {\n@@ -4892,7 +4926,7 @@\n (define_insn \"*rotrhi3_with_carry\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(rotatert:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (reg:HI 7)))]\n+\t\t     (reg:HI CC_REGNUM)))]\n   \"\"\n   \"*\n {\n@@ -5328,7 +5362,7 @@\n ;;\n ;;- Call a function that returns no value.\n (define_insn \"call\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"mAi\")\n+  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n \t (match_operand:SI 1 \"general_operand\" \"g\"))]\n   ;; Operand 1 not really used on the m68hc11.\n   \"\"\n@@ -5349,7 +5383,7 @@\n \n (define_insn \"call_value\"\n   [(set (match_operand 0 \"\" \"=g\")\n-\t(call (match_operand:QI 1 \"general_operand\" \"mAi\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n  \"*\n@@ -5478,7 +5512,7 @@\n \n (define_insn \"*return_16bit\"\n   [(return)\n-   (use (reg:HI 1))]\n+   (use (reg:HI D_REGNUM))]\n   \"reload_completed && m68hc11_total_frame_size () == 0\"\n   \"*\n {\n@@ -5545,13 +5579,13 @@\n (define_peephole\n   [(set (match_operand:HI 0 \"hard_reg_operand\" \"xy\")\n \t(match_operand:HI 1 \"const_int_operand\" \"\"))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-\t      (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:HI 1)\n-\t(plus (reg:HI 1)\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+\t      (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:HI D_REGNUM)\n+\t(plus (reg:HI D_REGNUM)\n \t      (match_operand:HI 2 \"general_operand\" \"\")))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-\t      (set (match_dup 0) (reg:HI 1))])]\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+\t      (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"(INTVAL (operands[1]) & 0x0FF) == 0\"\n   \"*\n {\n@@ -5634,9 +5668,9 @@\n ;; (set ...) insn.\n ;;\n (define_peephole\n-  [(set (match_operand:HI 0 \"hard_reg_operand\" \"A\") (reg:HI 1))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])]\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"A\") (reg:HI D_REGNUM))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"find_regno_note (ins1, REG_DEAD, HARD_D_REGNUM)\"\n   \"*\n {\n@@ -5648,10 +5682,10 @@\n ;; Same as above but due to some split, there may be a noop set\n ;; between the two.\n (define_peephole\n-  [(set (match_operand:HI 0 \"hard_reg_operand\" \"A\") (reg:HI 1))\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"A\") (reg:HI D_REGNUM))\n    (set (match_dup 0) (match_dup 0))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])]\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"find_regno_note (ins1, REG_DEAD, HARD_D_REGNUM)\"\n   \"*\n {\n@@ -5665,9 +5699,9 @@\n ;; and we must, at least, setup X/Y with value of D.\n ;;\n (define_peephole\n-  [(set (match_operand:HI 0 \"hard_reg_operand\" \"A\") (reg:HI 1))\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])]\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"A\") (reg:HI D_REGNUM))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"\"\n   \"*\n {\n@@ -5685,9 +5719,9 @@\n ;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.\n ;;;\n (define_peephole\n-  [(parallel [(set (reg:HI 1) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:HI 1) (match_dup 0))]\n+  [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:HI D_REGNUM) (match_dup 0))]\n   \"find_regno_note (insn, REG_DEAD, REGNO (operands[0]))\"\n   \"*\n {\n@@ -5701,9 +5735,9 @@\n ;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.\n ;;;\n (define_peephole\n-  [(parallel [(set (reg:HI 1) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:QI 1) (match_operand:QI 1 \"hard_reg_operand\" \"A\"))]\n+  [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:QI D_REGNUM) (match_operand:QI 1 \"hard_reg_operand\" \"A\"))]\n   \"REGNO (operands[0]) == REGNO (operands[1])\n    && find_regno_note (insn, REG_DEAD, REGNO (operands[0]))\"\n   \"*\n@@ -5718,9 +5752,9 @@\n ;;; need to emit anything. Otherwise, we just need a copy of D to X/Y.\n ;;;\n (define_peephole\n-  [(parallel [(set (reg:HI 1) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:HI 1) (match_dup 0))]\n+  [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:HI D_REGNUM) (match_dup 0))]\n   \"\"\n   \"*\n {\n@@ -5738,9 +5772,9 @@\n ;;; with the xgdx.\n ;;;\n (define_peephole\n-  [(parallel [(set (reg:HI 1) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (set (reg:QI 1) (match_operand:QI 1 \"hard_reg_operand\" \"A\"))]\n+  [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (set (reg:QI D_REGNUM) (match_operand:QI 1 \"hard_reg_operand\" \"A\"))]\n   \"REGNO (operands[0]) == REGNO (operands[1])\"\n   \"*\n {\n@@ -5757,10 +5791,10 @@\n ;;; Catch two consecutive xgdx or xgdy, emit nothing.\n ;;;\n (define_peephole\n-  [(parallel [(set (reg:HI 1) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n-              (set (match_dup 0) (reg:HI 1))])\n-   (parallel [(set (reg:HI 1) (match_dup 0))\n-              (set (match_dup 0) (reg:HI 1))])]\n+  [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n+              (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"\"\n   \"*\n {\n@@ -5834,7 +5868,7 @@\n ;;\n (define_peephole\n   [(set (match_operand:HI 0 \"hard_reg_operand\" \"dA\") (const_int -1))\n-   (set (match_dup 0) (plus:HI (match_dup 0) (reg:HI 3)))]\n+   (set (match_dup 0) (plus:HI (match_dup 0) (reg:HI SP_REGNUM)))]\n   \"TARGET_M6811\"\n   \"*\n {"}]}