{"sha": "6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc1N2VkZmU2NTVmOWIyMWNkZDFkYmFkZGQ4MGI4YzVkZGM2MzgyMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-04-26T16:30:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-04-26T16:30:11Z"}, "message": "cp-tree.h (CLASSTYPE_IS_TEMPLATE): New macro.\n\n\t* cp-tree.h (CLASSTYPE_IS_TEMPLATE): New macro.\n\t(DECL_CLASS_TEMPLATE_P): Likewise.\n\t(DECL_PRIMARY_TEMPLATE): Likewise.\n\t(PRIMARY_TEMPLATE_P): Use it.\n\t(push_template_decl_real): New function.\n\t(redeclare_class_template): Take new template parameters as\n\tinput.\n\t(is_specialization_of): New function.\n\t(comp_template_args): Declare.\n\t* decl.c (pushtag): Handle friend template classes.\n\t(xref_tag): Likewise.  Use new calling convention for\n\tredeclare_class_template.\n\t* decl2.c (grok_x_components): Handle friend templates.\n\t* friend.c (is_friend): Use is_specialization_of where\n\tappropriate.  Deal with friend class templates.\n\t(make_friend_class): Let a class template be friends with itself.\n\t* pt.c (comp_template_args): Remove declaration.\n\t(tsubst_friend_class): New function.\n\t(push_template_decl_real): New function.\n\t(push_template_decl): Use it.\n\t(redeclare_class_template): Adjust for new calling convention.\n\t(comp_template_args): Give it external linkage.\n\t(instantiate_class_type): Use tsubst_friend_class to deal\n\twith friend templates.\n\t* typeck.c (comptypes): Use comp_template_args, rather than\n\texpanding it inline.\n\t* parse.y (component_decl): Handle a nested template type\n\tlike other component type declarations.\n\nFrom-SVN: r19418", "tree": {"sha": "81d5ea7e7ca626cf4ade65df9c83bc0fd7422bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81d5ea7e7ca626cf4ade65df9c83bc0fd7422bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/comments", "author": null, "committer": null, "parents": [{"sha": "7bf407413f0d6b36bd1a799fea2d5863465dafed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf407413f0d6b36bd1a799fea2d5863465dafed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf407413f0d6b36bd1a799fea2d5863465dafed"}], "stats": {"total": 1187, "additions": 778, "deletions": 409}, "files": [{"sha": "d77726d19a3e2d8dcb89fa7bf5414d94fd22c70d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -1,5 +1,34 @@\n Sun Apr 26 12:10:18 1998  Mark Mitchell  <mmitchell@usa.net>\n \n+\t* cp-tree.h (CLASSTYPE_IS_TEMPLATE): New macro.\n+\t(DECL_CLASS_TEMPLATE_P): Likewise.\n+\t(DECL_PRIMARY_TEMPLATE): Likewise.\n+\t(PRIMARY_TEMPLATE_P): Use it.\n+\t(push_template_decl_real): New function.\n+\t(redeclare_class_template): Take new template parameters as\n+\tinput. \n+\t(is_specialization_of): New function.\n+\t(comp_template_args): Declare.\n+\t* decl.c (pushtag): Handle friend template classes.\n+\t(xref_tag): Likewise.  Use new calling convention for\n+\tredeclare_class_template.\n+\t* decl2.c (grok_x_components): Handle friend templates.\n+\t* friend.c (is_friend): Use is_specialization_of where\n+\tappropriate.  Deal with friend class templates.\n+\t(make_friend_class): Let a class template be friends with itself.\n+\t* pt.c (comp_template_args): Remove declaration.\n+\t(tsubst_friend_class): New function.\n+\t(push_template_decl_real): New function.\n+\t(push_template_decl): Use it.\n+\t(redeclare_class_template): Adjust for new calling convention.\n+\t(comp_template_args): Give it external linkage.\n+\t(instantiate_class_type): Use tsubst_friend_class to deal\n+\twith friend templates.\n+\t* typeck.c (comptypes): Use comp_template_args, rather than\n+\texpanding it inline.\n+\t* parse.y (component_decl): Handle a nested template type \n+\tlike other component type declarations.\n+\n \t* pt.c (check_explicit_specialization): Handle overloaded\n \tconstructors correctly.\n "}, {"sha": "b91f2e9ab4322d558da294d9cd753c5e4af04671", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -1139,6 +1139,15 @@ struct lang_decl\n #define DELETE_EXPR_USE_VEC(NODE)\tTREE_LANG_FLAG_1 (NODE)\n #define LOOKUP_EXPR_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n+/* The TYPE_MAIN_DECL for a class template type is a TYPE_DECL, not a\n+   TEMPLATE_DECL.  This macro determines whether or not a given class\n+   type is really a template type, as opposed to an instantiation or\n+   specialization of one.  */\n+#define CLASSTYPE_IS_TEMPLATE(NODE)  \\\n+  (CLASSTYPE_TEMPLATE_INFO (NODE)    \\\n+   && !CLASSTYPE_USE_TEMPLATE (NODE) \\\n+   && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE)))\n+\n #define TYPENAME_TYPE_FULLNAME(NODE)\tCLASSTYPE_SIZE (NODE)\n \n /* Nonzero in INT_CST means that this int is negative by dint of\n@@ -1412,11 +1421,22 @@ extern int flag_new_for_scope;\n   (TREE_CODE (NODE) == TEMPLATE_DECL \\\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n \n+/* Nonzero for a DECL that represents a template class.  */\n+#define DECL_CLASS_TEMPLATE_P(NODE) \\\n+  (TREE_CODE (NODE) == TEMPLATE_DECL \\\n+   && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == TYPE_DECL \\\n+   && !DECL_TEMPLATE_TEMPLATE_PARM_P (NODE))\n+\n /* A `primary' template is one that has its own template header.  A\n    member function of a class template is a template, but not primary.\n-   A member template is primary.  */\n-#define PRIMARY_TEMPLATE_P(NODE) \\\n-  (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)) == (NODE))\n+   A member template is primary.  Friend templates are primary, too.  */\n+\n+/* Returns the primary template corresponding to these parameters.  */\n+#define DECL_PRIMARY_TEMPLATE(NODE) \\\n+  (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)))\n+\n+/* Returns non-zero if NODE is a primary template.  */\n+#define PRIMARY_TEMPLATE_P(NODE) (DECL_PRIMARY_TEMPLATE (NODE) == NODE)\n \n #define CLASSTYPE_TEMPLATE_LEVEL(NODE) \\\n   (TREE_INT_CST_HIGH (TREE_PURPOSE (CLASSTYPE_TI_TEMPLATE (NODE))))\n@@ -2435,7 +2455,8 @@ extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n extern tree current_template_args\t\tPROTO((void));\n extern tree push_template_decl\t\t\tPROTO((tree));\n-extern void redeclare_class_template            PROTO((tree));\n+extern tree push_template_decl_real             PROTO((tree, int));\n+extern void redeclare_class_template            PROTO((tree, tree));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree, tree));\n extern tree lookup_template_function            PROTO((tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));\n@@ -2467,6 +2488,9 @@ extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));\n extern int comp_template_parms                  PROTO((tree, tree));\n extern int template_class_depth                 PROTO((tree));\n+extern int is_specialization_of                 PROTO((tree, tree));\n+extern int comp_template_args                   PROTO((tree, tree));\n+\n extern int processing_specialization;\n extern int processing_explicit_instantiation;\n "}, {"sha": "62d9db221c10b6db0c1edafe4a0288215665a8bb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -2157,7 +2157,7 @@ pop_everything ()\n }\n \n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n-   Normally put into into the inner-most non-tag-transparent scope,\n+   Normally put it into the inner-most non-tag-transparent scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n    The latter is needed for implicit declarations.  */\n \n@@ -2226,11 +2226,52 @@ pushtag (name, type, globalize)\n \t  TYPE_NAME (type) = d;\n \t  DECL_CONTEXT (d) = context;\n \n-\t  if (! globalize && processing_template_decl\n-\t      && IS_AGGR_TYPE (type))\n-\t    {\n-\t      d = push_template_decl (d);\n-\t      if (b->pseudo_global && b->level_chain->parm_flag == 2)\n+\t  if (IS_AGGR_TYPE (type)\n+\t      && (/* If !GLOBALIZE then we are looking at a\n+\t\t     definition.  */\n+\t\t  (processing_template_decl && !globalize)\n+\t\t  /* This next condition is tricky.  If we are\n+\t\t     declaring a friend template class, we will have\n+\t\t     GLOBALIZE set, since something like:\n+\n+\t\t       template <class T>\n+\t\t       struct S1 {\n+\t\t         template <class U>\n+\t\t         friend class S2; \n+\t\t       };\n+\n+\t\t     declares S2 to be at global scope.  The condition\n+\t\t     says that we are looking at a primary template\n+\t\t     that is being declared in class scope.  We can't\n+\t\t     just drop the `in class scope' and then not check\n+\t\t     GLOBALIZE either since on this code:\n+\t\t  \n+\t\t       template <class T>\n+\t\t       struct S1 {};\n+\t\t       template <class T>\n+\t\t       struct S2 { S1<T> f(); } \n+\n+\t\t     we get called by lookup_template_class (with TYPE\n+\t\t     set to S1<T> and GLOBALIZE set to 1).  However,\n+\t\t     lookup_template_class calls\n+\t\t     maybe_push_to_top_level which doesn't clear\n+\t\t     processing_template_decl, so we would then\n+\t\t     incorrectly call push_template_decl.  */\n+\t\t  || (current_class_type != NULL_TREE\n+\t\t      && (processing_template_decl > \n+\t\t\t  template_class_depth (current_class_type)))))\n+\t    {\n+\t      d = push_template_decl_real (d, globalize);\n+\t      /* If the current binding level is the binding level for\n+\t\t the template parameters (see the comment in\n+\t\t begin_template_parm_list) and the enclosing level is\n+\t\t a class scope, and we're not looking at a friend,\n+\t\t push the declaration of the member class into the\n+\t\t class scope.  In the friend case, push_template_decl\n+\t\t will already have put the friend into global scope,\n+\t\t if appropriate.  */ \n+\t      if (!globalize && b->pseudo_global &&\n+\t\t  b->level_chain->parm_flag == 2)\n \t\tpushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n \t\t\t\t     b->level_chain);\n \t    }\n@@ -10812,6 +10853,15 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t{\n \t  /* Try finding it as a type declaration.  If that wins, use it.  */\n \t  ref = lookup_name (name, 1);\n+\n+\t  if (ref != NULL_TREE\n+\t      && processing_template_decl\n+\t      && DECL_CLASS_TEMPLATE_P (ref)\n+\t      && template_class_depth (current_class_type) == 0)\n+\t    /* Since GLOBALIZE is true, we're declaring a global\n+\t       template, so we want this type.  */\n+\t    ref = DECL_RESULT (ref);\n+\n \t  if (ref && TREE_CODE (ref) == TYPE_DECL\n \t      && TREE_CODE (TREE_TYPE (ref)) == code)\n \t    ref = TREE_TYPE (ref);\n@@ -10898,7 +10948,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t}\n \n       if (!globalize && processing_template_decl && IS_AGGR_TYPE (ref))\n-\tredeclare_class_template (ref);\n+\tredeclare_class_template (ref, current_template_parms);\n     }\n \n   if (binfo)"}, {"sha": "32f90e84dbe3f7272101031fed25a69e495190a3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -870,8 +870,16 @@ grok_x_components (specs, components)\n \t    tcode = class_type_node;\n \t  else if (IS_SIGNATURE (t))\n \t    tcode = signature_type_node;\n-\t  \n-\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n+\n+\t  if (CLASSTYPE_IS_TEMPLATE (t))\n+\t    /* In this case, the TYPE_IDENTIFIER will be something\n+\t       like S<T>, rather than S, so to get the correct name we\n+\t       look at the template.  */\n+\t    x = DECL_NAME (CLASSTYPE_TI_TEMPLATE (t));\n+\t  else\n+\t    x = TYPE_IDENTIFIER (t);\n+\n+\t  t = xref_tag (tcode, x, NULL_TREE, 0);\n \t  return NULL_TREE;\n \t  break;\n "}, {"sha": "e5d1ccf0ed20873c81d09fac9e02a9be6aafbc0b", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -71,25 +71,17 @@ is_friend (type, supplicant)\n \n \t\t  if (TREE_CODE (TREE_VALUE (friends)) == TEMPLATE_DECL)\n \t\t    {\n-\t\t      tree t;\n-\n-\t\t      /* Perhaps this function is a specialization of\n-\t\t\t a friend template.  */\n-\t\t      for (t = supplicant;\n-\t\t\t   t != NULL_TREE;\n-\t\t\t   t = DECL_TEMPLATE_INFO (t) ? \n-\t\t\t     DECL_TI_TEMPLATE (t) : NULL_TREE)\n-\t\t\t/* FIXME: The use of comptypes here, and below, is\n-\t\t\t   bogus, since two specializations of a\n-\t\t\t   template parameter with non-type parameters\n-\t\t\t   may have the same type, but be different.  */\n-\t\t\tif (comptypes (TREE_TYPE (t),\n-\t\t\t\t       TREE_TYPE (TREE_VALUE (friends)), 1))\n-\t\t\t  return 1;\n+\t\t      if (is_specialization_of (supplicant, \n+\t\t\t\t\t\tTREE_VALUE (friends)))\n+\t\t\treturn 1;\n \n \t\t      continue;\n \t\t    }\n \n+\t\t  /* FIXME: The use of comptypes here is bogus, since\n+\t\t     two specializations of a template with non-type\n+\t\t     parameters may have the same type, but be\n+\t\t     different.  */\n \t\t  if (comptypes (TREE_TYPE (supplicant),\n \t\t\t\t TREE_TYPE (TREE_VALUE (friends)), 1))\n \t\t    return 1;\n@@ -106,8 +98,15 @@ is_friend (type, supplicant)\n       \n       list = CLASSTYPE_FRIEND_CLASSES (TREE_TYPE (TYPE_MAIN_DECL (type)));\n       for (; list ; list = TREE_CHAIN (list))\n-\tif (supplicant == TREE_VALUE (list))\n-\t  return 1;\n+\t{\n+\t  tree t = TREE_VALUE (list);\n+\n+\t  if (supplicant == t\n+\t      || (CLASSTYPE_IS_TEMPLATE (t)\n+\t\t  && is_specialization_of (TYPE_MAIN_DECL (supplicant),\n+\t\t\t\t\t   CLASSTYPE_TI_TEMPLATE (t))))\n+\t    return 1;\n+\t}\n     }      \n \n   if (declp && DECL_FUNCTION_MEMBER_P (supplicant))\n@@ -249,7 +248,10 @@ make_friend_class (type, friend_type)\n \t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (friend_type)));\n       return;\n     }\n-  if (type == friend_type)\n+  /* If the TYPE is a template then it makes sense for it to be\n+     friends with itself; this means that each instantiation is\n+     friends with all other instantiations.  */\n+  if (type == friend_type && !CLASSTYPE_IS_TEMPLATE (type))\n     {\n       pedwarn (\"class `%s' is implicitly friends with itself\",\n \t       TYPE_NAME_STRING (type));"}, {"sha": "dd68890e6a313da567324f9b477cd6b3b2d5add3", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 323, "deletions": 319, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -674,41 +674,41 @@ static const short yyrline[] = { 0,\n   2142,  2170,  2176,  2178,  2181,  2184,  2186,  2190,  2192,  2196,\n   2222,  2251,  2254,  2255,  2276,  2299,  2301,  2305,  2316,  2330,\n   2419,  2426,  2429,  2437,  2448,  2457,  2461,  2476,  2479,  2484,\n-  2486,  2488,  2490,  2492,  2494,  2497,  2499,  2507,  2513,  2515,\n-  2518,  2521,  2523,  2534,  2539,  2542,  2547,  2550,  2551,  2562,\n-  2565,  2566,  2577,  2579,  2582,  2584,  2587,  2594,  2602,  2609,\n-  2615,  2621,  2629,  2633,  2638,  2642,  2645,  2654,  2656,  2660,\n-  2663,  2668,  2672,  2677,  2687,  2690,  2694,  2698,  2706,  2711,\n-  2717,  2720,  2722,  2724,  2730,  2733,  2735,  2737,  2739,  2743,\n-  2746,  2764,  2774,  2776,  2777,  2781,  2786,  2789,  2791,  2793,\n-  2795,  2799,  2805,  2808,  2810,  2812,  2814,  2818,  2821,  2824,\n-  2826,  2828,  2830,  2834,  2837,  2840,  2842,  2844,  2846,  2853,\n-  2864,  2868,  2873,  2877,  2882,  2884,  2888,  2891,  2893,  2897,\n-  2899,  2900,  2903,  2905,  2907,  2913,  2928,  2934,  2940,  2954,\n-  2956,  2960,  2974,  2976,  2978,  2982,  2988,  3001,  3003,  3007,\n-  3018,  3024,  3026,  3027,  3028,  3036,  3041,  3050,  3051,  3055,\n-  3058,  3064,  3070,  3073,  3075,  3077,  3079,  3083,  3087,  3091,\n-  3094,  3099,  3102,  3104,  3106,  3108,  3110,  3112,  3114,  3116,\n-  3120,  3124,  3128,  3132,  3133,  3135,  3137,  3139,  3141,  3143,\n-  3145,  3147,  3149,  3157,  3159,  3160,  3161,  3164,  3170,  3172,\n-  3177,  3179,  3182,  3196,  3199,  3202,  3206,  3209,  3216,  3218,\n-  3221,  3223,  3225,  3228,  3231,  3234,  3237,  3239,  3242,  3246,\n-  3248,  3254,  3256,  3257,  3259,  3264,  3266,  3268,  3270,  3272,\n-  3275,  3276,  3278,  3281,  3282,  3285,  3285,  3288,  3288,  3291,\n-  3291,  3293,  3295,  3297,  3299,  3305,  3311,  3314,  3317,  3323,\n-  3325,  3327,  3331,  3333,  3336,  3343,  3346,  3354,  3358,  3360,\n-  3363,  3365,  3368,  3372,  3374,  3377,  3379,  3382,  3399,  3405,\n-  3413,  3415,  3417,  3421,  3424,  3425,  3433,  3437,  3441,  3444,\n-  3445,  3451,  3454,  3457,  3459,  3463,  3468,  3471,  3481,  3486,\n-  3487,  3495,  3501,  3506,  3510,  3515,  3519,  3523,  3527,  3532,\n-  3543,  3557,  3561,  3564,  3566,  3570,  3574,  3577,  3580,  3582,\n-  3586,  3588,  3595,  3602,  3605,  3608,  3612,  3616,  3622,  3626,\n-  3631,  3633,  3636,  3641,  3647,  3658,  3661,  3663,  3667,  3672,\n-  3674,  3681,  3684,  3686,  3688,  3694,  3699,  3702,  3704,  3706,\n-  3708,  3710,  3712,  3714,  3716,  3718,  3720,  3722,  3724,  3726,\n-  3728,  3730,  3732,  3734,  3736,  3738,  3740,  3742,  3744,  3746,\n-  3748,  3750,  3752,  3754,  3756,  3758,  3760,  3762,  3764,  3767,\n-  3769\n+  2486,  2488,  2490,  2492,  2494,  2497,  2499,  2511,  2517,  2519,\n+  2522,  2525,  2527,  2538,  2543,  2546,  2551,  2554,  2555,  2566,\n+  2569,  2570,  2581,  2583,  2586,  2588,  2591,  2598,  2606,  2613,\n+  2619,  2625,  2633,  2637,  2642,  2646,  2649,  2658,  2660,  2664,\n+  2667,  2672,  2676,  2681,  2691,  2694,  2698,  2702,  2710,  2715,\n+  2721,  2724,  2726,  2728,  2734,  2737,  2739,  2741,  2743,  2747,\n+  2750,  2768,  2778,  2780,  2781,  2785,  2790,  2793,  2795,  2797,\n+  2799,  2803,  2809,  2812,  2814,  2816,  2818,  2822,  2825,  2828,\n+  2830,  2832,  2834,  2838,  2841,  2844,  2846,  2848,  2850,  2857,\n+  2868,  2872,  2877,  2881,  2886,  2888,  2892,  2895,  2897,  2901,\n+  2903,  2904,  2907,  2909,  2911,  2917,  2932,  2938,  2944,  2958,\n+  2960,  2964,  2978,  2980,  2982,  2986,  2992,  3005,  3007,  3011,\n+  3022,  3028,  3030,  3031,  3032,  3040,  3045,  3054,  3055,  3059,\n+  3062,  3068,  3074,  3077,  3079,  3081,  3083,  3087,  3091,  3095,\n+  3098,  3103,  3106,  3108,  3110,  3112,  3114,  3116,  3118,  3120,\n+  3124,  3128,  3132,  3136,  3137,  3139,  3141,  3143,  3145,  3147,\n+  3149,  3151,  3153,  3161,  3163,  3164,  3165,  3168,  3174,  3176,\n+  3181,  3183,  3186,  3200,  3203,  3206,  3210,  3213,  3220,  3222,\n+  3225,  3227,  3229,  3232,  3235,  3238,  3241,  3243,  3246,  3250,\n+  3252,  3258,  3260,  3261,  3263,  3268,  3270,  3272,  3274,  3276,\n+  3279,  3280,  3282,  3285,  3286,  3289,  3289,  3292,  3292,  3295,\n+  3295,  3297,  3299,  3301,  3303,  3309,  3315,  3318,  3321,  3327,\n+  3329,  3331,  3335,  3337,  3340,  3347,  3350,  3358,  3362,  3364,\n+  3367,  3369,  3372,  3376,  3378,  3381,  3383,  3386,  3403,  3409,\n+  3417,  3419,  3421,  3425,  3428,  3429,  3437,  3441,  3445,  3448,\n+  3449,  3455,  3458,  3461,  3463,  3467,  3472,  3475,  3485,  3490,\n+  3491,  3499,  3505,  3510,  3514,  3519,  3523,  3527,  3531,  3536,\n+  3547,  3561,  3565,  3568,  3570,  3574,  3578,  3581,  3584,  3586,\n+  3590,  3592,  3599,  3606,  3609,  3612,  3616,  3620,  3626,  3630,\n+  3635,  3637,  3640,  3645,  3651,  3662,  3665,  3667,  3671,  3676,\n+  3678,  3685,  3688,  3690,  3692,  3698,  3703,  3706,  3708,  3710,\n+  3712,  3714,  3716,  3718,  3720,  3722,  3724,  3726,  3728,  3730,\n+  3732,  3734,  3736,  3738,  3740,  3742,  3744,  3746,  3748,  3750,\n+  3752,  3754,  3756,  3758,  3760,  3762,  3764,  3766,  3768,  3771,\n+  3773\n };\n #endif\n \n@@ -3491,7 +3491,7 @@ static const short yycheck[] = {     4,\n     80,    81,    82,    83,    84,    85\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -3684,7 +3684,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 196 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -6355,59 +6355,63 @@ case 506:\n case 507:\n #line 2500 \"parse.y\"\n {\n-\t\t  shadow_tag (yyvsp[-1].ftype.t);\n \t\t  note_list_got_semicolon (yyvsp[-1].ftype.t);\n+\t\t  grok_x_components (yyvsp[-1].ftype.t, NULL_TREE); \n+\t\t  if (TYPE_CONTEXT (TREE_VALUE (yyvsp[-1].ftype.t)) != current_class_type)\n+\t\t    /* The component was in fact a friend\n+\t\t       declaration.  */\n+\t\t    yyvsp[-1].ftype.t = NULL_TREE;\n \t\t  yyval.ttype = finish_member_template_decl (yyvsp[-2].ttype, yyvsp[-1].ftype.t);\n \t\t;\n     break;}\n case 508:\n-#line 2512 \"parse.y\"\n+#line 2516 \"parse.y\"\n { yyval.ttype = grok_x_components (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 509:\n-#line 2514 \"parse.y\"\n+#line 2518 \"parse.y\"\n { yyval.ttype = grok_x_components (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 510:\n-#line 2516 \"parse.y\"\n+#line 2520 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 511:\n-#line 2519 \"parse.y\"\n+#line 2523 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 512:\n-#line 2522 \"parse.y\"\n+#line 2526 \"parse.y\"\n { yyval.ttype = grokbitfield (NULL_TREE, NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 513:\n-#line 2524 \"parse.y\"\n+#line 2528 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 514:\n-#line 2535 \"parse.y\"\n+#line 2539 \"parse.y\"\n { tree specs, attrs;\n \t\t  split_specs_attrs (yyvsp[-4].ttype, &specs, &attrs);\n \t\t  yyval.ttype = grokfield (yyvsp[-3].ttype, specs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, attrs)); ;\n     break;}\n case 515:\n-#line 2540 \"parse.y\"\n+#line 2544 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 516:\n-#line 2543 \"parse.y\"\n+#line 2547 \"parse.y\"\n { yyval.ttype = do_class_using_decl (yyvsp[0].ttype); ;\n     break;}\n case 517:\n-#line 2549 \"parse.y\"\n+#line 2553 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 519:\n-#line 2552 \"parse.y\"\n+#line 2556 \"parse.y\"\n {\n \t\t  /* In this context, void_type_node encodes\n \t\t     friends.  They have been recorded elsewhere.  */\n@@ -6418,11 +6422,11 @@ case 519:\n \t\t;\n     break;}\n case 520:\n-#line 2564 \"parse.y\"\n+#line 2568 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 522:\n-#line 2567 \"parse.y\"\n+#line 2571 \"parse.y\"\n {\n \t\t  /* In this context, void_type_node encodes\n \t\t     friends.  They have been recorded elsewhere.  */\n@@ -6433,102 +6437,102 @@ case 522:\n \t\t;\n     break;}\n case 527:\n-#line 2589 \"parse.y\"\n+#line 2593 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 528:\n-#line 2595 \"parse.y\"\n+#line 2599 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 529:\n-#line 2604 \"parse.y\"\n+#line 2608 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 530:\n-#line 2610 \"parse.y\"\n+#line 2614 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 531:\n-#line 2616 \"parse.y\"\n+#line 2620 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 532:\n-#line 2622 \"parse.y\"\n+#line 2626 \"parse.y\"\n { split_specs_attrs (yyvsp[-3].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-3].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (NULL_TREE, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 533:\n-#line 2631 \"parse.y\"\n+#line 2635 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 534:\n-#line 2634 \"parse.y\"\n+#line 2638 \"parse.y\"\n { yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 535:\n-#line 2640 \"parse.y\"\n+#line 2644 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 536:\n-#line 2643 \"parse.y\"\n+#line 2647 \"parse.y\"\n { yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 537:\n-#line 2646 \"parse.y\"\n+#line 2650 \"parse.y\"\n { yyval.ttype = grokbitfield (NULL_TREE, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 539:\n-#line 2657 \"parse.y\"\n+#line 2661 \"parse.y\"\n { TREE_CHAIN (yyvsp[0].ttype) = yyval.ttype; yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 540:\n-#line 2662 \"parse.y\"\n+#line 2666 \"parse.y\"\n { yyval.ttype = build_enumerator (yyval.ttype, NULL_TREE); ;\n     break;}\n case 541:\n-#line 2664 \"parse.y\"\n+#line 2668 \"parse.y\"\n { yyval.ttype = build_enumerator (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 542:\n-#line 2670 \"parse.y\"\n+#line 2674 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 543:\n-#line 2673 \"parse.y\"\n+#line 2677 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[0].ftype.t, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 544:\n-#line 2678 \"parse.y\"\n+#line 2682 \"parse.y\"\n {\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n@@ -6538,71 +6542,71 @@ case 544:\n \t\t;\n     break;}\n case 545:\n-#line 2689 \"parse.y\"\n+#line 2693 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 546:\n-#line 2691 \"parse.y\"\n+#line 2695 \"parse.y\"\n { yyval.ttype = decl_tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 547:\n-#line 2696 \"parse.y\"\n+#line 2700 \"parse.y\"\n { yyval.ftype.t = IDENTIFIER_AS_LIST (yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 548:\n-#line 2699 \"parse.y\"\n+#line 2703 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ftype.t); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 549:\n-#line 2708 \"parse.y\"\n+#line 2712 \"parse.y\"\n { yyval.itype = suspend_momentary (); ;\n     break;}\n case 550:\n-#line 2713 \"parse.y\"\n+#line 2717 \"parse.y\"\n { resume_momentary ((int) yyvsp[-1].itype); yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 551:\n-#line 2719 \"parse.y\"\n+#line 2723 \"parse.y\"\n { resume_momentary ((int) yyvsp[-3].itype); yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 552:\n-#line 2721 \"parse.y\"\n+#line 2725 \"parse.y\"\n { resume_momentary ((int) yyvsp[-3].itype); yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 553:\n-#line 2723 \"parse.y\"\n+#line 2727 \"parse.y\"\n { resume_momentary ((int) yyvsp[-1].itype); yyval.ttype = empty_parms (); ;\n     break;}\n case 554:\n-#line 2725 \"parse.y\"\n+#line 2729 \"parse.y\"\n { resume_momentary ((int) yyvsp[-3].itype); yyval.ttype = NULL_TREE; ;\n     break;}\n case 555:\n-#line 2732 \"parse.y\"\n+#line 2736 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 556:\n-#line 2734 \"parse.y\"\n+#line 2738 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 557:\n-#line 2736 \"parse.y\"\n+#line 2740 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 558:\n-#line 2738 \"parse.y\"\n+#line 2742 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 559:\n-#line 2740 \"parse.y\"\n+#line 2744 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 561:\n-#line 2748 \"parse.y\"\n+#line 2752 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    {\n@@ -6621,7 +6625,7 @@ case 561:\n \t\t;\n     break;}\n case 562:\n-#line 2765 \"parse.y\"\n+#line 2769 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = IDENTIFIER_GLOBAL_VALUE (yyvsp[0].ttype);\n@@ -6631,97 +6635,97 @@ case 562:\n \t\t;\n     break;}\n case 565:\n-#line 2778 \"parse.y\"\n+#line 2782 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 566:\n-#line 2783 \"parse.y\"\n+#line 2787 \"parse.y\"\n { yyval.ttype = get_type_decl (yyvsp[0].ttype); ;\n     break;}\n case 567:\n-#line 2788 \"parse.y\"\n+#line 2792 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 568:\n-#line 2790 \"parse.y\"\n+#line 2794 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 569:\n-#line 2792 \"parse.y\"\n+#line 2796 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 570:\n-#line 2794 \"parse.y\"\n+#line 2798 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 571:\n-#line 2796 \"parse.y\"\n+#line 2800 \"parse.y\"\n { push_nested_class (yyvsp[-1].ttype, 3);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype);\n \t\t  TREE_COMPLEXITY (yyval.ttype) = current_class_depth; ;\n     break;}\n case 573:\n-#line 2807 \"parse.y\"\n+#line 2811 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 574:\n-#line 2809 \"parse.y\"\n+#line 2813 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 575:\n-#line 2811 \"parse.y\"\n+#line 2815 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 576:\n-#line 2813 \"parse.y\"\n+#line 2817 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 577:\n-#line 2815 \"parse.y\"\n+#line 2819 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 579:\n-#line 2823 \"parse.y\"\n+#line 2827 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 580:\n-#line 2825 \"parse.y\"\n+#line 2829 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 581:\n-#line 2827 \"parse.y\"\n+#line 2831 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 582:\n-#line 2829 \"parse.y\"\n+#line 2833 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 583:\n-#line 2831 \"parse.y\"\n+#line 2835 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 585:\n-#line 2839 \"parse.y\"\n+#line 2843 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 586:\n-#line 2841 \"parse.y\"\n+#line 2845 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 587:\n-#line 2843 \"parse.y\"\n+#line 2847 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 588:\n-#line 2845 \"parse.y\"\n+#line 2849 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 589:\n-#line 2847 \"parse.y\"\n+#line 2851 \"parse.y\"\n { if (OP0 (yyval.ttype) != current_class_type)\n \t\t    {\n \t\t      push_nested_class (OP0 (yyval.ttype), 3);\n@@ -6730,7 +6734,7 @@ case 589:\n \t\t;\n     break;}\n case 590:\n-#line 2854 \"parse.y\"\n+#line 2858 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  if (yyvsp[-1].ttype != current_class_type)\n@@ -6741,51 +6745,51 @@ case 590:\n \t\t;\n     break;}\n case 591:\n-#line 2866 \"parse.y\"\n+#line 2870 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 592:\n-#line 2869 \"parse.y\"\n+#line 2873 \"parse.y\"\n { got_scope = NULL_TREE;\n  \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 593:\n-#line 2875 \"parse.y\"\n+#line 2879 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 594:\n-#line 2878 \"parse.y\"\n+#line 2882 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 596:\n-#line 2885 \"parse.y\"\n+#line 2889 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 597:\n-#line 2890 \"parse.y\"\n+#line 2894 \"parse.y\"\n { yyval.ttype = build_functional_cast (yyvsp[-3].ftype.t, yyvsp[-1].ttype); ;\n     break;}\n case 598:\n-#line 2892 \"parse.y\"\n+#line 2896 \"parse.y\"\n { yyval.ttype = reparse_decl_as_expr (yyvsp[-3].ftype.t, yyvsp[-1].ttype); ;\n     break;}\n case 599:\n-#line 2894 \"parse.y\"\n+#line 2898 \"parse.y\"\n { yyval.ttype = reparse_absdcl_as_expr (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 604:\n-#line 2906 \"parse.y\"\n+#line 2910 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 605:\n-#line 2908 \"parse.y\"\n+#line 2912 \"parse.y\"\n { got_scope = yyval.ttype = make_typename_type (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 606:\n-#line 2915 \"parse.y\"\n+#line 2919 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) == IDENTIFIER_NODE)\n \t\t    {\n@@ -6801,31 +6805,31 @@ case 606:\n \t\t;\n     break;}\n case 607:\n-#line 2929 \"parse.y\"\n+#line 2933 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype = TREE_TYPE (yyval.ttype);\n \t\t;\n     break;}\n case 608:\n-#line 2935 \"parse.y\"\n+#line 2939 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyval.ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype;\n \t\t;\n     break;}\n case 609:\n-#line 2941 \"parse.y\"\n+#line 2945 \"parse.y\"\n { got_scope = yyval.ttype = complete_type (TREE_TYPE (yyvsp[-1].ttype)); ;\n     break;}\n case 611:\n-#line 2957 \"parse.y\"\n+#line 2961 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 612:\n-#line 2962 \"parse.y\"\n+#line 2966 \"parse.y\"\n {\n \t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype);\n@@ -6840,26 +6844,26 @@ case 612:\n \t\t;\n     break;}\n case 613:\n-#line 2975 \"parse.y\"\n+#line 2979 \"parse.y\"\n { yyval.ttype = TREE_TYPE (yyvsp[0].ttype); ;\n     break;}\n case 614:\n-#line 2977 \"parse.y\"\n+#line 2981 \"parse.y\"\n { yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 615:\n-#line 2979 \"parse.y\"\n+#line 2983 \"parse.y\"\n { yyval.ttype = make_typename_type (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 616:\n-#line 2984 \"parse.y\"\n+#line 2988 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", yyvsp[0].ttype);\n \t\t;\n     break;}\n case 617:\n-#line 2989 \"parse.y\"\n+#line 2993 \"parse.y\"\n {\n \t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype);\n@@ -6874,15 +6878,15 @@ case 617:\n \t\t;\n     break;}\n case 618:\n-#line 3002 \"parse.y\"\n+#line 3006 \"parse.y\"\n { got_scope = yyval.ttype = make_typename_type (yyvsp[-2].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 619:\n-#line 3004 \"parse.y\"\n+#line 3008 \"parse.y\"\n { got_scope = yyval.ttype = make_typename_type (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 620:\n-#line 3009 \"parse.y\"\n+#line 3013 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) != IDENTIFIER_NODE)\n \t\t    yyvsp[-1].ttype = lastiddecl;\n@@ -6894,31 +6898,31 @@ case 620:\n \t\t;\n     break;}\n case 621:\n-#line 3019 \"parse.y\"\n+#line 3023 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) != IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype = complete_type (TREE_TYPE (yyval.ttype));\n \t\t;\n     break;}\n case 622:\n-#line 3025 \"parse.y\"\n+#line 3029 \"parse.y\"\n { got_scope = yyval.ttype = complete_type (TREE_TYPE (yyval.ttype)); ;\n     break;}\n case 625:\n-#line 3029 \"parse.y\"\n+#line 3033 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyval.ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype;\n \t\t;\n     break;}\n case 626:\n-#line 3038 \"parse.y\"\n+#line 3042 \"parse.y\"\n { yyval.ttype = build_min_nt (TEMPLATE_ID_EXPR, yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 627:\n-#line 3043 \"parse.y\"\n+#line 3047 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = IDENTIFIER_GLOBAL_VALUE (yyvsp[0].ttype);\n@@ -6928,148 +6932,148 @@ case 627:\n \t\t;\n     break;}\n case 629:\n-#line 3052 \"parse.y\"\n+#line 3056 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 630:\n-#line 3057 \"parse.y\"\n+#line 3061 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 631:\n-#line 3059 \"parse.y\"\n+#line 3063 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; got_scope = NULL_TREE; ;\n     break;}\n case 632:\n-#line 3066 \"parse.y\"\n+#line 3070 \"parse.y\"\n { got_scope = void_type_node; ;\n     break;}\n case 633:\n-#line 3072 \"parse.y\"\n+#line 3076 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 634:\n-#line 3074 \"parse.y\"\n+#line 3078 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE); ;\n     break;}\n case 635:\n-#line 3076 \"parse.y\"\n+#line 3080 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 636:\n-#line 3078 \"parse.y\"\n+#line 3082 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[0].ttype, NULL_TREE); ;\n     break;}\n case 637:\n-#line 3080 \"parse.y\"\n+#line 3084 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, arg);\n \t\t;\n     break;}\n case 638:\n-#line 3084 \"parse.y\"\n+#line 3088 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 640:\n-#line 3093 \"parse.y\"\n+#line 3097 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 641:\n-#line 3095 \"parse.y\"\n+#line 3099 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 642:\n-#line 3101 \"parse.y\"\n+#line 3105 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 643:\n-#line 3103 \"parse.y\"\n+#line 3107 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 644:\n-#line 3105 \"parse.y\"\n+#line 3109 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[0].ftype.t, NULL_TREE); ;\n     break;}\n case 645:\n-#line 3107 \"parse.y\"\n+#line 3111 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, NULL_TREE); ;\n     break;}\n case 646:\n-#line 3109 \"parse.y\"\n+#line 3113 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 647:\n-#line 3111 \"parse.y\"\n+#line 3115 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 648:\n-#line 3113 \"parse.y\"\n+#line 3117 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[0].ftype.t, NULL_TREE); ;\n     break;}\n case 649:\n-#line 3115 \"parse.y\"\n+#line 3119 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, NULL_TREE); ;\n     break;}\n case 650:\n-#line 3117 \"parse.y\"\n+#line 3121 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, arg);\n \t\t;\n     break;}\n case 651:\n-#line 3121 \"parse.y\"\n+#line 3125 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 653:\n-#line 3130 \"parse.y\"\n+#line 3134 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 655:\n-#line 3134 \"parse.y\"\n+#line 3138 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 656:\n-#line 3136 \"parse.y\"\n+#line 3140 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, empty_parms (), yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 657:\n-#line 3138 \"parse.y\"\n+#line 3142 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 658:\n-#line 3140 \"parse.y\"\n+#line 3144 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 659:\n-#line 3142 \"parse.y\"\n+#line 3146 \"parse.y\"\n { yyval.ttype = make_call_declarator (NULL_TREE, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 660:\n-#line 3144 \"parse.y\"\n+#line 3148 \"parse.y\"\n { set_quals_and_spec (yyval.ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 661:\n-#line 3146 \"parse.y\"\n+#line 3150 \"parse.y\"\n { set_quals_and_spec (yyval.ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 662:\n-#line 3148 \"parse.y\"\n+#line 3152 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 663:\n-#line 3150 \"parse.y\"\n+#line 3154 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, NULL_TREE); ;\n     break;}\n case 670:\n-#line 3173 \"parse.y\"\n+#line 3177 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids label declarations\"); ;\n     break;}\n case 673:\n-#line 3184 \"parse.y\"\n+#line 3188 \"parse.y\"\n { tree link;\n \t\t  for (link = yyvsp[-1].ttype; link; link = TREE_CHAIN (link))\n \t\t    {\n@@ -7080,219 +7084,219 @@ case 673:\n \t\t;\n     break;}\n case 674:\n-#line 3198 \"parse.y\"\n+#line 3202 \"parse.y\"\n {;\n     break;}\n case 676:\n-#line 3204 \"parse.y\"\n+#line 3208 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 677:\n-#line 3206 \"parse.y\"\n+#line 3210 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 678:\n-#line 3211 \"parse.y\"\n+#line 3215 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_if_stmt ();\n \t\t  cond_stmt_keyword = \"if\";\n \t\t;\n     break;}\n case 679:\n-#line 3216 \"parse.y\"\n+#line 3220 \"parse.y\"\n { finish_if_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 680:\n-#line 3218 \"parse.y\"\n+#line 3222 \"parse.y\"\n { yyval.ttype = finish_then_clause (yyvsp[-3].ttype); ;\n     break;}\n case 682:\n-#line 3223 \"parse.y\"\n+#line 3227 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 683:\n-#line 3225 \"parse.y\"\n+#line 3229 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 684:\n-#line 3230 \"parse.y\"\n+#line 3234 \"parse.y\"\n {;\n     break;}\n case 686:\n-#line 3236 \"parse.y\"\n+#line 3240 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 687:\n-#line 3238 \"parse.y\"\n+#line 3242 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 688:\n-#line 3240 \"parse.y\"\n+#line 3244 \"parse.y\"\n { begin_else_clause (); ;\n     break;}\n case 689:\n-#line 3242 \"parse.y\"\n+#line 3246 \"parse.y\"\n { \n \t\t  finish_else_clause (yyvsp[-3].ttype); \n \t\t  finish_if_stmt ();\n \t\t;\n     break;}\n case 690:\n-#line 3247 \"parse.y\"\n+#line 3251 \"parse.y\"\n { finish_if_stmt (); ;\n     break;}\n case 691:\n-#line 3249 \"parse.y\"\n+#line 3253 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_while_stmt ();\n \t\t  cond_stmt_keyword = \"while\";\n \t\t;\n     break;}\n case 692:\n-#line 3254 \"parse.y\"\n+#line 3258 \"parse.y\"\n { finish_while_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 693:\n-#line 3256 \"parse.y\"\n+#line 3260 \"parse.y\"\n { finish_while_stmt (yyvsp[-3].ttype); ;\n     break;}\n case 694:\n-#line 3258 \"parse.y\"\n+#line 3262 \"parse.y\"\n { yyval.ttype = begin_do_stmt (); ;\n     break;}\n case 695:\n-#line 3260 \"parse.y\"\n+#line 3264 \"parse.y\"\n {\n \t\t  finish_do_body (yyvsp[-2].ttype);\n \t\t  cond_stmt_keyword = \"do\";\n \t\t;\n     break;}\n case 696:\n-#line 3265 \"parse.y\"\n+#line 3269 \"parse.y\"\n { finish_do_stmt (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 697:\n-#line 3267 \"parse.y\"\n+#line 3271 \"parse.y\"\n { yyval.ttype = begin_for_stmt (); ;\n     break;}\n case 698:\n-#line 3269 \"parse.y\"\n+#line 3273 \"parse.y\"\n { finish_for_init_stmt (yyvsp[-2].ttype); ;\n     break;}\n case 699:\n-#line 3271 \"parse.y\"\n+#line 3275 \"parse.y\"\n { finish_for_cond (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 700:\n-#line 3273 \"parse.y\"\n+#line 3277 \"parse.y\"\n { finish_for_expr (yyvsp[-1].ttype, yyvsp[-8].ttype); ;\n     break;}\n case 701:\n-#line 3275 \"parse.y\"\n+#line 3279 \"parse.y\"\n { finish_for_stmt (yyvsp[-3].ttype, yyvsp[-10].ttype); ;\n     break;}\n case 702:\n-#line 3277 \"parse.y\"\n+#line 3281 \"parse.y\"\n { begin_switch_stmt (); ;\n     break;}\n case 703:\n-#line 3279 \"parse.y\"\n+#line 3283 \"parse.y\"\n { yyval.ttype = finish_switch_cond (yyvsp[-1].ttype); ;\n     break;}\n case 704:\n-#line 3281 \"parse.y\"\n+#line 3285 \"parse.y\"\n { finish_switch_stmt (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 705:\n-#line 3283 \"parse.y\"\n+#line 3287 \"parse.y\"\n { finish_case_label (yyvsp[-1].ttype, NULL_TREE); ;\n     break;}\n case 707:\n-#line 3286 \"parse.y\"\n+#line 3290 \"parse.y\"\n { finish_case_label (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 709:\n-#line 3289 \"parse.y\"\n+#line 3293 \"parse.y\"\n { finish_case_label (NULL_TREE, NULL_TREE); ;\n     break;}\n case 711:\n-#line 3292 \"parse.y\"\n+#line 3296 \"parse.y\"\n { finish_break_stmt (); ;\n     break;}\n case 712:\n-#line 3294 \"parse.y\"\n+#line 3298 \"parse.y\"\n { finish_continue_stmt (); ;\n     break;}\n case 713:\n-#line 3296 \"parse.y\"\n+#line 3300 \"parse.y\"\n { finish_return_stmt (NULL_TREE); ;\n     break;}\n case 714:\n-#line 3298 \"parse.y\"\n+#line 3302 \"parse.y\"\n { finish_return_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 715:\n-#line 3300 \"parse.y\"\n+#line 3304 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 716:\n-#line 3306 \"parse.y\"\n+#line 3310 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 717:\n-#line 3312 \"parse.y\"\n+#line 3316 \"parse.y\"\n { finish_asm_stmt (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE); ;\n     break;}\n case 718:\n-#line 3316 \"parse.y\"\n+#line 3320 \"parse.y\"\n { finish_asm_stmt (yyvsp[-10].ttype, yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype); ;\n     break;}\n case 719:\n-#line 3318 \"parse.y\"\n+#line 3322 \"parse.y\"\n { \n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n \t\t  finish_goto_stmt (yyvsp[-1].ttype);\n \t\t;\n     break;}\n case 720:\n-#line 3324 \"parse.y\"\n+#line 3328 \"parse.y\"\n { finish_goto_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 721:\n-#line 3326 \"parse.y\"\n+#line 3330 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 722:\n-#line 3328 \"parse.y\"\n+#line 3332 \"parse.y\"\n { error (\"label must be followed by statement\");\n \t\t  yyungetc ('}', 0);\n \t\t  finish_stmt (); ;\n     break;}\n case 723:\n-#line 3332 \"parse.y\"\n+#line 3336 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 725:\n-#line 3338 \"parse.y\"\n+#line 3342 \"parse.y\"\n {\n \t\t  if (! current_function_parms_stored)\n \t\t    store_parm_decls ();\n \t\t  expand_start_early_try_stmts ();\n \t\t;\n     break;}\n case 726:\n-#line 3344 \"parse.y\"\n+#line 3348 \"parse.y\"\n { expand_start_all_catch (); ;\n     break;}\n case 727:\n-#line 3346 \"parse.y\"\n+#line 3350 \"parse.y\"\n {\n \t\t  int nested = (hack_decl_function_context\n \t\t\t\t(current_function_decl) != NULL_TREE);\n@@ -7301,41 +7305,41 @@ case 727:\n \t\t;\n     break;}\n case 728:\n-#line 3356 \"parse.y\"\n+#line 3360 \"parse.y\"\n { yyval.ttype = begin_try_block (); ;\n     break;}\n case 729:\n-#line 3358 \"parse.y\"\n+#line 3362 \"parse.y\"\n { finish_try_block (yyvsp[-1].ttype); ;\n     break;}\n case 730:\n-#line 3360 \"parse.y\"\n+#line 3364 \"parse.y\"\n { finish_handler_sequence (yyvsp[-3].ttype); ;\n     break;}\n case 733:\n-#line 3370 \"parse.y\"\n+#line 3374 \"parse.y\"\n { yyval.ttype = begin_handler(); ;\n     break;}\n case 734:\n-#line 3372 \"parse.y\"\n+#line 3376 \"parse.y\"\n { finish_handler_parms (yyvsp[-1].ttype); ;\n     break;}\n case 735:\n-#line 3374 \"parse.y\"\n+#line 3378 \"parse.y\"\n { finish_handler (yyvsp[-3].ttype); ;\n     break;}\n case 738:\n-#line 3384 \"parse.y\"\n+#line 3388 \"parse.y\"\n { expand_start_catch_block (NULL_TREE, NULL_TREE); ;\n     break;}\n case 739:\n-#line 3400 \"parse.y\"\n+#line 3404 \"parse.y\"\n { check_for_new_type (\"inside exception declarations\", yyvsp[-1].ftype);\n \t\t  expand_start_catch_block (TREE_PURPOSE (yyvsp[-1].ftype.t),\n \t\t\t\t\t    TREE_VALUE (yyvsp[-1].ftype.t)); ;\n     break;}\n case 740:\n-#line 3407 \"parse.y\"\n+#line 3411 \"parse.y\"\n { tree label;\n \t\tdo_label:\n \t\t  label = define_label (input_filename, lineno, yyvsp[-1].ttype);\n@@ -7344,129 +7348,129 @@ case 740:\n \t\t;\n     break;}\n case 741:\n-#line 3414 \"parse.y\"\n+#line 3418 \"parse.y\"\n { goto do_label; ;\n     break;}\n case 742:\n-#line 3416 \"parse.y\"\n+#line 3420 \"parse.y\"\n { goto do_label; ;\n     break;}\n case 743:\n-#line 3418 \"parse.y\"\n+#line 3422 \"parse.y\"\n { goto do_label; ;\n     break;}\n case 744:\n-#line 3423 \"parse.y\"\n+#line 3427 \"parse.y\"\n { if (yyvsp[-1].ttype) cplus_expand_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 746:\n-#line 3426 \"parse.y\"\n+#line 3430 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 747:\n-#line 3435 \"parse.y\"\n+#line 3439 \"parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 748:\n-#line 3438 \"parse.y\"\n+#line 3442 \"parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 749:\n-#line 3443 \"parse.y\"\n+#line 3447 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 751:\n-#line 3446 \"parse.y\"\n+#line 3450 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 752:\n-#line 3453 \"parse.y\"\n+#line 3457 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 755:\n-#line 3460 \"parse.y\"\n+#line 3464 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 756:\n-#line 3465 \"parse.y\"\n+#line 3469 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 757:\n-#line 3470 \"parse.y\"\n+#line 3474 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 758:\n-#line 3472 \"parse.y\"\n+#line 3476 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 759:\n-#line 3483 \"parse.y\"\n+#line 3487 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 761:\n-#line 3488 \"parse.y\"\n+#line 3492 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ftype.t, void_list_node);\n \t\t  TREE_PARMLIST (yyval.ttype) = 1; \n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 762:\n-#line 3497 \"parse.y\"\n+#line 3501 \"parse.y\"\n {\n \t\t  yyval.ttype = chainon (yyval.ttype, void_list_node);\n \t\t  TREE_PARMLIST (yyval.ttype) = 1;\n \t\t;\n     break;}\n case 763:\n-#line 3502 \"parse.y\"\n+#line 3506 \"parse.y\"\n {\n \t\t  TREE_PARMLIST (yyval.ttype) = 1;\n \t\t;\n     break;}\n case 764:\n-#line 3507 \"parse.y\"\n+#line 3511 \"parse.y\"\n {\n \t\t  TREE_PARMLIST (yyval.ttype) = 1;\n \t\t;\n     break;}\n case 765:\n-#line 3511 \"parse.y\"\n+#line 3515 \"parse.y\"\n {\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); \n \t\t  TREE_PARMLIST (yyval.ttype) = 1;\n \t\t;\n     break;}\n case 766:\n-#line 3516 \"parse.y\"\n+#line 3520 \"parse.y\"\n {\n \t\t  yyval.ttype = NULL_TREE;\n \t\t;\n     break;}\n case 767:\n-#line 3520 \"parse.y\"\n+#line 3524 \"parse.y\"\n {\n \t\t  TREE_PARMLIST (yyval.ttype) = 1;\n \t\t;\n     break;}\n case 768:\n-#line 3524 \"parse.y\"\n+#line 3528 \"parse.y\"\n {\n \t\t  TREE_PARMLIST (yyval.ttype) = 1;\n \t\t;\n     break;}\n case 769:\n-#line 3528 \"parse.y\"\n+#line 3532 \"parse.y\"\n {\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t);\n \t\t  TREE_PARMLIST (yyval.ttype) = 1;\n \t\t;\n     break;}\n case 770:\n-#line 3533 \"parse.y\"\n+#line 3537 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7479,7 +7483,7 @@ case 770:\n \t\t;\n     break;}\n case 771:\n-#line 3544 \"parse.y\"\n+#line 3548 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7492,98 +7496,98 @@ case 771:\n \t\t;\n     break;}\n case 772:\n-#line 3559 \"parse.y\"\n+#line 3563 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 773:\n-#line 3561 \"parse.y\"\n+#line 3565 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 776:\n-#line 3572 \"parse.y\"\n+#line 3576 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 777:\n-#line 3575 \"parse.y\"\n+#line 3579 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 778:\n-#line 3578 \"parse.y\"\n+#line 3582 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 779:\n-#line 3581 \"parse.y\"\n+#line 3585 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 780:\n-#line 3583 \"parse.y\"\n+#line 3587 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 782:\n-#line 3589 \"parse.y\"\n+#line 3593 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 783:\n-#line 3599 \"parse.y\"\n+#line 3603 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 784:\n-#line 3603 \"parse.y\"\n+#line 3607 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 785:\n-#line 3606 \"parse.y\"\n+#line 3610 \"parse.y\"\n { yyval.ftype.t = build_tree_list (get_decl_list (yyvsp[-1].ftype.t), yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 786:\n-#line 3609 \"parse.y\"\n+#line 3613 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 787:\n-#line 3613 \"parse.y\"\n+#line 3617 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 788:\n-#line 3617 \"parse.y\"\n+#line 3621 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 789:\n-#line 3624 \"parse.y\"\n+#line 3628 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 790:\n-#line 3627 \"parse.y\"\n+#line 3631 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 793:\n-#line 3638 \"parse.y\"\n+#line 3642 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 794:\n-#line 3643 \"parse.y\"\n+#line 3647 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 795:\n-#line 3648 \"parse.y\"\n+#line 3652 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -7594,193 +7598,193 @@ case 795:\n \t\t;\n     break;}\n case 796:\n-#line 3660 \"parse.y\"\n+#line 3664 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 797:\n-#line 3662 \"parse.y\"\n+#line 3666 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 798:\n-#line 3664 \"parse.y\"\n+#line 3668 \"parse.y\"\n { yyval.ttype = build_decl_list (NULL_TREE, NULL_TREE); ;\n     break;}\n case 799:\n-#line 3669 \"parse.y\"\n+#line 3673 \"parse.y\"\n { yyval.ttype = build_decl_list (NULL_TREE, groktypename(yyvsp[0].ftype.t)); ;\n     break;}\n case 801:\n-#line 3675 \"parse.y\"\n+#line 3679 \"parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[0].ttype) = yyval.ttype;\n \t\t  yyval.ttype = yyvsp[0].ttype;\n \t\t;\n     break;}\n case 802:\n-#line 3683 \"parse.y\"\n+#line 3687 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 803:\n-#line 3685 \"parse.y\"\n+#line 3689 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 804:\n-#line 3687 \"parse.y\"\n+#line 3691 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 805:\n-#line 3689 \"parse.y\"\n+#line 3693 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 806:\n-#line 3696 \"parse.y\"\n+#line 3700 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 807:\n-#line 3701 \"parse.y\"\n+#line 3705 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 808:\n-#line 3703 \"parse.y\"\n+#line 3707 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 809:\n-#line 3705 \"parse.y\"\n+#line 3709 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 810:\n-#line 3707 \"parse.y\"\n+#line 3711 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 811:\n-#line 3709 \"parse.y\"\n+#line 3713 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 812:\n-#line 3711 \"parse.y\"\n+#line 3715 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 813:\n-#line 3713 \"parse.y\"\n+#line 3717 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 814:\n-#line 3715 \"parse.y\"\n+#line 3719 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 815:\n-#line 3717 \"parse.y\"\n+#line 3721 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 816:\n-#line 3719 \"parse.y\"\n+#line 3723 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 817:\n-#line 3721 \"parse.y\"\n+#line 3725 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 818:\n-#line 3723 \"parse.y\"\n+#line 3727 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 819:\n-#line 3725 \"parse.y\"\n+#line 3729 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 820:\n-#line 3727 \"parse.y\"\n+#line 3731 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 821:\n-#line 3729 \"parse.y\"\n+#line 3733 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 822:\n-#line 3731 \"parse.y\"\n+#line 3735 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 823:\n-#line 3733 \"parse.y\"\n+#line 3737 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 824:\n-#line 3735 \"parse.y\"\n+#line 3739 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 825:\n-#line 3737 \"parse.y\"\n+#line 3741 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 826:\n-#line 3739 \"parse.y\"\n+#line 3743 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 827:\n-#line 3741 \"parse.y\"\n+#line 3745 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 828:\n-#line 3743 \"parse.y\"\n+#line 3747 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 829:\n-#line 3745 \"parse.y\"\n+#line 3749 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 830:\n-#line 3747 \"parse.y\"\n+#line 3751 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 831:\n-#line 3749 \"parse.y\"\n+#line 3753 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 832:\n-#line 3751 \"parse.y\"\n+#line 3755 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 833:\n-#line 3753 \"parse.y\"\n+#line 3757 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 834:\n-#line 3755 \"parse.y\"\n+#line 3759 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 835:\n-#line 3757 \"parse.y\"\n+#line 3761 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 836:\n-#line 3759 \"parse.y\"\n+#line 3763 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 837:\n-#line 3761 \"parse.y\"\n+#line 3765 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 838:\n-#line 3763 \"parse.y\"\n+#line 3767 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 839:\n-#line 3765 \"parse.y\"\n+#line 3769 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 840:\n-#line 3768 \"parse.y\"\n+#line 3772 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 841:\n-#line 3770 \"parse.y\"\n+#line 3774 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 498 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -7976,7 +7980,7 @@ case 841:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 3773 \"parse.y\"\n+#line 3777 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "12b59b10036dad7ffe6a96432812f711aaca364c", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -2498,8 +2498,12 @@ component_decl:\n                 { $$ = finish_member_template_decl ($1, $2); }\n \t| template_header typed_declspecs ';'\n                 {\n-\t\t  shadow_tag ($2.t);\n \t\t  note_list_got_semicolon ($2.t);\n+\t\t  grok_x_components ($2.t, NULL_TREE); \n+\t\t  if (TYPE_CONTEXT (TREE_VALUE ($2.t)) != current_class_type)\n+\t\t    /* The component was in fact a friend\n+\t\t       declaration.  */\n+\t\t    $2.t = NULL_TREE;\n \t\t  $$ = finish_member_template_decl ($1, $2.t);\n \t\t}\n \t;"}, {"sha": "d1a24464fc9cadb5bfb7eec408addd89a63c6b29", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 144, "deletions": 38, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -75,7 +75,6 @@ static int push_tinst_level PROTO((tree));\n static tree classtype_mangled_name PROTO((tree));\n static char *mangle_class_name_for_template PROTO((char *, tree, tree, tree));\n static tree tsubst_expr_values PROTO((tree, tree));\n-static int comp_template_args PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n@@ -100,6 +99,7 @@ static tree reduce_template_parm_level PROTO((tree, tree, int));\n static tree build_template_decl PROTO((tree, tree));\n static int mark_template_parm PROTO((tree, void *));\n static tree tsubst_friend_function PROTO((tree, tree));\n+static tree tsubst_friend_class PROTO((tree, tree));\n static tree get_bindings_real PROTO((tree, tree, tree, int));\n static int template_decl_level PROTO((tree));\n static tree maybe_get_template_decl_from_type_decl PROTO((tree));\n@@ -489,13 +489,26 @@ add_to_template_args (args, extra_args)\n void\n begin_template_parm_list ()\n {\n+  /* We use a non-tag-transparent scope here, which causes pushtag to\n+     put tags in this scope, rather than in the enclosing class or\n+     namespace scope.  This is the right thing, since we want\n+     TEMPLATE_DECLS, and not TYPE_DECLS for template classes.  For a\n+     global template class, push_template_decl handles putting the\n+     TEMPLATE_DECL into top-level scope.  For a nested template class,\n+     e.g.:\n+\n+       template <class T> struct S1 {\n+         template <class T> struct S2 {}; \n+       };\n+\n+     pushtag contains special code to call pushdecl_with_scope on the\n+     TEMPLATE_DECL for S2.  */\n   pushlevel (0);\n   declare_pseudo_global_level ();\n   ++processing_template_decl;\n   note_template_header (0);\n }\n \n-\n /* We've just seen template <>. */\n \n void\n@@ -504,7 +517,6 @@ begin_specialization ()\n   note_template_header (1);\n }\n \n-\n /* Called at then end of processing a declaration preceeded by\n    template<>.  */\n \n@@ -514,7 +526,6 @@ end_specialization ()\n   reset_specialization ();\n }\n \n-\n /* Any template <>'s that we have seen thus far are not referring to a\n    function specialization. */\n \n@@ -525,7 +536,6 @@ reset_specialization ()\n   template_header_count = 0;\n }\n \n-\n /* We've just seen a template header.  If SPECIALIZATION is non-zero,\n    it was of the form template <>.  */\n \n@@ -537,7 +547,6 @@ note_template_header (specialization)\n   template_header_count++;\n }\n \n-\n /* We're beginning an explicit instantiation.  */\n \n void\n@@ -554,7 +563,6 @@ end_explicit_instantiation ()\n   --processing_explicit_instantiation;\n }\n \n-\n /* Retrieve the specialization (in the sense of [temp.spec] - a\n    specialization is either an instantiation or an explicit\n    specialization) of TMPL for the given template ARGS.  If there is\n@@ -580,7 +588,38 @@ retrieve_specialization (tmpl, args)\n   return NULL_TREE;\n }\n \n+/* Returns non-zero iff DECL is a specialization of TMPL.  */\n+\n+int\n+is_specialization_of (decl, tmpl)\n+     tree decl;\n+     tree tmpl;\n+{\n+  tree t;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      for (t = decl; \n+\t   t != NULL_TREE;\n+\t   t = DECL_TEMPLATE_INFO (t) ? DECL_TI_TEMPLATE (t) : NULL_TREE)\n+\tif (t == tmpl)\n+\t  return 1;\n+    }\n+  else \n+    {\n+      my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 0);\n+\n+      for (t = TREE_TYPE (decl);\n+\t   t != NULL_TREE;\n+\t   t = CLASSTYPE_USE_TEMPLATE (t)\n+\t     ? TREE_TYPE (CLASSTYPE_TI_TEMPLATE (t)) : NULL_TREE)\n+\tif (comptypes (TYPE_MAIN_VARIANT (t), \n+\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (tmpl)), 1))\n+\t  return 1;\n+    }  \n \n+  return 0;\n+}\n \n /* Register the specialization SPEC as a specialization of TMPL with\n    the indicated ARGS.  */\n@@ -649,7 +688,6 @@ register_specialization (spec, tmpl, args)\n      = perm_tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n }\n \n-\n /* Print the list of candidate FNS in an error message.  */\n \n static void\n@@ -786,8 +824,7 @@ determine_specialization (template_id, decl, targs_out,\n   *targs_out = TREE_PURPOSE (templates);\n   return TREE_VALUE (templates);\n }\n-\n-\t\n+      \n /* Check to see if the function just declared, as indicated in\n    DECLARATOR, and in DECL, is a specialization of a function\n    template.  We may also discover that the declaration is an explicit\n@@ -1160,7 +1197,6 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n   return decl;\n }\n \n-\n /* Returns 1 iff PARMS1 and PARMS2 are identical sets of template\n    parameters.  These are represented in the same format used for\n    DECL_TEMPLATE_PARMS.  */\n@@ -1213,7 +1249,6 @@ int comp_template_parms (parms1, parms2)\n   return 1;\n }\n \n-\n /* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,\n    ORIG_LEVEL, DECL, and TYPE.  */\n \n@@ -1235,7 +1270,6 @@ build_template_parm_index (index, level, orig_level, decl, type)\n   return t;\n }\n \n-\n /* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose\n    TEMPLATE_PARM_LEVEL has been decreased by LEVELS.  If such a\n    TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a\n@@ -1520,19 +1554,22 @@ mark_template_parm (t, data)\n /* Creates a TEMPLATE_DECL for the indicated DECL using the template\n    parameters given by current_template_args, or reuses a\n    previously existing one, if appropriate.  Returns the DECL, or an\n-   equivalent one, if it is replaced via a call to duplicate_decls.  */\n+   equivalent one, if it is replaced via a call to duplicate_decls.  \n+\n+   If IS_FRIEND is non-zero, DECL is a friend declaration.  */\n \n tree\n-push_template_decl (decl)\n+push_template_decl_real (decl, is_friend)\n      tree decl;\n+     int is_friend;\n {\n   tree tmpl;\n   tree args;\n   tree info;\n   tree ctx;\n   int primary;\n-  int is_friend = (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t   && DECL_FRIEND_P (decl));\n+\n+  is_friend |= (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl));\n \n   if (is_friend)\n     /* For a friend, we want the context of the friend function, not\n@@ -1550,16 +1587,17 @@ push_template_decl (decl)\n   /* For determining whether this is a primary template or not, we're really\n      interested in the lexical context, not the true context.  */\n   if (is_friend)\n-    info = DECL_CLASS_CONTEXT (decl);\n+    /* For a TYPE_DECL, there is no DECL_CLASS_CONTEXT.  */\n+    info = TREE_CODE (decl) == FUNCTION_DECL \n+      ? DECL_CLASS_CONTEXT (decl) : current_class_type;\n   else\n     info = ctx;\n \n   if (info && TREE_CODE (info) == FUNCTION_DECL)\n     primary = 0;\n-  else if (! info\n-\t   || (TYPE_BEING_DEFINED (info) && template_header_count\n-\t       && ! processing_specialization)\n-\t   || (template_header_count > template_class_depth (info)))\n+  /* Note that template_class_depth returns 0 if given NULL_TREE, so\n+     this next line works even when we are at global scope.  */\n+  else if (processing_template_decl > template_class_depth (info))\n     primary = 1;\n   else\n     primary = 0;\n@@ -1775,14 +1813,14 @@ push_template_decl (decl)\n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n   TREE_TYPE (tmpl) = TREE_TYPE (decl);\n \n-  if (! ctx && primary)\n-    /* The check of PRIMARY ensures that we do not try to push a\n-       global template friend declared in a template class; such a\n-       thing may well depend on the template parameters of the class.  */\n+  if (! ctx && !(is_friend && template_class_depth (info) > 0))\n+    /* Note that we do not try to push a global template friend\n+       declared in a template class; such a thing may well depend on\n+       the template parameters of the class.  */\n     tmpl = pushdecl_top_level (tmpl);\n \n   if (primary)\n-    TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (tmpl)) = tmpl;\n+    DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n \n   info = perm_tree_cons (tmpl, args, NULL_TREE);\n \n@@ -1800,18 +1838,26 @@ push_template_decl (decl)\n   return DECL_TEMPLATE_RESULT (tmpl);\n }\n \n-/* Called when a class template TYPE is redeclared, e.g.:\n+tree\n+push_template_decl (decl)\n+     tree decl;\n+{\n+  return push_template_decl_real (decl, 0);\n+}\n+\n+/* Called when a class template TYPE is redeclared with the indicated\n+   template PARMS, e.g.:\n \n      template <class T> struct S;\n      template <class T> struct S {};  */\n \n void \n-redeclare_class_template (type)\n+redeclare_class_template (type, parms)\n      tree type;\n+     tree parms;\n {\n   tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n-  tree tmpl_parms = DECL_INNERMOST_TEMPLATE_PARMS (tmpl);\n-  tree parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n+  tree tmpl_parms;\n   int i;\n \n   if (!PRIMARY_TEMPLATE_P (tmpl))\n@@ -1820,6 +1866,9 @@ redeclare_class_template (type)\n        type.  */\n     return;\n \n+  parms = INNERMOST_TEMPLATE_PARMS (parms);\n+  tmpl_parms = DECL_INNERMOST_TEMPLATE_PARMS (tmpl);\n+\n   if (TREE_VEC_LENGTH (parms) != TREE_VEC_LENGTH (tmpl_parms))\n     {\n       cp_error_at (\"previous declaration `%D'\", tmpl);\n@@ -2484,7 +2533,7 @@ coerce_template_parms (parms, arglist, in_decl,\n /* Renturns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n    of template arguments.  Returns 0 otherwise.  */\n \n-static int\n+int\n comp_template_args (oldargs, newargs)\n      tree oldargs, newargs;\n {\n@@ -3251,7 +3300,6 @@ tinst_for_decl ()\n   return p;\n }\n \n-\n /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the\n    vector of template arguments, as for tsubst.\n \n@@ -3340,6 +3388,51 @@ tsubst_friend_function (decl, args)\n   return new_friend;\n }\n \n+/* FRIEND_TYPE is a friend RECORD_TYPE or UNION_TYPE.  ARGS is the\n+   vector of template arguments, as for tsubst.\n+\n+   Returns an appropriate tsbust'd friend type.  */\n+\n+static tree\n+tsubst_friend_class (friend_type, args)\n+     tree friend_type;\n+     tree args;\n+{\n+  tree tmpl = \n+    lookup_name (DECL_NAME (CLASSTYPE_TI_TEMPLATE (friend_type)), 1); \n+\n+  tmpl = maybe_get_template_decl_from_type_decl (tmpl);\n+\n+  if (tmpl != NULL_TREE && DECL_CLASS_TEMPLATE_P (tmpl))\n+    {\n+      /* The friend template has already been declared.  Just\n+\t check to see that the declarations match.  */\n+      redeclare_class_template (TREE_TYPE (tmpl),\n+\t\t\t\tDECL_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE \n+\t\t\t\t\t\t     (friend_type)));\n+      friend_type = TREE_TYPE (tmpl);\n+    }\n+  else\n+    {\n+      /* The friend template has not already been declared.  In this\n+\t case, the instantiation of the template class will cause the\n+\t injection of this template into the global scope.  */\n+      tmpl = tsubst (CLASSTYPE_TI_TEMPLATE (friend_type), args, NULL_TREE);\n+\n+      /* The new TMPL is not an instantiation of anything, so we\n+ \t forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for\n+\t the new type because that is supposed to be the corresponding\n+\t template decl, i.e., TMPL.  */\n+      DECL_USE_TEMPLATE (tmpl) = 0;\n+      DECL_TEMPLATE_INFO (tmpl) = NULL_TREE;\n+      CLASSTYPE_USE_TEMPLATE (TREE_TYPE (tmpl)) = 0;\n+\n+      /* Inject this template into the global scope.  */\n+      friend_type = TREE_TYPE (pushdecl_top_level (tmpl));\n+    }\n+\n+  return friend_type;\n+}\n \n tree\n instantiate_class_template (type)\n@@ -3604,12 +3697,25 @@ instantiate_class_template (type)\n \t}\n     }\n \n-  t = CLASSTYPE_FRIEND_CLASSES (type)\n-    = tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), args, NULL_TREE);\n+  for (t = CLASSTYPE_FRIEND_CLASSES (pattern);\n+       t != NULL_TREE;\n+       t = TREE_CHAIN (t))\n+    {\n+      tree friend_type = TREE_VALUE (t);\n+\n+      if (!CLASSTYPE_IS_TEMPLATE (friend_type))\n+\t/* The call to xref_tag_from_type does injection for friend\n+\t   classes.  */\n+\tfriend_type = \n+\t  xref_tag_from_type (tsubst (friend_type, args, NULL_TREE),\n+\t\t\t      NULL_TREE, 1);\n+      else\n+\tfriend_type = tsubst_friend_class (friend_type, args);\n \n-  /* This does injection for friend classes.  */\n-  for (; t; t = TREE_CHAIN (t))\n-    TREE_VALUE (t) = xref_tag_from_type (TREE_VALUE (t), NULL_TREE, 1);\n+      CLASSTYPE_FRIEND_CLASSES (type) = \n+\ttree_cons (NULL_TREE, friend_type,\n+\t\t   CLASSTYPE_FRIEND_CLASSES (type));\n+    }\n \n   /* This does injection for friend functions. */\n   if (!processing_template_decl)"}, {"sha": "361a559d88474e8a3b5fbd2278adc874699a40c4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -763,26 +763,8 @@ comptypes (type1, type2, strict)\n       if (CLASSTYPE_TEMPLATE_INFO (t1) && CLASSTYPE_TEMPLATE_INFO (t2)\n \t  && (CLASSTYPE_TI_TEMPLATE (t1) == CLASSTYPE_TI_TEMPLATE (t2)\n \t      || TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM))\n-\t{\n-\t  int i = TREE_VEC_LENGTH (CLASSTYPE_TI_ARGS (t1));\n-\t  tree *p1 = &TREE_VEC_ELT (CLASSTYPE_TI_ARGS (t1), 0);\n-\t  tree *p2 = &TREE_VEC_ELT (CLASSTYPE_TI_ARGS (t2), 0);\n-\t\n-\t  while (i--)\n-\t    {\n-\t      if (TREE_CODE_CLASS (TREE_CODE (p1[i])) == 't')\n-\t\t{\n-\t\t  if (! comptypes (p1[i], p2[i], 1))\n-\t\t    return 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (simple_cst_equal (p1[i], p2[i]) <= 0)\n-\t\t    return 0;\n-\t\t}\n-\t    }\n-\t  return 1;\n-\t}\n+\treturn comp_template_args (CLASSTYPE_TI_ARGS (t1),\n+\t\t\t\t   CLASSTYPE_TI_ARGS (t2));\n       if (strict <= 0)\n \tgoto look_hard;\n       return 0;"}, {"sha": "4ed5fcc47a89ea092b8490ce0d7103bda1f58254", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend14.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend14.C?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -0,0 +1,25 @@\n+// Build don't link:\n+\n+template <class U>\n+class S1\n+{\n+  template <class T>\n+  friend class S2;\n+\n+  static int i;\n+};\n+\n+\n+template <class T>\n+class S2\n+{\n+public:\n+  static void f() { S1<T>::i = 3; }\n+};\n+\n+\n+void g()\n+{\n+  S2<double>::f();\n+  S2<long>::f();\n+}"}, {"sha": "8d49f6a2be01bd3afe488ea91f3aa15c8c50d1c6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend15.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend15.C?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -0,0 +1,24 @@\n+// Build don't link:\n+\n+class S1\n+{\n+  template <class T>\n+  friend class S2;\n+\n+  static int i;\n+};\n+\n+\n+template <class T>\n+class S2\n+{\n+public:\n+  static void f() { S1::i = 3; }\n+};\n+\n+\n+void g()\n+{\n+  S2<double>::f();\n+  S2<char>::f();\n+}"}, {"sha": "7f13e5b90b38ff97bb454d0938b210990278bbee", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend16.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend16.C?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -0,0 +1,31 @@\n+// Build don't link:\n+\n+template <class T>\n+class S2\n+{\n+public:\n+  static void f();\n+};\n+\n+\n+template <class U>\n+class S1\n+{\n+  template <class T>\n+  friend class S2;\n+\n+  static int i;\n+};\n+\n+\n+template <class T>\n+void S2<T>::f() \n+{\n+  S1<T>::i = 3;\n+}\n+\n+void g()\n+{\n+  S2<double>::f();\n+  S2<char>::f();\n+}"}, {"sha": "cb12ce8e79332cfa1abd379f61716329b5dbc70f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend17.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend17.C?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -0,0 +1,28 @@\n+// Build don't link:\n+\n+template <class T>\n+class S2\n+{\n+public:\n+  static void f();\n+};\n+\n+class S1\n+{\n+  template <class T>\n+  friend class S2;\n+\n+  static int i;\n+};\n+\n+template <class T>\n+void S2<T>::f() \n+{\n+  S1::i = 3;\n+}\n+\n+void g()\n+{\n+  S2<double>::f();\n+  S2<char>::f();\n+}"}, {"sha": "998e1639fe69e8d47bfc04121d544d8229ac7d4c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend18.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend18.C?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -0,0 +1,26 @@\n+// Build don't link:\n+\n+template <class U>\n+class S1\n+{\n+  template <class T>\n+  friend class S2;\n+\n+  static int i;\n+};\n+\n+\n+template <class T>\n+class S2\n+{\n+public:\n+  static void f() { S1<T>::i = 3; }\n+};\n+\n+\n+void g()\n+{\n+  S2<double>::f();\n+  S2<long>::f();\n+}\n+"}, {"sha": "998e1639fe69e8d47bfc04121d544d8229ac7d4c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend19.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6757edfe655f9b21cdd1dbaddd80b8c5ddc63823/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend19.C?ref=6757edfe655f9b21cdd1dbaddd80b8c5ddc63823", "patch": "@@ -0,0 +1,26 @@\n+// Build don't link:\n+\n+template <class U>\n+class S1\n+{\n+  template <class T>\n+  friend class S2;\n+\n+  static int i;\n+};\n+\n+\n+template <class T>\n+class S2\n+{\n+public:\n+  static void f() { S1<T>::i = 3; }\n+};\n+\n+\n+void g()\n+{\n+  S2<double>::f();\n+  S2<long>::f();\n+}\n+"}]}