{"sha": "dbe13a374e58cda45a1a06df8e2a689bcc24e1da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJlMTNhMzc0ZTU4Y2RhNDVhMWEwNmRmOGUyYTY4OWJjYzI0ZTFkYQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-06-06T10:26:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:26:05Z"}, "message": "exp_ch7.ads, [...] (Expand_Cleanup_Actions): Set Sloc of inserted cleanup code appropriately for GDB use.\n\n2007-04-20  Ed Schonberg  <schonberg@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.ads, exp_ch7.adb (Expand_Cleanup_Actions): Set Sloc of\n\tinserted cleanup code appropriately for GDB use.\n\t(Make_Deep_Proc): Use Make_Handler_For_Ctrl_Operation to create\n\texception handler for Deep_Adjust or Deep_Finalize.\n\t(Make_Handler_For_Ctrl_Operation): New subprogram. When runtime entity\n\tRaise_From_Controlled_Operation is available, use a call to that\n\tsubprogram instead of a plain \"raise Program_Error\" node to raise\n\tProgram_Error if an exception is propagated from an Adjust or Finalize\n\toperation.\n\t(Insert_Actions_In_Scope_Around): If the statement to be wrapped\n\tappears in the optional statement list of a triggering alternative, the\n\tscope actions can be inserted directly there, and not in the list that\n\tincludes the asynchronous select itself.\n\nFrom-SVN: r125400", "tree": {"sha": "a6aef403ba2740ff9427d8dec69a70ef999786d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6aef403ba2740ff9427d8dec69a70ef999786d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbe13a374e58cda45a1a06df8e2a689bcc24e1da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe13a374e58cda45a1a06df8e2a689bcc24e1da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbe13a374e58cda45a1a06df8e2a689bcc24e1da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe13a374e58cda45a1a06df8e2a689bcc24e1da/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7888a6aecc26ae7f7d406e893e0620dfccb1837b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7888a6aecc26ae7f7d406e893e0620dfccb1837b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7888a6aecc26ae7f7d406e893e0620dfccb1837b"}], "stats": {"total": 238, "additions": 155, "deletions": 83}, "files": [{"sha": "6dcfae82809fdd7e770a359a29742f26ae14ecde", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 149, "deletions": 82, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbe13a374e58cda45a1a06df8e2a689bcc24e1da/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbe13a374e58cda45a1a06df8e2a689bcc24e1da/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=dbe13a374e58cda45a1a06df8e2a689bcc24e1da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,6 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n-with Hostparm; use Hostparm;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -58,6 +57,7 @@ with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -90,27 +90,33 @@ package body Exp_Ch7 is\n    --      declaration and the secondary stack deallocation is done in the\n    --      proper enclosing scope (see Wrap_Transient_Declaration for details)\n \n-   --  Note about function returning tagged types: It has been decided to\n-   --  always allocate their result in the secondary stack while it is not\n+   --  Note about functions returning tagged types: It has been decided to\n+   --  always allocate their result in the secondary stack, even though is not\n    --  absolutely mandatory when the tagged type is constrained because the\n    --  caller knows the size of the returned object and thus could allocate the\n-   --  result in the primary stack. But, allocating them always in the\n-   --  secondary stack simplifies many implementation hassles:\n+   --  result in the primary stack. An exception to this is when the function\n+   --  builds its result in place, as is done for functions with inherently\n+   --  limited result types for Ada 2005. In that case, certain callers may\n+   --  pass the address of a constrained object as the target object for the\n+   --  function result.\n \n-   --    - If it is dispatching function call, the computation of the size of\n+   --  By allocating tagged results in the secondary stack a number of\n+   --  implementation difficulties are avoided:\n+\n+   --    - If it is a dispatching function call, the computation of the size of\n    --      the result is possible but complex from the outside.\n \n    --    - If the returned type is controlled, the assignment of the returned\n    --      value to the anonymous object involves an Adjust, and we have no\n-   --      easy way to access the anonymous object created by the back-end\n+   --      easy way to access the anonymous object created by the back end.\n \n    --    - If the returned type is class-wide, this is an unconstrained type\n-   --      anyway\n+   --      anyway.\n \n-   --  Furthermore, the little loss in efficiency which is the result of this\n-   --  decision is not such a big deal because function returning tagged types\n-   --  are not very much used in real life as opposed to functions returning\n-   --  access to a tagged type\n+   --  Furthermore, the small loss in efficiency which is the result of this\n+   --  decision is not such a big deal because functions returning tagged types\n+   --  are not as common in practice compared to functions returning access to\n+   --  a tagged type.\n \n    --------------------------------------------------\n    -- Transient Blocks and Finalization Management --\n@@ -245,8 +251,8 @@ package body Exp_Ch7 is\n    --  controlled components (Has_Controlled_Component flag set). In the first\n    --  case the procedures to call are the user-defined primitive operations\n    --  Initialize/Adjust/Finalize. In the second case, GNAT generates\n-   --  Deep_Initialize, Deep_Adjust and Deep_Finalize that are in charge of\n-   --  calling the former procedures on the controlled components.\n+   --  Deep_Initialize, Deep_Adjust and Deep_Finalize that are in charge\n+   --  of calling the former procedures on the controlled components.\n \n    --  For records with Has_Controlled_Component set, a hidden \"controller\"\n    --  component is inserted. This controller component contains its own\n@@ -255,21 +261,21 @@ package body Exp_Ch7 is\n    --  technique facilitates the management of objects whose number of\n    --  controlled components changes during execution. This controller\n    --  component is itself controlled and is attached to the upper-level\n-   --  finalization chain. Its adjust primitive is in charge of calling\n-   --  adjust on the components and adusting the finalization pointer to\n-   --  match their new location (see a-finali.adb).\n+   --  finalization chain. Its adjust primitive is in charge of calling adjust\n+   --  on the components and adusting the finalization pointer to match their\n+   --  new location (see a-finali.adb).\n \n    --  It is not possible to use a similar technique for arrays that have\n    --  Has_Controlled_Component set. In this case, deep procedures are\n    --  generated that call initialize/adjust/finalize + attachment or\n    --  detachment on the finalization list for all component.\n \n    --  Initialize calls: they are generated for declarations or dynamic\n-   --  allocations of Controlled objects with no initial value. They are\n-   --  always followed by an attachment to the current Finalization\n-   --  Chain. For the dynamic allocation case this the chain attached to\n-   --  the scope of the access type definition otherwise, this is the chain\n-   --  of the current scope.\n+   --  allocations of Controlled objects with no initial value. They are always\n+   --  followed by an attachment to the current Finalization Chain. For the\n+   --  dynamic allocation case this the chain attached to the scope of the\n+   --  access type definition otherwise, this is the chain of the current\n+   --  scope.\n \n    --  Adjust Calls: They are generated on 2 occasions: (1) for\n    --  declarations or dynamic allocations of Controlled objects with an\n@@ -280,21 +286,26 @@ package body Exp_Ch7 is\n    --  Finalization Calls: They are generated on (1) scope exit, (2)\n    --  assignments, (3) unchecked deallocations. In case (3) they have to\n    --  be detached from the final chain, in case (2) they must not and in\n-   --  case (1) this is not important since we are exiting the scope\n-   --  anyway.\n+   --  case (1) this is not important since we are exiting the scope anyway.\n \n    --  Other details:\n-   --    - Type extensions will have a new record controller at each derivation\n-   --      level containing controlled components.\n-   --    - For types that are both Is_Controlled and Has_Controlled_Components,\n-   --      the record controller and the object itself are handled separately.\n-   --      It could seem simpler to attach the object at the end of its record\n-   --      controller but this would not tackle view conversions properly.\n-   --    - A classwide type can always potentially have controlled components\n-   --      but the record controller of the corresponding actual type may not\n-   --      be known at compile time so the dispatch table contains a special\n-   --      field that allows to compute the offset of the record controller\n-   --      dynamically. See s-finimp.Deep_Tag_Attach and a-tags.RC_Offset\n+\n+   --    Type extensions will have a new record controller at each derivation\n+   --    level containing controlled components. The record controller for\n+   --    the parent/ancestor is attached to the finalization list of the\n+   --    extension's record controller (i.e. the parent is like a component\n+   --    of the extension).\n+\n+   --    For types that are both Is_Controlled and Has_Controlled_Components,\n+   --    the record controller and the object itself are handled separately.\n+   --    It could seem simpler to attach the object at the end of its record\n+   --    controller but this would not tackle view conversions properly.\n+\n+   --    A classwide type can always potentially have controlled components\n+   --    but the record controller of the corresponding actual type may not\n+   --    be known at compile time so the dispatch table contains a special\n+   --    field that allows to compute the offset of the record controller\n+   --    dynamically. See s-finimp.Deep_Tag_Attach and a-tags.RC_Offset.\n \n    --  Here is a simple example of the expansion of a controlled block :\n \n@@ -1031,6 +1042,12 @@ package body Exp_Ch7 is\n       Wrap_Node : Node_Id;\n \n    begin\n+      --  Nothing to do for virtual machines where memory is GCed\n+\n+      if VM_Target /= No_VM then\n+         return;\n+      end if;\n+\n       --  Do not create a transient scope if we are already inside one\n \n       for S in reverse Scope_Stack.First .. Scope_Stack.Last loop\n@@ -1066,7 +1083,7 @@ package body Exp_Ch7 is\n          null;\n \n       else\n-         New_Scope (New_Internal_Entity (E_Block, Current_Scope, Loc, 'B'));\n+         Push_Scope (New_Internal_Entity (E_Block, Current_Scope, Loc, 'B'));\n          Set_Scope_Is_Transient;\n \n          if Sec_Stack then\n@@ -1089,27 +1106,25 @@ package body Exp_Ch7 is\n    ----------------------------\n \n    procedure Expand_Cleanup_Actions (N : Node_Id) is\n-      Loc                  :  Source_Ptr;\n-      S                    : constant Entity_Id  :=\n-                               Current_Scope;\n-      Flist                : constant Entity_Id  :=\n-                               Finalization_Chain_Entity (S);\n-      Is_Task              : constant Boolean    :=\n-                               (Nkind (Original_Node (N)) = N_Task_Body);\n-      Is_Master            : constant Boolean    :=\n+      S       : constant Entity_Id  := Current_Scope;\n+      Flist   : constant Entity_Id := Finalization_Chain_Entity (S);\n+      Is_Task : constant Boolean := Nkind (Original_Node (N)) = N_Task_Body;\n+\n+      Is_Master            : constant Boolean :=\n                                Nkind (N) /= N_Entry_Body\n                                  and then Is_Task_Master (N);\n-      Is_Protected         : constant Boolean    :=\n+      Is_Protected         : constant Boolean :=\n                                Nkind (N) = N_Subprogram_Body\n                                  and then Is_Protected_Subprogram_Body (N);\n-      Is_Task_Allocation   : constant Boolean    :=\n+      Is_Task_Allocation   : constant Boolean :=\n                                Nkind (N) = N_Block_Statement\n                                  and then Is_Task_Allocation_Block (N);\n-      Is_Asynchronous_Call : constant Boolean    :=\n+      Is_Asynchronous_Call : constant Boolean :=\n                                Nkind (N) = N_Block_Statement\n                                  and then Is_Asynchronous_Call_Block (N);\n \n       Clean     : Entity_Id;\n+      Loc       : Source_Ptr;\n       Mark      : Entity_Id := Empty;\n       New_Decls : constant List_Id := New_List;\n       Blok      : Node_Id;\n@@ -1120,21 +1135,19 @@ package body Exp_Ch7 is\n       Old_Poll  : Boolean;\n \n    begin\n-\n-      --  Compute a location that is not directly in the user code in\n-      --  order to avoid to generate confusing debug info. A good\n-      --  approximation is the name of the outer user-defined scope\n-\n-      declare\n-         S1 : Entity_Id := S;\n-\n-      begin\n-         while not Comes_From_Source (S1) and then S1 /= Standard_Standard loop\n-            S1 := Scope (S1);\n-         end loop;\n-\n-         Loc := Sloc (S1);\n-      end;\n+      --  If we are generating expanded code for debugging purposes, use\n+      --  the Sloc of the point of insertion for the cleanup code. The Sloc\n+      --  will be updated subsequently to reference the proper line in the\n+      --  .dg file.  If we are not debugging generated code, use instead\n+      --  No_Location, so that no debug information is generated for the\n+      --  cleanup code. This makes the behavior of the NEXT command in GDB\n+      --  monotonic, and makes the placement of breakpoints more accurate.\n+\n+      if Debug_Generated_Code then\n+         Loc := Sloc (S);\n+      else\n+         Loc := No_Location;\n+      end if;\n \n       --  There are cleanup actions only if the secondary stack needs\n       --  releasing or some finalizations are needed or in the context\n@@ -1194,12 +1207,12 @@ package body Exp_Ch7 is\n       --  If secondary stack is in use, expand:\n       --    _Mxx : constant Mark_Id := SS_Mark;\n \n-      --  Suppress calls to SS_Mark and SS_Release if Java_VM,\n-      --  since we never use the secondary stack on the JVM.\n+      --  Suppress calls to SS_Mark and SS_Release if VM_Target,\n+      --  since we never use the secondary stack on the VM.\n \n       if Uses_Sec_Stack (Current_Scope)\n         and then not Sec_Stack_Needed_For_Return (Current_Scope)\n-        and then not Java_VM\n+        and then VM_Target = No_VM\n       then\n          Mark := Make_Defining_Identifier (Loc, New_Internal_Name ('M'));\n          Append_To (New_Decls,\n@@ -1565,7 +1578,7 @@ package body Exp_Ch7 is\n       --  This is done only for non-generic packages\n \n       if Ekind (Ent) = E_Package then\n-         New_Scope (Corresponding_Spec (N));\n+         Push_Scope (Corresponding_Spec (N));\n          Build_Task_Activation_Call (N);\n          Pop_Scope;\n       end if;\n@@ -1629,8 +1642,7 @@ package body Exp_Ch7 is\n       --  have a specific separate compilation unit for that).\n \n       if No_Body then\n-\n-         New_Scope (Defining_Entity (N));\n+         Push_Scope (Defining_Entity (N));\n \n          if Has_RACW (Defining_Entity (N)) then\n \n@@ -2016,12 +2028,17 @@ package body Exp_Ch7 is\n       Target : Node_Id;\n \n    begin\n-      --  If the node to be wrapped is the triggering alternative of an\n+      --  If the node to be wrapped is the triggering statement of an\n       --  asynchronous select, it is not part of a statement list. The\n       --  actions must be inserted before the Select itself, which is\n-      --  part of some list of statements.\n+      --  part of some list of statements. Note that the triggering\n+      --  alternative includes the triggering statement and an optional\n+      --  statement list. If the node to be wrapped is part of that list,\n+      --  the normal insertion applies.\n \n-      if Nkind (Parent (Node_To_Be_Wrapped)) = N_Triggering_Alternative then\n+      if Nkind (Parent (Node_To_Be_Wrapped)) = N_Triggering_Alternative\n+        and then not Is_List_Member (Node_To_Be_Wrapped)\n+      then\n          Target := Parent (Parent (Node_To_Be_Wrapped));\n       else\n          Target := N;\n@@ -2661,12 +2678,7 @@ package body Exp_Ch7 is\n           Parameter_Type      => New_Reference_To (Type_B, Loc)));\n \n       if Prim = Finalize_Case or else Prim = Adjust_Case then\n-         Handler := New_List (\n-           Make_Implicit_Exception_Handler (Loc,\n-             Exception_Choices => New_List (Make_Others_Choice (Loc)),\n-             Statements        => New_List (\n-               Make_Raise_Program_Error (Loc,\n-                 Reason => PE_Finalize_Raised_Exception))));\n+         Handler := New_List (Make_Handler_For_Ctrl_Operation (Loc));\n       end if;\n \n       Proc_Name :=\n@@ -2932,6 +2944,61 @@ package body Exp_Ch7 is\n       return Res;\n    end Make_Final_Call;\n \n+   -------------------------------------\n+   -- Make_Handler_For_Ctrl_Operation --\n+   -------------------------------------\n+\n+   --  Generate:\n+\n+   --    when E : others =>\n+   --      Raise_From_Controlled_Operation (X => E);\n+\n+   --  or:\n+\n+   --    when others =>\n+   --      raise Program_Error [finalize raised exception];\n+\n+   --  depending on whether Raise_From_Controlled_Operation is available\n+\n+   function Make_Handler_For_Ctrl_Operation\n+     (Loc : Source_Ptr) return Node_Id\n+   is\n+      E_Occ : Entity_Id;\n+      --  Choice parameter (for the first case above)\n+\n+      Raise_Node : Node_Id;\n+      --  Procedure call or raise statement\n+\n+   begin\n+      if RTE_Available (RE_Raise_From_Controlled_Operation) then\n+\n+         --  Standard runtime: add choice parameter E, and pass it to\n+         --  Raise_From_Controlled_Operation so that the original exception\n+         --  name and message can be recorded in the exception message for\n+         --  Program_Error.\n+\n+         E_Occ := Make_Defining_Identifier (Loc, Name_E);\n+         Raise_Node := Make_Procedure_Call_Statement (Loc,\n+                         Name =>\n+                           New_Occurrence_Of (\n+                             RTE (RE_Raise_From_Controlled_Operation), Loc),\n+                         Parameter_Associations => New_List (\n+                           New_Occurrence_Of (E_Occ, Loc)));\n+\n+      else\n+         --  Restricted runtime: exception messages are not supported\n+\n+         E_Occ := Empty;\n+         Raise_Node := Make_Raise_Program_Error (Loc,\n+                         Reason => PE_Finalize_Raised_Exception);\n+      end if;\n+\n+      return Make_Implicit_Exception_Handler (Loc,\n+               Exception_Choices => New_List (Make_Others_Choice (Loc)),\n+               Choice_Parameter  => E_Occ,\n+               Statements        => New_List (Raise_Node));\n+   end Make_Handler_For_Ctrl_Operation;\n+\n    --------------------\n    -- Make_Init_Call --\n    --------------------\n@@ -3069,7 +3136,8 @@ package body Exp_Ch7 is\n    begin\n       --  Case where only secondary stack use is involved\n \n-      if Uses_Sec_Stack (Current_Scope)\n+      if VM_Target = No_VM\n+        and then Uses_Sec_Stack (Current_Scope)\n         and then No (Flist)\n         and then Nkind (Action) /= N_Return_Statement\n         and then Nkind (Par) /= N_Exception_Handler\n@@ -3136,7 +3204,6 @@ package body Exp_Ch7 is\n \n       declare\n          Last_Inserted : Node_Id := Prev (Action);\n-\n       begin\n          if Present (Last_Inserted) then\n             Freeze_All (First_Entity (Current_Scope), Last_Inserted);\n@@ -3340,7 +3407,7 @@ package body Exp_Ch7 is\n       --  released upon its exit unless this is a function that returns on\n       --  the sec stack in which case this will be done by the caller.\n \n-      if Uses_SS then\n+      if VM_Target = No_VM and then Uses_SS then\n          S := Enclosing_Dynamic_Scope (S);\n \n          if Ekind (S) = E_Function\n@@ -3428,7 +3495,7 @@ package body Exp_Ch7 is\n    --       end _Clean;\n \n    --    begin\n-   --       <Instr uction>;\n+   --       <Instruction>;\n    --    at end\n    --       _Clean;\n    --    end;"}, {"sha": "ebaa1f3f63b9bdf34f57f0273e3ad25eb3ef176e", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbe13a374e58cda45a1a06df8e2a689bcc24e1da/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbe13a374e58cda45a1a06df8e2a689bcc24e1da/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=dbe13a374e58cda45a1a06df8e2a689bcc24e1da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,6 +24,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Namet; use Namet;\n with Types; use Types;\n \n package Exp_Ch7 is\n@@ -163,6 +164,10 @@ package Exp_Ch7 is\n    --  say attach the result of the call to the current finalization list,\n    --  which is the one of the transient scope created for such constructs.\n \n+   function Make_Handler_For_Ctrl_Operation (Loc : Source_Ptr) return Node_Id;\n+   --  Generate an implicit exception handler with an 'others' choice,\n+   --  converting any occurrence to a raise of Program_Error.\n+\n    --------------------------------------------\n    -- Task and Protected Object finalization --\n    --------------------------------------------"}]}