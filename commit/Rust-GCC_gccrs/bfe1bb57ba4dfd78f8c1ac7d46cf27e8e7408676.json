{"sha": "bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlMWJiNTdiYTRkZmQ3OGY4YzFhYzdkNDZjZjI3ZThlNzQwODY3Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:59:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:59:50Z"}, "message": "Add support for vectorising live-out values using SVE LASTB\n\nThis patch uses the SVE LASTB instruction to optimise cases in which\na value produced by the final scalar iteration of a vectorised loop is\nlive outside the loop.  Previously this situation would stop us from\nusing a fully-masked loop.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/md.texi (extract_last_@var{m}): Document.\n\t* optabs.def (extract_last_optab): New optab.\n\t* internal-fn.def (EXTRACT_LAST): New internal function.\n\t* internal-fn.c (cond_unary_direct): New macro.\n\t(expand_cond_unary_optab_fn): Likewise.\n\t(direct_cond_unary_optab_supported_p): Likewise.\n\t* tree-vect-loop.c (vectorizable_live_operation): Allow fully-masked\n\tloops using EXTRACT_LAST.\n\t* config/aarch64/aarch64-sve.md (aarch64_sve_lastb<mode>): Rename to...\n\t(extract_last_<mode>): ...this optab.\n\t(vec_extract<mode><Vel>): Update accordingly.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/live_1.c: New test.\n\t* gcc.target/aarch64/sve/live_1_run.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256632", "tree": {"sha": "489dd37405fb9ba664020489aaec102ba690e05f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/489dd37405fb9ba664020489aaec102ba690e05f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/comments", "author": null, "committer": null, "parents": [{"sha": "76a34e3f8565e36d164006e62f7380bfe6057154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a34e3f8565e36d164006e62f7380bfe6057154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a34e3f8565e36d164006e62f7380bfe6057154"}], "stats": {"total": 213, "additions": 191, "deletions": 22}, "files": [{"sha": "5216a4824bfe580112f17deca77cf0329093df98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -1,3 +1,19 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/md.texi (extract_last_@var{m}): Document.\n+\t* optabs.def (extract_last_optab): New optab.\n+\t* internal-fn.def (EXTRACT_LAST): New internal function.\n+\t* internal-fn.c (cond_unary_direct): New macro.\n+\t(expand_cond_unary_optab_fn): Likewise.\n+\t(direct_cond_unary_optab_supported_p): Likewise.\n+\t* tree-vect-loop.c (vectorizable_live_operation): Allow fully-masked\n+\tloops using EXTRACT_LAST.\n+\t* config/aarch64/aarch64-sve.md (aarch64_sve_lastb<mode>): Rename to...\n+\t(extract_last_<mode>): ...this optab.\n+\t(vec_extract<mode><Vel>): Update accordingly.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "c451b024ad424ac0aa91beb4d3ef187a5e1835d1", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -345,8 +345,7 @@\n \t/* The last element can be extracted with a LASTB and a false\n \t   predicate.  */\n \trtx sel = force_reg (<VPRED>mode, CONST0_RTX (<VPRED>mode));\n-\temit_insn (gen_aarch64_sve_lastb<mode> (operands[0], sel,\n-\t\t\t\t\t\toperands[1]));\n+\temit_insn (gen_extract_last_<mode> (operands[0], sel, operands[1]));\n \tDONE;\n       }\n     if (!CONST_INT_P (operands[2]))\n@@ -365,8 +364,7 @@\n \temit_insn (gen_vec_cmp<v_int_equiv><vpred> (sel, cmp, series, zero));\n \n \t/* Select the element using LASTB.  */\n-\temit_insn (gen_aarch64_sve_lastb<mode> (operands[0], sel,\n-\t\t\t\t\t\toperands[1]));\n+\temit_insn (gen_extract_last_<mode> (operands[0], sel, operands[1]));\n \tDONE;\n       }\n   }\n@@ -431,7 +429,7 @@\n \n ;; Extract the last active element of operand 1 into operand 0.\n ;; If no elements are active, extract the last inactive element instead.\n-(define_insn \"aarch64_sve_lastb<mode>\"\n+(define_insn \"extract_last_<mode>\"\n   [(set (match_operand:<VEL> 0 \"register_operand\" \"=r, w\")\n \t(unspec:<VEL>\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")"}, {"sha": "f95e7e1193590ff5a23b0c0d5e9a8f4a8a393fa9", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -5219,6 +5219,14 @@ of a vector of mode @var{m}.  Operand 1 is the vector input and operand 0\n is the scalar result.  The mode of the scalar result is the same as one\n element of @var{m}.\n \n+@cindex @code{extract_last_@var{m}} instruction pattern\n+@item @code{extract_last_@var{m}}\n+Find the last set bit in mask operand 1 and extract the associated element\n+of vector operand 2.  Store the result in scalar operand 0.  Operand 2\n+has vector mode @var{m} while operand 0 has the mode appropriate for one\n+element of @var{m}.  Operand 1 has the usual mask mode for vectors of mode\n+@var{m}; see @code{TARGET_VECTORIZE_GET_MASK_MODE}.\n+\n @cindex @code{sdot_prod@var{m}} instruction pattern\n @item @samp{sdot_prod@var{m}}\n @cindex @code{udot_prod@var{m}} instruction pattern"}, {"sha": "23c922490d69ce5ef9f5d6c241e30638408bf88d", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -88,6 +88,7 @@ init_internal_fns ()\n #define mask_store_lanes_direct { 0, 0, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n+#define cond_unary_direct { 1, 1, true }\n #define cond_binary_direct { 1, 1, true }\n #define while_direct { 0, 2, false }\n \n@@ -2886,6 +2887,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_binary_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n \n+#define expand_cond_unary_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n+\n #define expand_cond_binary_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n \n@@ -2962,6 +2966,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n \n #define direct_unary_optab_supported_p direct_optab_supported_p\n #define direct_binary_optab_supported_p direct_optab_supported_p\n+#define direct_cond_unary_optab_supported_p direct_optab_supported_p\n #define direct_cond_binary_optab_supported_p direct_optab_supported_p\n #define direct_mask_load_optab_supported_p direct_optab_supported_p\n #define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p"}, {"sha": "fb9f095f69b64b28084fe9972790a264944b9dcc", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -154,6 +154,10 @@ DEF_INTERNAL_OPTAB_FN (REDUC_IOR, ECF_CONST | ECF_NOTHROW,\n DEF_INTERNAL_OPTAB_FN (REDUC_XOR, ECF_CONST | ECF_NOTHROW,\n \t\t       reduc_xor_scal, unary)\n \n+/* Extract the last active element from a vector.  */\n+DEF_INTERNAL_OPTAB_FN (EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,\n+\t\t       extract_last, cond_unary)\n+\n /* Unary math functions.  */\n DEF_INTERNAL_FLT_FN (ACOS, ECF_CONST, acos, unary)\n DEF_INTERNAL_FLT_FN (ASIN, ECF_CONST, asin, unary)"}, {"sha": "6030106965259591abaea83d84d4c12cb40e6146", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -307,6 +307,8 @@ OPTAB_D (reduc_and_scal_optab,  \"reduc_and_scal_$a\")\n OPTAB_D (reduc_ior_scal_optab,  \"reduc_ior_scal_$a\")\n OPTAB_D (reduc_xor_scal_optab,  \"reduc_xor_scal_$a\")\n \n+OPTAB_D (extract_last_optab, \"extract_last_$a\")\n+\n OPTAB_D (sdot_prod_optab, \"sdot_prod$I$a\")\n OPTAB_D (ssum_widen_optab, \"widen_ssum$I$a3\")\n OPTAB_D (udot_prod_optab, \"udot_prod$I$a\")"}, {"sha": "60109a1c75129e9499593529214c3a40f221f8fd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -1,3 +1,10 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.target/aarch64/sve/live_1.c: New test.\n+\t* gcc.target/aarch64/sve/live_1_run.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e8d92ec7e9f57a4f2d1c2fd8b259a41d87eb03c3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/live_1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Flive_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Flive_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Flive_1.c?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define EXTRACT_LAST(TYPE)\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\\\n+  test_##TYPE (TYPE *x, int n, TYPE value)\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE last;\t\t\t\t\t\\\n+    for (int j = 0; j < n; ++j)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tlast = x[j];\t\t\t\t\\\n+\tx[j] = last * value;\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    return last;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (_Float16)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (EXTRACT_LAST)\n+\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7].b, } 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7].h, } 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7].s, } 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7].d, } 4 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tlastb\\tw[0-9]+, p[0-7], z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tlastb\\tw[0-9]+, p[0-7], z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tlastb\\tw[0-9]+, p[0-7], z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tlastb\\tx[0-9]+, p[0-7], z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tlastb\\th[0-9]+, p[0-7], z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tlastb\\ts[0-9]+, p[0-7], z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tlastb\\td[0-9]+, p[0-7], z[0-9]+\\.d\\n} 1 } } */"}, {"sha": "e4308a5b076de354e925b41b180a55be8d0cb251", "filename": "gcc/testsuite/gcc.target/aarch64/sve/live_1_run.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Flive_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Flive_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Flive_1_run.c?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-inline\" } */\n+\n+#include \"live_1.c\"\n+\n+#define N 107\n+#define OP 70\n+\n+#define TEST_LOOP(TYPE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE a[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + (i % 3);\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\\\n+      }\t\t\t\t\t\t\\\n+    TYPE expected = a[N - 1];\t\t\t\\\n+    TYPE res = test_##TYPE (a, N, OP);\t\t\\\n+    if (res != expected)\t\t\t\\\n+      __builtin_abort ();\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tTYPE old = i * 2 + (i % 3);\t\t\\\n+\tif (a[i] != (TYPE) (old * (TYPE) OP))\t\\\n+\t  __builtin_abort ();\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (TEST_LOOP);\n+  return 0;\n+}"}, {"sha": "59cd1c4540c695aca08bd2aa88365522193f77d3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 70, "deletions": 17, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "patch": "@@ -7812,16 +7812,43 @@ vectorizable_live_operation (gimple *stmt,\n \n   if (!vec_stmt)\n     {\n+      /* No transformation required.  */\n       if (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"can't use a fully-masked loop because \"\n-\t\t\t     \"a value is live outside the loop.\\n\");\n-\t  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t  if (!direct_internal_fn_supported_p (IFN_EXTRACT_LAST, vectype,\n+\t\t\t\t\t       OPTIMIZE_FOR_SPEED))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"can't use a fully-masked loop because \"\n+\t\t\t\t \"the target doesn't support extract last \"\n+\t\t\t\t \"reduction.\\n\");\n+\t      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t    }\n+\t  else if (slp_node)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"can't use a fully-masked loop because an \"\n+\t\t\t\t \"SLP statement is live after the loop.\\n\");\n+\t      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t    }\n+\t  else if (ncopies > 1)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"can't use a fully-masked loop because\"\n+\t\t\t\t \" ncopies is greater than 1.\\n\");\n+\t      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (ncopies == 1 && !slp_node);\n+\t      vect_record_loop_mask (loop_vinfo,\n+\t\t\t\t     &LOOP_VINFO_MASKS (loop_vinfo),\n+\t\t\t\t     1, vectype);\n+\t    }\n \t}\n-\n-      /* No transformation required.  */\n       return true;\n     }\n \n@@ -7838,12 +7865,12 @@ vectorizable_live_operation (gimple *stmt,\n \t     : TYPE_SIZE (TREE_TYPE (vectype)));\n   vec_bitsize = TYPE_SIZE (vectype);\n \n-  gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n-\n   /* Get the vectorized lhs of STMT and the lane to use (counted in bits).  */\n   tree vec_lhs, bitstart;\n   if (slp_node)\n     {\n+      gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n+\n       /* Get the correct slp vectorized stmt.  */\n       vec_lhs = gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[vec_entry]);\n \n@@ -7855,6 +7882,8 @@ vectorizable_live_operation (gimple *stmt,\n     {\n       enum vect_def_type dt = STMT_VINFO_DEF_TYPE (stmt_info);\n       vec_lhs = vect_get_vec_def_for_operand_1 (stmt, dt);\n+      gcc_checking_assert (ncopies == 1\n+\t\t\t   || !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n \n       /* For multiple copies, get the last copy.  */\n       for (int i = 1; i < ncopies; ++i)\n@@ -7865,15 +7894,39 @@ vectorizable_live_operation (gimple *stmt,\n       bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitsize);\n     }\n \n-  /* Create a new vectorized stmt for the uses of STMT and insert outside the\n-     loop.  */\n   gimple_seq stmts = NULL;\n-  tree bftype = TREE_TYPE (vectype);\n-  if (VECTOR_BOOLEAN_TYPE_P (vectype))\n-    bftype = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 1);\n-  tree new_tree = build3 (BIT_FIELD_REF, bftype, vec_lhs, bitsize, bitstart);\n-  new_tree = force_gimple_operand (fold_convert (lhs_type, new_tree), &stmts,\n-\t\t\t\t   true, NULL_TREE);\n+  tree new_tree;\n+  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    {\n+      /* Emit:\n+\n+\t   SCALAR_RES = EXTRACT_LAST <VEC_LHS, MASK>\n+\n+\t where VEC_LHS is the vectorized live-out result and MASK is\n+\t the loop mask for the final iteration.  */\n+      gcc_assert (ncopies == 1 && !slp_node);\n+      tree scalar_type = TREE_TYPE (STMT_VINFO_VECTYPE (stmt_info));\n+      tree scalar_res = make_ssa_name (scalar_type);\n+      tree mask = vect_get_loop_mask (gsi, &LOOP_VINFO_MASKS (loop_vinfo),\n+\t\t\t\t      1, vectype, 0);\n+      gcall *new_stmt = gimple_build_call_internal (IFN_EXTRACT_LAST,\n+\t\t\t\t\t\t    2, mask, vec_lhs);\n+      gimple_call_set_lhs (new_stmt, scalar_res);\n+      gimple_seq_add_stmt (&stmts, new_stmt);\n+\n+      /* Convert the extracted vector element to the required scalar type.  */\n+      new_tree = gimple_convert (&stmts, lhs_type, scalar_res);\n+    }\n+  else\n+    {\n+      tree bftype = TREE_TYPE (vectype);\n+      if (VECTOR_BOOLEAN_TYPE_P (vectype))\n+\tbftype = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 1);\n+      new_tree = build3 (BIT_FIELD_REF, bftype, vec_lhs, bitsize, bitstart);\n+      new_tree = force_gimple_operand (fold_convert (lhs_type, new_tree),\n+\t\t\t\t       &stmts, true, NULL_TREE);\n+    }\n+\n   if (stmts)\n     gsi_insert_seq_on_edge_immediate (single_exit (loop), stmts);\n "}]}