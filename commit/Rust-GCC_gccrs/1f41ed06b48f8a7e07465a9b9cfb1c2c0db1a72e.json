{"sha": "1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY0MWVkMDZiNDhmOGE3ZTA3NDY1YTliOWNmYjFjMmMwZGIxYTcyZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2012-10-29T08:17:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-29T08:17:50Z"}, "message": "* pprint.ads, pprint.adb: New.\n\nFrom-SVN: r192909", "tree": {"sha": "3caa525faf8065b32a7532321edc6d4d68e5c6ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3caa525faf8065b32a7532321edc6d4d68e5c6ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3"}], "stats": {"total": 746, "additions": 746, "deletions": 0}, "files": [{"sha": "9058c9851fd33cf5ca992a26ad03969485497caf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e", "patch": "@@ -1,3 +1,7 @@\n+2012-10-29  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* pprint.ads, pprint.adb: New.\n+\n 2012-10-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* system-linux-mipsel.ads (Stack_Check_Probes): Set to True."}, {"sha": "b01ac2657c97ca4bc93af17b4299e9f7010b9b2c", "filename": "gcc/ada/pprint.adb", "status": "added", "additions": 682, "deletions": 0, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e/gcc%2Fada%2Fpprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e/gcc%2Fada%2Fpprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpprint.adb?ref=1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e", "patch": "@@ -0,0 +1,682 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               P P R I N T                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2008-2012, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;   use Atree;\n+with Einfo;   use Einfo;\n+with Namet;   use Namet;\n+with Nlists;  use Nlists;\n+with Opt;     use Opt;\n+with Sinfo;   use Sinfo;\n+with Sinput;  use Sinput;\n+with Snames;  use Snames;\n+with Uintp;   use Uintp;\n+\n+package body Pprint is\n+\n+   List_Name_Count : Integer := 0;\n+   --  Counter used to prevent infinite recursion while computing name of\n+   --  complex expressions.\n+\n+   ----------------------\n+   -- Expression_Image --\n+   ----------------------\n+\n+   function Expression_Image (Expr : Node_Id; Default : String)\n+      return String is\n+      Left         : Node_Id := Original_Node (Expr);\n+      Right        : Node_Id := Original_Node (Expr);\n+      From_Source  : constant Boolean :=\n+        Comes_From_Source (Expr) and then not Opt.Debug_Generated_Code;\n+      Append_Paren : Boolean := False;\n+\n+      function Expr_Name\n+        (Expr        : Node_Id;\n+         Take_Prefix : Boolean := True;\n+         Expand_Type : Boolean := True) return String;\n+      --  Return string corresponding to Expr. If no string can be extracted,\n+      --  return \"...\". If Take_Prefix is True, go back to prefix when needed,\n+      --  otherwise only consider the right-hand side of an expression. If\n+      --  Expand_Type is True and Expr is a type, try to expand Expr (an\n+      --  internally generated type) into a user understandable name.\n+\n+      Max_List : constant := 3;\n+      --  Limit number of list elements to dump\n+\n+      Max_Expr_Elements : constant := 24;\n+      --  Limit number of elements in an expression for use by Expr_Name\n+\n+      Num_Elements : Natural := 0;\n+      --  Current number of elements processed by Expr_Name\n+\n+      function List_Name\n+        (List      : Node_Id;\n+         Add_Space : Boolean := True;\n+         Add_Paren : Boolean := True) return String;\n+      --  Return a string corresponding to List\n+\n+      function List_Name\n+        (List      : Node_Id;\n+         Add_Space : Boolean := True;\n+         Add_Paren : Boolean := True) return String\n+      is\n+         function Internal_List_Name\n+           (List      : Node_Id;\n+            First     : Boolean := True;\n+            Add_Space : Boolean := True;\n+            Add_Paren : Boolean := True;\n+            Num       : Natural := 1) return String;\n+\n+         ------------------------\n+         -- Internal_List_Name --\n+         ------------------------\n+\n+         function Internal_List_Name\n+           (List      : Node_Id;\n+            First     : Boolean := True;\n+            Add_Space : Boolean := True;\n+            Add_Paren : Boolean := True;\n+            Num       : Natural := 1) return String\n+         is\n+            function Prepend (S : String) return String;\n+\n+            -------------\n+            -- Prepend --\n+            -------------\n+\n+            function Prepend (S : String) return String is\n+            begin\n+               if Add_Space then\n+                  if Add_Paren then\n+                     return \" (\" & S;\n+                  else\n+                     return ' ' & S;\n+                  end if;\n+               elsif Add_Paren then\n+                  return '(' & S;\n+               else\n+                  return S;\n+               end if;\n+            end Prepend;\n+\n+         --  Start of processing for Internal_List_Name\n+\n+         begin\n+            if not Present (List) then\n+               if First or else not Add_Paren then\n+                  return \"\";\n+               else\n+                  return \")\";\n+               end if;\n+            elsif Num > Max_List then\n+               if Add_Paren then\n+                  return \", ...)\";\n+               else\n+                  return \", ...\";\n+               end if;\n+            end if;\n+\n+            if First then\n+               return Prepend\n+                 (Expr_Name (List)\n+                  & Internal_List_Name (Next (List),\n+                    First     => False,\n+                    Add_Paren => Add_Paren,\n+                    Num       => Num + 1));\n+            else\n+               return \", \" & Expr_Name (List) &\n+                 Internal_List_Name\n+                 (Next (List),\n+                  First     => False,\n+                  Add_Paren => Add_Paren,\n+                  Num       => Num + 1);\n+            end if;\n+         end Internal_List_Name;\n+\n+      --  Start of processing for List_Name\n+\n+      begin\n+         --  Prevent infinite recursion by limiting depth to 3\n+\n+         if List_Name_Count > 3 then\n+            return \"...\";\n+         end if;\n+\n+         List_Name_Count := List_Name_Count + 1;\n+         declare\n+            Result : constant String :=\n+              Internal_List_Name\n+                (List, Add_Space => Add_Space, Add_Paren => Add_Paren);\n+         begin\n+            List_Name_Count := List_Name_Count - 1;\n+            return Result;\n+         end;\n+      end List_Name;\n+\n+      ---------------\n+      -- Expr_Name --\n+      ---------------\n+\n+      function Expr_Name\n+        (Expr        : Node_Id;\n+         Take_Prefix : Boolean := True;\n+         Expand_Type : Boolean := True) return String\n+      is\n+      begin\n+         Num_Elements := Num_Elements + 1;\n+\n+         if Num_Elements > Max_Expr_Elements then\n+            return \"...\";\n+         end if;\n+\n+         case Nkind (Expr) is\n+            when N_Defining_Identifier | N_Identifier =>\n+               return Ident_Image (Expr, Expression_Image.Expr, Expand_Type);\n+\n+            when N_Character_Literal =>\n+               declare\n+                  Char : constant Int :=\n+                    UI_To_Int (Char_Literal_Value (Expr));\n+               begin\n+                  if Char in 32 .. 127 then\n+                     return \"'\" & Character'Val (Char) & \"'\";\n+                  else\n+                     UI_Image (Char_Literal_Value (Expr));\n+                     return \"'\\\" & UI_Image_Buffer (1 .. UI_Image_Length)\n+                       & \"'\";\n+                  end if;\n+               end;\n+\n+            when N_Integer_Literal =>\n+               UI_Image (Intval (Expr));\n+               return UI_Image_Buffer (1 .. UI_Image_Length);\n+\n+            when N_Real_Literal =>\n+               return Real_Image (Realval (Expr));\n+\n+            when N_String_Literal =>\n+               return String_Image (Strval (Expr));\n+\n+            when N_Allocator =>\n+               return \"new \" & Expr_Name (Expression (Expr));\n+\n+            when N_Aggregate =>\n+               if Present (Sinfo.Expressions (Expr)) then\n+                  return List_Name\n+                    (First (Sinfo.Expressions (Expr)), Add_Space => False);\n+\n+               elsif Null_Record_Present (Expr) then\n+                  return (\"(null record)\");\n+\n+               else\n+                  return List_Name\n+                    (First (Component_Associations (Expr)),\n+                     Add_Space => False, Add_Paren => False);\n+               end if;\n+\n+            when N_Extension_Aggregate =>\n+               return \"(\" & Expr_Name (Ancestor_Part (Expr)) &\n+                 \" with \" &\n+                 List_Name (First (Sinfo.Expressions (Expr)),\n+                            Add_Space => False, Add_Paren => False) &\n+                 \")\";\n+\n+            when N_Attribute_Reference =>\n+               if Take_Prefix then\n+                  declare\n+                     Str    : constant String := Expr_Name (Prefix (Expr))\n+                       & \"'\" & Get_Name_String (Attribute_Name (Expr));\n+                     Id     : constant Attribute_Id :=\n+                       Get_Attribute_Id (Attribute_Name (Expr));\n+                     Ranges : List_Id;\n+                     N      : Node_Id;\n+\n+                  begin\n+                     if (Id = Attribute_First or else Id = Attribute_Last)\n+                       and then Str (Str'First) = '$'\n+                     then\n+                        N := Associated_Node_For_Itype (Etype (Prefix (Expr)));\n+\n+                        if Present (N) then\n+                           if Nkind (N) = N_Full_Type_Declaration then\n+                              N := Type_Definition (N);\n+                           end if;\n+\n+                           if Nkind (N) = N_Subtype_Declaration then\n+                              Ranges := Constraints (Constraint\n+                                                     (Subtype_Indication (N)));\n+\n+                              if List_Length (Ranges) = 1\n+                                and then Nkind_In\n+                                  (First (Ranges),\n+                                   N_Range,\n+                                   N_Real_Range_Specification,\n+                                   N_Signed_Integer_Type_Definition)\n+                              then\n+                                 if Id = Attribute_First then\n+                                    return Expression_Image\n+                                      (Low_Bound (First (Ranges)), Str);\n+                                 else\n+                                    return Expression_Image\n+                                      (High_Bound (First (Ranges)), Str);\n+                                 end if;\n+                              end if;\n+                           end if;\n+                        end if;\n+                     end if;\n+\n+                     return Str;\n+                  end;\n+               else\n+                  return \"'\" & Get_Name_String (Attribute_Name (Expr));\n+               end if;\n+\n+            when N_Explicit_Dereference =>\n+               if Take_Prefix then\n+                  return Expr_Name (Prefix (Expr)) & \".all\";\n+               else\n+                  return \".all\";\n+               end if;\n+\n+            when N_Expanded_Name | N_Selected_Component =>\n+               if Take_Prefix then\n+                  return Expr_Name (Prefix (Expr))\n+                    & \".\" & Expr_Name (Selector_Name (Expr));\n+               else\n+                  return \".\" & Expr_Name (Selector_Name (Expr));\n+               end if;\n+\n+            when N_Component_Association =>\n+               return \"(\"\n+                 & List_Name (First (Choices (Expr)),\n+                              Add_Space => False, Add_Paren => False)\n+                 & \" => \" & Expr_Name (Expression (Expr)) & \")\";\n+\n+            when N_If_Expression =>\n+               declare\n+                  N : constant Node_Id := First (Sinfo.Expressions (Expr));\n+               begin\n+                  return \"if \" & Expr_Name (N) & \" then \" &\n+                    Expr_Name (Next (N)) & \" else \" &\n+                    Expr_Name (Next (Next (N)));\n+               end;\n+\n+            when N_Qualified_Expression =>\n+               declare\n+                  Mark : constant String :=\n+                    Expr_Name (Subtype_Mark (Expr), Expand_Type => False);\n+                  Str  : constant String := Expr_Name (Expression (Expr));\n+               begin\n+                  if Str (Str'First) = '(' and then Str (Str'Last) = ')' then\n+                     return Mark & \"'\" & Str;\n+                  else\n+                     return Mark & \"'(\" & Str & \")\";\n+                  end if;\n+               end;\n+\n+            when N_Unchecked_Expression | N_Expression_With_Actions =>\n+               return Expr_Name (Expression (Expr));\n+\n+            when N_Raise_Constraint_Error =>\n+               if Present (Condition (Expr)) then\n+                  return \"[constraint_error when \" &\n+                    Expr_Name (Condition (Expr)) & \"]\";\n+               else\n+                  return \"[constraint_error]\";\n+               end if;\n+\n+            when N_Raise_Program_Error =>\n+               if Present (Condition (Expr)) then\n+                  return \"[program_error when \" &\n+                    Expr_Name (Condition (Expr)) & \"]\";\n+               else\n+                  return \"[program_error]\";\n+               end if;\n+\n+            when N_Range =>\n+               return Expr_Name (Low_Bound (Expr)) & \"..\" &\n+                 Expr_Name (High_Bound (Expr));\n+\n+            when N_Slice =>\n+               return Expr_Name (Prefix (Expr)) & \" (\" &\n+                 Expr_Name (Discrete_Range (Expr)) & \")\";\n+\n+            when N_And_Then =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" and then \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_In =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" in \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Not_In =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" not in \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Or_Else =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" or else \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_And =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" and \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Or =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" or \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Xor =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" xor \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Eq =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" = \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Ne =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" /= \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Lt =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" < \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Le =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" <= \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Gt =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" > \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Ge =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" >= \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Add =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" + \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Subtract =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" - \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Multiply =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" * \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Divide =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" / \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Mod =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" mod \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Rem =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" rem \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Expon =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" ** \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Shift_Left =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" << \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Shift_Right | N_Op_Shift_Right_Arithmetic =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" >> \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Concat =>\n+               return Expr_Name (Left_Opnd (Expr)) & \" & \" &\n+                 Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Plus =>\n+               return \"+\" & Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Minus =>\n+               return \"-\" & Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Abs =>\n+               return \"abs \" & Expr_Name (Right_Opnd (Expr));\n+\n+            when N_Op_Not =>\n+               return \"not (\" & Expr_Name (Right_Opnd (Expr)) & \")\";\n+\n+            when N_Parameter_Association =>\n+               return Expr_Name (Explicit_Actual_Parameter (Expr));\n+\n+            when N_Type_Conversion | N_Unchecked_Type_Conversion =>\n+\n+               --  Most conversions are not very interesting (used inside\n+               --  expanded checks to convert to larger ranges), so skip them.\n+\n+               return Expr_Name (Expression (Expr));\n+\n+            when N_Indexed_Component =>\n+               if Take_Prefix then\n+                  return Expr_Name (Prefix (Expr)) &\n+                    List_Name (First (Sinfo.Expressions (Expr)));\n+               else\n+                  return List_Name (First (Sinfo.Expressions (Expr)));\n+               end if;\n+\n+            when N_Function_Call =>\n+\n+               --  If Default = \"\", it means we're expanding the name of\n+               --  a gnat temporary (and not really a function call), so add\n+               --  parentheses around function call to mark it specially.\n+\n+               if Default = \"\" then\n+                  return '(' & Expr_Name (Name (Expr)) &\n+                    List_Name (First (Sinfo.Parameter_Associations (Expr))) &\n+                      ')';\n+               else\n+                  return Expr_Name (Name (Expr)) &\n+                    List_Name (First (Sinfo.Parameter_Associations (Expr)));\n+               end if;\n+\n+            when N_Null =>\n+               return \"null\";\n+\n+            when N_Others_Choice =>\n+               return \"others\";\n+\n+            when others =>\n+               return \"...\";\n+         end case;\n+      end Expr_Name;\n+\n+   --  Start of processing for Expression_Name\n+\n+   begin\n+      if not From_Source then\n+         declare\n+            S : constant String := Expr_Name (Expr);\n+         begin\n+            if S = \"...\" then\n+               return Default;\n+            else\n+               return S;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Compute left (start) and right (end) slocs for the expression\n+      --  Consider using Sinput.Sloc_Range instead, except that it does not\n+      --  work properly currently???\n+\n+      loop\n+         case Nkind (Left) is\n+            when N_Binary_Op | N_Membership_Test |\n+                 N_And_Then  | N_Or_Else         =>\n+               Left := Original_Node (Left_Opnd (Left));\n+\n+            when N_Attribute_Reference  | N_Expanded_Name      |\n+                 N_Explicit_Dereference | N_Indexed_Component  |\n+                 N_Reference            | N_Selected_Component |\n+                 N_Slice                                       =>\n+               Left := Original_Node (Prefix (Left));\n+\n+            when N_Designator | N_Defining_Program_Unit_Name |\n+                 N_Function_Call                             =>\n+               Left := Original_Node (Name (Left));\n+\n+            when N_Range =>\n+               Left := Original_Node (Low_Bound (Left));\n+\n+            when N_Type_Conversion =>\n+               Left := Original_Node (Subtype_Mark (Left));\n+\n+            --  For any other item, quit loop\n+\n+            when others =>\n+               exit;\n+         end case;\n+      end loop;\n+\n+      loop\n+         case Nkind (Right) is\n+            when N_Op       | N_Membership_Test |\n+                 N_And_Then | N_Or_Else         =>\n+               Right := Original_Node (Right_Opnd (Right));\n+\n+            when N_Selected_Component | N_Expanded_Name =>\n+               Right := Original_Node (Selector_Name (Right));\n+\n+            when N_Designator =>\n+               Right := Original_Node (Identifier (Right));\n+\n+            when N_Defining_Program_Unit_Name =>\n+               Right := Original_Node (Defining_Identifier (Right));\n+\n+            when N_Range =>\n+               Right := Original_Node (High_Bound (Right));\n+\n+            when N_Parameter_Association =>\n+               Right := Original_Node (Explicit_Actual_Parameter (Right));\n+\n+            when N_Indexed_Component =>\n+               Right := Original_Node (Last (Sinfo.Expressions (Right)));\n+               Append_Paren := True;\n+\n+            when N_Function_Call =>\n+               if Present (Sinfo.Parameter_Associations (Right)) then\n+                  Right :=\n+                    Original_Node\n+                      (Last (Sinfo.Parameter_Associations (Right)));\n+                  Append_Paren := True;\n+\n+               --  Quit loop if no named associations\n+\n+               else\n+                  exit;\n+               end if;\n+\n+            --  For all other items, quit the loop\n+\n+            when others =>\n+               exit;\n+         end case;\n+      end loop;\n+\n+      declare\n+         Scn      : Source_Ptr := Original_Location (Sloc (Left));\n+         Src      : constant Source_Buffer_Ptr :=\n+           Source_Text (Get_Source_File_Index (Scn));\n+         End_Sloc : constant Source_Ptr :=\n+           Original_Location (Sloc (Right));\n+\n+      begin\n+         if Scn > End_Sloc then\n+            return Default;\n+         end if;\n+\n+         declare\n+            Buffer           : String (1 .. Natural (End_Sloc - Scn));\n+            Skipping_Comment : Boolean := False;\n+            Underscore       : Boolean := False;\n+            Index            : Natural := 0;\n+\n+         begin\n+            if Right /= Expr then\n+               while Scn < End_Sloc loop\n+                  case Src (Scn) is\n+                  when ' ' | ASCII.HT =>\n+                     if not Skipping_Comment and then not Underscore then\n+                        Underscore := True;\n+                        Index := Index + 1;\n+                        Buffer (Index) := ' ';\n+                     end if;\n+\n+                  --  CR/LF/FF is the end of any comment\n+\n+                  when ASCII.LF | ASCII.CR | ASCII.FF =>\n+                     Skipping_Comment := False;\n+\n+                  when others =>\n+                     Underscore := False;\n+\n+                     if not Skipping_Comment then\n+\n+                        --  Ignore comment\n+\n+                        if Src (Scn) = '-' and then Src (Scn + 1) = '-' then\n+                           Skipping_Comment := True;\n+\n+                        else\n+                           Index := Index + 1;\n+                           Buffer (Index) := Src (Scn);\n+                        end if;\n+                     end if;\n+                  end case;\n+\n+                  Scn := Scn + 1;\n+               end loop;\n+            end if;\n+\n+            if Index < 1 then\n+               declare\n+                  S : constant String := Expr_Name (Right);\n+               begin\n+                  if S = \"...\" then\n+                     return Default;\n+                  else\n+                     return S;\n+                  end if;\n+               end;\n+\n+            elsif Append_Paren then\n+               return Buffer (1 .. Index) & Expr_Name (Right, False) & ')';\n+\n+            else\n+               return Buffer (1 .. Index) & Expr_Name (Right, False);\n+            end if;\n+         end;\n+      end;\n+   end Expression_Image;\n+\n+end Pprint;"}, {"sha": "8fc1036b1e4dc69b88a972f885865d6cc9a8caf9", "filename": "gcc/ada/pprint.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e/gcc%2Fada%2Fpprint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e/gcc%2Fada%2Fpprint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpprint.ads?ref=1f41ed06b48f8a7e07465a9b9cfb1c2c0db1a72e", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               P P R I N T                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2008-2012, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package (pretty print) contains a routine for printing an expression\n+--  given its node in the syntax tree. Contrarily to the Sprint package, this\n+--  routine tries to obtain \"pretty\" output that can be used for e.g. error\n+--  messages.\n+\n+with Types;  use Types;\n+with Urealp; use Urealp;\n+\n+package Pprint is\n+\n+   generic\n+\n+      --  ??? The generic parameters should be removed.\n+\n+      with function Real_Image (U : Ureal) return String;\n+      with function String_Image (S : String_Id) return String;\n+      with function Ident_Image (Expr        : Node_Id;\n+                                 Orig_Expr   : Node_Id;\n+                                 Expand_Type : Boolean)\n+                                 return String;\n+      --  Will be called for printing N_Identifier and N_Defining_Identifier\n+      --  nodes\n+      --  ??? Expand_Type argument should be removed\n+\n+   function Expression_Image (Expr              : Node_Id;\n+                              Default           : String)\n+                              return String;\n+   --  Given a Node for an expression, return a String that is meaningful for\n+   --  the programmer. If the expression comes from source, it is copied from\n+   --  there.\n+   --  Subexpressions outside of the maximum depth (3), the maximal number of\n+   --  accepted nodes (24), and the maximal number of list elements (3), are\n+   --  replaced by the default string.\n+\n+end Pprint;"}]}