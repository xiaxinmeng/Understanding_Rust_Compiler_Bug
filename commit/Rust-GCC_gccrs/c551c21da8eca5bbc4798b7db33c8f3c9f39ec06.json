{"sha": "c551c21da8eca5bbc4798b7db33c8f3c9f39ec06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU1MWMyMWRhOGVjYTViYmM0Nzk4YjdkYjMzYzhmM2M5ZjM5ZWMwNg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2015-07-09T15:19:46Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2015-07-09T15:19:46Z"}, "message": "genmatch.c (fprintf_indent): New function.\n\n\t* genmatch.c (fprintf_indent): New function.\n\t(operand::gen_transform): Add indent parameter.\n\t(expr::gen_transform, c_expr::gen_transform,\n\tcapture::gen_transform): Ditto and use fprintf_indent.\n\t(dt_node::gen, dt_node::gen_kids, dt_node::gen_kids_1): Ditto.\n\t(dt_operand::gen, dt_operand::gen_predicate,\n\tdt_operand::gen_match_op, dt_operand::gen_gimple_expr,\n\tdt_operand::gen_generic_expr, dt_simplify::gen): Ditto.\n\t(decision_tree::gen_gimple): Adjust calls and indent generated\n\tcode.\n\t(decision_tree::gen_generic): Ditto.\n\t(write_predicate): Ditto.\n\nFrom-SVN: r225617", "tree": {"sha": "05bf719f17a57b98b7d4c73716eeeae93529a1fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05bf719f17a57b98b7d4c73716eeeae93529a1fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb1fd5b43f7bd2b21e4418184f4b496a009fbd59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1fd5b43f7bd2b21e4418184f4b496a009fbd59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1fd5b43f7bd2b21e4418184f4b496a009fbd59"}], "stats": {"total": 663, "additions": 407, "deletions": 256}, "files": [{"sha": "844ff7b3f47ec01556f54dd91ebd2686c4558a4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c551c21da8eca5bbc4798b7db33c8f3c9f39ec06", "patch": "@@ -1,3 +1,18 @@\n+2015-07-09  Michael Matz  <matz@suse.de>\n+\n+\t* genmatch.c (fprintf_indent): New function.\n+\t(operand::gen_transform): Add indent parameter.\n+\t(expr::gen_transform, c_expr::gen_transform,\n+\tcapture::gen_transform): Ditto and use fprintf_indent.\n+\t(dt_node::gen, dt_node::gen_kids, dt_node::gen_kids_1): Ditto.\n+\t(dt_operand::gen, dt_operand::gen_predicate,\n+\tdt_operand::gen_match_op, dt_operand::gen_gimple_expr,\n+\tdt_operand::gen_generic_expr, dt_simplify::gen): Ditto.\n+\t(decision_tree::gen_gimple): Adjust calls and indent generated\n+\tcode.\n+\t(decision_tree::gen_generic): Ditto.\n+\t(write_predicate): Ditto.\n+\n 2015-07-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/66814"}, {"sha": "1a8895f0d1d9c717438a648dcb01a84a67ebfb7d", "filename": "gcc/genmatch.c", "status": "modified", "additions": 392, "deletions": 256, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c551c21da8eca5bbc4798b7db33c8f3c9f39ec06/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=c551c21da8eca5bbc4798b7db33c8f3c9f39ec06", "patch": "@@ -126,6 +126,23 @@ warning_at (const cpp_token *tk, const char *msg, ...)\n   va_end (ap);\n }\n \n+/* Like fprintf, but print INDENT spaces at the beginning.  */\n+\n+static void\n+#if GCC_VERSION >= 4001\n+__attribute__((format (printf, 3, 4)))\n+#endif\n+fprintf_indent (FILE *f, unsigned int indent, const char *format, ...)\n+{\n+  va_list ap;\n+  for (; indent >= 8; indent -= 8)\n+    fputc ('\\t', f);\n+  fprintf (f, \"%*s\", indent, \"\");\n+  va_start (ap, format);\n+  vfprintf (f, format, ap);\n+  va_end (ap);\n+}\n+\n static void\n output_line_directive (FILE *f, source_location location,\n \t\t       bool dumpfile = false)\n@@ -468,7 +485,7 @@ struct operand {\n   enum op_type { OP_PREDICATE, OP_EXPR, OP_CAPTURE, OP_C_EXPR };\n   operand (enum op_type type_) : type (type_) {}\n   enum op_type type;\n-  virtual void gen_transform (FILE *, const char *, bool, int,\n+  virtual void gen_transform (FILE *, int, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0,\n \t\t\t      bool = true)\n@@ -510,7 +527,7 @@ struct expr : public operand\n   /* Whether pushing any stmt to the sequence should be conditional\n      on this expression having a single-use.  */\n   bool force_single_use;\n-  virtual void gen_transform (FILE *f, const char *, bool, int,\n+  virtual void gen_transform (FILE *f, int, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0, bool = true);\n };\n@@ -541,7 +558,7 @@ struct c_expr : public operand\n   unsigned nr_stmts;\n   /* The identifier replacement vector.  */\n   vec<id_tab> ids;\n-  virtual void gen_transform (FILE *f, const char *, bool, int,\n+  virtual void gen_transform (FILE *f, int, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0, bool = true);\n };\n@@ -556,7 +573,7 @@ struct capture : public operand\n   unsigned where;\n   /* The captured value.  */\n   operand *what;\n-  virtual void gen_transform (FILE *f, const char *, bool, int,\n+  virtual void gen_transform (FILE *f, int, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0, bool = true);\n };\n@@ -1166,10 +1183,10 @@ struct dt_node\n   dt_node *append_match_op (dt_operand *, dt_node *parent = 0, unsigned pos = 0);\n   dt_node *append_simplify (simplify *, unsigned, dt_operand **);\n \n-  virtual void gen (FILE *, bool) {}\n+  virtual void gen (FILE *, int, bool) {}\n \n-  void gen_kids (FILE *, bool);\n-  void gen_kids_1 (FILE *, bool,\n+  void gen_kids (FILE *, int, bool);\n+  void gen_kids_1 (FILE *, int, bool,\n \t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_operand *>,\n \t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_node *>);\n };\n@@ -1188,12 +1205,12 @@ struct dt_operand : public dt_node\n       : dt_node (type), op (op_), match_dop (match_dop_),\n       parent (parent_), pos (pos_) {}\n \n-  void gen (FILE *, bool);\n-  unsigned gen_predicate (FILE *, const char *, bool);\n-  unsigned gen_match_op (FILE *, const char *);\n+  void gen (FILE *, int, bool);\n+  unsigned gen_predicate (FILE *, int, const char *, bool);\n+  unsigned gen_match_op (FILE *, int, const char *);\n \n-  unsigned gen_gimple_expr (FILE *);\n-  unsigned gen_generic_expr (FILE *, const char *);\n+  unsigned gen_gimple_expr (FILE *, int);\n+  unsigned gen_generic_expr (FILE *, int, const char *);\n \n   char *get_name (char *);\n   void gen_opname (char *, unsigned);\n@@ -1211,7 +1228,7 @@ struct dt_simplify : public dt_node\n \t: dt_node (DT_SIMPLIFY), s (s_), pattern_no (pattern_no_),\n \t  indexes (indexes_)  {}\n \n-  void gen (FILE *f, bool);\n+  void gen (FILE *f, int, bool);\n };\n \n template<>\n@@ -1739,8 +1756,8 @@ get_operand_type (id_base *op, const char *in_type,\n /* Generate transform code for an expression.  */\n \n void\n-expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n-\t\t     const char *in_type, capture_info *cinfo,\n+expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n+\t\t     int depth, const char *in_type, capture_info *cinfo,\n \t\t     dt_operand **indexes, bool)\n {\n   bool conversion_p = is_conversion (operation);\n@@ -1784,18 +1801,20 @@ expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n   if (!type)\n     fatal (\"two conversions in a row\");\n \n-  fprintf (f, \"{\\n\");\n-  fprintf (f, \"  tree ops%d[%u], res;\\n\", depth, ops.length ());\n+  fprintf_indent (f, indent, \"{\\n\");\n+  indent += 2;\n+  fprintf_indent (f, indent, \"tree ops%d[%u], res;\\n\", depth, ops.length ());\n   char op0type[64];\n   snprintf (op0type, 64, \"TREE_TYPE (ops%d[0])\", depth);\n   for (unsigned i = 0; i < ops.length (); ++i)\n     {\n       char dest[32];\n-      snprintf (dest, 32, \"  ops%d[%u]\", depth, i);\n+      snprintf (dest, 32, \"ops%d[%u]\", depth, i);\n       const char *optype\n \t= get_operand_type (operation, in_type, expr_type,\n \t\t\t    i == 0 ? NULL : op0type);\n-      ops[i]->gen_transform (f, dest, gimple, depth + 1, optype, cinfo, indexes,\n+      ops[i]->gen_transform (f, indent, dest, gimple, depth + 1, optype,\n+\t\t\t     cinfo, indexes,\n \t\t\t     ((!(*operation == COND_EXPR)\n \t\t\t       && !(*operation == VEC_COND_EXPR))\n \t\t\t      || i != 0));\n@@ -1810,58 +1829,80 @@ expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n   if (gimple)\n     {\n       if (*operation == CONVERT_EXPR)\n-\tfprintf (f, \"  if (%s != TREE_TYPE (ops%d[0])\\n\"\n-\t    \"      && !useless_type_conversion_p (%s, TREE_TYPE (ops%d[0])))\\n\"\n-\t    \"  {\\n\", type, depth, type, depth);\n+\t{\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"if (%s != TREE_TYPE (ops%d[0])\\n\",\n+\t\t\t  type, depth);\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"    && !useless_type_conversion_p (%s, TREE_TYPE (ops%d[0])))\\n\",\n+\t\t\t  type, depth);\n+\t  fprintf_indent (f, indent + 2, \"{\\n\");\n+\t  indent += 4;\n+\t}\n       /* ???  Building a stmt can fail for various reasons here, seq being\n          NULL or the stmt referencing SSA names occuring in abnormal PHIs.\n \t So if we fail here we should continue matching other patterns.  */\n-      fprintf (f, \"  code_helper tem_code = %s;\\n\"\n-\t       \"  tree tem_ops[3] = { \", opr);\n+      fprintf_indent (f, indent, \"code_helper tem_code = %s;\\n\", opr);\n+      fprintf_indent (f, indent, \"tree tem_ops[3] = { \");\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \"ops%d[%u]%s\", depth, i,\n \t\t i == ops.length () - 1 ? \" };\\n\" : \", \");\n-      fprintf (f, \"  gimple_resimplify%d (lseq, &tem_code, %s, tem_ops, valueize);\\n\",\n-\t       ops.length (), type);\n-      fprintf (f, \"  res = maybe_push_res_to_seq (tem_code, %s, tem_ops, lseq);\\n\"\n-\t       \"  if (!res) return false;\\n\", type);\n+      fprintf_indent (f, indent,\n+\t\t      \"gimple_resimplify%d (lseq, &tem_code, %s, tem_ops, valueize);\\n\",\n+\t\t      ops.length (), type);\n+      fprintf_indent (f, indent,\n+\t\t      \"res = maybe_push_res_to_seq (tem_code, %s, tem_ops, lseq);\\n\",\n+\t\t      type);\n+      fprintf_indent (f, indent,\n+\t\t      \"if (!res) return false;\\n\");\n       if (*operation == CONVERT_EXPR)\n-        fprintf (f, \"  }\\n\"\n-\t\t \"  else\\n\"\n-\t\t \"    res = ops%d[0];\\n\", depth);\n+\t{\n+\t  indent -= 4;\n+\t  fprintf_indent (f, indent, \"  }\\n\");\n+\t  fprintf_indent (f, indent, \"else\\n\");\n+\t  fprintf_indent (f, indent, \"  res = ops%d[0];\\n\", depth);\n+\t}\n     }\n   else\n     {\n       if (*operation == CONVERT_EXPR)\n-\tfprintf (f, \"  if (TREE_TYPE (ops%d[0]) != %s)\\n\", depth, type);\n+\t{\n+\t  fprintf_indent (f, indent, \"if (TREE_TYPE (ops%d[0]) != %s)\\n\",\n+\t\t\t  depth, type);\n+\t  indent += 2;\n+\t}\n       if (operation->kind == id_base::CODE)\n-\tfprintf (f, \"  res = fold_build%d_loc (loc, %s, %s\",\n-\t\t ops.length(), opr, type);\n+\tfprintf_indent (f, indent, \"res = fold_build%d_loc (loc, %s, %s\",\n+\t\t\tops.length(), opr, type);\n       else\n-\tfprintf (f, \"  res = build_call_expr_loc (loc, \"\n-\t\t \"builtin_decl_implicit (%s), %d\", opr, ops.length());\n+\tfprintf_indent (f, indent, \"res = build_call_expr_loc (loc, \"\n+\t\t\t\"builtin_decl_implicit (%s), %d\", opr, ops.length());\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \", ops%d[%u]\", depth, i);\n       fprintf (f, \");\\n\");\n       if (*operation == CONVERT_EXPR)\n-\tfprintf (f, \"  else\\n\"\n-\t\t \"    res = ops%d[0];\\n\", depth);\n+\t{\n+\t  indent -= 2;\n+\t  fprintf_indent (f, indent, \"else\\n\");\n+\t  fprintf_indent (f, indent, \"  res = ops%d[0];\\n\", depth);\n+\t}\n     }\n-  fprintf (f, \"%s = res;\\n\", dest);\n-  fprintf (f, \"}\\n\");\n+  fprintf_indent (f, indent, \"%s = res;\\n\", dest);\n+  indent -= 2;\n+  fprintf_indent (f, indent, \"}\\n\");\n }\n \n /* Generate code for a c_expr which is either the expression inside\n    an if statement or a sequence of statements which computes a\n    result to be stored to DEST.  */\n \n void\n-c_expr::gen_transform (FILE *f, const char *dest,\n+c_expr::gen_transform (FILE *f, int indent, const char *dest,\n \t\t       bool, int, const char *, capture_info *,\n \t\t       dt_operand **, bool)\n {\n   if (dest && nr_stmts == 1)\n-    fprintf (f, \"%s = \", dest);\n+    fprintf_indent (f, indent, \"%s = \", dest);\n \n   unsigned stmt_nr = 1;\n   for (unsigned i = 0; i < code.length (); ++i)\n@@ -1915,19 +1956,18 @@ c_expr::gen_transform (FILE *f, const char *dest,\n       if (token->type == CPP_SEMICOLON)\n \t{\n \t  stmt_nr++;\n+\t  fputc ('\\n', f);\n \t  if (dest && stmt_nr == nr_stmts)\n-\t    fprintf (f, \"\\n %s = \", dest);\n-\t  else\n-\t    fputc ('\\n', f);\n+\t    fprintf_indent (f, indent, \"%s = \", dest);\n \t}\n     }\n }\n \n /* Generate transform code for a capture.  */\n \n void\n-capture::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n-\t\t\tconst char *in_type, capture_info *cinfo,\n+capture::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n+\t\t\tint depth, const char *in_type, capture_info *cinfo,\n \t\t\tdt_operand **indexes, bool expand_compares)\n {\n   if (what && is_a<expr *> (what))\n@@ -1936,25 +1976,29 @@ capture::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n \t{\n \t  char buf[20];\n \t  sprintf (buf, \"captures[%u]\", where);\n-\t  what->gen_transform (f, buf, gimple, depth, in_type, cinfo, NULL);\n+\t  what->gen_transform (f, indent, buf, gimple, depth, in_type,\n+\t\t\t       cinfo, NULL);\n \t}\n     }\n \n-  fprintf (f, \"%s = captures[%u];\\n\", dest, where);\n+  fprintf_indent (f, indent, \"%s = captures[%u];\\n\", dest, where);\n \n   /* ???  Stupid tcc_comparison GENERIC trees in COND_EXPRs.  Deal\n      with substituting a capture of that.\n      ???  Returning false here will also not allow any other patterns\n      to match.  */\n   if (gimple && expand_compares\n       && cinfo->info[where].cond_expr_cond_p)\n-    fprintf (f, \"if (COMPARISON_CLASS_P (%s))\\n\"\n-\t     \"  {\\n\"\n-\t     \"    if (!seq) return false;\\n\"\n-\t     \"    %s = gimple_build (seq, TREE_CODE (%s),\"\n-\t     \" TREE_TYPE (%s), TREE_OPERAND (%s, 0),\"\n-\t     \" TREE_OPERAND (%s, 1));\\n\"\n-\t     \"  }\\n\", dest, dest, dest, dest, dest, dest);\n+    {\n+      fprintf_indent (f, indent, \"if (COMPARISON_CLASS_P (%s))\\n\", dest);\n+      fprintf_indent (f, indent, \"  {\\n\");\n+      fprintf_indent (f, indent, \"    if (!seq) return false;\\n\");\n+      fprintf_indent (f, indent, \"    %s = gimple_build (seq, TREE_CODE (%s),\"\n+\t\t                 \" TREE_TYPE (%s), TREE_OPERAND (%s, 0),\"\n+\t\t\t\t \" TREE_OPERAND (%s, 1));\\n\",\n+\t\t\t\t dest, dest, dest, dest, dest);\n+      fprintf_indent (f, indent, \"  }\\n\");\n+    }\n }\n \n /* Return the name of the operand representing the decision tree node.\n@@ -1989,7 +2033,7 @@ dt_operand::gen_opname (char *name, unsigned pos)\n    a predicate.  */\n \n unsigned\n-dt_operand::gen_predicate (FILE *f, const char *opname, bool gimple)\n+dt_operand::gen_predicate (FILE *f, int indent, const char *opname, bool gimple)\n {\n   predicate *p = as_a <predicate *> (op);\n \n@@ -1998,34 +2042,35 @@ dt_operand::gen_predicate (FILE *f, const char *opname, bool gimple)\n       /* If this is a predicate generated from a pattern mangle its\n \t name and pass on the valueize hook.  */\n       if (gimple)\n-\tfprintf (f, \"if (gimple_%s (%s, valueize))\\n\", p->p->id, opname);\n+\tfprintf_indent (f, indent, \"if (gimple_%s (%s, valueize))\\n\",\n+\t\t\tp->p->id, opname);\n       else\n-\tfprintf (f, \"if (tree_%s (%s))\\n\", p->p->id, opname);\n+\tfprintf_indent (f, indent, \"if (tree_%s (%s))\\n\", p->p->id, opname);\n     }\n   else\n-    fprintf (f, \"if (%s (%s))\\n\", p->p->id, opname);\n-  fprintf (f, \"{\\n\");\n+    fprintf_indent (f, indent, \"if (%s (%s))\\n\", p->p->id, opname);\n+  fprintf_indent (f, indent + 2, \"{\\n\");\n   return 1;\n }\n \n /* Generate matching code for the decision tree operand which is\n    a capture-match.  */\n \n unsigned\n-dt_operand::gen_match_op (FILE *f, const char *opname)\n+dt_operand::gen_match_op (FILE *f, int indent, const char *opname)\n {\n   char match_opname[20];\n   match_dop->get_name (match_opname);\n-  fprintf (f, \"if (%s == %s || operand_equal_p (%s, %s, 0))\\n\",\n-\t   opname, match_opname, opname, match_opname);\n-  fprintf (f, \"{\\n\");\n+  fprintf_indent (f, indent, \"if (%s == %s || operand_equal_p (%s, %s, 0))\\n\",\n+\t\t  opname, match_opname, opname, match_opname);\n+  fprintf_indent (f, indent + 2, \"{\\n\");\n   return 1;\n }\n \n /* Generate GIMPLE matching code for the decision tree operand.  */\n \n unsigned\n-dt_operand::gen_gimple_expr (FILE *f)\n+dt_operand::gen_gimple_expr (FILE *f, int indent)\n {\n   expr *e = static_cast<expr *> (op);\n   id_base *id = e->operation;\n@@ -2045,25 +2090,37 @@ dt_operand::gen_gimple_expr (FILE *f)\n \t      /* ???  If this is a memory operation we can't (and should not)\n \t\t match this.  The only sensible operand types are\n \t\t SSA names and invariants.  */\n-\t      fprintf (f, \"tree %s = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), %i);\\n\",\n-\t\t       child_opname, i);\n-\t      fprintf (f, \"if ((TREE_CODE (%s) == SSA_NAME\\n\"\n-\t\t       \"|| is_gimple_min_invariant (%s))\\n\"\n-\t\t       \"&& (%s = do_valueize (valueize, %s)))\\n\"\n-\t\t       \"{\\n\", child_opname, child_opname, child_opname,\n-\t\t       child_opname);\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"tree %s = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), %i);\\n\",\n+\t\t\t      child_opname, i);\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"if ((TREE_CODE (%s) == SSA_NAME\\n\",\n+\t\t\t      child_opname);\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"     || is_gimple_min_invariant (%s))\\n\",\n+\t\t\t      child_opname);\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"    && (%s = do_valueize (valueize, %s)))\\n\",\n+\t\t\t      child_opname, child_opname);\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"  {\\n\");\n+\t      indent += 4;\n \t      continue;\n \t    }\n \t  else\n-\t    fprintf (f, \"tree %s = gimple_assign_rhs%u (def_stmt);\\n\",\n-\t\t     child_opname, i + 1);\n+\t    fprintf_indent (f, indent,\n+\t\t\t    \"tree %s = gimple_assign_rhs%u (def_stmt);\\n\",\n+\t\t\t    child_opname, i + 1);\n \t}\n       else\n-\tfprintf (f, \"tree %s = gimple_call_arg (def_stmt, %u);\\n\",\n-\t\t child_opname, i);\n-      fprintf (f, \"if ((%s = do_valueize (valueize, %s)))\\n\",\n-\t       child_opname, child_opname);\n-      fprintf (f, \"{\\n\");\n+\tfprintf_indent (f, indent,\n+\t\t\t\"tree %s = gimple_call_arg (def_stmt, %u);\\n\",\n+\t\t\tchild_opname, i);\n+      fprintf_indent (f, indent,\n+\t\t      \"if ((%s = do_valueize (valueize, %s)))\\n\",\n+\t\t      child_opname, child_opname);\n+      fprintf_indent (f, indent, \"  {\\n\");\n+      indent += 4;\n     }\n   /* While the toplevel operands are canonicalized by the caller\n      after valueizing operands of sub-expressions we have to\n@@ -2079,9 +2136,12 @@ dt_operand::gen_gimple_expr (FILE *f)\n \t  char child_opname0[20], child_opname1[20];\n \t  gen_opname (child_opname0, 0);\n \t  gen_opname (child_opname1, 1);\n-\t  fprintf (f, \"if (tree_swap_operands_p (%s, %s, false))\\n\"\n-\t\t   \"  std::swap (%s, %s);\\n\", child_opname0, child_opname1,\n-\t\t   child_opname0, child_opname1);\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"if (tree_swap_operands_p (%s, %s, false))\\n\",\n+\t\t\t  child_opname0, child_opname1);\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"  std::swap (%s, %s);\\n\",\n+\t\t\t  child_opname0, child_opname1);\n \t}\n     }\n \n@@ -2091,7 +2151,7 @@ dt_operand::gen_gimple_expr (FILE *f)\n /* Generate GENERIC matching code for the decision tree operand.  */\n \n unsigned\n-dt_operand::gen_generic_expr (FILE *f, const char *opname)\n+dt_operand::gen_generic_expr (FILE *f, int indent, const char *opname)\n {\n   expr *e = static_cast<expr *> (op);\n   unsigned n_ops = e->ops.length ();\n@@ -2102,11 +2162,11 @@ dt_operand::gen_generic_expr (FILE *f, const char *opname)\n       gen_opname (child_opname, i);\n \n       if (e->operation->kind == id_base::CODE)\n-\tfprintf (f, \"tree %s = TREE_OPERAND (%s, %u);\\n\",\n-\t\t child_opname, opname, i);\n+\tfprintf_indent (f, indent, \"tree %s = TREE_OPERAND (%s, %u);\\n\",\n+\t\t\tchild_opname, opname, i);\n       else\n-\tfprintf (f, \"tree %s = CALL_EXPR_ARG (%s, %u);\\n\",\n-\t\t child_opname, opname, i);\n+\tfprintf_indent (f, indent, \"tree %s = CALL_EXPR_ARG (%s, %u);\\n\",\n+\t\t\tchild_opname, opname, i);\n     }\n \n   return 0;\n@@ -2115,7 +2175,7 @@ dt_operand::gen_generic_expr (FILE *f, const char *opname)\n /* Generate matching code for the children of the decision tree node.  */\n \n void\n-dt_node::gen_kids (FILE *f, bool gimple)\n+dt_node::gen_kids (FILE *f, int indent, bool gimple)\n {\n   auto_vec<dt_operand *> gimple_exprs;\n   auto_vec<dt_operand *> generic_exprs;\n@@ -2163,10 +2223,10 @@ dt_node::gen_kids (FILE *f, bool gimple)\n \t{\n \t  /* A DT_TRUE operand serves as a barrier - generate code now\n \t     for what we have collected sofar.  */\n-\t  gen_kids_1 (f, gimple, gimple_exprs, generic_exprs,\n+\t  gen_kids_1 (f, indent, gimple, gimple_exprs, generic_exprs,\n \t\t      fns, generic_fns, preds, others);\n \t  /* And output the true operand itself.  */\n-\t  kids[i]->gen (f, gimple);\n+\t  kids[i]->gen (f, indent, gimple);\n \t  gimple_exprs.truncate (0);\n \t  generic_exprs.truncate (0);\n \t  fns.truncate (0);\n@@ -2179,14 +2239,14 @@ dt_node::gen_kids (FILE *f, bool gimple)\n     }\n \n   /* Generate code for the remains.  */\n-  gen_kids_1 (f, gimple, gimple_exprs, generic_exprs,\n+  gen_kids_1 (f, indent, gimple, gimple_exprs, generic_exprs,\n \t      fns, generic_fns, preds, others);\n }\n \n /* Generate matching code for the children of the decision tree node.  */\n \n void\n-dt_node::gen_kids_1 (FILE *f, bool gimple,\n+dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \t\t     vec<dt_operand *> gimple_exprs,\n \t\t     vec<dt_operand *> generic_exprs,\n \t\t     vec<dt_operand *> fns,\n@@ -2213,144 +2273,178 @@ dt_node::gen_kids_1 (FILE *f, bool gimple,\n       else\n \tgeneric_exprs[0]->get_name (kid_opname);\n \n-      fprintf (f, \"switch (TREE_CODE (%s))\\n\"\n-\t       \"{\\n\", kid_opname);\n+      fprintf_indent (f, indent, \"switch (TREE_CODE (%s))\\n\", kid_opname);\n+      fprintf_indent (f, indent, \"  {\\n\");\n+      indent += 4;\n     }\n \n   if (exprs_len || fns_len)\n     {\n-      fprintf (f, \"case SSA_NAME:\\n\");\n-      fprintf (f, \"if (do_valueize (valueize, %s) != NULL_TREE)\\n\", kid_opname);\n-      fprintf (f, \"{\\n\");\n-      fprintf (f, \"gimple def_stmt = SSA_NAME_DEF_STMT (%s);\\n\", kid_opname);\n-\n+      fprintf_indent (f, indent,\n+\t\t      \"case SSA_NAME:\\n\");\n+      fprintf_indent (f, indent,\n+\t\t      \"  if (do_valueize (valueize, %s) != NULL_TREE)\\n\",\n+\t\t      kid_opname);\n+      fprintf_indent (f, indent,\n+\t\t      \"    {\\n\");\n+      fprintf_indent (f, indent,\n+\t\t      \"      gimple def_stmt = SSA_NAME_DEF_STMT (%s);\\n\",\n+\t\t      kid_opname);\n+\n+      indent += 6;\n       if (exprs_len)\n \t{\n-\t  fprintf (f, \"if (is_gimple_assign (def_stmt))\\n\");\n-\t  fprintf (f, \"switch (gimple_assign_rhs_code (def_stmt))\\n\"\n-\t\t   \"{\\n\");\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"if (is_gimple_assign (def_stmt))\\n\");\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"  switch (gimple_assign_rhs_code (def_stmt))\\n\");\n+\t  indent += 4;\n+\t  fprintf_indent (f, indent, \"{\\n\");\n \t  for (unsigned i = 0; i < exprs_len; ++i)\n \t    {\n \t      expr *e = as_a <expr *> (gimple_exprs[i]->op);\n \t      id_base *op = e->operation;\n \t      if (*op == CONVERT_EXPR || *op == NOP_EXPR)\n-\t\tfprintf (f, \"CASE_CONVERT:\\n\");\n+\t\tfprintf_indent (f, indent, \"  CASE_CONVERT:\\n\");\n \t      else\n-\t\tfprintf (f, \"case %s:\\n\", op->id);\n-\t      fprintf (f, \"{\\n\");\n-\t      gimple_exprs[i]->gen (f, true);\n-\t      fprintf (f, \"break;\\n\"\n-\t\t       \"}\\n\");\n+\t\tfprintf_indent (f, indent, \"  case %s:\\n\", op->id);\n+\t      fprintf_indent (f, indent, \"    {\\n\");\n+\t      gimple_exprs[i]->gen (f, indent + 6, true);\n+\t      fprintf_indent (f, indent, \"      break;\\n\");\n+\t      fprintf_indent (f, indent, \"    }\\n\");\n \t    }\n-\t  fprintf (f, \"default:;\\n\"\n-\t\t   \"}\\n\");\n+\t  fprintf_indent (f, indent, \"  default:;\\n\");\n+\t  indent -= 4;\n+\t  fprintf_indent (f, indent, \"}\\n\");\n \t}\n \n       if (fns_len)\n \t{\n \t  if (exprs_len)\n-\t    fprintf (f, \"else \");\n-\n-\t  fprintf (f, \"if (gimple_call_builtin_p (def_stmt, BUILT_IN_NORMAL))\\n\"\n-\t\t   \"{\\n\"\n-\t\t   \"tree fndecl = gimple_call_fndecl (def_stmt);\\n\"\n-\t\t   \"switch (DECL_FUNCTION_CODE (fndecl))\\n\"\n-\t\t   \"{\\n\");\n+\t    fprintf_indent (f, indent, \"else \");\n+\t  else\n+\t    fprintf_indent (f, indent, \" \");\n+\n+\t  fprintf (f, \"if (gimple_call_builtin_p (def_stmt, BUILT_IN_NORMAL))\\n\");\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"  {\\n\");\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"    tree fndecl = gimple_call_fndecl (def_stmt);\\n\");\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"    switch (DECL_FUNCTION_CODE (fndecl))\\n\");\n+\t  fprintf_indent (f, indent,\n+\t\t\t  \"      {\\n\");\n+\t  indent += 8;\n \n \t  for (unsigned i = 0; i < fns_len; ++i)\n \t    {\n \t      expr *e = as_a <expr *>(fns[i]->op);\n-\t      fprintf (f, \"case %s:\\n\"\n-\t\t       \"{\\n\", e->operation->id);\n-\t      fns[i]->gen (f, true);\n-\t      fprintf (f, \"break;\\n\"\n-\t\t       \"}\\n\");\n+\t      fprintf_indent (f, indent, \"case %s:\\n\", e->operation->id);\n+\t      fprintf_indent (f, indent, \"  {\\n\");\n+\t      fns[i]->gen (f, indent + 4, true);\n+\t      fprintf_indent (f, indent, \"    break;\\n\");\n+\t      fprintf_indent (f, indent, \"  }\\n\");\n \t    }\n \n-\t  fprintf (f, \"default:;\\n\"\n-\t\t   \"}\\n\"\n-\t\t   \"}\\n\");\n+\t  fprintf_indent (f, indent, \"default:;\\n\");\n+\t  indent -= 8;\n+\t  fprintf_indent (f, indent, \"      }\\n\");\n+\t  fprintf_indent (f, indent, \"  }\\n\");\n \t}\n \n-      fprintf (f, \"}\\n\"\n-\t       \"break;\\n\");\n+      indent -= 6;\n+      fprintf_indent (f, indent, \"    }\\n\");\n+      fprintf_indent (f, indent, \"  break;\\n\");\n     }\n \n   for (unsigned i = 0; i < generic_exprs.length (); ++i)\n     {\n       expr *e = as_a <expr *>(generic_exprs[i]->op);\n       id_base *op = e->operation;\n       if (*op == CONVERT_EXPR || *op == NOP_EXPR)\n-\tfprintf (f, \"CASE_CONVERT:\\n\");\n+\tfprintf_indent (f, indent, \"CASE_CONVERT:\\n\");\n       else\n-\tfprintf (f, \"case %s:\\n\", op->id);\n-      fprintf (f, \"{\\n\");\n-      generic_exprs[i]->gen (f, gimple);\n-      fprintf (f, \"break;\\n\"\n-\t       \"}\\n\");\n+\tfprintf_indent (f, indent, \"case %s:\\n\", op->id);\n+      fprintf_indent (f, indent, \"  {\\n\");\n+      generic_exprs[i]->gen (f, indent + 4, gimple);\n+      fprintf_indent (f, indent, \"    break;\\n\");\n+      fprintf_indent (f, indent, \"  }\\n\");\n     }\n \n   if (gfns_len)\n     {\n-      fprintf (f, \"case CALL_EXPR:\\n\"\n-\t       \"{\\n\"\n-\t       \"tree fndecl = get_callee_fndecl (%s);\\n\"\n-\t       \"if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\\n\"\n-\t       \"switch (DECL_FUNCTION_CODE (fndecl))\\n\"\n-\t       \"{\\n\", kid_opname);\n+      fprintf_indent (f, indent,\n+\t\t      \"case CALL_EXPR:\\n\");\n+      fprintf_indent (f, indent,\n+\t\t      \"  {\\n\");\n+      fprintf_indent (f, indent,\n+\t\t      \"    tree fndecl = get_callee_fndecl (%s);\\n\",\n+\t\t      kid_opname);\n+      fprintf_indent (f, indent,\n+\t\t      \"    if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\\n\");\n+      fprintf_indent (f, indent,\n+\t\t      \"      switch (DECL_FUNCTION_CODE (fndecl))\\n\");\n+      fprintf_indent (f, indent,\n+\t\t      \"        {\\n\");\n+      indent += 10;\n \n       for (unsigned j = 0; j < generic_fns.length (); ++j)\n \t{\n \t  expr *e = as_a <expr *>(generic_fns[j]->op);\n \t  gcc_assert (e->operation->kind == id_base::FN);\n \n-\t  fprintf (f, \"case %s:\\n\"\n-\t\t   \"{\\n\", e->operation->id);\n-\t  generic_fns[j]->gen (f, false);\n-\t  fprintf (f, \"break;\\n\"\n-\t\t   \"}\\n\");\n+\t  fprintf_indent (f, indent, \"case %s:\\n\", e->operation->id);\n+\t  fprintf_indent (f, indent, \"  {\\n\");\n+\t  generic_fns[j]->gen (f, indent + 4, false);\n+\t  fprintf_indent (f, indent, \"    break;\\n\");\n+\t  fprintf_indent (f, indent, \"  }\\n\");\n \t}\n \n-      fprintf (f, \"default:;\\n\"\n-\t       \"}\\n\"\n-\t       \"break;\\n\"\n-\t       \"}\\n\");\n+      indent -= 10;\n+      fprintf_indent (f, indent, \"          default:;\\n\");\n+      fprintf_indent (f, indent, \"        }\\n\");\n+      fprintf_indent (f, indent, \"    break;\\n\");\n+      fprintf_indent (f, indent, \"  }\\n\");\n     }\n \n   /* Close switch (TREE_CODE ()).  */\n   if (exprs_len || fns_len || gexprs_len || gfns_len)\n-    fprintf (f, \"default:;\\n\"\n-\t     \"}\\n\");\n+    {\n+      indent -= 4;\n+      fprintf_indent (f, indent, \"    default:;\\n\");\n+      fprintf_indent (f, indent, \"  }\\n\");\n+    }\n \n   for (unsigned i = 0; i < preds.length (); ++i)\n     {\n       expr *e = as_a <expr *> (preds[i]->op);\n       predicate_id *p = as_a <predicate_id *> (e->operation);\n       preds[i]->get_name (kid_opname);\n-      fprintf (f, \"tree %s_pops[%d];\\n\", kid_opname, p->nargs);\n-      fprintf (f, \"if (%s_%s (%s, %s_pops%s))\\n\",\n+      fprintf_indent (f, indent, \"tree %s_pops[%d];\\n\", kid_opname, p->nargs);\n+      fprintf_indent (f, indent, \"if (%s_%s (%s, %s_pops%s))\\n\",\n \t       gimple ? \"gimple\" : \"tree\",\n \t       p->id, kid_opname, kid_opname,\n \t       gimple ? \", valueize\" : \"\");\n-      fprintf (f, \"{\\n\");\n+      fprintf_indent (f, indent, \"  {\\n\");\n       for (int j = 0; j < p->nargs; ++j)\n \t{\n \t  char child_opname[20];\n \t  preds[i]->gen_opname (child_opname, j);\n-\t  fprintf (f, \"tree %s = %s_pops[%d];\\n\", child_opname, kid_opname, j);\n+\t  fprintf_indent (f, indent + 4, \"tree %s = %s_pops[%d];\\n\",\n+\t\t\t  child_opname, kid_opname, j);\n \t}\n-      preds[i]->gen_kids (f, gimple);\n+      preds[i]->gen_kids (f, indent + 4, gimple);\n       fprintf (f, \"}\\n\");\n     }\n \n   for (unsigned i = 0; i < others.length (); ++i)\n-    others[i]->gen (f, gimple);\n+    others[i]->gen (f, indent, gimple);\n }\n \n /* Generate matching code for the decision tree operand.  */\n \n void\n-dt_operand::gen (FILE *f, bool gimple)\n+dt_operand::gen (FILE *f, int indent, bool gimple)\n {\n   char opname[20];\n   get_name (opname);\n@@ -2361,14 +2455,14 @@ dt_operand::gen (FILE *f, bool gimple)\n     switch (op->type)\n       {\n \tcase operand::OP_PREDICATE:\n-\t  n_braces = gen_predicate (f, opname, gimple);\n+\t  n_braces = gen_predicate (f, indent, opname, gimple);\n \t  break;\n \n \tcase operand::OP_EXPR:\n \t  if (gimple)\n-\t    n_braces = gen_gimple_expr (f);\n+\t    n_braces = gen_gimple_expr (f, indent);\n \t  else\n-\t    n_braces = gen_generic_expr (f, opname);\n+\t    n_braces = gen_generic_expr (f, indent, opname);\n \t  break;\n \n \tdefault:\n@@ -2377,14 +2471,20 @@ dt_operand::gen (FILE *f, bool gimple)\n   else if (type == DT_TRUE)\n     ;\n   else if (type == DT_MATCH)\n-    n_braces = gen_match_op (f, opname);\n+    n_braces = gen_match_op (f, indent, opname);\n   else\n     gcc_unreachable ();\n \n-  gen_kids (f, gimple);\n+  indent += 4 * n_braces;\n+  gen_kids (f, indent, gimple);\n \n   for (unsigned i = 0; i < n_braces; ++i)\n-    fprintf (f, \"}\\n\");\n+    {\n+      indent -= 4;\n+      if (indent < 0)\n+\tindent = 0;\n+      fprintf_indent (f, indent, \"  }\\n\");\n+    }\n }\n \n \n@@ -2394,19 +2494,21 @@ dt_operand::gen (FILE *f, bool gimple)\n    that is not part of the decision tree (simplify->match).  */\n \n void\n-dt_simplify::gen (FILE *f, bool gimple)\n+dt_simplify::gen (FILE *f, int indent, bool gimple)\n {\n-  fprintf (f, \"{\\n\");\n+  fprintf_indent (f, indent, \"{\\n\");\n+  indent += 2;\n   output_line_directive (f, s->result_location);\n   if (s->capture_max >= 0)\n-    fprintf (f, \"tree captures[%u] ATTRIBUTE_UNUSED = {};\\n\",\n-\t     s->capture_max + 1);\n+    fprintf_indent (f, indent, \"tree captures[%u] ATTRIBUTE_UNUSED = {};\\n\",\n+\t\t    s->capture_max + 1);\n \n   for (int i = 0; i <= s->capture_max; ++i)\n     if (indexes[i])\n       {\n \tchar opname[20];\n-\tfprintf (f, \"captures[%u] = %s;\\n\", i, indexes[i]->get_name (opname));\n+\tfprintf_indent (f, indent, \"captures[%u] = %s;\\n\",\n+\t\t\ti, indexes[i]->get_name (opname));\n       }\n \n   unsigned n_braces = 0;\n@@ -2417,18 +2519,19 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t  if_or_with &w = s->ifexpr_vec[i];\n \t  if (w.is_with)\n \t    {\n-\t      fprintf (f, \"{\\n\");\n+\t      fprintf_indent (f, indent, \"{\\n\");\n+\t      indent += 4;\n \t      output_line_directive (f, w.location);\n-\t      w.cexpr->gen_transform (f, NULL, true, 1, \"type\", NULL);\n+\t      w.cexpr->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n \t      n_braces++;\n \t    }\n \t  else\n \t    {\n \t      output_line_directive (f, w.location);\n-\t      fprintf (f, \"if (\");\n+\t      fprintf_indent (f, indent, \"if (\");\n \t      if (i == s->ifexpr_vec.length () - 1\n \t\t  || s->ifexpr_vec[i+1].is_with)\n-\t\tw.cexpr->gen_transform (f, NULL, true, 1, \"type\", NULL);\n+\t\tw.cexpr->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n \t      else\n \t\t{\n \t\t  unsigned j = i;\n@@ -2438,10 +2541,10 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t\t\t{\n \t\t\t  fprintf (f, \"\\n\");\n \t\t\t  output_line_directive (f, s->ifexpr_vec[j].location);\n-\t\t\t  fprintf (f, \"&& \");\n+\t\t\t  fprintf_indent (f, indent + 4, \"&& \");\n \t\t\t}\n \t\t      fprintf (f, \"(\");\n-\t\t      s->ifexpr_vec[j].cexpr->gen_transform (f, NULL,\n+\t\t      s->ifexpr_vec[j].cexpr->gen_transform (f, 0, NULL,\n \t\t\t\t\t\t\t     true, 1, \"type\",\n \t\t\t\t\t\t\t     NULL);\n \t\t      fprintf (f, \")\");\n@@ -2454,7 +2557,8 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t      fprintf (f, \")\\n\");\n \t    }\n \t}\n-      fprintf (f, \"{\\n\");\n+      fprintf_indent (f, indent + 2, \"{\\n\");\n+      indent += 4;\n       n_braces++;\n     }\n \n@@ -2470,15 +2574,18 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t{\n \t  for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n \t    if (cinfo.force_no_side_effects & (1 << i))\n-\t      fprintf (f, \"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\", i);\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\",\n+\t\t\t      i);\n \t  for (int i = 0; i <= s->capture_max; ++i)\n \t    if (cinfo.info[i].cse_p)\n \t      ;\n \t    else if (cinfo.info[i].force_no_side_effects_p\n \t\t     && (cinfo.info[i].toplevel_msk\n \t\t\t & cinfo.force_no_side_effects) == 0)\n-\t      fprintf (f, \"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n-\t\t       \"return NULL_TREE;\\n\", i);\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n+\t\t\t      \"return NULL_TREE;\\n\", i);\n \t    else if ((cinfo.info[i].toplevel_msk\n \t\t      & cinfo.force_no_side_effects) != 0)\n \t      /* Mark capture as having no side-effects if we had to verify\n@@ -2489,28 +2596,33 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t{\n \t  /* Force single-use restriction by only allowing simple\n \t     results via setting seq to NULL.  */\n-\t  fprintf (f, \"gimple_seq *lseq = seq;\\n\");\n+\t  fprintf_indent (f, indent, \"gimple_seq *lseq = seq;\\n\");\n \t  bool first_p = true;\n \t  for (int i = 0; i <= s->capture_max; ++i)\n \t    if (cinfo.info[i].force_single_use)\n \t      {\n \t\tif (first_p)\n \t\t  {\n-\t\t    fprintf (f, \"if (lseq\\n\"\n-\t\t\t     \"&& (\");\n+\t\t    fprintf_indent (f, indent, \"if (lseq\\n\");\n+\t\t    fprintf_indent (f, indent, \"    && (\");\n \t\t    first_p = false;\n \t\t  }\n \t\telse\n-\t\t  fprintf (f, \"\\n|| \");\n+\t\t  {\n+\t\t    fprintf (f, \"\\n\");\n+\t\t    fprintf_indent (f, indent, \"        || \");\n+\t\t  }\n \t\tfprintf (f, \"!single_use (captures[%d])\", i);\n \t      }\n \t  if (!first_p)\n-\t    fprintf (f, \"))\\n\"\n-\t\t     \"lseq = NULL;\\n\");\n+\t    {\n+\t      fprintf (f, \"))\\n\");\n+\t      fprintf_indent (f, indent, \"  lseq = NULL;\\n\");\n+\t    }\n \t}\n     }\n \n-  fprintf (f, \"if (dump_file && (dump_flags & TDF_DETAILS)) \"\n+  fprintf_indent (f, indent, \"if (dump_file && (dump_flags & TDF_DETAILS)) \"\n \t   \"fprintf (dump_file, \\\"Applying pattern \");\n   output_line_directive (f, s->result_location, true);\n   fprintf (f, \", %%s:%%d\\\\n\\\", __FILE__, __LINE__);\\n\");\n@@ -2519,7 +2631,7 @@ dt_simplify::gen (FILE *f, bool gimple)\n   if (!result)\n     {\n       /* If there is no result then this is a predicate implementation.  */\n-      fprintf (f, \"return true;\\n\");\n+      fprintf_indent (f, indent, \"return true;\\n\");\n     }\n   else if (gimple)\n     {\n@@ -2533,18 +2645,17 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t  expr *e = as_a <expr *> (result);\n \t  bool is_predicate = is_a <predicate_id *> (e->operation);\n \t  if (!is_predicate)\n-\t    fprintf (f, \"*res_code = %s;\\n\",\n-\t\t     *e->operation == CONVERT_EXPR\n-\t\t     ? \"NOP_EXPR\" : e->operation->id);\n+\t    fprintf_indent (f, indent, \"*res_code = %s;\\n\",\n+\t\t\t    *e->operation == CONVERT_EXPR\n+\t\t\t    ? \"NOP_EXPR\" : e->operation->id);\n \t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t    {\n \t      char dest[32];\n-\t      snprintf (dest, 32, \"  res_ops[%d]\", j);\n+\t      snprintf (dest, 32, \"res_ops[%d]\", j);\n \t      const char *optype\n \t\t= get_operand_type (e->operation,\n \t\t\t\t    \"type\", e->expr_type,\n-\t\t\t\t    j == 0\n-\t\t\t\t    ? NULL : \"TREE_TYPE (res_ops[0])\");\n+\t\t\t\t    j == 0 ? NULL : \"TREE_TYPE (res_ops[0])\");\n \t      /* We need to expand GENERIC conditions we captured from\n \t         COND_EXPRs.  */\n \t      bool expand_generic_cond_exprs_p\n@@ -2555,38 +2666,46 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t\t   && ((!(*e->operation == COND_EXPR)\n \t\t\t&& !(*e->operation == VEC_COND_EXPR))\n \t\t       || j != 0));\n-\t      e->ops[j]->gen_transform (f, dest, true, 1, optype, &cinfo,\n+\t      e->ops[j]->gen_transform (f, indent, dest, true, 1, optype,\n+\t\t\t\t\t&cinfo,\n \t\t\t\t\tindexes, expand_generic_cond_exprs_p);\n \t    }\n \n \t  /* Re-fold the toplevel result.  It's basically an embedded\n \t     gimple_build w/o actually building the stmt.  */\n \t  if (!is_predicate)\n-\t    fprintf (f, \"gimple_resimplify%d (lseq, res_code, type, \"\n-\t\t     \"res_ops, valueize);\\n\", e->ops.length ());\n+\t    fprintf_indent (f, indent,\n+\t\t\t    \"gimple_resimplify%d (lseq, res_code, type, \"\n+\t\t\t    \"res_ops, valueize);\\n\", e->ops.length ());\n \t}\n       else if (result->type == operand::OP_CAPTURE\n \t       || result->type == operand::OP_C_EXPR)\n \t{\n-\t  result->gen_transform (f, \"res_ops[0]\", true, 1, \"type\",\n+\t  result->gen_transform (f, indent, \"res_ops[0]\", true, 1, \"type\",\n \t\t\t\t &cinfo, indexes, false);\n-\t  fprintf (f, \"*res_code = TREE_CODE (res_ops[0]);\\n\");\n+\t  fprintf_indent (f, indent, \"*res_code = TREE_CODE (res_ops[0]);\\n\");\n \t  if (is_a <capture *> (result)\n \t      && cinfo.info[as_a <capture *> (result)->where].cond_expr_cond_p)\n \t    {\n \t      /* ???  Stupid tcc_comparison GENERIC trees in COND_EXPRs.  Deal\n \t\t with substituting a capture of that.  */\n-\t      fprintf (f, \"if (COMPARISON_CLASS_P (res_ops[0]))\\n\"\n-\t\t       \"  {\\n\"\n-\t\t       \"    tree tem = res_ops[0];\\n\"\n-\t\t       \"    res_ops[0] = TREE_OPERAND (tem, 0);\\n\"\n-\t\t       \"    res_ops[1] = TREE_OPERAND (tem, 1);\\n\"\n-\t\t       \"  }\\n\");\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"if (COMPARISON_CLASS_P (res_ops[0]))\\n\");\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"  {\\n\");\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"    tree tem = res_ops[0];\\n\");\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"    res_ops[0] = TREE_OPERAND (tem, 0);\\n\");\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"    res_ops[1] = TREE_OPERAND (tem, 1);\\n\");\n+\t      fprintf_indent (f, indent,\n+\t\t\t      \"  }\\n\");\n \t    }\n \t}\n       else\n \tgcc_unreachable ();\n-      fprintf (f, \"return true;\\n\");\n+      fprintf_indent (f, indent, \"return true;\\n\");\n     }\n   else /* GENERIC */\n     {\n@@ -2602,9 +2721,14 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t      {\n \t\tif (!cinfo.info[i].force_no_side_effects_p\n \t\t    && cinfo.info[i].result_use_count > 1)\n-\t\t  fprintf (f, \"  if (TREE_SIDE_EFFECTS (captures[%d]))\\n\"\n-\t\t\t   \"    captures[%d] = save_expr (captures[%d]);\\n\",\n-\t\t\t   i, i, i);\n+\t\t  {\n+\t\t    fprintf_indent (f, indent,\n+\t\t\t\t    \"if (TREE_SIDE_EFFECTS (captures[%d]))\\n\",\n+\t\t\t\t    i);\n+\t\t    fprintf_indent (f, indent,\n+\t\t\t\t    \"  captures[%d] = save_expr (captures[%d]);\\n\",\n+\t\t\t\t    i, i);\n+\t\t  }\n \t      }\n \t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t    {\n@@ -2613,38 +2737,41 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t\tsnprintf (dest, 32, \"res_ops[%d]\", j);\n \t      else\n \t\t{\n-\t\t  fprintf (f, \"   tree res_op%d;\\n\", j);\n-\t\t  snprintf (dest, 32, \"  res_op%d\", j);\n+\t\t  fprintf_indent (f, indent, \"tree res_op%d;\\n\", j);\n+\t\t  snprintf (dest, 32, \"res_op%d\", j);\n \t\t}\n \t      const char *optype\n \t        = get_operand_type (e->operation,\n \t\t\t\t    \"type\", e->expr_type,\n \t\t\t\t    j == 0\n \t\t\t\t    ? NULL : \"TREE_TYPE (res_op0)\");\n-\t      e->ops[j]->gen_transform (f, dest, false, 1, optype,\n+\t      e->ops[j]->gen_transform (f, indent, dest, false, 1, optype,\n \t\t\t\t\t&cinfo, indexes);\n \t    }\n \t  if (is_predicate)\n-\t    fprintf (f, \"return true;\\n\");\n+\t    fprintf_indent (f, indent, \"return true;\\n\");\n \t  else\n \t    {\n-\t      fprintf (f, \"  tree res;\\n\");\n+\t      fprintf_indent (f, indent, \"tree res;\\n\");\n \t      /* Re-fold the toplevel result.  Use non_lvalue to\n \t         build NON_LVALUE_EXPRs so they get properly\n \t\t ignored when in GIMPLE form.  */\n \t      if (*e->operation == NON_LVALUE_EXPR)\n-\t\tfprintf (f, \"  res = non_lvalue_loc (loc, res_op0);\\n\");\n+\t\tfprintf_indent (f, indent,\n+\t\t\t\t\"res = non_lvalue_loc (loc, res_op0);\\n\");\n \t      else\n \t\t{\n \t\t  if (e->operation->kind == id_base::CODE)\n-\t\t    fprintf (f, \"  res = fold_build%d_loc (loc, %s, type\",\n-\t\t\t     e->ops.length (),\n-\t\t\t     *e->operation == CONVERT_EXPR\n-\t\t\t     ? \"NOP_EXPR\" : e->operation->id);\n+\t\t    fprintf_indent (f, indent,\n+\t\t\t\t    \"res = fold_build%d_loc (loc, %s, type\",\n+\t\t\t\t    e->ops.length (),\n+\t\t\t\t    *e->operation == CONVERT_EXPR\n+\t\t\t\t    ? \"NOP_EXPR\" : e->operation->id);\n \t\t  else\n-\t\t    fprintf (f, \"  res = build_call_expr_loc \"\n-\t\t\t     \"(loc, builtin_decl_implicit (%s), %d\",\n-\t\t\t     e->operation->id, e->ops.length());\n+\t\t    fprintf_indent (f, indent,\n+\t\t\t\t    \"res = build_call_expr_loc \"\n+\t\t\t\t    \"(loc, builtin_decl_implicit (%s), %d\",\n+\t\t\t\t    e->operation->id, e->ops.length());\n \t\t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t\t    fprintf (f, \", res_op%d\", j);\n \t\t  fprintf (f, \");\\n\");\n@@ -2655,8 +2782,8 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t       || result->type == operand::OP_C_EXPR)\n \n \t{\n-\t  fprintf (f, \"  tree res;\\n\");\n-\t  s->result->gen_transform (f, \" res\", false, 1, \"type\",\n+\t  fprintf_indent (f, indent, \"tree res;\\n\");\n+\t  s->result->gen_transform (f, indent, \"res\", false, 1, \"type\",\n \t\t\t\t    &cinfo, indexes);\n \t}\n       else\n@@ -2670,19 +2797,28 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t      if (!cinfo.info[i].force_no_side_effects_p\n \t\t  && !cinfo.info[i].expr_p\n \t\t  && cinfo.info[i].result_use_count == 0)\n-\t\tfprintf (f, \"  if (TREE_SIDE_EFFECTS (captures[%d]))\\n\"\n-\t\t\t \"    res = build2_loc (loc, COMPOUND_EXPR, type,\"\n-\t\t\t \" fold_ignored_result (captures[%d]), res);\\n\",\n-\t\t\t i, i);\n+\t\t{\n+\t\t  fprintf_indent (f, indent,\n+\t\t\t\t  \"if (TREE_SIDE_EFFECTS (captures[%d]))\\n\",\n+\t\t\t\t  i);\n+\t\t  fprintf_indent (f, indent + 2,\n+\t\t\t\t  \"res = build2_loc (loc, COMPOUND_EXPR, type, \"\n+\t\t\t\t  \"fold_ignored_result (captures[%d]), res);\\n\",\n+\t\t\t\t  i);\n+\t\t}\n \t    }\n-\t  fprintf (f, \"  return res;\\n\");\n+\t  fprintf_indent (f, indent, \"return res;\\n\");\n \t}\n     }\n \n   for (unsigned i = 0; i < n_braces; ++i)\n-    fprintf (f, \"}\\n\");\n+    {\n+      fprintf_indent (f, indent - 2, \"}\\n\");\n+      indent -= 4;\n+    }\n \n-  fprintf (f, \"}\\n\");\n+  indent -= 2;\n+  fprintf_indent (f, indent, \"}\\n\");\n }\n \n /* Main entry to generate code for matching GIMPLE IL off the decision\n@@ -2702,8 +2838,8 @@ decision_tree::gen_gimple (FILE *f)\n       fprintf (f, \")\\n\");\n       fprintf (f, \"{\\n\");\n \n-      fprintf (f, \"switch (code.get_rep())\\n\"\n-\t       \"{\\n\");\n+      fprintf (f, \"  switch (code.get_rep())\\n\"\n+\t          \"    {\\n\");\n       for (unsigned i = 0; i < root->kids.length (); i++)\n \t{\n \t  dt_operand *dop = static_cast<dt_operand *>(root->kids[i]);\n@@ -2713,20 +2849,20 @@ decision_tree::gen_gimple (FILE *f)\n \n \t  if (*e->operation == CONVERT_EXPR\n \t      || *e->operation == NOP_EXPR)\n-\t    fprintf (f, \"CASE_CONVERT:\\n\");\n+\t    fprintf (f, \"      CASE_CONVERT:\\n\");\n \t  else\n-\t    fprintf (f, \"case %s%s:\\n\",\n+\t    fprintf (f, \"      case %s%s:\\n\",\n \t\t     is_a <fn_id *> (e->operation) ? \"-\" : \"\",\n \t\t     e->operation->id);\n-\t  fprintf (f, \"{\\n\");\n-\t  dop->gen_kids (f, true);\n-\t  fprintf (f, \"break;\\n\");\n-\t  fprintf (f, \"}\\n\");\n+\t  fprintf (f,   \"        {\\n\");\n+\t  dop->gen_kids (f, 10, true);\n+\t  fprintf (f,   \"          break;\\n\");\n+\t  fprintf (f,   \"        }\\n\");\n \t}\n-      fprintf (f, \"default:;\\n\"\n-\t       \"}\\n\");\n+      fprintf (f,       \"      default:;\\n\"\n+\t                \"    }\\n\");\n \n-      fprintf (f, \"return false;\\n\");\n+      fprintf (f, \"  return false;\\n\");\n       fprintf (f, \"}\\n\");\n     }\n }\n@@ -2747,8 +2883,8 @@ decision_tree::gen_generic (FILE *f)\n       fprintf (f, \")\\n\");\n       fprintf (f, \"{\\n\");\n \n-      fprintf (f, \"switch (code)\\n\"\n-\t       \"{\\n\");\n+      fprintf (f, \"  switch (code)\\n\"\n+\t          \"    {\\n\");\n       for (unsigned i = 0; i < root->kids.length (); i++)\n \t{\n \t  dt_operand *dop = static_cast<dt_operand *>(root->kids[i]);\n@@ -2763,18 +2899,18 @@ decision_tree::gen_generic (FILE *f)\n \n \t  operator_id *op_id = static_cast <operator_id *> (e->operation);\n \t  if (op_id->code == NOP_EXPR || op_id->code == CONVERT_EXPR)\n-\t    fprintf (f, \"CASE_CONVERT:\\n\");\n+\t    fprintf (f, \"      CASE_CONVERT:\\n\");\n \t  else\n-\t    fprintf (f, \"case %s:\\n\", e->operation->id);\n-\t  fprintf (f, \"{\\n\");\n-\t  dop->gen_kids (f, false);\n-\t  fprintf (f, \"break;\\n\"\n-\t\t   \"}\\n\");\n+\t    fprintf (f, \"      case %s:\\n\", e->operation->id);\n+\t  fprintf (f,   \"        {\\n\");\n+\t  dop->gen_kids (f, 10, false);\n+\t  fprintf (f,   \"          break;\\n\"\n+\t\t        \"        }\\n\");\n \t}\n-      fprintf (f, \"default:;\\n\"\n-\t       \"}\\n\");\n+      fprintf (f, \"      default:;\\n\"\n+\t          \"    }\\n\");\n \n-      fprintf (f, \"return NULL_TREE;\\n\");\n+      fprintf (f, \"  return NULL_TREE;\\n\");\n       fprintf (f, \"}\\n\");\n     }\n }\n@@ -2790,13 +2926,13 @@ write_predicate (FILE *f, predicate_id *p, decision_tree &dt, bool gimple)\n \t   p->nargs > 0 ? \", tree *res_ops\" : \"\",\n \t   gimple ? \", tree (*valueize)(tree)\" : \"\");\n   /* Conveniently make 'type' available.  */\n-  fprintf (f, \"tree type = TREE_TYPE (t);\\n\");\n+  fprintf_indent (f, 2, \"tree type = TREE_TYPE (t);\\n\");\n \n   if (!gimple)\n-    fprintf (f, \"if (TREE_SIDE_EFFECTS (t)) return false;\\n\");\n-  dt.root->gen_kids (f, gimple);\n+    fprintf_indent (f, 2, \"if (TREE_SIDE_EFFECTS (t)) return false;\\n\");\n+  dt.root->gen_kids (f, 2, gimple);\n \n-  fprintf (f, \"return false;\\n\"\n+  fprintf_indent (f, 2, \"return false;\\n\"\n \t   \"}\\n\");\n }\n "}]}