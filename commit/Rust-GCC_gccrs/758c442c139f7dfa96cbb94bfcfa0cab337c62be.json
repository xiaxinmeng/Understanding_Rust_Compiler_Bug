{"sha": "758c442c139f7dfa96cbb94bfcfa0cab337c62be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU4YzQ0MmMxMzlmN2RmYTk2Y2JiOTRiZmNmYTBjYWIzMzdjNjJiZQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2005-06-16T08:32:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:32:47Z"}, "message": "exp_ch4.adb (Expand_Allocator_Expression): When an initialized allocator's designated type is a class-wide type...\n\n2005-06-14  Gary Dismukes  <dismukes@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): When an initialized\n\tallocator's designated type is a class-wide type, and compiling for\n\tAda 2005, emit a run-time check that the accessibility level of the\n\ttype given in the allocator's expression is not deeper than the level\n\tof the allocator's access type.\n\n\t(Tagged_Membership): Modified to gives support to abstract interface\n\ttypes.\n\n\t* a-tags.ads, a-tags.adb (type Type_Specific_Data): Add component\n\tAccess_Level.\n\t(Descendant_Tag): New predefined function\n\t(Is_Descendant_At_Same_Level): New predefined function\n\t(Get_Access_Level): New private function\n\t(Set_Access_Level): New private procedure\n\t(IW_Membership): New function. Given the tag of an object and the tag\n\tassociated with an interface, evaluate if the object implements the\n\tinterface.\n\t(Register_Interface_Tag): New procedure used to initialize the table of\n\tinterfaces used by the IW_Membership function.\n\t(Set_Offset_To_Top): Initialize the Offset_To_Top field in the prologue\n\tof the dispatch table.\n\t(Inherit_TSD): Modified to copy the table of ancestor tags plus the\n\ttable of interfaces of the parent.\n\t(Expanded_Name): Raise Tag_Error if the passed tag equals No_Tag.\n\t(External_Tag): Raise Tag_Error if the passed tag equals No_Tag.\n\t(Parent_Tag): Return No_Tag in the case of a root-level tagged type,\n\tand raise Tag_Error if the passed tag equalis No_Tag, to conform with\n\tAda 2005 semantics for the new predefined function.\n\n\t* exp_attr.adb (Expand_N_Attribute, case Attribute_Input): Generate\n\tcall to Descendant_Tag rather than Internal_Tag.\n\t(Expand_N_Attribute, case Attribute_Output): Emit a check to ensure that\n\tthe accessibility level of the attribute's Item parameter is not deeper\n\tthan the level of the attribute's prefix type. Tag_Error is raised if\n\tthe check fails. The check is only emitted for Ada_05.\n\t(Find_Stream_Subprogram): If a TSS exists on the type itself for the\n\trequested stream attribute, use it.\n\t(Expand_N_Attribute_Reference): If the designated type is an interface\n\tthen rewrite the referenced object as a conversion to force the\n\tdisplacement of the pointer to the secondary dispatch table.\n\t(Expand_N_Attribute_Reference, case 'Constrained): Return false if this\n\tis a dereference of an object with a constrained partial view.\n\n\t* exp_ch5.adb (Expand_N_Return_Statement): When a function's result\n\ttype is a class-wide type, emit a run-time check that the accessibility\n\tlevel of the returned object is not deeper than the level of the\n\tfunction's master (only when compiling for Ada 2005).\n\n\t* exp_disp.ads, exp_disp.adb (Ada_Actions, Action_Is_Proc,\n\tAction_Nb_Arg): Add entries for new Get_Access_Level and\n\tSet_Access_Level routines in these tables.\n\t(Make_DT): Generate a call to set the accessibility level of the\n\ttagged type in its TSD.\n\t(Make_DT): Code cleanup. The functionality of generating all the\n\tsecondary dispatch tables has been moved to freeze_record_type.\n\t(Make_Abstract_Interface_DT): Minor code cleanup.\n\t(Set_All_DT_Position): Code cleanup. As part of the code cleanup\n\tthis subprogram implements a new algorithm that provides the\n\tsame functionality and it is more clear in case of primitives\n\tassociated with abstract interfaces.\n\t(Set_All_Interfaces_DTC_Entity): Removed. As part of the code\n\tclean up, the functionality of this subprogram is now provided\n\tby Set_All_DT_Position.\n\t(Write_DT): New subprogram: a debugging procedure designed to be called\n\twithin gdb to display the dispatch tables associated with a tagged\n\ttype.\n\t(Collect_All_Interfaces): New subprogram that collects the whole list\n\tof interfaces that are directly or indirectly implemented by a tagged\n\ttype.\n\t(Default_Prim_Op_Position): New subprogram that returns the fixed\n\tposition in the dispatch table of the default primitive operations.\n\t(Expand_Interface_Actuals): New subprogram to generate code that\n\tdisplaces all the actuals corresponding to class-wide interfaces to\n\treference the interface tag of the actual object.\n\t(Expand_Interface_Conversion): New subprogram. Reference the base of\n\tthe object to give access to the interface tag associated with the\n\tsecondary dispatch table.\n\t(Expand_Interface_Thunk): New subprogram that generates the code of the\n\tthunk. This is required for compatibility with the C+ ABI.\n\t(Make_Abstract_Interface_DT): New subprogram that generate the\n\tdeclarations for the secondary dispatch tables associated with an\n\tabstract interface.\n\t(Set_All_Interfaces_DTC_Entity): New subprogram that sets the DTC_Entity\n\tattribute for each primitive operation covering interface subprograms\n\t(Expand_Dispatching_Call, Fill_DT_Entry, Make_DT, Set_All_DT_Position):\n\tThese subprograms were upgraded to give support to abstract interfaces\n\n\t* rtsfind.ads (type RE_Id): Add RE_Descendant_Tag,\n\tRE_Is_Descendant_At_Same_Level, RE_Get_Access_Level, and\n\tRE_Set_Access_Level.\n\t(RE_Unit_Table): Add entries for new Ada.Tags operations.\n\tAdd support to call the followig new run-time subprograms:\n\tIW_Membership, Register_Interface_Tag, and Set_Offset_To_Top\n\n\t* sem_ch3.adb (Constant_Redeclaration): Allow a deferred constant to\n\tmatch its full declaration when both have an access definition with\n\tstatically matching designated subtypes.\n\t(Analyze_Component_Declaration): Delete commented out code that was\n\tincorrectly setting the scope of an anonymous access component's type.\n\t(Process_Discriminants): Set Is_Local_Anonymous_Access for the type of\n\tan access discriminant when the containing type is nonlimited.\n\t(Make_Incomplete_Type_Declaration): Create an incomplete type\n\tdeclaration for a record type that includes self-referential access\n\tcomponents.\n\t(Check_Anonymous_Access_Types): Before full analysis of a record type\n\tdeclaration, create anonymous access types for each self-referential\n\taccess component.\n\t(Analyze_Component_Declaration, Array_Type_Declaration): Indicate that\n\tan access component in this context is a Local_Anonymous_Access, for\n\tproper accessibility checks.\n\t(Access_Definition): Set properly the scope of the anonymous access type\n\tcreated for a stand-alone access object.\n\t(Find_Type_Of_Object): An object declaration may be given with an access\n\tdefinition.\n\t(Complete_Subprograms_Derivation): New subprogram used to complete\n\ttype derivation of private tagged types implementing interfaces.\n\tIn this case some interface primitives may have been overriden\n\twith the partial-view and, instead of re-calculating them, they\n\tare included in the list of primitive operations of the full-view.\n\t(Build_Derived_Record_Type): Modified to give support to private\n\ttypes implemening interfaces.\n\t(Access_Definition): Reject ALL on anonymous access types.\n\t(Build_Derived_Record_Type): In the case of Ada 2005, allow a tagged\n\ttype derivation to occur at a deeper accessibility level than the\n\tparent type.\n\tFor the case of derivation within a generic body however, disallow the\n\tderivation if the derived type has an ancestor that is a formal type\n\tdeclared in the formal part of an enclosing generic.\n\t(Analyze_Object_Declaration): For protected objects, remove the check\n\tthat they cannot contain interrupt handlers if not declared at library\n\tlevel.\n\t(Add_Interface_Tag_Components): New subprogram to add the tag components\n\tcorresponding to all the abstract interface types implemented by a\n\trecord type or a derived record type.\n\t(Analyze_Private_Extension_Declaration, Build_Derived_Record_Type,\n\tDerived_Type_Declaration, Find_Type_Name, Inherit_Components,\n\tProcess_Full_View, Record_Type_Declaration): Modified to give\n\tsupport to abstract interface types\n\t(Collect_Interfaces): New subprogram that collects the list of\n\tinterfaces that are not already implemented by the ancestors\n\t(Process_Full_View): Set flag Has_Partial_Constrained_View appropriately\n\twhen partial view has no discriminants and full view has defaults.\n\t(Constrain_Access): Reject a constraint on a general access type\n\tif the discriminants of the designated type have defaults.\n\t(Access_Subprogram_Declaration): Associate the Itype node with the inner\n\tfull-type declaration or subprogram spec. This is required to handle\n\tnested anonymous declarations.\n\t(Analyze_Private_Extension_Declaration, Build_Derived_Record_Type,\n\tDerived_Type_Declaration, Find_Type_Name, Inherit_Components,\n\tProcess_Full_View, Record_Type_Declaration): Modified to give\n\tsupport to abstract interface types\n\t(Derive_Subprograms): Addition of a new formal to indicate if\n\twe are in the case of an abstact-interface derivation\n\t(Find_Type_Of_Subtype_Indic): Moved from the body of the package\n\tto the specification because it is requied to analyze all the\n\tidentifiers found in a list of interfaces\n\n\t* debug.adb: Complete documentation of flag \"-gnatdZ\"\n\n\t* exp_ch3.adb: Implement config version of persistent_bss pragma\n\t(Check_Stream_Attributes): Use Stream_Attribute_Available instead of\n\ttesting for TSS presence to properly enforce visibility rules.\n\t(Freeze_Record_Type): Code cleanup. Modified to call the subprogram\n\tMake_Abstract_Interfaces_DT to generate the secondary tables\n\tassociated with abstract interfaces.\n\t(Build_Init_Procedure): Modified to initialize all the tags\n\tcorresponding.\n\t(Component_Needs_Simple_Initialization): Similar to other tags,\n\tinterface tags do not need initialization.\n\t(Freeze_Record_Type): Modified to give support to abstract interface\n\ttypes.\n\t(Expand_N_Object_Declaration): Do not generate an initialization for\n\ta scalar temporary marked as internal.\n\n\t* exp_ch6.adb (Add_Simple_Call_By_Copy_Code): Handle properly an\n\tin-out parameter that is a component in an initialization procedure,\n\twhose constraint might depend on discriminants, and that may be\n\tmisaligned because of packing or representation clauses.\n\t(Is_Legal_Copy): New predicate to determine whether a possibly\n\tmisaligned in-out actual can actually be passed by copy/return. This\n\tis an error in case the type is by_reference, and a warning if this is\n\tthe consequence of a DEC import pragma on the subprogram.\n\t(Expand_Call, Freeze_Subprogram): Modified to give support to abstract\n\tinterface types\n\t(Expand_Inlined_Call): Mark temporary generated for the return value as\n\tinternal, so that no useless scalar normalization is generated for it.\n\t(Expand_N_Subprogram_Declaration): Save unanalyzed body so calls to\n\tnull procedure can always be inlined.\n\t(Expand_N_Subprogram_Declaration): If this is the declaration of a null\n\tprocedure, generate an explicit empty body for it.\n\n\t* exp_util.ads, exp_util.adb (Find_Interface_ADT): New subprogram.\n\tGiven a type implementing an interface, returns the corresponding\n\taccess_disp_table value.\n\t(Find_Interface_Tag): New subprogram. Given a type implementing an\n\tinterface, returns the record component containing the tag of the\n\tinterface.\n\t(Find_Interface_Tag): New overloaded subprogram. Subsidiary to the\n\tprevious ones that return the corresponding tag and access_disp_table\n\tentities.\n\t(Is_Predefined_Dispatching_Operation): Determines if a subprogram\n\tis a predefined primitive operation.\n\t(Expand_Subtype_From_Expr): If the expression is a selected component\n\twithin an initialization procedure, compute its actual subtype, because\n\tthe component may depend on the discriminants of the enclosing record.\n\n\t* i-cpp.ads, i-cpp.adb:\n\tThis package has been left available for compatibility with previous\n\tversions of the frontend. As part of the new layout this is now a\n\tdummy package that uses declarations available at a-tags.ads\n\n\t* par-ch3.adb (P_Identifier_Declarations): Give an error for use of\n\t\"constant access\" and \"aliased [constant] access\" when not compiling\n\twith -gnat05.\n\tSuppress Ada 2005 keyword warning if -gnatwY used\n\t(P_Identifier_Declarations): Add support for object declarations with\n\taccess definitions.\n\t(Private_Extension_Declaration): Complete the documentation\n\t(P_Derived_Type_Def_Or_Private_Ext_Decl): Fill the inteface_list\n\tattribute in case of private extension declaration\n\t(P_Type_Declaration): Mark as \"abstract\" the type declarations\n\tcorresponding with protected, synchronized and task interfaces\n\t(P_Declarative_Items): \"not\" and \"overriding\" are overriding indicators\n\tfor a subprogram or instance declaration.\n\n\t* sem_ch12.adb (Analyze_Subprogram_Instantiation): Verify that an\n\tinstantiation that is a dispatching operation has controlling access\n\tparameters that are null excluding.\n\tSave and restore Ada_Version_Explicit, for implementation of AI-362\n\t(Validate_Derived_Type_Instance): Add check for abstract interface\n\ttypes.\n\t(Analyze_Formal_Package): Establish Instantiation source for the copy of\n\tthe generic that is created to represent the formal package.\n\t(Analyze_Package_Instantiation): Instantiate body immediately if the\n\tpackage is a predefined unit that contains inlined subprograms, and\n\twe are compiling for a Configurable_Run_Time.\n\t(Instantiate_Formal_Subprogram): Indicate that null default subprogram\n\tIf the program has a null default, generate an empty body for it.\n\n\t* sem_ch6.adb, sem_ch9.adb (Analyze_Subprograms_Declaration): Update\n\terror message condition, null procedures are correctly detected now.\n\t(New_Overloaded_Entity): Bypass trivial overriding indicator check\n\tfor subprograms in the context of protected types. Instead, the\n\tindicator is examined in Sem_Ch9 while analysing the subprogram\n\tdeclaration.\n\t(Check_Overriding_Indicator): Check consistency of overriding indicator\n\ton subprogram stubs as well.\n\t(Analyze_Subprogram_Declaration): Diagnose null procedures declared at\n\tthe library level.\n\t(Analize_Subprogram_Specification): When analyzing a subprogram in which\n\tthe type of the first formal is a concurrent type, replace this type\n\tby the corresponding record type.\n\t(Analyze_Subprogram_Body): Undo the previous work.\n\t(Analyze_Procedure_Call): If the call has the form Object.Op, the\n\tanalysis of the prefix ends up analyzing the call itself, after which\n\twe are done.\n\t(Has_Interface_Formals): New subprogram subsidiary to analyze\n\tsubprogram_specification that returns true if some non\n\tclass-wide interface subprogram is found\n\t(New_Overloaded_Entity): Modified to give support to abstract\n\tinterface types\n\t(Conforming_Types): In Ada 2005 mode, conformance checking of anonymous\n\taccess to subprograms must be recursive.\n\t(Is_Unchecked_Conversion): Improve the test that recognizes\n\tinstantiations of Unchecked_Conversion, and allows them in bodies that\n\tare to be inlined by the front-end. When the body comes from an\n\tinstantiation, a reference to Unchecked_Conversion will be an\n\tExpanded_Name, even though the body has not been analyzed yet.\n\tReplace Is_Overriding and Not_Overriding in subprogram_indication with\n\tMust_Override and Must_Not_Override, to better express intent of AI.\n\t(Analyze_Subprogram_Body): If an overriding indicator is given, check\n\tthat it is consistent with the overrinding status of the subprogram\n\tat this point.\n\t(Analyze_Subprogram_Declaration): Indicate that a null procedure is\n\talways inlined.\n\tIf the subprogram is a null procedure, indicate that it does not need\n\ta completion.\n\n\t* sem_disp.adb (Check_Controlling_Type): Give support to entities\n\tavailable through limited-with clauses.\n\t(Check_Dispatching_Operation): A stub acts like a body, and therefore is\n\tallowed as the last primitive of a tagged type if it has no previous\n\tspec.\n\t(Override_Dispatching_Operation, Check_Dispatching_Operation): Modified\n\tto give support to abstract interface types\n\n\t* sem_res.adb (Valid_Conversion): Perform an accessibility level check\n\tin the case where the target type is an anonymous access type of an\n\tobject or component (that is, when Is_Local_Anonymous_Access is true).\n\tPrevent the special checks for conversions of access discriminants in\n\tthe case where the discriminant belongs to a nonlimited type, since\n\tsuch discriminants have their accessibility level defined in the same\n\tway as a normal component of an anonymous access type.\n\t(Resolve_Allocator): When an allocator's designated type is a class-wide\n\ttype, check that the accessibility level of type given in the\n\tallocator's expression or subtype indication is not statically deeper\n\tthan the level of the allocator's access type.\n\t(Check_Discriminant_Use): Diagnose discriminant given by an expanded\n\tname in a discriminant constraint of a record component.\n\t(Resolve_Explicit_Dereference): Do not check whether the type is\n\tincomplete when the dereference is a use of an access discriminant in\n\tan initialization procedure.\n\t(Resolve_Type_Conversion): Handle conversions to abstract interface\n\ttypes.\n\t(Valid_Tagged_Conversion): The conversion of a tagged type to an\n\tabstract interface type is always valid.\n\t(Valid_Conversion): Modified to give support to abstract interface types\n\t(Resolve_Actuals): Enable full error reporting on view conversions\n\tbetween unrelated by_reference array types.\n\tThe rule for view conversions of arrays with aliased components is\n\tweakened in Ada 2005.\n\tCall to obsolescent subprogram is now considered to be a violation of\n\tpragma Restrictions (No_Obsolescent_Features).\n\t(Check_Direct_Boolean_Operator): If the boolean operation has been\n\tconstant-folded, there is nothing to check.\n\t(Resolve_Comparison_Op, Resolve_Equality_Op, Resolve_Boolean_Op): Defer\n\tcheck on possible violation of restriction No_Direct_Boolean_Operators\n\tuntil after expansion of operands, to prevent spurious errors when\n\toperation is constant-folded.\n\n\t* sem_type.ads, sem_type.adb (Covers, Intersect_Types, Specific_Type,\n\tHas_Compatible_Type): Modified to give support to abstract interface\n\ttypes.\n\t(Interface_Present_In_Ancestor): New function to theck if some ancestor\n\tof a given type implements a given interface\n\n\t* sem_ch4.adb (Analyze_Call): Handle properly an indirect call whose\n\tprefix is a parameterless function that returns an access_to_procedure.\n\t(Transform_Object_Operation): Handle properly function calls of the\n\tform Obj.Op (X), which prior to analysis appear as indexed components.\n\t(Analyze_One_Call): Complete the error notification to help new Ada\n\t2005 users.\n\t(Analyze_Allocator): For an allocator without an initial value, where\n\tthe designated type has a constrained partial view, a discriminant\n\tconstraint is illegal.\n\nFrom-SVN: r101024", "tree": {"sha": "59a6d971ec99b14088954383ecddf8339a1c0e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59a6d971ec99b14088954383ecddf8339a1c0e07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/758c442c139f7dfa96cbb94bfcfa0cab337c62be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/758c442c139f7dfa96cbb94bfcfa0cab337c62be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/758c442c139f7dfa96cbb94bfcfa0cab337c62be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/758c442c139f7dfa96cbb94bfcfa0cab337c62be/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ba5b393544f89748b24bd522b56ce62d38e2a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba5b393544f89748b24bd522b56ce62d38e2a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ba5b393544f89748b24bd522b56ce62d38e2a13"}], "stats": {"total": 7715, "additions": 6017, "deletions": 1698}, "files": [{"sha": "1899c6c302495fca9d8db1367dc88049945d6569", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 244, "deletions": 69, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                             A D A . T A G S                              --\n --                                                                          --\n@@ -33,6 +33,7 @@\n \n with Ada.Exceptions;\n with System.HTable;\n+with System.Storage_Elements; use System.Storage_Elements;\n \n pragma Elaborate_All (System.HTable);\n \n@@ -57,9 +58,15 @@ package body Ada.Tags is\n --                                          +-------------------+\n --                                          | Rec Ctrler offset |\n --                                          +-------------------+\n+--                                          |  Num_Interfaces   |\n+--                                          +-------------------+\n --                                          | table of          |\n --                                          :   ancestor        :\n --                                          |      tags         |\n+--                                          +-------------------+\n+--                                          | table of          |\n+--                                          |   interface       |\n+--                                          |      tags         |\n --                                          +-------------------+\n \n    subtype Cstring is String (Positive);\n@@ -71,32 +78,34 @@ package body Ada.Tags is\n    --  We suppress index checks because the declared size in the record below\n    --  is a dummy size of one (see below).\n \n-   type Wide_Boolean is new Boolean;\n-   --  This name should probably be changed sometime ??? and indeed probably\n-   --  this field could simply be of type Standard.Boolean.\n-\n    type Type_Specific_Data is record\n-      Idepth             : Natural;\n-      Expanded_Name      : Cstring_Ptr;\n-      External_Tag       : Cstring_Ptr;\n-      HT_Link            : Tag;\n-      Remotely_Callable  : Wide_Boolean;\n-      RC_Offset          : SSE.Storage_Offset;\n-      Ancestor_Tags      : Tag_Table (0 .. 1);\n+      Idepth            : Natural;\n+      Access_Level      : Natural;\n+      Expanded_Name     : Cstring_Ptr;\n+      External_Tag      : Cstring_Ptr;\n+      HT_Link           : Tag;\n+      Remotely_Callable : Boolean;\n+      RC_Offset         : SSE.Storage_Offset;\n+      Num_Interfaces    : Natural;\n+      Tags_Table        : Tag_Table (Natural);\n+\n+      --  The size of the Tags_Table array actually depends on the tagged type\n+      --  to which it applies. The compiler ensures that has enough space to\n+      --  store all the entries of the two tables phisically stored there: the\n+      --  \"table of ancestor tags\" and the \"table of interface tags\". For this\n+      --  purpose we are using the same mechanism as for the Prims_Ptr array in\n+      --  the Dispatch_Table record. See comments below for more details.\n+\n    end record;\n-   --  The size of the Ancestor_Tags array actually depends on the tagged type\n-   --  to which it applies. We are using the same mechanism as for the\n-   --  Prims_Ptr array in the Dispatch_Table record. See comments below for\n-   --  more details.\n \n    type Dispatch_Table is record\n-      --  Offset_To_Top : Integer := 0;\n+      --  Offset_To_Top : Natural;\n       --  Typeinfo_Ptr  : System.Address; -- Currently TSD is also here???\n-      Prims_Ptr    : Address_Array (Positive);\n+      Prims_Ptr : Address_Array (Positive);\n    end record;\n \n    --  Note on the commented out fields of the Dispatch_Table\n-   --  ------------------------------------------------------\n+   --\n    --  According to the C++ ABI the components Offset_To_Top and Typeinfo_Ptr\n    --  are stored just \"before\" the dispatch table (that is, the Prims_Ptr\n    --  table), and they are referenced with negative offsets referring to the\n@@ -106,7 +115,6 @@ package body Ada.Tags is\n    --  expander generates a Prims_Ptr table that has enough space for these\n    --  additional components, and generates code that displaces the _Tag to\n    --  point after these components.\n-   --  -----------------------------------------------------------------------\n \n    --  The size of the Prims_Ptr array actually depends on the tagged type to\n    --  which it applies. For each tagged type, the expander computes the\n@@ -131,20 +139,20 @@ package body Ada.Tags is\n    -- Unchecked Conversions for String Fields --\n    ---------------------------------------------\n \n-   function To_Cstring_Ptr is\n-     new Unchecked_Conversion (System.Address, Cstring_Ptr);\n-\n    function To_Address is\n      new Unchecked_Conversion (Cstring_Ptr, System.Address);\n \n-   -----------------------------------------------------------\n-   -- Unchecked Conversions for the component offset_to_top --\n-   -----------------------------------------------------------\n+   function To_Cstring_Ptr is\n+     new Unchecked_Conversion (System.Address, Cstring_Ptr);\n+\n+   ------------------------------------------------\n+   -- Unchecked Conversions for other components --\n+   ------------------------------------------------\n \n-   type Int_Ptr is access Integer;\n+   type Storage_Offset_Ptr is access System.Storage_Elements.Storage_Offset;\n \n-   function To_Int_Ptr is\n-      new Unchecked_Conversion (System.Address, Int_Ptr);\n+   function To_Storage_Offset_Ptr is\n+      new Unchecked_Conversion (System.Address, Storage_Offset_Ptr);\n \n    -----------------------\n    -- Local Subprograms --\n@@ -154,15 +162,15 @@ package body Ada.Tags is\n    --  Length of string represented by the given pointer (treating the string\n    --  as a C-style string, which is Nul terminated).\n \n-   function Offset_To_Top (T : Tag) return Integer;\n+   function Offset_To_Top\n+     (T : Tag) return System.Storage_Elements.Storage_Offset;\n    --  Returns the current value of the offset_to_top component available in\n    --  the prologue of the dispatch table.\n \n    function Typeinfo_Ptr (T : Tag) return System.Address;\n    --  Returns the current value of the typeinfo_ptr component available in\n    --  the prologue of the dispatch table.\n \n-   pragma Unreferenced (Offset_To_Top);\n    pragma Unreferenced (Typeinfo_Ptr);\n    --  These functions will be used for full compatibility with the C++ ABI\n \n@@ -266,8 +274,9 @@ package body Ada.Tags is\n \n    --     Obj in Typ'Class\n \n-   --  Each dispatch table contains a reference to a table of ancestors\n-   --  (Ancestor_Tags) and a count of the level of inheritance \"Idepth\" .\n+   --  Each dispatch table contains a reference to a table of ancestors (stored\n+   --  in the first part of the Tags_Table) and a count of the level of\n+   --  inheritance \"Idepth\".\n \n    --  Obj is in Typ'Class if Typ'Tag is in the table of ancestors that are\n    --  contained in the dispatch table referenced by Obj'Tag . Knowing the\n@@ -280,16 +289,79 @@ package body Ada.Tags is\n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean is\n       Pos : constant Integer := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n    begin\n-      return Pos >= 0 and then TSD (Obj_Tag).Ancestor_Tags (Pos) = Typ_Tag;\n+      return Pos >= 0 and then TSD (Obj_Tag).Tags_Table (Pos) = Typ_Tag;\n    end CW_Membership;\n \n+   -------------------\n+   -- IW_Membership --\n+   -------------------\n+\n+   --  Canonical implementation of Classwide Membership corresponding to:\n+\n+   --     Obj in Iface'Class\n+\n+   --  Each dispatch table contains a table with the tags of all the\n+   --  implemented interfaces.\n+\n+   --  Obj is in Iface'Class if Iface'Tag is found in the table of interfaces\n+   --  that are contained in the dispatch table referenced by Obj'Tag.\n+\n+   function IW_Membership\n+     (This      : System.Address;\n+      Iface_Tag : Tag) return Boolean\n+   is\n+      T        : constant Tag := To_Tag_Ptr (This).all;\n+      Obj_Base : constant System.Address := This - Offset_To_Top (T);\n+      T_Base   : constant Tag := To_Tag_Ptr (Obj_Base).all;\n+\n+      Obj_TSD  : constant Type_Specific_Data_Ptr := TSD (T_Base);\n+      Last_Id  : constant Natural := Obj_TSD.Idepth + Obj_TSD.Num_Interfaces;\n+      Id       : Natural;\n+\n+   begin\n+      if Obj_TSD.Num_Interfaces > 0 then\n+         Id := Obj_TSD.Idepth + 1;\n+         loop\n+            if Obj_TSD.Tags_Table (Id) = Iface_Tag then\n+               return True;\n+            end if;\n+\n+            Id := Id + 1;\n+            exit when Id > Last_Id;\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end IW_Membership;\n+\n+   --------------------\n+   -- Descendant_Tag --\n+   --------------------\n+\n+   function Descendant_Tag (External : String; Ancestor : Tag) return Tag is\n+      Int_Tag : constant Tag := Internal_Tag (External);\n+\n+   begin\n+      if not Is_Descendant_At_Same_Level (Int_Tag, Ancestor) then\n+         raise Tag_Error;\n+      end if;\n+\n+      return Int_Tag;\n+   end Descendant_Tag;\n+\n    -------------------\n    -- Expanded_Name --\n    -------------------\n \n    function Expanded_Name (T : Tag) return String is\n-      Result : constant Cstring_Ptr := TSD (T).Expanded_Name;\n+      Result : Cstring_Ptr;\n+\n    begin\n+      if T = No_Tag then\n+         raise Tag_Error;\n+      end if;\n+\n+      Result := TSD (T).Expanded_Name;\n       return Result (1 .. Length (Result));\n    end Expanded_Name;\n \n@@ -298,11 +370,26 @@ package body Ada.Tags is\n    ------------------\n \n    function External_Tag (T : Tag) return String is\n-      Result : constant Cstring_Ptr := TSD (T).External_Tag;\n+      Result : Cstring_Ptr;\n    begin\n+      if T = No_Tag then\n+         raise Tag_Error;\n+      end if;\n+\n+      Result := TSD (T).External_Tag;\n+\n       return Result (1 .. Length (Result));\n    end External_Tag;\n \n+   ----------------------\n+   -- Get_Access_Level --\n+   ----------------------\n+\n+   function Get_Access_Level (T : Tag) return Natural is\n+   begin\n+      return TSD (T).Access_Level;\n+   end Get_Access_Level;\n+\n    ----------------------\n    -- Get_External_Tag --\n    ----------------------\n@@ -318,8 +405,7 @@ package body Ada.Tags is\n \n    function Get_Prim_Op_Address\n      (T        : Tag;\n-      Position : Positive) return System.Address\n-   is\n+      Position : Positive) return System.Address is\n    begin\n       return T.Prims_Ptr (Position);\n    end Get_Prim_Op_Address;\n@@ -339,7 +425,7 @@ package body Ada.Tags is\n \n    function Get_Remotely_Callable (T : Tag) return Boolean is\n    begin\n-      return TSD (T).Remotely_Callable = True;\n+      return TSD (T).Remotely_Callable;\n    end Get_Remotely_Callable;\n \n    ----------------\n@@ -368,15 +454,23 @@ package body Ada.Tags is\n \n    begin\n       if Old_Tag /= null then\n-         Old_TSD_Ptr        := TSD (Old_Tag);\n+         Old_TSD_Ptr := TSD (Old_Tag);\n          New_TSD_Ptr.Idepth := Old_TSD_Ptr.Idepth + 1;\n-         New_TSD_Ptr.Ancestor_Tags (1 .. New_TSD_Ptr.Idepth) :=\n-           Old_TSD_Ptr.Ancestor_Tags (0 .. Old_TSD_Ptr.Idepth);\n+         New_TSD_Ptr.Num_Interfaces := Old_TSD_Ptr.Num_Interfaces;\n+\n+         --  Copy the \"table of ancestor tags\" plus the \"table of interfaces\"\n+         --  of the parent\n+\n+         New_TSD_Ptr.Tags_Table\n+           (1 .. New_TSD_Ptr.Idepth + New_TSD_Ptr.Num_Interfaces)\n+           := Old_TSD_Ptr.Tags_Table\n+                (0 .. Old_TSD_Ptr.Idepth + Old_TSD_Ptr.Num_Interfaces);\n       else\n-         New_TSD_Ptr.Idepth := 0;\n+         New_TSD_Ptr.Idepth         := 0;\n+         New_TSD_Ptr.Num_Interfaces := 0;\n       end if;\n \n-      New_TSD_Ptr.Ancestor_Tags (0) := New_Tag;\n+      New_TSD_Ptr.Tags_Table (0) := New_Tag;\n    end Inherit_TSD;\n \n    ------------------\n@@ -410,6 +504,19 @@ package body Ada.Tags is\n       return Res;\n    end Internal_Tag;\n \n+   ---------------------------------\n+   -- Is_Descendant_At_Same_Level --\n+   ---------------------------------\n+\n+   function Is_Descendant_At_Same_Level\n+     (Descendant : Tag;\n+      Ancestor   : Tag) return Boolean\n+   is\n+   begin\n+      return CW_Membership (Descendant, Ancestor)\n+        and then TSD (Descendant).Access_Level = TSD (Ancestor).Access_Level;\n+   end Is_Descendant_At_Same_Level;\n+\n    ------------\n    -- Length --\n    ------------\n@@ -425,6 +532,21 @@ package body Ada.Tags is\n       return Len - 1;\n    end Length;\n \n+   -------------------\n+   -- Offset_To_Top --\n+   -------------------\n+\n+   function Offset_To_Top\n+     (T : Tag) return System.Storage_Elements.Storage_Offset\n+   is\n+      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n+                            To_Storage_Offset_Ptr (To_Address (T)\n+                              - DT_Typeinfo_Ptr_Size\n+                              - DT_Offset_To_Top_Size);\n+   begin\n+      return Offset_To_Top_Ptr.all;\n+   end Offset_To_Top;\n+\n    -----------------\n    -- Parent_Size --\n    -----------------\n@@ -439,12 +561,12 @@ package body Ada.Tags is\n      (Obj : System.Address;\n       T   : Tag) return SSE.Storage_Count\n    is\n-      Parent_Tag : constant Tag := TSD (T).Ancestor_Tags (1);\n+      Parent_Tag : constant Tag := TSD (T).Tags_Table (1);\n       --  The tag of the parent type through the dispatch table\n \n       F : constant Acc_Size := To_Acc_Size (Parent_Tag.Prims_Ptr (1));\n       --  Access to the _size primitive of the parent. We assume that\n-      --  it is always in the first slot of the distatch table\n+      --  it is always in the first slot of the dispatch table\n \n    begin\n       --  Here we compute the size of the _parent field of the object\n@@ -458,9 +580,57 @@ package body Ada.Tags is\n \n    function Parent_Tag (T : Tag) return Tag is\n    begin\n-      return TSD (T).Ancestor_Tags (1);\n+      if T = No_Tag then\n+         raise Tag_Error;\n+      end if;\n+\n+      --  The Parent_Tag of a root-level tagged type is defined to be No_Tag.\n+      --  The first entry in the Ancestors_Tags array will be null for such\n+      --  a type, but it's better to be explicit about returning No_Tag in\n+      --  this case.\n+\n+      if TSD (T).Idepth = 0 then\n+         return No_Tag;\n+      else\n+         return TSD (T).Tags_Table (1);\n+      end if;\n    end Parent_Tag;\n \n+   ----------------------------\n+   -- Register_Interface_Tag --\n+   ----------------------------\n+\n+   procedure Register_Interface_Tag\n+    (T           : Tag;\n+     Interface_T : Tag)\n+   is\n+      New_T_TSD : constant Type_Specific_Data_Ptr := TSD (T);\n+      Index     : Natural;\n+   begin\n+      --  Check if the interface is already registered\n+\n+      if New_T_TSD.Num_Interfaces > 0 then\n+         declare\n+            Id       : Natural          := New_T_TSD.Idepth + 1;\n+            Last_Id  : constant Natural := New_T_TSD.Idepth\n+                                            + New_T_TSD.Num_Interfaces;\n+         begin\n+            loop\n+               if New_T_TSD.Tags_Table (Id) = Interface_T then\n+                  return;\n+               end if;\n+\n+               Id := Id + 1;\n+               exit when Id > Last_Id;\n+            end loop;\n+         end;\n+      end if;\n+\n+      New_T_TSD.Num_Interfaces := New_T_TSD.Num_Interfaces + 1;\n+      Index := New_T_TSD.Idepth + New_T_TSD.Num_Interfaces;\n+      New_T_TSD.Tags_Table (Index) := Interface_T;\n+   end Register_Interface_Tag;\n+\n    ------------------\n    -- Register_Tag --\n    ------------------\n@@ -470,6 +640,15 @@ package body Ada.Tags is\n       External_Tag_HTable.Set (T);\n    end Register_Tag;\n \n+   ----------------------\n+   -- Set_Access_Level --\n+   ----------------------\n+\n+   procedure Set_Access_Level (T : Tag; Value : Natural) is\n+   begin\n+      TSD (T).Access_Level := Value;\n+   end Set_Access_Level;\n+\n    -----------------------\n    -- Set_Expanded_Name --\n    -----------------------\n@@ -488,15 +667,30 @@ package body Ada.Tags is\n       TSD (T).External_Tag := To_Cstring_Ptr (Value);\n    end Set_External_Tag;\n \n+   -----------------------\n+   -- Set_Offset_To_Top --\n+   -----------------------\n+\n+   procedure Set_Offset_To_Top\n+     (T     : Tag;\n+      Value : System.Storage_Elements.Storage_Offset)\n+   is\n+      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n+                            To_Storage_Offset_Ptr (To_Address (T)\n+                              - DT_Typeinfo_Ptr_Size\n+                              - DT_Offset_To_Top_Size);\n+   begin\n+      Offset_To_Top_Ptr.all := Value;\n+   end Set_Offset_To_Top;\n+\n    -------------------------\n    -- Set_Prim_Op_Address --\n    -------------------------\n \n    procedure Set_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive;\n-      Value    : System.Address)\n-   is\n+      Value    : System.Address) is\n    begin\n       T.Prims_Ptr (Position) := Value;\n    end Set_Prim_Op_Address;\n@@ -516,43 +710,25 @@ package body Ada.Tags is\n \n    procedure Set_Remotely_Callable (T : Tag; Value : Boolean) is\n    begin\n-      if Value then\n-         TSD (T).Remotely_Callable := True;\n-      else\n-         TSD (T).Remotely_Callable := False;\n-      end if;\n+      TSD (T).Remotely_Callable := Value;\n    end Set_Remotely_Callable;\n \n    -------------\n    -- Set_TSD --\n    -------------\n \n    procedure Set_TSD (T : Tag; Value : System.Address) is\n-      use type System.Storage_Elements.Storage_Offset;\n       TSD_Ptr : constant Addr_Ptr :=\n                   To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n    begin\n       TSD_Ptr.all := Value;\n    end Set_TSD;\n \n-   -------------------\n-   -- Offset_To_Top --\n-   -------------------\n-\n-   function Offset_To_Top (T : Tag) return Integer is\n-      use type System.Storage_Elements.Storage_Offset;\n-      TSD_Ptr : constant Int_Ptr :=\n-                  To_Int_Ptr (To_Address (T) - DT_Prologue_Size);\n-   begin\n-      return TSD_Ptr.all;\n-   end Offset_To_Top;\n-\n    ------------------\n    -- Typeinfo_Ptr --\n    ------------------\n \n    function Typeinfo_Ptr (T : Tag) return System.Address is\n-      use type System.Storage_Elements.Storage_Offset;\n       TSD_Ptr : constant Addr_Ptr :=\n                   To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n    begin\n@@ -564,7 +740,6 @@ package body Ada.Tags is\n    ---------\n \n    function TSD (T : Tag) return Type_Specific_Data_Ptr is\n-      use type System.Storage_Elements.Storage_Offset;\n       TSD_Ptr : constant Addr_Ptr :=\n                   To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n    begin"}, {"sha": "6532c1a7e32cfc3c4b8b2a794b0edbbea902c873", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -40,17 +40,30 @@ with System.Storage_Elements;\n with Unchecked_Conversion;\n \n package Ada.Tags is\n+pragma Preelaborate_05 (Tags);\n+--  In accordance with Ada 2005 AI-362\n \n    pragma Elaborate_Body;\n+   --  We need a dummy body to solve bootstrap path issues (why ???)\n \n    type Tag is private;\n \n+   No_Tag : constant Tag;\n+\n    function Expanded_Name (T : Tag) return String;\n \n    function External_Tag (T : Tag) return String;\n \n    function Internal_Tag (External : String) return Tag;\n \n+   function Descendant_Tag (External : String; Ancestor : Tag) return Tag;\n+\n+   function Is_Descendant_At_Same_Level\n+     (Descendant : Tag;\n+      Ancestor   : Tag) return Boolean;\n+\n+   function Parent_Tag (T : Tag) return Tag;\n+\n    Tag_Error : exception;\n \n private\n@@ -81,6 +94,9 @@ private\n \n    type Dispatch_Table;\n    type Tag is access all Dispatch_Table;\n+   type Interface_Tag is access all Dispatch_Table;\n+\n+   No_Tag : constant Tag := null;\n \n    type Type_Specific_Data;\n    type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n@@ -91,6 +107,16 @@ private\n    --  Given the tag of an object and the tag associated to a type, return\n    --  true if Obj is in Typ'Class.\n \n+   function IW_Membership\n+     (This      : System.Address;\n+      Iface_Tag : Tag) return Boolean;\n+   --  Ada 2005 (AI-251): Given the tag of an object and the tag associated\n+   --  with an interface, return true if Obj is in Iface'Class.\n+\n+   function Get_Access_Level (T : Tag) return Natural;\n+   --  Given the tag associated with a type, returns the accessibility level\n+   --  of the type.\n+\n    function Get_External_Tag (T : Tag) return System.Address;\n    --  Retrieve the address of a null terminated string containing\n    --  the external name\n@@ -115,8 +141,8 @@ private\n    --  Return the value previously set by Set_Remotely_Callable\n \n    procedure Inherit_DT\n-    (Old_T   : Tag;\n-     New_T   : Tag;\n+    (Old_T       : Tag;\n+     New_T       : Tag;\n      Entry_Count : Natural);\n    --  Entry point used to initialize the DT of a type knowing the tag\n    --  of the direct ancestor and the number of primitive ops that are\n@@ -137,17 +163,24 @@ private\n    pragma Export (Ada, Parent_Size, \"ada__tags__parent_size\");\n    --  This procedure is used in s-finimp and is thus exported manually\n \n-   function Parent_Tag (T : Tag) return Tag;\n-   --  Obj is the address of a tagged object. Parent_Tag fetch the tag of the\n-   --  immediate ancestor (parent) of the type associated with Obj.\n-\n-   pragma Export (Ada, Parent_Tag, \"ada__tags__parent_tag\");\n-   --  This procedure is used in s-finimp and is thus exported manually\n+   procedure Register_Interface_Tag\n+    (T           : Tag;\n+     Interface_T : Tag);\n+   --  Ada 2005 (AI-251): Used to initialize the table of interfaces\n+   --  implemented by a type. Required to give support to IW_Membership.\n \n    procedure Register_Tag (T : Tag);\n    --  Insert the Tag and its associated external_tag in a table for the\n    --  sake of Internal_Tag\n \n+   procedure Set_Offset_To_Top\n+     (T     : Tag;\n+      Value : System.Storage_Elements.Storage_Offset);\n+   --  Ada 2005 (AI-251): Initialize the Offset_To_Top field in the prologue of\n+   --  the dispatch table. In primary dispatch tables the value of this field\n+   --  is always 0; in secondary dispatch tables this is the offset to the base\n+   --  of the enclosing type.\n+\n    procedure Set_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive;\n@@ -160,6 +193,10 @@ private\n    --  Given a pointer T to a dispatch Table, stores the address of the record\n    --  containing the Type Specific Data generated by GNAT\n \n+   procedure Set_Access_Level (T : Tag; Value : Natural);\n+   --  Sets the accessibility level of the tagged type associated with T\n+   --  in its TSD.\n+\n    procedure Set_Expanded_Name (T : Tag; Value : System.Address);\n    --  Set the address of the string containing the expanded name\n    --  in the Dispatch table\n@@ -185,19 +222,24 @@ private\n                           (2 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the first part of the dispatch table\n \n+   DT_Offset_To_Top_Size : constant SSE.Storage_Count :=\n+                            SSE.Storage_Count\n+                              (Standard'Address_Size / System.Storage_Unit);\n+   --  Size of the Offset_To_Top field of the Dispatch Table\n+\n    DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n                             SSE.Storage_Count\n                               (Standard'Address_Size / System.Storage_Unit);\n-   --  Size of the Typeinfo_Ptr field of the Dispatch Table.\n+   --  Size of the Typeinfo_Ptr field of the Dispatch Table\n \n    DT_Entry_Size : constant SSE.Storage_Count :=\n                      SSE.Storage_Count\n                        (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of each primitive operation entry in the Dispatch Table.\n+   --  Size of each primitive operation entry in the Dispatch Table\n \n    TSD_Prologue_Size : constant SSE.Storage_Count :=\n                          SSE.Storage_Count\n-                           (6 * Standard'Address_Size / System.Storage_Unit);\n+                           (8 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the first part of the type specific data\n \n    TSD_Entry_Size : constant SSE.Storage_Count :=\n@@ -210,6 +252,8 @@ private\n    --  of this type are declared with a dummy size of 1, the actual size\n    --  depending on the number of primitive operations.\n \n+   --  Unchecked Conversions for Tag and TSD\n+\n    function To_Type_Specific_Data_Ptr is\n      new Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n \n@@ -220,22 +264,31 @@ private\n      new Unchecked_Conversion (Tag, System.Address);\n \n    type Addr_Ptr is access System.Address;\n+   type Tag_Ptr  is access Tag;\n \n    function To_Addr_Ptr is\n       new Unchecked_Conversion (System.Address, Addr_Ptr);\n \n+   function To_Tag_Ptr is\n+     new Unchecked_Conversion (System.Address, Tag_Ptr);\n+\n    --  Primitive dispatching operations are always inlined, to facilitate\n    --  use in a minimal/no run-time environment for high integrity use.\n \n    pragma Inline_Always (CW_Membership);\n+   pragma Inline_Always (IW_Membership);\n+   pragma Inline_Always (Get_Access_Level);\n    pragma Inline_Always (Get_Prim_Op_Address);\n    pragma Inline_Always (Get_RC_Offset);\n    pragma Inline_Always (Get_Remotely_Callable);\n    pragma Inline_Always (Inherit_DT);\n    pragma Inline_Always (Inherit_TSD);\n+   pragma Inline_Always (Register_Interface_Tag);\n    pragma Inline_Always (Register_Tag);\n+   pragma Inline_Always (Set_Access_Level);\n    pragma Inline_Always (Set_Expanded_Name);\n    pragma Inline_Always (Set_External_Tag);\n+   pragma Inline_Always (Set_Offset_To_Top);\n    pragma Inline_Always (Set_Prim_Op_Address);\n    pragma Inline_Always (Set_RC_Offset);\n    pragma Inline_Always (Set_Remotely_Callable);"}, {"sha": "56baf47c7942326c3cbb075d707b137f47e47753", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -91,7 +91,7 @@ package body Debug is\n    --  dW   Disable warnings on calls for IN OUT parameters\n    --  dX   Enable Frontend ZCX even when it is not supported\n    --  dY   Enable configurable run-time mode\n-   --  dZ\n+   --  dZ   Generate listing showing the contents of the dispatch tables\n \n    --  d.a\n    --  d.b"}, {"sha": "dc20de9660a0519b1652c49218ddab0062052b73", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 171, "deletions": 106, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -626,6 +626,16 @@ package body Exp_Attr is\n                      Rewrite (N, Conversion);\n                      Analyze_And_Resolve (N, Typ);\n                   end if;\n+\n+               --  Ada 2005 (AI-251): If the designated type is an interface,\n+               --  then rewrite the referenced object as a conversion to force\n+               --  the displacement of the pointer to the secondary dispatch\n+               --  table.\n+\n+               elsif Is_Interface (Directly_Designated_Type (Btyp)) then\n+                  Conversion := Convert_To (Typ, New_Copy_Tree (Ref_Object));\n+                  Rewrite (N, Conversion);\n+                  Analyze_And_Resolve (N, Typ);\n                end if;\n             end;\n \n@@ -996,7 +1006,7 @@ package body Exp_Attr is\n       -- Callable --\n       --------------\n \n-      --  Transforms 'Callable attribute into a call to the Callable function.\n+      --  Transforms 'Callable attribute into a call to the Callable function\n \n       when Attribute_Callable => Callable :\n       begin\n@@ -1106,6 +1116,7 @@ package body Exp_Attr is\n \n       when Attribute_Constrained => Constrained : declare\n          Formal_Ent : constant Entity_Id := Param_Entity (Pref);\n+         Typ        : constant Entity_Id := Etype (Pref);\n \n       begin\n          --  Reference to a parameter where the value is passed as an extra\n@@ -1189,15 +1200,20 @@ package body Exp_Attr is\n \n          --  Prefix is not an entity name. These are also cases where\n          --  we can always tell at compile time by looking at the form\n-         --  and type of the prefix.\n+         --  and type of the prefix. If an explicit dereference of an\n+         --  object with constrained partial view, this is unconstrained\n+         --  (Ada 2005 AI-363).\n \n          else\n             Rewrite (N,\n               New_Reference_To (\n                 Boolean_Literals (\n                   not Is_Variable (Pref)\n-                    or else Nkind (Pref) = N_Explicit_Dereference\n-                    or else Is_Constrained (Etype (Pref))),\n+                    or else\n+                     (Nkind (Pref) = N_Explicit_Dereference\n+                        and then\n+                          not Has_Constrained_Partial_View (Base_Type (Typ)))\n+                    or else Is_Constrained (Typ)),\n                 Loc));\n          end if;\n \n@@ -1665,7 +1681,7 @@ package body Exp_Attr is\n \n       --    taskV!(Prefix)._Task_Id, converted to the type Task_Id defined\n \n-      --  in Ada.Task_Identification.\n+      --  in Ada.Task_Identification\n \n       when Attribute_Identity => Identity : declare\n          Id_Kind : Entity_Id;\n@@ -1865,10 +1881,16 @@ package body Exp_Attr is\n                   --  initialize a dummy tag object:\n \n                   --    Dnn : Ada.Tags.Tag\n-                  --             := Internal_Tag (String'Input (Strm));\n+                  --           := Descendant_Tag (String'Input (Strm), P_Type);\n \n                   --  This dummy object is used only to provide a controlling\n-                  --  argument for the eventual _Input call.\n+                  --  argument for the eventual _Input call. Descendant_Tag is\n+                  --  called rather than Internal_Tag to ensure that we have a\n+                  --  tag for a type that is descended from the prefix type and\n+                  --  declared at the same accessibility level (the exception\n+                  --  Tag_Error will be raised otherwise). The level check is\n+                  --  required for Ada 2005 because tagged types can be\n+                  --  extended in nested scopes (AI-344).\n \n                   Dnn :=\n                     Make_Defining_Identifier (Loc,\n@@ -1882,23 +1904,26 @@ package body Exp_Attr is\n                       Expression =>\n                         Make_Function_Call (Loc,\n                           Name =>\n-                            New_Occurrence_Of (RTE (RE_Internal_Tag), Loc),\n+                            New_Occurrence_Of (RTE (RE_Descendant_Tag), Loc),\n                           Parameter_Associations => New_List (\n                             Make_Attribute_Reference (Loc,\n                               Prefix =>\n                                 New_Occurrence_Of (Standard_String, Loc),\n                               Attribute_Name => Name_Input,\n                               Expressions => New_List (\n                                 Relocate_Node\n-                                  (Duplicate_Subexpr (Strm)))))));\n+                                  (Duplicate_Subexpr (Strm)))),\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix => New_Reference_To (P_Type, Loc),\n+                              Attribute_Name => Name_Tag))));\n \n                   Insert_Action (N, Decl);\n \n                   --  Now we need to get the entity for the call, and construct\n                   --  a function call node, where we preset a reference to Dnn\n-                  --  as the controlling argument (doing an unchecked\n-                  --  conversion to the class-wide tagged type to make it\n-                  --  look like a real tagged object).\n+                  --  as the controlling argument (doing an unchecked convert\n+                  --  to the class-wide tagged type to make it look like a real\n+                  --  tagged object).\n \n                   Fname := Find_Prim_Op (Rtyp, TSS_Stream_Input);\n                   Cntrl := Unchecked_Convert_To (P_Type,\n@@ -1912,9 +1937,9 @@ package body Exp_Attr is\n             elsif Is_Tagged_Type (U_Type) then\n                Fname := Find_Prim_Op (U_Type, TSS_Stream_Input);\n \n-            --  All other record type cases, including protected records.\n-            --  The latter only arise for expander generated code for\n-            --  handling shared passive partition access.\n+            --  All other record type cases, including protected records. The\n+            --  latter only arise for expander generated code for handling\n+            --  shared passive partition access.\n \n             else\n                pragma Assert\n@@ -1967,9 +1992,9 @@ package body Exp_Attr is\n             end if;\n          end if;\n \n-         --  If we fall through, Fname is the function to be called. The\n-         --  result is obtained by calling the appropriate function, then\n-         --  converting the result. The conversion does a subtype check.\n+         --  If we fall through, Fname is the function to be called. The result\n+         --  is obtained by calling the appropriate function, then converting\n+         --  the result. The conversion does a subtype check.\n \n          Call :=\n            Make_Function_Call (Loc,\n@@ -2081,10 +2106,10 @@ package body Exp_Attr is\n       --  function Leading_Part in Fat_xxx (where xxx is the root type)\n \n       --  Note: strictly, we should have special case code to deal with\n-      --  absurdly large positive arguments (greater than Integer'Last),\n-      --  which result in returning the first argument unchanged, but it\n-      --  hardly seems worth the effort. We raise constraint error for\n-      --  absurdly negative arguments which is fine.\n+      --  absurdly large positive arguments (greater than Integer'Last), which\n+      --  result in returning the first argument unchanged, but it hardly seems\n+      --  worth the effort. We raise constraint error for absurdly negative\n+      --  arguments which is fine.\n \n       when Attribute_Leading_Part =>\n          Expand_Fpt_Attribute_RI (N);\n@@ -2276,9 +2301,9 @@ package body Exp_Attr is\n       -- Mantissa --\n       --------------\n \n-      --  The only case that can get this far is the dynamic case of the\n-      --  old Ada 83 Mantissa attribute for the fixed-point case. For this\n-      --  case, we expand:\n+      --  The only case that can get this far is the dynamic case of the old\n+      --  Ada 83 Mantissa attribute for the fixed-point case. For this case, we\n+      --  expand:\n \n       --    typ'Mantissa\n \n@@ -2352,12 +2377,11 @@ package body Exp_Attr is\n          --    a) The integer value is non-negative. In this case, it is\n          --    returned as the result (since it is less than the modulus).\n \n-         --    b) The integer value is negative. In this case, we know that\n-         --    the result is modulus + value, where the value might be as\n-         --    small as -modulus. The trouble is what type do we use to do\n-         --    this subtraction. No type will do, since modulus can be as\n-         --    big as 2**64, and no integer type accomodates this value.\n-         --    Let's do a bit of algebra\n+         --    b) The integer value is negative. In this case, we know that the\n+         --    result is modulus + value, where the value might be as small as\n+         --    -modulus. The trouble is what type do we use to do the subtract.\n+         --    No type will do, since modulus can be as big as 2**64, and no\n+         --    integer type accomodates this value. Let's do bit of algebra\n \n          --         modulus + value\n          --      =  modulus - (-value)\n@@ -2452,10 +2476,10 @@ package body Exp_Attr is\n \n             --     strmtyp'Output (Stream, strmwrite (acttyp (Item)));\n \n-            --  where strmwrite is the given Write function that converts\n-            --  an argument of type sourcetyp or a type acctyp, from which\n-            --  it is derived to type strmtyp. The conversion to acttyp is\n-            --  required for the derived case.\n+            --  where strmwrite is the given Write function that converts an\n+            --  argument of type sourcetyp or a type acctyp, from which it is\n+            --  derived to type strmtyp. The conversion to acttyp is required\n+            --  for the derived case.\n \n             Prag := Get_Stream_Convert_Pragma (P_Type);\n \n@@ -2518,7 +2542,43 @@ package body Exp_Attr is\n \n                begin\n                   --  The code is:\n-                  --  String'Output (Strm, External_Tag (Item'Tag))\n+                  --  if Get_Access_Level (Item'Tag)\n+                  --       /= Get_Access_Level (P_Type'Tag)\n+                  --  then\n+                  --     raise Tag_Error;\n+                  --  end if;\n+                  --  String'Output (Strm, External_Tag (Item'Tag));\n+\n+                  --  Ada 2005 (AI-344): Check that the accessibility level\n+                  --  of the type of the output object is not deeper than\n+                  --  that of the attribute's prefix type.\n+\n+                  if Ada_Version >= Ada_05 then\n+                     Insert_Action (N,\n+                       Make_Implicit_If_Statement (N,\n+                         Condition =>\n+                           Make_Op_Ne (Loc,\n+                             Left_Opnd  =>\n+                               Make_Function_Call (Loc,\n+                                 Name =>\n+                                   New_Reference_To\n+                                     (RTE (RE_Get_Access_Level), Loc),\n+                                 Parameter_Associations =>\n+                                   New_List (Make_Attribute_Reference (Loc,\n+                                               Prefix         =>\n+                                                 Relocate_Node (\n+                                                   Duplicate_Subexpr (Item,\n+                                                     Name_Req => True)),\n+                                               Attribute_Name =>\n+                                                  Name_Tag))),\n+                             Right_Opnd =>\n+                               Make_Integer_Literal\n+                                 (Loc, Type_Access_Level (P_Type))),\n+                         Then_Statements =>\n+                           New_List (Make_Raise_Statement (Loc,\n+                                       New_Occurrence_Of (\n+                                         RTE (RE_Tag_Error), Loc)))));\n+                  end if;\n \n                   Insert_Action (N,\n                     Make_Attribute_Reference (Loc,\n@@ -2544,9 +2604,9 @@ package body Exp_Attr is\n             elsif Is_Tagged_Type (U_Type) then\n                Pname := Find_Prim_Op (U_Type, TSS_Stream_Output);\n \n-            --  All other record type cases, including protected records.\n-            --  The latter only arise for expander generated code for\n-            --  handling shared passive partition access.\n+--              --  All other record type cases, including protected records.\n+--              --  The latter only arise for expander generated code for\n+--              --  handling shared passive partition access.\n \n             else\n                pragma Assert\n@@ -2857,10 +2917,10 @@ package body Exp_Attr is\n \n             --     Item := sourcetyp (strmread (strmtyp'Input (Stream)));\n \n-            --  where strmread is the given Read function that converts\n-            --  an argument of type strmtyp to type sourcetyp or a type\n-            --  from which it is derived. The conversion to sourcetyp\n-            --  is required in the latter case.\n+            --  where strmread is the given Read function that converts an\n+            --  argument of type strmtyp to type sourcetyp or a type from which\n+            --  it is derived. The conversion to sourcetyp is required in the\n+            --  latter case.\n \n             --  A special case arises if Item is a type conversion in which\n             --  case, we have to expand to:\n@@ -2943,9 +3003,9 @@ package body Exp_Attr is\n             elsif Is_Tagged_Type (U_Type) then\n                Pname := Find_Prim_Op (U_Type, TSS_Stream_Read);\n \n-            --  All other record type cases, including protected records.\n-            --  The latter only arise for expander generated code for\n-            --  handling shared passive partition access.\n+            --  All other record type cases, including protected records. The\n+            --  latter only arise for expander generated code for handling\n+            --  shared passive partition access.\n \n             else\n                pragma Assert\n@@ -2997,36 +3057,35 @@ package body Exp_Attr is\n       -- Round --\n       -----------\n \n-      --  The handling of the Round attribute is quite delicate. The\n-      --  processing in Sem_Attr introduced a conversion to universal\n-      --  real, reflecting the semantics of Round, but we do not want\n-      --  anything to do with universal real at runtime, since this\n-      --  corresponds to using floating-point arithmetic.\n-\n-      --  What we have now is that the Etype of the Round attribute\n-      --  correctly indicates the final result type. The operand of\n-      --  the Round is the conversion to universal real, described\n-      --  above, and the operand of this conversion is the actual\n-      --  operand of Round, which may be the special case of a fixed\n-      --  point multiplication or division (Etype = universal fixed)\n-\n-      --  The exapander will expand first the operand of the conversion,\n-      --  then the conversion, and finally the round attribute itself,\n-      --  since we always work inside out. But we cannot simply process\n-      --  naively in this order. In the semantic world where universal\n-      --  fixed and real really exist and have infinite precision, there\n-      --  is no problem, but in the implementation world, where universal\n-      --  real is a floating-point type, we would get the wrong result.\n-\n-      --  So the approach is as follows. First, when expanding a multiply\n-      --  or divide whose type is universal fixed, we do nothing at all,\n-      --  instead deferring the operation till later.\n+      --  The handling of the Round attribute is quite delicate. The processing\n+      --  in Sem_Attr introduced a conversion to universal real, reflecting the\n+      --  semantics of Round, but we do not want anything to do with universal\n+      --  real at runtime, since this corresponds to using floating-point\n+      --  arithmetic.\n+\n+      --  What we have now is that the Etype of the Round attribute correctly\n+      --  indicates the final result type. The operand of the Round is the\n+      --  conversion to universal real, described above, and the operand of\n+      --  this conversion is the actual operand of Round, which may be the\n+      --  special case of a fixed point multiplication or division (Etype =\n+      --  universal fixed)\n+\n+      --  The exapander will expand first the operand of the conversion, then\n+      --  the conversion, and finally the round attribute itself, since we\n+      --  always work inside out. But we cannot simply process naively in this\n+      --  order. In the semantic world where universal fixed and real really\n+      --  exist and have infinite precision, there is no problem, but in the\n+      --  implementation world, where universal real is a floating-point type,\n+      --  we would get the wrong result.\n+\n+      --  So the approach is as follows. First, when expanding a multiply or\n+      --  divide whose type is universal fixed, we do nothing at all, instead\n+      --  deferring the operation till later.\n \n       --  The actual processing is done in Expand_N_Type_Conversion which\n-      --  handles the special case of Round by looking at its parent to\n-      --  see if it is a Round attribute, and if it is, handling the\n-      --  conversion (or its fixed multiply/divide child) in an appropriate\n-      --  manner.\n+      --  handles the special case of Round by looking at its parent to see if\n+      --  it is a Round attribute, and if it is, handling the conversion (or\n+      --  its fixed multiply/divide child) in an appropriate manner.\n \n       --  This means that by the time we get to expanding the Round attribute\n       --  itself, the Round is nothing more than a type conversion (and will\n@@ -3120,9 +3179,9 @@ package body Exp_Attr is\n                   Rewrite (Pref, New_Occurrence_Of (Etype (Pref), Loc));\n                end if;\n \n-               --  For a scalar type for which no size was\n-               --  explicitly given, VADS_Size means Object_Size. This is the\n-               --  other respect in which VADS_Size differs from Size.\n+               --  For a scalar type for which no size was explicitly given,\n+               --  VADS_Size means Object_Size. This is the other respect in\n+               --  which VADS_Size differs from Size.\n \n                if Is_Scalar_Type (Etype (Pref))\n                  and then No (Size_Clause (Etype (Pref)))\n@@ -3177,9 +3236,9 @@ package body Exp_Attr is\n          elsif Nkind (Pref) = N_Indexed_Component then\n             Siz := Component_Size (Etype (Prefix (Pref)));\n \n-         --  For a record component, we can do Size in the front end\n-         --  if there is a component clause, or if the record is packed\n-         --  and the component's size is known at compile time.\n+         --  For a record component, we can do Size in the front end if there\n+         --  is a component clause, or if the record is packed and the\n+         --  component's size is known at compile time.\n \n          elsif Nkind (Pref) = N_Selected_Component then\n             declare\n@@ -3522,7 +3581,7 @@ package body Exp_Attr is\n       -- Terminated --\n       ----------------\n \n-      --  Transforms 'Terminated attribute into a call to Terminated function.\n+      --  Transforms 'Terminated attribute into a call to Terminated function\n \n       when Attribute_Terminated => Terminated :\n       begin\n@@ -3881,9 +3940,9 @@ package body Exp_Attr is\n             Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n \n          --  For biased representations, we will be doing an unchecked\n-         --  conversion without unbiasing the result. That means that\n-         --  the range test has to take this into account, and the\n-         --  proper form of the test is:\n+         --  conversion without unbiasing the result. That means that the range\n+         --  test has to take this into account, and the proper form of the\n+         --  test is:\n \n          --    Btyp!(Pref) < Btyp!(Ptyp'Range_Length)\n \n@@ -3924,18 +3983,18 @@ package body Exp_Attr is\n \n          --  Unsigned types. Note: it is safe to consider only whether the\n          --  subtype is unsigned, since we will in that case be doing all\n-         --  unsigned comparisons based on the subtype range. Since we use\n-         --  the actual subtype object size, this is appropriate.\n+         --  unsigned comparisons based on the subtype range. Since we use the\n+         --  actual subtype object size, this is appropriate.\n \n          --  For example, if we have\n \n          --    subtype x is integer range 1 .. 200;\n          --    for x'Object_Size use 8;\n \n-         --  Now the base type is signed, but objects of this type are 8\n-         --  bits unsigned, and doing an unsigned test of the range 1 to\n-         --  200 is correct, even though a value greater than 127 looks\n-         --  signed to a signed comparison.\n+         --  Now the base type is signed, but objects of this type are bits\n+         --  unsigned, and doing an unsigned test of the range 1 to 200 is\n+         --  correct, even though a value greater than 127 looks signed to a\n+         --  signed comparison.\n \n          elsif Is_Unsigned_Type (Ptyp) then\n             if Esize (Ptyp) <= 32 then\n@@ -4188,10 +4247,10 @@ package body Exp_Attr is\n \n             --     strmtyp'Output (Stream, strmwrite (acttyp (Item)));\n \n-            --  where strmwrite is the given Write function that converts\n-            --  an argument of type sourcetyp or a type acctyp, from which\n-            --  it is derived to type strmtyp. The conversion to acttyp is\n-            --  required for the derived case.\n+            --  where strmwrite is the given Write function that converts an\n+            --  argument of type sourcetyp or a type acctyp, from which it is\n+            --  derived to type strmtyp. The conversion to acttyp is required\n+            --  for the derived case.\n \n             Prag := Get_Stream_Convert_Pragma (P_Type);\n \n@@ -4272,22 +4331,22 @@ package body Exp_Attr is\n          Rewrite_Stream_Proc_Call (Pname);\n       end Write;\n \n-      --  Component_Size is handled by Gigi, unless the component size is\n-      --  known at compile time, which is always true in the packed array\n-      --  case. It is important that the packed array case is handled in\n-      --  the front end (see Eval_Attribute) since Gigi would otherwise\n-      --  get confused by the equivalent packed array type.\n+      --  Component_Size is handled by Gigi, unless the component size is known\n+      --  at compile time, which is always true in the packed array case. It is\n+      --  important that the packed array case is handled in the front end (see\n+      --  Eval_Attribute) since Gigi would otherwise get confused by the\n+      --  equivalent packed array type.\n \n       when Attribute_Component_Size =>\n          null;\n \n       --  The following attributes are handled by Gigi (except that static\n-      --  cases have already been evaluated by the semantics, but in any\n-      --  case Gigi should not count on that).\n+      --  cases have already been evaluated by the semantics, but in any case\n+      --  Gigi should not count on that).\n \n-      --  In addition Gigi handles the non-floating-point cases of Pred\n-      --  and Succ (including the fixed-point cases, which can just be\n-      --  treated as integer increment/decrement operations)\n+      --  In addition Gigi handles the non-floating-point cases of Pred and\n+      --  Succ (including the fixed-point cases, which can just be treated as\n+      --  integer increment/decrement operations)\n \n       --  Gigi also handles the non-class-wide cases of Size\n \n@@ -4423,8 +4482,14 @@ package body Exp_Attr is\n \n    function Find_Stream_Subprogram\n      (Typ : Entity_Id;\n-      Nam : TSS_Name_Type) return Entity_Id is\n+      Nam : TSS_Name_Type) return Entity_Id\n+   is\n+      Ent : constant Entity_Id := TSS (Typ, Nam);\n    begin\n+      if Present (Ent) then\n+         return Ent;\n+      end if;\n+\n       if Is_Tagged_Type (Typ)\n         and then Is_Derived_Type (Typ)\n       then"}, {"sha": "fc8463d71b4942cb696de81652a540c80460100e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 141, "deletions": 16, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -49,6 +49,7 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n+with Sem_Attr; use Sem_Attr;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n@@ -124,8 +125,9 @@ package body Exp_Ch3 is\n \n    procedure Check_Stream_Attributes (Typ : Entity_Id);\n    --  Check that if a limited extension has a parent with user-defined\n-   --  stream attributes, any limited component of the extension also has\n-   --  the corresponding user-defined stream attributes.\n+   --  stream attributes, and does not itself have user-definer\n+   --  stream-attributes, then any limited component of the extension also\n+   --  has the corresponding user-defined stream attributes.\n \n    procedure Expand_Tagged_Root (T : Entity_Id);\n    --  Add a field _Tag at the beginning of the record. This field carries\n@@ -1359,6 +1361,10 @@ package body Exp_Ch3 is\n       Rec_Type    : Entity_Id;\n       Set_Tag     : Entity_Id := Empty;\n \n+      ADT      : Elmt_Id;\n+      Aux_N    : Node_Id;\n+      Aux_Comp : Node_Id;\n+\n       function Build_Assignment (Id : Entity_Id; N : Node_Id) return List_Id;\n       --  Build a assignment statement node which assigns to record\n       --  component its default expression if defined. The left hand side\n@@ -1405,12 +1411,12 @@ package body Exp_Ch3 is\n \n       function Component_Needs_Simple_Initialization\n         (T : Entity_Id) return Boolean;\n-      --  Determines if a component needs simple initialization, given its\n-      --  type T. This is the same as Needs_Simple_Initialization except\n-      --  for the following difference: the types Tag and Vtable_Ptr, which\n-      --  are access types which would normally require simple initialization\n-      --  to null, do not require initialization as components, since they\n-      --  are explicitly initialized by other means.\n+      --  Determines if a component needs simple initialization, given its type\n+      --  T. This is the same as Needs_Simple_Initialization except for the\n+      --  following difference: the types Tag, Interface_Tag, and Vtable_Ptr\n+      --  which are access types which would normally require simple\n+      --  initialization to null, do not require initialization as components,\n+      --  since they are explicitly initialized by other means.\n \n       procedure Constrain_Array\n         (SI         : Node_Id;\n@@ -1855,6 +1861,60 @@ package body Exp_Ch3 is\n             if not Is_CPP_Class (Etype (Rec_Type)) then\n                Prepend_To (Body_Stmts, Init_Tag);\n \n+               --  Ada 2005 (AI-251): Initialization of all the tags\n+               --  corresponding with abstract interfaces\n+\n+               if Present (First_Tag_Component (Rec_Type)) then\n+\n+                  --  Skip the first _Tag, which is the main tag of the\n+                  --  tagged type. Following tags correspond with abstract\n+                  --  interfaces.\n+\n+                  Aux_Comp :=\n+                    Next_Tag_Component (First_Tag_Component (Rec_Type));\n+\n+                  ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Rec_Type)));\n+                  while Present (ADT) loop\n+                     Aux_N := Node (ADT);\n+\n+                     --  Initialize the pointer to the secondary DT associated\n+                     --  with the interface\n+\n+                     Append_To (Body_Stmts,\n+                       Make_Assignment_Statement (Loc,\n+                         Name =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix => Make_Identifier (Loc, Name_uInit),\n+                             Selector_Name =>\n+                               New_Reference_To (Aux_Comp, Loc)),\n+                         Expression =>\n+                           New_Reference_To (Aux_N, Loc)));\n+\n+                     --  Generate:\n+                     --    Set_Offset_To_Top (DT_Ptr, n);\n+\n+                     Append_To (Body_Stmts,\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name => New_Reference_To (RTE (RE_Set_Offset_To_Top),\n+                                                   Loc),\n+                         Parameter_Associations => New_List (\n+                           Unchecked_Convert_To (RTE (RE_Tag),\n+                             New_Reference_To (Aux_N, Loc)),\n+                           Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                             Make_Attribute_Reference (Loc,\n+                               Prefix         =>\n+                                Make_Selected_Component (Loc,\n+                                  Prefix         => Make_Identifier (Loc,\n+                                                      Name_uInit),\n+                                  Selector_Name  => New_Reference_To\n+                                                      (Aux_Comp, Loc)),\n+                              Attribute_Name => Name_Position)))));\n+\n+                     Aux_Comp := Next_Tag_Component (Aux_Comp);\n+                     Next_Elmt (ADT);\n+                  end loop;\n+               end if;\n+\n             else\n                declare\n                   Nod : Node_Id := First (Body_Stmts);\n@@ -2236,7 +2296,8 @@ package body Exp_Ch3 is\n          return\n            Needs_Simple_Initialization (T)\n              and then not Is_RTE (T, RE_Tag)\n-             and then not Is_RTE (T, RE_Vtable_Ptr);\n+             and then not Is_RTE (T, RE_Vtable_Ptr)\n+             and then not Is_RTE (T, RE_Interface_Tag); --  Ada 2005 (AI-251)\n       end Component_Needs_Simple_Initialization;\n \n       ---------------------\n@@ -2388,7 +2449,7 @@ package body Exp_Ch3 is\n \n          --  6. One or more components is a type that requires simple\n          --     initialization (see Needs_Simple_Initialization), except\n-         --     that types Tag and Vtable_Ptr are excluded, since fields\n+         --     that types Tag and Interface_Tag are excluded, since fields\n          --     of these types are initialized by other means.\n \n          --  7. The type is the record type built for a task type (since at\n@@ -3012,22 +3073,31 @@ package body Exp_Ch3 is\n \n    procedure Check_Stream_Attributes (Typ : Entity_Id) is\n       Comp      : Entity_Id;\n-      Par       : constant Entity_Id := Root_Type (Base_Type (Typ));\n-      Par_Read  : constant Boolean   := Present (TSS (Par, TSS_Stream_Read));\n-      Par_Write : constant Boolean   := Present (TSS (Par, TSS_Stream_Write));\n+      Par_Read  : constant Boolean :=\n+                    Stream_Attribute_Available (Typ, TSS_Stream_Read)\n+                      and then not Has_Specified_Stream_Read (Typ);\n+      Par_Write : constant Boolean :=\n+                    Stream_Attribute_Available (Typ, TSS_Stream_Write)\n+                      and then not Has_Specified_Stream_Write (Typ);\n \n       procedure Check_Attr (Nam : Name_Id; TSS_Nam : TSS_Name_Type);\n       --  Check that Comp has a user-specified Nam stream attribute\n \n+      ----------------\n+      -- Check_Attr --\n+      ----------------\n+\n       procedure Check_Attr (Nam : Name_Id; TSS_Nam : TSS_Name_Type) is\n       begin\n-         if No (TSS (Base_Type (Etype (Comp)), TSS_Nam)) then\n+         if not Stream_Attribute_Available (Etype (Comp), TSS_Nam) then\n             Error_Msg_Name_1 := Nam;\n             Error_Msg_N\n               (\"|component& in limited extension must have% attribute\", Comp);\n          end if;\n       end Check_Attr;\n \n+   --  Start of processing for Check_Stream_Attributes\n+\n    begin\n       if Par_Read or else Par_Write then\n          Comp := First_Component (Typ);\n@@ -3422,12 +3492,36 @@ package body Exp_Ch3 is\n          --  simple initialization expression in place. This special\n          --  initialization is required even though No_Init_Flag is present.\n \n-         elsif Needs_Simple_Initialization (Typ) then\n+         --  An internally generated temporary needs no initialization because\n+         --  it will be assigned subsequently. In particular, there is no\n+         --  point in applying Initialize_Scalars to such a temporary.\n+\n+         elsif Needs_Simple_Initialization (Typ)\n+            and then not Is_Internal (Def_Id)\n+         then\n             Set_No_Initialization (N, False);\n             Set_Expression (N, Get_Simple_Init_Val (Typ, Loc, Esize (Def_Id)));\n             Analyze_And_Resolve (Expression (N), Typ);\n          end if;\n \n+         --  Generate attribute for Persistent_BSS if needed\n+\n+         declare\n+            Prag : Node_Id;\n+         begin\n+            if Persistent_BSS_Mode\n+              and then Comes_From_Source (N)\n+              and then Is_Potentially_Persistent_Type (Typ)\n+              and then Is_Library_Level_Entity (Def_Id)\n+            then\n+               Prag :=\n+                 Make_Linker_Section_Pragma\n+                   (Def_Id, Sloc (N), \".persistent.bss\");\n+               Insert_After (N, Prag);\n+               Analyze (Prag);\n+            end if;\n+         end;\n+\n       --  Explicit initialization present\n \n       else\n@@ -4340,6 +4434,7 @@ package body Exp_Ch3 is\n       --  created in the C++ side and we just use it.\n \n       if Is_Tagged_Type (Def_Id) then\n+\n          if Is_CPP_Class (Def_Id) then\n             Set_All_DT_Position (Def_Id);\n             Set_Default_Constructor (Def_Id);\n@@ -4385,6 +4480,36 @@ package body Exp_Ch3 is\n                Expand_Tagged_Root (Def_Id);\n             end if;\n \n+            --  Build the secondary tables\n+\n+            if not Java_VM\n+              and then Present (Abstract_Interfaces (Def_Id))\n+              and then not Is_Empty_Elmt_List (Abstract_Interfaces (Def_Id))\n+            then\n+               declare\n+                  E      : Entity_Id;\n+                  Result : List_Id;\n+                  ADT    : Elist_Id := Access_Disp_Table (Def_Id);\n+\n+               begin\n+                  E := First_Entity (Def_Id);\n+                  while Present (E) loop\n+                     if Is_Tag (E) and then Chars (E) /= Name_uTag then\n+                        Make_Abstract_Interface_DT\n+                          (AI_Tag          => E,\n+                           Acc_Disp_Tables => ADT,\n+                           Result          => Result);\n+\n+                        Append_Freeze_Actions (Def_Id, Result);\n+                     end if;\n+\n+                     Next_Entity (E);\n+                  end loop;\n+\n+                  Set_Access_Disp_Table (Def_Id, ADT);\n+               end;\n+            end if;\n+\n             --  Unfreeze momentarily the type to add the predefined primitives\n             --  operations. The reason we unfreeze is so that these predefined\n             --  operations will indeed end up as primitive operations (which\n@@ -4556,7 +4681,7 @@ package body Exp_Ch3 is\n    --  Full type declarations are expanded at the point at which the type is\n    --  frozen. The formal N is the Freeze_Node for the type. Any statements or\n    --  declarations generated by the freezing (e.g. the procedure generated\n-   --  for initialization) are chained in the Acions field list of the freeze\n+   --  for initialization) are chained in the Actions field list of the freeze\n    --  node using Append_Freeze_Actions.\n \n    function Freeze_Type (N : Node_Id) return Boolean is"}, {"sha": "ea615edead16e1b4c42117f33c81d1325a0d0043", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,6 @@ with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n-with Exp_Disp; use Exp_Disp;\n with Exp_Fixd; use Exp_Fixd;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n@@ -445,6 +444,41 @@ package body Exp_Ch4 is\n                 Expression          => Node));\n          end if;\n \n+         --  Ada 2005 (AI-344):\n+         --  For an allocator with a class-wide designated type, generate an\n+         --  accessibility check to verify that the level of the type of the\n+         --  created object is not deeper than the level of the access type.\n+         --  If the type of the qualified expression is class-wide, then\n+         --  always generate the check. Otherwise, only generate the check\n+         --  if the level of the qualified expression type is statically deeper\n+         --  than the access type. Although the static accessibility will\n+         --  generally have been performed as a legality check, it won't have\n+         --  been done in cases where the allocator appears in a generic body,\n+         --  so the run-time check is needed in general. (Not yet doing the\n+         --  optimization to suppress the check for the static level case.???)\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Class_Wide_Type (Designated_Type (PtrT))\n+         then\n+            Insert_Action (N,\n+               Make_Raise_Program_Error (Loc,\n+                 Condition =>\n+                   Make_Op_Gt (Loc,\n+                     Left_Opnd  =>\n+                       Make_Function_Call (Loc,\n+                         Name =>\n+                           New_Reference_To (RTE (RE_Get_Access_Level), Loc),\n+                         Parameter_Associations =>\n+                           New_List (Make_Attribute_Reference (Loc,\n+                                       Prefix         =>\n+                                          New_Reference_To (Temp, Loc),\n+                                       Attribute_Name =>\n+                                          Name_Tag))),\n+                     Right_Opnd =>\n+                       Make_Integer_Literal (Loc, Type_Access_Level (PtrT))),\n+                 Reason => PE_Accessibility_Check_Failed));\n+         end if;\n+\n          --  Suppress the tag assignment when Java_VM because JVM tags\n          --  are represented implicitly in objects.\n \n@@ -8015,22 +8049,43 @@ package body Exp_Ch4 is\n             New_Reference_To (First_Tag_Component (Left_Type), Loc));\n \n       if Is_Class_Wide_Type (Right_Type) then\n-         return\n-           Make_DT_Access_Action (Left_Type,\n-             Action => CW_Membership,\n-             Args   => New_List (\n-               Obj_Tag,\n-               New_Reference_To\n-                 (Node (First_Elmt\n-                          (Access_Disp_Table (Root_Type (Right_Type)))),\n-                  Loc)));\n+\n+         --  Ada 2005 (AI-251): Class-wide applied to interfaces\n+\n+         if Is_Interface (Etype (Class_Wide_Type (Right_Type))) then\n+            return\n+              Make_Function_Call (Loc,\n+                 Name => New_Occurrence_Of (RTE (RE_IW_Membership), Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => Obj_Tag,\n+                     Attribute_Name => Name_Address),\n+                   New_Reference_To (\n+                     Node (First_Elmt\n+                            (Access_Disp_Table (Root_Type (Right_Type)))),\n+                     Loc)));\n+\n+         --  Ada 95: Normal case\n+\n+         else\n+            return\n+              Make_Function_Call (Loc,\n+                 Name => New_Occurrence_Of (RTE (RE_CW_Membership), Loc),\n+                 Parameter_Associations => New_List (\n+                   Obj_Tag,\n+                   New_Reference_To (\n+                     Node (First_Elmt\n+                            (Access_Disp_Table (Root_Type (Right_Type)))),\n+                     Loc)));\n+         end if;\n+\n       else\n          return\n            Make_Op_Eq (Loc,\n-           Left_Opnd  => Obj_Tag,\n-           Right_Opnd =>\n-             New_Reference_To\n-               (Node (First_Elmt (Access_Disp_Table (Right_Type))), Loc));\n+             Left_Opnd  => Obj_Tag,\n+             Right_Opnd =>\n+               New_Reference_To\n+                 (Node (First_Elmt (Access_Disp_Table (Right_Type))), Loc));\n       end if;\n \n    end Tagged_Membership;"}, {"sha": "6224d17f54a07cd2e0c524fcdfea042bba6106bb", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -2829,6 +2829,33 @@ package body Exp_Ch5 is\n             Rewrite (Exp, Result_Exp);\n             Analyze_And_Resolve (Exp, Return_Type);\n          end if;\n+\n+      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n+      --  a check that the level of the return expression's underlying type\n+      --  is not deeper than the level of the master enclosing the function.\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Class_Wide_Type (Return_Type)\n+      then\n+         Insert_Action (Exp,\n+           Make_Raise_Program_Error (Loc,\n+             Condition =>\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd =>\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       New_Reference_To\n+                         (RTE (RE_Get_Access_Level), Loc),\n+                     Parameter_Associations =>\n+                       New_List (Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                      Duplicate_Subexpr (Exp),\n+                                   Attribute_Name =>\n+                                      Name_Tag))),\n+                 Right_Opnd =>\n+                   Make_Integer_Literal (Loc,\n+                     Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n+             Reason => PE_Accessibility_Check_Failed));\n       end if;\n \n       --  Deal with returning variable length objects and controlled types"}, {"sha": "e23e12881c1e51f631be4c0ac4f48839d0a34d0c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 187, "deletions": 18, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,6 +60,7 @@ with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n+with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -515,6 +516,14 @@ package body Exp_Ch6 is\n       --  representation as True. We assume that .FALSE. = False = 0.\n       --  What about functions that return a logical type ???\n \n+      function Is_Legal_Copy return Boolean;\n+      --  Check that an actual can be copied before generating the temporary\n+      --  to be used in the call. If the actual is of a by_reference type then\n+      --  the program is illegal (this can only happen in the presence of\n+      --  rep. clauses that force an incorrect alignment). If the formal is\n+      --  a by_reference parameter imposed by a DEC pragma, emit a warning to\n+      --  the effect that this might lead to unaligned arguments.\n+\n       function Make_Var (Actual : Node_Id) return Entity_Id;\n       --  Returns an entity that refers to the given actual parameter,\n       --  Actual (not including any type conversion). If Actual is an\n@@ -541,11 +550,15 @@ package body Exp_Ch6 is\n          Crep  : Boolean;\n \n       begin\n+         if not Is_Legal_Copy then\n+            return;\n+         end if;\n+\n          Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n \n          --  Use formal type for temp, unless formal type is an unconstrained\n          --  array, in which case we don't have to worry about bounds checks,\n-         --  and we use the actual type, since that has appropriate bonds.\n+         --  and we use the actual type, since that has appropriate bounds.\n \n          if Is_Array_Type (F_Typ) and then not Is_Constrained (F_Typ) then\n             Indic := New_Occurrence_Of (Etype (Actual), Loc);\n@@ -715,6 +728,7 @@ package body Exp_Ch6 is\n \n       procedure Add_Simple_Call_By_Copy_Code is\n          Temp   : Entity_Id;\n+         Decl   : Node_Id;\n          Incod  : Node_Id;\n          Outcod : Node_Id;\n          Lhs    : Node_Id;\n@@ -723,9 +737,13 @@ package body Exp_Ch6 is\n          F_Typ  : constant Entity_Id := Etype (Formal);\n \n       begin\n+         if not Is_Legal_Copy then\n+            return;\n+         end if;\n+\n          --  Use formal type for temp, unless formal type is an unconstrained\n          --  array, in which case we don't have to worry about bounds checks,\n-         --  and we use the actual type, since that has appropriate bonds.\n+         --  and we use the actual type, since that has appropriate bounds.\n \n          if Is_Array_Type (F_Typ) and then not Is_Constrained (F_Typ) then\n             Indic := New_Occurrence_Of (Etype (Actual), Loc);\n@@ -742,17 +760,53 @@ package body Exp_Ch6 is\n          Outcod := New_Copy_Tree (Incod);\n \n          --  Generate declaration of temporary variable, initializing it\n-         --  with the input parameter unless we have an OUT variable.\n+         --  with the input parameter unless we have an OUT variable or\n+         --  this is an initialization call.\n \n          if Ekind (Formal) = E_Out_Parameter then\n             Incod := Empty;\n+\n+         elsif Inside_Init_Proc then\n+            if Nkind (Actual) /= N_Selected_Component\n+              or else\n+                not Has_Discriminant_Dependent_Constraint\n+                  (Entity (Selector_Name (Actual)))\n+            then\n+               Incod := Empty;\n+\n+            else\n+               --  We need the component in order to generate the proper\n+               --  actual subtype, that depends on enclosing discriminants.\n+               --  What is the comment for, given code below is null ???\n+\n+               null;\n+            end if;\n          end if;\n \n-         Insert_Action (N,\n+         Decl :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Temp,\n              Object_Definition   => Indic,\n-             Expression          => Incod));\n+             Expression          => Incod);\n+\n+         if Inside_Init_Proc\n+           and then No (Incod)\n+         then\n+            --  If the call is to initialize a component of a composite type,\n+            --  and the component does not depend on discriminants, use the\n+            --  actual type of the component. This is required in case the\n+            --  component is constrained, because in general the formal of the\n+            --  initialization procedure will be unconstrained. Note that if\n+            --  the component being initialized is constrained by an enclosing\n+            --  discriminant, the presence of the initialization in the\n+            --  declaration will generate an expression for the actual subtype.\n+\n+            Set_No_Initialization (Decl);\n+            Set_Object_Definition (Decl,\n+              New_Occurrence_Of (Etype (Actual), Loc));\n+         end if;\n+\n+         Insert_Action (N, Decl);\n \n          --  The actual is simply a reference to the temporary\n \n@@ -811,6 +865,38 @@ package body Exp_Ch6 is\n          end if;\n       end Check_Fortran_Logical;\n \n+      -------------------\n+      -- Is_Legal_Copy --\n+      -------------------\n+\n+      function Is_Legal_Copy return Boolean is\n+      begin\n+         --  An attempt to copy a value of such a type can only occur if\n+         --  representation clauses give the actual a misaligned address.\n+\n+         if Is_By_Reference_Type (Etype (Formal)) then\n+            Error_Msg_N\n+              (\"misaligned actual cannot be passed by reference\", Actual);\n+            return False;\n+\n+         --  For users of Starlet, we assume that the specification of by-\n+         --  reference mechanism is mandatory. This may lead to unligned\n+         --  objects but at least for DEC legacy code it is known to work.\n+         --  The warning will alert users of this code that a problem may\n+         --  be lurking.\n+\n+         elsif Mechanism (Formal) = By_Reference\n+           and then Is_Valued_Procedure (Scope (Formal))\n+         then\n+            Error_Msg_N\n+              (\"by_reference actual may be misaligned?\", Actual);\n+            return False;\n+\n+         else\n+            return True;\n+         end if;\n+      end Is_Legal_Copy;\n+\n       --------------\n       -- Make_Var --\n       --------------\n@@ -1127,6 +1213,8 @@ package body Exp_Ch6 is\n       Extra_Actuals : List_Id := No_List;\n       Cond          : Node_Id;\n \n+      CW_Interface_Formals_Present : Boolean := False;\n+\n       procedure Add_Actual_Parameter (Insert_Param : Node_Id);\n       --  Adds one entry to the end of the actual parameter list. Used for\n       --  default parameters and for extra actuals (for Extra_Formals).\n@@ -1391,16 +1479,28 @@ package body Exp_Ch6 is\n          Prev := Actual;\n          Prev_Orig := Original_Node (Prev);\n \n-         --  Create possible extra actual for constrained case. Usually,\n-         --  the extra actual is of the form actual'constrained, but since\n-         --  this attribute is only available for unconstrained records,\n-         --  TRUE is expanded if the type of the formal happens to be\n-         --  constrained (for instance when this procedure is inherited\n-         --  from an unconstrained record to a constrained one) or if the\n-         --  actual has no discriminant (its type is constrained). An\n-         --  exception to this is the case of a private type without\n-         --  discriminants. In this case we pass FALSE because the\n-         --  object has underlying discriminants with defaults.\n+         --  Ada 2005 (AI-251): Check if any formal is a class-wide interface\n+         --  to expand it in a further round\n+\n+         CW_Interface_Formals_Present :=\n+           CW_Interface_Formals_Present\n+             or else\n+               (Ekind (Etype (Formal)) = E_Class_Wide_Type\n+                  and then Is_Interface (Etype (Etype (Formal))))\n+             or else\n+               (Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n+                 and then Is_Interface (Directly_Designated_Type\n+                                         (Etype (Etype (Formal)))));\n+\n+         --  Create possible extra actual for constrained case. Usually, the\n+         --  extra actual is of the form actual'constrained, but since this\n+         --  attribute is only available for unconstrained records, TRUE is\n+         --  expanded if the type of the formal happens to be constrained (for\n+         --  instance when this procedure is inherited from an unconstrained\n+         --  record to a constrained one) or if the actual has no discriminant\n+         --  (its type is constrained). An exception to this is the case of a\n+         --  private type without discriminants. In this case we pass FALSE\n+         --  because the object has underlying discriminants with defaults.\n \n          if Present (Extra_Constrained (Formal)) then\n             if Ekind (Etype (Prev)) in Private_Kind\n@@ -1756,6 +1856,16 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n+      --  Ada 2005 (AI-251): If some formal is a class-wide interface, expand\n+      --  it to point to the correct secondary virtual table\n+\n+      if (Nkind (N) = N_Function_Call\n+           or else Nkind (N) = N_Procedure_Call_Statement)\n+        and then CW_Interface_Formals_Present\n+      then\n+         Expand_Interface_Actuals (N);\n+      end if;\n+\n       --  Deals with Dispatch_Call if we still have a call, before expanding\n       --  extra actuals since this will be done on the re-analysis of the\n       --  dispatching call. Note that we do not try to shorten the actual\n@@ -2858,6 +2968,7 @@ package body Exp_Ch6 is\n \n             Temp :=\n               Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n+            Set_Is_Internal (Temp);\n \n             Decl :=\n               Make_Object_Declaration (Loc,\n@@ -3685,6 +3796,8 @@ package body Exp_Ch6 is\n    --  protected subprogram an associated formals. For a normal protected\n    --  operation, this is done when expanding the protected type declaration.\n \n+   --  If the declaration is for a null procedure, emit null body\n+\n    procedure Expand_N_Subprogram_Declaration (N : Node_Id) is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Subp      : constant Entity_Id  := Defining_Entity (N);\n@@ -3732,6 +3845,24 @@ package body Exp_Ch6 is\n             Set_Protected_Body_Subprogram (Subp, Prot_Id);\n             Pop_Scope;\n          end if;\n+\n+      elsif Nkind (Specification (N)) = N_Procedure_Specification\n+        and then Null_Present (Specification (N))\n+      then\n+         declare\n+            Bod : constant Node_Id :=\n+                    Make_Subprogram_Body (Loc,\n+                      Specification =>\n+                        New_Copy_Tree (Specification (N)),\n+                      Declarations => New_List,\n+                     Handled_Statement_Sequence =>\n+                        Make_Handled_Sequence_Of_Statements (Loc,\n+                          Statements => New_List (Make_Null_Statement (Loc))));\n+         begin\n+            Set_Body_To_Inline (N, New_Copy_Tree (Bod));\n+            Insert_After (N, Bod);\n+            Analyze (Bod);\n+         end;\n       end if;\n    end Expand_N_Subprogram_Declaration;\n \n@@ -3907,7 +4038,11 @@ package body Exp_Ch6 is\n    -----------------------\n \n    procedure Freeze_Subprogram (N : Node_Id) is\n-      E : constant Entity_Id := Entity (N);\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      E         : constant Entity_Id  := Entity (N);\n+      Thunk_Id  : Entity_Id;\n+      Iface_Tag : Entity_Id;\n+      New_Thunk : Node_Id;\n \n    begin\n       --  When a primitive is frozen, enter its name in the corresponding\n@@ -3923,7 +4058,41 @@ package body Exp_Ch6 is\n         and then not Java_VM\n       then\n          Check_Overriding_Operation (E);\n-         Insert_After (N, Fill_DT_Entry (Sloc (N), E));\n+\n+         --  Common case: Primitive subprogram\n+\n+         if not Present (Abstract_Interface_Alias (E)) then\n+            Insert_After (N, Fill_DT_Entry (Sloc (N), E));\n+\n+         --  Ada 2005 (AI-251): Primitive subprogram that covers an interface\n+\n+         else\n+            Iface_Tag :=\n+              Find_Interface_Tag\n+                (T     => Scope (DTC_Entity (Alias (E))),    -- Formal Type\n+                 Iface => Scope (DTC_Entity (Abstract_Interface_Alias (E))));\n+\n+            --  Generate the thunk only if the associated tag is an interface\n+            --  tag. The case in which the associated tag is the primary tag\n+            --  occurs when a tagged type is a direct derivation of an\n+            --  interface. For example:\n+\n+            --    type I is interface;\n+            --    ...\n+            --    type T is new I with ...\n+\n+            if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n+               Thunk_Id  := Make_Defining_Identifier (Loc,\n+                              New_Internal_Name ('T'));\n+\n+               New_Thunk := Expand_Interface_Thunk (N, Thunk_Id, Iface_Tag);\n+\n+               Insert_After (New_Thunk,\n+                  Fill_DT_Entry (Sloc (N),\n+                     Prim     => E,\n+                     Thunk_Id => Thunk_Id));\n+            end if;\n+         end if;\n       end if;\n \n       --  Mark functions that return by reference. Note that it cannot be"}, {"sha": "ea82dd339f49abbde9d732f0386ffdd399912d9c", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1387, "deletions": 212, "changes": 1599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -26,41 +26,49 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Fname;    use Fname;\n with Itypes;   use Itypes;\n-with Lib;      use Lib;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n+with Namet;    use Namet;\n with Opt;      use Opt;\n+with Output;   use Output;\n with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n with Sem_Disp; use Sem_Disp;\n with Sem_Res;  use Sem_Res;\n+with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n \n package body Exp_Disp is\n \n    Ada_Actions : constant array (DT_Access_Action) of RE_Id :=\n       (CW_Membership           => RE_CW_Membership,\n+       IW_Membership           => RE_IW_Membership,\n        DT_Entry_Size           => RE_DT_Entry_Size,\n        DT_Prologue_Size        => RE_DT_Prologue_Size,\n+       Get_Access_Level        => RE_Get_Access_Level,\n        Get_External_Tag        => RE_Get_External_Tag,\n        Get_Prim_Op_Address     => RE_Get_Prim_Op_Address,\n        Get_RC_Offset           => RE_Get_RC_Offset,\n        Get_Remotely_Callable   => RE_Get_Remotely_Callable,\n        Inherit_DT              => RE_Inherit_DT,\n        Inherit_TSD             => RE_Inherit_TSD,\n+       Register_Interface_Tag  => RE_Register_Interface_Tag,\n        Register_Tag            => RE_Register_Tag,\n+       Set_Access_Level        => RE_Set_Access_Level,\n        Set_Expanded_Name       => RE_Set_Expanded_Name,\n        Set_External_Tag        => RE_Set_External_Tag,\n        Set_Prim_Op_Address     => RE_Set_Prim_Op_Address,\n@@ -70,37 +78,21 @@ package body Exp_Disp is\n        TSD_Entry_Size          => RE_TSD_Entry_Size,\n        TSD_Prologue_Size       => RE_TSD_Prologue_Size);\n \n-   CPP_Actions : constant array (DT_Access_Action) of RE_Id :=\n-      (CW_Membership           => RE_CPP_CW_Membership,\n-       DT_Entry_Size           => RE_CPP_DT_Entry_Size,\n-       DT_Prologue_Size        => RE_CPP_DT_Prologue_Size,\n-       Get_External_Tag        => RE_CPP_Get_External_Tag,\n-       Get_Prim_Op_Address     => RE_CPP_Get_Prim_Op_Address,\n-       Get_RC_Offset           => RE_CPP_Get_RC_Offset,\n-       Get_Remotely_Callable   => RE_CPP_Get_Remotely_Callable,\n-       Inherit_DT              => RE_CPP_Inherit_DT,\n-       Inherit_TSD             => RE_CPP_Inherit_TSD,\n-       Register_Tag            => RE_CPP_Register_Tag,\n-       Set_Expanded_Name       => RE_CPP_Set_Expanded_Name,\n-       Set_External_Tag        => RE_CPP_Set_External_Tag,\n-       Set_Prim_Op_Address     => RE_CPP_Set_Prim_Op_Address,\n-       Set_RC_Offset           => RE_CPP_Set_RC_Offset,\n-       Set_Remotely_Callable   => RE_CPP_Set_Remotely_Callable,\n-       Set_TSD                 => RE_CPP_Set_TSD,\n-       TSD_Entry_Size          => RE_CPP_TSD_Entry_Size,\n-       TSD_Prologue_Size       => RE_CPP_TSD_Prologue_Size);\n-\n    Action_Is_Proc : constant array (DT_Access_Action) of Boolean :=\n       (CW_Membership           => False,\n+       IW_Membership           => False,\n        DT_Entry_Size           => False,\n        DT_Prologue_Size        => False,\n+       Get_Access_Level        => False,\n        Get_External_Tag        => False,\n        Get_Prim_Op_Address     => False,\n        Get_Remotely_Callable   => False,\n        Get_RC_Offset           => False,\n        Inherit_DT              => True,\n        Inherit_TSD             => True,\n+       Register_Interface_Tag  => True,\n        Register_Tag            => True,\n+       Set_Access_Level        => True,\n        Set_Expanded_Name       => True,\n        Set_External_Tag        => True,\n        Set_Prim_Op_Address     => True,\n@@ -112,15 +104,19 @@ package body Exp_Disp is\n \n    Action_Nb_Arg : constant array (DT_Access_Action) of Int :=\n       (CW_Membership           => 2,\n+       IW_Membership           => 2,\n        DT_Entry_Size           => 0,\n        DT_Prologue_Size        => 0,\n+       Get_Access_Level        => 1,\n        Get_External_Tag        => 1,\n        Get_Prim_Op_Address     => 2,\n        Get_RC_Offset           => 1,\n        Get_Remotely_Callable   => 1,\n        Inherit_DT              => 3,\n        Inherit_TSD             => 2,\n+       Register_Interface_Tag  => 2,\n        Register_Tag            => 1,\n+       Set_Access_Level        => 2,\n        Set_Expanded_Name       => 2,\n        Set_External_Tag        => 2,\n        Set_Prim_Op_Address     => 3,\n@@ -130,10 +126,194 @@ package body Exp_Disp is\n        TSD_Entry_Size          => 0,\n        TSD_Prologue_Size       => 0);\n \n+   function Build_Anonymous_Access_Type\n+     (Directly_Designated_Type : Entity_Id;\n+      Related_Nod              : Node_Id) return Entity_Id;\n+   --  Returns a decorated entity corresponding with an anonymous access type.\n+   --  Used to generate unchecked type conversion of an address.\n+\n+   procedure Collect_All_Interfaces (T : Entity_Id);\n+   --  Ada 2005 (AI-251): Collect the whole list of interfaces that are\n+   --  directly or indirectly implemented by T. Used to compute the size\n+   --  of the table of interfaces.\n+\n+   function Default_Prim_Op_Position (Subp : Entity_Id) return Uint;\n+   --  Ada 2005 (AI-251): Returns the fixed position in the dispatch table\n+   --  of the default primitive operations.\n+\n    function Original_View_In_Visible_Part (Typ : Entity_Id) return Boolean;\n    --  Check if the type has a private view or if the public view appears\n    --  in the visible part of a package spec.\n \n+   ----------------------------------\n+   --  Build_Anonymous_Access_Type --\n+   ----------------------------------\n+\n+   function Build_Anonymous_Access_Type\n+     (Directly_Designated_Type : Entity_Id;\n+      Related_Nod              : Node_Id) return Entity_Id\n+   is\n+      New_E : Entity_Id;\n+\n+   begin\n+      New_E := Create_Itype (Ekind       => E_Anonymous_Access_Type,\n+                             Related_Nod => Related_Nod,\n+                             Scope_Id    => Current_Scope);\n+\n+      Set_Etype                    (New_E, New_E);\n+      Init_Size_Align              (New_E);\n+      Init_Size                    (New_E, System_Address_Size);\n+      Set_Directly_Designated_Type (New_E, Directly_Designated_Type);\n+      Set_Is_First_Subtype         (New_E);\n+\n+      return New_E;\n+   end Build_Anonymous_Access_Type;\n+\n+   ----------------------------\n+   -- Collect_All_Interfaces --\n+   ----------------------------\n+\n+   procedure Collect_All_Interfaces (T : Entity_Id) is\n+\n+      procedure Add_Interface (Iface : Entity_Id);\n+      --  Add the interface it if is not already in the list\n+\n+      procedure Collect (Typ   : Entity_Id);\n+      --  Subsidiary subprogram used to traverse the whole list\n+      --  of directly and indirectly implemented interfaces\n+\n+      -------------------\n+      -- Add_Interface --\n+      -------------------\n+\n+      procedure Add_Interface (Iface : Entity_Id) is\n+         Elmt  : Elmt_Id := First_Elmt (Abstract_Interfaces (T));\n+\n+      begin\n+         while Present (Elmt) and then Node (Elmt) /= Iface loop\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         if not Present (Elmt) then\n+            Append_Elmt (Iface, Abstract_Interfaces (T));\n+         end if;\n+      end Add_Interface;\n+\n+      -------------\n+      -- Collect --\n+      -------------\n+\n+      procedure Collect (Typ : Entity_Id) is\n+         Nod      : constant Node_Id := Type_Definition (Parent (Typ));\n+         Id       : Node_Id;\n+         Iface    : Entity_Id;\n+         Ancestor : Entity_Id;\n+\n+      begin\n+         pragma Assert (False\n+            or else Nkind (Nod) = N_Derived_Type_Definition\n+            or else Nkind (Nod) = N_Record_Definition);\n+\n+         if Nkind (Nod) = N_Record_Definition then\n+            return;\n+         end if;\n+\n+         --  Include the ancestor if we are generating the whole list\n+         --  of interfaces. This is used to know the size of the table\n+         --  that stores the tag of all the ancestor interfaces.\n+\n+         Ancestor := Etype (Typ);\n+\n+         if Is_Interface (Ancestor) then\n+            Add_Interface (Ancestor);\n+         end if;\n+\n+         if Ancestor /= Typ\n+           and then Ekind (Ancestor) /= E_Record_Type_With_Private\n+         then\n+            Collect (Ancestor);\n+         end if;\n+\n+         --  Traverse the graph of ancestor interfaces\n+\n+         if Is_Non_Empty_List (Interface_List (Nod)) then\n+            Id := First (Interface_List (Nod));\n+\n+            while Present (Id) loop\n+\n+               Iface := Etype (Id);\n+\n+               if Is_Interface (Iface) then\n+                  Add_Interface (Iface);\n+                  Collect (Iface);\n+               end if;\n+\n+               Next (Id);\n+            end loop;\n+         end if;\n+      end Collect;\n+\n+   --  Start of processing for Collect_All_Interfaces\n+\n+   begin\n+      Collect (T);\n+   end Collect_All_Interfaces;\n+\n+   ------------------------------\n+   -- Default_Prim_Op_Position --\n+   ------------------------------\n+\n+   function Default_Prim_Op_Position (Subp : Entity_Id) return Uint is\n+      TSS_Name : TSS_Name_Type;\n+      E        : Entity_Id := Subp;\n+\n+   begin\n+      --  Handle overriden subprograms\n+\n+      while Present (Alias (E)) loop\n+         E := Alias (E);\n+      end loop;\n+\n+      Get_Name_String (Chars (E));\n+      TSS_Name :=\n+        TSS_Name_Type\n+          (Name_Buffer (Name_Len - TSS_Name'Length + 1 .. Name_Len));\n+\n+      if Chars (E) = Name_uSize then\n+         return Uint_1;\n+\n+      elsif Chars (E) = Name_uAlignment then\n+         return Uint_2;\n+\n+      elsif TSS_Name = TSS_Stream_Read then\n+         return Uint_3;\n+\n+      elsif TSS_Name = TSS_Stream_Write then\n+         return Uint_4;\n+\n+      elsif TSS_Name = TSS_Stream_Input then\n+         return Uint_5;\n+\n+      elsif TSS_Name = TSS_Stream_Output then\n+         return Uint_6;\n+\n+      elsif Chars (E) = Name_Op_Eq then\n+         return Uint_7;\n+\n+      elsif Chars (E) = Name_uAssign then\n+         return Uint_8;\n+\n+      elsif TSS_Name = TSS_Deep_Adjust then\n+         return Uint_9;\n+\n+      elsif TSS_Name = TSS_Deep_Finalize then\n+         return Uint_10;\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+   end Default_Prim_Op_Position;\n+\n    -----------------------------\n    -- Expand_Dispatching_Call --\n    -----------------------------\n@@ -247,7 +427,9 @@ package body Exp_Disp is\n       --  This capability of dispatching directly by tag is also needed by the\n       --  implementation of AI-260 (for the generic dispatching constructors).\n \n-      if Etype (Ctrl_Arg) = RTE (RE_Tag) then\n+      if Etype (Ctrl_Arg) = RTE (RE_Tag)\n+        or else Etype (Ctrl_Arg) = RTE (RE_Interface_Tag)\n+      then\n          CW_Typ := Class_Wide_Type (Controlling_Type (Subp));\n \n       elsif Is_Access_Type (Etype (Ctrl_Arg)) then\n@@ -270,47 +452,7 @@ package body Exp_Disp is\n          New_Params := New_List;\n          Param := First_Actual (Call_Node);\n          while Present (Param) loop\n-\n-            --  We assume that dispatching through the main dispatch table\n-            --  (referenced by Tag_Component) doesn't require a displacement\n-            --  so the expansion below is only done when dispatching on\n-            --  another vtable pointer, in which case the first argument\n-            --  is expanded into :\n-\n-            --     typ!(Displaced_This (Address!(Param)))\n-\n-            if Param = Ctrl_Arg\n-              and then DTC_Entity (Subp) /= First_Tag_Component (Typ)\n-            then\n-               Append_To (New_Params,\n-\n-                 Unchecked_Convert_To (Etype (Param),\n-                   Make_Function_Call (Loc,\n-                     Name => New_Reference_To (RTE (RE_Displaced_This), Loc),\n-                     Parameter_Associations => New_List (\n-\n-                     --  Current_This\n-\n-                       Make_Unchecked_Type_Conversion (Loc,\n-                         Subtype_Mark =>\n-                           New_Reference_To (RTE (RE_Address), Loc),\n-                         Expression   => Relocate_Node (Param)),\n-\n-                     --  Vptr\n-\n-                       Make_Selected_Component (Loc,\n-                          Prefix => Duplicate_Subexpr (Ctrl_Arg),\n-                          Selector_Name =>\n-                            New_Reference_To (DTC_Entity (Subp), Loc)),\n-\n-                     --  Position\n-\n-                       Make_Integer_Literal (Loc, DT_Position (Subp))))));\n-\n-            else\n-               Append_To (New_Params, Relocate_Node (Param));\n-            end if;\n-\n+            Append_To (New_Params, Relocate_Node (Param));\n             Next_Actual (Param);\n          end loop;\n \n@@ -493,7 +635,9 @@ package body Exp_Disp is\n       --  use it directly.  Otherwise, the tag must be extracted from\n       --  the controlling object.\n \n-      if Etype (Ctrl_Arg) = RTE (RE_Tag) then\n+      if Etype (Ctrl_Arg) = RTE (RE_Tag)\n+        or else Etype (Ctrl_Arg) = RTE (RE_Interface_Tag)\n+      then\n          Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n \n       else\n@@ -521,37 +665,64 @@ package body Exp_Disp is\n               Make_Integer_Literal (Loc, DT_Position (Subp)))));\n \n       if Nkind (Call_Node) = N_Function_Call then\n-         New_Call :=\n-           Make_Function_Call (Loc,\n-             Name => New_Call_Name,\n-             Parameter_Associations => New_Params);\n \n-         --  If this is a dispatching \"=\", we must first compare the tags so\n-         --  we generate: x.tag = y.tag and then x = y\n+         --  Ada 2005 (AI-251): A dispatching \"=\" with an abstract interface\n+         --  just requires the comparison of the tags.\n \n-         if Subp = Eq_Prim_Op then\n+         if Ekind (Etype (Ctrl_Arg)) = E_Class_Wide_Type\n+           and then Is_Interface (Etype (Ctrl_Arg))\n+           and then Subp = Eq_Prim_Op\n+         then\n             Param := First_Actual (Call_Node);\n-            New_Call :=\n-              Make_And_Then (Loc,\n-                Left_Opnd =>\n-                     Make_Op_Eq (Loc,\n-                       Left_Opnd =>\n-                         Make_Selected_Component (Loc,\n-                           Prefix => New_Value (Param),\n-                           Selector_Name =>\n-                             New_Reference_To\n-                               (First_Tag_Component (Typ), Loc)),\n \n-                       Right_Opnd =>\n-                         Make_Selected_Component (Loc,\n-                           Prefix =>\n-                             Unchecked_Convert_To (Typ,\n-                               New_Value (Next_Actual (Param))),\n-                           Selector_Name =>\n-                             New_Reference_To\n-                               (First_Tag_Component (Typ), Loc))),\n+            New_Call :=\n+                Make_Op_Eq (Loc,\n+                   Left_Opnd =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => New_Value (Param),\n+                       Selector_Name =>\n+                         New_Reference_To (First_Tag_Component (Typ), Loc)),\n+\n+                   Right_Opnd =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix =>\n+                         Unchecked_Convert_To (Typ,\n+                           New_Value (Next_Actual (Param))),\n+                       Selector_Name =>\n+                         New_Reference_To (First_Tag_Component (Typ), Loc)));\n \n-                Right_Opnd => New_Call);\n+         else\n+            New_Call :=\n+              Make_Function_Call (Loc,\n+                Name => New_Call_Name,\n+                Parameter_Associations => New_Params);\n+\n+            --  If this is a dispatching \"=\", we must first compare the tags so\n+            --  we generate: x.tag = y.tag and then x = y\n+\n+            if Subp = Eq_Prim_Op then\n+               Param := First_Actual (Call_Node);\n+               New_Call :=\n+                 Make_And_Then (Loc,\n+                   Left_Opnd =>\n+                        Make_Op_Eq (Loc,\n+                          Left_Opnd =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix => New_Value (Param),\n+                              Selector_Name =>\n+                                New_Reference_To (First_Tag_Component (Typ),\n+                                                  Loc)),\n+\n+                          Right_Opnd =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix =>\n+                                Unchecked_Convert_To (Typ,\n+                                  New_Value (Next_Actual (Param))),\n+                              Selector_Name =>\n+                                New_Reference_To (First_Tag_Component (Typ),\n+                                                  Loc))),\n+                   Right_Opnd => New_Call);\n+            end if;\n          end if;\n \n       else\n@@ -565,30 +736,478 @@ package body Exp_Disp is\n       Analyze_And_Resolve (Call_Node, Call_Typ);\n    end Expand_Dispatching_Call;\n \n+   ---------------------------------\n+   -- Expand_Interface_Conversion --\n+   ---------------------------------\n+\n+   procedure Expand_Interface_Conversion (N : Node_Id) is\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Operand     : constant Node_Id    := Expression (N);\n+      Operand_Typ : Entity_Id           := Etype (Operand);\n+      Target_Type : Entity_Id           := Etype (N);\n+      Iface_Tag   : Entity_Id;\n+\n+   begin\n+      pragma Assert (Nkind (Operand) /= N_Attribute_Reference);\n+\n+      --  Ada 2005 (AI-345): Set Operand_Typ and Handle task interfaces\n+\n+      if Ekind (Operand_Typ) = E_Task_Type\n+        or else Ekind (Operand_Typ) = E_Protected_Type\n+      then\n+         Operand_Typ := Corresponding_Record_Type (Operand_Typ);\n+      end if;\n+\n+      if Is_Access_Type (Target_Type) then\n+         Target_Type := Etype (Directly_Designated_Type (Target_Type));\n+\n+      elsif Is_Class_Wide_Type (Target_Type) then\n+         Target_Type := Etype (Target_Type);\n+      end if;\n+\n+      pragma Assert (not Is_Class_Wide_Type (Target_Type)\n+        and then Is_Interface (Target_Type));\n+\n+      Iface_Tag := Find_Interface_Tag (Operand_Typ, Target_Type);\n+\n+      pragma Assert (Iface_Tag /= Empty);\n+\n+      Rewrite (N,\n+        Unchecked_Convert_To (Etype (N),\n+          Make_Attribute_Reference (Loc,\n+            Prefix => Make_Selected_Component (Loc,\n+                        Prefix => Relocate_Node (Expression (N)),\n+                        Selector_Name => New_Occurrence_Of (Iface_Tag, Loc)),\n+            Attribute_Name => Name_Address)));\n+\n+      Analyze (N);\n+   end Expand_Interface_Conversion;\n+\n+   ------------------------------\n+   -- Expand_Interface_Actuals --\n+   ------------------------------\n+\n+   procedure Expand_Interface_Actuals (Call_Node : Node_Id) is\n+      Loc        : constant Source_Ptr := Sloc (Call_Node);\n+      Actual     : Node_Id;\n+      Actual_Typ : Entity_Id;\n+      Conversion : Node_Id;\n+      Formal     : Entity_Id;\n+      Formal_Typ : Entity_Id;\n+      Subp       : Entity_Id;\n+      Nam        : Name_Id;\n+\n+   begin\n+      --  This subprogram is called directly from the semantics, so we need a\n+      --  check to see whether expansion is active before proceeding.\n+\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n+      --  Call using access to subprogram with explicit dereference\n+\n+      if Nkind (Name (Call_Node)) = N_Explicit_Dereference then\n+         Subp := Etype (Name (Call_Node));\n+\n+      --  Normal case\n+\n+      else\n+         Subp := Entity (Name (Call_Node));\n+      end if;\n+\n+      Formal := First_Formal (Subp);\n+      Actual := First_Actual (Call_Node);\n+\n+      while Present (Formal) loop\n+\n+         pragma Assert (Ekind (Etype (Etype (Formal)))\n+                        /= E_Record_Type_With_Private);\n+\n+         --  Ada 2005 (AI-251): Conversion to interface to force \"this\"\n+         --  displacement\n+\n+         Formal_Typ := Etype (Etype (Formal));\n+         Actual_Typ := Etype (Actual);\n+\n+         if Is_Interface (Formal_Typ) then\n+\n+            Conversion := Convert_To (Formal_Typ, New_Copy_Tree (Actual));\n+            Rewrite             (Actual, Conversion);\n+            Analyze_And_Resolve (Actual, Formal_Typ);\n+\n+            Rewrite (Actual,\n+              Make_Explicit_Dereference (Loc,\n+                Unchecked_Convert_To\n+                  (Build_Anonymous_Access_Type (Formal_Typ, Call_Node),\n+                   Relocate_Node (Expression (Actual)))));\n+\n+            Analyze_And_Resolve (Actual, Formal_Typ);\n+\n+         --  Anonymous access type\n+\n+         elsif Is_Access_Type (Formal_Typ)\n+           and then Is_Interface (Etype\n+                                  (Directly_Designated_Type\n+                                   (Formal_Typ)))\n+           and then Interface_Present_In_Ancestor\n+                      (Typ   => Etype (Directly_Designated_Type\n+                                        (Actual_Typ)),\n+                       Iface => Etype (Directly_Designated_Type\n+                                        (Formal_Typ)))\n+         then\n+\n+            if Nkind (Actual) = N_Attribute_Reference\n+              and then\n+               (Attribute_Name (Actual) = Name_Access\n+                 or else Attribute_Name (Actual) = Name_Unchecked_Access)\n+            then\n+               Nam := Attribute_Name (Actual);\n+\n+               Conversion :=\n+                 Convert_To\n+                   (Etype (Directly_Designated_Type (Formal_Typ)),\n+                    Prefix (Actual));\n+\n+               Rewrite (Actual, Conversion);\n+\n+               Analyze_And_Resolve (Actual,\n+                 Etype (Directly_Designated_Type (Formal_Typ)));\n+\n+               Rewrite (Actual,\n+                 Unchecked_Convert_To (Formal_Typ,\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix =>\n+                       Relocate_Node (Prefix (Expression (Actual))),\n+                     Attribute_Name => Nam)));\n+\n+               Analyze_And_Resolve (Actual, Formal_Typ);\n+\n+            else\n+               Conversion :=\n+                 Convert_To (Formal_Typ, New_Copy_Tree (Actual));\n+               Rewrite             (Actual, Conversion);\n+               Analyze_And_Resolve (Actual, Formal_Typ);\n+            end if;\n+         end if;\n+\n+         Next_Actual (Actual);\n+         Next_Formal (Formal);\n+      end loop;\n+   end Expand_Interface_Actuals;\n+\n+   ----------------------------\n+   -- Expand_Interface_Thunk --\n+   ----------------------------\n+\n+   function Expand_Interface_Thunk\n+     (N           : Node_Id;\n+      Thunk_Id    : Entity_Id;\n+      Iface_Tag   : Entity_Id) return Node_Id\n+   is\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Actuals     : constant List_Id    := New_List;\n+      Decl        : constant List_Id    := New_List;\n+      Formals     : constant List_Id    := New_List;\n+      Thunk_Tag   : constant Node_Id    := Iface_Tag;\n+      Thunk_Alias : constant Entity_Id  := Alias (Entity (N));\n+      Target      : Entity_Id;\n+      New_Code    : Node_Id;\n+      Formal      : Node_Id;\n+      New_Formal  : Node_Id;\n+      Decl_1      : Node_Id;\n+      Decl_2      : Node_Id;\n+      Subtyp_Mark : Node_Id;\n+\n+   begin\n+\n+      --  Traverse the list of alias to find the final target\n+\n+      Target := Thunk_Alias;\n+\n+      while Present (Alias (Target)) loop\n+         Target := Alias (Target);\n+      end loop;\n+\n+      --  Duplicate the formals\n+\n+      Formal := First_Formal (Thunk_Alias);\n+\n+      while Present (Formal) loop\n+         New_Formal := Copy_Separate_Tree (Parent (Formal));\n+\n+         --  Handle the case in which the subprogram covering\n+         --  the interface has been inherited:\n+\n+         --  Example:\n+         --     type I is interface;\n+         --     procedure P (X : in I) is abstract;\n+\n+         --     type T is tagged null record;\n+         --     procedure P (X : T);\n+\n+         --     type DT is new T and I with ...\n+\n+         if Is_Controlling_Formal (Formal) then\n+            Set_Parameter_Type (New_Formal,\n+              New_Reference_To (Etype (First_Entity (Entity (N))), Loc));\n+\n+            --  Why is this line silently commented out ???\n+\n+            --  New_Reference_To (Etype (Formal), Loc));\n+         end if;\n+\n+         Append_To (Formals, New_Formal);\n+         Next_Formal (Formal);\n+      end loop;\n+\n+      if Ekind (First_Formal (Thunk_Alias)) = E_In_Parameter\n+        and then Ekind (Etype (First_Formal (Thunk_Alias)))\n+                  = E_Anonymous_Access_Type\n+      then\n+\n+         --  Generate:\n+\n+         --     type T is access all <<type of the first formal>>\n+         --     S1 := Storage_Offset!(First_formal)\n+         --           - Storage_Offset!(First_Formal.Thunk_Tag'Position)\n+\n+         --  ... and the first actual of the call is generated as T!(S1)\n+\n+         Decl_2 :=\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc,\n+                 New_Internal_Name ('T')),\n+             Type_Definition =>\n+               Make_Access_To_Object_Definition (Loc,\n+                 All_Present            => True,\n+                 Null_Exclusion_Present => False,\n+                 Constant_Present       => False,\n+                 Subtype_Indication     =>\n+                   New_Reference_To\n+                     (Directly_Designated_Type\n+                        (Etype (First_Formal (Thunk_Alias))), Loc)\n+                         ));\n+\n+         Decl_1 :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc,\n+                 New_Internal_Name ('S')),\n+             Constant_Present    => True,\n+             Object_Definition   =>\n+               New_Reference_To (RTE (RE_Storage_Offset), Loc),\n+             Expression          =>\n+               Make_Op_Subtract (Loc,\n+                 Left_Opnd  =>\n+                   Unchecked_Convert_To\n+                     (RTE (RE_Storage_Offset),\n+                      New_Reference_To\n+                        (Defining_Identifier (First (Formals)), Loc)),\n+                  Right_Opnd =>\n+                    Unchecked_Convert_To\n+                      (RTE (RE_Storage_Offset),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix =>\n+                               New_Reference_To\n+                                 (Defining_Identifier (First (Formals)), Loc),\n+                             Selector_Name =>\n+                               New_Occurrence_Of (Thunk_Tag, Loc)),\n+                         Attribute_Name => Name_Position))));\n+\n+         Append_To (Decl, Decl_2);\n+         Append_To (Decl, Decl_1);\n+\n+         --  Reference the new first actual\n+\n+         Append_To (Actuals,\n+           Unchecked_Convert_To\n+             (Defining_Identifier (Decl_2),\n+              New_Reference_To (Defining_Identifier (Decl_1), Loc)));\n+\n+         --  Side note: The reverse order of declarations is just to ensure\n+         --  that the call to RE_Print is correct.\n+\n+      else\n+         --  Generate:\n+         --\n+         --     S1 := Storage_Offset!(First_formal'Address)\n+         --           - Storage_Offset!(First_Formal.Thunk_Tag'Position)\n+         --     S2 := Tag_Ptr!(S3)\n+\n+         Decl_1 :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, New_Internal_Name ('S')),\n+             Constant_Present    => True,\n+             Object_Definition   =>\n+               New_Reference_To (RTE (RE_Storage_Offset), Loc),\n+             Expression          =>\n+               Make_Op_Subtract (Loc,\n+                 Left_Opnd =>\n+                   Unchecked_Convert_To\n+                     (RTE (RE_Storage_Offset),\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix =>\n+                          New_Reference_To\n+                            (Defining_Identifier (First (Formals)), Loc),\n+                        Attribute_Name => Name_Address)),\n+                 Right_Opnd =>\n+                   Unchecked_Convert_To\n+                     (RTE (RE_Storage_Offset),\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix =>\n+                          Make_Selected_Component (Loc,\n+                            Prefix =>\n+                              New_Reference_To\n+                                (Defining_Identifier (First (Formals)), Loc),\n+                                 Selector_Name =>\n+                                   New_Occurrence_Of (Thunk_Tag, Loc)),\n+                        Attribute_Name => Name_Position))));\n+\n+         Decl_2 :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, New_Internal_Name ('S')),\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (RTE (RE_Addr_Ptr), Loc),\n+             Expression          =>\n+               Unchecked_Convert_To\n+                 (RTE (RE_Addr_Ptr),\n+                  New_Reference_To (Defining_Identifier (Decl_1), Loc)));\n+\n+         Append_To (Decl, Decl_1);\n+         Append_To (Decl, Decl_2);\n+\n+         --  Reference the new first actual\n+\n+         Append_To (Actuals,\n+           Unchecked_Convert_To\n+             (Etype (First_Entity (Target)),\n+              Make_Explicit_Dereference (Loc,\n+                New_Reference_To (Defining_Identifier (Decl_2), Loc))));\n+\n+      end if;\n+\n+      Formal := Next (First (Formals));\n+      while Present (Formal) loop\n+         Append_To (Actuals,\n+            New_Reference_To (Defining_Identifier (Formal), Loc));\n+         Next (Formal);\n+      end loop;\n+\n+      if Ekind (Thunk_Alias) = E_Procedure then\n+         New_Code :=\n+           Make_Subprogram_Body (Loc,\n+              Specification =>\n+                Make_Procedure_Specification (Loc,\n+                  Defining_Unit_Name       => Thunk_Id,\n+                  Parameter_Specifications => Formals),\n+              Declarations => Decl,\n+              Handled_Statement_Sequence =>\n+                Make_Handled_Sequence_Of_Statements (Loc,\n+                  Statements => New_List (\n+                    Make_Procedure_Call_Statement (Loc,\n+                       Name => New_Occurrence_Of (Target, Loc),\n+                       Parameter_Associations => Actuals))));\n+\n+      else pragma Assert (Ekind (Thunk_Alias) = E_Function);\n+\n+         if not Present (Alias (Thunk_Alias)) then\n+            Subtyp_Mark := Subtype_Mark (Parent (Thunk_Alias));\n+         else\n+            --  The last element in the alias list has the correct subtype_mark\n+            --  of the function result\n+\n+            declare\n+               E : Entity_Id := Alias (Thunk_Alias);\n+            begin\n+               while Present (Alias (E)) loop\n+                  E := Alias (E);\n+               end loop;\n+               Subtyp_Mark := Subtype_Mark (Parent (E));\n+            end;\n+         end if;\n+\n+         New_Code :=\n+           Make_Subprogram_Body (Loc,\n+              Specification =>\n+                Make_Function_Specification (Loc,\n+                  Defining_Unit_Name       => Thunk_Id,\n+                  Parameter_Specifications => Formals,\n+                  Subtype_Mark => New_Copy (Subtyp_Mark)),\n+              Declarations => Decl,\n+              Handled_Statement_Sequence =>\n+                Make_Handled_Sequence_Of_Statements (Loc,\n+                  Statements => New_List (\n+                    Make_Return_Statement (Loc,\n+                      Make_Function_Call (Loc,\n+                        Name => New_Occurrence_Of (Target, Loc),\n+                        Parameter_Associations => Actuals)))));\n+      end if;\n+\n+      Analyze (New_Code);\n+      Insert_After (N, New_Code);\n+      return New_Code;\n+   end Expand_Interface_Thunk;\n+\n    -------------\n    -- Fill_DT --\n    -------------\n \n    function Fill_DT_Entry\n-     (Loc  : Source_Ptr;\n-      Prim : Entity_Id)\n-      return Node_Id\n+     (Loc      : Source_Ptr;\n+      Prim     : Entity_Id;\n+      Thunk_Id : Entity_Id := Empty) return Node_Id\n    is\n-      Typ    : constant Entity_Id := Scope (DTC_Entity (Prim));\n-      DT_Ptr : constant Entity_Id := Node (First_Elmt\n-                                           (Access_Disp_Table (Typ)));\n+      Typ     : constant Entity_Id := Scope (DTC_Entity (Prim));\n+      DT_Ptr  : Entity_Id := Node (First_Elmt (Access_Disp_Table (Typ)));\n+      Target  : Entity_Id;\n+      Tag     : Entity_Id := First_Tag_Component (Typ);\n+      Prim_Op : Entity_Id := Prim;\n \n    begin\n+      --  Ada 2005 (AI-251): If we have a thunk available then generate code\n+      --  that saves its address in the secondary dispatch table of its\n+      --  abstract interface; otherwise save the address of the primitive\n+      --  subprogram in the main virtual table.\n+\n+      if Thunk_Id /= Empty then\n+         Target := Thunk_Id;\n+      else\n+         Target := Prim;\n+      end if;\n+\n+      --  Ada 2005 (AI-251): If the subprogram is the alias of an abstract\n+      --  interface subprogram then find the correct dispatch table pointer\n+\n+      if Present (Abstract_Interface_Alias (Prim)) then\n+         Prim_Op := Abstract_Interface_Alias (Prim);\n+\n+         DT_Ptr  := Find_Interface_ADT\n+                      (T     => Typ,\n+                       Iface => Scope (DTC_Entity (Prim_Op)));\n+\n+         Tag := First_Tag_Component (Scope (DTC_Entity (Prim_Op)));\n+      end if;\n+\n+      pragma Assert (DT_Position (Prim_Op) <= DT_Entry_Count (Tag));\n+      pragma Assert (DT_Position (Prim_Op) > Uint_0);\n+\n       return\n         Make_DT_Access_Action (Typ,\n           Action => Set_Prim_Op_Address,\n           Args   => New_List (\n-            New_Reference_To (DT_Ptr, Loc),                     -- DTptr\n+            Unchecked_Convert_To (RTE (RE_Tag),\n+              New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n \n-            Make_Integer_Literal (Loc, DT_Position (Prim)),     -- Position\n+            Make_Integer_Literal (Loc, DT_Position (Prim_Op)),  -- Position\n \n             Make_Attribute_Reference (Loc,                      -- Value\n-              Prefix          => New_Reference_To (Prim, Loc),\n+              Prefix          => New_Reference_To (Target, Loc),\n               Attribute_Name  => Name_Address)));\n    end Fill_DT_Entry;\n \n@@ -614,11 +1233,9 @@ package body Exp_Disp is\n    -------------\n \n    function Make_DT (Typ : Entity_Id) return List_Id is\n-      Loc : constant Source_Ptr := Sloc (Typ);\n-\n-      ADT_List  : constant Elist_Id := New_Elmt_List;\n-      Result    : constant List_Id  := New_List;\n-      Elab_Code : constant List_Id  := New_List;\n+      Loc         : constant Source_Ptr := Sloc (Typ);\n+      Result      : constant List_Id    := New_List;\n+      Elab_Code   : constant List_Id    := New_List;\n \n       Tname       : constant Name_Id := Chars (Typ);\n       Name_DT     : constant Name_Id := New_External_Name (Tname, 'T');\n@@ -633,23 +1250,69 @@ package body Exp_Disp is\n       Exname : constant Node_Id := Make_Defining_Identifier (Loc, Name_Exname);\n       No_Reg : constant Node_Id := Make_Defining_Identifier (Loc, Name_No_Reg);\n \n+      Generalized_Tag : constant Entity_Id := RTE (RE_Tag);\n       I_Depth         : Int;\n-      Generalized_Tag : Entity_Id;\n       Size_Expr_Node  : Node_Id;\n       Old_Tag1        : Node_Id;\n       Old_Tag2        : Node_Id;\n+      Num_Ifaces      : Int;\n+      Nb_Prim         : Int;\n+      TSD_Num_Entries : Int;\n+      Typ_Copy        : constant Entity_Id := New_Copy (Typ);\n+      AI              : Elmt_Id;\n \n    begin\n       if not RTE_Available (RE_Tag) then\n          Error_Msg_CRT (\"tagged types\", Typ);\n          return New_List;\n       end if;\n \n-      if Is_CPP_Class (Root_Type (Typ)) then\n-         Generalized_Tag := RTE (RE_Vtable_Ptr);\n-      else\n-         Generalized_Tag := RTE (RE_Tag);\n-      end if;\n+      --  Collect the full list of directly and indirectly implemented\n+      --  interfaces\n+\n+      Set_Parent              (Typ_Copy, Parent (Typ));\n+      Set_Abstract_Interfaces (Typ_Copy, New_Elmt_List);\n+      Collect_All_Interfaces  (Typ_Copy);\n+\n+      --  Calculate the number of entries required in the table of interfaces\n+\n+      Num_Ifaces := 0;\n+      AI         := First_Elmt (Abstract_Interfaces (Typ_Copy));\n+\n+      while Present (AI) loop\n+         Num_Ifaces := Num_Ifaces + 1;\n+         Next_Elmt (AI);\n+      end loop;\n+\n+      --  Count ancestors to compute the inheritance depth. For private\n+      --  extensions, always go to the full view in order to compute the real\n+      --  inheritance depth.\n+\n+      declare\n+         Parent_Type : Entity_Id := Typ;\n+         P           : Entity_Id;\n+\n+      begin\n+         I_Depth := 0;\n+\n+         loop\n+            P := Etype (Parent_Type);\n+\n+            if Is_Private_Type (P) then\n+               P := Full_View (Base_Type (P));\n+            end if;\n+\n+            exit when P = Parent_Type;\n+\n+            I_Depth := I_Depth + 1;\n+            Parent_Type := P;\n+         end loop;\n+      end;\n+\n+      TSD_Num_Entries := I_Depth + Num_Ifaces + 1;\n+      Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n+\n+      --  ----------------------------------------------------------------\n \n       --  Dispatch table and related entities are allocated statically\n \n@@ -681,8 +1344,7 @@ package body Exp_Disp is\n               Left_Opnd  =>\n                 Make_DT_Access_Action (Typ, DT_Entry_Size, No_List),\n               Right_Opnd =>\n-                Make_Integer_Literal (Loc,\n-                  DT_Entry_Count (First_Tag_Component (Typ)))));\n+                Make_Integer_Literal (Loc, Nb_Prim)));\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n@@ -708,14 +1370,11 @@ package body Exp_Disp is\n \n       --  Generate code to create the pointer to the dispatch table\n \n-      --    DT_Ptr : Tag := Tag!(DT'Address);                 Ada case\n-      --  or\n-      --    DT_Ptr : Vtable_Ptr := Vtable_Ptr!(DT'Address);   CPP case\n+      --    DT_Ptr : Tag := Tag!(DT'Address);\n \n-      --  According to the C++ ABI, the base of the vtable is located\n-      --  after the following prologue: Offset_To_Top, Typeinfo_Ptr.\n-      --  Hence, move the pointer to the base of the vtable down, after\n-      --  this prologue.\n+      --  According to the C++ ABI, the base of the vtable is located after a\n+      --  prologue containing Offset_To_Top, and Typeinfo_Ptr. Hence, we move\n+      --  down the pointer to the real base of the vtable\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n@@ -746,37 +1405,18 @@ package body Exp_Disp is\n \n       --  Set Access_Disp_Table field to be the dispatch table pointer\n \n-      Append_Elmt (DT_Ptr, ADT_List);\n-      Set_Access_Disp_Table (Typ, ADT_List);\n+      if not Present (Access_Disp_Table (Typ)) then\n+         Set_Access_Disp_Table (Typ, New_Elmt_List);\n+      end if;\n \n-      --  Count ancestors to compute the inheritance depth. For private\n-      --  extensions, always go to the full view in order to compute the real\n-      --  inheritance depth.\n-\n-      declare\n-         Parent_Type : Entity_Id := Typ;\n-         P           : Entity_Id;\n-\n-      begin\n-         I_Depth := 0;\n-\n-         loop\n-            P := Etype (Parent_Type);\n-\n-            if Is_Private_Type (P) then\n-               P := Full_View (Base_Type (P));\n-            end if;\n-\n-            exit when P = Parent_Type;\n-\n-            I_Depth := I_Depth + 1;\n-            Parent_Type := P;\n-         end loop;\n-      end;\n+      Prepend_Elmt (DT_Ptr, Access_Disp_Table (Typ));\n \n       --  Generate code to create the storage for the type specific data object\n-\n-      --   TSD: Storage_Array (1..TSD_Prologue_Size+(1+Idepth)*TSD_Entry_Size);\n+      --  with enough space to store the tags of the ancestors plus the tags\n+      --  of all the implemented interfaces (as described in a-tags.adb)\n+      --\n+      --   TSD: Storage_Array\n+      --     (1..TSD_Prologue_Size+TSD_Num_Entries*TSD_Entry_Size);\n       --   for TSD'Alignment use Address'Alignment\n \n       Size_Expr_Node :=\n@@ -788,10 +1428,7 @@ package body Exp_Disp is\n               Left_Opnd  =>\n                 Make_DT_Access_Action (Typ, TSD_Entry_Size, No_List),\n               Right_Opnd =>\n-                Make_Op_Add (Loc,\n-                  Left_Opnd  => Make_Integer_Literal (Loc, 1),\n-                  Right_Opnd =>\n-                    Make_Integer_Literal (Loc, I_Depth))));\n+                Make_Integer_Literal (Loc, TSD_Num_Entries)));\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n@@ -827,6 +1464,50 @@ package body Exp_Disp is\n               Prefix          => New_Reference_To (TSD, Loc),\n               Attribute_Name  => Name_Address))));\n \n+      --  Generate: Exname : constant String := full_qualified_name (typ);\n+      --  The type itself may be an anonymous parent type, so use the first\n+      --  subtype to have a user-recognizable name.\n+\n+      Append_To (Result,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Exname,\n+          Constant_Present    => True,\n+          Object_Definition   => New_Reference_To (Standard_String, Loc),\n+          Expression =>\n+            Make_String_Literal (Loc,\n+              Full_Qualified_Name (First_Subtype (Typ)))));\n+\n+      --  Generate: Set_Expanded_Name (DT_Ptr, exname'Address);\n+\n+      Append_To (Elab_Code,\n+        Make_DT_Access_Action (Typ,\n+          Action => Set_Expanded_Name,\n+          Args   => New_List (\n+            Node1 => New_Reference_To (DT_Ptr, Loc),\n+            Node2 =>\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (Exname, Loc),\n+                Attribute_Name => Name_Address))));\n+\n+      --  Generate: Set_Access_Level (DT_Ptr, <type's accessibility level>);\n+\n+      Append_To (Elab_Code,\n+        Make_DT_Access_Action (Typ,\n+          Action => Set_Access_Level,\n+          Args   => New_List (\n+            Node1 => New_Reference_To (DT_Ptr, Loc),\n+            Node2 => Make_Integer_Literal (Loc, Type_Access_Level (Typ)))));\n+\n+      --  Generate:\n+      --    Set_Offset_To_Top (DT_Ptr, 0);\n+\n+      Append_To (Elab_Code,\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n+          Parameter_Associations => New_List (\n+            New_Reference_To (DT_Ptr, Loc),\n+            Make_Integer_Literal (Loc, Uint_0))));\n+\n       if Typ = Etype (Typ)\n         or else Is_CPP_Class (Etype (Typ))\n       then\n@@ -866,31 +1547,6 @@ package body Exp_Disp is\n             Node1 => Old_Tag2,\n             Node2 => New_Reference_To (DT_Ptr, Loc))));\n \n-      --  Generate: Exname : constant String := full_qualified_name (typ);\n-      --  The type itself may be an anonymous parent type, so use the first\n-      --  subtype to have a user-recognizable name.\n-\n-      Append_To (Result,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Exname,\n-          Constant_Present    => True,\n-          Object_Definition   => New_Reference_To (Standard_String, Loc),\n-          Expression =>\n-            Make_String_Literal (Loc,\n-              Full_Qualified_Name (First_Subtype (Typ)))));\n-\n-      --  Generate: Set_Expanded_Name (DT_Ptr, exname'Address);\n-\n-      Append_To (Elab_Code,\n-        Make_DT_Access_Action (Typ,\n-          Action => Set_Expanded_Name,\n-          Args   => New_List (\n-            Node1 => New_Reference_To (DT_Ptr, Loc),\n-            Node2 =>\n-              Make_Attribute_Reference (Loc,\n-                Prefix => New_Reference_To (Exname, Loc),\n-                Attribute_Name => Name_Address))));\n-\n       --  for types with no controlled components\n       --    Generate: Set_RC_Offset (DT_Ptr, 0);\n       --  for simple types with controlled components\n@@ -1022,29 +1678,192 @@ package body Exp_Disp is\n           Condition       => New_Reference_To (No_Reg, Loc),\n           Then_Statements => Elab_Code));\n \n+      --  Ada 2005 (AI-251): Register the tag of the interfaces into\n+      --  the table of implemented interfaces\n+\n+      if Present (Abstract_Interfaces (Typ))\n+        and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+      then\n+         AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n+         while Present (AI) loop\n+\n+            --  Generate:\n+            --    Register_Interface (DT_Ptr, Interface'Tag);\n+\n+            Append_To (Result,\n+              Make_DT_Access_Action (Typ,\n+                Action => Register_Interface_Tag,\n+                Args   => New_List (\n+                  Node1 => New_Reference_To (DT_Ptr, Loc),\n+                  Node2 => New_Reference_To\n+                             (Node\n+                              (First_Elmt\n+                               (Access_Disp_Table (Node (AI)))),\n+                              Loc))));\n+\n+            Next_Elmt (AI);\n+         end loop;\n+      end if;\n+\n       return Result;\n    end Make_DT;\n \n+   --------------------------------\n+   -- Make_Abstract_Interface_DT --\n+   --------------------------------\n+\n+   procedure Make_Abstract_Interface_DT\n+     (AI_Tag          : Entity_Id;\n+      Acc_Disp_Tables : in out Elist_Id;\n+      Result          : out List_Id)\n+   is\n+      Loc         : constant Source_Ptr := Sloc (AI_Tag);\n+      Tname       : constant Name_Id := Chars (AI_Tag);\n+      Name_DT     : constant Name_Id := New_External_Name (Tname, 'T');\n+      Name_DT_Ptr : constant Name_Id := New_External_Name (Tname, 'P');\n+\n+      Iface_DT     : constant Node_Id :=\n+                       Make_Defining_Identifier (Loc, Name_DT);\n+      Iface_DT_Ptr : constant Node_Id :=\n+                       Make_Defining_Identifier (Loc, Name_DT_Ptr);\n+\n+      Generalized_Tag : constant Entity_Id := RTE (RE_Interface_Tag);\n+      Size_Expr_Node  : Node_Id;\n+      Nb_Prim         : Int;\n+\n+   begin\n+      Result := New_List;\n+\n+      --  Dispatch table and related entities are allocated statically\n+\n+      Set_Ekind (Iface_DT, E_Variable);\n+      Set_Is_Statically_Allocated (Iface_DT);\n+\n+      Set_Ekind (Iface_DT_Ptr, E_Variable);\n+      Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+\n+      --  Generate code to create the storage for the Dispatch_Table object\n+\n+      --    DT : Storage_Array (1..DT_Prologue_Size+nb_prim*DT_Entry_Size);\n+      --    for DT'Alignment use Address'Alignment\n+\n+      Nb_Prim := UI_To_Int (DT_Entry_Count (AI_Tag));\n+\n+      Size_Expr_Node :=\n+        Make_Op_Add (Loc,\n+          Left_Opnd  => Make_DT_Access_Action (Etype (AI_Tag),\n+                          DT_Prologue_Size,\n+                          No_List),\n+          Right_Opnd =>\n+            Make_Op_Multiply (Loc,\n+              Left_Opnd  =>\n+                Make_DT_Access_Action (Etype (AI_Tag),\n+                                       DT_Entry_Size,\n+                                       No_List),\n+              Right_Opnd =>\n+                Make_Integer_Literal (Loc, Nb_Prim)));\n+\n+      Append_To (Result,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Iface_DT,\n+          Aliased_Present     => True,\n+          Object_Definition   =>\n+            Make_Subtype_Indication (Loc,\n+              Subtype_Mark => New_Reference_To (RTE (RE_Storage_Array), Loc),\n+              Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n+                Constraints => New_List (\n+                  Make_Range (Loc,\n+                    Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                    High_Bound => Size_Expr_Node)))),\n+\n+            --  Initialize the signature of the interface tag. It is currently\n+            --  a sequence of four bytes located in the unused Typeinfo_Ptr\n+            --  field of the prologue). Its current value is the following\n+            --  sequence: (80, Nb_Prim, 0, 80)\n+\n+          Expression =>\n+            Make_Aggregate (Loc,\n+              Component_Associations => New_List (\n+                Make_Component_Association (Loc,\n+\n+                  --  -80, 0, 0, -80\n+\n+                  Choices => New_List (\n+                    Make_Integer_Literal (Loc, Uint_5),\n+                    Make_Integer_Literal (Loc, Uint_8)),\n+                  Expression =>\n+                    Make_Integer_Literal (Loc, Uint_80)),\n+\n+                Make_Component_Association (Loc,\n+                  Choices => New_List (\n+                    Make_Integer_Literal (Loc, Uint_2)),\n+                  Expression =>\n+                    Make_Integer_Literal (Loc, Nb_Prim)),\n+\n+                Make_Component_Association (Loc,\n+                  Choices => New_List (\n+                    Make_Others_Choice (Loc)),\n+                  Expression => Make_Integer_Literal (Loc, Uint_0))))));\n+\n+      Append_To (Result,\n+        Make_Attribute_Definition_Clause (Loc,\n+          Name       => New_Reference_To (Iface_DT, Loc),\n+          Chars      => Name_Alignment,\n+          Expression =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix => New_Reference_To (RTE (RE_Integer_Address), Loc),\n+              Attribute_Name => Name_Alignment)));\n+\n+      --  Generate code to create the pointer to the dispatch table\n+\n+      --    Iface_DT_Ptr : Tag := Tag!(DT'Address);\n+\n+      --  According to the C++ ABI, the base of the vtable is located\n+      --  after the following prologue: Offset_To_Top, and Typeinfo_Ptr.\n+      --  Hence, move the pointer down to the real base of the vtable.\n+\n+      Append_To (Result,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Iface_DT_Ptr,\n+          Constant_Present    => True,\n+          Object_Definition   => New_Reference_To (Generalized_Tag, Loc),\n+          Expression          =>\n+            Unchecked_Convert_To (Generalized_Tag,\n+              Make_Op_Add (Loc,\n+                Left_Opnd =>\n+                  Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Reference_To (Iface_DT, Loc),\n+                      Attribute_Name => Name_Address)),\n+                Right_Opnd =>\n+                  Make_DT_Access_Action (Etype (AI_Tag),\n+                    DT_Prologue_Size, No_List)))));\n+\n+      --  Note: Offset_To_Top will be initialized by the init subprogram\n+\n+      --  Set Access_Disp_Table field to be the dispatch table pointer\n+\n+      if not (Present (Acc_Disp_Tables)) then\n+         Acc_Disp_Tables := New_Elmt_List;\n+      end if;\n+\n+      Append_Elmt (Iface_DT_Ptr, Acc_Disp_Tables);\n+\n+   end Make_Abstract_Interface_DT;\n+\n    ---------------------------\n    -- Make_DT_Access_Action --\n    ---------------------------\n \n    function Make_DT_Access_Action\n      (Typ    : Entity_Id;\n       Action : DT_Access_Action;\n-      Args   : List_Id)\n-      return Node_Id\n+      Args   : List_Id) return Node_Id\n    is\n-      Action_Name : Entity_Id;\n+      Action_Name : constant Entity_Id := RTE (Ada_Actions (Action));\n       Loc         : Source_Ptr;\n \n    begin\n-      if Is_CPP_Class (Root_Type (Typ)) then\n-         Action_Name := RTE (CPP_Actions (Action));\n-      else\n-         Action_Name := RTE (Ada_Actions (Action));\n-      end if;\n-\n       if No (Args) then\n \n          --  This is a constant\n@@ -1106,15 +1925,61 @@ package body Exp_Disp is\n       Root_Typ   : constant Entity_Id := Root_Type (Typ);\n       First_Prim : constant Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n       The_Tag    : constant Entity_Id := First_Tag_Component (Typ);\n+\n       Adjusted   : Boolean := False;\n       Finalized  : Boolean := False;\n-      Parent_EC  : Int;\n+\n+      Count_Prim : Int;\n+      DT_Length  : Int;\n       Nb_Prim    : Int;\n+      Parent_EC  : Int;\n       Prim       : Entity_Id;\n       Prim_Elmt  : Elmt_Id;\n \n-   begin\n+      procedure Validate_Position (Prim : Entity_Id);\n+      --  Check that the position assignated to Prim is completely safe\n+      --  (it has not been assigned to a previously defined primitive\n+      --   operation of Typ)\n+\n+      -----------------------\n+      -- Validate_Position --\n+      -----------------------\n+\n+      procedure Validate_Position (Prim : Entity_Id) is\n+         Prim_Elmt : Elmt_Id;\n+      begin\n+         Prim_Elmt :=  First_Elmt (Primitive_Operations (Typ));\n+         while Present (Prim_Elmt)\n+            and then Node (Prim_Elmt) /= Prim\n+         loop\n+            --  Primitive operations covering abstract interfaces are\n+            --  allocated later\n+\n+            if Present (Abstract_Interface_Alias (Node (Prim_Elmt))) then\n+               null;\n+\n+            --  Predefined dispatching operations are completely safe.\n+            --  They are allocated at fixed positions.\n+\n+            elsif Is_Predefined_Dispatching_Operation (Node (Prim_Elmt)) then\n+               null;\n \n+            --  Aliased subprograms are safe\n+\n+            elsif Present (Alias (Prim)) then\n+               null;\n+\n+            elsif DT_Position (Node (Prim_Elmt)) = DT_Position (Prim) then\n+               raise Program_Error;\n+            end if;\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+      end Validate_Position;\n+\n+   --  Start of processing for Set_All_DT_Position\n+\n+   begin\n       --  Get Entry_Count of the parent\n \n       if Parent_Typ /= Typ\n@@ -1246,26 +2111,218 @@ package body Exp_Disp is\n       --  in a-tags.ad?)\n \n       else\n-         Nb_Prim := 1;\n-         Prim_Elmt := First_Prim;\n+         --  First stage: Set the DTC entity of all the primitive operations\n+         --  This is required to properly read the DT_Position attribute in\n+         --  the latter stages.\n+\n+         Prim_Elmt  := First_Prim;\n+         Count_Prim := 0;\n          while Present (Prim_Elmt) loop\n-            Nb_Prim := Nb_Prim + 1;\n-            Prim := Node (Prim_Elmt);\n-            Set_DTC_Entity (Prim, The_Tag);\n+            Count_Prim := Count_Prim + 1;\n+            Prim       := Node (Prim_Elmt);\n+\n+            --  Ada 2005 (AI-251)\n+\n+            if Present (Abstract_Interface_Alias (Prim)) then\n+               Set_DTC_Entity (Prim,\n+                  Find_Interface_Tag\n+                    (T => Typ,\n+                     Iface => Scope (DTC_Entity\n+                                      (Abstract_Interface_Alias (Prim)))));\n \n-            if Chars (Prim) = Name_uSize then\n-               Set_DT_Position (Prim, Uint_1);\n-               Nb_Prim := Nb_Prim - 1;\n             else\n-               Set_DT_Position (Prim, UI_From_Int (Nb_Prim));\n+               Set_DTC_Entity (Prim, The_Tag);\n             end if;\n \n-            if Chars (Prim) = Name_Finalize\n-              and then\n-                (Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n-                   or else not Is_Predefined_File_Name\n-                                  (Unit_File_Name (Get_Source_Unit (Prim))))\n+            --  Clear any previous value of the DT_Position attribute. In this\n+            --  way we ensure that the final position of all the primitives is\n+            --  stablished by the following stages of this algorithm.\n+\n+            Set_DT_Position (Prim, No_Uint);\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+\n+         declare\n+            Fixed_Prim : array (Int range 0 .. 10 + Parent_EC + Count_Prim)\n+                            of Boolean := (others => False);\n+            E          : Entity_Id;\n+\n+         begin\n+            --  Second stage: Register fixed entries\n+\n+            Nb_Prim   := 10;\n+            Prim_Elmt := First_Prim;\n+\n+            while Present (Prim_Elmt) loop\n+               Prim := Node (Prim_Elmt);\n+\n+               --  Predefined primitives have a fixed position in all the\n+               --  dispatch tables\n+\n+               if Is_Predefined_Dispatching_Operation (Prim) then\n+                  Set_DT_Position (Prim, Default_Prim_Op_Position (Prim));\n+                  Fixed_Prim (UI_To_Int (DT_Position (Prim))) := True;\n+\n+               --  Overriding interface primitives of an ancestor\n+\n+               elsif DT_Position (Prim) = No_Uint\n+                 and then Present (Abstract_Interface_Alias (Prim))\n+                 and then Present (DTC_Entity\n+                                   (Abstract_Interface_Alias (Prim)))\n+                 and then DT_Position (Abstract_Interface_Alias (Prim))\n+                                        /= No_Uint\n+                 and then Is_Inherited_Operation (Prim)\n+                 and then Is_Ancestor (Scope\n+                                       (DTC_Entity\n+                                        (Abstract_Interface_Alias (Prim))),\n+                                       Typ)\n+               then\n+                  Set_DT_Position (Prim,\n+                    DT_Position (Abstract_Interface_Alias (Prim)));\n+                  Set_DT_Position (Alias (Prim),\n+                    DT_Position (Abstract_Interface_Alias (Prim)));\n+                  Fixed_Prim (UI_To_Int (DT_Position (Prim))) := True;\n+\n+               --  Overriding primitives must use the same entry as the\n+               --  overriden primitive\n+\n+               elsif DT_Position (Prim) = No_Uint\n+                 and then Present (Alias (Prim))\n+                 and then Present (DTC_Entity (Alias (Prim)))\n+                 and then DT_Position (Alias (Prim)) /= No_Uint\n+                 and then Is_Inherited_Operation (Prim)\n+                 and then Is_Ancestor (Scope (DTC_Entity (Alias (Prim))), Typ)\n+               then\n+                  E := Alias (Prim);\n+                  while not (Present (DTC_Entity (E))\n+                              or else DT_Position (E) = No_Uint)\n+                    and then Present (Alias (E))\n+                  loop\n+                     E := Alias (E);\n+                  end loop;\n+\n+                  pragma Assert (Present (DTC_Entity (E))\n+                                   and then\n+                                 DT_Position (E) /= No_Uint);\n+\n+                  Set_DT_Position (Prim, DT_Position (E));\n+                  Fixed_Prim (UI_To_Int (DT_Position (E))) := True;\n+\n+                  --  If this is not the last element in the chain continue\n+                  --  traversing the chain. This is required to properly\n+                  --  handling renamed primitives\n+\n+                  if Present (Alias (E)) then\n+                     while Present (Alias (E)) loop\n+                        E   := Alias (E);\n+                        Fixed_Prim (UI_To_Int (DT_Position (E))) := True;\n+                     end loop;\n+                  end if;\n+               end if;\n+\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+\n+            --  Third stage: Fix the position of all the new primitives\n+            --  Entries associated with primitives covering interfaces\n+            --  are handled in a latter round.\n+\n+            Prim_Elmt := First_Prim;\n+            while Present (Prim_Elmt) loop\n+               Prim := Node (Prim_Elmt);\n+\n+               --  Skip primitives previously set entries\n+\n+               if DT_Position (Prim) /= No_Uint then\n+                  null;\n+\n+               elsif Etype (DTC_Entity (Prim)) /= RTE (RE_Tag) then\n+                  null;\n+\n+               --  Primitives covering interface primitives are\n+               --  handled later\n+\n+               elsif Present (Abstract_Interface_Alias (Prim)) then\n+                  null;\n+\n+               else\n+                  --  Take the next available position in the DT\n+\n+                  loop\n+                     Nb_Prim := Nb_Prim + 1;\n+                     exit when not Fixed_Prim (Nb_Prim);\n+                  end loop;\n+\n+                  Set_DT_Position (Prim, UI_From_Int (Nb_Prim));\n+                  Fixed_Prim (Nb_Prim) := True;\n+               end if;\n+\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+         end;\n+\n+         --  Fourth stage: Complete the decoration of primitives covering\n+         --  interfaces (that is, propagate the DT_Position attribute\n+         --  from the aliased primitive)\n+\n+         Prim_Elmt := First_Prim;\n+         while Present (Prim_Elmt) loop\n+            Prim := Node (Prim_Elmt);\n+\n+            if DT_Position (Prim) = No_Uint\n+               and then Present (Abstract_Interface_Alias (Prim))\n             then\n+               --  Check if this entry will be placed in the primary DT\n+\n+               if Etype (DTC_Entity (Abstract_Interface_Alias (Prim)))\n+                    = RTE (RE_Tag)\n+               then\n+                  pragma Assert (DT_Position (Alias (Prim)) /= No_Uint);\n+                  Set_DT_Position (Prim, DT_Position (Alias (Prim)));\n+\n+               --  Otherwise it will be placed in the secondary DT\n+\n+               else\n+                  pragma Assert\n+                    (DT_Position (Abstract_Interface_Alias (Prim)) /= No_Uint);\n+\n+                  Set_DT_Position (Prim,\n+                     DT_Position (Abstract_Interface_Alias (Prim)));\n+               end if;\n+            end if;\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+\n+         --  Final stage: Ensure that the table is correct plus some further\n+         --  verifications concerning the primitives.\n+\n+         Prim_Elmt := First_Prim;\n+         DT_Length := 0;\n+\n+         while Present (Prim_Elmt) loop\n+            Prim := Node (Prim_Elmt);\n+\n+            --  At this point all the primitives MUST have a position\n+            --  in the dispatch table\n+\n+            if DT_Position (Prim) = No_Uint then\n+               raise Program_Error;\n+            end if;\n+\n+            --  Calculate real size of the dispatch table\n+\n+            if UI_To_Int (DT_Position (Prim)) > DT_Length then\n+               DT_Length := UI_To_Int (DT_Position (Prim));\n+            end if;\n+\n+            --  Ensure that the asignated position in the dispatch\n+            --  table is correct\n+\n+            Validate_Position (Prim);\n+\n+            if Chars (Prim) = Name_Finalize then\n                Finalized := True;\n             end if;\n \n@@ -1275,17 +2332,19 @@ package body Exp_Disp is\n \n             --  An abstract operation cannot be declared in the private part\n             --  for a visible abstract type, because it could never be over-\n-            --  ridden. For explicit declarations this is checked at the point\n-            --  of declaration, but for inherited operations it must be done\n-            --  when building the dispatch table. Input is excluded because\n+            --  ridden. For explicit declarations this is checked at the\n+            --  point of declaration, but for inherited operations it must\n+            --  be done when building the dispatch table. Input is excluded\n+            --  because\n \n             if Is_Abstract (Typ)\n               and then Is_Abstract (Prim)\n               and then Present (Alias (Prim))\n               and then Is_Derived_Type (Typ)\n               and then In_Private_Part (Current_Scope)\n-              and then List_Containing (Parent (Prim))\n-               =  Private_Declarations\n+              and then\n+                List_Containing (Parent (Prim)) =\n+                  Private_Declarations\n                    (Specification (Unit_Declaration_Node (Current_Scope)))\n               and then Original_View_In_Visible_Part (Typ)\n             then\n@@ -1301,12 +2360,15 @@ package body Exp_Disp is\n                   Error_Msg_NE\n                     (\"abstract inherited private operation&\" &\n                      \" must be overridden ('R'M 3.9.3(10))\",\n-                     Parent (Typ), Prim);\n+                    Parent (Typ), Prim);\n                end if;\n             end if;\n+\n             Next_Elmt (Prim_Elmt);\n          end loop;\n \n+         --  Additional check\n+\n          if Is_Controlled (Typ) then\n             if not Finalized then\n                Error_Msg_N\n@@ -1318,15 +2380,28 @@ package body Exp_Disp is\n             end if;\n          end if;\n \n-         Set_DT_Entry_Count (The_Tag, UI_From_Int (Nb_Prim));\n+         --  Set the final size of the Dispatch Table\n+\n+         Set_DT_Entry_Count (The_Tag, UI_From_Int (DT_Length));\n \n          --  The derived type must have at least as many components as its\n          --  parent (for root types, the Etype points back to itself\n          --  and the test should not fail)\n \n-         pragma Assert (\n-           DT_Entry_Count (The_Tag) >=\n-           DT_Entry_Count (First_Tag_Component (Parent_Typ)));\n+         --  This test fails compiling the partial view of a tagged type\n+         --  derived from an interface which defines the overriding subprogram\n+         --  in the private part. This needs further investigation???\n+\n+         if not Has_Private_Declaration (Typ) then\n+            pragma Assert (\n+              DT_Entry_Count (The_Tag) >=\n+              DT_Entry_Count (First_Tag_Component (Parent_Typ)));\n+            null;\n+         end if;\n+      end if;\n+\n+      if Debug_Flag_ZZ then\n+         Write_DT (Typ);\n       end if;\n    end Set_All_DT_Position;\n \n@@ -1382,4 +2457,104 @@ package body Exp_Disp is\n       end if;\n    end Set_Default_Constructor;\n \n+   --------------\n+   -- Write_DT --\n+   --------------\n+\n+   procedure Write_DT (Typ : Entity_Id) is\n+      Elmt : Elmt_Id;\n+      Prim : Node_Id;\n+\n+   begin\n+      --  Protect this procedure against wrong usage. Required because it will\n+      --  be used directly from GDB\n+\n+      if not (Typ in First_Node_Id .. Last_Node_Id)\n+        or else not Is_Tagged_Type (Typ)\n+      then\n+         Write_Str (\"wrong usage: write_dt must be used with tagged types\");\n+         Write_Eol;\n+         return;\n+      end if;\n+\n+      Write_Int (Int (Typ));\n+      Write_Str (\": \");\n+      Write_Name (Chars (Typ));\n+\n+      if Is_Interface (Typ) then\n+         Write_Str (\" is interface\");\n+      end if;\n+\n+      Write_Eol;\n+\n+      Elmt := First_Elmt (Primitive_Operations (Typ));\n+      while Present (Elmt) loop\n+         Prim := Node (Elmt);\n+         Write_Str  (\" - \");\n+\n+         --  Indicate if this primitive will be allocated in the primary\n+         --  dispatch table or in a secondary dispatch table associated\n+         --  with an abstract interface type\n+\n+         if Present (DTC_Entity (Prim)) then\n+            if Etype (DTC_Entity (Prim)) = RTE (RE_Tag) then\n+               Write_Str (\"[P] \");\n+            else\n+               Write_Str (\"[s] \");\n+            end if;\n+         end if;\n+\n+         --  Output the node of this primitive operation and its name\n+\n+         Write_Int  (Int (Prim));\n+         Write_Str  (\": \");\n+         Write_Name (Chars (Prim));\n+\n+         --  Indicate if this primitive has an aliased primitive\n+\n+         if Present (Alias (Prim)) then\n+            Write_Str (\" (alias = \");\n+            Write_Int (Int (Alias (Prim)));\n+\n+            --  If the DTC_Entity attribute is already set we can also output\n+            --  the name of the interface covered by this primitive (if any)\n+\n+            if Present (DTC_Entity (Alias (Prim)))\n+              and then Is_Interface (Scope (DTC_Entity (Alias (Prim))))\n+            then\n+               Write_Str  (\" from interface \");\n+               Write_Name (Chars (Scope (DTC_Entity (Alias (Prim)))));\n+            end if;\n+\n+            if Present (Abstract_Interface_Alias (Prim)) then\n+               Write_Str  (\", AI_Alias of \");\n+               Write_Name (Chars (Scope (DTC_Entity\n+                                          (Abstract_Interface_Alias (Prim)))));\n+               Write_Char (':');\n+               Write_Int  (Int (Abstract_Interface_Alias (Prim)));\n+            end if;\n+\n+            Write_Str (\")\");\n+         end if;\n+\n+         --  Display the final position of this primitive in its associated\n+         --  (primary or secondary) dispatch table\n+\n+         if Present (DTC_Entity (Prim))\n+           and then DT_Position (Prim) /= No_Uint\n+         then\n+            Write_Str (\" at #\");\n+            Write_Int (UI_To_Int (DT_Position (Prim)));\n+         end if;\n+\n+         if Is_Abstract (Prim) then\n+            Write_Str (\" is abstract;\");\n+         end if;\n+\n+         Write_Eol;\n+\n+         Next_Elmt (Elmt);\n+      end loop;\n+   end Write_DT;\n+\n end Exp_Disp;"}, {"sha": "a60a43d470d8b5d3eb7bc1109ed7ae695b9af7ee", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -25,22 +25,26 @@\n ------------------------------------------------------------------------------\n \n --  This package contains routines involved in tagged types and dynamic\n---  dispatching expansion\n+--  dispatching expansion.\n \n with Types; use Types;\n package Exp_Disp is\n \n    type DT_Access_Action is\n       (CW_Membership,\n+       IW_Membership,\n        DT_Entry_Size,\n        DT_Prologue_Size,\n+       Get_Access_Level,\n        Get_External_Tag,\n        Get_Prim_Op_Address,\n        Get_RC_Offset,\n        Get_Remotely_Callable,\n        Inherit_DT,\n        Inherit_TSD,\n+       Register_Interface_Tag,\n        Register_Tag,\n+       Set_Access_Level,\n        Set_Expanded_Name,\n        Set_External_Tag,\n        Set_Prim_Op_Address,\n@@ -51,17 +55,26 @@ package Exp_Disp is\n        TSD_Prologue_Size);\n \n    function Fill_DT_Entry\n-     (Loc  : Source_Ptr;\n-      Prim : Entity_Id)\n-      return Node_Id;\n+     (Loc      : Source_Ptr;\n+      Prim     : Entity_Id;\n+      Thunk_Id : Entity_Id := Empty) return Node_Id;\n    --  Generate the code necessary to fill the appropriate entry of the\n    --  dispatch table of Prim's controlling type with Prim's address.\n \n+   procedure Make_Abstract_Interface_DT\n+     (AI_Tag          : Entity_Id;\n+      Acc_Disp_Tables : in out Elist_Id;\n+      Result          : out List_Id);\n+   --  Ada 2005 (AI-251): Expand the declarations for the secondary Dispatch\n+   --  Tables corresponding with an abstract interface. The reference to the\n+   --  dispatch table is appended at the end of Acc_Disp_Tables; it will be\n+   --  are later used to generate the corresponding initialization statement\n+   --  (see Exp_Ch3.Build_Init_Procedure).\n+\n    function Make_DT_Access_Action\n      (Typ    : Entity_Id;\n       Action : DT_Access_Action;\n-      Args   : List_Id)\n-      return Node_Id;\n+      Args   : List_Id) return Node_Id;\n    --  Generate a call to one of the Dispatch Table Access Subprograms defined\n    --  in Ada.Tags or in Interfaces.Cpp\n \n@@ -71,14 +84,33 @@ package Exp_Disp is\n \n    procedure Set_All_DT_Position (Typ : Entity_Id);\n    --  Set the DT_Position field for each primitive operation. In the CPP\n-   --  Class case check that no pragma CPP_Virtual is missing  and that the\n+   --  Class case check that no pragma CPP_Virtual is missing and that the\n    --  DT_Position are coherent\n \n    procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n    --  Expand the call to the operation through the dispatch table and perform\n    --  the required tag checks when appropriate. For CPP types the call is\n    --  done through the Vtable (tag checks are not relevant)\n \n+   procedure Expand_Interface_Actuals    (Call_Node : Node_Id);\n+   --  Ada 2005 (AI-251): Displace all the actuals corresponding to class-wide\n+   --  interfaces to reference the interface tag of the actual object\n+\n+   procedure Expand_Interface_Conversion (N : Node_Id);\n+   --  Ada 2005 (AI-251): N is a type-conversion node. Reference the base of\n+   --  the object to give access to the interface tag associated with the\n+   --  secondary dispatch table\n+\n+   function Expand_Interface_Thunk\n+     (N         : Node_Id;\n+      Thunk_Id  : Entity_Id;\n+      Iface_Tag : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n+   --  generate additional subprograms (thunks) to have a layout compatible\n+   --  with the C++ ABI. The thunk modifies the value of the first actual of\n+   --  the call (that is, the pointer to the object) before transferring\n+   --  control to the target function.\n+\n    procedure Set_Default_Constructor (Typ : Entity_Id);\n    --  Typ is a CPP_Class type. Create the Init procedure of that type to\n    --  be the default constructor (i.e. the function returning this type,\n@@ -88,4 +120,8 @@ package Exp_Disp is\n    --  Return an expression that holds True if the object can be transmitted\n    --  onto another partition according to E.4 (18)\n \n+   procedure Write_DT (Typ : Entity_Id);\n+   pragma Export (Ada, Write_DT);\n+   --  Debugging procedure (to be called within gdb)\n+\n end Exp_Disp;"}, {"sha": "eda4383e276ce1aa069fbc34dc39fa381fd9d40c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 244, "deletions": 32, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,6 +47,7 @@ with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n+with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n@@ -107,6 +108,15 @@ package body Exp_Util is\n    --  procedure of record with task components, or for a dynamically\n    --  created task that is assigned to a selected component.\n \n+   procedure Find_Interface_Tag\n+     (T         : Entity_Id;\n+      Iface     : Entity_Id;\n+      Iface_Tag : out Entity_Id;\n+      Iface_ADT : out Entity_Id);\n+   --  Ada 2005 (AI-251): Subsidiary procedure to Find_Interface_ADT and\n+   --  Find_Interface_Tag. Given a type T implementing the interface,\n+   --  returns the corresponding Tag and Access_Disp_Table entities.\n+\n    function Make_CW_Equivalent_Type\n      (T : Entity_Id;\n       E : Node_Id) return Entity_Id;\n@@ -1219,9 +1229,32 @@ package body Exp_Util is\n       then\n          if Is_Itype (Exp_Typ) then\n \n-            --  No need to generate a new one\n+            --  Within an initialization procedure, a selected component\n+            --  denotes a component of the enclosing record, and it appears\n+            --  as an actual in a call to its own initialization procedure.\n+            --  If this component depends on the outer discriminant, we must\n+            --  generate the proper actual subtype for it.\n \n-            T := Exp_Typ;\n+            if Nkind (Exp) = N_Selected_Component\n+              and then Within_Init_Proc\n+            then\n+               declare\n+                  Decl : constant Node_Id :=\n+                           Build_Actual_Subtype_Of_Component (Exp_Typ, Exp);\n+               begin\n+                  if Present (Decl) then\n+                     Insert_Action (N, Decl);\n+                     T := Defining_Identifier (Decl);\n+                  else\n+                     T := Exp_Typ;\n+                  end if;\n+               end;\n+\n+            --  No need to generate a new one (new what???)\n+\n+            else\n+               T := Exp_Typ;\n+            end if;\n \n          else\n             T :=\n@@ -1261,6 +1294,145 @@ package body Exp_Util is\n       end if;\n    end Expand_Subtype_From_Expr;\n \n+   ------------------------\n+   -- Find_Interface_Tag --\n+   ------------------------\n+\n+   procedure Find_Interface_Tag\n+     (T         : Entity_Id;\n+      Iface     : Entity_Id;\n+      Iface_Tag : out Entity_Id;\n+      Iface_ADT : out Entity_Id)\n+   is\n+      AI_Tag   : Entity_Id;\n+      ADT_Elmt : Elmt_Id;\n+      Found    : Boolean   := False;\n+\n+      procedure Find_AI_Tag (Typ : in Entity_Id; Found : in out Boolean);\n+      --  This must be commented ???\n+\n+      -----------------\n+      -- Find_AI_Tag --\n+      -----------------\n+\n+      procedure Find_AI_Tag (Typ : in Entity_Id; Found : in out Boolean) is\n+         T       : Entity_Id := Typ;\n+         Etyp    : Entity_Id; -- := Etype (Typ); -- why is this commented ???\n+         AI_Elmt : Elmt_Id;\n+         AI      : Node_Id;\n+\n+      begin\n+         --  Check if the interface is an immediate ancestor of the type and\n+         --  therefore shares the main tag.\n+\n+         if Typ = Iface then\n+            AI_Tag    := First_Tag_Component (Typ);\n+            ADT_Elmt  := First_Elmt (Access_Disp_Table (Typ));\n+            Found     := True;\n+            return;\n+         end if;\n+\n+         --  Handle private types\n+\n+         if Has_Private_Declaration (T)\n+           and then Present (Full_View (T))\n+         then\n+            T := Full_View (T);\n+         end if;\n+\n+         if Is_Access_Type (Typ) then\n+            T := Directly_Designated_Type (T);\n+\n+         elsif Ekind (T) = E_Protected_Type\n+           or else Ekind (T) = E_Task_Type\n+         then\n+            T := Corresponding_Record_Type (T);\n+         end if;\n+\n+         Etyp := Etype (T);\n+\n+         --  Climb to the root type\n+\n+         if Etyp /= Typ then\n+            Find_AI_Tag (Etyp, Found);\n+         end if;\n+\n+         --  Traverse the list of interfaces implemented by the type\n+\n+         if not Found\n+           and then Present (Abstract_Interfaces (T))\n+           and then not Is_Empty_Elmt_List (Abstract_Interfaces (T))\n+         then\n+            --  Skip the tag associated with the primary table (if\n+            --  already placed in the record)\n+\n+            if Etype (Node (First_Elmt\n+                              (Access_Disp_Table (T)))) = RTE (RE_Tag)\n+            then\n+               AI_Tag   := Next_Tag_Component (First_Tag_Component (T));\n+               ADT_Elmt := Next_Elmt (First_Elmt (Access_Disp_Table (T)));\n+            else\n+               AI_Tag   := First_Tag_Component (T);\n+               ADT_Elmt := First_Elmt (Access_Disp_Table (T));\n+            end if;\n+\n+            pragma Assert (Present (AI_Tag));\n+            pragma Assert (Present (Node (ADT_Elmt)));\n+\n+            AI_Elmt  := First_Elmt (Abstract_Interfaces (T));\n+            while Present (AI_Elmt) loop\n+               AI := Node (AI_Elmt);\n+\n+               if AI = Iface or else Is_Ancestor (Iface, AI) then\n+                  Found := True;\n+                  return;\n+               end if;\n+\n+               AI_Tag := Next_Tag_Component (AI_Tag);\n+               Next_Elmt (AI_Elmt);\n+               Next_Elmt (ADT_Elmt);\n+            end loop;\n+         end if;\n+      end Find_AI_Tag;\n+\n+   begin\n+      Find_AI_Tag (T, Found);\n+      pragma Assert (Found);\n+\n+      Iface_Tag := AI_Tag;\n+      Iface_ADT := Node (ADT_Elmt);\n+   end Find_Interface_Tag;\n+\n+   ------------------------\n+   -- Find_Interface_Tag --\n+   ------------------------\n+\n+   function Find_Interface_ADT\n+     (T     : Entity_Id;\n+      Iface : Entity_Id) return Entity_Id\n+   is\n+      Iface_Tag : Entity_Id := Empty;\n+      Iface_ADT : Entity_Id := Empty;\n+   begin\n+      Find_Interface_Tag (T, Iface, Iface_Tag, Iface_ADT);\n+      return Iface_ADT;\n+   end Find_Interface_ADT;\n+\n+   ------------------------\n+   -- Find_Interface_Tag --\n+   ------------------------\n+\n+   function Find_Interface_Tag\n+     (T     : Entity_Id;\n+      Iface : Entity_Id) return Entity_Id\n+   is\n+      Iface_Tag : Entity_Id := Empty;\n+      Iface_ADT : Entity_Id := Empty;\n+   begin\n+      Find_Interface_Tag (T, Iface, Iface_Tag, Iface_ADT);\n+      return Iface_Tag;\n+   end Find_Interface_Tag;\n+\n    ------------------\n    -- Find_Prim_Op --\n    ------------------\n@@ -1317,10 +1489,9 @@ package body Exp_Util is\n       Par              : Node_Id;\n \n    begin\n-      --  Loop to determine whether there is a component reference in\n-      --  the left hand side if Exp appears on the left side of an\n-      --  assignment statement. Needed to determine if form of result\n-      --  must be a variable.\n+      --  Loop to determine whether there is a component reference in the left\n+      --  hand side if Exp appears on the left side of an assignment statement.\n+      --  Needed to determine if form of result must be a variable.\n \n       Par := Exp;\n       while Present (Par)\n@@ -1339,15 +1510,15 @@ package body Exp_Util is\n          end if;\n       end loop;\n \n-      --  If the expression is a selected component, it is being evaluated\n-      --  as part of a discriminant check. If it is part of a left-hand\n-      --  side, this is the last use of its value and it is safe to create\n-      --  a renaming for it, rather than a temporary. In addition, if it\n-      --  is not an addressable field, creating a temporary may be a problem\n-      --  for gigi, or might drop the value of the assignment. Therefore,\n-      --  if the expression is on the lhs of an assignment, remove side\n-      --  effects without requiring a temporary, and create a renaming.\n-      --  (See remove_side_effects for details).\n+      --  If the expression is a selected component, it is being evaluated as\n+      --  part of a discriminant check. If it is part of a left-hand side, this\n+      --  is the last use of its value and it is safe to create a renaming for\n+      --  it, rather than a temporary. In addition, if it is not an addressable\n+      --  field, creating a temporary may be a problem for gigi, or might drop\n+      --  the value of the assignment. Therefore, if the expression is on the\n+      --  lhs of an assignment, remove side effects without requiring a\n+      --  temporary, and create a renaming. (See remove_side_effects for\n+      --  details).\n \n       Remove_Side_Effects\n         (Exp, Name_Req, Variable_Ref => not Component_In_Lhs);\n@@ -1423,9 +1594,9 @@ package body Exp_Util is\n \n                --  If we fall off the top of the tree, then that's odd, but\n                --  perhaps it could occur in some error situation, and the\n-               --  safest response is simply to assume that the outcome of\n-               --  the condition is unknown. No point in bombing during an\n-               --  attempt to optimize things.\n+               --  safest response is simply to assume that the outcome of the\n+               --  condition is unknown. No point in bombing during an attempt\n+               --  to optimize things.\n \n                if No (N) then\n                   return;\n@@ -1448,9 +1619,9 @@ package body Exp_Util is\n             end if;\n          end;\n \n-      --  ELSIF part. Condition is known true within the referenced\n-      --  ELSIF, known False in any subsequent ELSIF or ELSE part,\n-      --  and unknown before the ELSE part or after the IF statement.\n+      --  ELSIF part. Condition is known true within the referenced ELSIF,\n+      --  known False in any subsequent ELSIF or ELSE part, and unknown before\n+      --  the ELSE part or after the IF statement.\n \n       elsif Nkind (CV) = N_Elsif_Part then\n          Stm := Parent (CV);\n@@ -1468,8 +1639,8 @@ package body Exp_Util is\n             return;\n          end if;\n \n-         --  Again we lack the SLOC of the ELSE, so we need to climb the\n-         --  tree to see if we are within the ELSIF part in question.\n+         --  Again we lack the SLOC of the ELSE, so we need to climb the tree\n+         --  to see if we are within the ELSIF part in question.\n \n          declare\n             N : Node_Id;\n@@ -1481,9 +1652,9 @@ package body Exp_Util is\n \n                --  If we fall off the top of the tree, then that's odd, but\n                --  perhaps it could occur in some error situation, and the\n-               --  safest response is simply to assume that the outcome of\n-               --  the condition is unknown. No point in bombing during an\n-               --  attempt to optimize things.\n+               --  safest response is simply to assume that the outcome of the\n+               --  condition is unknown. No point in bombing during an attempt\n+               --  to optimize things.\n \n                if No (N) then\n                   return;\n@@ -1510,9 +1681,8 @@ package body Exp_Util is\n          return;\n       end if;\n \n-      --  If we fall through here, then we have a reportable\n-      --  condition, Sens is True if the condition is true and\n-      --  False if it needs inverting.\n+      --  If we fall through here, then we have a reportable condition, Sens is\n+      --  True if the condition is true and False if it needs inverting.\n \n       --  Deal with NOT operators, inverting sense\n \n@@ -2320,6 +2490,47 @@ package body Exp_Util is\n       return True;\n    end Is_All_Null_Statements;\n \n+   ------------------------\n+   -- Is_Default_Prim_Op --\n+   ------------------------\n+\n+   function Is_Predefined_Dispatching_Operation\n+     (Subp     : Entity_Id) return Boolean\n+   is\n+      TSS_Name : TSS_Name_Type;\n+      E        : Entity_Id := Subp;\n+   begin\n+      pragma Assert (Is_Dispatching_Operation (Subp));\n+\n+      --  Handle overriden subprograms\n+\n+      while Present (Alias (E)) loop\n+         E := Alias (E);\n+      end loop;\n+\n+      Get_Name_String (Chars (E));\n+\n+      if Name_Len > TSS_Name_Type'Last then\n+         TSS_Name := TSS_Name_Type (Name_Buffer (Name_Len - TSS_Name'Length + 1\n+                                     .. Name_Len));\n+         if Chars (E)        = Name_uSize\n+           or else Chars (E) = Name_uAlignment\n+           or else TSS_Name  = TSS_Stream_Read\n+           or else TSS_Name  = TSS_Stream_Write\n+           or else TSS_Name  = TSS_Stream_Input\n+           or else TSS_Name  = TSS_Stream_Output\n+           or else Chars (E) = Name_Op_Eq\n+           or else Chars (E) = Name_uAssign\n+           or else TSS_Name  = TSS_Deep_Adjust\n+           or else TSS_Name  = TSS_Deep_Finalize\n+         then\n+            return True;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Is_Predefined_Dispatching_Operation;\n+\n    ----------------------------------\n    -- Is_Possibly_Unaligned_Object --\n    ----------------------------------\n@@ -2366,8 +2577,9 @@ package body Exp_Util is\n \n          begin\n             --  If component reference is for an array with non-static bounds,\n-            --  then it is always aligned, we can only unaligned arrays with\n-            --  static bounds (more accurately bounds known at compile time)\n+            --  then it is always aligned: we can only process unaligned\n+            --  arrays with static bounds (more accurately bounds known at\n+            --  compile time).\n \n             if Is_Array_Type (T)\n               and then not Compile_Time_Known_Bounds (T)"}, {"sha": "711949c3dc629a446bea68b12b392852e5c3b72c", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 215, "deletions": 206, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -135,7 +135,7 @@ package Exp_Util is\n    --  Actions field of the N_Compilation_Aux node for the main unit).\n \n    procedure Insert_Library_Level_Actions (L : List_Id);\n-   --  Similar, but inserts a list of actions.\n+   --  Similar, but inserts a list of actions\n \n    -----------------------\n    -- Other Subprograms --\n@@ -145,47 +145,46 @@ package Exp_Util is\n    --  The node N is an expression whose root-type is Boolean, and which\n    --  represents a boolean value used as a condition (i.e. a True/False\n    --  value). This routine handles the case of C and Fortran convention\n-   --  boolean types, which have zero/non-zero semantics rather than the\n-   --  normal 0/1 semantics, and also the case of an enumeration rep\n-   --  clause that specifies a non-standard representation. On return,\n-   --  node N always has the type Standard.Boolean, with a value that\n-   --  is a standard Boolean values of 0/1 for False/True. This procedure\n-   --  is used in two situations. First, the processing for a condition\n-   --  field always calls Adjust_Condition, so that the boolean value\n-   --  presented to the backend is a standard value. Second, for the\n-   --  code for boolean operations such as AND, Adjust_Condition is\n-   --  called on both operands, and then the operation is done in the\n-   --  domain of Standard_Boolean, then Adjust_Result_Type is called\n-   --  on the result to possibly reset the original type. This procedure\n+   --  boolean types, which have zero/non-zero semantics rather than the normal\n+   --  0/1 semantics, and also the case of an enumeration rep clause that\n+   --  specifies a non-standard representation. On return, node N always has\n+   --  the type Standard.Boolean, with a value that is a standard Boolean\n+   --  values of 0/1 for False/True. This procedure is used in two situations.\n+   --  First, the processing for a condition field always calls\n+   --  Adjust_Condition, so that the boolean value presented to the backend is\n+   --  a standard value. Second, for the code for boolean operations such as\n+   --  AND, Adjust_Condition is called on both operands, and then the operation\n+   --  is done in the domain of Standard_Boolean, then Adjust_Result_Type is\n+   --  called on the result to possibly reset the original type. This procedure\n    --  also takes care of validity checking if Validity_Checks = Tests.\n \n    procedure Adjust_Result_Type (N : Node_Id; T : Entity_Id);\n    --  The processing of boolean operations like AND uses the procedure\n-   --  Adjust_Condition so that it can operate on Standard.Boolean, which\n-   --  is the only boolean type on which the backend needs to be able to\n-   --  implement such operators. This means that the result is also of\n-   --  type Standard.Boolean. In general the type must be reset back to\n-   --  the original type to get proper semantics, and that is the purpose\n-   --  of this procedure. N is the node (of type Standard.Boolean), and\n-   --  T is the desired type. As an optimization, this procedure leaves\n-   --  the type as Standard.Boolean in contexts where this is permissible\n-   --  (in particular for Condition fields, and for operands of other\n-   --  logical operations higher up the tree). The call to this procedure\n-   --  is completely ignored if the argument N is not of type Boolean.\n+   --  Adjust_Condition so that it can operate on Standard.Boolean, which is\n+   --  the only boolean type on which the backend needs to be able to implement\n+   --  such operators. This means that the result is also of type\n+   --  Standard.Boolean. In general the type must be reset back to the original\n+   --  type to get proper semantics, and that is the purpose of this procedure.\n+   --  N is the node (of type Standard.Boolean), and T is the desired type. As\n+   --  an optimization, this procedure leaves the type as Standard.Boolean in\n+   --  contexts where this is permissible (in particular for Condition fields,\n+   --  and for operands of other logical operations higher up the tree). The\n+   --  call to this procedure is completely ignored if the argument N is not of\n+   --  type Boolean.\n \n    procedure Append_Freeze_Action (T : Entity_Id; N : Node_Id);\n    --  Add a new freeze action for the given type. The freeze action is\n-   --  attached to the freeze node for the type. Actions will be elaborated\n-   --  in the order in which they are added. Note that the added node is not\n+   --  attached to the freeze node for the type. Actions will be elaborated in\n+   --  the order in which they are added. Note that the added node is not\n    --  analyzed. The analyze call is found in Sem_Ch13.Expand_N_Freeze_Entity.\n \n    procedure Append_Freeze_Actions (T : Entity_Id; L : List_Id);\n-   --  Adds the given list of freeze actions (declarations or statements)\n-   --  for the given type. The freeze actions are attached to the freeze\n-   --  node for the type. Actions will be elaborated in the order in which\n-   --  they are added, and the actions within the list will be elaborated in\n-   --  list order. Note that the added nodes are not analyzed. The analyze\n-   --  call is found in Sem_Ch13.Expand_N_Freeze_Entity.\n+   --  Adds the given list of freeze actions (declarations or statements) for\n+   --  the given type. The freeze actions are attached to the freeze node for\n+   --  the type. Actions will be elaborated in the order in which they are\n+   --  added, and the actions within the list will be elaborated in list order.\n+   --  Note that the added nodes are not analyzed. The analyze call is found in\n+   --  Sem_Ch13.Expand_N_Freeze_Entity.\n \n    function Build_Runtime_Call (Loc : Source_Ptr; RE : RE_Id) return Node_Id;\n    --  Build an N_Procedure_Call_Statement calling the given runtime entity.\n@@ -198,55 +197,52 @@ package Exp_Util is\n       Id_Ref : Node_Id;\n       A_Type : Entity_Id)\n       return   List_Id;\n-   --  Build declaration for a variable that holds an identifying string\n-   --  to be used as a task name. Id_Ref is an identifier if the task is\n-   --  a variable, and a selected or indexed component if the task is a\n-   --  component of an object. If it is an indexed component, A_Type is\n-   --  the corresponding array type. Its index types are used to build the\n-   --  string as an image of the index values. For composite types, the\n-   --  result includes two declarations: one for a generated function that\n-   --  computes the image without using concatenation, and one for the\n-   --  variable that holds the result.\n+   --  Build declaration for a variable that holds an identifying string to be\n+   --  used as a task name. Id_Ref is an identifier if the task is a variable,\n+   --  and a selected or indexed component if the task is component of an\n+   --  object. If it is an indexed component, A_Type is the corresponding array\n+   --  type. Its index types are used to build the string as an image of the\n+   --  index values. For composite types, the result includes two declarations:\n+   --  one for a generated function that computes the image without using\n+   --  concatenation, and one for the variable that holds the result.\n \n    function Component_May_Be_Bit_Aligned (Comp : Entity_Id) return Boolean;\n-   --  This function is in charge of detecting record components that may\n-   --  cause trouble in the back end if an attempt is made to assign the\n-   --  component. The back end can handle such assignments with no problem\n-   --  if the components involved are small (64-bits or less) records or\n-   --  scalar items (including bit-packed arrays represented with modular\n-   --  types) or are both aligned on a byte boundary (starting on a byte\n-   --  boundary, and occupying an integral number of bytes).\n+   --  This function is in charge of detecting record components that may cause\n+   --  trouble in the back end if an attempt is made to assign the component.\n+   --  The back end can handle such assignments with no problem if the\n+   --  components involved are small (64-bits or less) records or scalar items\n+   --  (including bit-packed arrays represented with modular types) or are both\n+   --  aligned on a byte boundary (starting on a byte boundary, and occupying\n+   --  an integral number of bytes).\n    --\n-   --  However, problems arise for records larger than 64 bits, or for\n-   --  arrays (other than bit-packed arrays represented with a modular\n-   --  type) if the component starts on a non-byte boundary, or does\n-   --  not occupy an integral number of bytes (i.e. there are some bits\n-   --  possibly shared with fields at the start or beginning of the\n-   --  component). The back end cannot handle loading and storing such\n-   --  components in a single operation.\n+   --  However, problems arise for records larger than 64 bits, or for arrays\n+   --  (other than bit-packed arrays represented with a modular type) if the\n+   --  component starts on a non-byte boundary, or does not occupy an integral\n+   --  number of bytes (i.e. there are some bits possibly shared with fields at\n+   --  the start or beginning of the component). The back end cannot handle\n+   --  loading and storing such components in a single operation.\n    --\n    --  This function is used to detect the troublesome situation. it is\n-   --  conservative in the sense that it produces True unless it knows\n-   --  for sure that the component is safe (as outlined in the first\n-   --  paragraph above). The code generation for record and array\n-   --  assignment checks for trouble using this function, and if so\n-   --  the assignment is generated component-wise, which the back end\n-   --  is required to handle correctly.\n+   --  conservative in the sense that it produces True unless it knows for sure\n+   --  that the component is safe (as outlined in the first paragraph above).\n+   --  The code generation for record and array assignment checks for trouble\n+   --  using this function, and if so the assignment is generated\n+   --  component-wise, which the back end is required to handle correctly.\n    --\n-   --  Note that in GNAT 3, the back end will reject such components\n-   --  anyway, so the hard work in checking for this case is wasted\n-   --  in GNAT 3, but it's harmless, so it is easier to do it in\n-   --  all cases, rather than conditionalize it in GNAT 5 or beyond.\n+   --  Note that in GNAT 3, the back end will reject such components anyway, so\n+   --  the hard work in checking for this case is wasted in GNAT 3, but it's\n+   --  harmless, so it is easier to do it in all cases, rather than\n+   --  conditionalize it in GNAT 5 or beyond.\n \n    procedure Convert_To_Actual_Subtype (Exp : Node_Id);\n-   --  The Etype of an expression is the nominal type of the expression,\n-   --  not the actual subtype. Often these are the same, but not always.\n-   --  For example, a reference to a formal of unconstrained type has the\n-   --  unconstrained type as its Etype, but the actual subtype is obtained\n-   --  by applying the actual bounds. This routine is given an expression,\n-   --  Exp, and (if necessary), replaces it using Rewrite, with a conversion\n-   --  to the actual subtype, building the actual subtype if necessary. If\n-   --  the expression is already of the requested type, then it is unchanged.\n+   --  The Etype of an expression is the nominal type of the expression, not\n+   --  the actual subtype. Often these are the same, but not always. For\n+   --  example, a reference to a formal of unconstrained type has the\n+   --  unconstrained type as its Etype, but the actual subtype is obtained by\n+   --  applying the actual bounds. This routine is given an expression, Exp,\n+   --  and (if necessary), replaces it using Rewrite, with a conversion to the\n+   --  actual subtype, building the actual subtype if necessary. If the\n+   --  expression is already of the requested type, then it is unchanged.\n \n    function Current_Sem_Unit_Declarations return List_Id;\n    --  Return the a place where it is fine to insert declarations for the\n@@ -258,20 +254,20 @@ package Exp_Util is\n    function Duplicate_Subexpr\n      (Exp      : Node_Id;\n       Name_Req : Boolean := False) return Node_Id;\n-   --  Given the node for a subexpression, this function makes a logical\n-   --  copy of the subexpression, and returns it. This is intended for use\n-   --  when the expansion of an expression needs to repeat part of it. For\n-   --  example, replacing a**2 by a*a requires two references to a which\n-   --  may be a complex subexpression. Duplicate_Subexpr guarantees not\n-   --  to duplicate side effects. If necessary, it generates actions to\n-   --  save the expression value in a temporary, inserting these actions\n-   --  into the tree using Insert_Actions with Exp as the insertion location.\n-   --  The original expression and the returned result then become references\n-   --  to this saved value. Exp must be analyzed on entry. On return, Exp\n-   --  is analyzed, but the caller is responsible for analyzing the returned\n-   --  copy after it is attached to the tree. The Name_Req flag is set to\n-   --  ensure that the result is suitable for use in a context requiring a\n-   --  name (e.g. the prefix of an attribute reference).\n+   --  Given the node for a subexpression, this function makes a logical copy\n+   --  of the subexpression, and returns it. This is intended for use when the\n+   --  expansion of an expression needs to repeat part of it. For example,\n+   --  replacing a**2 by a*a requires two references to a which may be a\n+   --  complex subexpression. Duplicate_Subexpr guarantees not to duplicate\n+   --  side effects. If necessary, it generates actions to save the expression\n+   --  value in a temporary, inserting these actions into the tree using\n+   --  Insert_Actions with Exp as the insertion location. The original\n+   --  expression and the returned result then become references to this saved\n+   --  value. Exp must be analyzed on entry. On return, Exp is analyzed, but\n+   --  the caller is responsible for analyzing the returned copy after it is\n+   --  attached to the tree. The Name_Req flag is set to ensure that the result\n+   --  is suitable for use in a context requiring name (e.g. the prefix of an\n+   --  attribute reference).\n    --\n    --  Note that if there are any run time checks in Exp, these same checks\n    --  will be duplicated in the returned duplicated expression. The two\n@@ -289,13 +285,13 @@ package Exp_Util is\n    function Duplicate_Subexpr_Move_Checks\n      (Exp      : Node_Id;\n       Name_Req : Boolean := False) return Node_Id;\n-   --  Identical in effect to Duplicate_Subexpr, except that Remove_Checks\n-   --  is called on Exp after the duplication is complete, so that the\n-   --  original expression does not include checks. In this case the result\n-   --  returned (the duplicated expression) will retain the original checks.\n-   --  This is appropriate for use when the duplicated expression is sure\n-   --  to be elaborated before the original expression Exp, so that there\n-   --  is no need to repeat the checks.\n+   --  Identical in effect to Duplicate_Subexpr, except that Remove_Checks is\n+   --  called on Exp after the duplication is complete, so that the original\n+   --  expression does not include checks. In this case the result returned\n+   --  (the duplicated expression) will retain the original checks. This is\n+   --  appropriate for use when the duplicated expression is sure to be\n+   --  elaborated before the original expression Exp, so that there is no need\n+   --  to repeat the checks.\n \n    procedure Ensure_Defined (Typ : Entity_Id; N : Node_Id);\n    --  This procedure ensures that type referenced by Typ is defined. For the\n@@ -309,15 +305,15 @@ package Exp_Util is\n    --  Rewrites Cond with the expression: Cond and then Cond1. If Cond is\n    --  Empty, then simply returns Cond1 (this allows the use of Empty to\n    --  initialize a series of checks evolved by this routine, with a final\n-   --  result of Empty indicating that no checks were required). The Sloc\n-   --  field of the constructed N_And_Then node is copied from Cond1.\n+   --  result of Empty indicating that no checks were required). The Sloc field\n+   --  of the constructed N_And_Then node is copied from Cond1.\n \n    procedure Evolve_Or_Else (Cond : in out Node_Id; Cond1 : Node_Id);\n-   --  Rewrites Cond with the expression: Cond or else Cond1. If Cond is\n-   --  Empty, then simply returns Cond1 (this allows the use of Empty to\n-   --  initialize a series of checks evolved by this routine, with a final\n-   --  result of Empty indicating that no checks were required). The Sloc\n-   --  field of the constructed N_Or_Else node is copied from Cond1.\n+   --  Rewrites Cond with the expression: Cond or else Cond1. If Cond is Empty,\n+   --  then simply returns Cond1 (this allows the use of Empty to initialize a\n+   --  series of checks evolved by this routine, with a final result of Empty\n+   --  indicating that no checks were required). The Sloc field of the\n+   --  constructed N_Or_Else node is copied from Cond1.\n \n    procedure Expand_Subtype_From_Expr\n      (N             : Node_Id;\n@@ -328,6 +324,18 @@ package Exp_Util is\n    --  declarations and/or allocations when the type is indefinite (including\n    --  class-wide).\n \n+   function Find_Interface_ADT\n+     (T         : Entity_Id;\n+      Iface     : Entity_Id) return Entity_Id;\n+   --  Ada 2005 (AI-251): Given a type T implementing the interface Iface,\n+   --  return the Access_Disp_Table value of the interface.\n+\n+   function Find_Interface_Tag\n+     (T         : Entity_Id;\n+      Iface     : Entity_Id) return Entity_Id;\n+   --  Ada 2005 (AI-251): Given a type T implementing the interface Iface,\n+   --  return the record component containing the tag of Iface.\n+\n    function Find_Prim_Op (T : Entity_Id; Name : Name_Id) return Entity_Id;\n    --  Find the first primitive operation of type T whose name is 'Name'.\n    --  This function allows the use of a primitive operation which is not\n@@ -362,105 +370,107 @@ package Exp_Util is\n      (Var : Node_Id;\n       Op  : out Node_Kind;\n       Val : out Node_Id);\n-   --  This routine processes the Current_Value field of the variable Var.\n-   --  If the Current_Value field is null or if it represents a known value,\n-   --  then on return Cond is set to N_Empty, and Val is set to Empty.\n+   --  This routine processes the Current_Value field of the variable Var. If\n+   --  the Current_Value field is null or if it represents a known value, then\n+   --  on return Cond is set to N_Empty, and Val is set to Empty.\n    --\n-   --  The other case is when Current_Value points to an N_If_Statement\n-   --  or an N_Elsif_Part (while statement). Such a setting only occurs\n-   --  if the condition of an IF or ELSIF is of the form X op Y, where X\n-   --  is the variable in question, Y is a compile-time known value, and\n-   --  op is one of the six possible relational operators.\n+   --  The other case is when Current_Value points to an N_If_Statement or an\n+   --  N_Elsif_Part (while statement). Such a setting only occurs if the\n+   --  condition of an IF or ELSIF is of the form X op Y, where is the variable\n+   --  in question, Y is a compile-time known value, and op is one of the six\n+   --  possible relational operators.\n    --\n-   --  In this case, Get_Current_Condition digs out the condition, and\n-   --  then checks if the condition is known false, known true, or not\n-   --  known at all. In the first two cases, Get_Current_Condition will\n-   --  return with Op set to the appropriate conditional operator (inverted\n-   --  if the condition is known false), and Val set to the constant value.\n-   --  If the condition is not known, then Cond and Val are set for the\n-   --  empty case (N_Empty and Empty).\n+   --  In this case, Get_Current_Condition digs out the condition, and then\n+   --  checks if the condition is known false, known true, or not known at all.\n+   --  In the first two cases, Get_Current_Condition will return with Op set to\n+   --  the appropriate conditional operator (inverted if the condition is known\n+   --  false), and Val set to the constant value. If the condition is not\n+   --  known, then Cond and Val are set for the empty case (N_Empty and Empty).\n    --\n    --  The check for whether the condition is true/false unknown depends\n    --  on the case:\n    --\n-   --     For an IF, the condition is known true in the THEN part, known\n-   --     false in any ELSIF or ELSE part, and not known outside the IF\n-   --     statement in question.\n+   --     For an IF, the condition is known true in the THEN part, known false\n+   --     in any ELSIF or ELSE part, and not known outside the IF statement in\n+   --     question.\n    --\n-   --     For an ELSIF, the condition is known true in the ELSIF part,\n-   --     known FALSE in any subsequent ELSIF, or ELSE part, and not\n-   --     known before the ELSIF, or after the end of the IF statement.\n+   --     For an ELSIF, the condition is known true in the ELSIF part, known\n+   --     FALSE in any subsequent ELSIF, or ELSE part, and not known before the\n+   --     ELSIF, or after the end of the IF statement.\n    --\n-   --  The caller can use this result to determine the value (for the\n-   --  case of N_Op_Eq), or to determine the result of some other test\n-   --  in other cases (e.g. no access check required if N_Op_Ne Null).\n+   --  The caller can use this result to determine the value (for the case of\n+   --  N_Op_Eq), or to determine the result of some other test in other cases\n+   --  (e.g. no access check required if N_Op_Ne Null).\n \n    function Homonym_Number (Subp : Entity_Id) return Nat;\n    --  Here subp is the entity for a subprogram. This routine returns the\n-   --  homonym number used to disambiguate overloaded subprograms in the\n-   --  same scope (the number is used as part of constructed names to make\n-   --  sure that they are unique). The number is the ordinal position on\n-   --  the Homonym chain, counting only entries in the curren scope. If\n-   --  an entity is not overloaded, the returned number will be one.\n+   --  homonym number used to disambiguate overloaded subprograms in the same\n+   --  scope (the number is used as part of constructed names to make sure that\n+   --  they are unique). The number is the ordinal position on the Homonym\n+   --  chain, counting only entries in the curren scope. If an entity is not\n+   --  overloaded, the returned number will be one.\n \n    function Inside_Init_Proc return Boolean;\n    --  Returns True if current scope is within an init proc\n \n    function In_Unconditional_Context (Node : Node_Id) return Boolean;\n-   --  Node is the node for a statement or a component of a statement.\n-   --  This function deteermines if the statement appears in a context\n-   --  that is unconditionally executed, i.e. it is not within a loop\n-   --  or a conditional or a case statement etc.\n+   --  Node is the node for a statement or a component of a statement. This\n+   --  function deteermines if the statement appears in a context that is\n+   --  unconditionally executed, i.e. it is not within a loop or a conditional\n+   --  or a case statement etc.\n \n    function Is_All_Null_Statements (L : List_Id) return Boolean;\n-   --  Return True if all the items of the list are N_Null_Statement\n-   --  nodes. False otherwise. True for an empty list. It is an error\n-   --  to call this routine with No_List as the argument.\n+   --  Return True if all the items of the list are N_Null_Statement nodes.\n+   --  False otherwise. True for an empty list. It is an error to call this\n+   --  routine with No_List as the argument.\n+\n+   function Is_Predefined_Dispatching_Operation\n+     (Subp : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-251): Determines if Subp is a predefined primitive\n+   --  operation.\n \n    function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean;\n-   --  Determine whether the node P is a reference to a bit packed\n-   --  array, i.e. whether the designated object is a component of\n-   --  a bit packed array, or a subcomponent of such a component.\n-   --  If so, then all subscripts in P are evaluated with a call\n-   --  to Force_Evaluation, and True is returned. Otherwise False\n-   --  is returned, and P is not affected.\n+   --  Determine whether the node P is a reference to a bit packed array, i.e.\n+   --  whether the designated object is a component of a bit packed array, or a\n+   --  subcomponent of such a component. If so, then all subscripts in P are\n+   --  evaluated with a call to Force_Evaluation, and True is returned.\n+   --  Otherwise False is returned, and P is not affected.\n \n    function Is_Ref_To_Bit_Packed_Slice (N : Node_Id) return Boolean;\n-   --  Determine whether the node P is a reference to a bit packed\n-   --  slice, i.e. whether the designated object is bit packed slice\n-   --  or a component of a bit packed slice. Return True if so.\n+   --  Determine whether the node P is a reference to a bit packed slice, i.e.\n+   --  whether the designated object is bit packed slice or a component of a\n+   --  bit packed slice. Return True if so.\n \n    function Is_Possibly_Unaligned_Slice (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a slice of an array where the slice\n    --  result may cause alignment problems because it has an alignment that\n    --  is not compatible with the type. Return True if so.\n \n    function Is_Possibly_Unaligned_Object (N : Node_Id) return Boolean;\n-   --  Node N is an object reference. This function returns True if it\n-   --  is possible that the object may not be aligned according to the\n-   --  normal default alignment requirement for its type (e.g. if it\n-   --  appears in a packed record, or as part of a component that has\n-   --  a component clause.\n+   --  Node N is an object reference. This function returns True if it is\n+   --  possible that the object may not be aligned according to the normal\n+   --  default alignment requirement for its type (e.g. if it appears in a\n+   --  packed record, or as part of a component that has a component clause.\n \n    function Is_Renamed_Object (N : Node_Id) return Boolean;\n-   --  Returns True if the node N is a renamed object. An expression\n-   --  is considered to be a renamed object if either it is the Name\n-   --  of an object renaming declaration, or is the prefix of a name\n-   --  which is a renamed object. For example, in:\n+   --  Returns True if the node N is a renamed object. An expression is\n+   --  considered to be a renamed object if either it is the Name of an object\n+   --  renaming declaration, or is the prefix of a name which is a renamed\n+   --  object. For example, in:\n    --\n    --     x : r renames a (1 .. 2) (1);\n    --\n-   --  We consider that a (1 .. 2) is a renamed object since it is the\n-   --  prefix of the name in the renaming declaration.\n+   --  We consider that a (1 .. 2) is a renamed object since it is the prefix\n+   --  of the name in the renaming declaration.\n \n    function Is_Untagged_Derivation (T : Entity_Id) return Boolean;\n    --  Returns true if type T is not tagged and is a derived type,\n    --  or is a private type whose completion is such a type.\n \n    procedure Kill_Dead_Code (N : Node_Id);\n-   --  N represents a node for a section of code that is known to be\n-   --  dead. The node is deleted, and any exception handler references\n-   --  and warning messages relating to this code are removed.\n+   --  N represents a node for a section of code that is known to be dead. The\n+   --  node is deleted, and any exception handler references and warning\n+   --  messages relating to this code are removed.\n \n    procedure Kill_Dead_Code (L : List_Id);\n    --  Like the above procedure, but applies to every element in the given\n@@ -485,54 +495,53 @@ package Exp_Util is\n    --  a classwide type.\n \n    function May_Generate_Large_Temp (Typ : Entity_Id) return Boolean;\n-   --  Determines if the given type, Typ, may require a large temporary\n-   --  of the kind that causes back-end trouble if stack checking is enabled.\n-   --  The result is True only the size of the type is known at compile time\n-   --  and large, where large is defined heuristically by the body of this\n-   --  routine. The purpose of this routine is to help avoid generating\n-   --  troublesome temporaries that interfere with stack checking mechanism.\n-   --  Note that the caller has to check whether stack checking is actually\n-   --  enabled in order to guide the expansion (typically of a function call).\n+   --  Determines if the given type, Typ, may require a large temporary of the\n+   --  kind that causes back-end trouble if stack checking is enabled. The\n+   --  result is True only the size of the type is known at compile time and\n+   --  large, where large is defined heuristically by the body of this routine.\n+   --  The purpose of this routine is to help avoid generating troublesome\n+   --  temporaries that interfere with stack checking mechanism. Note that the\n+   --  caller has to check whether stack checking is actually enabled in order\n+   --  to guide the expansion (typically of a function call).\n \n    procedure Remove_Side_Effects\n      (Exp          : Node_Id;\n       Name_Req     : Boolean := False;\n       Variable_Ref : Boolean := False);\n-   --  Given the node for a subexpression, this function replaces the node\n-   --  if necessary by an equivalent subexpression that is guaranteed to be\n-   --  side effect free. This is done by extracting any actions that could\n-   --  cause side effects, and inserting them using Insert_Actions into the\n-   --  tree to which Exp is attached. Exp must be analyzed and resolved\n-   --  before the call and is analyzed and resolved on return. The Name_Req\n-   --  may only be set to True if Exp has the form of a name, and the\n-   --  effect is to guarantee that any replacement maintains the form of a\n-   --  name. If Variable_Ref is set to TRUE, a variable is considered as a\n-   --  side effect (used in implementing Force_Evaluation). Note: after a\n-   --  call to Remove_Side_Effects, it is safe to call New_Copy_Tree to\n-   --  obtain a copy of the resulting expression.\n+   --  Given the node for a subexpression, this function replaces the node if\n+   --  necessary by an equivalent subexpression that is guaranteed to be side\n+   --  effect free. This is done by extracting any actions that could cause\n+   --  side effects, and inserting them using Insert_Actions into the tree to\n+   --  which Exp is attached. Exp must be analyzed and resolved before the call\n+   --  and is analyzed and resolved on return. The Name_Req may only be set to\n+   --  True if Exp has the form of a name, and the effect is to guarantee that\n+   --  any replacement maintains the form of name. If Variable_Ref is set to\n+   --  TRUE, a variable is considered as side effect (used in implementing\n+   --  Force_Evaluation). Note: after call to Remove_Side_Effects, it is safe\n+   --  to call New_Copy_Tree to obtain a copy of the resulting expression.\n \n    function Represented_As_Scalar (T : Entity_Id) return Boolean;\n    --  Returns True iff the implementation of this type in code generation\n    --  terms is scalar. This is true for scalars in the Ada sense, and for\n    --  packed arrays which are represented by a scalar (modular) type.\n \n    function Safe_Unchecked_Type_Conversion (Exp : Node_Id) return Boolean;\n-   --  Given the node for an N_Unchecked_Type_Conversion, return True\n-   --  if this is an unchecked conversion that Gigi can handle directly.\n-   --  Otherwise return False if it is one for which the front end must\n-   --  provide a temporary. Note that the node need not be analyzed, and\n-   --  thus the Etype field may not be set, but in that case it must be\n-   --  the case that the Subtype_Mark field of the node is set/analyzed.\n+   --  Given the node for an N_Unchecked_Type_Conversion, return True if this\n+   --  is an unchecked conversion that Gigi can handle directly. Otherwise\n+   --  return False if it is one for which the front end must provide a\n+   --  temporary. Note that the node need not be analyzed, and thus the Etype\n+   --  field may not be set, but in that case it must be the case that the\n+   --  Subtype_Mark field of the node is set/analyzed.\n \n    procedure Set_Elaboration_Flag (N : Node_Id; Spec_Id : Entity_Id);\n-   --  N is the node for a subprogram or generic body, and Spec_Id\n-   --  is the entity for the corresponding spec. If an elaboration\n-   --  entity is defined, then this procedure generates an assignment\n-   --  statement to set it True, immediately after the body is elaborated.\n-   --  However, no assignment is generated in the case of library level\n-   --  procedures, since the setting of the flag in this case is generated\n-   --  in the binder. We do that so that we can detect cases where this is\n-   --  the only elaboration action that is required.\n+   --  N is the node for a subprogram or generic body, and Spec_Id is the\n+   --  entity for the corresponding spec. If an elaboration entity is defined,\n+   --  then this procedure generates an assignment statement to set it True,\n+   --  immediately after the body is elaborated. However, no assignment is\n+   --  generated in the case of library level procedures, since the setting of\n+   --  the flag in this case is generated in the binder. We do that so that we\n+   --  can detect cases where this is the only elaboration action that is\n+   --  required.\n \n    function Target_Has_Fixed_Ops\n      (Left_Typ   : Entity_Id;\n@@ -545,20 +554,20 @@ package Exp_Util is\n \n    function Type_May_Have_Bit_Aligned_Components\n      (Typ : Entity_Id) return Boolean;\n-   --  Determines if Typ is a composite type that has within it (looking\n-   --  down recursively at any subcomponents), a record type which has a\n-   --  component that may be bit aligned (see Possible_Bit_Aligned_Component).\n-   --  The result is conservative, in that a result of False is decisive.\n-   --  A result of True means that such a component may or may not be present.\n+   --  Determines if Typ is a composite type that has within it (looking down\n+   --  recursively at any subcomponents), a record type which has component\n+   --  that may be bit aligned (see Possible_Bit_Aligned_Component). The result\n+   --  is conservative, in that a result of False is decisive. A result of True\n+   --  means that such a component may or may not be present.\n \n    procedure Wrap_Cleanup_Procedure (N : Node_Id);\n-   --  Given an N_Subprogram_Body node, this procedure adds an Abort_Defer\n-   --  call at the start of the statement sequence, and an Abort_Undefer call\n-   --  at the end of the statement sequence. All cleanup routines (i.e. those\n-   --  that are called from \"at end\" handlers) must defer abort on entry and\n-   --  undefer abort on exit. Note that it is assumed that the code for the\n-   --  procedure does not contain any return statements which would allow the\n-   --  flow of control to escape doing the undefer call.\n+   --  Given an N_Subprogram_Body node, this procedure adds an Abort_Defer call\n+   --  at the start of the statement sequence, and an Abort_Undefer call at the\n+   --  end of the statement sequence. All cleanup routines (i.e. those that are\n+   --  called from \"at end\" handlers) must defer abort on entry and undefer\n+   --  abort on exit. Note that it is assumed that the code for the procedure\n+   --  does not contain any return statements which would allow the flow of\n+   --  control to escape doing the undefer call.\n \n private\n    pragma Inline (Force_Evaluation);"}, {"sha": "85efcea6fcda02337bce4ee2e118b05616a16f03", "filename": "gcc/ada/i-cpp.adb", "status": "modified", "additions": 2, "deletions": 352, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fi-cpp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fi-cpp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpp.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,357 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Tags;                use Ada.Tags;\n-with System;                  use System;\n-with System.Storage_Elements; use System.Storage_Elements;\n+--  Dummy body to deal with bootstrap issues (there used to be a real body)\n \n package body Interfaces.CPP is\n-\n---  Structure of the Dispatch Table\n-\n---           +-----------------------+\n---           |     Offset_To_Top     |\n---           +-----------------------+\n---           | Typeinfo_Ptr/TSD_Ptr  |----> Type Specific Data\n---  Tag ---> +-----------------------+      +-------------------+\n---           |        table of       |      | inheritance depth |\n---           :     primitive ops     :      +-------------------+\n---           |        pointers       |      |   expanded name   |\n---           +-----------------------+      +-------------------+\n---                                          |   external tag    |\n---                                          +-------------------+\n---                                          |   Hash table link |\n---                                          +-------------------+\n---                                          | Remotely Callable |\n---                                          +-------------------+\n---                                          | Rec Ctrler offset |\n---                                          +-------------------+\n---                                          | table of          |\n---                                          :   ancestor        :\n---                                          |      tags         |\n---                                          +-------------------+\n-\n-   --  The declarations below need (extensive) comments ???\n-\n-   subtype Cstring is String (Positive);\n-   type Cstring_Ptr is access all Cstring;\n-   type Tag_Table is array (Natural range <>) of Vtable_Ptr;\n-   pragma Suppress_Initialization (Tag_Table);\n-\n-   type Type_Specific_Data is record\n-      Idepth        : Natural;\n-      Expanded_Name : Cstring_Ptr;\n-      External_Tag  : Cstring_Ptr;\n-      HT_Link       : Tag;\n-      Ancestor_Tags : Tag_Table (Natural);\n-   end record;\n-\n-   type Vtable_Entry is record\n-     Pfn : System.Address;\n-   end record;\n-\n-   type Vtable_Entry_Array is array (Positive range <>) of Vtable_Entry;\n-\n-   type VTable is record\n-      --  Offset_To_Top : Integer;\n-      --  Typeinfo_Ptr  : System.Address; -- TSD is currently also here???\n-      Prims_Ptr  : Vtable_Entry_Array (Positive);\n-   end record;\n-   --  Note: See comment in a-tags.adb explaining why the components\n-   --        Offset_To_Top and Typeinfo_Ptr have been commented out.\n-   --  -----------------------------------------------------------------------\n-   --  The size of the Prims_Ptr array actually depends on the tagged type to\n-   --  which it applies. For each tagged type, the expander computes the\n-   --  actual array size, allocates the Dispatch_Table record accordingly, and\n-   --  generates code that displaces the base of the record after the\n-   --  Typeinfo_Ptr component. For this reason the first two components have\n-   --  been commented in the previous declaration. The access to these\n-   --  components is done by means of local functions.\n-\n-   ---------------------------\n-   -- Unchecked Conversions --\n-   ---------------------------\n-\n-   type Int_Ptr is access Integer;\n-\n-   function To_Int_Ptr is\n-      new Unchecked_Conversion (System.Address, Int_Ptr);\n-\n-   function To_Cstring_Ptr is\n-     new Unchecked_Conversion (Address, Cstring_Ptr);\n-\n-   function To_Address is\n-     new Unchecked_Conversion (Cstring_Ptr, Address);\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Length (Str : Cstring_Ptr) return Natural;\n-   --  Length of string represented by the given pointer (treating the string\n-   --  as a C-style string, which is Nul terminated).\n-\n-   function Offset_To_Top (T : Vtable_Ptr) return Integer;\n-   --  Returns the current value of the offset_to_top component available in\n-   --  the prologue of the dispatch table.\n-\n-   function Typeinfo_Ptr (T : Vtable_Ptr) return System.Address;\n-   --  Returns the current value of the typeinfo_ptr component available in\n-   --  the prologue of the dispatch table.\n-\n-   pragma Unreferenced (Offset_To_Top);\n-   pragma Unreferenced (Typeinfo_Ptr);\n-   --  These functions will be used for full compatibility with the C++ ABI\n-\n-   -----------------------\n-   -- CPP_CW_Membership --\n-   -----------------------\n-\n-   function CPP_CW_Membership\n-     (Obj_Tag : Vtable_Ptr;\n-      Typ_Tag : Vtable_Ptr) return Boolean\n-   is\n-      Pos : constant Integer := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n-   begin\n-      return Pos >= 0 and then TSD (Obj_Tag).Ancestor_Tags (Pos) = Typ_Tag;\n-   end CPP_CW_Membership;\n-\n-   --------------------------\n-   -- CPP_Get_External_Tag --\n-   --------------------------\n-\n-   function CPP_Get_External_Tag (T : Vtable_Ptr) return Address is\n-   begin\n-      return To_Address (TSD (T).External_Tag);\n-   end CPP_Get_External_Tag;\n-\n-   -------------------------\n-   -- CPP_Get_Prim_Op_Address --\n-   -------------------------\n-\n-   function CPP_Get_Prim_Op_Address\n-     (T        : Vtable_Ptr;\n-      Position : Positive) return Address\n-   is\n-   begin\n-      return T.Prims_Ptr (Position).Pfn;\n-   end CPP_Get_Prim_Op_Address;\n-\n-   -----------------------\n-   -- CPP_Get_RC_Offset --\n-   -----------------------\n-\n-   function CPP_Get_RC_Offset (T : Vtable_Ptr) return SSE.Storage_Offset is\n-      pragma Warnings (Off, T);\n-   begin\n-      return 0;\n-   end CPP_Get_RC_Offset;\n-\n-   -------------------------------\n-   -- CPP_Get_Remotely_Callable --\n-   -------------------------------\n-\n-   function CPP_Get_Remotely_Callable (T : Vtable_Ptr) return Boolean is\n-      pragma Warnings (Off, T);\n-   begin\n-      return True;\n-   end CPP_Get_Remotely_Callable;\n-\n-   --------------------\n-   -- CPP_Inherit_DT --\n-   --------------------\n-\n-   procedure CPP_Inherit_DT\n-    (Old_T   : Vtable_Ptr;\n-     New_T   : Vtable_Ptr;\n-     Entry_Count : Natural)\n-   is\n-   begin\n-      if Old_T /= null then\n-         New_T.Prims_Ptr (1 .. Entry_Count)\n-           := Old_T.Prims_Ptr (1 .. Entry_Count);\n-      end if;\n-   end CPP_Inherit_DT;\n-\n-   ---------------------\n-   -- CPP_Inherit_TSD --\n-   ---------------------\n-\n-   procedure CPP_Inherit_TSD\n-     (Old_Tag : Vtable_Ptr;\n-      New_Tag : Vtable_Ptr)\n-   is\n-      New_TSD_Ptr : constant Type_Specific_Data_Ptr := TSD (New_Tag);\n-      Old_TSD_Ptr : Type_Specific_Data_Ptr;\n-\n-   begin\n-      if Old_Tag /= null then\n-         Old_TSD_Ptr        := TSD (Old_Tag);\n-         New_TSD_Ptr.Idepth := Old_TSD_Ptr.Idepth + 1;\n-         New_TSD_Ptr.Ancestor_Tags (1 .. New_TSD_Ptr.Idepth) :=\n-           Old_TSD_Ptr.Ancestor_Tags (0 .. Old_TSD_Ptr.Idepth);\n-      else\n-         New_TSD_Ptr.Idepth := 0;\n-      end if;\n-\n-      New_TSD_Ptr.Ancestor_Tags (0) := New_Tag;\n-   end CPP_Inherit_TSD;\n-\n-   ---------------------------\n-   -- CPP_Set_Expanded_Name --\n-   ---------------------------\n-\n-   procedure CPP_Set_Expanded_Name (T : Vtable_Ptr; Value : Address) is\n-   begin\n-      TSD (T).Expanded_Name := To_Cstring_Ptr (Value);\n-   end CPP_Set_Expanded_Name;\n-\n-   --------------------------\n-   -- CPP_Set_External_Tag --\n-   --------------------------\n-\n-   procedure CPP_Set_External_Tag (T : Vtable_Ptr; Value : Address) is\n-   begin\n-      TSD (T).External_Tag := To_Cstring_Ptr (Value);\n-   end CPP_Set_External_Tag;\n-\n-   -----------------------------\n-   -- CPP_Set_Prim_Op_Address --\n-   -----------------------------\n-\n-   procedure CPP_Set_Prim_Op_Address\n-     (T        : Vtable_Ptr;\n-      Position : Positive;\n-      Value    : Address)\n-   is\n-   begin\n-      T.Prims_Ptr (Position).Pfn := Value;\n-   end CPP_Set_Prim_Op_Address;\n-\n-   -----------------------\n-   -- CPP_Set_RC_Offset --\n-   -----------------------\n-\n-   procedure CPP_Set_RC_Offset (T : Vtable_Ptr; Value : SSE.Storage_Offset) is\n-      pragma Warnings (Off, T);\n-      pragma Warnings (Off, Value);\n-   begin\n-      null;\n-   end CPP_Set_RC_Offset;\n-\n-   -------------------------------\n-   -- CPP_Set_Remotely_Callable --\n-   -------------------------------\n-\n-   procedure CPP_Set_Remotely_Callable (T : Vtable_Ptr; Value : Boolean) is\n-      pragma Warnings (Off, T);\n-      pragma Warnings (Off, Value);\n-   begin\n-      null;\n-   end CPP_Set_Remotely_Callable;\n-\n-   -----------------\n-   -- CPP_Set_TSD --\n-   -----------------\n-\n-   procedure CPP_Set_TSD (T : Vtable_Ptr; Value : Address) is\n-      use type System.Storage_Elements.Storage_Offset;\n-      TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - CPP_DT_Typeinfo_Ptr_Size);\n-   begin\n-      TSD_Ptr.all := Value;\n-   end CPP_Set_TSD;\n-\n-   --------------------\n-   -- Displaced_This --\n-   --------------------\n-\n-   function Displaced_This\n-    (Current_This : System.Address;\n-     Vptr         : Vtable_Ptr;\n-     Position     : Positive)\n-     return         System.Address\n-   is\n-      pragma Warnings (Off, Vptr);\n-      pragma Warnings (Off, Position);\n-\n-   begin\n-      return Current_This;\n-\n-      --  why is the following here commented out ???\n-      --  + Storage_Offset (Vptr.Prims_Ptr (Position).Delta1);\n-   end Displaced_This;\n-\n-   -------------------\n-   -- Expanded_Name --\n-   -------------------\n-\n-   function Expanded_Name (T : Vtable_Ptr) return String is\n-      Result : constant Cstring_Ptr := TSD (T).Expanded_Name;\n-   begin\n-      return Result (1 .. Length (Result));\n-   end Expanded_Name;\n-\n-   ------------------\n-   -- External_Tag --\n-   ------------------\n-\n-   function External_Tag (T : Vtable_Ptr) return String is\n-      Result : constant Cstring_Ptr := TSD (T).External_Tag;\n-   begin\n-      return Result (1 .. Length (Result));\n-   end External_Tag;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Str : Cstring_Ptr) return Natural is\n-      Len : Integer := 1;\n-\n-   begin\n-      while Str (Len) /= ASCII.Nul loop\n-         Len := Len + 1;\n-      end loop;\n-\n-      return Len - 1;\n-   end Length;\n-\n-   ------------------\n-   -- Offset_To_Top --\n-   ------------------\n-\n-   function Offset_To_Top (T : Vtable_Ptr) return Integer is\n-      use type System.Storage_Elements.Storage_Offset;\n-\n-      TSD_Ptr : constant Int_Ptr\n-        := To_Int_Ptr (To_Address (T) - CPP_DT_Prologue_Size);\n-   begin\n-      return TSD_Ptr.all;\n-   end Offset_To_Top;\n-\n-   ------------------\n-   -- Typeinfo_Ptr --\n-   ------------------\n-\n-   function Typeinfo_Ptr (T : Vtable_Ptr) return System.Address is\n-      use type System.Storage_Elements.Storage_Offset;\n-      TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - CPP_DT_Typeinfo_Ptr_Size);\n-   begin\n-      return TSD_Ptr.all;\n-   end Typeinfo_Ptr;\n-\n-   ---------\n-   -- TSD --\n-   ---------\n-\n-   function TSD (T : Vtable_Ptr) return Type_Specific_Data_Ptr is\n-      use type System.Storage_Elements.Storage_Offset;\n-      TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - CPP_DT_Typeinfo_Ptr_Size);\n-   begin\n-      return To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n-   end TSD;\n-\n end Interfaces.CPP;"}, {"sha": "6dbed5f481f308037d61a99b418c1ef9e1a916df", "filename": "gcc/ada/i-cpp.ads", "status": "modified", "additions": 12, "deletions": 159, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fi-cpp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fi-cpp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpp.ads?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                       I N T E R F A C E S . C P P                        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,168 +31,21 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Definitions for interfacing to C++ classes\n-\n---  This package corresponds to Ada.Tags but applied to tagged types which are\n---  are imported from C++ and correspond exactly to a C++ Class. The code that\n---  the GNAT front end generates does not know about the structure of the C++\n---  dispatch table (Vtable) but always accesses it through the procedural\n---  interface defined in this package, thus the implementation of this package\n---  (the body) can be customized to another C++ compiler without any change in\n---  the compiler code itself as long as this procedural interface is respected.\n---  Note that Ada.Tags defines a very similar procedural interface to the\n---  regular Ada Dispatch Table.\n-\n-with System;\n-with System.Storage_Elements;\n-with Unchecked_Conversion;\n+--  Missing package comment ???\n \n+with Ada.Tags;\n package Interfaces.CPP is\n+pragma Elaborate_Body;\n+--  We have a dummy body to deal with bootstrap path issues\n \n-   type Vtable_Ptr is private;\n-\n-   function Expanded_Name (T : Vtable_Ptr) return String;\n-   function External_Tag  (T : Vtable_Ptr) return String;\n-\n-private\n-   package S   renames System;\n-   package SSE renames System.Storage_Elements;\n-\n-   type Vtable;\n-   type Vtable_Ptr is access all Vtable;\n-\n-   type Type_Specific_Data;\n-   type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n-\n-   --  These subprograms are in the private part. They are never accessed\n-   --  directly except from compiler generated code, which has access to\n-   --  private components of packages via the Rtsfind interface.\n-\n-   procedure CPP_Set_Prim_Op_Address\n-     (T        : Vtable_Ptr;\n-      Position : Positive;\n-      Value    : S.Address);\n-   --  Given a pointer to a dispatch Table (T) and a position in the\n-   --  dispatch Table put the address of the virtual function in it\n-   --  (used for overriding)\n-\n-   function CPP_Get_Prim_Op_Address\n-     (T        : Vtable_Ptr;\n-      Position : Positive)\n-      return     S.Address;\n-   --  Given a pointer to a dispatch Table (T) and a position in the DT\n-   --  this function returns the address of the virtual function stored\n-   --  in it (used for dispatching calls)\n-\n-   procedure CPP_Set_TSD (T : Vtable_Ptr; Value : S.Address);\n-   --  Given a pointer T to a dispatch Table, stores the address of the\n-   --  record containing the Type Specific Data generated by GNAT\n-\n-   CPP_DT_Prologue_Size : constant SSE.Storage_Count :=\n-                            SSE.Storage_Count\n-                              (2 * (Standard'Address_Size / S.Storage_Unit));\n-   --  Size of the first part of the dispatch table\n-\n-   CPP_DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n-                            SSE.Storage_Count\n-                              (Standard'Address_Size / System.Storage_Unit);\n-   --  Size of the Typeinfo_Ptr field of the Dispatch Table.\n-\n-   CPP_DT_Entry_Size : constant SSE.Storage_Count :=\n-                         SSE.Storage_Count\n-                           (1 * (Standard'Address_Size / S.Storage_Unit));\n-   --  Size of each primitive operation entry in the Dispatch Table.\n-\n-   CPP_TSD_Prologue_Size : constant SSE.Storage_Count :=\n-                             SSE.Storage_Count\n-                               (4 * (Standard'Address_Size / S.Storage_Unit));\n-   --  Size of the first part of the type specific data\n-\n-   CPP_TSD_Entry_Size : constant SSE.Storage_Count :=\n-                          SSE.Storage_Count\n-                            (1 * (Standard'Address_Size / S.Storage_Unit));\n-   --  Size of each ancestor tag entry in the TSD\n-\n-   procedure CPP_Inherit_DT\n-    (Old_T       : Vtable_Ptr;\n-     New_T       : Vtable_Ptr;\n-     Entry_Count : Natural);\n-   --  Entry point used to initialize the DT of a type knowing the\n-   --  tag of the direct ancestor and the number of primitive ops that are\n-   --  inherited (Entry_Count).\n-\n-   procedure CPP_Inherit_TSD\n-     (Old_Tag : Vtable_Ptr;\n-      New_Tag : Vtable_Ptr);\n-   --  Entry point used to initialize the TSD of a type knowing the\n-   --  TSD of the direct ancestor.\n-\n-   function CPP_CW_Membership (Obj_Tag, Typ_Tag : Vtable_Ptr) return Boolean;\n-   --  Given the tag of an object and the tag associated to a type, return\n-   --  true if Obj is in Typ'Class.\n-\n-   procedure CPP_Set_External_Tag (T : Vtable_Ptr; Value : S.Address);\n-   --  Set the address of the string containing the external tag\n-   --  in the Dispatch table\n-\n-   function CPP_Get_External_Tag (T : Vtable_Ptr) return S.Address;\n-   --  Retrieve the address of a null terminated string containing\n-   --  the external name\n-\n-   procedure CPP_Set_Expanded_Name (T : Vtable_Ptr; Value : S.Address);\n-   --  Set the address of the string containing the expanded name\n-   --  in the Dispatch table\n-\n-   procedure CPP_Set_Remotely_Callable (T : Vtable_Ptr; Value : Boolean);\n-   --  Since the notions of spec/body distinction and categorized packages\n-   --  do not exist in C, this procedure will do nothing\n-\n-   function CPP_Get_Remotely_Callable (T : Vtable_Ptr) return Boolean;\n-   --  This function will always return True for the reason explained above\n-\n-   procedure CPP_Set_RC_Offset (T : Vtable_Ptr; Value : SSE.Storage_Offset);\n-   --  Sets the Offset of the implicit record controller when the object\n-   --  has controlled components. Set to O otherwise.\n-\n-   function CPP_Get_RC_Offset (T : Vtable_Ptr) return SSE.Storage_Offset;\n-   --  Return the Offset of the implicit record controller when the object\n-   --  has controlled components. O otherwise.\n-\n-   function Displaced_This\n-    (Current_This : S.Address;\n-     Vptr         : Vtable_Ptr;\n-     Position     : Positive)\n-     return         S.Address;\n-   --  Compute the displacement on the \"this\" pointer in order to be\n-   --  compatible with MI.\n-   --  (used for virtual function calls)\n-\n-   function TSD (T : Vtable_Ptr) return Type_Specific_Data_Ptr;\n-   --  Given a pointer T to a dispatch Table, retreives the address of the\n-   --  record containing the Type Specific Data generated by GNAT\n-\n-   type Addr_Ptr is access System.Address;\n-\n-   function To_Address is\n-     new Unchecked_Conversion (Vtable_Ptr, System.Address);\n+   subtype Vtable_Ptr is Ada.Tags.Tag;\n \n-   function To_Addr_Ptr is\n-      new Unchecked_Conversion (System.Address, Addr_Ptr);\n+   --  These need commenting (this is not an RM package!)\n \n-   function To_Type_Specific_Data_Ptr is\n-     new Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n+   function Expanded_Name (T : Vtable_Ptr) return String\n+     renames Ada.Tags.Expanded_Name;\n \n-   pragma Inline (CPP_Set_Prim_Op_Address);\n-   pragma Inline (CPP_Get_Prim_Op_Address);\n-   pragma Inline (CPP_Set_TSD);\n-   pragma Inline (CPP_Inherit_DT);\n-   pragma Inline (CPP_CW_Membership);\n-   pragma Inline (CPP_Set_External_Tag);\n-   pragma Inline (CPP_Get_External_Tag);\n-   pragma Inline (CPP_Set_Expanded_Name);\n-   pragma Inline (CPP_Set_Remotely_Callable);\n-   pragma Inline (CPP_Get_Remotely_Callable);\n-   pragma Inline (Displaced_This);\n-   pragma Inline (TSD);\n+   function External_Tag (T : Vtable_Ptr) return String\n+     renames Ada.Tags.External_Tag;\n \n end Interfaces.CPP;"}, {"sha": "b86058801cefcbf91d54424ba7cecae57a07f12f", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 87, "deletions": 29, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -175,11 +175,12 @@ package body Ch3 is\n \n       if Token = Tok_Identifier then\n \n-         --  Ada 2005 (AI-284): Compiling in Ada95 mode we notify\n-         --  that interface, overriding, and synchronized are\n-         --  new reserved words\n+         --  Ada 2005 (AI-284): Compiling in Ada95 mode we warn that INTERFACE,\n+         --  OVERRIDING, and SYNCHRONIZED are new reserved words.\n \n-         if Ada_Version = Ada_95 then\n+         if Ada_Version = Ada_95\n+           and then Warn_On_Ada_2005_Compatibility\n+         then\n             if Token_Name = Name_Overriding\n               or else Token_Name = Name_Synchronized\n               or else (Token_Name = Name_Interface\n@@ -235,7 +236,8 @@ package body Ch3 is\n \n    --  PRIVATE_EXTENSION_DECLARATION ::=\n    --    type DEFINING_IDENTIFIER [DISCRIMINANT_PART] is\n-   --      [abstract] new ancestor_SUBTYPE_INDICATION with private;\n+   --      [abstract] new ancestor_SUBTYPE_INDICATION\n+   --      [and INTERFACE_LIST] with private;\n \n    --  TYPE_DEFINITION ::=\n    --    ENUMERATION_TYPE_DEFINITION  | INTEGER_TYPE_DEFINITION\n@@ -702,6 +704,7 @@ package body Ch3 is\n \n                   Typedef_Node := P_Interface_Type_Definition\n                                    (Is_Synchronized => True);\n+                  Abstract_Present := True;\n \n                   case Saved_Token is\n                      when Tok_Task =>\n@@ -1120,6 +1123,8 @@ package body Ch3 is\n    --    DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n    --      [NULL_EXCLUSION] SUBTYPE_INDICATION [:= EXPRESSION];\n    --  | DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n+   --      ACCESS_DEFINITION [:= EXPRESSION];\n+   --  | DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n    --      ARRAY_TYPE_DEFINITION [:= EXPRESSION];\n \n    --  NUMBER_DECLARATION ::=\n@@ -1414,8 +1419,21 @@ package body Ch3 is\n                   Not_Null_Present := P_Null_Exclusion; --  Ada 2005 (AI-231)\n                   Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n \n-                  Set_Object_Definition (Decl_Node,\n-                     P_Subtype_Indication (Not_Null_Present));\n+                  if Token = Tok_Access then\n+                     if Ada_Version < Ada_05 then\n+                        Error_Msg_SP\n+                          (\"generalized use of anonymous access types \" &\n+                           \"is an Ada 2005 extension\");\n+                        Error_Msg_SP\n+                          (\"\\unit must be compiled with -gnat05 switch\");\n+                     end if;\n+\n+                     Set_Object_Definition\n+                       (Decl_Node, P_Access_Definition (Not_Null_Present));\n+                  else\n+                     Set_Object_Definition\n+                       (Decl_Node, P_Subtype_Indication (Not_Null_Present));\n+                  end if;\n                end if;\n \n                if Token = Tok_Renames then\n@@ -1461,8 +1479,24 @@ package body Ch3 is\n             else\n                Not_Null_Present := P_Null_Exclusion; --  Ada 2005 (AI-231)\n                Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n-               Set_Object_Definition (Decl_Node,\n-                  P_Subtype_Indication (Not_Null_Present));\n+\n+               --  Access definition (AI-406) or subtype indication.\n+\n+               if Token = Tok_Access then\n+                  if Ada_Version < Ada_05 then\n+                     Error_Msg_SP\n+                       (\"generalized use of anonymous access types \" &\n+                        \"is an Ada 2005 extension\");\n+                     Error_Msg_SP\n+                       (\"\\unit must be compiled with -gnat05 switch\");\n+                  end if;\n+\n+                  Set_Object_Definition\n+                    (Decl_Node, P_Access_Definition (Not_Null_Present));\n+               else\n+                  Set_Object_Definition\n+                    (Decl_Node, P_Subtype_Indication (Not_Null_Present));\n+               end if;\n             end if;\n \n          --  Array case\n@@ -1471,13 +1505,15 @@ package body Ch3 is\n             Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n             Set_Object_Definition (Decl_Node, P_Array_Type_Definition);\n \n-         --  Ada 2005 (AI-254)\n+         --  Ada 2005 (AI-254, AI-406)\n \n          elsif Token = Tok_Not then\n \n             --  OBJECT_DECLARATION ::=\n             --    DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n             --      [NULL_EXCLUSION] SUBTYPE_INDICATION [:= EXPRESSION];\n+            --  | DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n+            --          ACCESS_DEFINITION [:= EXPRESSION];\n \n             --  OBJECT_RENAMING_DECLARATION ::=\n             --    ...\n@@ -1496,16 +1532,18 @@ package body Ch3 is\n                Acc_Node := P_Access_Definition (Not_Null_Present);\n \n                if Token /= Tok_Renames then\n-                  Error_Msg_SC (\"RENAMES expected\");\n-                  raise Error_Resync;\n-               end if;\n+                  Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n+                  Set_Object_Definition (Decl_Node, Acc_Node);\n+                  goto init;\n \n-               Scan; --  past renames\n-               No_List;\n-               Decl_Node :=\n-                 New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n-               Set_Access_Definition (Decl_Node, Acc_Node);\n-               Set_Name (Decl_Node, P_Name);\n+               else\n+                  Scan; --  past renames\n+                  No_List;\n+                  Decl_Node :=\n+                    New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n+                  Set_Access_Definition (Decl_Node, Acc_Node);\n+                  Set_Name (Decl_Node, P_Name);\n+               end if;\n \n             else\n                Type_Node := P_Subtype_Mark;\n@@ -1551,17 +1589,21 @@ package body Ch3 is\n \n             Acc_Node := P_Access_Definition (Null_Exclusion_Present => False);\n \n+            --  Object declaration with access definition, or renaming.\n+\n             if Token /= Tok_Renames then\n-               Error_Msg_SC (\"RENAMES expected\");\n-               raise Error_Resync;\n-            end if;\n+               Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n+               Set_Object_Definition (Decl_Node, Acc_Node);\n+               goto init; -- ??? is this really needed goes here anyway\n \n-            Scan; --  past renames\n-            No_List;\n-            Decl_Node :=\n-              New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n-            Set_Access_Definition (Decl_Node, Acc_Node);\n-            Set_Name (Decl_Node, P_Name);\n+            else\n+               Scan; --  past renames\n+               No_List;\n+               Decl_Node :=\n+                 New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n+               Set_Access_Definition (Decl_Node, Acc_Node);\n+               Set_Name (Decl_Node, P_Name);\n+            end if;\n \n          --  Subtype indication case\n \n@@ -1600,6 +1642,7 @@ package body Ch3 is\n \n          --  Scan out initialization, allowed only for object declaration\n \n+         <<init>> -- is this really needed ???\n          Init_Loc := Token_Ptr;\n          Init_Expr := Init_Expr_Opt;\n \n@@ -1765,7 +1808,8 @@ package body Ch3 is\n               Make_Private_Extension_Declaration (No_Location,\n                 Defining_Identifier => Empty,\n                 Subtype_Indication  => Subtype_Indication (Typedef_Node),\n-                Abstract_Present    => Abstract_Present (Typedef_Node));\n+                Abstract_Present    => Abstract_Present (Typedef_Node),\n+                Interface_List      => Interface_List (Typedef_Node));\n \n             Delete_Node (Typedef_Node);\n             return Typedecl_Node;\n@@ -3823,6 +3867,20 @@ package body Ch3 is\n             Check_Bad_Layout;\n             P_Identifier_Declarations (Decls, Done, In_Spec);\n \n+         --  Ada2005: A subprogram declaration can start with \"not\" or\n+         --  \"overriding\". In older versions, \"overriding\" is handled\n+         --  like an identifier, with the appropriate warning.\n+\n+         when Tok_Not =>\n+            Check_Bad_Layout;\n+            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+            Done := False;\n+\n+         when Tok_Overriding =>\n+            Check_Bad_Layout;\n+            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+            Done := False;\n+\n          when Tok_Package =>\n             Check_Bad_Layout;\n             Append (P_Package (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);"}, {"sha": "1908af5ca63952459be9cfd49357b412d392efaa", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -484,27 +484,36 @@ package Rtsfind is\n \n      RE_Stream_Access,                   -- Ada.Streams.Stream_IO\n \n+     RE_Addr_Ptr,                        -- Ada.Tags\n      RE_CW_Membership,                   -- Ada.Tags\n+     RE_IW_Membership,                   -- Ada.Tags\n+     RE_Descendant_Tag,                  -- Ada.Tags\n      RE_DT_Entry_Size,                   -- Ada.Tags\n      RE_DT_Prologue_Size,                -- Ada.Tags\n      RE_External_Tag,                    -- Ada.Tags\n+     RE_Get_Access_Level,                -- Ada.Tags\n      RE_Get_External_Tag,                -- Ada.Tags\n      RE_Get_Prim_Op_Address,             -- Ada.Tags\n      RE_Get_RC_Offset,                   -- Ada.Tags\n      RE_Get_Remotely_Callable,           -- Ada.Tags\n      RE_Inherit_DT,                      -- Ada.Tags\n      RE_Inherit_TSD,                     -- Ada.Tags\n      RE_Internal_Tag,                    -- Ada.Tags\n+     RE_Is_Descendant_At_Same_Level,     -- Ada.Tags\n+     RE_Register_Interface_Tag,          -- Ada.Tags\n      RE_Register_Tag,                    -- Ada.Tags\n+     RE_Set_Access_Level,                -- Ada.Tags\n      RE_Set_Expanded_Name,               -- Ada.Tags\n      RE_Set_External_Tag,                -- Ada.Tags\n+     RE_Set_Offset_To_Top,               -- Ada.Tags\n      RE_Set_Prim_Op_Address,             -- Ada.Tags\n      RE_Set_RC_Offset,                   -- Ada.Tags\n      RE_Set_Remotely_Callable,           -- Ada.Tags\n      RE_Set_TSD,                         -- Ada.Tags\n      RE_Tag_Error,                       -- Ada.Tags\n      RE_TSD_Entry_Size,                  -- Ada.Tags\n      RE_TSD_Prologue_Size,               -- Ada.Tags\n+     RE_Interface_Tag,                   -- Ada.Tags\n      RE_Tag,                             -- Ada.Tags\n      RE_Address_Array,                   -- Ada.Tags\n \n@@ -1582,27 +1591,36 @@ package Rtsfind is\n \n      RE_Stream_Access                    => Ada_Streams_Stream_IO,\n \n+     RE_Addr_Ptr                         => Ada_Tags,\n      RE_CW_Membership                    => Ada_Tags,\n+     RE_IW_Membership                    => Ada_Tags,\n+     RE_Descendant_Tag                   => Ada_Tags,\n      RE_DT_Entry_Size                    => Ada_Tags,\n      RE_DT_Prologue_Size                 => Ada_Tags,\n      RE_External_Tag                     => Ada_Tags,\n+     RE_Get_Access_Level                 => Ada_Tags,\n      RE_Get_External_Tag                 => Ada_Tags,\n      RE_Get_Prim_Op_Address              => Ada_Tags,\n      RE_Get_RC_Offset                    => Ada_Tags,\n      RE_Get_Remotely_Callable            => Ada_Tags,\n      RE_Inherit_DT                       => Ada_Tags,\n      RE_Inherit_TSD                      => Ada_Tags,\n      RE_Internal_Tag                     => Ada_Tags,\n+     RE_Is_Descendant_At_Same_Level      => Ada_Tags,\n+     RE_Register_Interface_Tag           => Ada_Tags,\n      RE_Register_Tag                     => Ada_Tags,\n+     RE_Set_Access_Level                 => Ada_Tags,\n      RE_Set_Expanded_Name                => Ada_Tags,\n      RE_Set_External_Tag                 => Ada_Tags,\n+     RE_Set_Offset_To_Top                => Ada_Tags,\n      RE_Set_Prim_Op_Address              => Ada_Tags,\n      RE_Set_RC_Offset                    => Ada_Tags,\n      RE_Set_Remotely_Callable            => Ada_Tags,\n      RE_Set_TSD                          => Ada_Tags,\n      RE_Tag_Error                        => Ada_Tags,\n      RE_TSD_Entry_Size                   => Ada_Tags,\n      RE_TSD_Prologue_Size                => Ada_Tags,\n+     RE_Interface_Tag                    => Ada_Tags,\n      RE_Tag                              => Ada_Tags,\n      RE_Address_Array                    => Ada_Tags,\n "}, {"sha": "fd4392aa931a74df2976184251dcf4e477ec401f", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 104, "deletions": 34, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -690,12 +690,13 @@ package body Sem_Ch12 is\n    --  parent at the end of the instantiation (see Remove_Parent).\n \n    type Instance_Env is record\n-      Ada_Version         : Ada_Version_Type;\n-      Instantiated_Parent : Assoc;\n-      Exchanged_Views     : Elist_Id;\n-      Hidden_Entities     : Elist_Id;\n-      Current_Sem_Unit    : Unit_Number_Type;\n-      Parent_Unit_Visible : Boolean := False;\n+      Ada_Version          : Ada_Version_Type;\n+      Ada_Version_Explicit : Ada_Version_Type;\n+      Instantiated_Parent  : Assoc;\n+      Exchanged_Views      : Elist_Id;\n+      Hidden_Entities      : Elist_Id;\n+      Current_Sem_Unit     : Unit_Number_Type;\n+      Parent_Unit_Visible  : Boolean := False;\n    end record;\n \n    package Instance_Envs is new Table.Table (\n@@ -1696,6 +1697,8 @@ package body Sem_Ch12 is\n          end if;\n \n          Formal := New_Copy (Pack_Id);\n+         Create_Instantiation_Source (N, Gen_Unit, False, S_Adjustment);\n+\n          New_N :=\n            Copy_Generic_Node\n              (Original_Node (Gen_Decl), Empty, Instantiating => True);\n@@ -2620,17 +2623,30 @@ package body Sem_Ch12 is\n             --  generic is not a child unit of another generic, to avoid scope\n             --  problems and the reinstallation of parent instances.\n \n-            if Front_End_Inlining\n-              and then Expander_Active\n+            if Expander_Active\n               and then (not Is_Child_Unit (Gen_Unit)\n                          or else not Is_Generic_Unit (Scope (Gen_Unit)))\n-              and then (Is_In_Main_Unit (N)\n-                          or else In_Main_Context (Current_Scope))\n-              and then Nkind (Parent (N)) /= N_Compilation_Unit\n               and then Might_Inline_Subp\n               and then not Is_Actual_Pack\n             then\n-               Inline_Now := True;\n+               if Front_End_Inlining\n+                 and then (Is_In_Main_Unit (N)\n+                            or else In_Main_Context (Current_Scope))\n+                 and then Nkind (Parent (N)) /= N_Compilation_Unit\n+               then\n+                  Inline_Now := True;\n+\n+               --  In configurable_run_time mode we force the inlining of\n+               --  predefined subprogram marked Inline_Always, to minimize\n+               --  the use of the run-time library.\n+\n+               elsif Is_Predefined_File_Name\n+                       (Unit_File_Name (Get_Source_Unit (Gen_Decl)))\n+                 and then Configurable_Run_Time_Mode\n+                 and then Nkind (Parent (N)) /= N_Compilation_Unit\n+               then\n+                  Inline_Now := True;\n+               end if;\n             end if;\n \n             Needs_Body :=\n@@ -2641,7 +2657,6 @@ package body Sem_Ch12 is\n                            or else Might_Inline_Subp)\n                 and then not Is_Actual_Pack\n                 and then not Inline_Now\n-\n                 and then (Operating_Mode = Generate_Code\n                             or else (Operating_Mode = Check_Semantics\n                                       and then ASIS_Mode));\n@@ -2657,12 +2672,11 @@ package body Sem_Ch12 is\n             end if;\n \n             --  If the current context is generic, and the package being\n-            --  instantiated is declared within a formal package, there\n-            --  is no body to instantiate until the enclosing generic is\n-            --  instantiated, and there is an actual for the formal\n-            --  package. If the formal package has parameters, we build a\n-            --  regular package instance for it, that preceeds the original\n-            --  formal package declaration.\n+            --  instantiated is declared within a formal package, there is no\n+            --  body to instantiate until the enclosing generic is instantiated\n+            --  and there is an actual for the formal package. If the formal\n+            --  package has parameters, we build regular package instance for\n+            --  it, that preceeds the original formal package declaration.\n \n             if In_Open_Scopes (Scope (Scope (Gen_Unit))) then\n                declare\n@@ -2683,9 +2697,9 @@ package body Sem_Ch12 is\n             end if;\n          end;\n \n-         --  If we are generating the calling stubs from the instantiation\n-         --  of a generic RCI package, we will not use the body of the\n-         --  generic package.\n+         --  If we are generating the calling stubs from the instantiation of\n+         --  a generic RCI package, we will not use the body of the generic\n+         --  package.\n \n          if Distribution_Stub_Mode = Generate_Caller_Stub_Body\n            and then Is_Compilation_Unit (Defining_Entity (N))\n@@ -2829,7 +2843,8 @@ package body Sem_Ch12 is\n                end if;\n             end if;\n \n-            --  There is a problem with inlining here.\n+            --  There is a problem with inlining here\n+            --  More comments needed??? what problem\n \n             Set_Unit (Parent (N), Act_Decl);\n             Set_Parent_Spec (Act_Decl, Parent_Spec (N));\n@@ -3500,14 +3515,37 @@ package body Sem_Ch12 is\n             Check_Elab_Instantiation (N);\n          end if;\n \n+         if Is_Dispatching_Operation (Act_Decl_Id)\n+           and then Ada_Version >= Ada_05\n+         then\n+            declare\n+               Formal : Entity_Id;\n+\n+            begin\n+               Formal := First_Formal (Act_Decl_Id);\n+               while Present (Formal) loop\n+                  if Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n+                    and then Is_Controlling_Formal (Formal)\n+                    and then not Can_Never_Be_Null (Formal)\n+                  then\n+                     Error_Msg_NE (\"access parameter& is controlling,\",\n+                       N, Formal);\n+                     Error_Msg_NE (\"\\corresponding parameter of & must be\"\n+                       & \" explicitly null-excluding\", N, Gen_Id);\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+            end;\n+         end if;\n+\n          Check_Hidden_Child_Unit (N, Gen_Unit, Act_Decl_Id);\n \n          --  Subject to change, pending on if other pragmas are inherited ???\n \n          Validate_Categorization_Dependency (N, Act_Decl_Id);\n \n          if not Is_Intrinsic_Subprogram (Act_Decl_Id) then\n-\n             if not Generic_Separately_Compiled (Gen_Unit) then\n                Inherit_Context (Gen_Decl, N);\n             end if;\n@@ -3521,7 +3559,7 @@ package body Sem_Ch12 is\n                   or else Is_Inlined (Act_Decl_Id))\n               and then (Operating_Mode = Generate_Code\n                           or else (Operating_Mode = Check_Semantics\n-                                    and then ASIS_Mode))\n+                                     and then ASIS_Mode))\n               and then (Expander_Active or else ASIS_Mode)\n               and then not ABE_Is_Certain (N)\n               and then not Is_Eliminated (Act_Decl_Id)\n@@ -3764,6 +3802,7 @@ package body Sem_Ch12 is\n         (E1, E2 : Entity_Id) return Boolean\n       is\n          Ent : Entity_Id;\n+\n       begin\n          Ent := E2;\n          while Present (Ent) loop\n@@ -5814,12 +5853,13 @@ package body Sem_Ch12 is\n       Saved : Instance_Env;\n \n    begin\n-      Saved.Ada_Version         := Ada_Version;\n-      Saved.Instantiated_Parent := Current_Instantiated_Parent;\n-      Saved.Exchanged_Views     := Exchanged_Views;\n-      Saved.Hidden_Entities     := Hidden_Entities;\n-      Saved.Current_Sem_Unit    := Current_Sem_Unit;\n-      Saved.Parent_Unit_Visible := Parent_Unit_Visible;\n+      Saved.Ada_Version          := Ada_Version;\n+      Saved.Ada_Version_Explicit := Ada_Version_Explicit;\n+      Saved.Instantiated_Parent  := Current_Instantiated_Parent;\n+      Saved.Exchanged_Views      := Exchanged_Views;\n+      Saved.Hidden_Entities      := Hidden_Entities;\n+      Saved.Current_Sem_Unit     := Current_Sem_Unit;\n+      Saved.Parent_Unit_Visible  := Parent_Unit_Visible;\n       Instance_Envs.Increment_Last;\n       Instance_Envs.Table (Instance_Envs.Last) := Saved;\n \n@@ -6976,6 +7016,22 @@ package body Sem_Ch12 is\n             Nam := Make_Identifier (Loc, Chars (Formal_Sub));\n          end if;\n \n+      elsif Nkind (Specification (Formal)) = N_Procedure_Specification\n+        and then Null_Present (Specification (Formal))\n+      then\n+         --  Generate null body for procedure, for use in the instance\n+\n+         Decl_Node :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              => New_Spec,\n+             Declarations               => New_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Make_Null_Statement (Loc))));\n+\n+         Set_Is_Intrinsic_Subprogram (Defining_Unit_Name (New_Spec));\n+         return Decl_Node;\n+\n       else\n          Error_Msg_Sloc := Sloc (Scope (Analyzed_S));\n          Error_Msg_NE\n@@ -8172,7 +8228,18 @@ package body Sem_Ch12 is\n             Ancestor := Get_Instance_Of (Etype (Base_Type (A_Gen_T)));\n          end if;\n \n-         if not Is_Ancestor (Base_Type (Ancestor), Act_T) then\n+         --  Ada 2005 (AI-251)\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Interface (Ancestor)\n+         then\n+            if not Interface_Present_In_Ancestor (Act_T, Ancestor) then\n+               Error_Msg_NE\n+                 (\"(Ada 2005) expected type implementing & in instantiation\",\n+                  Actual, Ancestor);\n+            end if;\n+\n+         elsif not Is_Ancestor (Base_Type (Ancestor), Act_T) then\n             Error_Msg_NE\n               (\"expect type derived from & in instantiation\",\n                Actual, First_Subtype (Ancestor));\n@@ -9061,6 +9128,7 @@ package body Sem_Ch12 is\n \n    begin\n       Ada_Version := Saved.Ada_Version;\n+      Ada_Version_Explicit := Saved.Ada_Version_Explicit;\n \n       if No (Current_Instantiated_Parent.Act_Id) then\n \n@@ -10060,16 +10128,18 @@ package body Sem_Ch12 is\n      (Gen_Unit : Entity_Id;\n       Act_Unit : Entity_Id)\n    is\n-\n    begin\n       --  Regardless of the current mode, predefined units are analyzed in\n       --  the most current Ada mode, and earlier version Ada checks do not\n       --  apply to predefined units.\n \n+      --  Why is this not using the routine Opt.Set_Opt_Config_Switches ???\n+\n       if Is_Internal_File_Name\n           (Fname => Unit_File_Name (Get_Source_Unit (Gen_Unit)),\n            Renamings_Included => True) then\n          Ada_Version := Ada_Version_Type'Last;\n+         Ada_Version_Explicit := Ada_Version_Explicit_Config;\n       end if;\n \n       Current_Instantiated_Parent := (Gen_Unit, Act_Unit, Assoc_Null);"}, {"sha": "7ca349c337d8a3d42c8ad04bdc365e61b03a5011", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1549, "deletions": 98, "changes": 1647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -76,6 +76,12 @@ package body Sem_Ch3 is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Add_Interface_Tag_Components\n+     (N : Node_Id; Typ : Entity_Id);\n+   --  Ada 2005 (AI-251): Add the tag components corresponding to all the\n+   --  abstract interface types implemented by a record type or a derived\n+   --  record type.\n+\n    procedure Build_Derived_Type\n      (N             : Node_Id;\n       Parent_Type   : Entity_Id;\n@@ -164,6 +170,23 @@ package body Sem_Ch3 is\n    --  False is for an implicit derived full type for a type derived from a\n    --  private type (see Build_Derived_Type).\n \n+   procedure Collect_Interfaces\n+     (N            : Node_Id;\n+      Derived_Type : Entity_Id);\n+   --  Ada 2005 (AI-251): Subsidiary procedure to Build_Derived_Record_Type.\n+   --  Collect the list of interfaces that are not already implemented by the\n+   --  ancestors. This is the list of interfaces for which we must provide\n+   --  additional tag components.\n+\n+   procedure Complete_Subprograms_Derivation\n+     (Partial_View : Entity_Id;\n+      Derived_Type : Entity_Id);\n+   --  Ada 2005 (AI-251): Used to complete type derivation of private tagged\n+   --  types implementing interfaces. In this case some interface primitives\n+   --  may have been overriden with the partial-view and, instead of\n+   --  re-calculating them, they are included in the list of primitive\n+   --  operations of the full-view.\n+\n    function Inherit_Components\n      (N             : Node_Id;\n       Parent_Base   : Entity_Id;\n@@ -485,6 +508,12 @@ package body Sem_Ch3 is\n    --  the appropriate semantic fields. If the full view of the parent is\n    --  a record type, build constrained components of subtype.\n \n+   procedure Derive_Interface_Subprograms\n+     (Derived_Type : Entity_Id);\n+   --  Ada 2005 (AI-251): Subsidiary procedure to Build_Derived_Record_Type.\n+   --  Traverse the list of implemented interfaces and derive all their\n+   --  subprograms.\n+\n    procedure Derived_Standard_Character\n      (N             : Node_Id;\n       Parent_Type   : Entity_Id;\n@@ -503,10 +532,6 @@ package body Sem_Ch3 is\n    --  defined in the N_Full_Type_Declaration node N, that is T is the\n    --  derived type.\n \n-   function Find_Type_Of_Subtype_Indic (S : Node_Id) return Entity_Id;\n-   --  Given a subtype indication S (which is really an N_Subtype_Indication\n-   --  node or a plain N_Identifier), find the type of the subtype mark.\n-\n    procedure Enumeration_Type_Declaration (T : Entity_Id; Def : Node_Id);\n    --  Insert each literal in symbol table, as an overloadable identifier\n    --  Each enumeration type is mapped into a sequence of integers, and\n@@ -677,6 +702,21 @@ package body Sem_Ch3 is\n          Error_Msg_N (\"task entries cannot have access parameters\", N);\n       end if;\n \n+      --  Ada 2005: for an object declaration, the corresponding anonymous\n+      --  type is declared in the current scope. For access formals, access\n+      --  components, and access discriminants, the scope is that of the\n+      --  enclosing declaration, as set above.\n+\n+      if Nkind (Related_Nod) = N_Object_Declaration then\n+         Set_Scope (Anon_Type, Current_Scope);\n+      end if;\n+\n+      if All_Present (N)\n+        and then Ada_Version >= Ada_05\n+      then\n+         Error_Msg_N (\"ALL is not permitted for anonymous access types\", N);\n+      end if;\n+\n       --  Ada 2005 (AI-254): In case of anonymous access to subprograms\n       --  call the corresponding semantic routine\n \n@@ -731,13 +771,13 @@ package body Sem_Ch3 is\n \n       Set_Is_Access_Constant (Anon_Type, Constant_Present (N));\n \n-      --  The context is either a subprogram declaration or an access\n-      --  discriminant, in a private or a full type declaration. In the case\n-      --  of a subprogram, If the designated type is incomplete, the operation\n-      --  will be a primitive operation of the full type, to be updated\n-      --  subsequently. If the type is imported through a limited with clause,\n-      --  it is not a primitive operation of the type (which is declared\n-      --  elsewhere in some other scope).\n+      --  The context is either a subprogram declaration, object declaration,\n+      --  or an access discriminant, in a private or a full type declaration.\n+      --  In the case of a subprogram, if the designated type is incomplete,\n+      --  the operation will be a primitive operation of the full type, to be\n+      --  updated subsequently. If the type is imported through a limited_with\n+      --  clause, the subprogram is not a primitive operation of the type\n+      --  (which is declared elsewhere in some other scope).\n \n       if Ekind (Desig_Type) = E_Incomplete_Type\n         and then not From_With_Type (Desig_Type)\n@@ -763,8 +803,42 @@ package body Sem_Ch3 is\n \n       Desig_Type : constant Entity_Id :=\n                      Create_Itype (E_Subprogram_Type, Parent (T_Def));\n+      D_Ityp     : Node_Id := Associated_Node_For_Itype (Desig_Type);\n \n    begin\n+      --  Associate the Itype node with the inner full-type declaration\n+      --  or subprogram spec. This is required to handle nested anonymous\n+      --  declarations. For example:\n+\n+      --      procedure P\n+      --       (X : access procedure\n+      --                     (Y : access procedure\n+      --                                   (Z : access T)))\n+\n+      while Nkind (D_Ityp) /= N_Full_Type_Declaration\n+         and then Nkind (D_Ityp) /= N_Procedure_Specification\n+         and then Nkind (D_Ityp) /= N_Function_Specification\n+         and then Nkind (D_Ityp) /= N_Object_Renaming_Declaration\n+         and then Nkind (D_Ityp) /= N_Formal_Type_Declaration\n+      loop\n+         D_Ityp := Parent (D_Ityp);\n+         pragma Assert (D_Ityp /= Empty);\n+      end loop;\n+\n+      Set_Associated_Node_For_Itype (Desig_Type, D_Ityp);\n+\n+      if Nkind (D_Ityp) = N_Procedure_Specification\n+        or else Nkind (D_Ityp) = N_Function_Specification\n+      then\n+         Set_Scope (Desig_Type, Scope (Defining_Unit_Name (D_Ityp)));\n+\n+      elsif Nkind (D_Ityp) = N_Full_Type_Declaration\n+        or else Nkind (D_Ityp) = N_Object_Renaming_Declaration\n+        or else Nkind (D_Ityp) = N_Formal_Type_Declaration\n+      then\n+         Set_Scope (Desig_Type, Scope (Defining_Identifier (D_Ityp)));\n+      end if;\n+\n       if Nkind (T_Def) = N_Access_Function_Definition then\n          Analyze (Subtype_Mark (T_Def));\n          Set_Etype (Desig_Type, Entity (Subtype_Mark (T_Def)));\n@@ -940,6 +1014,143 @@ package body Sem_Ch3 is\n       Set_Is_Access_Constant (T, Constant_Present (Def));\n    end Access_Type_Declaration;\n \n+   ----------------------------------\n+   -- Add_Interface_Tag_Components --\n+   ----------------------------------\n+\n+   procedure Add_Interface_Tag_Components\n+     (N        : Node_Id;\n+      Typ      : Entity_Id)\n+   is\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Elmt     : Elmt_Id;\n+      Ext      : Node_Id;\n+      L        : List_Id;\n+      Last_Tag : Node_Id;\n+      Comp     : Node_Id;\n+\n+      procedure Add_Tag (Iface : Entity_Id);\n+      --  Comment required ???\n+\n+      -------------\n+      -- Add_Tag --\n+      -------------\n+\n+      procedure Add_Tag (Iface : Entity_Id) is\n+         Def      : Node_Id;\n+         Tag      : Entity_Id;\n+         Decl     : Node_Id;\n+\n+      begin\n+         pragma Assert (Is_Tagged_Type (Iface)\n+           and then Is_Interface (Iface));\n+\n+         Def :=\n+           Make_Component_Definition (Loc,\n+             Aliased_Present    => True,\n+             Subtype_Indication =>\n+               New_Occurrence_Of (RTE (RE_Interface_Tag), Loc));\n+\n+         Tag := Make_Defining_Identifier (Loc, New_Internal_Name ('V'));\n+\n+         Decl :=\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier  => Tag,\n+             Component_Definition => Def);\n+\n+         Analyze_Component_Declaration (Decl);\n+\n+         Set_Analyzed (Decl);\n+         Set_Ekind               (Tag, E_Component);\n+         Set_Is_Limited_Record   (Tag);\n+         Set_Is_Tag              (Tag);\n+         Init_Component_Location (Tag);\n+\n+         pragma Assert (Is_Frozen (Iface));\n+\n+         Set_DT_Entry_Count    (Tag,\n+           DT_Entry_Count (First_Entity (Iface)));\n+\n+         if not Present (Last_Tag) then\n+            Prepend (Decl, L);\n+         else\n+            Insert_After (Last_Tag, Decl);\n+         end if;\n+\n+         Last_Tag := Decl;\n+      end Add_Tag;\n+\n+   --  Start of procesing for Add_Interface_Tag_Components\n+\n+   begin\n+      if Ekind (Typ) /= E_Record_Type\n+        or else not Present (Abstract_Interfaces (Typ))\n+        or else Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+      then\n+         return;\n+      end if;\n+\n+      if Present (Abstract_Interfaces (Typ)) then\n+\n+         --  Find the current last tag\n+\n+         if Nkind (Type_Definition (N)) = N_Derived_Type_Definition then\n+            Ext := Record_Extension_Part (Type_Definition (N));\n+         else\n+            pragma Assert (Nkind (Type_Definition (N)) = N_Record_Definition);\n+            Ext := Type_Definition (N);\n+         end if;\n+\n+         Last_Tag := Empty;\n+\n+         if not (Present (Component_List (Ext))) then\n+            Set_Null_Present (Ext, False);\n+            L := New_List;\n+            Set_Component_List (Ext,\n+              Make_Component_List (Loc,\n+                Component_Items => L,\n+                Null_Present => False));\n+         else\n+            if Nkind (Type_Definition (N)) = N_Derived_Type_Definition then\n+               L := Component_Items\n+                      (Component_List\n+                        (Record_Extension_Part\n+                          (Type_Definition (N))));\n+            else\n+               L := Component_Items\n+                      (Component_List\n+                        (Type_Definition (N)));\n+            end if;\n+\n+            --  Find the last tag component\n+\n+            Comp := First (L);\n+\n+            while Present (Comp) loop\n+               if Is_Tag (Defining_Identifier (Comp)) then\n+                  Last_Tag := Comp;\n+               end if;\n+\n+               Next (Comp);\n+            end loop;\n+         end if;\n+\n+         --  At this point L references the list of components and Last_Tag\n+         --  references the current last tag (if any). Now we add the tag\n+         --  corresponding with all the interfaces that are not implemented\n+         --  by the parent.\n+\n+         pragma Assert (Present\n+                        (First_Elmt (Abstract_Interfaces (Typ))));\n+\n+         Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+         while Present (Elmt) loop\n+            Add_Tag (Node (Elmt));\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+   end Add_Interface_Tag_Components;\n+\n    -----------------------------------\n    -- Analyze_Component_Declaration --\n    -----------------------------------\n@@ -1023,12 +1234,7 @@ package body Sem_Ch3 is\n          T := Access_Definition\n                 (Related_Nod => N,\n                  N => Access_Definition (Component_Definition (N)));\n-\n-         --  Ada 2005 (AI-230): In case of components that are anonymous\n-         --  access types the level of accessibility depends on the enclosing\n-         --  type declaration\n-\n-         Set_Scope (T, Current_Scope); -- Ada 2005 (AI-230)\n+         Set_Is_Local_Anonymous_Access (T);\n \n          --  Ada 2005 (AI-254)\n \n@@ -1044,10 +1250,10 @@ package body Sem_Ch3 is\n \n       --  If the subtype is a constrained subtype of the enclosing record,\n       --  (which must have a partial view) the back-end does not handle\n-      --  properly the recursion. Rewrite the component declaration with\n-      --  an explicit subtype indication, which is acceptable to Gigi. We\n-      --  can copy the tree directly because side effects have already been\n-      --  removed from discriminant constraints.\n+      --  properly the recursion. Rewrite the component declaration with an\n+      --  explicit subtype indication, which is acceptable to Gigi. We can copy\n+      --  the tree directly because side effects have already been removed from\n+      --  discriminant constraints.\n \n       if Ekind (T) = E_Access_Subtype\n         and then Is_Entity_Name (Subtype_Indication (Component_Definition (N)))\n@@ -1127,9 +1333,8 @@ package body Sem_Ch3 is\n          Null_Exclusion_Static_Checks (N);\n       end if;\n \n-      --  If this component is private (or depends on a private type),\n-      --  flag the record type to indicate that some operations are not\n-      --  available.\n+      --  If this component is private (or depends on a private type), flag the\n+      --  record type to indicate that some operations are not available.\n \n       P := Private_Component (T);\n \n@@ -1742,7 +1947,13 @@ package body Sem_Ch3 is\n \n          --  Protected objects with interrupt handlers must be at library level\n \n-         if Has_Interrupt_Handler (T) then\n+         --  Ada 2005: this test is not needed (and the corresponding clause\n+         --  in the RM is removed) because accessibility checks are sufficient\n+         --  to make handlers not at the library level illegal.\n+\n+         if Has_Interrupt_Handler (T)\n+           and then Ada_Version < Ada_05\n+         then\n             Error_Msg_N\n               (\"interrupt object can only be declared at library level\", Id);\n          end if;\n@@ -2265,6 +2476,26 @@ package body Sem_Ch3 is\n       Parent_Base : Entity_Id;\n \n    begin\n+      --  Ada 2005 (AI-251): Decorate all the names in the list of ancestor\n+      --  interfaces\n+\n+      if Is_Non_Empty_List (Interface_List (N)) then\n+         declare\n+            I : Node_Id := First (Interface_List (N));\n+            T : Entity_Id;\n+         begin\n+            while Present (I) loop\n+               T := Find_Type_Of_Subtype_Indic (I);\n+\n+               if not Is_Interface (T) then\n+                  Error_Msg_NE (\"(Ada 2005) & must be an interface\", I, T);\n+               end if;\n+\n+               Next (I);\n+            end loop;\n+         end;\n+      end if;\n+\n       Generate_Definition (T);\n       Enter_Name (T);\n \n@@ -3065,6 +3296,7 @@ package body Sem_Ch3 is\n          Element_Type := Access_Definition\n                            (Related_Nod => Related_Id,\n                             N           => Access_Definition (Component_Def));\n+         Set_Is_Local_Anonymous_Access (Element_Type);\n \n          --  Ada 2005 (AI-230): In case of components that are anonymous\n          --  access types the level of accessibility depends on the enclosing\n@@ -3218,7 +3450,7 @@ package body Sem_Ch3 is\n \n       elsif Is_Abstract (Element_Type) then\n          Error_Msg_N\n-           (\"The type of a component cannot be abstract\",\n+           (\"the type of a component cannot be abstract\",\n             Subtype_Indication (Component_Def));\n       end if;\n \n@@ -4931,28 +5163,30 @@ package body Sem_Ch3 is\n       Last_Discrim : Entity_Id;\n       Constrs      : Elist_Id;\n \n-      Discs : Elist_Id := New_Elmt_List;\n+      Discs        : Elist_Id := New_Elmt_List;\n       --  An empty Discs list means that there were no constraints in the\n       --  subtype indication or that there was an error processing it.\n \n-      Assoc_List : Elist_Id;\n-      New_Discrs : Elist_Id;\n-      New_Base   : Entity_Id;\n-      New_Decl   : Node_Id;\n-      New_Indic  : Node_Id;\n+      Assoc_List         : Elist_Id;\n+      New_Discrs         : Elist_Id;\n+      New_Base           : Entity_Id;\n+      New_Decl           : Node_Id;\n+      New_Indic          : Node_Id;\n \n       Is_Tagged          : constant Boolean := Is_Tagged_Type (Parent_Type);\n       Discriminant_Specs : constant Boolean :=\n                              Present (Discriminant_Specifications (N));\n       Private_Extension  : constant Boolean :=\n                              (Nkind (N) = N_Private_Extension_Declaration);\n \n-      Constraint_Present : Boolean;\n-      Inherit_Discrims   : Boolean := False;\n-\n-      Save_Etype        : Entity_Id;\n-      Save_Discr_Constr : Elist_Id;\n-      Save_Next_Entity  : Entity_Id;\n+      Constraint_Present     : Boolean;\n+      Has_Interfaces         : Boolean := False;\n+      Inherit_Discrims       : Boolean := False;\n+      Last_Inherited_Prim_Op : Elmt_Id;\n+      Tagged_Partial_View    : Entity_Id;\n+      Save_Etype             : Entity_Id;\n+      Save_Discr_Constr      : Elist_Id;\n+      Save_Next_Entity       : Entity_Id;\n \n    begin\n       if Ekind (Parent_Type) = E_Record_Type_With_Private\n@@ -5193,7 +5427,54 @@ package body Sem_Ch3 is\n             Freeze_Before (N, Parent_Type);\n          end if;\n \n-         if Type_Access_Level (Derived_Type) /= Type_Access_Level (Parent_Type)\n+         --  In Ada 2005 (AI-344), the restriction that a derived tagged type\n+         --  cannot be declared at a deeper level than its parent type is\n+         --  removed. The check on derivation within a generic body is also\n+         --  relaxed, but there's a restriction that a derived tagged type\n+         --  cannot be declared in a generic body if it's derived directly\n+         --  or indirectly from a formal type of that generic.\n+\n+         if Ada_Version >= Ada_05 then\n+            if Present (Enclosing_Generic_Body (Derived_Type)) then\n+               declare\n+                  Ancestor_Type : Entity_Id := Parent_Type;\n+\n+               begin\n+                  --  Check to see if any ancestor of the derived type is a\n+                  --  formal type.\n+\n+                  while not Is_Generic_Type (Ancestor_Type)\n+                    and then Etype (Ancestor_Type) /= Ancestor_Type\n+                  loop\n+                     Ancestor_Type := Etype (Ancestor_Type);\n+                  end loop;\n+\n+                  --  If the derived type does have a formal type as an\n+                  --  ancestor, then it's an error if the derived type is\n+                  --  declared within the body of the generic unit that\n+                  --  declares the formal type in its generic formal part. It's\n+                  --  sufficient to check whether the ancestor type is declared\n+                  --  inside the same generic body as the derived type (such as\n+                  --  within a nested generic spec), in which case the\n+                  --  derivation is legal. If the formal type is declared\n+                  --  outside of that generic body, then it's guaranteed that\n+                  --  the derived type is declared within the generic body of\n+                  --  the generic unit declaring the formal type.\n+\n+                  if Is_Generic_Type (Ancestor_Type)\n+                    and then Enclosing_Generic_Body (Ancestor_Type) /=\n+                               Enclosing_Generic_Body (Derived_Type)\n+                  then\n+                     Error_Msg_NE\n+                       (\"parent type of& must not be descendant of formal type\"\n+                          & \" of an enclosing generic body\",\n+                            Indic, Derived_Type);\n+                  end if;\n+               end;\n+            end if;\n+\n+         elsif Type_Access_Level (Derived_Type) /=\n+                 Type_Access_Level (Parent_Type)\n            and then not Is_Generic_Type (Derived_Type)\n          then\n             if Is_Controlled (Parent_Type) then\n@@ -5223,6 +5504,29 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Ada 2005 (AI-251)\n+\n+      if Ada_Version = Ada_05\n+        and then Is_Tagged\n+      then\n+\n+         --  \"The declaration of a specific descendant of an interface type\n+         --  freezes the interface type\" (RM 13.14).\n+\n+         declare\n+            Iface : Node_Id;\n+         begin\n+            if Is_Non_Empty_List (Interface_List (Type_Def)) then\n+               Iface := First (Interface_List (Type_Def));\n+\n+               while Present (Iface) loop\n+                  Freeze_Before (N, Etype (Iface));\n+                  Next (Iface);\n+               end loop;\n+            end if;\n+         end;\n+      end if;\n+\n       --  STEP 1b : preliminary cleanup of the full view of private types\n \n       --  If the type is already marked as having discriminants, then it's the\n@@ -5424,6 +5728,17 @@ package body Sem_Ch3 is\n       Set_Is_Tagged_Type    (Derived_Type, Is_Tagged);\n       Set_Stored_Constraint (Derived_Type, No_Elist);\n \n+      --  Ada 2005 (AI-251): Private type-declarations can implement interfaces\n+      --  but cannot be interfaces\n+\n+      if not Private_Extension\n+         and then Ekind (Derived_Type) /= E_Private_Type\n+         and then Ekind (Derived_Type) /= E_Limited_Private_Type\n+      then\n+         Set_Is_Interface (Derived_Type, Interface_Present (Type_Def));\n+         Set_Abstract_Interfaces (Derived_Type, No_Elist);\n+      end if;\n+\n       --  Fields inherited from the Parent_Type\n \n       Set_Discard_Names\n@@ -5507,6 +5822,143 @@ package body Sem_Ch3 is\n               (Derived_Type, Expand_To_Stored_Constraint (Parent_Base, Discs));\n          end if;\n \n+         --  Ada 2005 (AI-251): Look for the partial view of tagged types\n+         --  declared in the private part. This will be used 1) to check that\n+         --  the set of interfaces in both views is equal, and 2) to complete\n+         --  the derivation of subprograms covering interfaces.\n+\n+         Tagged_Partial_View := Empty;\n+\n+         if Has_Private_Declaration (Derived_Type) then\n+            Tagged_Partial_View := Next_Entity (Derived_Type);\n+            loop\n+               exit when Has_Private_Declaration (Tagged_Partial_View)\n+                 and then Full_View (Tagged_Partial_View) = Derived_Type;\n+\n+               Next_Entity (Tagged_Partial_View);\n+            end loop;\n+         end if;\n+\n+         --  Ada 2005 (AI-251): Collect the whole list of implemented\n+         --  interfaces.\n+\n+         if Ada_Version >= Ada_05 then\n+            Set_Abstract_Interfaces (Derived_Type, New_Elmt_List);\n+\n+            if Nkind (N) = N_Private_Extension_Declaration then\n+               Collect_Interfaces (N, Derived_Type);\n+            else\n+               Collect_Interfaces (Type_Definition (N), Derived_Type);\n+            end if;\n+\n+            --  Check that the full view and the partial view agree\n+            --  in the set of implemented interfaces\n+\n+            if Has_Private_Declaration (Derived_Type)\n+              and then Present (Abstract_Interfaces (Derived_Type))\n+              and then not Is_Empty_Elmt_List\n+                             (Abstract_Interfaces (Derived_Type))\n+            then\n+               declare\n+                  N_Partial : constant Node_Id := Parent (Tagged_Partial_View);\n+                  N_Full    : constant Node_Id := Parent (Derived_Type);\n+\n+                  Iface_Partial      : Entity_Id;\n+                  Iface_Full         : Entity_Id;\n+                  Num_Ifaces_Partial : Natural := 0;\n+                  Num_Ifaces_Full    : Natural := 0;\n+                  Same_Interfaces    : Boolean := True;\n+\n+               begin\n+                  --  Count the interfaces implemented by the partial view\n+\n+                  if not Is_Empty_List (Interface_List (N_Partial)) then\n+                     Iface_Partial := First (Interface_List (N_Partial));\n+\n+                     while Present (Iface_Partial) loop\n+                        Num_Ifaces_Partial := Num_Ifaces_Partial + 1;\n+                        Next (Iface_Partial);\n+                     end loop;\n+                  end if;\n+\n+                  --  Take into account the case in which the partial\n+                  --  view is a directly derived from an interface\n+\n+                  if Is_Interface (Etype\n+                                   (Defining_Identifier (N_Partial)))\n+                  then\n+                     Num_Ifaces_Partial := Num_Ifaces_Partial + 1;\n+                  end if;\n+\n+                  --  Count the interfaces implemented by the full view\n+\n+                  if not Is_Empty_List (Interface_List\n+                                        (Type_Definition (N_Full)))\n+                  then\n+                     Iface_Full := First (Interface_List\n+                                          (Type_Definition (N_Full)));\n+\n+                     while Present (Iface_Full) loop\n+                        Num_Ifaces_Full := Num_Ifaces_Full + 1;\n+                        Next (Iface_Full);\n+                     end loop;\n+                  end if;\n+\n+                  --  Take into account the case in which the full\n+                  --  view is a directly derived from an interface\n+\n+                  if Is_Interface (Etype\n+                                   (Defining_Identifier (N_Full)))\n+                  then\n+                     Num_Ifaces_Full := Num_Ifaces_Full + 1;\n+                  end if;\n+\n+                  if Num_Ifaces_Full > 0\n+                    and then Num_Ifaces_Full = Num_Ifaces_Partial\n+                  then\n+\n+                     --  Check that the full-view and the private-view have\n+                     --  the same list of interfaces\n+\n+                     Iface_Full := First (Interface_List\n+                                           (Type_Definition (N_Full)));\n+\n+                     while Present (Iface_Full) loop\n+                        Iface_Partial := First (Interface_List (N_Partial));\n+\n+                        while Present (Iface_Partial)\n+                          and then Etype (Iface_Partial) /= Etype (Iface_Full)\n+                        loop\n+                           Next (Iface_Partial);\n+                        end loop;\n+\n+                        --  If not found we check if the partial view is a\n+                        --  direct derivation of the interface.\n+\n+                        if not Present (Iface_Partial)\n+                             and then\n+                           Etype (Tagged_Partial_View) /= Etype (Iface_Full)\n+                        then\n+                           Same_Interfaces := False;\n+                           exit;\n+                        end if;\n+\n+                        Next (Iface_Full);\n+                     end loop;\n+                  end if;\n+\n+                  if Num_Ifaces_Partial /= Num_Ifaces_Full\n+                    or else not Same_Interfaces\n+                  then\n+                     Error_Msg_N\n+                       (\"(Ada 2005) full declaration and private declaration\"\n+                        & \" must have the same list of interfaces\",\n+                        Derived_Type);\n+                  end if;\n+               end;\n+            end if;\n+         end if;\n+\n       else\n          Set_Is_Packed (Derived_Type, Is_Packed (Parent_Base));\n          Set_Has_Non_Standard_Rep\n@@ -5596,6 +6048,13 @@ package body Sem_Ch3 is\n \n          Expand_Record_Extension (Derived_Type, Type_Def);\n \n+         --  Ada 2005 (AI-251): Addition of the Tag corresponding to all the\n+         --  implemented interfaces if we are in expansion mode\n+\n+         if Expander_Active then\n+            Add_Interface_Tag_Components (N, Derived_Type);\n+         end if;\n+\n          --  Analyze the record extension\n \n          Record_Type_Definition\n@@ -5613,8 +6072,140 @@ package body Sem_Ch3 is\n       --  derived freeze if necessary.\n \n       Set_Has_Delayed_Freeze (Derived_Type);\n+\n       if Derive_Subps then\n          Derive_Subprograms (Parent_Type, Derived_Type);\n+\n+         --  Ada 2005 (AI-251): Check if this tagged type implements abstract\n+         --  interfaces\n+\n+         Has_Interfaces := False;\n+\n+         if Is_Tagged_Type (Derived_Type) then\n+            declare\n+               E : Entity_Id;\n+\n+            begin\n+               E := Derived_Type;\n+               loop\n+                  if Is_Interface (E)\n+                    or else (Present (Abstract_Interfaces (E))\n+                               and then\n+                             not Is_Empty_Elmt_List (Abstract_Interfaces (E)))\n+                  then\n+                     Has_Interfaces := True;\n+                     exit;\n+                  end if;\n+\n+                  exit when Etype (E) = E\n+\n+                     --  Protect the frontend against wrong source\n+\n+                    or else Etype (E) = Derived_Type;\n+\n+                  E := Etype (E);\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  Ada 2005 (AI-251): Keep separate the management of tagged types\n+         --  implementing interfaces\n+\n+         if Is_Tagged_Type (Derived_Type)\n+           and then Has_Interfaces\n+         then\n+            --  Complete the decoration of private tagged types\n+\n+            if Present (Tagged_Partial_View) then\n+               Complete_Subprograms_Derivation\n+                 (Partial_View => Tagged_Partial_View,\n+                  Derived_Type => Derived_Type);\n+            end if;\n+\n+            --  Ada 2005 (AI-251): Derive the interface subprograms of all the\n+            --  implemented interfaces and check if some of the subprograms\n+            --  inherited from the ancestor cover some interface subprogram.\n+\n+            if not Present (Tagged_Partial_View) then\n+               declare\n+                  Subp_Elmt         : Elmt_Id := First_Elmt\n+                                                   (Primitive_Operations\n+                                                     (Derived_Type));\n+                  Iface_Subp_Elmt   : Elmt_Id;\n+                  Subp              : Entity_Id;\n+                  Iface_Subp        : Entity_Id;\n+                  Is_Interface_Subp : Boolean;\n+\n+               begin\n+                  --  Ada 2005 (AI-251): Remember the entity corresponding to\n+                  --  the last inherited primitive operation. This is required\n+                  --  to check if some of the inherited subprograms covers some\n+                  --  of the new interfaces.\n+\n+                  Last_Inherited_Prim_Op := No_Elmt;\n+\n+                  while Present (Subp_Elmt) loop\n+                     Last_Inherited_Prim_Op := Subp_Elmt;\n+                     Next_Elmt (Subp_Elmt);\n+                  end loop;\n+\n+                  --  Ada 2005 (AI-251): Derive subprograms in abstract\n+                  --  interfaces\n+\n+                  Derive_Interface_Subprograms (Derived_Type);\n+\n+                  --  Ada 2005 (AI-251): Check if some of the inherited\n+                  --  subprograms cover some of the new interfaces.\n+\n+                  if Present (Last_Inherited_Prim_Op) then\n+                     Iface_Subp_Elmt := Next_Elmt (Last_Inherited_Prim_Op);\n+                     while Present (Iface_Subp_Elmt) loop\n+                        Subp_Elmt := First_Elmt (Primitive_Operations\n+                                                  (Derived_Type));\n+                        while Subp_Elmt /= Last_Inherited_Prim_Op loop\n+                           Subp       := Node (Subp_Elmt);\n+                           Iface_Subp := Node (Iface_Subp_Elmt);\n+\n+                           Is_Interface_Subp :=\n+                             Present (Alias (Subp))\n+                               and then Present (DTC_Entity (Alias (Subp)))\n+                               and then Is_Interface (Scope\n+                                                      (DTC_Entity\n+                                                       (Alias (Subp))));\n+\n+                           if Chars (Subp) = Chars (Iface_Subp)\n+                             and then not Is_Interface_Subp\n+                             and then not Is_Abstract (Subp)\n+                             and then Type_Conformant (Iface_Subp, Subp)\n+                           then\n+                              Check_Dispatching_Operation\n+                                (Subp     => Subp,\n+                                 Old_Subp => Iface_Subp);\n+\n+                              --  Traverse the list of aliased subprograms\n+\n+                              declare\n+                                 E : Entity_Id := Alias (Subp);\n+                              begin\n+                                 while Present (Alias (E)) loop\n+                                    E := Alias (E);\n+                                 end loop;\n+                                 Set_Alias (Subp, E);\n+                              end;\n+\n+                              Set_Has_Delayed_Freeze (Subp);\n+                              exit;\n+                           end if;\n+\n+                           Next_Elmt (Subp_Elmt);\n+                        end loop;\n+\n+                        Next_Elmt (Iface_Subp_Elmt);\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+         end if;\n       end if;\n \n       --  If we have a private extension which defines a constrained derived\n@@ -6424,6 +7015,16 @@ package body Sem_Ch3 is\n                   Error_Msg_NE\n                     (\"type must be declared abstract or & overridden\",\n                      T, Subp);\n+\n+               --  Ada 2005 (AI-345): Protected or task type implementing\n+               --  abstract interfaces\n+\n+               elsif Is_Concurrent_Record_Type (T)\n+                   and then Present (Abstract_Interfaces (T))\n+               then\n+                  Error_Msg_NE\n+                    (\"interface subprogram & must be overridden\",\n+                     T, Subp);\n                end if;\n             else\n                Error_Msg_NE\n@@ -6475,6 +7076,11 @@ package body Sem_Ch3 is\n       --  ??? Also need to check components of record extensions, but not\n       --  components of protected types (which are always limited).\n \n+      --  Ada 2005: AI-363 relaxes this rule, to allow heap objects\n+      --  of such types to be unconstrained. This is safe because it is\n+      --  illegal to create access subtypes to such types with explicit\n+      --  discriminant constraints.\n+\n       if not Is_Limited_Type (T) then\n          if Ekind (T) = E_Record_Type then\n             C := First_Component (T);\n@@ -6483,6 +7089,7 @@ package body Sem_Ch3 is\n                  and then Has_Discriminants (Etype (C))\n                  and then not Is_Constrained (Etype (C))\n                  and then not In_Instance\n+                 and then Ada_Version < Ada_05\n                then\n                   Error_Msg_N\n                     (\"aliased component must be constrained ('R'M 3.6(11))\",\n@@ -6880,28 +7487,89 @@ package body Sem_Ch3 is\n       Resolve (Bound, Standard_Float);\n    end Check_Real_Bound;\n \n-   ------------------------------\n-   -- Complete_Private_Subtype --\n-   ------------------------------\n+   ------------------------\n+   -- Collect_Interfaces --\n+   ------------------------\n \n-   procedure Complete_Private_Subtype\n-     (Priv        : Entity_Id;\n-      Full        : Entity_Id;\n-      Full_Base   : Entity_Id;\n-      Related_Nod : Node_Id)\n-   is\n-      Save_Next_Entity : Entity_Id;\n-      Save_Homonym     : Entity_Id;\n+   procedure Collect_Interfaces (N : Node_Id; Derived_Type : Entity_Id) is\n+      I          : Node_Id;\n \n-   begin\n-      --  Set semantic attributes for (implicit) private subtype completion.\n-      --  If the full type has no discriminants, then it is a copy of the full\n-      --  view of the base. Otherwise, it is a subtype of the base with a\n-      --  possible discriminant constraint. Save and restore the original\n-      --  Next_Entity field of full to ensure that the calls to Copy_Node\n-      --  do not corrupt the entity chain.\n+      procedure Add_Interface (Iface : Entity_Id);\n \n-      --  Note that the type of the full view is the same entity as the\n+      procedure Add_Interface (Iface : Entity_Id) is\n+         Elmt : Elmt_Id := First_Elmt (Abstract_Interfaces (Derived_Type));\n+\n+      begin\n+         while Present (Elmt) and then Node (Elmt) /= Iface loop\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         if not Present (Elmt) then\n+            Append_Elmt (Node => Iface,\n+                         To   => Abstract_Interfaces (Derived_Type));\n+         end if;\n+      end Add_Interface;\n+\n+   begin\n+      pragma Assert (False\n+         or else Nkind (N) = N_Derived_Type_Definition\n+         or else Nkind (N) = N_Record_Definition\n+         or else Nkind (N) = N_Private_Extension_Declaration);\n+\n+      --  Traverse the graph of ancestor interfaces\n+\n+      if Is_Non_Empty_List (Interface_List (N)) then\n+         I := First (Interface_List (N));\n+\n+         while Present (I) loop\n+\n+            --  Protect against wrong usages. Example:\n+            --    type I is interface;\n+            --    type O is tagged null record;\n+            --    type Wrong is new I and O with null record;\n+\n+            if Is_Interface (Etype (I)) then\n+\n+               --  Do not add the interface when the derived type already\n+               --  implements this interface\n+\n+               if not Interface_Present_In_Ancestor (Derived_Type,\n+                                                     Etype (I))\n+               then\n+                  Collect_Interfaces\n+                     (Type_Definition (Parent (Etype (I))),\n+                      Derived_Type);\n+                  Add_Interface (Etype (I));\n+               end if;\n+            end if;\n+\n+            Next (I);\n+         end loop;\n+      end if;\n+   end Collect_Interfaces;\n+\n+   ------------------------------\n+   -- Complete_Private_Subtype --\n+   ------------------------------\n+\n+   procedure Complete_Private_Subtype\n+     (Priv        : Entity_Id;\n+      Full        : Entity_Id;\n+      Full_Base   : Entity_Id;\n+      Related_Nod : Node_Id)\n+   is\n+      Save_Next_Entity : Entity_Id;\n+      Save_Homonym     : Entity_Id;\n+\n+   begin\n+      --  Set semantic attributes for (implicit) private subtype completion.\n+      --  If the full type has no discriminants, then it is a copy of the full\n+      --  view of the base. Otherwise, it is a subtype of the base with a\n+      --  possible discriminant constraint. Save and restore the original\n+      --  Next_Entity field of full to ensure that the calls to Copy_Node\n+      --  do not corrupt the entity chain.\n+\n+      --  Note that the type of the full view is the same entity as the\n       --  type of the partial view. In this fashion, the subtype has\n       --  access to the correct view of the parent.\n \n@@ -7091,6 +7759,77 @@ package body Sem_Ch3 is\n       end if;\n    end Complete_Private_Subtype;\n \n+   -------------------------------------\n+   -- Complete_Subprograms_Derivation --\n+   -------------------------------------\n+\n+   procedure Complete_Subprograms_Derivation\n+     (Partial_View : Entity_Id;\n+      Derived_Type : Entity_Id)\n+   is\n+      Result  : constant Elist_Id := New_Elmt_List;\n+      Elmt_P  : Elmt_Id := No_Elmt;\n+      Elmt_D  : Elmt_Id;\n+      Found   : Boolean;\n+      Prim_Op : Entity_Id;\n+      E       : Entity_Id;\n+\n+   begin\n+      if Is_Tagged_Type (Partial_View) then\n+         Elmt_P := First_Elmt (Primitive_Operations (Partial_View));\n+      end if;\n+\n+      --  Inherit primitives declared with the partial-view\n+\n+      while Present (Elmt_P) loop\n+         Prim_Op := Node (Elmt_P);\n+         Found   := False;\n+         Elmt_D  := First_Elmt (Primitive_Operations (Derived_Type));\n+         while Present (Elmt_D) loop\n+            if Node (Elmt_D) = Prim_Op then\n+               Found := True;\n+               exit;\n+            end if;\n+\n+            Next_Elmt (Elmt_D);\n+         end loop;\n+\n+         if not Found then\n+            Append_Elmt (Prim_Op, Result);\n+\n+            --  Search for entries associated with abstract interfaces that\n+            --  have been covered by this primitive\n+\n+            Elmt_D  := First_Elmt (Primitive_Operations (Derived_Type));\n+            while Present (Elmt_D) loop\n+               E := Node (Elmt_D);\n+\n+               if Chars (E) = Chars (Prim_Op)\n+                 and then Is_Abstract (E)\n+                 and then Present (Alias (E))\n+                 and then Present (DTC_Entity (Alias (E)))\n+                 and then Is_Interface (Scope (DTC_Entity (Alias (E))))\n+               then\n+                  Remove_Elmt (Primitive_Operations (Derived_Type), Elmt_D);\n+               end if;\n+\n+               Next_Elmt (Elmt_D);\n+            end loop;\n+         end if;\n+\n+         Next_Elmt (Elmt_P);\n+      end loop;\n+\n+      --  Append the entities of the full-view to the list of primitives\n+      --  of derived_type\n+\n+      Elmt_D  := First_Elmt (Result);\n+      while Present (Elmt_D) loop\n+         Append_Elmt (Node (Elmt_D), Primitive_Operations (Derived_Type));\n+         Next_Elmt (Elmt_D);\n+      end loop;\n+   end Complete_Subprograms_Derivation;\n+\n    ----------------------------\n    -- Constant_Redeclaration --\n    ----------------------------\n@@ -7190,9 +7929,18 @@ package body Sem_Ch3 is\n       then\n          Enter_Name (Id);\n \n-      --  Verify that types of both declarations match\n+      --  Verify that types of both declarations match, or else that both types\n+      --  are anonymous access types whose designated subtypes statically match\n+      --  (as allowed in Ada 2005 by AI-385).\n \n-      elsif Base_Type (Etype (Prev)) /= Base_Type (New_T) then\n+      elsif Base_Type (Etype (Prev)) /= Base_Type (New_T)\n+        and then\n+          (Ekind (Etype (Prev)) /= E_Anonymous_Access_Type\n+             or else Ekind (Etype (New_T)) /= E_Anonymous_Access_Type\n+             or else not Subtypes_Statically_Match\n+                           (Designated_Type (Etype (Prev)),\n+                            Designated_Type (Etype (New_T))))\n+      then\n          Error_Msg_Sloc := Sloc (Prev);\n          Error_Msg_N (\"type does not match declaration#\", N);\n          Set_Full_View (Prev, Id);\n@@ -7257,6 +8005,24 @@ package body Sem_Ch3 is\n       Desig_Subtype : Entity_Id := Create_Itype (E_Void, Related_Nod);\n       Constraint_OK : Boolean := True;\n \n+      function Has_Defaulted_Discriminants (Typ : Entity_Id) return Boolean;\n+      --  Simple predicate to test for defaulted discriminants\n+      --  Shouldn't this be in sem_util???\n+\n+      ---------------------------------\n+      -- Has_Defaulted_Discriminants --\n+      ---------------------------------\n+\n+      function Has_Defaulted_Discriminants (Typ : Entity_Id) return Boolean is\n+      begin\n+         return Has_Discriminants (Typ)\n+          and then Present (First_Discriminant (Typ))\n+          and then Present\n+            (Discriminant_Default_Value (First_Discriminant (Typ)));\n+      end Has_Defaulted_Discriminants;\n+\n+   --  Start of processing for Constrain_Access\n+\n    begin\n       if Is_Array_Type (Desig_Type) then\n          Constrain_Array (Desig_Subtype, S, Related_Nod, Def_Id, 'P');\n@@ -7296,6 +8062,9 @@ package body Sem_Ch3 is\n             --  a derivation from a private type) has no discriminants.\n             --  (Defect Report 8652/0008, Technical Corrigendum 1, checked\n             --  by ACATS B371001).\n+            --  Rule updated for Ada 2005: the private type is said to have\n+            --  a constrained partial view, given that objects of the type\n+            --  can be declared.\n \n             declare\n                Pack  : constant Node_Id :=\n@@ -7324,8 +8093,9 @@ package body Sem_Ch3 is\n                      then\n                         if No (Discriminant_Specifications (Decl)) then\n                            Error_Msg_N\n-                            (\"cannot constrain general access type \" &\n-                               \"if designated type has unconstrained view\", S);\n+                            (\"cannot constrain general access type if \" &\n+                               \"designated type has constrained partial view\",\n+                                S);\n                         end if;\n \n                         exit;\n@@ -7376,6 +8146,31 @@ package body Sem_Ch3 is\n       Set_Is_Access_Constant       (Def_Id, Is_Access_Constant (T));\n \n       Conditional_Delay (Def_Id, T);\n+\n+      --  AI-363 : Subtypes of general access types whose designated\n+      --  types have default discriminants are disallowed. In instances,\n+      --  the rule has to be checked against the actual, of which T is\n+      --  the subtype. In a generic body, the rule is checked assuming\n+      --  that the actual type has defaulted discriminants.\n+\n+      if Ada_Version >=  Ada_05 then\n+         if Ekind (Base_Type (T)) = E_General_Access_Type\n+           and then Has_Defaulted_Discriminants (Desig_Type)\n+         then\n+            Error_Msg_N\n+              (\"access subype of general access type not allowed\", S);\n+            Error_Msg_N (\"\\ when discriminants have defaults\", S);\n+\n+         elsif Is_Access_Type (T)\n+           and then Is_Generic_Type (Desig_Type)\n+           and then Has_Discriminants (Desig_Type)\n+           and then In_Package_Body (Current_Scope)\n+         then\n+            Error_Msg_N (\"access subtype not allowed in generic body\", S);\n+            Error_Msg_N\n+              (\"\\ wben designated type is a discriminated formal\", S);\n+         end if;\n+      end if;\n    end Constrain_Access;\n \n    ---------------------\n@@ -7461,6 +8256,8 @@ package body Sem_Ch3 is\n \n       if Constraint_OK then\n          Set_First_Index (Def_Id, First (Constraints (C)));\n+      else\n+         Set_First_Index (Def_Id, First_Index (T));\n       end if;\n \n       Set_Is_Constrained     (Def_Id, True);\n@@ -9047,6 +9844,58 @@ package body Sem_Ch3 is\n       Set_Is_Constrained (T);\n    end Decimal_Fixed_Point_Type_Declaration;\n \n+   ---------------------------------\n+   -- Derive_Interface_Subprogram --\n+   ---------------------------------\n+\n+   procedure Derive_Interface_Subprograms (Derived_Type : Entity_Id) is\n+\n+      procedure Do_Derivation (T : Entity_Id);\n+      --  This inner subprograms is used to climb to the ancestors.\n+      --  It is needed to add the derivations to the Derived_Type.\n+\n+      procedure Do_Derivation (T : Entity_Id) is\n+         Etyp : constant Entity_Id := Etype (T);\n+         AI   : Elmt_Id;\n+\n+      begin\n+         if Etyp /= T\n+           and then Is_Interface (Etyp)\n+         then\n+            Do_Derivation (Etyp);\n+         end if;\n+\n+         if Present (Abstract_Interfaces (T))\n+           and then not Is_Empty_Elmt_List (Abstract_Interfaces (T))\n+         then\n+            AI := First_Elmt (Abstract_Interfaces (T));\n+\n+            while Present (AI) loop\n+               Derive_Subprograms\n+                 (Parent_Type             => Node (AI),\n+                  Derived_Type            => Derived_Type,\n+                  Is_Interface_Derivation => True);\n+\n+               Next_Elmt (AI);\n+            end loop;\n+         end if;\n+      end Do_Derivation;\n+\n+   begin\n+      Do_Derivation (Derived_Type);\n+\n+      --  At this point the list of primitive operations of Derived_Type\n+      --  contains the entities corresponding to all the subprograms of all the\n+      --  implemented interfaces. If N interfaces have subprograms with the\n+      --  same profile we have N entities in this list because each one must be\n+      --  allocated in its corresponding virtual table.\n+\n+      --  Its alias attribute references its original interface subprogram.\n+      --  When overriden, the alias attribute is later saved in the\n+      --  Abstract_Interface_Alias attribute.\n+\n+   end Derive_Interface_Subprograms;\n+\n    -----------------------\n    -- Derive_Subprogram --\n    -----------------------\n@@ -9430,9 +10279,10 @@ package body Sem_Ch3 is\n    ------------------------\n \n    procedure Derive_Subprograms\n-     (Parent_Type    : Entity_Id;\n-      Derived_Type   : Entity_Id;\n-      Generic_Actual : Entity_Id := Empty)\n+     (Parent_Type             : Entity_Id;\n+      Derived_Type            : Entity_Id;\n+      Generic_Actual          : Entity_Id := Empty;\n+      Is_Interface_Derivation : Boolean   := False)\n    is\n       Op_List     : constant Elist_Id :=\n                       Collect_Primitive_Operations (Parent_Type);\n@@ -9468,7 +10318,13 @@ package body Sem_Ch3 is\n          Subp := Node (Elmt);\n \n          if Ekind (Subp) /= E_Enumeration_Literal then\n-            if No (Generic_Actual) then\n+            if Is_Interface_Derivation then\n+               if not Is_Predefined_Dispatching_Operation (Subp) then\n+                  Derive_Subprogram\n+                    (New_Subp, Subp, Derived_Type, Parent_Base);\n+               end if;\n+\n+            elsif No (Generic_Actual) then\n                Derive_Subprogram\n                  (New_Subp, Subp, Derived_Type, Parent_Base);\n \n@@ -9567,6 +10423,7 @@ package body Sem_Ch3 is\n       Is_Completion : Boolean)\n    is\n       Def          : constant Node_Id := Type_Definition (N);\n+      Iface_Def    : Node_Id;\n       Indic        : constant Node_Id := Subtype_Indication (Def);\n       Extension    : constant Node_Id := Record_Extension_Part (Def);\n       Parent_Type  : Entity_Id;\n@@ -9608,6 +10465,92 @@ package body Sem_Ch3 is\n    begin\n       Parent_Type := Find_Type_Of_Subtype_Indic (Indic);\n \n+      --  Ada 2005 (AI-251): In case of interface derivation check that the\n+      --  parent is also an interface.\n+\n+      if Interface_Present (Def) then\n+         if not Is_Interface (Parent_Type) then\n+            Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                          Indic, Parent_Type);\n+\n+         else\n+            Iface_Def := Type_Definition (Parent (Parent_Type));\n+\n+            --  Ada 2005 (AI-251): Limited interfaces can only inherit from\n+            --  other limited interfaces.\n+\n+            if Limited_Present (Def) then\n+               if Limited_Present (Iface_Def) then\n+                  null;\n+\n+               elsif Protected_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n+                    \" inherit from protected interface\", Indic);\n+\n+               elsif Synchronized_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n+                    \" inherit from synchronized interface\", Indic);\n+\n+               elsif Task_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n+                    \" inherit from task interface\", Indic);\n+\n+               else\n+                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n+                    \" inherit from non-limited interface\", Indic);\n+               end if;\n+\n+            --  Ada 2005 (AI-345): Non-limited interfaces can only inherit\n+            --  from non-limited or limited interfaces.\n+\n+            elsif not Protected_Present (Def)\n+              and then not Synchronized_Present (Def)\n+              and then not Task_Present (Def)\n+            then\n+               if Limited_Present (Iface_Def) then\n+                  null;\n+\n+               elsif Protected_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) non-limited interface cannot\" &\n+                    \" inherit from protected interface\", Indic);\n+\n+               elsif Synchronized_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) non-limited interface cannot\" &\n+                    \" inherit from synchronized interface\", Indic);\n+\n+               elsif Task_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) non-limited interface cannot\" &\n+                    \" inherit from task interface\", Indic);\n+\n+               else\n+                  null;\n+               end if;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Ada 2005 (AI-251): Decorate all the names in the list of ancestor\n+      --  interfaces\n+\n+      if Is_Tagged_Type (Parent_Type)\n+        and then Is_Non_Empty_List (Interface_List (Def))\n+      then\n+         declare\n+            I : Node_Id := First (Interface_List (Def));\n+            T : Entity_Id;\n+         begin\n+            while Present (I) loop\n+               T := Find_Type_Of_Subtype_Indic (I);\n+\n+               if not Is_Interface (T) then\n+                  Error_Msg_NE (\"(Ada 2005) & must be an interface\", I, T);\n+               end if;\n+\n+               Next (I);\n+            end loop;\n+         end;\n+      end if;\n+\n       if Parent_Type = Any_Type\n         or else Etype (Parent_Type) = Any_Type\n         or else (Is_Class_Wide_Type (Parent_Type)\n@@ -10009,6 +10952,14 @@ package body Sem_Ch3 is\n                    (\"completion of nonlimited type cannot be limited\", N);\n                end if;\n \n+            --  Ada 2005 (AI-251): Private extension declaration of a\n+            --  task type. This case arises with tasks implementing interfaces\n+\n+            elsif Nkind (N) = N_Task_Type_Declaration\n+              or else Nkind (N) = N_Protected_Type_Declaration\n+            then\n+               null;\n+\n             elsif Nkind (N) /= N_Full_Type_Declaration\n               or else Nkind (Type_Definition (N)) /= N_Derived_Type_Definition\n             then\n@@ -10078,6 +11029,8 @@ package body Sem_Ch3 is\n          if Is_Type (Prev)\n            and then (Is_Tagged_Type (Prev)\n                       or else Present (Class_Wide_Type (Prev)))\n+           and then (Nkind (N) /= N_Task_Type_Declaration\n+                      and then Nkind (N) /= N_Protected_Type_Declaration)\n          then\n             --  The full declaration is either a tagged record or an\n             --  extension otherwise this is an error\n@@ -10183,11 +11136,19 @@ package body Sem_Ch3 is\n            and then No (Expression (P))\n          then\n             null;\n-\n          else\n             Insert_Actions (Obj_Def, Freeze_Entity (T, Sloc (P)));\n          end if;\n \n+      --  Ada 2005 AI-406: the object definition in an object declaration\n+      --  can be an access definition.\n+\n+      elsif Def_Kind = N_Access_Definition then\n+         T := Access_Definition (Related_Nod, Obj_Def);\n+         Set_Is_Local_Anonymous_Access (T);\n+\n+      --  comment here, what cases ???\n+\n       else\n          T := Process_Subtype (Obj_Def, Related_Nod);\n       end if;\n@@ -10850,7 +11811,17 @@ package body Sem_Ch3 is\n \n       Component := First_Entity (Parent_Base);\n       while Present (Component) loop\n-         if Ekind (Component) /= E_Component\n+\n+         --  Ada 2005 (AI-251): Do not inherit tags corresponding with the\n+         --  interfaces of the parent\n+\n+         if Ekind (Component) = E_Component\n+           and then Is_Tag (Component)\n+           and then Etype  (Component) = RTE (RE_Interface_Tag)\n+         then\n+            null;\n+\n+         elsif Ekind (Component) /= E_Component\n            or else Chars (Component) = Name_uParent\n          then\n             null;\n@@ -11812,6 +12783,18 @@ package body Sem_Ch3 is\n          if Nkind (Discriminant_Type (Discr)) = N_Access_Definition then\n             Discr_Type := Access_Definition (N, Discriminant_Type (Discr));\n \n+            --  Ada 2005 (AI-230): Access discriminants are now allowed for\n+            --  nonlimited types, and are treated like other components of\n+            --  anonymous access types in terms of accessibility.\n+\n+            if not Is_Concurrent_Type (Current_Scope)\n+              and then not Is_Concurrent_Record_Type (Current_Scope)\n+              and then not Is_Limited_Record (Current_Scope)\n+              and then Ekind (Current_Scope) /= E_Limited_Private_Type\n+            then\n+               Set_Is_Local_Anonymous_Access (Discr_Type);\n+            end if;\n+\n             --  Ada 2005 (AI-254)\n \n             if Present (Access_To_Subprogram_Definition\n@@ -11981,6 +12964,34 @@ package body Sem_Ch3 is\n       Full_Parent : Entity_Id;\n       Full_Indic  : Node_Id;\n \n+      function Find_Interface_In_Descendant\n+        (Typ : Entity_Id) return Entity_Id;\n+      --  Find an implemented interface in the derivation chain of Typ\n+\n+      ----------------------------------\n+      -- Find_Interface_In_Descendant --\n+      ----------------------------------\n+\n+      function Find_Interface_In_Descendant\n+        (Typ : Entity_Id) return Entity_Id\n+      is\n+         T : Entity_Id;\n+\n+      begin\n+         T := Typ;\n+         while T /= Etype (T) loop\n+            if Is_Interface (Etype (T)) then\n+               return Etype (T);\n+            end if;\n+\n+            T := Etype (T);\n+         end loop;\n+\n+         return Empty;\n+      end Find_Interface_In_Descendant;\n+\n+   --  Start of processing for Process_Full_View\n+\n    begin\n       --  First some sanity checks that must be done after semantic\n       --  decoration of the full view and thus cannot be placed with other\n@@ -12017,6 +13028,54 @@ package body Sem_Ch3 is\n          Error_Msg_N (\"generic type cannot have a completion\", Full_T);\n       end if;\n \n+      --  Ada 2005 (AI-396): A full view shall be a descendant of an\n+      --  interface type if and only if the corresponding partial view\n+      --  (if any) is also a descendant of the interface type, or if\n+      --  the partial view is untagged.\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Tagged_Type (Full_T)\n+      then\n+         declare\n+            Iface     : Entity_Id;\n+            Iface_Def : Node_Id;\n+\n+         begin\n+            Iface := Find_Interface_In_Descendant (Full_T);\n+\n+            if Present (Iface) then\n+               Iface_Def := Type_Definition (Parent (Iface));\n+            end if;\n+\n+            --  The full view derives from an interface descendant, but the\n+            --  partial view does not share the same tagged type.\n+\n+            if Present (Iface)\n+              and then Is_Tagged_Type (Priv_T)\n+              and then Etype (Full_T) /= Etype (Priv_T)\n+            then\n+               Error_Msg_N (\"(Ada 2005) tagged partial view cannot be \" &\n+                            \"completed by a type that implements an \" &\n+                            \"interface\", Priv_T);\n+            end if;\n+\n+            --  The full view derives from a limited, protected,\n+            --  synchronized or task interface descendant, but the\n+            --  partial view is not labeled as limited.\n+\n+            if Present (Iface)\n+              and then (Limited_Present      (Iface_Def)\n+                     or Protected_Present    (Iface_Def)\n+                     or Synchronized_Present (Iface_Def)\n+                     or Task_Present         (Iface_Def))\n+              and then not Limited_Present (Parent (Priv_T))\n+            then\n+               Error_Msg_N (\"(Ada 2005) non-limited private type cannot be \" &\n+                            \"completed by a limited type\", Priv_T);\n+            end if;\n+         end;\n+      end if;\n+\n       if Is_Tagged_Type (Priv_T)\n         and then Nkind (Parent (Priv_T)) = N_Private_Extension_Declaration\n         and then Is_Derived_Type (Full_T)\n@@ -12044,9 +13103,24 @@ package body Sem_Ch3 is\n             return;\n \n          elsif not Is_Ancestor (Base_Type (Priv_Parent), Full_Parent) then\n-            Error_Msg_N\n-              (\"parent of full type must descend from parent\"\n-                  & \" of private extension\", Full_Indic);\n+\n+            --  Ada 2005 (AI-251): No error needed if the immediate\n+            --  ancestor of the partial view is an interface\n+            --\n+            --  Example:\n+            --\n+            --       type PT1 is new I1 with private;\n+            --    private\n+            --       type PT1 is new T and I1 with null record;\n+\n+            if Is_Interface (Base_Type (Priv_Parent)) then\n+               null;\n+\n+            else\n+               Error_Msg_N\n+                 (\"parent of full type must descend from parent\"\n+                     & \" of private extension\", Full_Indic);\n+            end if;\n \n          --  Check the rules of 7.3(10): if the private extension inherits\n          --  known discriminants, then the full type must also inherit those\n@@ -12124,7 +13198,7 @@ package body Sem_Ch3 is\n          then\n             Error_Msg_N\n               (\"full view must define a constrained type if partial view\"\n-               & \" has no discriminants\", Full_T);\n+                & \" has no discriminants\", Full_T);\n          end if;\n \n          --  ??????? Do we implement the following properly ?????\n@@ -12144,6 +13218,22 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Ada 2005 AI-363: if the full view has discriminants with\n+      --  defaults, it is illegal to declare constrained access subtypes\n+      --  whose designated type is the current type. This allows objects\n+      --  of the type that are declared in the heap to be unconstrained.\n+\n+      if not Has_Unknown_Discriminants (Priv_T)\n+        and then not Has_Discriminants (Priv_T)\n+        and then Has_Discriminants (Full_T)\n+        and then\n+          Present\n+            (Discriminant_Default_Value (First_Discriminant (Full_T)))\n+      then\n+         Set_Has_Constrained_Partial_View (Full_T);\n+         Set_Has_Constrained_Partial_View (Priv_T);\n+      end if;\n+\n       --  Create a full declaration for all its subtypes recorded in\n       --  Private_Dependents and swap them similarly to the base type. These\n       --  are subtypes that have been define before the full declaration of\n@@ -12748,7 +13838,7 @@ package body Sem_Ch3 is\n \n             Rewrite (S, New_Copy_Tree (Subtype_Mark (S)));\n \n-            --  Set Ekind of orphan itype, to prevent cascaded errors.\n+            --  Set Ekind of orphan itype, to prevent cascaded errors\n \n             if Present (Def_Id) then\n                Set_Ekind (Def_Id, Ekind (Any_Type));\n@@ -12848,46 +13938,390 @@ package body Sem_Ch3 is\n       N    : Node_Id;\n       Prev : Entity_Id)\n    is\n-      Def : constant Node_Id := Type_Definition (N);\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Def   : constant Node_Id    := Type_Definition (N);\n+      Inc_T : Entity_Id := Empty;\n \n       Is_Tagged : Boolean;\n       Tag_Comp  : Entity_Id;\n \n-   begin\n-      --  The flag Is_Tagged_Type might have already been set by Find_Type_Name\n-      --  if it detected an error for declaration T. This arises in the case of\n-      --  private tagged types where the full view omits the word tagged.\n+      procedure Check_Anonymous_Access_Types (Comp_List : Node_Id);\n+      --  Ada 2005 AI-382: an access component in a record declaration can\n+      --  refer to the enclosing record, in which case it denotes the type\n+      --  itself, and not the current instance of the type. We create an\n+      --  anonymous access type for the component, and flag it as an access\n+      --  to a component, so that accessibility checks are properly performed\n+      --  on it. The declaration of the access type is placed ahead of that\n+      --  of the record, to prevent circular order-of-elaboration issues in\n+      --  gigi. We create an incomplete type for the record declaration, which\n+      --  is the designated type of the anonymous access.\n+\n+      procedure Make_Incomplete_Type_Declaration;\n+      --  If the record type contains components that include an access to the\n+      --  current record, create an incomplete type declaration for the record,\n+      --  to be used as the designated type of the anonymous access. This is\n+      --  done only once, and only if there is no previous partial view of the\n+      --  type.\n \n-      Is_Tagged :=\n-        Tagged_Present (Def)\n-          or else (Serious_Errors_Detected > 0 and then Is_Tagged_Type (T));\n+      ----------------------------------\n+      -- Check_Anonymous_Access_Types --\n+      ----------------------------------\n \n-      --  Records constitute a scope for the component declarations within.\n-      --  The scope is created prior to the processing of these declarations.\n-      --  Discriminants are processed first, so that they are visible when\n-      --  processing the other components. The Ekind of the record type itself\n-      --  is set to E_Record_Type (subtypes appear as E_Record_Subtype).\n+      procedure Check_Anonymous_Access_Types (Comp_List : Node_Id) is\n+         Anon_Access : Entity_Id;\n+         Acc_Def     : Node_Id;\n+         Comp        : Node_Id;\n+         Decl        : Node_Id;\n+         Type_Def    : Node_Id;\n \n-      --  Enter record scope\n+         function Mentions_T (Acc_Def : Node_Id) return Boolean;\n+         --  Check whether an access definition includes a reference to\n+         --  the enclosing record type. The reference can be a subtype\n+         --  mark in the access definition itself, or a 'Class attribute\n+         --  reference, or recursively a reference appearing in a parameter\n+         --  type in an access_to_subprogram definition.\n \n-      New_Scope (T);\n+         ----------------\n+         -- Mentions_T --\n+         ----------------\n+\n+         function Mentions_T (Acc_Def : Node_Id) return Boolean is\n+            Subt : Node_Id;\n+\n+         begin\n+            if No (Access_To_Subprogram_Definition (Acc_Def)) then\n+               Subt := Subtype_Mark (Acc_Def);\n+\n+               if Nkind (Subt) = N_Identifier then\n+                  return Chars (Subt) = Chars (T);\n+               elsif Nkind (Subt) = N_Attribute_Reference\n+                  and then Attribute_Name (Subt) = Name_Class\n+               then\n+                  return (Chars (Prefix (Subt))) = Chars (T);\n+               else\n+                  return False;\n+               end if;\n+\n+            else\n+               --  Component is an access_to_subprogram: examine its formals\n+\n+               declare\n+                  Param_Spec : Node_Id;\n+\n+               begin\n+                  Param_Spec :=\n+                    First\n+                      (Parameter_Specifications\n+                        (Access_To_Subprogram_Definition (Acc_Def)));\n+                  while Present (Param_Spec) loop\n+                     if Nkind (Parameter_Type (Param_Spec))\n+                          = N_Access_Definition\n+                       and then Mentions_T (Parameter_Type (Param_Spec))\n+                     then\n+                        return True;\n+                     end if;\n+\n+                     Next (Param_Spec);\n+                  end loop;\n+\n+                  return False;\n+               end;\n+            end if;\n+         end Mentions_T;\n+\n+      --  Start of processing for Check_Anonymous_Access_Types\n+\n+      begin\n+         if No (Comp_List) then\n+            return;\n+         end if;\n+\n+         Comp := First (Component_Items (Comp_List));\n+         while Present (Comp) loop\n+            if Nkind (Comp) = N_Component_Declaration\n+              and then\n+                Present (Access_Definition (Component_Definition (Comp)))\n+              and then\n+                Mentions_T (Access_Definition (Component_Definition (Comp)))\n+            then\n+               Acc_Def :=\n+                 Access_To_Subprogram_Definition\n+                   (Access_Definition (Component_Definition (Comp)));\n+\n+               Make_Incomplete_Type_Declaration;\n+               Anon_Access :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_Internal_Name ('S'));\n+\n+               --  Create a declaration for the anonymous access type: either\n+               --  an access_to_object or an access_to_subprogram.\n+\n+               if Present (Acc_Def) then\n+                  if Nkind  (Acc_Def) = N_Access_Function_Definition then\n+                     Type_Def :=\n+                       Make_Access_Function_Definition (Loc,\n+                         Parameter_Specifications =>\n+                           Parameter_Specifications (Acc_Def),\n+                         Subtype_Mark => Subtype_Mark (Acc_Def));\n+                  else\n+                     Type_Def :=\n+                       Make_Access_Procedure_Definition (Loc,\n+                         Parameter_Specifications =>\n+                           Parameter_Specifications (Acc_Def));\n+                  end if;\n+\n+               else\n+                  Type_Def :=\n+                    Make_Access_To_Object_Definition (Loc,\n+                      Subtype_Indication =>\n+                         Relocate_Node\n+                           (Subtype_Mark\n+                             (Access_Definition\n+                               (Component_Definition (Comp)))));\n+               end if;\n+\n+               Decl := Make_Full_Type_Declaration (Loc,\n+                  Defining_Identifier => Anon_Access,\n+                  Type_Definition => Type_Def);\n+\n+               Insert_Before (N, Decl);\n+               Analyze (Decl);\n+\n+               Set_Access_Definition (Component_Definition (Comp), Empty);\n+               Set_Subtype_Indication (Component_Definition (Comp),\n+                  New_Occurrence_Of (Anon_Access, Loc));\n+               Set_Ekind (Anon_Access, E_Anonymous_Access_Type);\n+               Set_Is_Local_Anonymous_Access (Anon_Access);\n+            end if;\n+\n+            Next (Comp);\n+         end loop;\n+\n+         if Present (Variant_Part (Comp_List)) then\n+            declare\n+               V : Node_Id;\n+            begin\n+               V := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n+               while Present (V) loop\n+                  Check_Anonymous_Access_Types (Component_List (V));\n+                  Next_Non_Pragma (V);\n+               end loop;\n+            end;\n+         end if;\n+      end Check_Anonymous_Access_Types;\n \n+      --------------------------------------\n+      -- Make_Incomplete_Type_Declaration --\n+      --------------------------------------\n+\n+      procedure Make_Incomplete_Type_Declaration is\n+         Decl : Node_Id;\n+         H    : Entity_Id;\n+\n+      begin\n+         --  If there is a previous partial view, no need to create a new one.\n+\n+         if Prev /= T then\n+            return;\n+\n+         elsif No (Inc_T) then\n+            Inc_T  := Make_Defining_Identifier (Loc, Chars (T));\n+            Decl   := Make_Incomplete_Type_Declaration (Loc, Inc_T);\n+\n+            --  Type has already been inserted into the current scope.\n+            --  Remove it, and add incomplete declaration for type, so\n+            --  that subsequent anonymous access types can use it.\n+\n+            H := Current_Entity (T);\n+\n+            if H = T then\n+               Set_Name_Entity_Id (Chars (T), Empty);\n+            else\n+               while Present (H)\n+                 and then Homonym (H) /= T\n+               loop\n+                  H := Homonym (T);\n+               end loop;\n+\n+               Set_Homonym (H, Homonym (T));\n+            end if;\n+\n+            Insert_Before (N, Decl);\n+            Analyze (Decl);\n+            Set_Full_View (Inc_T, T);\n+\n+            if Tagged_Present (Def) then\n+               Make_Class_Wide_Type (Inc_T);\n+               Set_Class_Wide_Type (T, Class_Wide_Type (Inc_T));\n+            end if;\n+         end if;\n+      end Make_Incomplete_Type_Declaration;\n+\n+   --  Start of processing for Record_Type_Declaration\n+\n+   begin\n       --  These flags must be initialized before calling Process_Discriminants\n       --  because this routine makes use of them.\n \n-      Set_Is_Tagged_Type     (T, Is_Tagged);\n-      Set_Is_Limited_Record  (T, Limited_Present (Def));\n+      Set_Ekind               (T, E_Record_Type);\n+      Set_Etype               (T, T);\n+      Init_Size_Align         (T);\n+      Set_Abstract_Interfaces (T, No_Elist);\n+      Set_Stored_Constraint   (T, No_Elist);\n \n-      --  Type is abstract if full declaration carries keyword, or if\n-      --  previous partial view did.\n+      --  Normal case\n \n-      Set_Is_Abstract (T, Is_Abstract (T) or else Abstract_Present (Def));\n+      if Ada_Version < Ada_05\n+        or else not Interface_Present (Def)\n+      then\n+         --  The flag Is_Tagged_Type might have already been set by\n+         --  Find_Type_Name if it detected an error for declaration T. This\n+         --  arises in the case of private tagged types where the full view\n+         --  omits the word tagged.\n \n-      Set_Ekind       (T, E_Record_Type);\n-      Set_Etype       (T, T);\n-      Init_Size_Align (T);\n+         Is_Tagged :=\n+           Tagged_Present (Def)\n+             or else (Serious_Errors_Detected > 0 and then Is_Tagged_Type (T));\n \n-      Set_Stored_Constraint (T, No_Elist);\n+         Set_Is_Tagged_Type      (T, Is_Tagged);\n+         Set_Is_Limited_Record   (T, Limited_Present (Def));\n+\n+         --  Type is abstract if full declaration carries keyword, or if\n+         --  previous partial view did.\n+\n+         Set_Is_Abstract         (T, Is_Abstract (T)\n+                                      or else Abstract_Present (Def));\n+\n+      else\n+         Is_Tagged := True;\n+         Set_Is_Tagged_Type      (T);\n+\n+         Set_Is_Limited_Record   (T, Limited_Present (Def)\n+                                      or else Task_Present (Def)\n+                                      or else Protected_Present (Def));\n+\n+         --  Type is abstract if full declaration carries keyword, or if\n+         --  previous partial view did.\n+\n+         Set_Is_Abstract  (T);\n+         Set_Is_Interface (T);\n+      end if;\n+\n+      --  First pass: if there are self-referential access components,\n+      --  create the required anonymous access type declarations, and if\n+      --  need be an incomplete type declaration for T itself.\n+\n+      Check_Anonymous_Access_Types (Component_List (Def));\n+\n+      --  Ada 2005 (AI-251): Complete the initialization of attributes\n+      --  associated with abstract interfaces and decorate the names in the\n+      --  list of ancestor interfaces (if any).\n+\n+      if Ada_Version >= Ada_05\n+        and then Present (Interface_List (Def))\n+      then\n+         declare\n+            Iface     : Node_Id;\n+            Iface_Def : Node_Id;\n+            Iface_Typ : Entity_Id;\n+         begin\n+            Iface := First (Interface_List (Def));\n+\n+            while Present (Iface) loop\n+               Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n+               Iface_Def := Type_Definition (Parent (Iface_Typ));\n+\n+               if not Is_Interface (Iface_Typ) then\n+                  Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                                Iface, Iface_Typ);\n+\n+               else\n+                  --  \"The declaration of a specific descendant of an\n+                  --  interface type freezes the interface type\" RM 13.14\n+\n+                  Freeze_Before (N, Iface_Typ);\n+\n+                  --  Ada 2005 (AI-345): Protected interfaces can only\n+                  --  inherit from limited, synchronized or protected\n+                  --  interfaces.\n+\n+                  if Protected_Present (Def) then\n+                     if Limited_Present (Iface_Def)\n+                       or else Synchronized_Present (Iface_Def)\n+                       or else Protected_Present (Iface_Def)\n+                     then\n+                        null;\n+\n+                     elsif Task_Present (Iface_Def) then\n+                        Error_Msg_N (\"(Ada 2005) protected interface cannot\"\n+                          & \" inherit from task interface\", Iface);\n+\n+                     else\n+                        Error_Msg_N (\"(Ada 2005) protected interface cannot\"\n+                          & \" inherit from non-limited interface\", Iface);\n+                     end if;\n+\n+                  --  Ada 2005 (AI-345): Synchronized interfaces can only\n+                  --  inherit from limited and synchronized.\n+\n+                  elsif Synchronized_Present (Def) then\n+                     if Limited_Present (Iface_Def)\n+                       or else Synchronized_Present (Iface_Def)\n+                     then\n+                        null;\n+\n+                     elsif Protected_Present (Iface_Def) then\n+                        Error_Msg_N (\"(Ada 2005) synchronized interface \" &\n+                          \"cannot inherit from protected interface\", Iface);\n+\n+                     elsif Task_Present (Iface_Def) then\n+                        Error_Msg_N (\"(Ada 2005) synchronized interface \" &\n+                          \"cannot inherit from task interface\", Iface);\n+\n+                     else\n+                        Error_Msg_N (\"(Ada 2005) synchronized interface \" &\n+                          \"cannot inherit from non-limited interface\",\n+                          Iface);\n+                     end if;\n+\n+                  --  Ada 2005 (AI-345): Task interfaces can only inherit\n+                  --  from limited, synchronized or task interfaces.\n+\n+                  elsif Task_Present (Def) then\n+                     if Limited_Present (Iface_Def)\n+                       or else Synchronized_Present (Iface_Def)\n+                       or else Task_Present (Iface_Def)\n+                     then\n+                        null;\n+\n+                     elsif Protected_Present (Iface_Def) then\n+                        Error_Msg_N (\"(Ada 2005) task interface cannot\" &\n+                          \" inherit from protected interface\", Iface);\n+\n+                     else\n+                        Error_Msg_N (\"(Ada 2005) task interface cannot\" &\n+                          \" inherit from non-limited interface\", Iface);\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               Next (Iface);\n+            end loop;\n+\n+            Set_Abstract_Interfaces (T, New_Elmt_List);\n+            Collect_Interfaces (Type_Definition (N), T);\n+         end;\n+      end if;\n+\n+      --  Records constitute a scope for the component declarations within.\n+      --  The scope is created prior to the processing of these declarations.\n+      --  Discriminants are processed first, so that they are visible when\n+      --  processing the other components. The Ekind of the record type itself\n+      --  is set to E_Record_Type (subtypes appear as E_Record_Subtype).\n+\n+      --  Enter record scope\n+\n+      New_Scope (T);\n \n       --  If an incomplete or private type declaration was already given for\n       --  the type, then this scope already exists, and the discriminants have\n@@ -12912,11 +14346,17 @@ package body Sem_Ch3 is\n             Enter_Name (Tag_Comp);\n \n             Set_Is_Tag                    (Tag_Comp);\n+            Set_Is_Aliased                (Tag_Comp);\n             Set_Ekind                     (Tag_Comp, E_Component);\n             Set_Etype                     (Tag_Comp, RTE (RE_Tag));\n             Set_DT_Entry_Count            (Tag_Comp, No_Uint);\n             Set_Original_Record_Component (Tag_Comp, Tag_Comp);\n             Init_Component_Location       (Tag_Comp);\n+\n+            --  Ada 2005 (AI-251): Addition of the Tag corresponding to all the\n+            --  implemented interfaces\n+\n+            Add_Interface_Tag_Components (N, T);\n          end if;\n \n          Make_Class_Wide_Type (T);\n@@ -12940,6 +14380,17 @@ package body Sem_Ch3 is\n       --  Exit from record scope\n \n       End_Scope;\n+\n+      if Expander_Active\n+        and then Is_Tagged\n+        and then not Is_Empty_List (Interface_List (Def))\n+      then\n+         --  Ada 2005 (AI-251): Derive the interface subprograms of all the\n+         --  implemented interfaces and check if some of the subprograms\n+         --  inherited from the ancestor cover some interface subprogram.\n+\n+         Derive_Interface_Subprograms (T);\n+      end if;\n    end Record_Type_Declaration;\n \n    ----------------------------"}, {"sha": "1cf52cbfa58a8a1319413d8d1d6f22821335bdd5", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -390,7 +390,8 @@ package body Sem_Ch4 is\n \n       else\n          declare\n-            Def_Id : Entity_Id;\n+            Def_Id   : Entity_Id;\n+            Base_Typ : Entity_Id;\n \n          begin\n             --  If the allocator includes a N_Subtype_Indication then a\n@@ -410,10 +411,11 @@ package body Sem_Ch4 is\n                --  access-to-composite type, but the constraint is ignored.\n \n                Find_Type (Subtype_Mark (E));\n+               Base_Typ := Entity (Subtype_Mark (E));\n \n-               if Is_Elementary_Type (Entity (Subtype_Mark (E))) then\n+               if Is_Elementary_Type (Base_Typ) then\n                   if not (Ada_Version = Ada_83\n-                           and then Is_Access_Type (Entity (Subtype_Mark (E))))\n+                           and then Is_Access_Type (Base_Typ))\n                   then\n                      Error_Msg_N (\"constraint not allowed here\", E);\n \n@@ -431,6 +433,17 @@ package body Sem_Ch4 is\n                   Rewrite (E, New_Copy_Tree (Subtype_Mark (E)));\n                   Analyze_Allocator (N);\n                   return;\n+\n+               --  Ada 2005, AI-363: if the designated type has a constrained\n+               --  partial view, it cannot receive a discriminant constraint,\n+               --  and the allocated object is unconstrained.\n+\n+               elsif Ada_Version >= Ada_05\n+                 and then Has_Constrained_Partial_View (Base_Typ)\n+               then\n+                  Error_Msg_N\n+                    (\"constraint no allowed when type \" &\n+                      \"has a constrained partial view\", Constraint (E));\n                end if;\n \n                if Expander_Active then\n@@ -670,9 +683,18 @@ package body Sem_Ch4 is\n          if Ekind (Etype (Nam)) = E_Subprogram_Type then\n             Nam_Ent := Etype (Nam);\n \n+         --  If the prefix is an access_to_subprogram, this may be an indirect\n+         --  call. This is the case if the name in the call is not an entity\n+         --  name, or if it is a function name in the context of a procedure\n+         --  call. In this latter case, we have a call to a parameterless\n+         --  function that returns a pointer_to_procedure which is the entity\n+         --  being called.\n+\n          elsif Is_Access_Type (Etype (Nam))\n            and then Ekind (Designated_Type (Etype (Nam))) = E_Subprogram_Type\n-           and then not Name_Denotes_Function\n+           and then\n+             (not Name_Denotes_Function\n+                or else Nkind (N) = N_Procedure_Call_Statement)\n          then\n             Nam_Ent := Designated_Type (Etype (Nam));\n             Insert_Explicit_Dereference (Nam);\n@@ -1969,6 +1991,9 @@ package body Sem_Ch4 is\n             Is_Indexed :=\n               Try_Indexed_Call (N, Nam, Designated_Type (Subp_Type));\n \n+         --  The prefix can also be a parameterless function that returns an\n+         --  access to subprogram. in which case this is an indirect call.\n+\n          elsif Is_Access_Type (Subp_Type)\n            and then Ekind (Designated_Type (Subp_Type))  = E_Subprogram_Type\n          then\n@@ -2099,6 +2124,23 @@ package body Sem_Ch4 is\n                   end if;\n \n                   if Report and not Is_Indexed then\n+\n+                     --  Ada 2005 (AI-251): Complete the error notification\n+                     --  to help new Ada 2005 users\n+\n+                     if Is_Class_Wide_Type (Etype (Formal))\n+                       and then Is_Interface (Etype (Etype (Formal)))\n+                       and then not Interface_Present_In_Ancestor\n+                                      (Typ   => Etype (Actual),\n+                                       Iface => Etype (Etype (Formal)))\n+                     then\n+                        Error_Msg_Name_1 := Chars (Actual);\n+                        Error_Msg_Name_2 := Chars (Etype (Etype (Formal)));\n+                        Error_Msg_NE\n+                          (\"(Ada 2005) % does not implement interface %\",\n+                           Actual, Etype (Etype (Formal)));\n+                     end if;\n+\n                      Wrong_Type (Actual, Etype (Formal));\n \n                      if Nkind (Actual) = N_Op_Eq\n@@ -4892,6 +4934,30 @@ package body Sem_Ch4 is\n \n             end if;\n \n+         --  Before analysis, the function call appears as an\n+         --  indexed component.\n+\n+         elsif Nkind (Parent_Node) =  N_Indexed_Component then\n+            Node_To_Replace := Parent_Node;\n+\n+            declare\n+               Actual : Node_Id;\n+               New_Act : Node_Id;\n+            begin\n+               Actual := First (Expressions (Parent_Node));\n+               while Present (Actual) loop\n+                  New_Act := New_Copy_Tree (Actual);\n+                  Analyze (New_Act);\n+                  Append (New_Act, Actuals);\n+                  Next (Actual);\n+               end loop;\n+            end;\n+\n+            Call_Node :=\n+               Make_Function_Call (Loc,\n+                 Name => New_Copy_Tree (Subprog),\n+                 Parameter_Associations => Actuals);\n+\n          --  Parameterless call\n \n          else\n@@ -4901,7 +4967,6 @@ package body Sem_Ch4 is\n                Make_Function_Call (Loc,\n                  Name => New_Copy_Tree (Subprog),\n                  Parameter_Associations => Actuals);\n-\n          end if;\n       end Transform_Object_Operation;\n "}, {"sha": "b3bb22275c4fdd5048450ccc5fe72b167f32bf97", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 299, "deletions": 104, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -122,13 +122,14 @@ package body Sem_Ch6 is\n    --  against a formal access-to-subprogram type so Get_Instance_Of must\n    --  be called.\n \n-   procedure Check_Overriding_Operation\n-     (N    : Node_Id;\n-      Subp : Entity_Id);\n-   --  Check that a subprogram with a pragma Overriding or Optional_Overriding\n-   --  is legal. This check is performed here rather than in Sem_Prag because\n-   --  the pragma must follow immediately the declaration, and can be treated\n-   --  as part of the declaration itself, as described in AI-218.\n+   procedure Check_Overriding_Indicator\n+     (Subp          : Entity_Id;\n+      Does_Override : Boolean);\n+   --  Verify the consistency of an overriding_indicator given for subprogram\n+   --  declaration, body, renaming, or instantiation. The flag Does_Override\n+   --  is set if the scope into which we are introducing the subprogram\n+   --  contains a type-conformant subprogram that becomes hidden by the new\n+   --  subprogram.\n \n    procedure Check_Subprogram_Order (N : Node_Id);\n    --  N is the N_Subprogram_Body node for a subprogram. This routine applies\n@@ -514,6 +515,14 @@ package body Sem_Ch6 is\n \n       Analyze (P);\n \n+      --  If this is a call of the form Obj.Op, the call may have been\n+      --  analyzed and possibly rewritten into a block, in which case\n+      --  we are done.\n+\n+      if Analyzed (N) then\n+         return;\n+      end if;\n+\n       --  If error analyzing prefix, then set Any_Type as result and return\n \n       if Etype (P) = Any_Type then\n@@ -678,7 +687,7 @@ package body Sem_Ch6 is\n       --  Anything else is an error\n \n       else\n-         Error_Msg_N (\"Invalid procedure or entry call\", N);\n+         Error_Msg_N (\"invalid procedure or entry call\", N);\n       end if;\n    end Analyze_Procedure_Call;\n \n@@ -836,6 +845,16 @@ package body Sem_Ch6 is\n       --  If front-end inlining is enabled, look ahead to recognize a pragma\n       --  that may appear after the body.\n \n+      procedure Verify_Overriding_Indicator;\n+      --  If there was a previous spec, the entity has been entered in the\n+      --  current scope previously. If the body itself carries an overriding\n+      --  indicator, check that it is consistent with the known status of the\n+      --  entity.\n+\n+      ----------------------------\n+      -- Check_Following_Pragma --\n+      ----------------------------\n+\n       procedure Check_Following_Pragma is\n          Prag : Node_Id;\n \n@@ -860,6 +879,27 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Following_Pragma;\n \n+      ---------------------------------\n+      -- Verify_Overriding_Indicator --\n+      ---------------------------------\n+\n+      procedure Verify_Overriding_Indicator is\n+      begin\n+         if Must_Override (Body_Spec)\n+           and then not Is_Overriding_Operation (Spec_Id)\n+         then\n+            Error_Msg_NE\n+              (\"subprogram& is not overriding\", Body_Spec, Spec_Id);\n+\n+         elsif Must_Not_Override (Body_Spec)\n+              and then Is_Overriding_Operation (Spec_Id)\n+         then\n+            Error_Msg_NE\n+              (\"subprogram& overrides inherited operation\",\n+                 Body_Spec, Spec_Id);\n+         end if;\n+      end Verify_Overriding_Indicator;\n+\n    --  Start of processing for Analyze_Subprogram_Body\n \n    begin\n@@ -1065,13 +1105,19 @@ package body Sem_Ch6 is\n \n       elsif Present (Spec_Id) then\n          Spec_Decl := Unit_Declaration_Node (Spec_Id);\n+         Verify_Overriding_Indicator;\n       end if;\n \n       --  Place subprogram on scope stack, and make formals visible. If there\n       --  is a spec, the visible entity remains that of the spec.\n \n       if Present (Spec_Id) then\n          Generate_Reference (Spec_Id, Body_Id, 'b', Set_Ref => False);\n+\n+         if Is_Child_Unit (Spec_Id) then\n+            Generate_Reference (Spec_Id, Scope (Spec_Id), 'k', False);\n+         end if;\n+\n          if Style_Check then\n             Style.Check_Identifier (Body_Id, Spec_Id);\n          end if;\n@@ -1136,6 +1182,27 @@ package body Sem_Ch6 is\n \n          if Nkind (N) /= N_Subprogram_Body_Stub then\n             Set_Corresponding_Spec (N, Spec_Id);\n+\n+            --  Ada 2005 (AI-345): Restore the correct Etype: here we undo the\n+            --  work done by Analyze_Subprogram_Specification to allow the\n+            --  overriding of task, protected and interface primitives.\n+\n+            if Comes_From_Source (Spec_Id)\n+              and then Present (First_Entity (Spec_Id))\n+              and then Ekind (Etype (First_Entity (Spec_Id))) = E_Record_Type\n+              and then Is_Tagged_Type (Etype (First_Entity (Spec_Id)))\n+              and then Present (Abstract_Interfaces\n+                                (Etype (First_Entity (Spec_Id))))\n+              and then Present (Corresponding_Concurrent_Type\n+                                (Etype (First_Entity (Spec_Id))))\n+            then\n+               Set_Etype (First_Entity (Spec_Id),\n+                 Corresponding_Concurrent_Type\n+                   (Etype (First_Entity (Spec_Id))));\n+            end if;\n+\n+            --  Comment needed here, since this is not Ada 2005 stuff! ???\n+\n             Install_Formals (Spec_Id);\n             Last_Formal := Last_Entity (Spec_Id);\n             New_Scope (Spec_Id);\n@@ -1500,15 +1567,27 @@ package body Sem_Ch6 is\n \n       if Nkind (Parent (N)) = N_Compilation_Unit then\n          Set_Body_Required (Parent (N), True);\n+\n+         if Ada_Version >= Ada_05\n+           and then Nkind (Specification (N)) = N_Procedure_Specification\n+           and then Null_Present (Specification (N))\n+         then\n+            Error_Msg_N\n+              (\"null procedure cannot be declared at library level\", N);\n+         end if;\n       end if;\n \n       Generate_Reference_To_Formals (Designator);\n       Check_Eliminated (Designator);\n \n-      if Comes_From_Source (N)\n-        and then Is_List_Member (N)\n+      --  Ada 2005: if procedure is declared with \"is null\" qualifier,\n+      --  it requires no body.\n+\n+      if Nkind (Specification (N)) = N_Procedure_Specification\n+        and then Null_Present (Specification (N))\n       then\n-         Check_Overriding_Operation (N, Designator);\n+         Set_Has_Completion (Designator);\n+         Set_Is_Inlined (Designator);\n       end if;\n    end Analyze_Subprogram_Declaration;\n \n@@ -1524,6 +1603,39 @@ package body Sem_Ch6 is\n       Designator : constant Entity_Id := Defining_Entity (N);\n       Formals    : constant List_Id   := Parameter_Specifications (N);\n \n+      function Has_Interface_Formals (T : List_Id) return Boolean;\n+      --  Ada 2005 (AI-251): Returns true if some non class-wide interface\n+      --  formal is found.\n+\n+      ---------------------------\n+      -- Has_Interface_Formals --\n+      ---------------------------\n+\n+      function Has_Interface_Formals (T : List_Id) return Boolean is\n+         Param_Spec : Node_Id;\n+         Formal     : Entity_Id;\n+\n+      begin\n+         Param_Spec := First (T);\n+\n+         while Present (Param_Spec) loop\n+            Formal := Defining_Identifier (Param_Spec);\n+\n+            if Is_Class_Wide_Type (Etype (Formal)) then\n+               null;\n+\n+            elsif Is_Interface (Etype (Formal)) then\n+               return True;\n+            end if;\n+\n+            Next (Param_Spec);\n+         end loop;\n+\n+         return False;\n+      end Has_Interface_Formals;\n+\n+   --  Start of processing for Analyze_Subprogram_Specification\n+\n    begin\n       Generate_Definition (Designator);\n \n@@ -1544,6 +1656,30 @@ package body Sem_Ch6 is\n       if Present (Formals) then\n          New_Scope (Designator);\n          Process_Formals (Formals, N);\n+\n+         --  Ada 2005 (AI-345): Allow overriding primitives of protected\n+         --  interfaces by means of normal subprograms. For this purpose\n+         --  temporarily use the corresponding record type as the etype\n+         --  of the first formal.\n+\n+         if Ada_Version >= Ada_05\n+           and then Comes_From_Source (Designator)\n+           and then Present (First_Entity (Designator))\n+           and then (Ekind (Etype (First_Entity (Designator)))\n+                             = E_Protected_Type\n+                       or else\n+                     Ekind (Etype (First_Entity (Designator)))\n+                             = E_Task_Type)\n+           and then Present (Corresponding_Record_Type\n+                             (Etype (First_Entity (Designator))))\n+           and then Present (Abstract_Interfaces\n+                             (Corresponding_Record_Type\n+                             (Etype (First_Entity (Designator)))))\n+         then\n+            Set_Etype (First_Entity (Designator),\n+              Corresponding_Record_Type (Etype (First_Entity (Designator))));\n+         end if;\n+\n          End_Scope;\n \n       elsif Nkind (N) = N_Function_Specification then\n@@ -1571,6 +1707,20 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n+      if Ada_Version >= Ada_05\n+        and then Comes_From_Source (N)\n+        and then Nkind (Parent (N)) /= N_Abstract_Subprogram_Declaration\n+        and then (Nkind (N) /= N_Procedure_Specification\n+                    or else\n+                  not Null_Present (N))\n+        and then Has_Interface_Formals (Formals)\n+      then\n+         Error_Msg_Name_1 := Chars (Defining_Unit_Name\n+                                    (Specification (Parent (N))));\n+         Error_Msg_N\n+           (\"(Ada 2005) interface subprogram % must be abstract or null\", N);\n+      end if;\n+\n       return Designator;\n    end Analyze_Subprogram_Specification;\n \n@@ -1638,7 +1788,8 @@ package body Sem_Ch6 is\n             then\n                Conv := Current_Entity (Id);\n \n-            elsif Nkind (Id) = N_Selected_Component\n+            elsif (Nkind (Id) = N_Selected_Component\n+                    or else Nkind (Id) = N_Expanded_Name)\n               and then Chars (Selector_Name (Id)) = Name_Unchecked_Conversion\n             then\n                Conv := Current_Entity (Selector_Name (Id));\n@@ -1647,9 +1798,9 @@ package body Sem_Ch6 is\n                return False;\n             end if;\n \n-            return\n-              Present (Conv)\n-              and then Scope (Conv) = Standard_Standard\n+            return Present (Conv)\n+              and then Is_Predefined_File_Name\n+                         (Unit_File_Name (Get_Source_Unit (Conv)))\n               and then Is_Intrinsic_Subprogram (Conv);\n          end Is_Unchecked_Conversion;\n \n@@ -2572,100 +2723,49 @@ package body Sem_Ch6 is\n    end Check_Mode_Conformant;\n \n    --------------------------------\n-   -- Check_Overriding_Operation --\n+   -- Check_Overriding_Indicator --\n    --------------------------------\n \n-   procedure Check_Overriding_Operation\n-     (N    : Node_Id;\n-      Subp : Entity_Id)\n+   procedure Check_Overriding_Indicator\n+     (Subp          : Entity_Id;\n+      Does_Override : Boolean)\n    is\n-      Arg1       : Node_Id;\n-      Decl       : Node_Id;\n-      Has_Pragma : Boolean := False;\n+      Decl : Node_Id;\n+      Spec : Node_Id;\n \n    begin\n-      --  See whether there is an overriding pragma immediately following\n-      --  the declaration. Intervening pragmas, such as Inline, are allowed.\n-\n-      Decl := Next (N);\n-      while Present (Decl)\n-        and then Nkind (Decl) = N_Pragma\n-      loop\n-         if Chars (Decl) = Name_Overriding\n-           or else Chars (Decl) = Name_Optional_Overriding\n-         then\n-            --  For now disable the use of these pragmas, until the ARG\n-            --  finalizes the design of this feature.\n-\n-            Error_Msg_N (\"?unrecognized pragma\", Decl);\n-\n-            if not Is_Overriding_Operation (Subp) then\n-\n-               --  Before emitting an error message, check whether this\n-               --  may override an operation that is not yet visible, as\n-               --  in the case of a derivation of a private operation in\n-               --  a child unit. Such an operation is introduced with a\n-               --  different name, but its alias is the parent operation.\n-\n-               declare\n-                  E : Entity_Id;\n-\n-               begin\n-                  E := First_Entity (Current_Scope);\n-\n-                  while Present (E) loop\n-                     if Ekind (E) = Ekind (Subp)\n-                       and then not Comes_From_Source (E)\n-                       and then Present (Alias (E))\n-                       and then Chars (Alias (E)) = Chars (Subp)\n-                       and then In_Open_Scopes (Scope (Alias (E)))\n-                     then\n-                        exit;\n-                     else\n-                        Next_Entity (E);\n-                     end if;\n-                  end loop;\n-\n-                  if No (E) then\n-                     Error_Msg_NE\n-                       (\"& must override an inherited operation\",\n-                         Decl, Subp);\n-                  end if;\n-               end;\n-            end if;\n+      if Ekind (Subp) = E_Enumeration_Literal then\n \n-            --  Verify syntax of pragma\n+         --  No overriding indicator for literals\n \n-            Arg1 := First (Pragma_Argument_Associations (Decl));\n-\n-            if Present (Arg1) then\n-               if not Is_Entity_Name (Expression (Arg1)) then\n-                  Error_Msg_N (\"pragma applies to local subprogram\", Decl);\n+         return;\n \n-               elsif Chars (Expression (Arg1)) /= Chars (Subp) then\n-                  Error_Msg_N\n-                    (\"pragma must apply to preceding subprogram\", Decl);\n+      else\n+         Decl := Unit_Declaration_Node (Subp);\n+      end if;\n \n-               elsif Present (Next (Arg1)) then\n-                  Error_Msg_N (\"illegal pragma format\", Decl);\n-               end if;\n-            end if;\n+      if Nkind (Decl) = N_Subprogram_Declaration\n+        or else Nkind (Decl) = N_Subprogram_Body\n+        or else Nkind (Decl) = N_Subprogram_Renaming_Declaration\n+        or else Nkind (Decl) = N_Subprogram_Body_Stub\n+      then\n+         Spec := Specification (Decl);\n+      else\n+         return;\n+      end if;\n \n-            Set_Analyzed (Decl);\n-            Has_Pragma := True;\n-            exit;\n+      if not Does_Override then\n+         if Must_Override (Spec) then\n+            Error_Msg_NE (\"subprogram& is not overriding\", Spec, Subp);\n          end if;\n \n-         Next (Decl);\n-      end loop;\n-\n-      if not Has_Pragma\n-        and then Explicit_Overriding\n-        and then Is_Overriding_Operation (Subp)\n-      then\n-         Error_Msg_NE (\"Missing overriding pragma for&\", Subp, Subp);\n+      else\n+         if Must_Not_Override (Spec) then\n+            Error_Msg_NE\n+              (\"subprogram& overrides inherited operation\", Spec, Subp);\n+         end if;\n       end if;\n-   end Check_Overriding_Operation;\n+   end Check_Overriding_Indicator;\n \n    -------------------\n    -- Check_Returns --\n@@ -3142,6 +3242,8 @@ package body Sem_Ch6 is\n          end if;\n       end Base_Types_Match;\n \n+      --  Start of processing for Conforming_Types\n+\n    begin\n       --  The context is an instance association for a formal\n       --  access-to-subprogram type; the formal parameter types require\n@@ -3182,7 +3284,8 @@ package body Sem_Ch6 is\n            or else Subtypes_Statically_Match (Type_1, Full_View (Type_2));\n       end if;\n \n-      --  Ada 2005 (AI-254): Detect anonymous access to subprogram types\n+      --  Ada 2005 (AI-254): Anonymous access to subprogram types must be\n+      --  treated recursively because they carry a signature.\n \n       Are_Anonymous_Access_To_Subprogram_Types :=\n \n@@ -3264,10 +3367,23 @@ package body Sem_Ch6 is\n                     Etype (Base_Type (Desig_2)), Ctype);\n \n             elsif Are_Anonymous_Access_To_Subprogram_Types then\n-               return Ctype = Type_Conformant\n-                        or else\n+               if Ada_Version < Ada_05 then\n+                  return Ctype = Type_Conformant\n+                    or else\n                       Subtypes_Statically_Match (Desig_1, Desig_2);\n \n+               --  We must check the conformance of the signatures themselves\n+\n+               else\n+                  declare\n+                     Conformant : Boolean;\n+                  begin\n+                     Check_Conformance\n+                       (Desig_1, Desig_2, Ctype, False, Conformant);\n+                     return Conformant;\n+                  end;\n+               end if;\n+\n             else\n                return Base_Type (Desig_1) = Base_Type (Desig_2)\n                 and then (Ctype = Type_Conformant\n@@ -4438,12 +4554,18 @@ package body Sem_Ch6 is\n      (S            : Entity_Id;\n       Derived_Type : Entity_Id := Empty)\n    is\n+      Does_Override : Boolean := False;\n+      --  Set if the current scope has an operation that is type-conformant\n+      --  with S, and becomes hidden by S.\n+\n       E : Entity_Id;\n       --  Entity that S overrides\n \n       Prev_Vis : Entity_Id := Empty;\n       --  Needs comment ???\n \n+      Is_Alias_Interface : Boolean := False;\n+\n       function Is_Private_Declaration (E : Entity_Id) return Boolean;\n       --  Check that E is declared in the private part of the current package,\n       --  or in the package body, where it may hide a previous declaration.\n@@ -4522,8 +4644,17 @@ package body Sem_Ch6 is\n                  and then Is_Abstract (S)\n                  and then (not Is_Overriding or else not Is_Abstract (E))\n                then\n-                  Error_Msg_N (\"abstract subprograms must be visible \"\n-                                & \"('R'M 3.9.3(10))!\", S);\n+                  if not Is_Interface (T) then\n+                     Error_Msg_N (\"abstract subprograms must be visible \"\n+                                   & \"('R'M 3.9.3(10))!\", S);\n+\n+                  --  Ada 2005 (AI-251)\n+\n+                  else\n+                     Error_Msg_N (\"primitive subprograms of interface types \"\n+                       & \"declared in a visible part, must be declared in \"\n+                       & \"the visible part ('R'M 3.9.4)!\", S);\n+                  end if;\n \n                elsif Ekind (S) = E_Function\n                  and then Is_Tagged_Type (T)\n@@ -4650,6 +4781,15 @@ package body Sem_Ch6 is\n          Check_Dispatching_Operation (S, Empty);\n          Maybe_Primitive_Operation;\n \n+         --  Ada 2005 (AI-397): Subprograms in the context of protected\n+         --  types have their overriding indicators checked in Sem_Ch9.\n+\n+         if Ekind (S) not in Subprogram_Kind\n+           or else Ekind (Scope (S)) /= E_Protected_Type\n+         then\n+            Check_Overriding_Indicator (S, False);\n+         end if;\n+\n       --  If there is a homonym that is not overloadable, then we have an\n       --  error, except for the special cases checked explicitly below.\n \n@@ -4673,6 +4813,7 @@ package body Sem_Ch6 is\n             Enter_Overloaded_Entity (S);\n             Set_Homonym (S, Homonym (E));\n             Check_Dispatching_Operation (S, Empty);\n+            Check_Overriding_Indicator (S, False);\n \n          --  If the subprogram is implicit it is hidden by the previous\n          --  declaration. However if it is dispatching, it must appear in the\n@@ -4706,6 +4847,12 @@ package body Sem_Ch6 is\n       --  E exists and is overloadable\n \n       else\n+         Is_Alias_Interface :=\n+            Present (Alias (S))\n+            and then Is_Dispatching_Operation (Alias (S))\n+            and then Present (DTC_Entity (Alias (S)))\n+            and then Is_Interface (Scope (DTC_Entity (Alias (S))));\n+\n          --  Loop through E and its homonyms to determine if any of them is\n          --  the candidate for overriding by S.\n \n@@ -4718,8 +4865,13 @@ package body Sem_Ch6 is\n \n             --  Check if we have type conformance\n \n-            elsif Type_Conformant (E, S) then\n+            --  Ada 2005 (AI-251): In case of overriding an interface\n+            --  subprogram it is not an error that the old and new entities\n+            --  have the same profile, and hence we skip this code.\n \n+            elsif not Is_Alias_Interface\n+              and then Type_Conformant (E, S)\n+            then\n                --  If the old and new entities have the same profile and one\n                --  is not the body of the other, then this is an error, unless\n                --  one of them is implicitly declared.\n@@ -4762,6 +4914,11 @@ package body Sem_Ch6 is\n                   --  the existing declaration, which is overriding.\n \n                   Set_Is_Overriding_Operation (E);\n+\n+                  if Comes_From_Source (E) then\n+                     Check_Overriding_Indicator (E, True);\n+                  end if;\n+\n                   return;\n \n                   --  Within an instance, the renaming declarations for\n@@ -4805,6 +4962,8 @@ package body Sem_Ch6 is\n                   --  replaced in the list of primitive operations of its type\n                   --  (see Override_Dispatching_Operation).\n \n+                  Does_Override := True;\n+\n                   declare\n                      Prev : Entity_Id;\n \n@@ -4912,6 +5071,7 @@ package body Sem_Ch6 is\n \n                      Enter_Overloaded_Entity (S);\n                      Set_Is_Overriding_Operation (S);\n+                     Check_Overriding_Indicator (S, True);\n \n                      if Is_Dispatching_Operation (E) then\n \n@@ -4921,7 +5081,41 @@ package body Sem_Ch6 is\n \n                         Set_Convention (S, Convention (E));\n \n-                        Check_Dispatching_Operation (S, E);\n+                        --  AI-251: If the subprogram implements an interface,\n+                        --  check if this subprogram covers other interface\n+                        --  subprograms available in the same scope.\n+\n+                        if Present (Alias (E))\n+                          and then Ekind (Alias (E)) /= E_Operator\n+                          and then Present (DTC_Entity (Alias (E)))\n+                          and then Is_Interface (Scope (DTC_Entity\n+                                                        (Alias (E))))\n+                        then\n+                           Check_Dispatching_Operation (S, E);\n+\n+                           declare\n+                              E1 : Entity_Id;\n+\n+                           begin\n+                              E1 := Homonym (E);\n+                              while Present (E1) loop\n+                                 if Present (Alias (E1))\n+                                   and then Ekind (Alias (E1)) /= E_Operator\n+                                   and then Present (DTC_Entity (Alias (E1)))\n+                                   and then Is_Interface\n+                                              (Scope (DTC_Entity (Alias (E1))))\n+                                   and then Type_Conformant (E1, S)\n+                                 then\n+                                    Check_Dispatching_Operation (S, E1);\n+                                 end if;\n+\n+                                 E1 := Homonym (E1);\n+                              end loop;\n+                           end;\n+                        else\n+                           Check_Dispatching_Operation (S, E);\n+                        end if;\n+\n                      else\n                         Check_Dispatching_Operation (S, Empty);\n                      end if;\n@@ -4978,6 +5172,7 @@ package body Sem_Ch6 is\n \n          Enter_Overloaded_Entity (S);\n          Maybe_Primitive_Operation;\n+         Check_Overriding_Indicator (S, Does_Override);\n \n          --  If S is a derived operation for an untagged type then by\n          --  definition it's not a dispatching operation (even if the parent"}, {"sha": "71b42f7e1f675f1bbf95912e054c07f7c61d001e", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 395, "deletions": 19, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,7 @@ with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Ch9;\n with Elists;   use Elists;\n+with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n with Lib.Xref; use Lib.Xref;\n with Nlists;   use Nlists;\n@@ -67,6 +68,11 @@ package body Sem_Ch9 is\n    --  count the entries (checking the static requirement), and compare with\n    --  the given maximum.\n \n+   procedure Check_Overriding_Indicator (Def : Node_Id);\n+   --  Ada 2005 (AI-397): Check the overriding indicator of entries and\n+   --  subprograms of protected or task types. Def is the definition of\n+   --  the protected or task type.\n+\n    function Find_Concurrent_Spec (Body_Id : Entity_Id) return Entity_Id;\n    --  Find entity in corresponding task or protected declaration. Use full\n    --  view if first declaration was for an incomplete type.\n@@ -1024,16 +1030,20 @@ package body Sem_Ch9 is\n \n       Check_Max_Entries (N, Max_Protected_Entries);\n       Process_End_Label (N, 'e', Current_Scope);\n+      Check_Overriding_Indicator (N);\n    end Analyze_Protected_Definition;\n \n    ----------------------------\n    -- Analyze_Protected_Type --\n    ----------------------------\n \n    procedure Analyze_Protected_Type (N : Node_Id) is\n-      E      : Entity_Id;\n-      T      : Entity_Id;\n-      Def_Id : constant Entity_Id := Defining_Identifier (N);\n+      E         : Entity_Id;\n+      T         : Entity_Id;\n+      Def_Id    : constant Entity_Id := Defining_Identifier (N);\n+      Iface     : Node_Id;\n+      Iface_Def : Node_Id;\n+      Iface_Typ : Entity_Id;\n \n    begin\n       if No_Run_Time_Mode then\n@@ -1052,13 +1062,56 @@ package body Sem_Ch9 is\n       end if;\n \n       Set_Ekind              (T, E_Protected_Type);\n+      Set_Is_First_Subtype   (T, True);\n       Init_Size_Align        (T);\n       Set_Etype              (T, T);\n-      Set_Is_First_Subtype   (T, True);\n       Set_Has_Delayed_Freeze (T, True);\n       Set_Stored_Constraint  (T, No_Elist);\n       New_Scope (T);\n \n+      --  Ada 2005 (AI-345)\n+\n+      if Present (Interface_List (N)) then\n+         Iface := First (Interface_List (N));\n+\n+         while Present (Iface) loop\n+            Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n+            Iface_Def := Type_Definition (Parent (Iface_Typ));\n+\n+            if not Is_Interface (Iface_Typ) then\n+               Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                             Iface, Iface_Typ);\n+\n+            else\n+               --  Ada 2005 (AI-251): \"The declaration of a specific\n+               --  descendant of an interface type freezes the interface\n+               --  type\" RM 13.14\n+\n+               Freeze_Before (N, Etype (Iface));\n+\n+               --  Ada 2005 (AI-345): Protected types can only implement\n+               --  limited, synchronized or protected interfaces.\n+\n+               if Limited_Present (Iface_Def)\n+                 or else Synchronized_Present (Iface_Def)\n+                 or else Protected_Present (Iface_Def)\n+               then\n+                  null;\n+\n+               elsif Task_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) protected type cannot implement a \"\n+                    & \"task interface\", Iface);\n+\n+               else\n+                  Error_Msg_N (\"(Ada 2005) protected type cannot implement a \"\n+                    & \"non-limited interface\", Iface);\n+               end if;\n+            end if;\n+\n+            Next (Iface);\n+         end loop;\n+      end if;\n+\n       if Present (Discriminant_Specifications (N)) then\n          if Has_Discriminants (T) then\n \n@@ -1071,6 +1124,8 @@ package body Sem_Ch9 is\n          end if;\n       end if;\n \n+      Set_Is_Constrained (T, not Has_Discriminants (T));\n+\n       Analyze (Protected_Definition (N));\n \n       --  Protected types with entries are controlled (because of the\n@@ -1119,9 +1174,9 @@ package body Sem_Ch9 is\n    ---------------------\n \n    procedure Analyze_Requeue (N : Node_Id) is\n+      Count      : Natural := 0;\n       Entry_Name : Node_Id := Name (N);\n       Entry_Id   : Entity_Id;\n-      Found      : Boolean;\n       I          : Interp_Index;\n       It         : Interp;\n       Enclosing  : Entity_Id;\n@@ -1200,29 +1255,37 @@ package body Sem_Ch9 is\n \n       if Is_Overloaded (Entry_Name) then\n          Get_First_Interp (Entry_Name, I, It);\n-         Found := False;\n          Entry_Id := Empty;\n \n          while Present (It.Nam) loop\n             if No (First_Formal (It.Nam))\n               or else Subtype_Conformant (Enclosing, It.Nam)\n             then\n-               if not Found then\n-                  Found := True;\n+\n+               --  Ada 2005 (AI-345): Since protected and task types have\n+               --  primitive entry wrappers, we only consider source entries.\n+\n+               if Comes_From_Source (It.Nam) then\n+                  Count := Count + 1;\n                   Entry_Id := It.Nam;\n                else\n-                  Error_Msg_N (\"ambiguous entry name in requeue\", N);\n-                  return;\n+                  Remove_Interp (I);\n                end if;\n             end if;\n \n             Get_Next_Interp (I, It);\n          end loop;\n \n-         if not Found then\n-            Error_Msg_N (\"no entry matches context\",  N);\n+         if Count = 0 then\n+            Error_Msg_N (\"no entry matches context\", N);\n+            return;\n+\n+         elsif Count > 1 then\n+            Error_Msg_N (\"ambiguous entry name in requeue\", N);\n             return;\n+\n          else\n+            Set_Is_Overloaded (Entry_Name, False);\n             Set_Entity (Entry_Name, Entry_Id);\n          end if;\n \n@@ -1361,7 +1424,7 @@ package body Sem_Ch9 is\n \n          elsif Nkind (Alt) = N_Terminate_Alternative then\n             if Terminate_Present then\n-               Error_Msg_N (\"Only one terminate alternative allowed\", N);\n+               Error_Msg_N (\"only one terminate alternative allowed\", N);\n             else\n                Terminate_Present := True;\n                Check_Restriction (No_Terminate_Alternatives, N);\n@@ -1462,11 +1525,16 @@ package body Sem_Ch9 is\n       T_Decl :=\n         Make_Protected_Type_Declaration (Loc,\n          Defining_Identifier => T,\n-         Protected_Definition => Relocate_Node (Protected_Definition (N)));\n+         Protected_Definition => Relocate_Node (Protected_Definition (N)),\n+         Interface_List       => Interface_List (N));\n+\n+      --  Ada 2005 (AI-399): Mark the object as aliased. Required to use\n+      --  the attribute 'access\n \n       O_Decl :=\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => O_Name,\n+          Aliased_Present     => Ada_Version >= Ada_05,\n           Object_Definition   => Make_Identifier (Loc,  Chars (T)));\n \n       Rewrite (N, T_Decl);\n@@ -1489,7 +1557,6 @@ package body Sem_Ch9 is\n       --  expanded twice, with disastrous result.\n \n       Analyze_Protected_Type (N);\n-\n    end Analyze_Single_Protected;\n \n    -------------------------\n@@ -1518,11 +1585,16 @@ package body Sem_Ch9 is\n       T_Decl :=\n         Make_Task_Type_Declaration (Loc,\n           Defining_Identifier => T,\n-          Task_Definition     => Relocate_Node (Task_Definition (N)));\n+          Task_Definition     => Relocate_Node (Task_Definition (N)),\n+          Interface_List      => Interface_List (N));\n+\n+      --  Ada 2005 (AI-399): Mark the object as aliased. Required to use\n+      --  the attribute 'access\n \n       O_Decl :=\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => O_Name,\n+          Aliased_Present     => Ada_Version >= Ada_05,\n           Object_Definition   => Make_Identifier (Loc, Chars (T)));\n \n       Rewrite (N, T_Decl);\n@@ -1690,15 +1762,19 @@ package body Sem_Ch9 is\n \n       Check_Max_Entries (N, Max_Task_Entries);\n       Process_End_Label (N, 'e', Current_Scope);\n+      Check_Overriding_Indicator (N);\n    end Analyze_Task_Definition;\n \n    -----------------------\n    -- Analyze_Task_Type --\n    -----------------------\n \n    procedure Analyze_Task_Type (N : Node_Id) is\n-      T      : Entity_Id;\n-      Def_Id : constant Entity_Id := Defining_Identifier (N);\n+      T         : Entity_Id;\n+      Def_Id    : constant Entity_Id := Defining_Identifier (N);\n+      Iface     : Node_Id;\n+      Iface_Def : Node_Id;\n+      Iface_Typ : Entity_Id;\n \n    begin\n       Check_Restriction (No_Tasking, N);\n@@ -1720,6 +1796,47 @@ package body Sem_Ch9 is\n       Set_Stored_Constraint  (T, No_Elist);\n       New_Scope (T);\n \n+      --  Ada 2005 (AI-345)\n+\n+      if Present (Interface_List (N)) then\n+         Iface := First (Interface_List (N));\n+         while Present (Iface) loop\n+            Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n+            Iface_Def := Type_Definition (Parent (Iface_Typ));\n+\n+            if not Is_Interface (Iface_Typ) then\n+               Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                             Iface, Iface_Typ);\n+\n+            else\n+               --  Ada 2005 (AI-251): The declaration of a specific descendant\n+               --  of an interface type freezes the interface type (RM 13.14).\n+\n+               Freeze_Before (N, Etype (Iface));\n+\n+               --  Ada 2005 (AI-345): Task types can only implement limited,\n+               --  synchronized or task interfaces.\n+\n+               if Limited_Present (Iface_Def)\n+                 or else Synchronized_Present (Iface_Def)\n+                 or else Task_Present (Iface_Def)\n+               then\n+                  null;\n+\n+               elsif Protected_Present (Iface_Def) then\n+                  Error_Msg_N (\"(Ada 2005) task type cannot implement a \" &\n+                    \"protected interface\", Iface);\n+\n+               else\n+                  Error_Msg_N (\"(Ada 2005) task type cannot implement a \" &\n+                    \"non-limited interface\", Iface);\n+               end if;\n+            end if;\n+\n+            Next (Iface);\n+         end loop;\n+      end if;\n+\n       if Present (Discriminant_Specifications (N)) then\n          if Ada_Version = Ada_83 and then Comes_From_Source (N) then\n             Error_Msg_N (\"(Ada 83) task discriminant not allowed!\", N);\n@@ -1736,6 +1853,8 @@ package body Sem_Ch9 is\n          end if;\n       end if;\n \n+      Set_Is_Constrained (T, not Has_Discriminants (T));\n+\n       if Present (Task_Definition (N)) then\n          Analyze_Task_Definition (Task_Definition (N));\n       end if;\n@@ -1901,6 +2020,263 @@ package body Sem_Ch9 is\n       end if;\n    end Check_Max_Entries;\n \n+   --------------------------------\n+   -- Check_Overriding_Indicator --\n+   --------------------------------\n+\n+   procedure Check_Overriding_Indicator (Def : Node_Id) is\n+      Aliased_Hom : Entity_Id;\n+      Decl        : Node_Id;\n+      Def_Id      : Entity_Id;\n+      Hom         : Entity_Id;\n+      Ifaces      : constant List_Id := Interface_List (Parent (Def));\n+      Overrides   : Boolean;\n+      Spec        : Node_Id;\n+      Vis_Decls   : constant List_Id := Visible_Declarations (Def);\n+\n+      function Matches_Prefixed_View_Profile\n+        (Ifaces       : List_Id;\n+         Entry_Params : List_Id;\n+         Proc_Params  : List_Id) return Boolean;\n+      --  Ada 2005 (AI-397): Determine if an entry parameter profile matches\n+      --  the prefixed view profile of an abstract procedure. Also determine\n+      --  whether the abstract procedure belongs to an implemented interface.\n+\n+      -----------------------------------\n+      -- Matches_Prefixed_View_Profile --\n+      -----------------------------------\n+\n+      function Matches_Prefixed_View_Profile\n+        (Ifaces       : List_Id;\n+         Entry_Params : List_Id;\n+         Proc_Params  : List_Id) return Boolean\n+      is\n+         Entry_Param    : Node_Id;\n+         Proc_Param     : Node_Id;\n+         Proc_Param_Typ : Entity_Id;\n+\n+         function Includes_Interface\n+           (Iface  : Entity_Id;\n+            Ifaces : List_Id) return Boolean;\n+         --  Determine if an interface is contained in a list of interfaces\n+\n+         ------------------------\n+         -- Includes_Interface --\n+         ------------------------\n+\n+         function Includes_Interface\n+           (Iface  : Entity_Id;\n+            Ifaces : List_Id) return Boolean\n+         is\n+            Ent : Entity_Id;\n+\n+         begin\n+            Ent := First (Ifaces);\n+\n+            while Present (Ent) loop\n+               if Etype (Ent) = Iface then\n+                  return True;\n+               end if;\n+\n+               Next (Ent);\n+            end loop;\n+\n+            return False;\n+         end Includes_Interface;\n+\n+      --  Start of processing for Matches_Prefixed_View_Profile\n+\n+      begin\n+         Proc_Param := First (Proc_Params);\n+         Proc_Param_Typ := Etype (Parameter_Type (Proc_Param));\n+\n+         --  The first parameter of the abstract procedure must be of an\n+         --  interface type. The task or protected type must also implement\n+         --  that interface.\n+\n+         if not Is_Interface (Proc_Param_Typ)\n+           or else not Includes_Interface (Proc_Param_Typ, Ifaces)\n+         then\n+            return False;\n+         end if;\n+\n+         Entry_Param := First (Entry_Params);\n+         Proc_Param  := Next (Proc_Param);\n+         while Present (Entry_Param)\n+           and then Present (Proc_Param)\n+         loop\n+            --  The two parameters must be mode conformant and have the exact\n+            --  same types.\n+\n+            if In_Present (Entry_Param) /= In_Present (Proc_Param)\n+              or else Out_Present (Entry_Param) /= Out_Present (Proc_Param)\n+              or else Etype (Parameter_Type (Entry_Param)) /=\n+                      Etype (Parameter_Type (Proc_Param))\n+            then\n+               return False;\n+            end if;\n+\n+            Next (Entry_Param);\n+            Next (Proc_Param);\n+         end loop;\n+\n+         --  One of the lists is longer than the other\n+\n+         if Present (Entry_Param) or else Present (Proc_Param) then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Matches_Prefixed_View_Profile;\n+\n+   --  Start of processing for Check_Overriding_Indicator\n+\n+   begin\n+      if Present (Ifaces) then\n+         Decl := First (Vis_Decls);\n+         while Present (Decl) loop\n+\n+            --  Consider entries with either \"overriding\" or \"not overriding\"\n+            --  indicator present.\n+\n+            if Nkind (Decl) = N_Entry_Declaration\n+              and then (Must_Override (Decl)\n+                          or else\n+                        Must_Not_Override (Decl))\n+            then\n+               Def_Id := Defining_Identifier (Decl);\n+\n+               Overrides := False;\n+\n+               Hom := Homonym (Def_Id);\n+               while Present (Hom) loop\n+\n+                  --  The current entry may override a procedure from an\n+                  --  implemented interface.\n+\n+                  if Ekind (Hom) = E_Procedure\n+                    and then (Is_Abstract (Hom)\n+                                or else\n+                              Null_Present (Parent (Hom)))\n+                  then\n+                     Aliased_Hom := Hom;\n+\n+                     while Present (Alias (Aliased_Hom)) loop\n+                        Aliased_Hom := Alias (Aliased_Hom);\n+                     end loop;\n+\n+                     if Matches_Prefixed_View_Profile (Ifaces,\n+                          Parameter_Specifications (Decl),\n+                          Parameter_Specifications (Parent (Aliased_Hom)))\n+                     then\n+                        Overrides := True;\n+                        exit;\n+                     end if;\n+                  end if;\n+\n+                  Hom := Homonym (Hom);\n+               end loop;\n+\n+               if Overrides then\n+                  if Must_Not_Override (Decl) then\n+                     Error_Msg_NE (\"entry& is overriding\", Def_Id, Def_Id);\n+                  end if;\n+               else\n+                  if Must_Override (Decl) then\n+                     Error_Msg_NE (\"entry& is not overriding\", Def_Id, Def_Id);\n+                  end if;\n+               end if;\n+\n+            --  Consider subprograms with either \"overriding\" or \"not\n+            --  overriding\" indicator present.\n+\n+            elsif Nkind (Decl) = N_Subprogram_Declaration\n+              and then (Must_Override (Specification (Decl))\n+                          or else\n+                        Must_Not_Override (Specification (Decl)))\n+            then\n+               Spec := Specification (Decl);\n+               Def_Id := Defining_Unit_Name (Spec);\n+\n+               Overrides := False;\n+\n+               Hom := Homonym (Def_Id);\n+               while Present (Hom) loop\n+\n+                  --  Function\n+\n+                  if Ekind (Def_Id) = E_Function\n+                    and then Ekind (Hom) = E_Function\n+                    and then Is_Abstract (Hom)\n+                    and then Matches_Prefixed_View_Profile (Ifaces,\n+                               Parameter_Specifications (Spec),\n+                               Parameter_Specifications (Parent (Hom)))\n+                    and then Etype (Subtype_Mark (Spec)) =\n+                             Etype (Subtype_Mark (Parent (Hom)))\n+                  then\n+                     Overrides := True;\n+                     exit;\n+\n+                  --  Procedure\n+\n+                  elsif Ekind (Def_Id) = E_Procedure\n+                    and then Ekind (Hom) = E_Procedure\n+                    and then (Is_Abstract (Hom)\n+                                or else\n+                              Null_Present (Parent (Hom)))\n+                    and then Matches_Prefixed_View_Profile (Ifaces,\n+                               Parameter_Specifications (Spec),\n+                               Parameter_Specifications (Parent (Hom)))\n+                  then\n+                     Overrides := True;\n+                     exit;\n+                  end if;\n+\n+                  Hom := Homonym (Hom);\n+               end loop;\n+\n+               if Overrides then\n+                  if Must_Not_Override (Spec) then\n+                     Error_Msg_NE\n+                       (\"subprogram& is overriding\", Def_Id, Def_Id);\n+                  end if;\n+               else\n+                  if Must_Override (Spec) then\n+                     Error_Msg_NE\n+                       (\"subprogram& is not overriding\", Def_Id, Def_Id);\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+\n+      --  The protected or task type is not implementing an interface,\n+      --  we need to check for the presence of \"overriding\" entries or\n+      --  subprograms and flag them as erroneous.\n+\n+      else\n+         Decl := First (Vis_Decls);\n+\n+         while Present (Decl) loop\n+            if Nkind (Decl) = N_Entry_Declaration\n+              and then Must_Override (Decl)\n+            then\n+               Def_Id := Defining_Identifier (Decl);\n+               Error_Msg_NE (\"entry& is not overriding\", Def_Id, Def_Id);\n+\n+            elsif Nkind (Decl) = N_Subprogram_Declaration\n+              and then Must_Override (Specification (Decl))\n+            then\n+               Def_Id := Defining_Identifier (Specification (Decl));\n+               Error_Msg_NE (\"subprogram& is not overriding\", Def_Id, Def_Id);\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end if;\n+   end Check_Overriding_Indicator;\n+\n    --------------------------\n    -- Find_Concurrent_Spec --\n    --------------------------"}, {"sha": "c5fe8324cbed6f30587ab98554a9e66d0a57c83c", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 106, "deletions": 9, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -31,6 +31,7 @@ with Einfo;    use Einfo;\n with Exp_Disp; use Exp_Disp;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Tss;  use Exp_Tss;\n+with Exp_Util; use Exp_Util;\n with Errout;   use Errout;\n with Hostparm; use Hostparm;\n with Nlists;   use Nlists;\n@@ -219,12 +220,25 @@ package body Sem_Disp is\n \n       elsif Ekind (T) = E_Anonymous_Access_Type\n         and then Is_Tagged_Type (Designated_Type (T))\n-        and then Ekind (Designated_Type (T)) /= E_Incomplete_Type\n       then\n-         if Is_First_Subtype (Designated_Type (T)) then\n-            Tagged_Type := Designated_Type (T);\n-         else\n-            Tagged_Type := Base_Type (Designated_Type (T));\n+         if Ekind (Designated_Type (T)) /= E_Incomplete_Type then\n+            if Is_First_Subtype (Designated_Type (T)) then\n+               Tagged_Type := Designated_Type (T);\n+            else\n+               Tagged_Type := Base_Type (Designated_Type (T));\n+            end if;\n+\n+         --  Ada 2005 (AI-50217)\n+\n+         elsif From_With_Type (Designated_Type (T))\n+           and then Present (Non_Limited_View (Designated_Type (T)))\n+         then\n+            if Is_First_Subtype (Non_Limited_View (Designated_Type (T))) then\n+               Tagged_Type := Non_Limited_View (Designated_Type (T));\n+            else\n+               Tagged_Type := Base_Type (Non_Limited_View\n+                                         (Designated_Type (T)));\n+            end if;\n          end if;\n       end if;\n \n@@ -522,6 +536,18 @@ package body Sem_Disp is\n       Set_Is_Dispatching_Operation (Subp, False);\n       Tagged_Type := Find_Dispatching_Type (Subp);\n \n+      --  Ada 2005 (AI-345)\n+\n+      if Ada_Version = Ada_05\n+        and then Present (Tagged_Type)\n+        and then Is_Concurrent_Type (Tagged_Type)\n+        and then not Is_Empty_Elmt_List\n+                       (Abstract_Interfaces\n+                        (Corresponding_Record_Type (Tagged_Type)))\n+      then\n+         Tagged_Type := Corresponding_Record_Type (Tagged_Type);\n+      end if;\n+\n       --  If Subp is derived from a dispatching operation then it should\n       --  always be treated as dispatching. In this case various checks\n       --  below will be bypassed. Makes sure that late declarations for\n@@ -574,8 +600,10 @@ package body Sem_Disp is\n          elsif Present (Old_Subp)\n            and then Is_Dispatching_Operation (Old_Subp)\n          then\n-            if Nkind (Unit_Declaration_Node (Subp)) = N_Subprogram_Body\n-              and then Comes_From_Source (Subp)\n+            if Comes_From_Source (Subp)\n+              and then\n+                (Nkind (Unit_Declaration_Node (Subp)) = N_Subprogram_Body\n+                  or else Nkind (Unit_Declaration_Node (Subp)) in N_Body_Stub)\n             then\n                declare\n                   Subp_Body : constant Node_Id := Unit_Declaration_Node (Subp);\n@@ -947,7 +975,6 @@ package body Sem_Disp is\n                Set_Alias (Old_Subp, Alias (Subp));\n \n                --  The derived subprogram should inherit the abstractness\n-\n                --  of the parent subprogram (except in the case of a function\n                --  returning the type). This sets the abstractness properly\n                --  for cases where a private extension may have inherited\n@@ -1140,6 +1167,34 @@ package body Sem_Disp is\n       New_Op      : Entity_Id)\n    is\n       Op_Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Tagged_Type));\n+      Elmt    : Elmt_Id;\n+      Found   : Boolean;\n+\n+      function Is_Interface_Subprogram (Op : Entity_Id) return Boolean;\n+      --  Comment requjired ???\n+\n+      -----------------------------\n+      -- Is_Interface_Subprogram --\n+      -----------------------------\n+\n+      function Is_Interface_Subprogram (Op : Entity_Id) return Boolean is\n+         Aux : Entity_Id;\n+\n+      begin\n+         Aux := Op;\n+         while Present (Alias (Aux))\n+            and then Present (DTC_Entity (Alias (Aux)))\n+         loop\n+            if Is_Interface (Scope (DTC_Entity (Alias (Aux)))) then\n+               return True;\n+            end if;\n+            Aux := Alias (Aux);\n+         end loop;\n+\n+         return False;\n+      end Is_Interface_Subprogram;\n+\n+   --  Start of processing for Override_Dispatching_Operation\n \n    begin\n       --  Patch the primitive operation list\n@@ -1157,7 +1212,49 @@ package body Sem_Disp is\n          return;\n       end if;\n \n-      Replace_Elmt (Op_Elmt, New_Op);\n+      --  Ada 2005 (AI-251): Do not replace subprograms corresponding to\n+      --  abstract interfaces. They will be used later to generate the\n+      --  corresponding thunks to initialize the Vtable (see subprogram\n+      --  Freeze_Subprogram)\n+\n+      if Is_Interface_Subprogram (Prev_Op) then\n+         Set_DT_Position              (Prev_Op, DT_Position (Alias (Prev_Op)));\n+         Set_Is_Abstract              (Prev_Op, Is_Abstract (New_Op));\n+         Set_Is_Overriding_Operation  (Prev_Op);\n+         Set_Abstract_Interface_Alias (Prev_Op, Alias (Prev_Op));\n+         Set_Alias                    (Prev_Op, New_Op);\n+         Set_Is_Internal              (Prev_Op);\n+\n+         --  Override predefined primitive operations\n+\n+         if Is_Predefined_Dispatching_Operation (Prev_Op) then\n+            Replace_Elmt (Op_Elmt, New_Op);\n+            return;\n+         end if;\n+\n+         --  Check if this primitive operation was previously added for another\n+         --  interface.\n+\n+         Elmt  := First_Elmt (Primitive_Operations (Tagged_Type));\n+         Found := False;\n+         while Present (Elmt) loop\n+            if Node (Elmt) = New_Op then\n+               Found := True;\n+               exit;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         if not Found then\n+            Append_Elmt (New_Op, Primitive_Operations (Tagged_Type));\n+            --  Replace_Elmt (Op_Elmt, New_Op); -- why is this commented out???\n+         end if;\n+         return;\n+\n+      else\n+         Replace_Elmt (Op_Elmt, New_Op);\n+      end if;\n \n       if (not Is_Package (Current_Scope))\n         or else not In_Private_Part (Current_Scope)"}, {"sha": "fdba2bdec0320809e3a707a9cb8c29d8855600fb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 397, "deletions": 184, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ with Debug_A;  use Debug_A;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Expander; use Expander;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n@@ -357,7 +358,9 @@ package body Sem_Res is\n \n    procedure Check_Direct_Boolean_Op (N : Node_Id) is\n    begin\n-      if Root_Type (Etype (Left_Opnd (N))) = Standard_Boolean then\n+      if Nkind (N) in N_Op\n+        and then Root_Type (Etype (Left_Opnd (N))) = Standard_Boolean\n+      then\n          Check_Restriction (No_Direct_Boolean_Operators, N);\n       end if;\n    end Check_Direct_Boolean_Op;\n@@ -538,6 +541,12 @@ package body Sem_Res is\n          if Paren_Count (N) > 0 then\n             Error_Msg_N\n               (\"discriminant in constraint must appear alone\",  N);\n+\n+         elsif Nkind (N) = N_Expanded_Name\n+           and then Comes_From_Source (N)\n+         then\n+            Error_Msg_N\n+              (\"discriminant must appear alone as a direct name\", N);\n          end if;\n \n          return;\n@@ -2120,7 +2129,7 @@ package body Sem_Res is\n             if Typ = Any_Real\n               and then Expr_Type = Any_Fixed\n             then\n-               Error_Msg_N (\"Illegal context for mixed mode operation\", N);\n+               Error_Msg_N (\"illegal context for mixed mode operation\", N);\n                Set_Etype (N, Universal_Real);\n                Ctx_Type := Universal_Real;\n             end if;\n@@ -2590,18 +2599,32 @@ package body Sem_Res is\n                   if Has_Aliased_Components (Etype (Expression (A)))\n                     /= Has_Aliased_Components (Etype (F))\n                   then\n-                     Error_Msg_N\n-                       (\"both component types in a view conversion must be\"\n-                         & \" aliased, or neither\", A);\n+                     if Ada_Version < Ada_05 then\n+                        Error_Msg_N\n+                          (\"both component types in a view conversion must be\"\n+                            & \" aliased, or neither\", A);\n+\n+                     --  Ada 2005: rule is relaxed (see AI-363)\n+\n+                     elsif Has_Aliased_Components (Etype (F))\n+                       and then\n+                         not Has_Aliased_Components (Etype (Expression (A)))\n+                     then\n+                        Error_Msg_N\n+                          (\"view conversion operand must have aliased \" &\n+                           \"components\", N);\n+                        Error_Msg_N\n+                          (\"\\since target type has aliased components\", N);\n+                     end if;\n \n                   elsif not Same_Ancestor (Etype (F), Etype (Expression (A)))\n                     and then\n                      (Is_By_Reference_Type (Etype (F))\n                         or else Is_By_Reference_Type (Etype (Expression (A))))\n                   then\n                      Error_Msg_N\n-                       (\"view conversion between unrelated by_reference \"\n-                         & \"array types not allowed (\\A\\I-00246)?\", A);\n+                       (\"view conversion between unrelated by reference \" &\n+                        \"array types not allowed (\\'A'I-00246)\", A);\n                   end if;\n                end if;\n \n@@ -2620,19 +2643,16 @@ package body Sem_Res is\n                      or else Is_Limited_Type (Etype (Expression (A))))\n                then\n                   Error_Msg_N\n-                    (\"Conversion between unrelated limited array types \"\n-                        & \"not allowed (\\A\\I-00246)?\", A);\n-\n-                  --  Disable explanation (which produces additional errors)\n-                  --  until AI is approved and warning becomes an error.\n+                    (\"conversion between unrelated limited array types \" &\n+                     \"not allowed (\\A\\I-00246)\", A);\n \n-                  --  if Is_Limited_Type (Etype (F)) then\n-                  --     Explain_Limited_Type (Etype (F), A);\n-                  --  end if;\n+                  if Is_Limited_Type (Etype (F)) then\n+                     Explain_Limited_Type (Etype (F), A);\n+                  end if;\n \n-                  --  if Is_Limited_Type (Etype (Expression (A))) then\n-                  --     Explain_Limited_Type (Etype (Expression (A)), A);\n-                  --  end if;\n+                  if Is_Limited_Type (Etype (Expression (A))) then\n+                     Explain_Limited_Type (Etype (Expression (A)), A);\n+                  end if;\n                end if;\n \n                Resolve (A, Etype (F));\n@@ -2668,9 +2688,9 @@ package body Sem_Res is\n                   Check_Unset_Reference (A);\n                end if;\n \n-               --  In Ada 83 we cannot pass an OUT parameter as an IN\n-               --  or IN OUT actual to a nested call, since this is a\n-               --  case of reading an out parameter, which is not allowed.\n+               --  In Ada 83 we cannot pass an OUT parameter as an IN or IN OUT\n+               --  actual to a nested call, since this is case of reading an\n+               --  out parameter, which is not allowed.\n \n                if Ada_Version = Ada_83\n                  and then Is_Entity_Name (A)\n@@ -3035,6 +3055,46 @@ package body Sem_Res is\n          end if;\n       end if;\n \n+      --  Ada 2005 (AI-344): A class-wide allocator requires an accessibility\n+      --  check that the level of the type of the created object is not deeper\n+      --  than the level of the allocator's access type, since extensions can\n+      --  now occur at deeper levels than their ancestor types. This is a\n+      --  static accessibility level check; a run-time check is also needed in\n+      --  the case of an initialized allocator with a class-wide argument (see\n+      --  Expand_Allocator_Expression).\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Class_Wide_Type (Designated_Type (Typ))\n+      then\n+         declare\n+            Exp_Typ   : Entity_Id;\n+\n+         begin\n+            if Nkind (E) = N_Qualified_Expression then\n+               Exp_Typ := Etype (E);\n+            elsif Nkind (E) = N_Subtype_Indication then\n+               Exp_Typ := Entity (Subtype_Mark (Original_Node (E)));\n+            else\n+               Exp_Typ := Entity (E);\n+            end if;\n+\n+            if Type_Access_Level (Exp_Typ) > Type_Access_Level (Typ) then\n+               if In_Instance_Body then\n+                  Error_Msg_N (\"?type in allocator has deeper level than\" &\n+                               \" designated class-wide type\", E);\n+                  Error_Msg_N (\"?Program_Error will be raised at run time\", E);\n+                  Rewrite (N,\n+                    Make_Raise_Program_Error (Sloc (N),\n+                      Reason => PE_Accessibility_Check_Failed));\n+                  Set_Etype (N, Typ);\n+               else\n+                  Error_Msg_N (\"type in allocator has deeper level than\" &\n+                               \" designated class-wide type\", E);\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Check for allocation from an empty storage pool\n \n       if No_Pool_Assigned (Typ) then\n@@ -3126,8 +3186,8 @@ package body Sem_Res is\n          if Universal_Interpretation (N) = Universal_Integer then\n \n             --  A universal integer literal is resolved as standard integer\n-            --  except in the case of a fixed-point result, where we leave\n-            --  it as universal (to be handled by Exp_Fixd later on)\n+            --  except in the case of a fixed-point result, where we leave it\n+            --  as universal (to be handled by Exp_Fixd later on)\n \n             if Is_Fixed_Point_Type (T) then\n                Resolve (N, Universal_Integer);\n@@ -3209,11 +3269,11 @@ package body Sem_Res is\n                Get_Next_Interp (Index, It);\n             end loop;\n \n-            --  Reanalyze the literal with the fixed type of the context.\n-            --  If context is Universal_Fixed, we are within a conversion,\n-            --  leave the literal as a universal real because there is no\n-            --  usable fixed type, and the target of the conversion plays\n-            --  no role in the resolution.\n+            --  Reanalyze the literal with the fixed type of the context. If\n+            --  context is Universal_Fixed, we are within a conversion, leave\n+            --  the literal as a universal real because there is no usable\n+            --  fixed type, and the target of the conversion plays no role in\n+            --  the resolution.\n \n             declare\n                Op2 : Node_Id;\n@@ -3466,11 +3526,11 @@ package body Sem_Res is\n       W       : Node_Id;\n \n    begin\n-      --  The context imposes a unique interpretation with type Typ on\n-      --  a procedure or function call. Find the entity of the subprogram\n-      --  that yields the expected type, and propagate the corresponding\n-      --  formal constraints on the actuals. The caller has established\n-      --  that an interpretation exists, and emitted an error if not unique.\n+      --  The context imposes a unique interpretation with type Typ on a\n+      --  procedure or function call. Find the entity of the subprogram that\n+      --  yields the expected type, and propagate the corresponding formal\n+      --  constraints on the actuals. The caller has established that an\n+      --  interpretation exists, and emitted an error if not unique.\n \n       --  First deal with the case of a call to an access-to-subprogram,\n       --  dereference made explicit in Analyze_Call.\n@@ -3480,9 +3540,9 @@ package body Sem_Res is\n             Nam := Etype (Subp);\n \n          else\n-            --  Find the interpretation whose type (a subprogram type)\n-            --  has a return type that is compatible with the context.\n-            --  Analysis of the node has established that one exists.\n+            --  Find the interpretation whose type (a subprogram type) has a\n+            --  return type that is compatible with the context. Analysis of\n+            --  the node has established that one exists.\n \n             Get_First_Interp (Subp,  I, It);\n             Nam := Empty;\n@@ -3507,18 +3567,18 @@ package body Sem_Res is\n             Resolve (Subp, Nam);\n          end if;\n \n-         --  For an indirect call, we always invalidate checks, since we\n-         --  do not know whether the subprogram is local or global. Yes\n-         --  we could do better here, e.g. by knowing that there are no\n-         --  local subprograms, but it does not seem worth the effort.\n-         --  Similarly, we kill al knowledge of current constant values.\n+         --  For an indirect call, we always invalidate checks, since we do not\n+         --  know whether the subprogram is local or global. Yes we could do\n+         --  better here, e.g. by knowing that there are no local subprograms,\n+         --  but it does not seem worth the effort. Similarly, we kill al\n+         --  knowledge of current constant values.\n \n          Kill_Current_Values;\n \n-      --  If this is a procedure call which is really an entry call, do\n-      --  the conversion of the procedure call to an entry call. Protected\n-      --  operations use the same circuitry because the name in the call\n-      --  can be an arbitrary expression with special resolution rules.\n+      --  If this is a procedure call which is really an entry call, do the\n+      --  conversion of the procedure call to an entry call. Protected\n+      --  operations use the same circuitry because the name in the call can be\n+      --  an arbitrary expression with special resolution rules.\n \n       elsif Nkind (Subp) = N_Selected_Component\n         or else Nkind (Subp) = N_Indexed_Component\n@@ -3589,12 +3649,12 @@ package body Sem_Res is\n          Error_Msg_N (\"cannot call thread body directly\", N);\n       end if;\n \n-      --  If the subprogram is not global, then kill all checks. This is\n-      --  a bit conservative, since in many cases we could do better, but\n-      --  it is not worth the effort. Similarly, we kill constant values.\n-      --  However we do not need to do this for internal entities (unless\n-      --  they are inherited user-defined subprograms), since they are not\n-      --  in the business of molesting global values.\n+      --  If the subprogram is not global, then kill all checks. This is a bit\n+      --  conservative, since in many cases we could do better, but it is not\n+      --  worth the effort. Similarly, we kill constant values. However we do\n+      --  not need to do this for internal entities (unless they are inherited\n+      --  user-defined subprograms), since they are not in the business of\n+      --  molesting global values.\n \n       if not Is_Library_Level_Entity (Nam)\n         and then (Comes_From_Source (Nam)\n@@ -3604,43 +3664,47 @@ package body Sem_Res is\n          Kill_Current_Values;\n       end if;\n \n-      --  Check for call to obsolescent subprogram\n+      --  Deal with call to obsolescent subprogram. Note that we always allow\n+      --  such calls in the compiler itself and the run-time, since we assume\n+      --  that we know what we are doing in such cases. For example, the calls\n+      --  in Ada.Characters.Handling to its own obsolescent subprograms are\n+      --  just fine.\n \n-      if Warn_On_Obsolescent_Feature\n-        and then Is_Subprogram (Nam)\n-        and then Is_Obsolescent (Nam)\n-      then\n-         Error_Msg_NE (\"call to obsolescent subprogram&?\", N, Nam);\n+      if Is_Obsolescent (Nam) and then not GNAT_Mode then\n+         Check_Restriction (No_Obsolescent_Features, N);\n \n-         --  Output additional warning if present\n+         if Warn_On_Obsolescent_Feature then\n+            Error_Msg_NE (\"call to obsolescent subprogram&?\", N, Nam);\n \n-         W := Obsolescent_Warning (Nam);\n+            --  Output additional warning if present\n \n-         if Present (W) then\n-            Name_Buffer (1) := '|';\n-            Name_Buffer (2) := '?';\n-            Name_Len := 2;\n+            W := Obsolescent_Warning (Nam);\n \n-            --  Add characters to message, protecting all of them\n+            if Present (W) then\n+               Name_Buffer (1) := '|';\n+               Name_Buffer (2) := '?';\n+               Name_Len := 2;\n \n-            for J in 1 .. String_Length (Strval (W)) loop\n-               Add_Char_To_Name_Buffer (''');\n-               Add_Char_To_Name_Buffer\n-                 (Get_Character (Get_String_Char (Strval (W), J)));\n-            end loop;\n+               --  Add characters to message, and output message\n+\n+               for J in 1 .. String_Length (Strval (W)) loop\n+                  Add_Char_To_Name_Buffer (''');\n+                  Add_Char_To_Name_Buffer\n+                    (Get_Character (Get_String_Char (Strval (W), J)));\n+               end loop;\n \n-            Error_Msg_N (Name_Buffer (1 .. Name_Len), N);\n+               Error_Msg_N (Name_Buffer (1 .. Name_Len), N);\n+            end if;\n          end if;\n       end if;\n \n-      --  Check that a procedure call does not occur in the context\n-      --  of the entry call statement of a conditional or timed\n-      --  entry call. Note that the case of a call to a subprogram\n-      --  renaming of an entry will also be rejected. The test\n-      --  for N not being an N_Entry_Call_Statement is defensive,\n-      --  covering the possibility that the processing of entry\n-      --  calls might reach this point due to later modifications\n-      --  of the code above.\n+      --  Check that a procedure call does not occur in the context of the\n+      --  entry call statement of a conditional or timed entry call. Note that\n+      --  the case of a call to a subprogram renaming of an entry will also be\n+      --  rejected. The test for N not being an N_Entry_Call_Statement is\n+      --  defensive, covering the possibility that the processing of entry\n+      --  calls might reach this point due to later modifications of the code\n+      --  above.\n \n       if Nkind (Parent (N)) = N_Entry_Call_Alternative\n         and then Nkind (N) /= N_Entry_Call_Statement\n@@ -3662,34 +3726,33 @@ package body Sem_Res is\n          Error_Msg_N (\"\\cannot call operation that may modify it\", N);\n       end if;\n \n-      --  Freeze the subprogram name if not in default expression. Note\n-      --  that we freeze procedure calls as well as function calls.\n-      --  Procedure calls are not frozen according to the rules (RM\n-      --  13.14(14)) because it is impossible to have a procedure call to\n-      --  a non-frozen procedure in pure Ada, but in the code that we\n-      --  generate in the expander, this rule needs extending because we\n-      --  can generate procedure calls that need freezing.\n+      --  Freeze the subprogram name if not in default expression. Note that we\n+      --  freeze procedure calls as well as function calls. Procedure calls are\n+      --  not frozen according to the rules (RM 13.14(14)) because it is\n+      --  impossible to have a procedure call to a non-frozen procedure in pure\n+      --  Ada, but in the code that we generate in the expander, this rule\n+      --  needs extending because we can generate procedure calls that need\n+      --  freezing.\n \n       if Is_Entity_Name (Subp) and then not In_Default_Expression then\n          Freeze_Expression (Subp);\n       end if;\n \n-      --  For a predefined operator, the type of the result is the type\n-      --  imposed by context, except for a predefined operation on universal\n-      --  fixed. Otherwise The type of the call is the type returned by the\n-      --  subprogram being called.\n+      --  For a predefined operator, the type of the result is the type imposed\n+      --  by context, except for a predefined operation on universal fixed.\n+      --  Otherwise The type of the call is the type returned by the subprogram\n+      --  being called.\n \n       if Is_Predefined_Op (Nam) then\n          if Etype (N) /= Universal_Fixed then\n             Set_Etype (N, Typ);\n          end if;\n \n-      --  If the subprogram returns an array type, and the context\n-      --  requires the component type of that array type, the node is\n-      --  really an indexing of the parameterless call. Resolve as such.\n-      --  A pathological case occurs when the type of the component is\n-      --  an access to the array type. In this case the call is truly\n-      --  ambiguous.\n+      --  If the subprogram returns an array type, and the context requires the\n+      --  component type of that array type, the node is really an indexing of\n+      --  the parameterless call. Resolve as such. A pathological case occurs\n+      --  when the type of the component is an access to the array type. In\n+      --  this case the call is truly ambiguous.\n \n       elsif Needs_No_Actuals (Nam)\n         and then\n@@ -3760,10 +3823,10 @@ package body Sem_Res is\n       Set_Is_Overloaded (Subp, False);\n       Set_Is_Overloaded (N, False);\n \n-      --  If we are calling the current subprogram from immediately within\n-      --  its body, then that is the case where we can sometimes detect\n-      --  cases of infinite recursion statically. Do not try this in case\n-      --  restriction No_Recursion is in effect anyway.\n+      --  If we are calling the current subprogram from immediately within its\n+      --  body, then that is the case where we can sometimes detect cases of\n+      --  infinite recursion statically. Do not try this in case restriction\n+      --  No_Recursion is in effect anyway.\n \n       Scop := Current_Scope;\n \n@@ -4018,8 +4081,6 @@ package body Sem_Res is\n       T : Entity_Id;\n \n    begin\n-      Check_Direct_Boolean_Op (N);\n-\n       --  If this is an intrinsic operation which is not predefined, use\n       --  the types of its declared arguments to resolve the possibly\n       --  overloaded operands. Otherwise the operands are unambiguous and\n@@ -4059,6 +4120,7 @@ package body Sem_Res is\n             Check_Unset_Reference (R);\n             Generate_Operator_Reference (N, T);\n             Eval_Relational_Op (N);\n+            Check_Direct_Boolean_Op (N);\n          end if;\n       end if;\n    end Resolve_Comparison_Op;\n@@ -4213,7 +4275,7 @@ package body Sem_Res is\n             null;\n          else\n             Error_Msg_N\n-               (\"Invalid use of subtype mark in expression or call\", N);\n+               (\"invalid use of subtype mark in expression or call\", N);\n          end if;\n \n       --  Check discriminant use if entity is discriminant in current scope,\n@@ -4636,7 +4698,7 @@ package body Sem_Res is\n          elsif Ekind (Scope (Nam)) = E_Task_Type\n            and then not In_Open_Scopes (Scope (Nam))\n          then\n-            Error_Msg_N (\"Task has no entry with this name\", Entry_Name);\n+            Error_Msg_N (\"task has no entry with this name\", Entry_Name);\n          end if;\n       end if;\n \n@@ -4752,8 +4814,6 @@ package body Sem_Res is\n    --  Start of processing for Resolve_Equality_Op\n \n    begin\n-      Check_Direct_Boolean_Op (N);\n-\n       Set_Etype (N, Base_Type (Typ));\n       Generate_Reference (T, N, ' ');\n \n@@ -4822,6 +4882,8 @@ package body Sem_Res is\n          then\n             Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Entity (N));\n          end if;\n+\n+         Check_Direct_Boolean_Op (N);\n       end if;\n    end Resolve_Equality_Op;\n \n@@ -4837,20 +4899,35 @@ package body Sem_Res is\n       It    : Interp;\n \n    begin\n-      --  Now that we know the type, check that this is not a\n-      --  dereference of an uncompleted type. Note that this\n-      --  is not entirely correct, because dereferences of\n-      --  private types are legal in default expressions.\n-      --  This consideration also applies to similar checks\n-      --  for allocators, qualified expressions, and type\n-      --  conversions. ???\n-\n-      Check_Fully_Declared (Typ, N);\n+      --  Now that we know the type, check that this is not dereference of an\n+      --  uncompleted type. Note that this is not entirely correct, because\n+      --  dereferences of private types are legal in default expressions. This\n+      --  exception is taken care of in Check_Fully_Declared.\n+\n+      --  This consideration also applies to similar checks for allocators,\n+      --  qualified expressions, and type conversions.\n+\n+      --  An additional exception concerns other per-object expressions that\n+      --  are not directly related to component declarations, in particular\n+      --  representation pragmas for tasks. These will be per-object\n+      --  expressions if they depend on discriminants or some global entity.\n+      --  If the task has access discriminants, the designated type may be\n+      --  incomplete at the point the expression is resolved. This resolution\n+      --  takes place within the body of the initialization procedure, where\n+      --  the discriminant is replaced by its discriminal.\n+\n+      if Is_Entity_Name (Prefix (N))\n+        and then Ekind (Entity (Prefix (N))) = E_In_Parameter\n+      then\n+         null;\n+      else\n+         Check_Fully_Declared (Typ, N);\n+      end if;\n \n       if Is_Overloaded (P) then\n \n-         --  Use the context type to select the prefix that has the\n-         --  correct designated type.\n+         --  Use the context type to select the prefix that has the correct\n+         --  designated type.\n \n          Get_First_Interp (P, I, It);\n          while Present (It.Typ) loop\n@@ -4863,13 +4940,12 @@ package body Sem_Res is\n          if Present (It.Typ) then\n             Resolve (P, It.Typ);\n          else\n-            --  If no interpretation covers the designated type of the\n-            --  prefix, this is the pathological case where not all\n-            --  implementations of the prefix allow the interpretation\n-            --  of the node as a call. Now that the expected type is known,\n-            --  Remove other interpretations from prefix, rewrite it as\n-            --  a call, and resolve again, so that the proper call node\n-            --  is generated.\n+            --  If no interpretation covers the designated type of the prefix,\n+            --  this is the pathological case where not all implementations of\n+            --  the prefix allow the interpretation of the node as a call. Now\n+            --  that the expected type is known, Remove other interpretations\n+            --  from prefix, rewrite it as a call, and resolve again, so that\n+            --  the proper call node is generated.\n \n             Get_First_Interp (P, I, It);\n             while Present (It.Typ) loop\n@@ -4903,14 +4979,13 @@ package body Sem_Res is\n          Apply_Access_Check (N);\n       end if;\n \n-      --  If the designated type is a packed unconstrained array type,\n-      --  and the explicit dereference is not in the context of an\n-      --  attribute reference, then we must compute and set the actual\n-      --  subtype, since it is needed by Gigi. The reason we exclude\n-      --  the attribute case is that this is handled fine by Gigi, and\n-      --  in fact we use such attributes to build the actual subtype.\n-      --  We also exclude generated code (which builds actual subtypes\n-      --  directly if they are needed).\n+      --  If the designated type is a packed unconstrained array type, and the\n+      --  explicit dereference is not in the context of an attribute reference,\n+      --  then we must compute and set the actual subtype, since it is needed\n+      --  by Gigi. The reason we exclude the attribute case is that this is\n+      --  handled fine by Gigi, and in fact we use such attributes to build the\n+      --  actual subtype. We also exclude generated code (which builds actual\n+      --  subtypes directly if they are needed).\n \n       if Is_Array_Type (Etype (N))\n         and then Is_Packed (Etype (N))\n@@ -4921,9 +4996,9 @@ package body Sem_Res is\n          Set_Etype (N, Get_Actual_Subtype (N));\n       end if;\n \n-      --  Note: there is no Eval processing required for an explicit\n-      --  deference, because the type is known to be an allocators, and\n-      --  allocator expressions can never be static.\n+      --  Note: there is no Eval processing required for an explicit deference,\n+      --  because the type is known to be an allocators, and allocator\n+      --  expressions can never be static.\n \n    end Resolve_Explicit_Dereference;\n \n@@ -4940,8 +5015,8 @@ package body Sem_Res is\n    begin\n       if Is_Overloaded (Name) then\n \n-         --  Use the context type to select the prefix that yields the\n-         --  correct component type.\n+         --  Use the context type to select the prefix that yields the correct\n+         --  component type.\n \n          declare\n             I     : Interp_Index;\n@@ -4953,6 +5028,9 @@ package body Sem_Res is\n          begin\n             Get_First_Interp (P, I, It);\n \n+      --  the task has access discriminants, the designated type may be\n+      --  incomplete at the point the expression is resolved. This resolution\n+      --  takes place within the body of the initialization proc\n             while Present (It.Typ) loop\n \n                if (Is_Array_Type (It.Typ)\n@@ -5009,10 +5087,10 @@ package body Sem_Res is\n       Index := First_Index (Array_Type);\n       Expr  := First (Expressions (N));\n \n-      --  The prefix may have resolved to a string literal, in which case\n-      --  its etype has a special representation. This is only possible\n-      --  currently if the prefix is a static concatenation, written in\n-      --  functional notation.\n+      --  The prefix may have resolved to a string literal, in which case its\n+      --  etype has a special representation. This is only possible currently\n+      --  if the prefix is a static concatenation, written in functional\n+      --  notation.\n \n       if Ekind (Array_Type) = E_String_Literal_Subtype then\n          Resolve (Expr, Standard_Positive);\n@@ -5067,9 +5145,9 @@ package body Sem_Res is\n       Set_Entity (N, Op);\n       Set_Is_Overloaded (N, False);\n \n-      --  If the operand type is private, rewrite with suitable\n-      --  conversions on the operands and the result, to expose\n-      --  the proper underlying numeric type.\n+      --  If the operand type is private, rewrite with suitable conversions on\n+      --  the operands and the result, to expose the proper underlying numeric\n+      --  type.\n \n       if Is_Private_Type (Typ) then\n          Arg1 := Unchecked_Convert_To (Btyp, Left_Opnd  (N));\n@@ -5167,11 +5245,9 @@ package body Sem_Res is\n       B_Typ : Entity_Id;\n \n    begin\n-      Check_Direct_Boolean_Op (N);\n-\n-      --  Predefined operations on scalar types yield the base type. On\n-      --  the other hand, logical operations on arrays yield the type of\n-      --  the arguments (and the context).\n+      --  Predefined operations on scalar types yield the base type. On the\n+      --  other hand, logical operations on arrays yield the type of the\n+      --  arguments (and the context).\n \n       if Is_Array_Type (Typ) then\n          B_Typ := Typ;\n@@ -5211,6 +5287,7 @@ package body Sem_Res is\n       Set_Etype (N, B_Typ);\n       Generate_Operator_Reference (N, B_Typ);\n       Eval_Logical_Op (N);\n+      Check_Direct_Boolean_Op (N);\n    end Resolve_Logical_Op;\n \n    ---------------------------\n@@ -5269,8 +5346,8 @@ package body Sem_Res is\n \n    procedure Resolve_Null (N : Node_Id; Typ : Entity_Id) is\n    begin\n-      --  Handle restriction against anonymous null access values\n-      --  This restriction can be turned off using -gnatdh.\n+      --  Handle restriction against anonymous null access values This\n+      --  restriction can be turned off using -gnatdh.\n \n       --  Ada 2005 (AI-231): Remove restriction\n \n@@ -5417,9 +5494,9 @@ package body Sem_Res is\n          Explain_Limited_Type (Btyp, N);\n       end if;\n \n-      --  If the operands are themselves concatenations, resolve them as\n-      --  such directly. This removes several layers of recursion and allows\n-      --  GNAT to handle larger multiple concatenations.\n+      --  If the operands are themselves concatenations, resolve them as such\n+      --  directly. This removes several layers of recursion and allows GNAT to\n+      --  handle larger multiple concatenations.\n \n       if Nkind (Op1) = N_Op_Concat\n         and then not Is_Array_Type (Component_Type (Typ))\n@@ -5468,8 +5545,8 @@ package body Sem_Res is\n \n    begin\n       --  Catch attempts to do fixed-point exponentation with universal\n-      --  operands, which is a case where the illegality is not caught\n-      --  during normal operator analysis.\n+      --  operands, which is a case where the illegality is not caught during\n+      --  normal operator analysis.\n \n       if Is_Fixed_Point_Type (Typ) and then Comes_From_Source (N) then\n          Error_Msg_N (\"exponentiation not available for fixed point\", N);\n@@ -5560,9 +5637,9 @@ package body Sem_Res is\n    --  Start of processing for Resolve_Op_Not\n \n    begin\n-      --  Predefined operations on scalar types yield the base type. On\n-      --  the other hand, logical operations on arrays yield the type of\n-      --  the arguments (and the context).\n+      --  Predefined operations on scalar types yield the base type. On the\n+      --  other hand, logical operations on arrays yield the type of the\n+      --  arguments (and the context).\n \n       if Is_Array_Type (Typ) then\n          B_Typ := Typ;\n@@ -5669,12 +5746,12 @@ package body Sem_Res is\n       Check_Unset_Reference (H);\n \n       --  We have to check the bounds for being within the base range as\n-      --  required for a non-static context. Normally this is automatic\n-      --  and done as part of evaluating expressions, but the N_Range\n-      --  node is an exception, since in GNAT we consider this node to\n-      --  be a subexpression, even though in Ada it is not. The circuit\n-      --  in Sem_Eval could check for this, but that would put the test\n-      --  on the main evaluation path for expressions.\n+      --  required for a non-static context. Normally this is automatic and\n+      --  done as part of evaluating expressions, but the N_Range node is an\n+      --  exception, since in GNAT we consider this node to be a subexpression,\n+      --  even though in Ada it is not. The circuit in Sem_Eval could check for\n+      --  this, but that would put the test on the main evaluation path for\n+      --  expressions.\n \n       Check_Non_Static_Context (L);\n       Check_Non_Static_Context (H);\n@@ -5756,8 +5833,6 @@ package body Sem_Res is\n                    Realval => Small_Value (Typ) * Cint));\n \n                Set_Is_Static_Expression (N, Stat);\n-\n-\n             end if;\n \n             --  In all cases, set the corresponding integer field\n@@ -6389,8 +6464,8 @@ package body Sem_Res is\n    -----------------------------\n \n    procedure Resolve_Type_Conversion (N : Node_Id; Typ : Entity_Id) is\n-      Target_Type : constant Entity_Id := Etype (N);\n-      Conv_OK     : constant Boolean   := Conversion_OK (N);\n+      Conv_OK     : constant Boolean := Conversion_OK (N);\n+      Target_Type : Entity_Id := Etype (N);\n       Operand     : Node_Id;\n       Opnd_Type   : Entity_Id;\n       Rop         : Node_Id;\n@@ -6525,6 +6600,43 @@ package body Sem_Res is\n               (\"?useless conversion, & has this type\", N, Entity (Orig_N));\n          end if;\n       end if;\n+\n+      --  Ada 2005 (AI-251): Handle conversions to abstract interface types\n+\n+      if Ada_Version >= Ada_05 then\n+         if Is_Access_Type (Target_Type) then\n+            Target_Type := Directly_Designated_Type (Target_Type);\n+         end if;\n+\n+         if Is_Class_Wide_Type (Target_Type) then\n+            Target_Type := Etype (Target_Type);\n+         end if;\n+\n+         if Is_Interface (Target_Type) then\n+            if Is_Class_Wide_Type (Opnd_Type) then\n+               Opnd_Type := Etype (Opnd_Type);\n+            end if;\n+\n+            if not Interface_Present_In_Ancestor\n+                     (Typ   => Opnd_Type,\n+                      Iface => Target_Type)\n+            then\n+               if Nkind (Operand) = N_Attribute_Reference then\n+                  Error_Msg_Name_1 := Chars (Prefix (Operand));\n+               else\n+                  Error_Msg_Name_1 := Chars (Operand);\n+               end if;\n+\n+               Error_Msg_Name_2 := Chars (Target_Type);\n+               Error_Msg_NE\n+                 (\"(Ada 2005) % does not implement interface %\",\n+                  Operand, Target_Type);\n+\n+            else\n+               Expand_Interface_Conversion (N);\n+            end if;\n+         end if;\n+      end if;\n    end Resolve_Type_Conversion;\n \n    ----------------------\n@@ -6998,6 +7110,13 @@ package body Sem_Res is\n             return\n               Conversion_Check (False,\n                 \"downward conversion of tagged objects not allowed\");\n+\n+         --  Ada 2005 (AI-251): The conversion of a tagged type to an\n+         --  abstract interface type is always valid\n+\n+         elsif Is_Interface (Target_Type) then\n+            return True;\n+\n          else\n             Error_Msg_NE\n               (\"invalid tagged conversion, not compatible with}\",\n@@ -7162,6 +7281,94 @@ package body Sem_Res is\n \n          return True;\n \n+      --  Ada 2005 (AI-251)\n+\n+      elsif (Ekind (Target_Type) = E_General_Access_Type\n+               or else Ekind (Target_Type) = E_Anonymous_Access_Type)\n+        and then Is_Interface (Directly_Designated_Type (Target_Type))\n+      then\n+         --  Check the static accessibility rule of 4.6(17). Note that the\n+         --  check is not enforced when within an instance body, since the RM\n+         --  requires such cases to be caught at run time.\n+\n+         if Ekind (Target_Type) /= E_Anonymous_Access_Type then\n+            if Type_Access_Level (Opnd_Type) >\n+               Type_Access_Level (Target_Type)\n+            then\n+               --  In an instance, this is a run-time check, but one we know\n+               --  will fail, so generate an appropriate warning. The raise\n+               --  will be generated by Expand_N_Type_Conversion.\n+\n+               if In_Instance_Body then\n+                  Error_Msg_N\n+                    (\"?cannot convert local pointer to non-local access type\",\n+                     Operand);\n+                  Error_Msg_N\n+                    (\"?Program_Error will be raised at run time\", Operand);\n+\n+               else\n+                  Error_Msg_N\n+                    (\"cannot convert local pointer to non-local access type\",\n+                     Operand);\n+                  return False;\n+               end if;\n+\n+            --  Special accessibility checks are needed in the case of access\n+            --  discriminants declared for a limited type.\n+\n+            elsif Ekind (Opnd_Type) = E_Anonymous_Access_Type\n+              and then not Is_Local_Anonymous_Access (Opnd_Type)\n+            then\n+               --  When the operand is a selected access discriminant the check\n+               --  needs to be made against the level of the object denoted by\n+               --  the prefix of the selected name. (Object_Access_Level\n+               --  handles checking the prefix of the operand for this case.)\n+\n+               if Nkind (Operand) = N_Selected_Component\n+                 and then Object_Access_Level (Operand)\n+                   > Type_Access_Level (Target_Type)\n+               then\n+                  --  In an instance, this is a run-time check, but one we\n+                  --  know will fail, so generate an appropriate warning.\n+                  --  The raise will be generated by Expand_N_Type_Conversion.\n+\n+                  if In_Instance_Body then\n+                     Error_Msg_N\n+                       (\"?cannot convert access discriminant to non-local\" &\n+                        \" access type\", Operand);\n+                     Error_Msg_N\n+                       (\"?Program_Error will be raised at run time\", Operand);\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"cannot convert access discriminant to non-local\" &\n+                        \" access type\", Operand);\n+                     return False;\n+                  end if;\n+               end if;\n+\n+               --  The case of a reference to an access discriminant from\n+               --  within a limited type declaration (which will appear as\n+               --  a discriminal) is always illegal because the level of the\n+               --  discriminant is considered to be deeper than any (namable)\n+               --  access type.\n+\n+               if Is_Entity_Name (Operand)\n+                 and then not Is_Local_Anonymous_Access (Opnd_Type)\n+                 and then (Ekind (Entity (Operand)) = E_In_Parameter\n+                            or else Ekind (Entity (Operand)) = E_Constant)\n+                 and then Present (Discriminal_Link (Entity (Operand)))\n+               then\n+                  Error_Msg_N\n+                    (\"discriminant has deeper accessibility level than target\",\n+                     Operand);\n+                  return False;\n+               end if;\n+            end if;\n+         end if;\n+\n+         return True;\n+\n       elsif (Ekind (Target_Type) = E_General_Access_Type\n         or else Ekind (Target_Type) = E_Anonymous_Access_Type)\n           and then\n@@ -7181,11 +7388,13 @@ package body Sem_Res is\n             return False;\n          end if;\n \n-         --  Check the static accessibility rule of 4.6(17). Note that\n-         --  the check is not enforced when within an instance body, since\n-         --  the RM requires such cases to be caught at run time.\n+         --  Check the static accessibility rule of 4.6(17). Note that the\n+         --  check is not enforced when within an instance body, since the RM\n+         --  requires such cases to be caught at run time.\n \n-         if Ekind (Target_Type) /= E_Anonymous_Access_Type then\n+         if Ekind (Target_Type) /= E_Anonymous_Access_Type\n+           or else Is_Local_Anonymous_Access (Target_Type)\n+         then\n             if Type_Access_Level (Opnd_Type)\n               > Type_Access_Level (Target_Type)\n             then\n@@ -7207,13 +7416,17 @@ package body Sem_Res is\n                   return False;\n                end if;\n \n-            elsif Ekind (Opnd_Type) = E_Anonymous_Access_Type then\n+            --  Special accessibility checks are needed in the case of access\n+            --  discriminants declared for a limited type.\n+\n+            elsif Ekind (Opnd_Type) = E_Anonymous_Access_Type\n+              and then not Is_Local_Anonymous_Access (Opnd_Type)\n+            then\n \n-               --  When the operand is a selected access discriminant\n-               --  the check needs to be made against the level of the\n-               --  object denoted by the prefix of the selected name.\n-               --  (Object_Access_Level handles checking the prefix\n-               --  of the operand for this case.)\n+               --  When the operand is a selected access discriminant the check\n+               --  needs to be made against the level of the object denoted by\n+               --  the prefix of the selected name. (Object_Access_Level\n+               --  handles checking the prefix of the operand for this case.)\n \n                if Nkind (Operand) = N_Selected_Component\n                  and then Object_Access_Level (Operand)\n@@ -7238,11 +7451,11 @@ package body Sem_Res is\n                   end if;\n                end if;\n \n-               --  The case of a reference to an access discriminant\n-               --  from within a type declaration (which will appear\n-               --  as a discriminal) is always illegal because the\n-               --  level of the discriminant is considered to be\n-               --  deeper than any (namable) access type.\n+               --  The case of a reference to an access discriminant from\n+               --  within a limited type declaration (which will appear as\n+               --  a discriminal) is always illegal because the level of the\n+               --  discriminant is considered to be deeper than any (namable)\n+               --  access type.\n \n                if Is_Entity_Name (Operand)\n                  and then (Ekind (Entity (Operand)) = E_In_Parameter"}, {"sha": "93a692e5e9c4ec90bb7589f8ac9be603feae657c", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 174, "deletions": 9, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -28,6 +28,7 @@ with Atree;    use Atree;\n with Alloc;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Lib;      use Lib;\n with Opt;      use Opt;\n@@ -529,7 +530,7 @@ package body Sem_Type is\n                   end if;\n                end loop;\n \n-               --  On exit, we know that current homograph is not hidden.\n+               --  On exit, we know that current homograph is not hidden\n \n                Add_One_Interp (N, H, Etype (H));\n \n@@ -686,6 +687,58 @@ package body Sem_Type is\n       then\n          return True;\n \n+      --  Ada 2005 (AI-345): A class-wide abstract interface type T1 covers a\n+      --  task_type or protected_type implementing T1\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Class_Wide_Type (T1)\n+        and then Is_Interface (Etype (T1))\n+        and then Is_Concurrent_Type (T2)\n+        and then Interface_Present_In_Ancestor (\n+                   Typ   => Corresponding_Record_Type (Base_Type (T2)),\n+                   Iface => Etype (T1))\n+      then\n+         return True;\n+\n+      --  Ada 2005 (AI-251): A class-wide abstract interface type T1 covers an\n+      --  object T2 implementing T1\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Class_Wide_Type (T1)\n+        and then Is_Interface (Etype (T1))\n+        and then Is_Tagged_Type (T2)\n+      then\n+         if Interface_Present_In_Ancestor (Typ => T2,\n+                                           Iface => Etype (T1))\n+         then\n+            return True;\n+\n+         elsif Present (Abstract_Interfaces (T2)) then\n+\n+            --  Ada 2005 (AI-251): A class-wide abstract interface type T1\n+            --  covers an object T2 that implements a direct derivation of T1.\n+\n+            declare\n+               E : Elmt_Id := First_Elmt (Abstract_Interfaces (T2));\n+            begin\n+               while Present (E) loop\n+                  if Is_Ancestor (Etype (T1), Node (E)) then\n+                     return True;\n+                  end if;\n+\n+                  Next_Elmt (E);\n+               end loop;\n+            end;\n+\n+            --  We should also check the case in which T1 is an ancestor of\n+            --  some implemented interface???\n+\n+            return False;\n+\n+         else\n+            return False;\n+         end if;\n+\n       --  In a dispatching call the actual may be class-wide\n \n       elsif Is_Class_Wide_Type (T2)\n@@ -1629,6 +1682,13 @@ package body Sem_Type is\n       then\n          return\n            Covers (Typ, Etype (N))\n+\n+            --  Ada 2005 (AI-345)\n+\n+           or else\n+             (Is_Concurrent_Type (Etype (N))\n+                and then Covers (Typ, Corresponding_Record_Type (Etype (N))))\n+\n            or else\n              (not Is_Tagged_Type (Typ)\n                 and then Ekind (Typ) /= E_Anonymous_Access_Type\n@@ -1641,6 +1701,14 @@ package body Sem_Type is\n                   and then\n                     (Scope (It.Nam) /= Standard_Standard\n                        or else not Is_Invisible_Operator (N, Base_Type (Typ))))\n+\n+               --  Ada 2005 (AI-345)\n+\n+              or else\n+                (Is_Concurrent_Type (It.Typ)\n+                  and then Covers (Typ, Corresponding_Record_Type\n+                                                             (Etype (It.Typ))))\n+\n               or else (not Is_Tagged_Type (Typ)\n                          and then Ekind (Typ) /= E_Anonymous_Access_Type\n                          and then Covers (It.Typ, Typ))\n@@ -1694,6 +1762,72 @@ package body Sem_Type is\n       Headers := (others => No_Entry);\n    end Init_Interp_Tables;\n \n+   -----------------------------------\n+   -- Interface_Present_In_Ancestor --\n+   -----------------------------------\n+\n+   function Interface_Present_In_Ancestor\n+     (Typ   : Entity_Id;\n+      Iface : Entity_Id) return Boolean\n+   is\n+      AI    : Entity_Id;\n+      E     : Entity_Id;\n+      Elmt  : Elmt_Id;\n+\n+   begin\n+      if Is_Access_Type (Typ) then\n+         E := Etype (Directly_Designated_Type (Typ));\n+      else\n+         E := Typ;\n+      end if;\n+\n+      if Is_Concurrent_Type (E) then\n+         E := Corresponding_Record_Type (E);\n+      end if;\n+\n+      if Is_Class_Wide_Type (E) then\n+         E := Etype (E);\n+      end if;\n+\n+      if E = Iface then\n+         return True;\n+      end if;\n+\n+      loop\n+         if Present (Abstract_Interfaces (E))\n+           and then Abstract_Interfaces (E) /= Empty_List_Or_Node --  ????\n+           and then not Is_Empty_Elmt_List (Abstract_Interfaces (E))\n+         then\n+            Elmt := First_Elmt (Abstract_Interfaces (E));\n+\n+            while Present (Elmt) loop\n+               AI := Node (Elmt);\n+\n+               if AI = Iface or else Is_Ancestor (Iface, AI) then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end if;\n+\n+         exit when Etype (E) = E;\n+\n+         --  Check if the current type is a direct derivation of the\n+         --  interface\n+\n+         if Etype (E) = Iface then\n+            return True;\n+         end if;\n+\n+         --  Climb to the immediate ancestor\n+\n+         E := Etype (E);\n+      end loop;\n+\n+      return False;\n+   end Interface_Present_In_Ancestor;\n+\n    ---------------------\n    -- Intersect_Types --\n    ---------------------\n@@ -1766,6 +1900,16 @@ package body Sem_Type is\n          elsif Nkind (Parent (L)) = N_Range then\n             Error_Msg_N (\"incompatible types given in constraint\", Parent (L));\n \n+         --  Ada 2005 (AI-251): Complete the error notification\n+\n+         elsif Is_Class_Wide_Type (Etype (R))\n+             and then Is_Interface (Etype (Class_Wide_Type (Etype (R))))\n+         then\n+            Error_Msg_Name_1 := Chars (L);\n+            Error_Msg_Name_2 := Chars (Etype (Class_Wide_Type (Etype (R))));\n+            Error_Msg_NE (\"(Ada 2005) % does not implement interface %\",\n+                          L, Etype (Class_Wide_Type (Etype (R))));\n+\n          else\n             Error_Msg_N (\"incompatible types\", Parent (L));\n          end if;\n@@ -1930,7 +2074,7 @@ package body Sem_Type is\n          Headers (Hash (N)) := Interp_Map.Last;\n \n       else\n-         --   Place node at end of chain, or locate its previous entry.\n+         --   Place node at end of chain, or locate its previous entry\n \n          loop\n             if Interp_Map.Table (Map_Ptr).Node = N then\n@@ -1949,7 +2093,7 @@ package body Sem_Type is\n             end if;\n          end loop;\n \n-         --  Chain the new node.\n+         --  Chain the new node\n \n          Interp_Map.Increment_Last;\n          Interp_Map.Table (Map_Ptr).Next := Interp_Map.Last;\n@@ -2259,8 +2403,29 @@ package body Sem_Type is\n       elsif T2 = Any_Modular and then Is_Modular_Integer_Type (T1) then\n          return T1;\n \n+      --  ----------------------------------------------------------\n       --  Special cases for equality operators (all other predefined\n       --  operators can never apply to tagged types)\n+      --  ----------------------------------------------------------\n+\n+      --  Ada 2005 (AI-251): T1 and T2 are class-wide types, and T2 is an\n+      --  interface\n+\n+      elsif Is_Class_Wide_Type (T1)\n+        and then Is_Class_Wide_Type (T2)\n+        and then Is_Interface (Etype (T2))\n+      then\n+         return T1;\n+\n+      --  Ada 2005 (AI-251): T1 is a concrete type that implements the\n+      --  class-wide interface T2\n+\n+      elsif Is_Class_Wide_Type (T2)\n+        and then Is_Interface (Etype (T2))\n+        and then Interface_Present_In_Ancestor (Typ => T1,\n+                                                Iface => Etype (T2))\n+      then\n+         return T1;\n \n       elsif Is_Class_Wide_Type (T1)\n         and then Is_Ancestor (Root_Type (T1), T2)\n@@ -2302,7 +2467,7 @@ package body Sem_Type is\n       then\n          return T1;\n \n-      --  If none of the above cases applies, types are not compatible.\n+      --  If none of the above cases applies, types are not compatible\n \n       else\n          return Any_Type;\n@@ -2314,11 +2479,11 @@ package body Sem_Type is\n    -----------------------\n \n    --  In addition to booleans and arrays of booleans, we must include\n-   --  aggregates as valid boolean arguments, because in the first pass\n-   --  of resolution their components are not examined. If it turns out not\n-   --  to be an aggregate of booleans, this will be diagnosed in Resolve.\n-   --  Any_Composite must be checked for prior to the array type checks\n-   --  because Any_Composite does not have any associated indexes.\n+   --  aggregates as valid boolean arguments, because in the first pass of\n+   --  resolution their components are not examined. If it turns out not to be\n+   --  an aggregate of booleans, this will be diagnosed in Resolve.\n+   --  Any_Composite must be checked for prior to the array type checks because\n+   --  Any_Composite does not have any associated indexes.\n \n    function Valid_Boolean_Arg (T : Entity_Id) return Boolean is\n    begin"}, {"sha": "8cf54fdc1f2b93af289997d097710feca9a2c804", "filename": "gcc/ada/sem_type.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_type.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/758c442c139f7dfa96cbb94bfcfa0cab337c62be/gcc%2Fada%2Fsem_type.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.ads?ref=758c442c139f7dfa96cbb94bfcfa0cab337c62be", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -203,6 +203,13 @@ package Sem_Type is\n    --  matches the signature of the operator, and is declared in an\n    --  open scope, or in the scope of the result type.\n \n+   function Interface_Present_In_Ancestor\n+     (Typ   : Entity_Id;\n+      Iface : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-251): Typ must be a tagged record type/subtype and Iface\n+   --  must be an abstract interface type. This function is used to check if\n+   --  some ancestor of Typ implements Iface.\n+\n    function Intersect_Types (L, R : Node_Id) return Entity_Id;\n    --  Find the common interpretation to two analyzed nodes. If one of the\n    --  interpretations is universal, choose the non-universal one. If either"}]}