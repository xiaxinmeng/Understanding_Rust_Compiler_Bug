{"sha": "5eda5bad3c455d499b6a3611b433f2945caa239d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVkYTViYWQzYzQ1NWQ0OTliNmEzNjExYjQzM2YyOTQ1Y2FhMjM5ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2014-10-24T05:01:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-24T05:01:50Z"}, "message": "compiler: Use MPC library for complex numbers.\n\n\t* go-gcc.cc (Gcc_backend::complex_constant_expression): Take one\n\tmpc_t parameter instead of two mpfr_t parameters.\n\nFrom-SVN: r216611", "tree": {"sha": "c692cb03790db22948d2d1d2c21226b54e7c9a25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c692cb03790db22948d2d1d2c21226b54e7c9a25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5eda5bad3c455d499b6a3611b433f2945caa239d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eda5bad3c455d499b6a3611b433f2945caa239d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eda5bad3c455d499b6a3611b433f2945caa239d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eda5bad3c455d499b6a3611b433f2945caa239d/comments", "author": null, "committer": null, "parents": [{"sha": "3c7652863686230db5cb861ebfcbc600f10156e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c7652863686230db5cb861ebfcbc600f10156e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c7652863686230db5cb861ebfcbc600f10156e0"}], "stats": {"total": 639, "additions": 169, "deletions": 470}, "files": [{"sha": "22078f0b0fbeefb2e1cffee36f491c13ac49aa9b", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=5eda5bad3c455d499b6a3611b433f2945caa239d", "patch": "@@ -1,3 +1,8 @@\n+2014-10-23  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::complex_constant_expression): Take one\n+\tmpc_t parameter instead of two mpfr_t parameters.\n+\n 2014-09-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* Make-lang.in (check_go_parallelize): Change to just an upper bound"}, {"sha": "caf66db72f675d9e61821e614018f37448b11ee6", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=5eda5bad3c455d499b6a3611b433f2945caa239d", "patch": "@@ -247,7 +247,7 @@ class Gcc_backend : public Backend\n   float_constant_expression(Btype* btype, mpfr_t val);\n \n   Bexpression*\n-  complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag);\n+  complex_constant_expression(Btype* btype, mpc_t val);\n \n   Bexpression*\n   string_constant_expression(const std::string& val);\n@@ -1241,20 +1241,20 @@ Gcc_backend::float_constant_expression(Btype* btype, mpfr_t val)\n // Return a typed real and imaginary value as a constant complex number.\n \n Bexpression*\n-Gcc_backend::complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag)\n+Gcc_backend::complex_constant_expression(Btype* btype, mpc_t val)\n {\n   tree t = btype->get_tree();\n   tree ret;\n   if (t == error_mark_node)\n     return this->error_expression();\n \n   REAL_VALUE_TYPE r1;\n-  real_from_mpfr(&r1, real, TREE_TYPE(t), GMP_RNDN);\n+  real_from_mpfr(&r1, mpc_realref(val), TREE_TYPE(t), GMP_RNDN);\n   REAL_VALUE_TYPE r2;\n   real_convert(&r2, TYPE_MODE(TREE_TYPE(t)), &r1);\n \n   REAL_VALUE_TYPE r3;\n-  real_from_mpfr(&r3, imag, TREE_TYPE(t), GMP_RNDN);\n+  real_from_mpfr(&r3, mpc_imagref(val), TREE_TYPE(t), GMP_RNDN);\n   REAL_VALUE_TYPE r4;\n   real_convert(&r4, TYPE_MODE(TREE_TYPE(t)), &r3);\n "}, {"sha": "46b2a6d69068e32a28b5ebeae61aefcebd259a13", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=5eda5bad3c455d499b6a3611b433f2945caa239d", "patch": "@@ -9,6 +9,7 @@\n \n #include <gmp.h>\n #include <mpfr.h>\n+#include <mpc.h>\n \n #include \"operator.h\"\n \n@@ -277,9 +278,9 @@ class Backend\n   virtual Bexpression*\n   float_constant_expression(Btype* btype, mpfr_t val) = 0;\n \n-  // Return an expression for the complex value REAL/IMAG in BTYPE.\n+  // Return an expression for the complex value VAL in BTYPE.\n   virtual Bexpression*\n-  complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag) = 0;\n+  complex_constant_expression(Btype* btype, mpc_t val) = 0;\n \n   // Return an expression for the string value VAL.\n   virtual Bexpression*"}, {"sha": "6f2b07ca97a9c0db039530acb8fce159de8a5b8e", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 143, "deletions": 453, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5eda5bad3c455d499b6a3611b433f2945caa239d", "patch": "@@ -436,16 +436,14 @@ Expression::backend_numeric_constant_expression(Translate_context* context,\n     }\n   else if (type->complex_type() != NULL)\n     {\n-      mpfr_t real;\n-      mpfr_t imag;\n-      if (!val->to_complex(&real, &imag))\n+      mpc_t cval;\n+      if (!val->to_complex(&cval))\n         {\n           go_assert(saw_errors());\n           return gogo->backend()->error_expression();\n         }\n-      ret = gogo->backend()->complex_constant_expression(btype, real, imag);\n-      mpfr_clear(real);\n-      mpfr_clear(imag);\n+      ret = gogo->backend()->complex_constant_expression(btype, cval);\n+      mpc_clear(cval);\n     }\n   else\n     go_unreachable();\n@@ -2016,10 +2014,13 @@ Integer_expression::do_import(Import* imp)\n \t\t   imag_str.c_str());\n \t  return Expression::make_error(imp->location());\n \t}\n-      Expression* ret = Expression::make_complex(&real, &imag, NULL,\n-\t\t\t\t\t\t imp->location());\n+      mpc_t cval;\n+      mpc_init2(cval, mpc_precision);\n+      mpc_set_fr_fr(cval, real, imag, MPC_RNDNN);\n       mpfr_clear(real);\n       mpfr_clear(imag);\n+      Expression* ret = Expression::make_complex(&cval, NULL, imp->location());\n+      mpc_clear(cval);\n       return ret;\n     }\n   else if (num.find('.') == std::string::npos\n@@ -2297,23 +2298,21 @@ Expression::make_float(const mpfr_t* val, Type* type, Location location)\n class Complex_expression : public Expression\n {\n  public:\n-  Complex_expression(const mpfr_t* real, const mpfr_t* imag, Type* type,\n-\t\t     Location location)\n+  Complex_expression(const mpc_t* val, Type* type, Location location)\n     : Expression(EXPRESSION_COMPLEX, location),\n       type_(type)\n   {\n-    mpfr_init_set(this->real_, *real, GMP_RNDN);\n-    mpfr_init_set(this->imag_, *imag, GMP_RNDN);\n+    mpc_init2(this->val_, mpc_precision);\n+    mpc_set(this->val_, *val, MPC_RNDNN);\n   }\n \n-  // Write REAL/IMAG to string dump.\n+  // Write VAL to string dump.\n   static void\n-  export_complex(String_dump* exp, const mpfr_t real, const mpfr_t val);\n+  export_complex(String_dump* exp, const mpc_t val);\n \n   // Write REAL/IMAG to dump context.\n   static void\n-  dump_complex(Ast_dump_context* ast_dump_context, \n-\t       const mpfr_t real, const mpfr_t val);\n+  dump_complex(Ast_dump_context* ast_dump_context, const mpc_t val);\n   \n  protected:\n   bool\n@@ -2327,7 +2326,7 @@ class Complex_expression : public Expression\n   bool\n   do_numeric_constant_value(Numeric_constant* nc) const\n   {\n-    nc->set_complex(this->type_, this->real_, this->imag_);\n+    nc->set_complex(this->type_, this->val_);\n     return true;\n   }\n \n@@ -2343,7 +2342,7 @@ class Complex_expression : public Expression\n   Expression*\n   do_copy()\n   {\n-    return Expression::make_complex(&this->real_, &this->imag_, this->type_,\n+    return Expression::make_complex(&this->val_, this->type_,\n \t\t\t\t    this->location());\n   }\n \n@@ -2357,10 +2356,8 @@ class Complex_expression : public Expression\n   do_dump_expression(Ast_dump_context*) const;\n   \n  private:\n-  // The real part.\n-  mpfr_t real_;\n-  // The imaginary part;\n-  mpfr_t imag_;\n+  // The complex value.\n+  mpc_t val_;\n   // The type if known.\n   Type* type_;\n };\n@@ -2400,7 +2397,7 @@ Complex_expression::do_check_types(Gogo*)\n   if (type == NULL)\n     return;\n   Numeric_constant nc;\n-  nc.set_complex(NULL, this->real_, this->imag_);\n+  nc.set_complex(NULL, this->val_);\n   if (!nc.set_type(this->type_, true, this->location()))\n     this->set_is_error();\n }\n@@ -2432,23 +2429,22 @@ Complex_expression::do_get_backend(Translate_context* context)\n     }\n \n   Numeric_constant nc;\n-  nc.set_complex(resolved_type, this->real_, this->imag_);\n+  nc.set_complex(resolved_type, this->val_);\n   return Expression::backend_numeric_constant_expression(context, &nc);\n }\n \n // Write REAL/IMAG to export data.\n \n void\n-Complex_expression::export_complex(String_dump* exp, const mpfr_t real,\n-\t\t\t\t   const mpfr_t imag)\n+Complex_expression::export_complex(String_dump* exp, const mpc_t val)\n {\n-  if (!mpfr_zero_p(real))\n+  if (!mpfr_zero_p(mpc_realref(val)))\n     {\n-      Float_expression::export_float(exp, real);\n-      if (mpfr_sgn(imag) > 0)\n+      Float_expression::export_float(exp, mpc_realref(val));\n+      if (mpfr_sgn(mpc_imagref(val)) > 0)\n \texp->write_c_string(\"+\");\n     }\n-  Float_expression::export_float(exp, imag);\n+  Float_expression::export_float(exp, mpc_imagref(val));\n   exp->write_c_string(\"i\");\n }\n \n@@ -2457,7 +2453,7 @@ Complex_expression::export_complex(String_dump* exp, const mpfr_t real,\n void\n Complex_expression::do_export(Export* exp) const\n {\n-  Complex_expression::export_complex(exp, this->real_, this->imag_);\n+  Complex_expression::export_complex(exp, this->val_);\n   // A trailing space lets us reliably identify the end of the number.\n   exp->write_c_string(\" \");\n }\n@@ -2467,18 +2463,15 @@ Complex_expression::do_export(Export* exp) const\n void\n Complex_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n {\n-  Complex_expression::export_complex(ast_dump_context,\n-                                      this->real_,\n-                                      this->imag_);\n+  Complex_expression::export_complex(ast_dump_context, this->val_);\n }\n \n // Make a complex expression.\n \n Expression*\n-Expression::make_complex(const mpfr_t* real, const mpfr_t* imag, Type* type,\n-\t\t\t Location location)\n+Expression::make_complex(const mpc_t* val, Type* type, Location location)\n {\n-  return new Complex_expression(real, imag, type, location);\n+  return new Complex_expression(val, type, location);\n }\n \n // Find a named object in an expression.\n@@ -3774,18 +3767,14 @@ Unary_expression::eval_constant(Operator op, const Numeric_constant* unc,\n \t}\n       else if (unc->is_complex())\n \t{\n-\t  mpfr_t ureal, uimag;\n-\t  unc->get_complex(&ureal, &uimag);\n-\t  mpfr_t real, imag;\n-\t  mpfr_init(real);\n-\t  mpfr_init(imag);\n-\t  mpfr_neg(real, ureal, GMP_RNDN);\n-\t  mpfr_neg(imag, uimag, GMP_RNDN);\n-\t  nc->set_complex(unc->type(), real, imag);\n-\t  mpfr_clear(ureal);\n-\t  mpfr_clear(uimag);\n-\t  mpfr_clear(real);\n-\t  mpfr_clear(imag);\n+\t  mpc_t uval;\n+\t  unc->get_complex(&uval);\n+\t  mpc_t val;\n+\t  mpc_init2(val, mpc_precision);\n+\t  mpc_neg(val, uval, MPC_RNDNN);\n+\t  nc->set_complex(unc->type(), val);\n+\t  mpc_clear(uval);\n+\t  mpc_clear(val);\n \t  return true;\n \t}\n       else\n@@ -4505,14 +4494,13 @@ Binary_expression::compare_complex(const Numeric_constant* left_nc,\n \t\t\t\t   const Numeric_constant* right_nc,\n \t\t\t\t   int* cmp)\n {\n-  mpfr_t left_real, left_imag;\n-  if (!left_nc->to_complex(&left_real, &left_imag))\n+  mpc_t left_val;\n+  if (!left_nc->to_complex(&left_val))\n     return false;\n-  mpfr_t right_real, right_imag;\n-  if (!right_nc->to_complex(&right_real, &right_imag))\n+  mpc_t right_val;\n+  if (!right_nc->to_complex(&right_val))\n     {\n-      mpfr_clear(left_real);\n-      mpfr_clear(left_imag);\n+      mpc_clear(left_val);\n       return false;\n     }\n \n@@ -4522,19 +4510,16 @@ Binary_expression::compare_complex(const Numeric_constant* left_nc,\n   if (!type->is_abstract() && type->complex_type() != NULL)\n     {\n       int bits = type->complex_type()->bits();\n-      mpfr_prec_round(left_real, bits / 2, GMP_RNDN);\n-      mpfr_prec_round(left_imag, bits / 2, GMP_RNDN);\n-      mpfr_prec_round(right_real, bits / 2, GMP_RNDN);\n-      mpfr_prec_round(right_imag, bits / 2, GMP_RNDN);\n+      mpfr_prec_round(mpc_realref(left_val), bits / 2, GMP_RNDN);\n+      mpfr_prec_round(mpc_imagref(left_val), bits / 2, GMP_RNDN);\n+      mpfr_prec_round(mpc_realref(right_val), bits / 2, GMP_RNDN);\n+      mpfr_prec_round(mpc_imagref(right_val), bits / 2, GMP_RNDN);\n     }\n \n-  *cmp = (mpfr_cmp(left_real, right_real) != 0\n-\t  || mpfr_cmp(left_imag, right_imag) != 0);\n+  *cmp = mpc_cmp(left_val, right_val) != 0;\n \n-  mpfr_clear(left_real);\n-  mpfr_clear(left_imag);\n-  mpfr_clear(right_real);\n-  mpfr_clear(right_imag);\n+  mpc_clear(left_val);\n+  mpc_clear(right_val);\n \n   return true;\n }\n@@ -4805,31 +4790,27 @@ Binary_expression::eval_complex(Operator op, const Numeric_constant* left_nc,\n \t\t\t\tconst Numeric_constant* right_nc,\n \t\t\t\tLocation location, Numeric_constant* nc)\n {\n-  mpfr_t left_real, left_imag;\n-  if (!left_nc->to_complex(&left_real, &left_imag))\n+  mpc_t left_val;\n+  if (!left_nc->to_complex(&left_val))\n     return false;\n-  mpfr_t right_real, right_imag;\n-  if (!right_nc->to_complex(&right_real, &right_imag))\n+  mpc_t right_val;\n+  if (!right_nc->to_complex(&right_val))\n     {\n-      mpfr_clear(left_real);\n-      mpfr_clear(left_imag);\n+      mpc_clear(left_val);\n       return false;\n     }\n \n-  mpfr_t real, imag;\n-  mpfr_init(real);\n-  mpfr_init(imag);\n+  mpc_t val;\n+  mpc_init2(val, mpc_precision);\n \n   bool ret = true;\n   switch (op)\n     {\n     case OPERATOR_PLUS:\n-      mpfr_add(real, left_real, right_real, GMP_RNDN);\n-      mpfr_add(imag, left_imag, right_imag, GMP_RNDN);\n+      mpc_add(val, left_val, right_val, MPC_RNDNN);\n       break;\n     case OPERATOR_MINUS:\n-      mpfr_sub(real, left_real, right_real, GMP_RNDN);\n-      mpfr_sub(imag, left_imag, right_imag, GMP_RNDN);\n+      mpc_sub(val, left_val, right_val, MPC_RNDNN);\n       break;\n     case OPERATOR_OR:\n     case OPERATOR_XOR:\n@@ -4838,310 +4819,30 @@ Binary_expression::eval_complex(Operator op, const Numeric_constant* left_nc,\n     case OPERATOR_MOD:\n     case OPERATOR_LSHIFT:\n     case OPERATOR_RSHIFT:\n-      mpfr_set_ui(real, 0, GMP_RNDN);\n-      mpfr_set_ui(imag, 0, GMP_RNDN);\n+      mpc_set_ui(val, 0, MPC_RNDNN);\n       ret = false;\n       break;\n     case OPERATOR_MULT:\n-      {\n-\t// You might think that multiplying two complex numbers would\n-\t// be simple, and you would be right, until you start to think\n-\t// about getting the right answer for infinity.  If one\n-\t// operand here is infinity and the other is anything other\n-\t// than zero or NaN, then we are going to wind up subtracting\n-\t// two infinity values.  That will give us a NaN, but the\n-\t// correct answer is infinity.\n-\n-\tmpfr_t lrrr;\n-\tmpfr_init(lrrr);\n-\tmpfr_mul(lrrr, left_real, right_real, GMP_RNDN);\n-\n-\tmpfr_t lrri;\n-\tmpfr_init(lrri);\n-\tmpfr_mul(lrri, left_real, right_imag, GMP_RNDN);\n-\n-\tmpfr_t lirr;\n-\tmpfr_init(lirr);\n-\tmpfr_mul(lirr, left_imag, right_real, GMP_RNDN);\n-\n-\tmpfr_t liri;\n-\tmpfr_init(liri);\n-\tmpfr_mul(liri, left_imag, right_imag, GMP_RNDN);\n-\n-\tmpfr_sub(real, lrrr, liri, GMP_RNDN);\n-\tmpfr_add(imag, lrri, lirr, GMP_RNDN);\n-\n-\t// If we get NaN on both sides, check whether it should really\n-\t// be infinity.  The rule is that if either side of the\n-\t// complex number is infinity, then the whole value is\n-\t// infinity, even if the other side is NaN.  So the only case\n-\t// we have to fix is the one in which both sides are NaN.\n-\tif (mpfr_nan_p(real) && mpfr_nan_p(imag)\n-\t    && (!mpfr_nan_p(left_real) || !mpfr_nan_p(left_imag))\n-\t    && (!mpfr_nan_p(right_real) || !mpfr_nan_p(right_imag)))\n-\t  {\n-\t    bool is_infinity = false;\n-\n-\t    mpfr_t lr;\n-\t    mpfr_t li;\n-\t    mpfr_init_set(lr, left_real, GMP_RNDN);\n-\t    mpfr_init_set(li, left_imag, GMP_RNDN);\n-\n-\t    mpfr_t rr;\n-\t    mpfr_t ri;\n-\t    mpfr_init_set(rr, right_real, GMP_RNDN);\n-\t    mpfr_init_set(ri, right_imag, GMP_RNDN);\n-\n-\t    // If the left side is infinity, then the result is\n-\t    // infinity.\n-\t    if (mpfr_inf_p(lr) || mpfr_inf_p(li))\n-\t      {\n-\t\tmpfr_set_ui(lr, mpfr_inf_p(lr) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(lr, lr, left_real, GMP_RNDN);\n-\t\tmpfr_set_ui(li, mpfr_inf_p(li) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(li, li, left_imag, GMP_RNDN);\n-\t\tif (mpfr_nan_p(rr))\n-\t\t  {\n-\t\t    mpfr_set_ui(rr, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(rr, rr, right_real, GMP_RNDN);\n-\t\t  }\n-\t\tif (mpfr_nan_p(ri))\n-\t\t  {\n-\t\t    mpfr_set_ui(ri, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(ri, ri, right_imag, GMP_RNDN);\n-\t\t  }\n-\t\tis_infinity = true;\n-\t      }\n-\n-\t    // If the right side is infinity, then the result is\n-\t    // infinity.\n-\t    if (mpfr_inf_p(rr) || mpfr_inf_p(ri))\n-\t      {\n-\t\tmpfr_set_ui(rr, mpfr_inf_p(rr) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(rr, rr, right_real, GMP_RNDN);\n-\t\tmpfr_set_ui(ri, mpfr_inf_p(ri) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(ri, ri, right_imag, GMP_RNDN);\n-\t\tif (mpfr_nan_p(lr))\n-\t\t  {\n-\t\t    mpfr_set_ui(lr, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(lr, lr, left_real, GMP_RNDN);\n-\t\t  }\n-\t\tif (mpfr_nan_p(li))\n-\t\t  {\n-\t\t    mpfr_set_ui(li, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(li, li, left_imag, GMP_RNDN);\n-\t\t  }\n-\t\tis_infinity = true;\n-\t      }\n-\n-\t    // If we got an overflow in the intermediate computations,\n-\t    // then the result is infinity.\n-\t    if (!is_infinity\n-\t\t&& (mpfr_inf_p(lrrr) || mpfr_inf_p(lrri)\n-\t\t    || mpfr_inf_p(lirr) || mpfr_inf_p(liri)))\n-\t      {\n-\t\tif (mpfr_nan_p(lr))\n-\t\t  {\n-\t\t    mpfr_set_ui(lr, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(lr, lr, left_real, GMP_RNDN);\n-\t\t  }\n-\t\tif (mpfr_nan_p(li))\n-\t\t  {\n-\t\t    mpfr_set_ui(li, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(li, li, left_imag, GMP_RNDN);\n-\t\t  }\n-\t\tif (mpfr_nan_p(rr))\n-\t\t  {\n-\t\t    mpfr_set_ui(rr, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(rr, rr, right_real, GMP_RNDN);\n-\t\t  }\n-\t\tif (mpfr_nan_p(ri))\n-\t\t  {\n-\t\t    mpfr_set_ui(ri, 0, GMP_RNDN);\n-\t\t    mpfr_copysign(ri, ri, right_imag, GMP_RNDN);\n-\t\t  }\n-\t\tis_infinity = true;\n-\t      }\n-\n-\t    if (is_infinity)\n-\t      {\n-\t\tmpfr_mul(lrrr, lr, rr, GMP_RNDN);\n-\t\tmpfr_mul(lrri, lr, ri, GMP_RNDN);\n-\t\tmpfr_mul(lirr, li, rr, GMP_RNDN);\n-\t\tmpfr_mul(liri, li, ri, GMP_RNDN);\n-\t\tmpfr_sub(real, lrrr, liri, GMP_RNDN);\n-\t\tmpfr_add(imag, lrri, lirr, GMP_RNDN);\n-\t\tmpfr_set_inf(real, mpfr_sgn(real));\n-\t\tmpfr_set_inf(imag, mpfr_sgn(imag));\n-\t      }\n-\n-\t    mpfr_clear(lr);\n-\t    mpfr_clear(li);\n-\t    mpfr_clear(rr);\n-\t    mpfr_clear(ri);\n-\t  }\n-\n-\tmpfr_clear(lrrr);\n-\tmpfr_clear(lrri);\n-\tmpfr_clear(lirr);\n-\tmpfr_clear(liri);\t\t\t\t  \n-      }\n+      mpc_mul(val, left_val, right_val, MPC_RNDNN);\n       break;\n     case OPERATOR_DIV:\n-      {\n-\t// For complex division we want to avoid having an\n-\t// intermediate overflow turn the whole result in a NaN.  We\n-\t// scale the values to try to avoid this.\n-\n-\tif (mpfr_zero_p(right_real) && mpfr_zero_p(right_imag))\n-\t  {\n-\t    error_at(location, \"division by zero\");\n-\t    mpfr_set_ui(real, 0, GMP_RNDN);\n-\t    mpfr_set_ui(imag, 0, GMP_RNDN);\n-\t    break;\n-\t  }\n-\n-\tmpfr_t rra;\n-\tmpfr_t ria;\n-\tmpfr_init(rra);\n-\tmpfr_init(ria);\n-\tmpfr_abs(rra, right_real, GMP_RNDN);\n-\tmpfr_abs(ria, right_imag, GMP_RNDN);\n-\tmpfr_t t;\n-\tmpfr_init(t);\n-\tmpfr_max(t, rra, ria, GMP_RNDN);\n-\n-\tmpfr_t rr;\n-\tmpfr_t ri;\n-\tmpfr_init_set(rr, right_real, GMP_RNDN);\n-\tmpfr_init_set(ri, right_imag, GMP_RNDN);\n-\tlong ilogbw = 0;\n-\tif (!mpfr_inf_p(t) && !mpfr_nan_p(t) && !mpfr_zero_p(t))\n-\t  {\n-\t    ilogbw = mpfr_get_exp(t);\n-\t    mpfr_mul_2si(rr, rr, - ilogbw, GMP_RNDN);\n-\t    mpfr_mul_2si(ri, ri, - ilogbw, GMP_RNDN);\n-\t  }\n-\n-\tmpfr_t denom;\n-\tmpfr_init(denom);\n-\tmpfr_mul(denom, rr, rr, GMP_RNDN);\n-\tmpfr_mul(t, ri, ri, GMP_RNDN);\n-\tmpfr_add(denom, denom, t, GMP_RNDN);\n-\n-\tmpfr_mul(real, left_real, rr, GMP_RNDN);\n-\tmpfr_mul(t, left_imag, ri, GMP_RNDN);\n-\tmpfr_add(real, real, t, GMP_RNDN);\n-\tmpfr_div(real, real, denom, GMP_RNDN);\n-\tmpfr_mul_2si(real, real, - ilogbw, GMP_RNDN);\n-\n-\tmpfr_mul(imag, left_imag, rr, GMP_RNDN);\n-\tmpfr_mul(t, left_real, ri, GMP_RNDN);\n-\tmpfr_sub(imag, imag, t, GMP_RNDN);\n-\tmpfr_div(imag, imag, denom, GMP_RNDN);\n-\tmpfr_mul_2si(imag, imag, - ilogbw, GMP_RNDN);\n-\n-\t// If we wind up with NaN on both sides, check whether we\n-\t// should really have infinity.  The rule is that if either\n-\t// side of the complex number is infinity, then the whole\n-\t// value is infinity, even if the other side is NaN.  So the\n-\t// only case we have to fix is the one in which both sides are\n-\t// NaN.\n-\tif (mpfr_nan_p(real) && mpfr_nan_p(imag)\n-\t    && (!mpfr_nan_p(left_real) || !mpfr_nan_p(left_imag))\n-\t    && (!mpfr_nan_p(right_real) || !mpfr_nan_p(right_imag)))\n-\t  {\n-\t    if (mpfr_zero_p(denom))\n-\t      {\n-\t\tmpfr_set_inf(real, mpfr_sgn(rr));\n-\t\tmpfr_mul(real, real, left_real, GMP_RNDN);\n-\t\tmpfr_set_inf(imag, mpfr_sgn(rr));\n-\t\tmpfr_mul(imag, imag, left_imag, GMP_RNDN);\n-\t      }\n-\t    else if ((mpfr_inf_p(left_real) || mpfr_inf_p(left_imag))\n-\t\t     && mpfr_number_p(rr) && mpfr_number_p(ri))\n-\t      {\n-\t\tmpfr_set_ui(t, mpfr_inf_p(left_real) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(t, t, left_real, GMP_RNDN);\n-\n-\t\tmpfr_t t2;\n-\t\tmpfr_init_set_ui(t2, mpfr_inf_p(left_imag) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(t2, t2, left_imag, GMP_RNDN);\n-\n-\t\tmpfr_t t3;\n-\t\tmpfr_init(t3);\n-\t\tmpfr_mul(t3, t, rr, GMP_RNDN);\n-\n-\t\tmpfr_t t4;\n-\t\tmpfr_init(t4);\n-\t\tmpfr_mul(t4, t2, ri, GMP_RNDN);\n-\n-\t\tmpfr_add(t3, t3, t4, GMP_RNDN);\n-\t\tmpfr_set_inf(real, mpfr_sgn(t3));\n-\n-\t\tmpfr_mul(t3, t2, rr, GMP_RNDN);\n-\t\tmpfr_mul(t4, t, ri, GMP_RNDN);\n-\t\tmpfr_sub(t3, t3, t4, GMP_RNDN);\n-\t\tmpfr_set_inf(imag, mpfr_sgn(t3));\n-\n-\t\tmpfr_clear(t2);\n-\t\tmpfr_clear(t3);\n-\t\tmpfr_clear(t4);\n-\t      }\n-\t    else if ((mpfr_inf_p(right_real) || mpfr_inf_p(right_imag))\n-\t\t     && mpfr_number_p(left_real) && mpfr_number_p(left_imag))\n-\t      {\n-\t\tmpfr_set_ui(t, mpfr_inf_p(rr) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(t, t, rr, GMP_RNDN);\n-\n-\t\tmpfr_t t2;\n-\t\tmpfr_init_set_ui(t2, mpfr_inf_p(ri) ? 1 : 0, GMP_RNDN);\n-\t\tmpfr_copysign(t2, t2, ri, GMP_RNDN);\n-\n-\t\tmpfr_t t3;\n-\t\tmpfr_init(t3);\n-\t\tmpfr_mul(t3, left_real, t, GMP_RNDN);\n-\n-\t\tmpfr_t t4;\n-\t\tmpfr_init(t4);\n-\t\tmpfr_mul(t4, left_imag, t2, GMP_RNDN);\n-\n-\t\tmpfr_add(t3, t3, t4, GMP_RNDN);\n-\t\tmpfr_set_ui(real, 0, GMP_RNDN);\n-\t\tmpfr_mul(real, real, t3, GMP_RNDN);\n-\n-\t\tmpfr_mul(t3, left_imag, t, GMP_RNDN);\n-\t\tmpfr_mul(t4, left_real, t2, GMP_RNDN);\n-\t\tmpfr_sub(t3, t3, t4, GMP_RNDN);\n-\t\tmpfr_set_ui(imag, 0, GMP_RNDN);\n-\t\tmpfr_mul(imag, imag, t3, GMP_RNDN);\n-\n-\t\tmpfr_clear(t2);\n-\t\tmpfr_clear(t3);\n-\t\tmpfr_clear(t4);\n-\t      }\n-\t  }\n-\n-\tmpfr_clear(denom);\n-\tmpfr_clear(rr);\n-\tmpfr_clear(ri);\n-\tmpfr_clear(t);\n-\tmpfr_clear(rra);\n-\tmpfr_clear(ria);\n-      }\n+      if (mpc_cmp_si(right_val, 0) == 0)\n+\t{\n+\t  error_at(location, \"division by zero\");\n+\t  mpc_set_ui(val, 0, MPC_RNDNN);\n+\t  break;\n+\t}\n+      mpc_div(val, left_val, right_val, MPC_RNDNN);\n       break;\n     default:\n       go_unreachable();\n     }\n \n-  mpfr_clear(left_real);\n-  mpfr_clear(left_imag);\n-  mpfr_clear(right_real);\n-  mpfr_clear(right_imag);\n+  mpc_clear(left_val);\n+  mpc_clear(right_val);\n \n-  nc->set_complex(NULL, real, imag);\n-  mpfr_clear(real);\n-  mpfr_clear(imag);\n+  nc->set_complex(NULL, val);\n+  mpc_clear(val);\n \n   return ret;\n }\n@@ -7397,9 +7098,9 @@ Builtin_call_expression::check_int_value(Expression* e, bool is_length)\n }\n \n // Return the type of the real or imag functions, given the type of\n-// the argument.  We need to map complex to float, complex64 to\n-// float32, and complex128 to float64, so it has to be done by name.\n-// This returns NULL if it can't figure out the type.\n+// the argument.  We need to map complex64 to float32 and complex128\n+// to float64, so it has to be done by name.  This returns NULL if it\n+// can't figure out the type.\n \n Type*\n Builtin_call_expression::real_imag_type(Type* arg_type)\n@@ -7713,16 +7414,16 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n       if (!arg->numeric_constant_value(&argnc))\n \treturn false;\n \n-      mpfr_t real;\n-      mpfr_t imag;\n-      if (!argnc.to_complex(&real, &imag))\n+      mpc_t val;\n+      if (!argnc.to_complex(&val))\n \treturn false;\n \n       Type* type = Builtin_call_expression::real_imag_type(argnc.type());\n       if (this->code_ == BUILTIN_REAL)\n-\tnc->set_float(type, real);\n+\tnc->set_float(type, mpc_realref(val));\n       else\n-\tnc->set_float(type, imag);\n+\tnc->set_float(type, mpc_imagref(val));\n+      mpc_clear(val);\n       return true;\n     }\n   else if (this->code_ == BUILTIN_COMPLEX)\n@@ -7759,12 +7460,17 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n       if (arg_type == NULL || arg_type->is_abstract())\n \targ_type = inc.type();\n \n-      Type* type = Builtin_call_expression::complex_type(arg_type);\n-      nc->set_complex(type, r, i);\n-\n+      mpc_t val;\n+      mpc_init2(val, mpc_precision);\n+      mpc_set_fr_fr(val, r, i, MPC_RNDNN);\n       mpfr_clear(r);\n       mpfr_clear(i);\n \n+      Type* type = Builtin_call_expression::complex_type(arg_type);\n+      nc->set_complex(type, val);\n+\n+      mpc_clear(val);\n+\n       return true;\n     }\n \n@@ -8690,11 +8396,10 @@ Builtin_call_expression::do_export(Export* exp) const\n     }\n   else if (nc.is_complex())\n     {\n-      mpfr_t real;\n-      mpfr_t imag;\n-      Complex_expression::export_complex(exp, real, imag);\n-      mpfr_clear(real);\n-      mpfr_clear(imag);\n+      mpc_t cval;\n+      nc.get_complex(&cval);\n+      Complex_expression::export_complex(exp, cval);\n+      mpc_clear(cval);\n     }\n   else\n     go_unreachable();\n@@ -15333,10 +15038,8 @@ Numeric_constant::Numeric_constant(const Numeric_constant& a)\n       mpfr_init_set(this->u_.float_val, a.u_.float_val, GMP_RNDN);\n       break;\n     case NC_COMPLEX:\n-      mpfr_init_set(this->u_.complex_val.real, a.u_.complex_val.real,\n-\t\t    GMP_RNDN);\n-      mpfr_init_set(this->u_.complex_val.imag, a.u_.complex_val.imag,\n-\t\t    GMP_RNDN);\n+      mpc_init2(this->u_.complex_val, mpc_precision);\n+      mpc_set(this->u_.complex_val, a.u_.complex_val, MPC_RNDNN);\n       break;\n     default:\n       go_unreachable();\n@@ -15363,10 +15066,8 @@ Numeric_constant::operator=(const Numeric_constant& a)\n       mpfr_init_set(this->u_.float_val, a.u_.float_val, GMP_RNDN);\n       break;\n     case NC_COMPLEX:\n-      mpfr_init_set(this->u_.complex_val.real, a.u_.complex_val.real,\n-\t\t    GMP_RNDN);\n-      mpfr_init_set(this->u_.complex_val.imag, a.u_.complex_val.imag,\n-\t\t    GMP_RNDN);\n+      mpc_init2(this->u_.complex_val, mpc_precision);\n+      mpc_set(this->u_.complex_val, a.u_.complex_val, MPC_RNDNN);\n       break;\n     default:\n       go_unreachable();\n@@ -15391,8 +15092,7 @@ Numeric_constant::clear()\n       mpfr_clear(this->u_.float_val);\n       break;\n     case NC_COMPLEX:\n-      mpfr_clear(this->u_.complex_val.real);\n-      mpfr_clear(this->u_.complex_val.imag);\n+      mpc_clear(this->u_.complex_val);\n       break;\n     default:\n       go_unreachable();\n@@ -15453,13 +15153,13 @@ Numeric_constant::set_float(Type* type, const mpfr_t val)\n // Set to a complex value.\n \n void\n-Numeric_constant::set_complex(Type* type, const mpfr_t real, const mpfr_t imag)\n+Numeric_constant::set_complex(Type* type, const mpc_t val)\n {\n   this->clear();\n   this->classification_ = NC_COMPLEX;\n   this->type_ = type;\n-  mpfr_init_set(this->u_.complex_val.real, real, GMP_RNDN);\n-  mpfr_init_set(this->u_.complex_val.imag, imag, GMP_RNDN);\n+  mpc_init2(this->u_.complex_val, mpc_precision);\n+  mpc_set(this->u_.complex_val, val, MPC_RNDNN);\n }\n \n // Get an int value.\n@@ -15492,11 +15192,11 @@ Numeric_constant::get_float(mpfr_t* val) const\n // Get a complex value.\n \n void\n-Numeric_constant::get_complex(mpfr_t* real, mpfr_t* imag) const\n+Numeric_constant::get_complex(mpc_t* val) const\n {\n   go_assert(this->is_complex());\n-  mpfr_init_set(*real, this->u_.complex_val.real, GMP_RNDN);\n-  mpfr_init_set(*imag, this->u_.complex_val.imag, GMP_RNDN);\n+  mpc_init2(*val, mpc_precision);\n+  mpc_set(*val, this->u_.complex_val, MPC_RNDNN);\n }\n \n // Express value as unsigned long if possible.\n@@ -15512,9 +15212,10 @@ Numeric_constant::to_unsigned_long(unsigned long* val) const\n     case NC_FLOAT:\n       return this->mpfr_to_unsigned_long(this->u_.float_val, val);\n     case NC_COMPLEX:\n-      if (!mpfr_zero_p(this->u_.complex_val.imag))\n+      if (!mpfr_zero_p(mpc_imagref(this->u_.complex_val)))\n \treturn NC_UL_NOTINT;\n-      return this->mpfr_to_unsigned_long(this->u_.complex_val.real, val);\n+      return this->mpfr_to_unsigned_long(mpc_realref(this->u_.complex_val),\n+\t\t\t\t\t val);\n     default:\n       go_unreachable();\n     }\n@@ -15569,11 +15270,11 @@ Numeric_constant::to_int(mpz_t* val) const\n       mpfr_get_z(*val, this->u_.float_val, GMP_RNDN);\n       return true;\n     case NC_COMPLEX:\n-      if (!mpfr_zero_p(this->u_.complex_val.imag)\n-\t  || !mpfr_integer_p(this->u_.complex_val.real))\n+      if (!mpfr_zero_p(mpc_imagref(this->u_.complex_val))\n+\t  || !mpfr_integer_p(mpc_realref(this->u_.complex_val)))\n \treturn false;\n       mpz_init(*val);\n-      mpfr_get_z(*val, this->u_.complex_val.real, GMP_RNDN);\n+      mpfr_get_z(*val, mpc_realref(this->u_.complex_val), GMP_RNDN);\n       return true;\n     default:\n       go_unreachable();\n@@ -15595,9 +15296,9 @@ Numeric_constant::to_float(mpfr_t* val) const\n       mpfr_init_set(*val, this->u_.float_val, GMP_RNDN);\n       return true;\n     case NC_COMPLEX:\n-      if (!mpfr_zero_p(this->u_.complex_val.imag))\n+      if (!mpfr_zero_p(mpc_imagref(this->u_.complex_val)))\n \treturn false;\n-      mpfr_init_set(*val, this->u_.complex_val.real, GMP_RNDN);\n+      mpfr_init_set(*val, mpc_realref(this->u_.complex_val), GMP_RNDN);\n       return true;\n     default:\n       go_unreachable();\n@@ -15607,22 +15308,20 @@ Numeric_constant::to_float(mpfr_t* val) const\n // Convert value to complex.\n \n bool\n-Numeric_constant::to_complex(mpfr_t* vr, mpfr_t* vi) const\n+Numeric_constant::to_complex(mpc_t* val) const\n {\n+  mpc_init2(*val, mpc_precision);\n   switch (this->classification_)\n     {\n     case NC_INT:\n     case NC_RUNE:\n-      mpfr_init_set_z(*vr, this->u_.int_val, GMP_RNDN);\n-      mpfr_init_set_ui(*vi, 0, GMP_RNDN);\n+      mpc_set_z(*val, this->u_.int_val, MPC_RNDNN);\n       return true;\n     case NC_FLOAT:\n-      mpfr_init_set(*vr, this->u_.float_val, GMP_RNDN);\n-      mpfr_init_set_ui(*vi, 0, GMP_RNDN);\n+      mpc_set_fr(*val, this->u_.float_val, MPC_RNDNN);\n       return true;\n     case NC_COMPLEX:\n-      mpfr_init_set(*vr, this->u_.complex_val.real, GMP_RNDN);\n-      mpfr_init_set(*vi, this->u_.complex_val.imag, GMP_RNDN);\n+      mpc_set(*val, this->u_.complex_val, MPC_RNDNN);\n       return true;\n     default:\n       go_unreachable();\n@@ -15700,15 +15399,15 @@ Numeric_constant::check_int_type(Integer_type* type, bool issue_error,\n       break;\n \n     case NC_COMPLEX:\n-      if (!mpfr_integer_p(this->u_.complex_val.real)\n-\t  || !mpfr_zero_p(this->u_.complex_val.imag))\n+      if (!mpfr_integer_p(mpc_realref(this->u_.complex_val))\n+\t  || !mpfr_zero_p(mpc_imagref(this->u_.complex_val)))\n \t{\n \t  if (issue_error)\n \t    error_at(location, \"complex constant truncated to integer\");\n \t  return false;\n \t}\n       mpz_init(val);\n-      mpfr_get_z(val, this->u_.complex_val.real, GMP_RNDN);\n+      mpfr_get_z(val, mpc_realref(this->u_.complex_val), GMP_RNDN);\n       break;\n \n     default:\n@@ -15767,13 +15466,13 @@ Numeric_constant::check_float_type(Float_type* type, bool issue_error,\n       break;\n \n     case NC_COMPLEX:\n-      if (!mpfr_zero_p(this->u_.complex_val.imag))\n+      if (!mpfr_zero_p(mpc_imagref(this->u_.complex_val)))\n \t{\n \t  if (issue_error)\n \t    error_at(location, \"complex constant truncated to float\");\n \t  return false;\n \t}\n-      mpfr_init_set(val, this->u_.complex_val.real, GMP_RNDN);\n+      mpfr_init_set(val, mpc_realref(this->u_.complex_val), GMP_RNDN);\n       break;\n \n     default:\n@@ -15860,45 +15559,42 @@ Numeric_constant::check_complex_type(Complex_type* type, bool issue_error,\n       go_unreachable();\n     }\n \n-  mpfr_t real;\n-  mpfr_t imag;\n+  mpc_t val;\n+  mpc_init2(val, mpc_precision);\n   switch (this->classification_)\n     {\n     case NC_INT:\n     case NC_RUNE:\n-      mpfr_init_set_z(real, this->u_.int_val, GMP_RNDN);\n-      mpfr_init_set_ui(imag, 0, GMP_RNDN);\n+      mpc_set_z(val, this->u_.int_val, MPC_RNDNN);\n       break;\n \n     case NC_FLOAT:\n-      mpfr_init_set(real, this->u_.float_val, GMP_RNDN);\n-      mpfr_init_set_ui(imag, 0, GMP_RNDN);\n+      mpc_set_fr(val, this->u_.float_val, MPC_RNDNN);\n       break;\n \n     case NC_COMPLEX:\n-      mpfr_init_set(real, this->u_.complex_val.real, GMP_RNDN);\n-      mpfr_init_set(imag, this->u_.complex_val.imag, GMP_RNDN);\n+      mpc_set(val, this->u_.complex_val, MPC_RNDNN);\n       break;\n \n     default:\n       go_unreachable();\n     }\n \n   bool ret = true;\n-  if (!mpfr_nan_p(real)\n-      && !mpfr_inf_p(real)\n-      && !mpfr_zero_p(real)\n-      && mpfr_get_exp(real) > max_exp)\n+  if (!mpfr_nan_p(mpc_realref(val))\n+      && !mpfr_inf_p(mpc_realref(val))\n+      && !mpfr_zero_p(mpc_realref(val))\n+      && mpfr_get_exp(mpc_realref(val)) > max_exp)\n     {\n       if (issue_error)\n \terror_at(location, \"complex real part overflow\");\n       ret = false;\n     }\n \n-  if (!mpfr_nan_p(imag)\n-      && !mpfr_inf_p(imag)\n-      && !mpfr_zero_p(imag)\n-      && mpfr_get_exp(imag) > max_exp)\n+  if (!mpfr_nan_p(mpc_imagref(val))\n+      && !mpfr_inf_p(mpc_imagref(val))\n+      && !mpfr_zero_p(mpc_imagref(val))\n+      && mpfr_get_exp(mpc_imagref(val)) > max_exp)\n     {\n       if (issue_error)\n \terror_at(location, \"complex imaginary part overflow\");\n@@ -15908,30 +15604,26 @@ Numeric_constant::check_complex_type(Complex_type* type, bool issue_error,\n   if (ret)\n     {\n       // Round the constant to the desired type.\n-      mpfr_t t;\n-      mpfr_init(t);\n+      mpc_t t;\n       switch (type->bits())\n \t{\n \tcase 64:\n-\t  mpfr_set_prec(t, 24);\n+\t  mpc_init2(t, 24);\n \t  break;\n \tcase 128:\n-\t  mpfr_set_prec(t, 53);\n+\t  mpc_init2(t, 53);\n \t  break;\n \tdefault:\n \t  go_unreachable();\n \t}\n-      mpfr_set(t, real, GMP_RNDN);\n-      mpfr_set(real, t, GMP_RNDN);\n-      mpfr_set(t, imag, GMP_RNDN);\n-      mpfr_set(imag, t, GMP_RNDN);\n-      mpfr_clear(t);\n+      mpc_set(t, val, MPC_RNDNN);\n+      mpc_set(val, t, MPC_RNDNN);\n+      mpc_clear(t);\n \n-      this->set_complex(type, real, imag);\n+      this->set_complex(type, val);\n     }\n \n-  mpfr_clear(real);\n-  mpfr_clear(imag);\n+  mpc_clear(val);\n \n   return ret;\n }\n@@ -15950,9 +15642,7 @@ Numeric_constant::expression(Location loc) const\n     case NC_FLOAT:\n       return Expression::make_float(&this->u_.float_val, this->type_, loc);\n     case NC_COMPLEX:\n-      return Expression::make_complex(&this->u_.complex_val.real,\n-\t\t\t\t      &this->u_.complex_val.imag,\n-\t\t\t\t      this->type_, loc);\n+      return Expression::make_complex(&this->u_.complex_val, this->type_, loc);\n     default:\n       go_unreachable();\n     }"}, {"sha": "b7e1806040d967b59705382a1b844b6a56ae4e25", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5eda5bad3c455d499b6a3611b433f2945caa239d", "patch": "@@ -8,6 +8,7 @@\n #define GO_EXPRESSIONS_H\n \n #include <mpfr.h>\n+#include <mpc.h>\n \n #include \"operator.h\"\n \n@@ -52,6 +53,9 @@ class Label;\n class Ast_dump_context;\n class String_dump;\n \n+// The precision to use for complex values represented as an mpc_t.\n+const int mpc_precision = 256;\n+\n // The base class for all expressions.\n \n class Expression\n@@ -237,7 +241,7 @@ class Expression\n   // Make a constant complex expression.  TYPE should be NULL for an\n   // abstract type.\n   static Expression*\n-  make_complex(const mpfr_t* real, const mpfr_t* imag, Type*, Location);\n+  make_complex(const mpc_t*, Type*, Location);\n \n   // Make a nil expression.\n   static Expression*\n@@ -2585,7 +2589,7 @@ class Numeric_constant\n \n   // Set to a complex value.\n   void\n-  set_complex(Type*, const mpfr_t, const mpfr_t);\n+  set_complex(Type*, const mpc_t);\n \n   // Classifiers.\n   bool\n@@ -2617,7 +2621,7 @@ class Numeric_constant\n   get_float(mpfr_t*) const;\n \n   void\n-  get_complex(mpfr_t*, mpfr_t*) const;\n+  get_complex(mpc_t*) const;\n \n   // Codes returned by to_unsigned_long.\n   enum To_unsigned_long\n@@ -2653,7 +2657,7 @@ class Numeric_constant\n   // If the value can be expressed as a complex, return true and\n   // initialize and set VR and VI.\n   bool\n-  to_complex(mpfr_t* vr, mpfr_t* vi) const;\n+  to_complex(mpc_t* val) const;\n \n   // Get the type.\n   Type*\n@@ -2709,11 +2713,7 @@ class Numeric_constant\n     // If NC_FLOAT.\n     mpfr_t float_val;\n     // If NC_COMPLEX.\n-    struct\n-    {\n-      mpfr_t real;\n-      mpfr_t imag;\n-    } complex_val;\n+    mpc_t complex_val;\n   } u_;\n   // The type if there is one.  This will be NULL for an untyped\n   // constant."}, {"sha": "d806b4789f1474661aa57e4cc731720b8c612f77", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eda5bad3c455d499b6a3611b433f2945caa239d/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=5eda5bad3c455d499b6a3611b433f2945caa239d", "patch": "@@ -2525,9 +2525,12 @@ Parse::operand(bool may_be_sink, bool* is_parenthesized)\n       {\n \tmpfr_t zero;\n \tmpfr_init_set_ui(zero, 0, GMP_RNDN);\n-\tret = Expression::make_complex(&zero, token->imaginary_value(),\n-\t\t\t\t       NULL, token->location());\n+\tmpc_t val;\n+\tmpc_init2(val, mpc_precision);\n+\tmpc_set_fr_fr(val, zero, *token->imaginary_value(), MPC_RNDNN);\n \tmpfr_clear(zero);\n+\tret = Expression::make_complex(&val, NULL, token->location());\n+\tmpc_clear(val);\n \tthis->advance_token();\n \treturn ret;\n       }"}]}