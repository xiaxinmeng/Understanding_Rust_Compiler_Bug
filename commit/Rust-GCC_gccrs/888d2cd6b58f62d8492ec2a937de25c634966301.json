{"sha": "888d2cd6b58f62d8492ec2a937de25c634966301", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg4ZDJjZDZiNThmNjJkODQ5MmVjMmE5MzdkZTI1YzYzNDk2NjMwMQ==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@debian.org", "date": "2004-10-12T19:28:56Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2004-10-12T19:28:56Z"}, "message": "* defaults.h (REGNO_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P)\n\t(MODE_BASE_REG_REG_CLASS, REGNO_MODE_OK_FOR_REG_BASE_P)\n\t(REG_MODE_OK_FOR_REG_BASE_P): Provide default definitions.\n\t* regclass.c (record_address_regs): Remove ifdef.  Use\n\tREG_MODE_OK_FOR_REG_BASE_P and MODE_BASE_REG_REG_CLASS.\n\t* regrename.c (REG_MODE_OK_FOR_BASE_P): Remove unnecessary\n\tdefinition.\n\t(scan_rtx_address, replace_oldest_value_addr): Use\n\tREG_MODE_OK_FOR_REG_BASE_P and MODE_BASE_REG_REG_CLASS.\n\t* reload.c (REGNO_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P): Remove\n\tunnecessary definitions.\n\t(find_reloads_address_1): Support REG_MODE_OK_FOR_REG_BASE_P\n\tand MODE_BASE_REG_REG_CLASS.\n\t* config/arm/arm.h (MODE_BASE_REG_CLASS): Don't check reload_completed.\n\t(MODE_BASE_REG_REG_CLASS): Define.\n\t(REGNO_MODE_OK_FOR_REG_BASE_P): Define.\n\t(REG_MODE_OK_FOR_REG_BASE_P): Define.\n\t* doc/tm.texi (Register Classes): Document MODE_BASE_REG_REG_CLASS,\n\tREG_MODE_OK_FOR_REG_BASE_P, and REGNO_MODE_OK_FOR_REG_BASE_P.\n\nFrom-SVN: r88948", "tree": {"sha": "32fb1749887c1bb5a4613d1d87b18c9a8537c8f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32fb1749887c1bb5a4613d1d87b18c9a8537c8f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/888d2cd6b58f62d8492ec2a937de25c634966301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/888d2cd6b58f62d8492ec2a937de25c634966301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/888d2cd6b58f62d8492ec2a937de25c634966301", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/888d2cd6b58f62d8492ec2a937de25c634966301/comments", "author": null, "committer": null, "parents": [{"sha": "3d4818fd4dfa6fec3d7603ef2b7e13dd8d661680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d4818fd4dfa6fec3d7603ef2b7e13dd8d661680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d4818fd4dfa6fec3d7603ef2b7e13dd8d661680"}], "stats": {"total": 241, "additions": 167, "deletions": 74}, "files": [{"sha": "23d9fcd53ab907b5f243fcf611b3c8190837e93a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=888d2cd6b58f62d8492ec2a937de25c634966301", "patch": "@@ -1,3 +1,25 @@\n+2004-10-12  Daniel Jacobowitz  <dan@debian.org>\n+\n+\t* defaults.h (REGNO_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P)\n+\t(MODE_BASE_REG_REG_CLASS, REGNO_MODE_OK_FOR_REG_BASE_P)\n+\t(REG_MODE_OK_FOR_REG_BASE_P): Provide default definitions.\n+\t* regclass.c (record_address_regs): Remove ifdef.  Use\n+\tREG_MODE_OK_FOR_REG_BASE_P and MODE_BASE_REG_REG_CLASS.\n+\t* regrename.c (REG_MODE_OK_FOR_BASE_P): Remove unnecessary\n+\tdefinition.\n+\t(scan_rtx_address, replace_oldest_value_addr): Use\n+\tREG_MODE_OK_FOR_REG_BASE_P and MODE_BASE_REG_REG_CLASS.\n+\t* reload.c (REGNO_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P): Remove\n+\tunnecessary definitions.\n+\t(find_reloads_address_1): Support REG_MODE_OK_FOR_REG_BASE_P\n+\tand MODE_BASE_REG_REG_CLASS.\n+\t* config/arm/arm.h (MODE_BASE_REG_CLASS): Don't check reload_completed.\n+\t(MODE_BASE_REG_REG_CLASS): Define.\n+\t(REGNO_MODE_OK_FOR_REG_BASE_P): Define.\n+\t(REG_MODE_OK_FOR_REG_BASE_P): Define.\n+\t* doc/tm.texi (Register Classes): Document MODE_BASE_REG_REG_CLASS,\n+\tREG_MODE_OK_FOR_REG_BASE_P, and REGNO_MODE_OK_FOR_REG_BASE_P.\n+\n 2004-10-12  Daniel Berlin <dberlin@dberlin.org>\n \n \t* tree-ssa-alias.c (verify_name_tags): New function."}, {"sha": "446062feea9b4339db02724e99cfd0215d7533c7", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=888d2cd6b58f62d8492ec2a937de25c634966301", "patch": "@@ -1218,12 +1218,14 @@ enum reg_class\n \n /* For the Thumb the high registers cannot be used as base registers\n    when addressing quantities in QI or HI mode; if we don't know the\n-   mode, then we must be conservative.  After reload we must also be\n-   conservative, since we can't support SP+reg addressing, and we\n-   can't fix up any bad substitutions.  */\n+   mode, then we must be conservative.  */\n #define MODE_BASE_REG_CLASS(MODE)\t\t\t\t\t\\\n     (TARGET_ARM ? GENERAL_REGS :\t\t\t\t\t\\\n-     (((MODE) == SImode && !reload_completed) ? BASE_REGS : LO_REGS))\n+     (((MODE) == SImode) ? BASE_REGS : LO_REGS))\n+\n+/* For Thumb we can not support SP+reg addressing, so we return LO_REGS\n+   instead of BASE_REGS.  */\n+#define MODE_BASE_REG_REG_CLASS(MODE) BASE_REG_CLASS\n \n /* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n@@ -1980,6 +1982,11 @@ typedef struct\n    ? THUMB_REGNO_MODE_OK_FOR_BASE_P (REGNO, MODE)\t\\\n    : ARM_REGNO_OK_FOR_BASE_P (REGNO))\n \n+/* Nonzero if X can be the base register in a reg+reg addressing mode.\n+   For Thumb, we can not use SP + reg, so reject SP.  */\n+#define REGNO_MODE_OK_FOR_REG_BASE_P(X, MODE)\t\\\n+  REGNO_OK_FOR_INDEX_P (X)\n+\n /* For ARM code, we don't care about the mode, but for Thumb, the index\n    must be suitable for use in a QImode load.  */\n #define REGNO_OK_FOR_INDEX_P(REGNO)\t\\\n@@ -2123,6 +2130,10 @@ typedef struct\n    ? THUMB_REG_OK_FOR_INDEX_P (X)\t\t\\\n    : ARM_REG_OK_FOR_INDEX_P (X))\n \n+/* Nonzero if X can be the base register in a reg+reg addressing mode.\n+   For Thumb, we can not use SP + reg, so reject SP.  */\n+#define REG_MODE_OK_FOR_REG_BASE_P(X, MODE)\t\\\n+  REG_OK_FOR_INDEX_P (X)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction."}, {"sha": "5aa667d9461162234e40505f9a1a260579fa2646", "filename": "gcc/defaults.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=888d2cd6b58f62d8492ec2a937de25c634966301", "patch": "@@ -577,13 +577,40 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #define\tTARGET_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n #endif\n \n+/* Some macros can be defined by the backend in either a mode-dependent\n+   or mode-independent form.  The compiler proper should only use the\n+   mode-dependent form, providing VOIDmode when the mode is unknown.\n+   We can't poison the macros because the backend may reference them.  */\n+\n+#ifndef REGNO_MODE_OK_FOR_BASE_P\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) REGNO_OK_FOR_BASE_P (REGNO)\n+#endif\n+\n+#ifndef REG_MODE_OK_FOR_BASE_P\n+#define REG_MODE_OK_FOR_BASE_P(REG, MODE) REG_OK_FOR_BASE_P (REG)\n+#endif\n+\n /* Determine the register class for registers suitable to be the base\n    address register in a MEM.  Allow the choice to be dependent upon\n    the mode of the memory access.  */\n #ifndef MODE_BASE_REG_CLASS\n #define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS\n #endif\n \n+/* Some machines require a different base register class if the index\n+   is a register.  By default, assume that a base register is acceptable.  */\n+#ifndef MODE_BASE_REG_REG_CLASS\n+#define MODE_BASE_REG_REG_CLASS(MODE) MODE_BASE_REG_CLASS(MODE)\n+#endif\n+\n+#ifndef REGNO_MODE_OK_FOR_REG_BASE_P\n+#define REGNO_MODE_OK_FOR_REG_BASE_P(REGNO, MODE) REGNO_MODE_OK_FOR_BASE_P (REGNO, MODE)\n+#endif\n+\n+#ifndef REG_MODE_OK_FOR_REG_BASE_P\n+#define REG_MODE_OK_FOR_REG_BASE_P(REGNO, MODE) REG_MODE_OK_FOR_BASE_P (REGNO, MODE)\n+#endif\n+\n #ifndef LARGEST_EXPONENT_IS_NORMAL\n #define LARGEST_EXPONENT_IS_NORMAL(SIZE) 0\n #endif"}, {"sha": "8ca2a9a4dc5b94a49a435d953a063b724c1911ed", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=888d2cd6b58f62d8492ec2a937de25c634966301", "patch": "@@ -2402,6 +2402,13 @@ the selection of a base register in a mode dependent manner.  If\n @code{BASE_REG_CLASS}.\n @end defmac\n \n+@defmac MODE_BASE_REG_REG_CLASS (@var{mode})\n+A C expression whose value is the register class to which a valid\n+base register must belong in order to be used in a base plus index\n+register address.  You should define this macro if base plus index\n+addresses have different requirements than other base register uses.\n+@end defmac\n+\n @defmac INDEX_REG_CLASS\n A macro whose definition is the name of the class to which a valid\n index register must belong.  An index register is one used in an\n@@ -2455,6 +2462,15 @@ you define this macro, the compiler will use it instead of\n @code{REGNO_OK_FOR_BASE_P}.\n @end defmac\n \n+@defmac REGNO_MODE_OK_FOR_REG_BASE_P (@var{num}, @var{mode})\n+A C expression which is nonzero if register number @var{num} is suitable for\n+use as a base register in base plus index operand addresses, accessing\n+memory in mode @var{mode}.  It may be either a suitable hard register or a\n+pseudo register that has been allocated such a hard register.  You should\n+define this macro if base plus index addresses have different requirements\n+than other base register uses.\n+@end defmac\n+\n @defmac REGNO_OK_FOR_INDEX_P (@var{num})\n A C expression which is nonzero if register number @var{num} is\n suitable for use as an index register in operand addresses.  It may be\n@@ -5003,6 +5019,15 @@ you define this macro, the compiler will use it instead of\n @code{REG_OK_FOR_BASE_P}.\n @end defmac\n \n+@defmac REG_MODE_OK_FOR_REG_BASE_P (@var{x}, @var{mode})\n+A C expression which is nonzero if @var{x} (assumed to be a @code{reg} RTX)\n+is suitable for use as a base register in base plus index operand addresses,\n+accessing memory in mode @var{mode}.  It may be either a suitable hard\n+register or a pseudo register that has been allocated such a hard register. \n+You should define this macro if base plus index addresses have different\n+requirements than other base register uses.\n+@end defmac\n+\n @defmac REG_OK_FOR_INDEX_P (@var{x})\n A C expression that is nonzero if @var{x} (assumed to be a @code{reg}\n RTX) is valid for use as an index register."}, {"sha": "c3abadd557a6093de270413a5ecebde38e161460", "filename": "gcc/regclass.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=888d2cd6b58f62d8492ec2a937de25c634966301", "patch": "@@ -2011,25 +2011,27 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \t  record_address_regs (arg0, INDEX_REG_CLASS, scale);\n \n \t/* If both operands are registers but one is already a hard register\n-\t   of index or base class, give the other the class that the hard\n-\t   register is not.  */\n+\t   of index or reg-base class, give the other the class that the\n+\t   hard register is not.  */\n \n-#ifdef REG_OK_FOR_BASE_P\n \telse if (code0 == REG && code1 == REG\n \t\t && REGNO (arg0) < FIRST_PSEUDO_REGISTER\n-\t\t && (REG_OK_FOR_BASE_P (arg0) || REG_OK_FOR_INDEX_P (arg0)))\n+\t\t && (REG_MODE_OK_FOR_REG_BASE_P (arg0, VOIDmode)\n+\t\t     || REG_OK_FOR_INDEX_P (arg0)))\n \t  record_address_regs (arg1,\n-\t\t\t       REG_OK_FOR_BASE_P (arg0)\n-\t\t\t       ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (VOIDmode),\n+\t\t\t       REG_MODE_OK_FOR_REG_BASE_P (arg0, VOIDmode)\n+\t\t\t       ? INDEX_REG_CLASS\n+\t\t\t       : MODE_BASE_REG_REG_CLASS (VOIDmode),\n \t\t\t       scale);\n \telse if (code0 == REG && code1 == REG\n \t\t && REGNO (arg1) < FIRST_PSEUDO_REGISTER\n-\t\t && (REG_OK_FOR_BASE_P (arg1) || REG_OK_FOR_INDEX_P (arg1)))\n+\t\t && (REG_MODE_OK_FOR_REG_BASE_P (arg1, VOIDmode)\n+\t\t     || REG_OK_FOR_INDEX_P (arg1)))\n \t  record_address_regs (arg0,\n-\t\t\t       REG_OK_FOR_BASE_P (arg1)\n-\t\t\t       ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (VOIDmode),\n+\t\t\t       REG_MODE_OK_FOR_REG_BASE_P (arg1, VOIDmode)\n+\t\t\t       ? INDEX_REG_CLASS\n+\t\t\t       : MODE_BASE_REG_REG_CLASS (VOIDmode),\n \t\t\t       scale);\n-#endif\n \n \t/* If one operand is known to be a pointer, it must be the base\n \t   with the other operand the index.  Likewise if the other operand\n@@ -2038,25 +2040,27 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \telse if ((code0 == REG && REG_POINTER (arg0))\n \t\t || code1 == MULT)\n \t  {\n-\t    record_address_regs (arg0, MODE_BASE_REG_CLASS (VOIDmode), scale);\n+\t    record_address_regs (arg0, MODE_BASE_REG_REG_CLASS (VOIDmode),\n+\t\t\t\t scale);\n \t    record_address_regs (arg1, INDEX_REG_CLASS, scale);\n \t  }\n \telse if ((code1 == REG && REG_POINTER (arg1))\n \t\t || code0 == MULT)\n \t  {\n \t    record_address_regs (arg0, INDEX_REG_CLASS, scale);\n-\t    record_address_regs (arg1, MODE_BASE_REG_CLASS (VOIDmode), scale);\n+\t    record_address_regs (arg1, MODE_BASE_REG_REG_CLASS (VOIDmode),\n+\t\t\t\t scale);\n \t  }\n \n \t/* Otherwise, count equal chances that each might be a base\n \t   or index register.  This case should be rare.  */\n \n \telse\n \t  {\n-\t    record_address_regs (arg0, MODE_BASE_REG_CLASS (VOIDmode),\n+\t    record_address_regs (arg0, MODE_BASE_REG_REG_CLASS (VOIDmode),\n \t\t\t\t scale / 2);\n \t    record_address_regs (arg0, INDEX_REG_CLASS, scale / 2);\n-\t    record_address_regs (arg1, MODE_BASE_REG_CLASS (VOIDmode),\n+\t    record_address_regs (arg1, MODE_BASE_REG_REG_CLASS (VOIDmode),\n \t\t\t\t scale / 2);\n \t    record_address_regs (arg1, INDEX_REG_CLASS, scale / 2);\n \t  }"}, {"sha": "dc2bb01780ed9bc4400791b11c74989ef5efd299", "filename": "gcc/regrename.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=888d2cd6b58f62d8492ec2a937de25c634966301", "patch": "@@ -36,10 +36,6 @@\n #include \"toplev.h\"\n #include \"obstack.h\"\n \n-#ifndef REG_MODE_OK_FOR_BASE_P\n-#define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n-#endif\n-\n static const char *const reg_class_names[] = REG_CLASS_NAMES;\n \n struct du_chain\n@@ -524,6 +520,7 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \trtx op1 = orig_op1;\n \trtx *locI = NULL;\n \trtx *locB = NULL;\n+\trtx *locB_reg = NULL;\n \n \tif (GET_CODE (op0) == SUBREG)\n \t  {\n@@ -560,22 +557,22 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \t    int index_op;\n \n \t    if (REG_OK_FOR_INDEX_P (op0)\n-\t\t&& REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t\t&& REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n \t      index_op = 0;\n \t    else if (REG_OK_FOR_INDEX_P (op1)\n-\t\t     && REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t\t     && REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n \t      index_op = 1;\n-\t    else if (REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n \t      index_op = 0;\n-\t    else if (REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n \t      index_op = 1;\n \t    else if (REG_OK_FOR_INDEX_P (op1))\n \t      index_op = 1;\n \t    else\n \t      index_op = 0;\n \n \t    locI = &XEXP (x, index_op);\n-\t    locB = &XEXP (x, !index_op);\n+\t    locB_reg = &XEXP (x, !index_op);\n \t  }\n \telse if (code0 == REG)\n \t  {\n@@ -592,6 +589,9 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \t  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode);\n \tif (locB)\n \t  scan_rtx_address (insn, locB, MODE_BASE_REG_CLASS (mode), action, mode);\n+\tif (locB_reg)\n+\t  scan_rtx_address (insn, locB_reg, MODE_BASE_REG_REG_CLASS (mode),\n+\t\t\t    action, mode);\n \treturn;\n       }\n \n@@ -1415,6 +1415,7 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \trtx op1 = orig_op1;\n \trtx *locI = NULL;\n \trtx *locB = NULL;\n+\trtx *locB_reg = NULL;\n \n \tif (GET_CODE (op0) == SUBREG)\n \t  {\n@@ -1451,22 +1452,22 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \t    int index_op;\n \n \t    if (REG_OK_FOR_INDEX_P (op0)\n-\t\t&& REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t\t&& REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n \t      index_op = 0;\n \t    else if (REG_OK_FOR_INDEX_P (op1)\n-\t\t     && REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t\t     && REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n \t      index_op = 1;\n-\t    else if (REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n \t      index_op = 0;\n-\t    else if (REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n \t      index_op = 1;\n \t    else if (REG_OK_FOR_INDEX_P (op1))\n \t      index_op = 1;\n \t    else\n \t      index_op = 0;\n \n \t    locI = &XEXP (x, index_op);\n-\t    locB = &XEXP (x, !index_op);\n+\t    locB_reg = &XEXP (x, !index_op);\n \t  }\n \telse if (code0 == REG)\n \t  {\n@@ -1486,6 +1487,10 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \t  changed |= replace_oldest_value_addr (locB,\n \t\t\t\t\t\tMODE_BASE_REG_CLASS (mode),\n \t\t\t\t\t\tmode, insn, vd);\n+\tif (locB_reg)\n+\t  changed |= replace_oldest_value_addr (locB_reg,\n+\t\t\t\t\t\tMODE_BASE_REG_REG_CLASS (mode),\n+\t\t\t\t\t\tmode, insn, vd);\n \treturn changed;\n       }\n "}, {"sha": "f6a008d957df03aae610706219fbccc7eb46ca5b", "filename": "gcc/reload.c", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888d2cd6b58f62d8492ec2a937de25c634966301/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=888d2cd6b58f62d8492ec2a937de25c634966301", "patch": "@@ -108,14 +108,6 @@ a register with any other reload.  */\n #include \"params.h\"\n #include \"target.h\"\n \n-#ifndef REGNO_MODE_OK_FOR_BASE_P\n-#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) REGNO_OK_FOR_BASE_P (REGNO)\n-#endif\n-\n-#ifndef REG_MODE_OK_FOR_BASE_P\n-#define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n-#endif\n-\n /* True if X is a constant that can be forced into the constant pool.  */\n #define CONST_POOL_OK_P(X)\t\t\t\\\n   (CONSTANT_P (X)\t\t\t\t\\\n@@ -5227,7 +5219,8 @@ update_auto_inc_notes (rtx insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n    is strictly valid.)\n \n    CONTEXT = 1 means we are considering regs as index regs,\n-   = 0 means we are considering them as base regs.\n+   = 0 means we are considering them as base regs, = 2 means we\n+   are considering them as base regs for REG + REG.\n \n    OPNUM and TYPE specify the purpose of any reloads made.\n \n@@ -5250,8 +5243,23 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t\trtx *loc, int opnum, enum reload_type type,\n \t\t\tint ind_levels, rtx insn)\n {\n+#define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE)\t\t\\\n+  ((CONTEXT) == 2\t\t\t\t\t\\\n+   ? REGNO_MODE_OK_FOR_REG_BASE_P (REGNO, MODE)\t\t\\\n+   : (CONTEXT) == 1\t\t\t\t\t\\\n+   ? REGNO_OK_FOR_INDEX_P (REGNO)\t\t\t\\\n+   : REGNO_MODE_OK_FOR_BASE_P (REGNO, MODE))\n+\n+  enum reg_class context_reg_class;\n   RTX_CODE code = GET_CODE (x);\n \n+  if (context == 2)\n+    context_reg_class = MODE_BASE_REG_REG_CLASS (mode);\n+  else if (context == 1)\n+    context_reg_class = INDEX_REG_CLASS;\n+  else\n+    context_reg_class = MODE_BASE_REG_CLASS (mode);\n+\n   switch (code)\n     {\n     case PLUS:\n@@ -5294,12 +5302,12 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t   register remateralization for expression like &localvar*4.  Reload it.\n \t   It may be possible to combine the displacement on the outer level,\n \t   but it is probably not worthwhile to do so.  */\n-\tif (context)\n+\tif (context == 1)\n \t  {\n \t    find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t\t  opnum, ADDR_TYPE (type), ind_levels, insn);\n \t    push_reload (*loc, NULL_RTX, loc, (rtx*) 0,\n-\t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n+\t\t\t context_reg_class,\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n@@ -5335,22 +5343,22 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \telse if (code0 == REG && code1 == REG)\n \t  {\n \t    if (REG_OK_FOR_INDEX_P (op0)\n-\t\t&& REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t\t&& REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n \t      return 0;\n \t    else if (REG_OK_FOR_INDEX_P (op1)\n-\t\t     && REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t\t     && REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n \t      return 0;\n-\t    else if (REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n \t      find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n \t\t\t\t      type, ind_levels, insn);\n-\t    else if (REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n \t      find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n \t\t\t\t      type, ind_levels, insn);\n \t    else if (REG_OK_FOR_INDEX_P (op1))\n-\t      find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n+\t      find_reloads_address_1 (mode, orig_op0, 2, &XEXP (x, 0), opnum,\n \t\t\t\t      type, ind_levels, insn);\n \t    else if (REG_OK_FOR_INDEX_P (op0))\n-\t      find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n+\t      find_reloads_address_1 (mode, orig_op1, 2, &XEXP (x, 1), opnum,\n \t\t\t\t      type, ind_levels, insn);\n \t    else\n \t      {\n@@ -5514,9 +5522,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \n \t  if (reg_renumber[regno] >= 0)\n \t    regno = reg_renumber[regno];\n-\t  if ((regno >= FIRST_PSEUDO_REGISTER\n-\t       || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t    : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n+\t  if (regno >= FIRST_PSEUDO_REGISTER\n+\t      || !REG_OK_FOR_CONTEXT (context, regno, mode))\n \t    {\n \t      int reloadnum;\n \n@@ -5552,17 +5559,15 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t  x = XEXP (x, 0);\n \t\t  reloadnum\n \t\t    = push_reload (x, x, loc, loc,\n-\t\t\t\t   (context ? INDEX_REG_CLASS :\n-\t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n+\t\t\t\t   context_reg_class,\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t   opnum, RELOAD_OTHER);\n \t\t}\n \t      else\n \t\t{\n \t\t  reloadnum\n \t\t    = push_reload (x, NULL_RTX, loc, (rtx*) 0,\n-\t\t\t\t   (context ? INDEX_REG_CLASS :\n-\t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n+\t\t\t\t   context_reg_class,\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t   opnum, type);\n \t\t  rld[reloadnum].inc\n@@ -5602,8 +5607,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t\t\topnum, type, ind_levels, insn);\n \n \t  reloadnum = push_reload (x, NULL_RTX, loc, (rtx*) 0,\n-\t\t\t\t   (context ? INDEX_REG_CLASS :\n-\t\t\t\t    MODE_BASE_REG_CLASS (mode)),\n+\t\t\t\t   context_reg_class,\n \t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t  rld[reloadnum].inc\n \t    = find_inc_amount (PATTERN (this_insn), XEXP (x, 0));\n@@ -5632,7 +5636,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t    opnum, ADDR_TYPE (type), ind_levels, insn);\n       push_reload (*loc, NULL_RTX, loc, (rtx*) 0,\n-\t\t   (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n+\t\t   context_reg_class,\n \t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n       return 1;\n \n@@ -5643,8 +5647,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif (reg_equiv_constant[regno] != 0)\n \t  {\n \t    find_reloads_address_part (reg_equiv_constant[regno], loc,\n-\t\t\t\t       (context ? INDEX_REG_CLASS :\n-\t\t\t\t\tMODE_BASE_REG_CLASS (mode)),\n+\t\t\t\t       context_reg_class,\n \t\t\t\t       GET_MODE (x), opnum, type, ind_levels);\n \t    return 1;\n \t  }\n@@ -5654,8 +5657,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif (reg_equiv_mem[regno] != 0)\n \t  {\n \t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, (rtx*) 0,\n-\t\t\t (context ? INDEX_REG_CLASS :\n-\t\t\t  MODE_BASE_REG_CLASS (mode)),\n+\t\t\t context_reg_class,\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n@@ -5678,12 +5680,11 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif (reg_renumber[regno] >= 0)\n \t  regno = reg_renumber[regno];\n \n-\tif ((regno >= FIRST_PSEUDO_REGISTER\n-\t     || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t  : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n+\tif (regno >= FIRST_PSEUDO_REGISTER\n+\t    || !REG_OK_FOR_CONTEXT (context, regno, mode))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, (rtx*) 0,\n-\t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n+\t\t\t context_reg_class,\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n@@ -5695,7 +5696,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif (regno_clobbered_p (regno, this_insn, GET_MODE (x), 0))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, (rtx*) 0,\n-\t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n+\t\t\t context_reg_class,\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n@@ -5712,12 +5713,10 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t    {\n \t      int regno ATTRIBUTE_UNUSED = subreg_regno (x);\n \n-\t      if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t     : REGNO_MODE_OK_FOR_BASE_P (regno, mode)))\n+\t      if (! REG_OK_FOR_CONTEXT (context, regno, mode))\n \t\t{\n \t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0,\n-\t\t\t       (context ? INDEX_REG_CLASS :\n-\t\t\t\tMODE_BASE_REG_CLASS (mode)),\n+\t\t\t       context_reg_class,\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n \t\t}\n@@ -5726,8 +5725,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t     is larger than the class size, then reload the whole SUBREG.  */\n \t  else\n \t    {\n-\t      enum reg_class class = (context ? INDEX_REG_CLASS\n-\t\t\t\t      : MODE_BASE_REG_CLASS (mode));\n+\t      enum reg_class class = context_reg_class;\n \t      if ((unsigned) CLASS_MAX_NREGS (class, GET_MODE (SUBREG_REG (x)))\n \t\t  > reg_class_size[class])\n \t\t{\n@@ -5757,6 +5755,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n       }\n   }\n \n+#undef REG_OK_FOR_CONTEXT\n   return 0;\n }\n \f"}]}