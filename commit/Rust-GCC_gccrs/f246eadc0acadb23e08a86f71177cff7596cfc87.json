{"sha": "f246eadc0acadb23e08a86f71177cff7596cfc87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI0NmVhZGMwYWNhZGIyM2UwOGE4NmY3MTE3N2NmZjc1OTZjZmM4Nw==", "commit": {"author": {"name": "Jack Howarth", "email": "howarth@bromo.med.uc.edu", "date": "2012-11-24T18:24:13Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2012-11-24T18:24:13Z"}, "message": "[libsanitizer] add mach_override and enable libsanitizer on darwin\n\nFrom-SVN: r193781", "tree": {"sha": "a4cc714b9f3e72f81729db56491c1ddec5d0811c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4cc714b9f3e72f81729db56491c1ddec5d0811c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f246eadc0acadb23e08a86f71177cff7596cfc87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f246eadc0acadb23e08a86f71177cff7596cfc87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f246eadc0acadb23e08a86f71177cff7596cfc87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f246eadc0acadb23e08a86f71177cff7596cfc87/comments", "author": null, "committer": null, "parents": [{"sha": "9f1b2dcbad84010f9014de2cd608154cbac53d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1b2dcbad84010f9014de2cd608154cbac53d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f1b2dcbad84010f9014de2cd608154cbac53d9b"}], "stats": {"total": 1224, "additions": 1217, "deletions": 7}, "files": [{"sha": "3bcbf790ed4c01459ca9c190ce63c6a70a22ef0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -1,3 +1,7 @@\n+2012-11-24  Jack Howarth <howarth@bromo.med.uc.edu>\n+\n+\t* config/darwin.h (LINK_COMMAND_SPEC_A): Deal with -fsanitize=address.\n+\n 2012-11-24  Matthias Klose  <doko@ubuntu.com>\n \n \t* configure.ac (multiarch): Use $enableval instead of $withval."}, {"sha": "0eb3474ecdd714b34b4b70b1433cb92584fc9bde", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -180,6 +180,9 @@ extern GTY(()) int darwin_ms_struct;\n     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n     %{fopenmp|ftree-parallelize-loops=*: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n+    %{fsanitize=address: \\\n+      %{static|static-libasan|static-libgcc|static-libgfortran: -framework CoreFoundation -lstdc++ libasan.a%s; \\\n+      static-libstdc++: -framework CoreFoundation libstdc++.a%s libasan.a%s; : -framework CoreFoundation -lasan } } \\\n     %{fgnu-tm: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libitm.a%s; : -litm } } \\\n     %{!nostdlib:%{!nodefaultlibs:\\"}, {"sha": "90053021bd5358936d9d8b64ab0166fdd4d0dc01", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -1,3 +1,16 @@\n+2012-11-24  Kostya Serebryany kcc@google.com\n+\t    Jack Howarth <howarth@bromo.med.uc.edu>\n+\n+\t* interception/mach_override/mach_override.c: Migrate from llvm.\n+\t* interception/mach_override/mach_override.h: Likewise.\n+\t* interception/mach_override/LICENSE.txt: Likewise.\n+\t* configure.tgt: Add darwin to supported targets.\n+\t* configure.ac: Define USING_MACH_OVERRIDE when on darwin.\n+\t* interception/Makefile.am: Compile mach_override.c when\n+\tUSING_MACH_OVERRIDE defined.\n+\t* configure: Regenerated.\n+\t* interception/Makefile.in: Likewise.\n+\n 2012-11-23  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR sanitizer/55450"}, {"sha": "48f984c7bbbb493f5dd5bf99757c191f83601e64", "filename": "libsanitizer/configure", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -604,6 +604,8 @@ ac_subst_vars='am__EXEEXT_FALSE\n am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n+USING_MACH_OVERRIDE_FALSE\n+USING_MACH_OVERRIDE_TRUE\n TSAN_SUPPORTED_FALSE\n TSAN_SUPPORTED_TRUE\n enable_static\n@@ -11078,7 +11080,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11081 \"configure\"\n+#line 11083 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11184,7 +11186,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11187 \"configure\"\n+#line 11189 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -14494,6 +14496,19 @@ else\n fi\n \n \n+case \"$host\" in\n+  *-*-darwin*) MACH_OVERRIDE=true ;;\n+  *) MACH_OVERRIDE=false ;;\n+esac\n+ if $MACH_OVERRIDE; then\n+  USING_MACH_OVERRIDE_TRUE=\n+  USING_MACH_OVERRIDE_FALSE='#'\n+else\n+  USING_MACH_OVERRIDE_TRUE='#'\n+  USING_MACH_OVERRIDE_FALSE=\n+fi\n+\n+\n ac_config_files=\"$ac_config_files Makefile\"\n \n \n@@ -14670,6 +14685,10 @@ if test -z \"${TSAN_SUPPORTED_TRUE}\" && test -z \"${TSAN_SUPPORTED_FALSE}\"; then\n   as_fn_error \"conditional \\\"TSAN_SUPPORTED\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${USING_MACH_OVERRIDE_TRUE}\" && test -z \"${USING_MACH_OVERRIDE_FALSE}\"; then\n+  as_fn_error \"conditional \\\"USING_MACH_OVERRIDE\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n \n : ${CONFIG_STATUS=./config.status}\n ac_write_fail=0"}, {"sha": "2d62ec4ecc0eb6b31938247037bd6f3e89183a28", "filename": "libsanitizer/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -80,6 +80,12 @@ unset TSAN_SUPPORTED\n . ${srcdir}/configure.tgt\n AM_CONDITIONAL(TSAN_SUPPORTED, [test \"x$TSAN_SUPPORTED\" = \"xyes\"])\n \n+case \"$host\" in\n+  *-*-darwin*) MACH_OVERRIDE=true ;;\n+  *) MACH_OVERRIDE=false ;;\n+esac\n+AM_CONDITIONAL(USING_MACH_OVERRIDE, $MACH_OVERRIDE)\n+\n AC_CONFIG_FILES([Makefile])\n \n AC_CONFIG_FILES(AC_FOREACH([DIR], [interception sanitizer_common asan], [DIR/Makefile ]),"}, {"sha": "26335391c4a39b1b50c81a3de213e043d534a94a", "filename": "libsanitizer/configure.tgt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.tgt?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -27,6 +27,9 @@ case \"${target}\" in\n \t;;\n   sparc*-*-linux*)\n \t;;\n+  x86_64-*-darwin* | i?86-*-darwin*)\n+\tTSAN_SUPPORTED=no\n+\t;;\n   *)\n \tUNSUPPORTED=1\n \t;;"}, {"sha": "029417f46e517f326b6682cf43dbcbac858829b3", "filename": "libsanitizer/interception/Makefile.am", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.am?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -14,7 +14,11 @@ interception_files = \\\n         interception_mac.cc \\\n         interception_win.cc\n \n-libinterception_la_SOURCES = $(interception_files) \n+if USING_MACH_OVERRIDE\n+libinterception_la_SOURCES = $(interception_files) mach_override/mach_override.c\n+else\n+libinterception_la_SOURCES = $(interception_files)\n+endif\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "bd58c4d47a069e943e18385233873f3c17820b6f", "filename": "libsanitizer/interception/Makefile.in", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.in?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -53,14 +53,29 @@ CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libinterception_la_LIBADD =\n+am__libinterception_la_SOURCES_DIST = interception_linux.cc \\\n+\tinterception_mac.cc interception_win.cc \\\n+\tmach_override/mach_override.c\n am__objects_1 = interception_linux.lo interception_mac.lo \\\n \tinterception_win.lo\n-am_libinterception_la_OBJECTS = $(am__objects_1)\n+@USING_MACH_OVERRIDE_FALSE@am_libinterception_la_OBJECTS =  \\\n+@USING_MACH_OVERRIDE_FALSE@\t$(am__objects_1)\n+@USING_MACH_OVERRIDE_TRUE@am_libinterception_la_OBJECTS =  \\\n+@USING_MACH_OVERRIDE_TRUE@\t$(am__objects_1) mach_override.lo\n libinterception_la_OBJECTS = $(am_libinterception_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n am__depfiles_maybe = depfiles\n am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -71,7 +86,7 @@ CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libinterception_la_SOURCES)\n-DIST_SOURCES = $(libinterception_la_SOURCES)\n+DIST_SOURCES = $(am__libinterception_la_SOURCES_DIST)\n ETAGS = etags\n CTAGS = ctags\n DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n@@ -215,7 +230,8 @@ interception_files = \\\n         interception_mac.cc \\\n         interception_win.cc\n \n-libinterception_la_SOURCES = $(interception_files) \n+@USING_MACH_OVERRIDE_FALSE@libinterception_la_SOURCES = $(interception_files)\n+@USING_MACH_OVERRIDE_TRUE@libinterception_la_SOURCES = $(interception_files) mach_override/mach_override.c\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n@@ -261,7 +277,7 @@ MAKEOVERRIDES =\n all: all-am\n \n .SUFFIXES:\n-.SUFFIXES: .cc .lo .o .obj\n+.SUFFIXES: .c .cc .lo .o .obj\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n \t  case '$(am__configure_deps)' in \\\n@@ -313,6 +329,35 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mach_override.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+mach_override.lo: mach_override/mach_override.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mach_override.lo -MD -MP -MF $(DEPDIR)/mach_override.Tpo -c -o mach_override.lo `test -f 'mach_override/mach_override.c' || echo '$(srcdir)/'`mach_override/mach_override.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/mach_override.Tpo $(DEPDIR)/mach_override.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='mach_override/mach_override.c' object='mach_override.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o mach_override.lo `test -f 'mach_override/mach_override.c' || echo '$(srcdir)/'`mach_override/mach_override.c\n \n .cc.o:\n @am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<"}, {"sha": "9446965176cedef047f0930dfe550db4ba2389fb", "filename": "libsanitizer/interception/mach_override/LICENSE.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2Fmach_override%2FLICENSE.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2Fmach_override%2FLICENSE.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Fmach_override%2FLICENSE.txt?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -0,0 +1,3 @@\n+Copyright (c) 2003-2009 Jonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n+Some rights reserved: <http://opensource.org/licenses/mit-license.php>\n+"}, {"sha": "7511a7bebb82075a17c360cee7591b0727fdf4d7", "filename": "libsanitizer/interception/mach_override/mach_override.c", "status": "added", "additions": 970, "deletions": 0, "changes": 970, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.c?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -0,0 +1,970 @@\n+/*******************************************************************************\n+\tmach_override.c\n+\t\tCopyright (c) 2003-2009 Jonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n+\t\tSome rights reserved: <http://opensource.org/licenses/mit-license.php>\n+\n+\t***************************************************************************/\n+#ifdef __APPLE__\n+\n+#include \"mach_override.h\"\n+\n+#include <mach-o/dyld.h>\n+#include <mach/mach_host.h>\n+#include <mach/mach_init.h>\n+#include <mach/vm_map.h>\n+#include <sys/mman.h>\n+\n+#include <CoreServices/CoreServices.h>\n+\n+//#define DEBUG_DISASM 1\n+#undef DEBUG_DISASM\n+\n+/**************************\n+*\t\n+*\tConstants\n+*\t\n+**************************/\n+#pragma mark\t-\n+#pragma mark\t(Constants)\n+\n+#if defined(__ppc__) || defined(__POWERPC__)\n+\n+static\n+long kIslandTemplate[] = {\n+\t0x9001FFFC,\t//\tstw\t\tr0,-4(SP)\n+\t0x3C00DEAD,\t//\tlis\t\tr0,0xDEAD\n+\t0x6000BEEF,\t//\tori\t\tr0,r0,0xBEEF\n+\t0x7C0903A6,\t//\tmtctr\tr0\n+\t0x8001FFFC,\t//\tlwz\t\tr0,-4(SP)\n+\t0x60000000,\t//\tnop\t\t; optionally replaced\n+\t0x4E800420 \t//\tbctr\n+};\n+\n+#define kAddressHi\t\t\t3\n+#define kAddressLo\t\t\t5\n+#define kInstructionHi\t\t10\n+#define kInstructionLo\t\t11\n+\n+#elif defined(__i386__) \n+\n+#define kOriginalInstructionsSize 16\n+\n+static\n+unsigned char kIslandTemplate[] = {\n+\t// kOriginalInstructionsSize nop instructions so that we \n+\t// should have enough space to host original instructions \n+\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, \n+\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n+\t// Now the real jump instruction\n+\t0xE9, 0xEF, 0xBE, 0xAD, 0xDE\n+};\n+\n+#define kInstructions\t0\n+#define kJumpAddress    kInstructions + kOriginalInstructionsSize + 1\n+#elif defined(__x86_64__)\n+\n+#define kOriginalInstructionsSize 32\n+\n+#define kJumpAddress    kOriginalInstructionsSize + 6\n+\n+static\n+unsigned char kIslandTemplate[] = {\n+\t// kOriginalInstructionsSize nop instructions so that we \n+\t// should have enough space to host original instructions \n+\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, \n+\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n+\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, \n+\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n+\t// Now the real jump instruction\n+\t0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00\n+};\n+\n+#endif\n+\n+#define\tkAllocateHigh\t\t1\n+#define\tkAllocateNormal\t\t0\n+\n+/**************************\n+*\t\n+*\tData Types\n+*\t\n+**************************/\n+#pragma mark\t-\n+#pragma mark\t(Data Types)\n+\n+typedef\tstruct\t{\n+\tchar\tinstructions[sizeof(kIslandTemplate)];\n+\tint\t\tallocatedHigh;\n+}\tBranchIsland;\n+\n+/**************************\n+*\t\n+*\tFunky Protos\n+*\t\n+**************************/\n+#pragma mark\t-\n+#pragma mark\t(Funky Protos)\n+\n+\n+\tstatic mach_error_t\n+allocateBranchIsland(\n+\t\tBranchIsland\t**island,\n+\t\tint\t\t\t\tallocateHigh,\n+\t\tvoid *originalFunctionAddress);\n+\n+\tstatic mach_error_t\n+freeBranchIsland(\n+\t\tBranchIsland\t*island );\n+\n+\tstatic mach_error_t\n+defaultIslandMalloc(\n+\t  void **ptr, size_t unused_size, void *hint);\n+\n+\tstatic mach_error_t\n+defaultIslandFree(\n+   \tvoid *ptr);\n+\n+#if defined(__ppc__) || defined(__POWERPC__)\n+\tstatic mach_error_t\n+setBranchIslandTarget(\n+\t\tBranchIsland\t*island,\n+\t\tconst void\t\t*branchTo,\n+\t\tlong\t\t\tinstruction );\n+#endif \n+\n+#if defined(__i386__) || defined(__x86_64__)\n+static mach_error_t\n+setBranchIslandTarget_i386(\n+\t\t\t\t\t\t   BranchIsland\t*island,\n+\t\t\t\t\t\t   const void\t\t*branchTo,\n+\t\t\t\t\t\t   char*\t\t\tinstructions );\n+// Can't be made static because there's no C implementation for atomic_mov64\n+// on i386.\n+void \n+atomic_mov64(\n+\t\tuint64_t *targetAddress,\n+\t\tuint64_t value ) __attribute__((visibility(\"hidden\")));\n+\n+\tstatic Boolean \n+eatKnownInstructions( \n+\tunsigned char\t*code, \n+\tuint64_t\t\t*newInstruction,\n+\tint\t\t\t\t*howManyEaten, \n+\tchar\t\t\t*originalInstructions,\n+\tint\t\t\t\t*originalInstructionCount, \n+\tuint8_t\t\t\t*originalInstructionSizes );\n+\n+\tstatic void\n+fixupInstructions(\n+    void\t\t*originalFunction,\n+    void\t\t*escapeIsland,\n+    void\t\t*instructionsToFix,\n+\tint\t\t\tinstructionCount,\n+\tuint8_t\t\t*instructionSizes );\n+\n+#ifdef DEBUG_DISASM\n+\tstatic void\n+dump16Bytes(\n+\tvoid\t*ptr);\n+#endif  // DEBUG_DISASM\n+#endif\n+\n+/*******************************************************************************\n+*\t\n+*\tInterface\n+*\t\n+*******************************************************************************/\n+#pragma mark\t-\n+#pragma mark\t(Interface)\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+static mach_error_t makeIslandExecutable(void *address) {\n+\tmach_error_t err = err_none;\n+    vm_size_t pageSize;\n+    host_page_size( mach_host_self(), &pageSize );\n+    uintptr_t page = (uintptr_t)address & ~(uintptr_t)(pageSize-1);\n+    int e = err_none;\n+    e |= mprotect((void *)page, pageSize, PROT_EXEC | PROT_READ | PROT_WRITE);\n+    e |= msync((void *)page, pageSize, MS_INVALIDATE );\n+    if (e) {\n+        err = err_cannot_override;\n+    }\n+    return err;\n+}\n+#endif\n+\n+\t\tstatic mach_error_t\n+defaultIslandMalloc(\n+\tvoid **ptr, size_t unused_size, void *hint) {\n+  return allocateBranchIsland( (BranchIsland**)ptr, kAllocateHigh, hint );\n+}\n+\t\tstatic mach_error_t\n+defaultIslandFree(\n+\tvoid *ptr) {\n+\treturn freeBranchIsland(ptr);\n+}\n+\n+    mach_error_t\n+__asan_mach_override_ptr(\n+\tvoid *originalFunctionAddress,\n+    const void *overrideFunctionAddress,\n+    void **originalFunctionReentryIsland )\n+{\n+  return __asan_mach_override_ptr_custom(originalFunctionAddress,\n+\t\toverrideFunctionAddress,\n+\t\toriginalFunctionReentryIsland,\n+\t\tdefaultIslandMalloc,\n+\t\tdefaultIslandFree);\n+}\n+\n+    mach_error_t\n+__asan_mach_override_ptr_custom(\n+\tvoid *originalFunctionAddress,\n+    const void *overrideFunctionAddress,\n+    void **originalFunctionReentryIsland,\n+\t\tisland_malloc *alloc,\n+\t\tisland_free *dealloc)\n+{\n+\tassert( originalFunctionAddress );\n+\tassert( overrideFunctionAddress );\n+\t\n+\t// this addresses overriding such functions as AudioOutputUnitStart()\n+\t// test with modified DefaultOutputUnit project\n+#if defined(__x86_64__)\n+    for(;;){\n+        if(*(uint16_t*)originalFunctionAddress==0x25FF)    // jmp qword near [rip+0x????????]\n+            originalFunctionAddress=*(void**)((char*)originalFunctionAddress+6+*(int32_t *)((uint16_t*)originalFunctionAddress+1));\n+        else break;\n+    }\n+#elif defined(__i386__)\n+    for(;;){\n+        if(*(uint16_t*)originalFunctionAddress==0x25FF)    // jmp *0x????????\n+            originalFunctionAddress=**(void***)((uint16_t*)originalFunctionAddress+1);\n+        else break;\n+    }\n+#endif\n+#ifdef DEBUG_DISASM\n+  {\n+    fprintf(stderr, \"Replacing function at %p\\n\", originalFunctionAddress);\n+    fprintf(stderr, \"First 16 bytes of the function: \");\n+    unsigned char *orig = (unsigned char *)originalFunctionAddress;\n+    int i;\n+    for (i = 0; i < 16; i++) {\n+       fprintf(stderr, \"%x \", (unsigned int) orig[i]);\n+    }\n+    fprintf(stderr, \"\\n\");\n+    fprintf(stderr, \n+            \"To disassemble, save the following function as disas.c\"\n+            \" and run:\\n  gcc -c disas.c && gobjdump -d disas.o\\n\"\n+            \"The first 16 bytes of the original function will start\"\n+            \" after four nop instructions.\\n\");\n+    fprintf(stderr, \"\\nvoid foo() {\\n  asm volatile(\\\"nop;nop;nop;nop;\\\");\\n\");\n+    int j = 0;\n+    for (j = 0; j < 2; j++) {\n+      fprintf(stderr, \"  asm volatile(\\\".byte \");\n+      for (i = 8 * j; i < 8 * (j+1) - 1; i++) {\n+        fprintf(stderr, \"0x%x, \", (unsigned int) orig[i]);\n+      }\n+      fprintf(stderr, \"0x%x;\\\");\\n\", (unsigned int) orig[8 * (j+1) - 1]);\n+    }\n+    fprintf(stderr, \"}\\n\\n\");\n+  }\n+#endif\n+\n+\tlong\t*originalFunctionPtr = (long*) originalFunctionAddress;\n+\tmach_error_t\terr = err_none;\n+\t\n+#if defined(__ppc__) || defined(__POWERPC__)\n+\t//\tEnsure first instruction isn't 'mfctr'.\n+\t#define\tkMFCTRMask\t\t\t0xfc1fffff\n+\t#define\tkMFCTRInstruction\t0x7c0903a6\n+\t\n+\tlong\toriginalInstruction = *originalFunctionPtr;\n+\tif( !err && ((originalInstruction & kMFCTRMask) == kMFCTRInstruction) )\n+\t\terr = err_cannot_override;\n+#elif defined(__i386__) || defined(__x86_64__)\n+\tint eatenCount = 0;\n+\tint originalInstructionCount = 0;\n+\tchar originalInstructions[kOriginalInstructionsSize];\n+\tuint8_t originalInstructionSizes[kOriginalInstructionsSize];\n+\tuint64_t jumpRelativeInstruction = 0; // JMP\n+\n+\tBoolean overridePossible = eatKnownInstructions ((unsigned char *)originalFunctionPtr, \n+\t\t\t\t\t\t\t\t\t\t&jumpRelativeInstruction, &eatenCount, \n+\t\t\t\t\t\t\t\t\t\toriginalInstructions, &originalInstructionCount, \n+\t\t\t\t\t\t\t\t\t\toriginalInstructionSizes );\n+#ifdef DEBUG_DISASM\n+  if (!overridePossible) fprintf(stderr, \"overridePossible = false @%d\\n\", __LINE__);\n+#endif\n+\tif (eatenCount > kOriginalInstructionsSize) {\n+#ifdef DEBUG_DISASM\n+\t\tfprintf(stderr, \"Too many instructions eaten\\n\");\n+#endif    \n+\t\toverridePossible = false;\n+\t}\n+\tif (!overridePossible) err = err_cannot_override;\n+\tif (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n+#endif\n+\t\n+\t//\tMake the original function implementation writable.\n+\tif( !err ) {\n+\t\terr = vm_protect( mach_task_self(),\n+\t\t\t\t(vm_address_t) originalFunctionPtr, 8, false,\n+\t\t\t\t(VM_PROT_ALL | VM_PROT_COPY) );\n+\t\tif( err )\n+\t\t\terr = vm_protect( mach_task_self(),\n+\t\t\t\t\t(vm_address_t) originalFunctionPtr, 8, false,\n+\t\t\t\t\t(VM_PROT_DEFAULT | VM_PROT_COPY) );\n+\t}\n+\tif (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n+\t\n+\t//\tAllocate and target the escape island to the overriding function.\n+\tBranchIsland\t*escapeIsland = NULL;\n+\tif( !err )\n+\t\terr = alloc( (void**)&escapeIsland, sizeof(BranchIsland), originalFunctionAddress );\n+\tif ( err ) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n+\t\n+#if defined(__ppc__) || defined(__POWERPC__)\n+\tif( !err )\n+\t\terr = setBranchIslandTarget( escapeIsland, overrideFunctionAddress, 0 );\n+\t\n+\t//\tBuild the branch absolute instruction to the escape island.\n+\tlong\tbranchAbsoluteInstruction = 0; // Set to 0 just to silence warning.\n+\tif( !err ) {\n+\t\tlong escapeIslandAddress = ((long) escapeIsland) & 0x3FFFFFF;\n+\t\tbranchAbsoluteInstruction = 0x48000002 | escapeIslandAddress;\n+\t}\n+#elif defined(__i386__) || defined(__x86_64__)\n+        if (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n+\n+\tif( !err )\n+\t\terr = setBranchIslandTarget_i386( escapeIsland, overrideFunctionAddress, 0 );\n+ \n+\tif (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n+\t// Build the jump relative instruction to the escape island\n+#endif\n+\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+\tif (!err) {\n+\t\tuint32_t addressOffset = ((char*)escapeIsland - (char*)originalFunctionPtr - 5);\n+\t\taddressOffset = OSSwapInt32(addressOffset);\n+\t\t\n+\t\tjumpRelativeInstruction |= 0xE900000000000000LL; \n+\t\tjumpRelativeInstruction |= ((uint64_t)addressOffset & 0xffffffff) << 24;\n+\t\tjumpRelativeInstruction = OSSwapInt64(jumpRelativeInstruction);\t\t\n+\t}\n+#endif\n+\t\n+\t//\tOptionally allocate & return the reentry island. This may contain relocated\n+\t//  jmp instructions and so has all the same addressing reachability requirements\n+\t//  the escape island has to the original function, except the escape island is\n+\t//  technically our original function.\n+\tBranchIsland\t*reentryIsland = NULL;\n+\tif( !err && originalFunctionReentryIsland ) {\n+\t\terr = alloc( (void**)&reentryIsland, sizeof(BranchIsland), escapeIsland);\n+\t\tif( !err )\n+\t\t\t*originalFunctionReentryIsland = reentryIsland;\n+\t}\n+\t\n+#if defined(__ppc__) || defined(__POWERPC__)\t\n+\t//\tAtomically:\n+\t//\to If the reentry island was allocated:\n+\t//\t\to Insert the original instruction into the reentry island.\n+\t//\t\to Target the reentry island at the 2nd instruction of the\n+\t//\t\t  original function.\n+\t//\to Replace the original instruction with the branch absolute.\n+\tif( !err ) {\n+\t\tint escapeIslandEngaged = false;\n+\t\tdo {\n+\t\t\tif( reentryIsland )\n+\t\t\t\terr = setBranchIslandTarget( reentryIsland,\n+\t\t\t\t\t\t(void*) (originalFunctionPtr+1), originalInstruction );\n+\t\t\tif( !err ) {\n+\t\t\t\tescapeIslandEngaged = CompareAndSwap( originalInstruction,\n+\t\t\t\t\t\t\t\t\t\tbranchAbsoluteInstruction,\n+\t\t\t\t\t\t\t\t\t\t(UInt32*)originalFunctionPtr );\n+\t\t\t\tif( !escapeIslandEngaged ) {\n+\t\t\t\t\t//\tSomeone replaced the instruction out from under us,\n+\t\t\t\t\t//\tre-read the instruction, make sure it's still not\n+\t\t\t\t\t//\t'mfctr' and try again.\n+\t\t\t\t\toriginalInstruction = *originalFunctionPtr;\n+\t\t\t\t\tif( (originalInstruction & kMFCTRMask) == kMFCTRInstruction)\n+\t\t\t\t\t\terr = err_cannot_override;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} while( !err && !escapeIslandEngaged );\n+\t}\n+#elif defined(__i386__) || defined(__x86_64__)\n+\t// Atomically:\n+\t//\to If the reentry island was allocated:\n+\t//\t\to Insert the original instructions into the reentry island.\n+\t//\t\to Target the reentry island at the first non-replaced \n+\t//        instruction of the original function.\n+\t//\to Replace the original first instructions with the jump relative.\n+\t//\n+\t// Note that on i386, we do not support someone else changing the code under our feet\n+\tif ( !err ) {\n+\t\tfixupInstructions(originalFunctionPtr, reentryIsland, originalInstructions,\n+\t\t\t\t\toriginalInstructionCount, originalInstructionSizes );\n+\t\n+\t\tif( reentryIsland )\n+\t\t\terr = setBranchIslandTarget_i386( reentryIsland,\n+\t\t\t\t\t\t\t\t\t\t (void*) ((char *)originalFunctionPtr+eatenCount), originalInstructions );\n+\t\t// try making islands executable before planting the jmp\n+#if defined(__x86_64__) || defined(__i386__)\n+        if( !err )\n+            err = makeIslandExecutable(escapeIsland);\n+        if( !err && reentryIsland )\n+            err = makeIslandExecutable(reentryIsland);\n+#endif\n+\t\tif ( !err )\n+\t\t\tatomic_mov64((uint64_t *)originalFunctionPtr, jumpRelativeInstruction);\n+\t}\n+#endif\n+\t\n+\t//\tClean up on error.\n+\tif( err ) {\n+\t\tif( reentryIsland )\n+\t\t\tdealloc( reentryIsland );\n+\t\tif( escapeIsland )\n+\t\t\tdealloc( escapeIsland );\n+\t}\n+\n+#ifdef DEBUG_DISASM\n+  {\n+    fprintf(stderr, \"First 16 bytes of the function after slicing: \");\n+    unsigned char *orig = (unsigned char *)originalFunctionAddress;\n+    int i;\n+    for (i = 0; i < 16; i++) {\n+       fprintf(stderr, \"%x \", (unsigned int) orig[i]);\n+    }\n+    fprintf(stderr, \"\\n\");\n+  }\n+#endif\n+\treturn err;\n+}\n+\n+/*******************************************************************************\n+*\t\n+*\tImplementation\n+*\t\n+*******************************************************************************/\n+#pragma mark\t-\n+#pragma mark\t(Implementation)\n+\n+/***************************************************************************//**\n+\tImplementation: Allocates memory for a branch island.\n+\t\n+\t@param\tisland\t\t\t<-\tThe allocated island.\n+\t@param\tallocateHigh\t->\tWhether to allocate the island at the end of the\n+\t\t\t\t\t\t\t\taddress space (for use with the branch absolute\n+\t\t\t\t\t\t\t\tinstruction).\n+\t@result\t\t\t\t\t<-\tmach_error_t\n+\n+\t***************************************************************************/\n+\n+\tstatic mach_error_t\n+allocateBranchIsland(\n+\t\tBranchIsland\t**island,\n+\t\tint\t\t\t\tallocateHigh,\n+\t\tvoid *originalFunctionAddress)\n+{\n+\tassert( island );\n+\t\n+\tmach_error_t\terr = err_none;\n+\t\n+\tif( allocateHigh ) {\n+\t\tvm_size_t pageSize;\n+\t\terr = host_page_size( mach_host_self(), &pageSize );\n+\t\tif( !err ) {\n+\t\t\tassert( sizeof( BranchIsland ) <= pageSize );\n+#if defined(__ppc__) || defined(__POWERPC__)\n+\t\t\tvm_address_t first = 0xfeffffff;\n+\t\t\tvm_address_t last = 0xfe000000 + pageSize;\n+#elif defined(__x86_64__)\n+\t\t\tvm_address_t first = ((uint64_t)originalFunctionAddress & ~(uint64_t)(((uint64_t)1 << 31) - 1)) | ((uint64_t)1 << 31); // start in the middle of the page?\n+\t\t\tvm_address_t last = 0x0;\n+#else\n+\t\t\tvm_address_t first = 0xffc00000;\n+\t\t\tvm_address_t last = 0xfffe0000;\n+#endif\n+\n+\t\t\tvm_address_t page = first;\n+\t\t\tint allocated = 0;\n+\t\t\tvm_map_t task_self = mach_task_self();\n+\t\t\t\n+\t\t\twhile( !err && !allocated && page != last ) {\n+\n+\t\t\t\terr = vm_allocate( task_self, &page, pageSize, 0 );\n+\t\t\t\tif( err == err_none )\n+\t\t\t\t\tallocated = 1;\n+\t\t\t\telse if( err == KERN_NO_SPACE ) {\n+#if defined(__x86_64__)\n+\t\t\t\t\tpage -= pageSize;\n+#else\n+\t\t\t\t\tpage += pageSize;\n+#endif\n+\t\t\t\t\terr = err_none;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif( allocated )\n+\t\t\t\t*island = (BranchIsland*) page;\n+\t\t\telse if( !allocated && !err )\n+\t\t\t\terr = KERN_NO_SPACE;\n+\t\t}\n+\t} else {\n+\t\tvoid *block = malloc( sizeof( BranchIsland ) );\n+\t\tif( block )\n+\t\t\t*island = block;\n+\t\telse\n+\t\t\terr = KERN_NO_SPACE;\n+\t}\n+\tif( !err )\n+\t\t(**island).allocatedHigh = allocateHigh;\n+\t\n+\treturn err;\n+}\n+\n+/***************************************************************************//**\n+\tImplementation: Deallocates memory for a branch island.\n+\t\n+\t@param\tisland\t->\tThe island to deallocate.\n+\t@result\t\t\t<-\tmach_error_t\n+\n+\t***************************************************************************/\n+\n+\tstatic mach_error_t\n+freeBranchIsland(\n+\t\tBranchIsland\t*island )\n+{\n+\tassert( island );\n+\tassert( (*(long*)&island->instructions[0]) == kIslandTemplate[0] );\n+\tassert( island->allocatedHigh );\n+\t\n+\tmach_error_t\terr = err_none;\n+\t\n+\tif( island->allocatedHigh ) {\n+\t\tvm_size_t pageSize;\n+\t\terr = host_page_size( mach_host_self(), &pageSize );\n+\t\tif( !err ) {\n+\t\t\tassert( sizeof( BranchIsland ) <= pageSize );\n+\t\t\terr = vm_deallocate(\n+\t\t\t\t\tmach_task_self(),\n+\t\t\t\t\t(vm_address_t) island, pageSize );\n+\t\t}\n+\t} else {\n+\t\tfree( island );\n+\t}\n+\t\n+\treturn err;\n+}\n+\n+/***************************************************************************//**\n+\tImplementation: Sets the branch island's target, with an optional\n+\tinstruction.\n+\t\n+\t@param\tisland\t\t->\tThe branch island to insert target into.\n+\t@param\tbranchTo\t->\tThe address of the target.\n+\t@param\tinstruction\t->\tOptional instruction to execute prior to branch. Set\n+\t\t\t\t\t\t\tto zero for nop.\n+\t@result\t\t\t\t<-\tmach_error_t\n+\n+\t***************************************************************************/\n+#if defined(__ppc__) || defined(__POWERPC__)\n+\tstatic mach_error_t\n+setBranchIslandTarget(\n+\t\tBranchIsland\t*island,\n+\t\tconst void\t\t*branchTo,\n+\t\tlong\t\t\tinstruction )\n+{\n+\t//\tCopy over the template code.\n+    bcopy( kIslandTemplate, island->instructions, sizeof( kIslandTemplate ) );\n+    \n+    //\tFill in the address.\n+    ((short*)island->instructions)[kAddressLo] = ((long) branchTo) & 0x0000FFFF;\n+    ((short*)island->instructions)[kAddressHi]\n+    \t= (((long) branchTo) >> 16) & 0x0000FFFF;\n+    \n+    //\tFill in the (optional) instuction.\n+    if( instruction != 0 ) {\n+        ((short*)island->instructions)[kInstructionLo]\n+        \t= instruction & 0x0000FFFF;\n+        ((short*)island->instructions)[kInstructionHi]\n+        \t= (instruction >> 16) & 0x0000FFFF;\n+    }\n+    \n+    //MakeDataExecutable( island->instructions, sizeof( kIslandTemplate ) );\n+\tmsync( island->instructions, sizeof( kIslandTemplate ), MS_INVALIDATE );\n+    \n+    return err_none;\n+}\n+#endif \n+\n+#if defined(__i386__)\n+\tstatic mach_error_t\n+setBranchIslandTarget_i386(\n+\tBranchIsland\t*island,\n+\tconst void\t\t*branchTo,\n+\tchar*\t\t\tinstructions )\n+{\n+\n+\t//\tCopy over the template code.\n+    bcopy( kIslandTemplate, island->instructions, sizeof( kIslandTemplate ) );\n+\n+\t// copy original instructions\n+\tif (instructions) {\n+\t\tbcopy (instructions, island->instructions + kInstructions, kOriginalInstructionsSize);\n+\t}\n+\t\n+    // Fill in the address.\n+    int32_t addressOffset = (char *)branchTo - (island->instructions + kJumpAddress + 4);\n+    *((int32_t *)(island->instructions + kJumpAddress)) = addressOffset; \n+\n+    msync( island->instructions, sizeof( kIslandTemplate ), MS_INVALIDATE );\n+    return err_none;\n+}\n+\n+#elif defined(__x86_64__)\n+static mach_error_t\n+setBranchIslandTarget_i386(\n+        BranchIsland\t*island,\n+        const void\t\t*branchTo,\n+        char*\t\t\tinstructions )\n+{\n+    // Copy over the template code.\n+    bcopy( kIslandTemplate, island->instructions, sizeof( kIslandTemplate ) );\n+\n+    // Copy original instructions.\n+    if (instructions) {\n+        bcopy (instructions, island->instructions, kOriginalInstructionsSize);\n+    }\n+\n+    //\tFill in the address.\n+    *((uint64_t *)(island->instructions + kJumpAddress)) = (uint64_t)branchTo; \n+    msync( island->instructions, sizeof( kIslandTemplate ), MS_INVALIDATE );\n+\n+    return err_none;\n+}\n+#endif\n+\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+// simplistic instruction matching\n+typedef struct {\n+\tunsigned int length; // max 15\n+\tunsigned char mask[15]; // sequence of bytes in memory order\n+\tunsigned char constraint[15]; // sequence of bytes in memory order\n+}\tAsmInstructionMatch;\n+\n+#if defined(__i386__)\n+static AsmInstructionMatch possibleInstructions[] = {\n+\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xE9, 0x00, 0x00, 0x00, 0x00} },\t// jmp 0x????????\n+\t{ 0x5, {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, {0x55, 0x89, 0xe5, 0xc9, 0xc3} },\t// push %esp; mov %esp,%ebp; leave; ret\n+\t{ 0x1, {0xFF}, {0x90} },\t\t\t\t\t\t\t// nop\n+\t{ 0x1, {0xF8}, {0x50} },\t\t\t\t\t\t\t// push %reg\n+\t{ 0x2, {0xFF, 0xFF}, {0x89, 0xE5} },\t\t\t\t                // mov %esp,%ebp\n+\t{ 0x3, {0xFF, 0xFF, 0xFF}, {0x89, 0x1C, 0x24} },\t\t\t\t                // mov %ebx,(%esp)\n+\t{ 0x3, {0xFF, 0xFF, 0x00}, {0x83, 0xEC, 0x00} },\t                        // sub 0x??, %esp\n+\t{ 0x6, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00}, {0x81, 0xEC, 0x00, 0x00, 0x00, 0x00} },\t// sub 0x??, %esp with 32bit immediate\n+\t{ 0x2, {0xFF, 0xFF}, {0x31, 0xC0} },\t\t\t\t\t\t// xor %eax, %eax\n+\t{ 0x3, {0xFF, 0x4F, 0x00}, {0x8B, 0x45, 0x00} },  // mov $imm(%ebp), %reg\n+\t{ 0x3, {0xFF, 0x4C, 0x00}, {0x8B, 0x40, 0x00} },  // mov $imm(%eax-%edx), %reg\n+\t{ 0x3, {0xFF, 0xCF, 0x00}, {0x8B, 0x4D, 0x00} },  // mov $imm(%rpb), %reg\n+\t{ 0x3, {0xFF, 0x4F, 0x00}, {0x8A, 0x4D, 0x00} },  // mov $imm(%ebp), %cl\n+\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x8B, 0x4C, 0x24, 0x00} },  \t\t\t// mov $imm(%esp), %ecx\n+\t{ 0x4, {0xFF, 0x00, 0x00, 0x00}, {0x8B, 0x00, 0x00, 0x00} },  \t\t\t// mov r16,r/m16 or r32,r/m32\n+\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xB9, 0x00, 0x00, 0x00, 0x00} }, \t// mov $imm, %ecx\n+\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xB8, 0x00, 0x00, 0x00, 0x00} }, \t// mov $imm, %eax\n+\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x66, 0x0F, 0xEF, 0x00} },             \t// pxor xmm2/128, xmm1\n+\t{ 0x2, {0xFF, 0xFF}, {0xDB, 0xE3} }, \t\t\t\t\t\t// fninit\n+\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xE8, 0x00, 0x00, 0x00, 0x00} },\t// call $imm\n+\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x0F, 0xBE, 0x55, 0x00} },                    // movsbl $imm(%ebp), %edx\n+\t{ 0x0, {0x00}, {0x00} }\n+};\n+#elif defined(__x86_64__)\n+// TODO(glider): disassembling the \"0x48, 0x89\" sequences is trickier than it's done below.\n+// If it stops working, refer to http://ref.x86asm.net/geek.html#modrm_byte_32_64 to do it\n+// more accurately.\n+// Note: 0x48 is in fact the REX.W prefix, but it might be wrong to treat it as a separate\n+// instruction.\n+static AsmInstructionMatch possibleInstructions[] = {\n+\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xE9, 0x00, 0x00, 0x00, 0x00} },\t// jmp 0x????????\n+\t{ 0x1, {0xFF}, {0x90} },\t\t\t\t\t\t\t// nop\n+\t{ 0x1, {0xF8}, {0x50} },\t\t\t\t\t\t\t// push %rX\n+\t{ 0x1, {0xFF}, {0x65} },\t\t\t\t\t\t\t// GS prefix\n+\t{ 0x3, {0xFF, 0xFF, 0xFF}, {0x48, 0x89, 0xE5} },\t\t\t\t// mov %rsp,%rbp\n+\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x48, 0x83, 0xEC, 0x00} },\t                // sub 0x??, %rsp\n+\t{ 0x4, {0xFB, 0xFF, 0x07, 0x00}, {0x48, 0x89, 0x05, 0x00} },\t                // move onto rbp\n+\t{ 0x3, {0xFB, 0xFF, 0x00}, {0x48, 0x89, 0x00} },\t                            // mov %reg, %reg\n+\t{ 0x3, {0xFB, 0xFF, 0x00}, {0x49, 0x89, 0x00} },\t                            // mov %reg, %reg (REX.WB)\n+\t{ 0x2, {0xFF, 0x00}, {0x41, 0x00} },\t\t\t\t\t\t// push %rXX\n+\t{ 0x2, {0xFF, 0x00}, {0x84, 0x00} },\t\t\t\t\t\t// test %rX8,%rX8\n+\t{ 0x2, {0xFF, 0x00}, {0x85, 0x00} },\t\t\t\t\t\t// test %rX,%rX\n+\t{ 0x2, {0xFF, 0x00}, {0x77, 0x00} },\t\t\t\t\t\t// ja $i8\n+\t{ 0x2, {0xFF, 0x00}, {0x74, 0x00} },\t\t\t\t\t\t// je $i8\n+\t{ 0x5, {0xF8, 0x00, 0x00, 0x00, 0x00}, {0xB8, 0x00, 0x00, 0x00, 0x00} },\t// mov $imm, %reg\n+\t{ 0x3, {0xFF, 0xFF, 0x00}, {0xFF, 0x77, 0x00} },\t\t\t\t// pushq $imm(%rdi)\n+\t{ 0x2, {0xFF, 0xFF}, {0x31, 0xC0} },\t\t\t\t\t\t// xor %eax, %eax\n+\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0x25, 0x00, 0x00, 0x00, 0x00} },\t// and $imm, %eax\n+\t{ 0x3, {0xFF, 0xFF, 0xFF}, {0x80, 0x3F, 0x00} },\t\t\t\t// cmpb $imm, (%rdi)\n+\n+  { 0x8, {0xFF, 0xFF, 0xCF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n+         {0x48, 0x8B, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00}, },                     // mov $imm, %{rax,rdx,rsp,rsi}\n+  { 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x48, 0x83, 0xFA, 0x00}, },   // cmp $i8, %rdx\n+\t{ 0x4, {0xFF, 0xFF, 0x00, 0x00}, {0x83, 0x7f, 0x00, 0x00}, },\t\t\t// cmpl $imm, $imm(%rdi)\n+\t{ 0xa, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+               {0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },    // mov $imm, %rax\n+        { 0x6, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n+               {0x81, 0xE6, 0x00, 0x00, 0x00, 0x00} },                            // and $imm, %esi\n+        { 0x6, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n+               {0xFF, 0x25, 0x00, 0x00, 0x00, 0x00} },                            // jmpq *(%rip)\n+        { 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x66, 0x0F, 0xEF, 0x00} },              // pxor xmm2/128, xmm1\n+        { 0x2, {0xFF, 0x00}, {0x89, 0x00} },                               // mov r/m32,r32 or r/m16,r16\n+        { 0x3, {0xFF, 0xFF, 0xFF}, {0x49, 0x89, 0xF8} },                   // mov %rdi,%r8\n+        { 0x4, {0xFF, 0xFF, 0xFF, 0xFF}, {0x40, 0x0F, 0xBE, 0xCE} },       // movsbl %sil,%ecx\n+        { 0x7, {0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n+               {0x48, 0x8D, 0x05, 0x00, 0x00, 0x00, 0x00} },  // lea $imm(%rip),%rax\n+        { 0x3, {0xFF, 0xFF, 0xFF}, {0x0F, 0xBE, 0xCE} },  // movsbl, %dh, %ecx\n+        { 0x3, {0xFF, 0xFF, 0x00}, {0xFF, 0x77, 0x00} },  // pushq $imm(%rdi)\n+        { 0x2, {0xFF, 0xFF}, {0xDB, 0xE3} }, // fninit\n+        { 0x3, {0xFF, 0xFF, 0xFF}, {0x48, 0x85, 0xD2} },  // test %rdx,%rdx\n+\t{ 0x0, {0x00}, {0x00} }\n+};\n+#endif\n+\n+static Boolean codeMatchesInstruction(unsigned char *code, AsmInstructionMatch* instruction) \n+{\n+\tBoolean match = true;\n+\t\n+\tsize_t i;\n+  assert(instruction);\n+#ifdef DEBUG_DISASM\n+\tfprintf(stderr, \"Matching: \");\n+#endif  \n+\tfor (i=0; i<instruction->length; i++) {\n+\t\tunsigned char mask = instruction->mask[i];\n+\t\tunsigned char constraint = instruction->constraint[i];\n+\t\tunsigned char codeValue = code[i];\n+#ifdef DEBUG_DISASM\n+\t\tfprintf(stderr, \"%x \", (unsigned)codeValue);\n+#endif    \n+\t\tmatch = ((codeValue & mask) == constraint);\n+\t\tif (!match) break;\n+\t}\n+#ifdef DEBUG_DISASM\n+\tif (match) {\n+\t\tfprintf(stderr, \" OK\\n\");\n+\t} else {\n+\t\tfprintf(stderr, \" FAIL\\n\");\n+\t}\n+#endif  \n+\treturn match;\n+}\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+\tstatic Boolean \n+eatKnownInstructions( \n+\tunsigned char\t*code, \n+\tuint64_t\t\t*newInstruction,\n+\tint\t\t\t\t*howManyEaten, \n+\tchar\t\t\t*originalInstructions,\n+\tint\t\t\t\t*originalInstructionCount, \n+\tuint8_t\t\t\t*originalInstructionSizes )\n+{\n+\tBoolean allInstructionsKnown = true;\n+\tint totalEaten = 0;\n+\tunsigned char* ptr = code;\n+\tint remainsToEat = 5; // a JMP instruction takes 5 bytes\n+\tint instructionIndex = 0;\n+\t\n+\tif (howManyEaten) *howManyEaten = 0;\n+\tif (originalInstructionCount) *originalInstructionCount = 0;\n+\twhile (remainsToEat > 0) {\n+\t\tBoolean curInstructionKnown = false;\n+\t\t\n+\t\t// See if instruction matches one  we know\n+\t\tAsmInstructionMatch* curInstr = possibleInstructions;\n+\t\tdo { \n+\t\t\tif ((curInstructionKnown = codeMatchesInstruction(ptr, curInstr))) break;\n+\t\t\tcurInstr++;\n+\t\t} while (curInstr->length > 0);\n+\t\t\n+\t\t// if all instruction matches failed, we don't know current instruction then, stop here\n+\t\tif (!curInstructionKnown) { \n+\t\t\tallInstructionsKnown = false;\n+\t\t\tfprintf(stderr, \"mach_override: some instructions unknown! Need to update mach_override.c\\n\");\n+\t\t\tbreak;\n+\t\t}\n+\t\t\n+\t\t// At this point, we've matched curInstr\n+\t\tint eaten = curInstr->length;\n+\t\tptr += eaten;\n+\t\tremainsToEat -= eaten;\n+\t\ttotalEaten += eaten;\n+\t\t\n+\t\tif (originalInstructionSizes) originalInstructionSizes[instructionIndex] = eaten;\n+\t\tinstructionIndex += 1;\n+\t\tif (originalInstructionCount) *originalInstructionCount = instructionIndex;\n+\t}\n+\n+\n+\tif (howManyEaten) *howManyEaten = totalEaten;\n+\n+\tif (originalInstructions) {\n+\t\tBoolean enoughSpaceForOriginalInstructions = (totalEaten < kOriginalInstructionsSize);\n+\t\t\n+\t\tif (enoughSpaceForOriginalInstructions) {\n+\t\t\tmemset(originalInstructions, 0x90 /* NOP */, kOriginalInstructionsSize); // fill instructions with NOP\n+\t\t\tbcopy(code, originalInstructions, totalEaten);\n+\t\t} else {\n+#ifdef DEBUG_DISASM\n+\t\t\tfprintf(stderr, \"Not enough space in island to store original instructions. Adapt the island definition and kOriginalInstructionsSize\\n\");\n+#endif      \n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\tif (allInstructionsKnown) {\n+\t\t// save last 3 bytes of first 64bits of codre we'll replace\n+\t\tuint64_t currentFirst64BitsOfCode = *((uint64_t *)code);\n+\t\tcurrentFirst64BitsOfCode = OSSwapInt64(currentFirst64BitsOfCode); // back to memory representation\n+\t\tcurrentFirst64BitsOfCode &= 0x0000000000FFFFFFLL; \n+\t\t\n+\t\t// keep only last 3 instructions bytes, first 5 will be replaced by JMP instr\n+\t\t*newInstruction &= 0xFFFFFFFFFF000000LL; // clear last 3 bytes\n+\t\t*newInstruction |= (currentFirst64BitsOfCode & 0x0000000000FFFFFFLL); // set last 3 bytes\n+\t}\n+\n+\treturn allInstructionsKnown;\n+}\n+\n+\tstatic void\n+fixupInstructions(\n+    void\t\t*originalFunction,\n+    void\t\t*escapeIsland,\n+    void\t\t*instructionsToFix,\n+\tint\t\t\tinstructionCount,\n+\tuint8_t\t\t*instructionSizes )\n+{\n+\tvoid *initialOriginalFunction = originalFunction;\n+\tint\tindex, fixed_size, code_size = 0;\n+\tfor (index = 0;index < instructionCount;index += 1)\n+\t\tcode_size += instructionSizes[index];\n+\n+#ifdef DEBUG_DISASM\n+\tvoid *initialInstructionsToFix = instructionsToFix;\n+\tfprintf(stderr, \"BEFORE FIXING:\\n\");\n+\tdump16Bytes(initialOriginalFunction);\n+\tdump16Bytes(initialInstructionsToFix);\n+#endif  // DEBUG_DISASM\n+\n+\tfor (index = 0;index < instructionCount;index += 1)\n+\t{\n+                fixed_size = instructionSizes[index];\n+\t\tif ((*(uint8_t*)instructionsToFix == 0xE9) || // 32-bit jump relative\n+\t\t    (*(uint8_t*)instructionsToFix == 0xE8))   // 32-bit call relative\n+\t\t{\n+\t\t\tuint32_t offset = (uintptr_t)originalFunction - (uintptr_t)escapeIsland;\n+\t\t\tuint32_t *jumpOffsetPtr = (uint32_t*)((uintptr_t)instructionsToFix + 1);\n+\t\t\t*jumpOffsetPtr += offset;\n+\t\t}\n+\t\tif ((*(uint8_t*)instructionsToFix == 0x74) ||  // Near jump if equal (je), 2 bytes.\n+\t\t    (*(uint8_t*)instructionsToFix == 0x77))    // Near jump if above (ja), 2 bytes.\n+\t\t{\n+\t\t\t// We replace a near je/ja instruction, \"7P JJ\", with a 32-bit je/ja, \"0F 8P WW XX YY ZZ\".\n+\t\t\t// This is critical, otherwise a near jump will likely fall outside the original function.\n+\t\t\tuint32_t offset = (uintptr_t)initialOriginalFunction - (uintptr_t)escapeIsland;\n+\t\t\tuint32_t jumpOffset = *(uint8_t*)((uintptr_t)instructionsToFix + 1);\n+\t\t\t*((uint8_t*)instructionsToFix + 1) = *(uint8_t*)instructionsToFix + 0x10;\n+\t\t\t*(uint8_t*)instructionsToFix = 0x0F;\n+\t\t\tuint32_t *jumpOffsetPtr = (uint32_t*)((uintptr_t)instructionsToFix + 2 );\n+\t\t\t*jumpOffsetPtr = offset + jumpOffset;\n+\t\t\tfixed_size = 6;\n+                }\n+\t\t\n+\t\toriginalFunction = (void*)((uintptr_t)originalFunction + instructionSizes[index]);\n+\t\tescapeIsland = (void*)((uintptr_t)escapeIsland + instructionSizes[index]);\n+\t\tinstructionsToFix = (void*)((uintptr_t)instructionsToFix + fixed_size);\n+\n+\t\t// Expanding short instructions into longer ones may overwrite the next instructions,\n+\t\t// so we must restore them.\n+\t\tcode_size -= fixed_size;\n+\t\tif ((code_size > 0) && (fixed_size != instructionSizes[index])) {\n+\t\t\tbcopy(originalFunction, instructionsToFix, code_size);\n+\t\t}\n+\t}\n+#ifdef DEBUG_DISASM\n+\tfprintf(stderr, \"AFTER_FIXING:\\n\");\n+\tdump16Bytes(initialOriginalFunction);\n+\tdump16Bytes(initialInstructionsToFix);\n+#endif  // DEBUG_DISASM\n+}\n+\n+#ifdef DEBUG_DISASM\n+#define HEX_DIGIT(x) ((((x) % 16) < 10) ? ('0' + ((x) % 16)) : ('A' + ((x) % 16 - 10)))\n+\n+\tstatic void\n+dump16Bytes(\n+\tvoid \t*ptr) {\n+\tint i;\n+\tchar buf[3];\n+\tuint8_t *bytes = (uint8_t*)ptr;\n+\tfor (i = 0; i < 16; i++) {\n+\t\tbuf[0] = HEX_DIGIT(bytes[i] / 16);\n+\t\tbuf[1] = HEX_DIGIT(bytes[i] % 16);\n+\t\tbuf[2] = ' ';\n+\t\twrite(2, buf, 3);\n+\t}\n+\twrite(2, \"\\n\", 1);\n+}\n+#endif  // DEBUG_DISASM\n+#endif\n+\n+#if defined(__i386__)\n+__asm(\n+\t\t\t\".text;\"\n+\t\t\t\".align 2, 0x90;\"\n+\t\t\t\"_atomic_mov64:;\"\n+\t\t\t\"\tpushl %ebp;\"\n+\t\t\t\"\tmovl %esp, %ebp;\"\n+\t\t\t\"\tpushl %esi;\"\n+\t\t\t\"\tpushl %ebx;\"\n+\t\t\t\"\tpushl %ecx;\"\n+\t\t\t\"\tpushl %eax;\"\n+\t\t\t\"\tpushl %edx;\"\n+\t\n+\t\t\t// atomic push of value to an address\n+\t\t\t// we use cmpxchg8b, which compares content of an address with \n+\t\t\t// edx:eax. If they are equal, it atomically puts 64bit value \n+\t\t\t// ecx:ebx in address. \n+\t\t\t// We thus put contents of address in edx:eax to force ecx:ebx\n+\t\t\t// in address\n+\t\t\t\"\tmov\t\t8(%ebp), %esi;\"  // esi contains target address\n+\t\t\t\"\tmov\t\t12(%ebp), %ebx;\"\n+\t\t\t\"\tmov\t\t16(%ebp), %ecx;\" // ecx:ebx now contains value to put in target address\n+\t\t\t\"\tmov\t\t(%esi), %eax;\"\n+\t\t\t\"\tmov\t\t4(%esi), %edx;\"  // edx:eax now contains value currently contained in target address\n+\t\t\t\"\tlock; cmpxchg8b\t(%esi);\" // atomic move.\n+\t\t\t\n+\t\t\t// restore registers\n+\t\t\t\"\tpopl %edx;\"\n+\t\t\t\"\tpopl %eax;\"\n+\t\t\t\"\tpopl %ecx;\"\n+\t\t\t\"\tpopl %ebx;\"\n+\t\t\t\"\tpopl %esi;\"\n+\t\t\t\"\tpopl %ebp;\"\n+\t\t\t\"\tret\"\n+);\n+#elif defined(__x86_64__)\n+void atomic_mov64(\n+\t\tuint64_t *targetAddress,\n+\t\tuint64_t value )\n+{\n+    *targetAddress = value;\n+}\n+#endif\n+#endif\n+#endif  // __APPLE__"}, {"sha": "7e60cdcd619c66f5964bd9943d9faa534e291479", "filename": "libsanitizer/interception/mach_override/mach_override.h", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f246eadc0acadb23e08a86f71177cff7596cfc87/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.h?ref=f246eadc0acadb23e08a86f71177cff7596cfc87", "patch": "@@ -0,0 +1,140 @@\n+/*******************************************************************************\n+\tmach_override.h\n+\t\tCopyright (c) 2003-2009 Jonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n+\t\tSome rights reserved: <http://opensource.org/licenses/mit-license.php>\n+\n+\t***************************************************************************/\n+\n+/***************************************************************************//**\n+\t@mainpage\tmach_override\n+\t@author\t\tJonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n+\t\n+\tThis package, coded in C to the Mach API, allows you to override (\"patch\")\n+\tprogram- and system-supplied functions at runtime. You can fully replace\n+\tfunctions with your implementations, or merely head- or tail-patch the\n+\toriginal implementations.\n+\t\n+\tUse it by #include'ing mach_override.h from your .c, .m or .mm file(s).\n+\t\n+\t@todo\tDiscontinue use of Carbon's MakeDataExecutable() and\n+\t\t\tCompareAndSwap() calls and start using the Mach equivalents, if they\n+\t\t\texist. If they don't, write them and roll them in. That way, this\n+\t\t\tcode will be pure Mach, which will make it easier to use everywhere.\n+\t\t\tUpdate: MakeDataExecutable() has been replaced by\n+\t\t\tmsync(MS_INVALIDATE). There is an OSCompareAndSwap in libkern, but\n+\t\t\tI'm currently unsure if I can link against it. May have to roll in\n+\t\t\tmy own version...\n+\t@todo\tStop using an entire 4K high-allocated VM page per 28-byte escape\n+\t\t\tbranch island. Done right, this will dramatically speed up escape\n+\t\t\tisland allocations when they number over 250. Then again, if you're\n+\t\t\toverriding more than 250 functions, maybe speed isn't your main\n+\t\t\tconcern...\n+\t@todo\tAdd detection of: b, bl, bla, bc, bcl, bcla, bcctrl, bclrl\n+\t\t\tfirst-instructions. Initially, we should refuse to override\n+\t\t\tfunctions beginning with these instructions. Eventually, we should\n+\t\t\tdynamically rewrite them to make them position-independent.\n+\t@todo\tWrite mach_unoverride(), which would remove an override placed on a\n+\t\t\tfunction. Must be multiple-override aware, which means an almost\n+\t\t\tcomplete rewrite under the covers, because the target address can't\n+\t\t\tbe spread across two load instructions like it is now since it will\n+\t\t\tneed to be atomically updatable.\n+\t@todo\tAdd non-rentry variants of overrides to test_mach_override.\n+\n+\t***************************************************************************/\n+\n+#ifdef __APPLE__\n+\n+#ifndef\t\t_mach_override_\n+#define\t\t_mach_override_\n+\n+#include <sys/types.h>\n+#include <mach/error.h>\n+\n+#ifdef\t__cplusplus\n+\textern\t\"C\"\t{\n+#endif\n+\n+/**\n+\tReturned if the function to be overrided begins with a 'mfctr' instruction.\n+*/\n+#define\terr_cannot_override\t(err_local|1)\n+\n+/************************************************************************************//**\n+\tDynamically overrides the function implementation referenced by\n+\toriginalFunctionAddress with the implentation pointed to by overrideFunctionAddress.\n+\tOptionally returns a pointer to a \"reentry island\" which, if jumped to, will resume\n+\tthe original implementation.\n+\t\n+\t@param\toriginalFunctionAddress\t\t\t->\tRequired address of the function to\n+\t\t\t\t\t\t\t\t\t\t\t\toverride (with overrideFunctionAddress).\n+\t@param\toverrideFunctionAddress\t\t\t->\tRequired address to the overriding\n+\t\t\t\t\t\t\t\t\t\t\t\tfunction.\n+\t@param\toriginalFunctionReentryIsland\t<-\tOptional pointer to pointer to the\n+\t\t\t\t\t\t\t\t\t\t\t\treentry island. Can be NULL.\n+\t@result\t\t\t\t\t\t\t\t\t<-\terr_cannot_override if the original\n+\t\t\t\t\t\t\t\t\t\t\t\tfunction's implementation begins with\n+\t\t\t\t\t\t\t\t\t\t\t\tthe 'mfctr' instruction.\n+\n+\t************************************************************************************/\n+\n+// We're prefixing mach_override_ptr() with \"__asan_\" to avoid name conflicts with other\n+// mach_override_ptr() implementations that may appear in the client program.\n+    mach_error_t\n+__asan_mach_override_ptr(\n+\tvoid *originalFunctionAddress,\n+    const void *overrideFunctionAddress,\n+    void **originalFunctionReentryIsland );\n+\n+// Allow to use custom allocation and deallocation routines with mach_override_ptr().\n+// This should help to speed up the things on x86_64.\n+typedef mach_error_t island_malloc( void **ptr, size_t size, void *hint );\n+typedef mach_error_t island_free( void *ptr );\n+\n+    mach_error_t\n+__asan_mach_override_ptr_custom(\n+\tvoid *originalFunctionAddress,\n+    const void *overrideFunctionAddress,\n+    void **originalFunctionReentryIsland,\n+    island_malloc *alloc,\n+    island_free *dealloc );\n+\n+/************************************************************************************//**\n+\t\n+\n+\t************************************************************************************/\n+ \n+#ifdef\t__cplusplus\n+\n+#define MACH_OVERRIDE( ORIGINAL_FUNCTION_RETURN_TYPE, ORIGINAL_FUNCTION_NAME, ORIGINAL_FUNCTION_ARGS, ERR )\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tstatic ORIGINAL_FUNCTION_RETURN_TYPE (*ORIGINAL_FUNCTION_NAME##_reenter)ORIGINAL_FUNCTION_ARGS;\t\t\t\t\\\n+\t\tstatic bool ORIGINAL_FUNCTION_NAME##_overriden = false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tclass mach_override_class__##ORIGINAL_FUNCTION_NAME {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tpublic:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tstatic kern_return_t override(void *originalFunctionPtr) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\tkern_return_t result = err_none;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\tif (!ORIGINAL_FUNCTION_NAME##_overriden) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\tORIGINAL_FUNCTION_NAME##_overriden = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\tresult = mach_override_ptr( (void*)originalFunctionPtr,\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\t\t\t(void*)mach_override_class__##ORIGINAL_FUNCTION_NAME::replacement,\t\\\n+\t\t\t\t\t\t\t\t\t\t\t\t(void**)&ORIGINAL_FUNCTION_NAME##_reenter );\t\t\t\t\t\t\\\n+\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\treturn result;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tstatic ORIGINAL_FUNCTION_RETURN_TYPE replacement ORIGINAL_FUNCTION_ARGS {\n+\n+#define END_MACH_OVERRIDE( ORIGINAL_FUNCTION_NAME )\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\terr = mach_override_class__##ORIGINAL_FUNCTION_NAME::override((void*)ORIGINAL_FUNCTION_NAME);\t\t\t\t\\\n+\t}\n+ \n+#endif\n+\n+#ifdef\t__cplusplus\n+\t}\n+#endif\n+#endif\t//\t_mach_override_\n+\n+#endif  // __APPLE__"}]}