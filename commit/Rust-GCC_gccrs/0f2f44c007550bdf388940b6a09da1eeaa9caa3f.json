{"sha": "0f2f44c007550bdf388940b6a09da1eeaa9caa3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYyZjQ0YzAwNzU1MGJkZjM4ODk0MGI2YTA5ZGExZWVhYTljYWEzZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-04-21T07:05:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-04-21T07:05:00Z"}, "message": "dwarf2out.c (add_var_loc_to_decl): Add LABEL argument.\n\n\t* dwarf2out.c (add_var_loc_to_decl): Add LABEL argument.  Drop\n\tlast chain entry if it starts with the still current label.\n\t(add_location_or_const_value_attribute): Check that\n\tloc_list->first->next is NULL instead of comparing ->first with\n\t->last.\n\t(dwarf2out_var_location): Pass last_label resp. last_postcall_label\n\tto add_var_loc_to_decl.\n\nFrom-SVN: r158590", "tree": {"sha": "d36a720d20ebd5b31bcb5f0f57b43d8c5abffc73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d36a720d20ebd5b31bcb5f0f57b43d8c5abffc73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f2f44c007550bdf388940b6a09da1eeaa9caa3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2f44c007550bdf388940b6a09da1eeaa9caa3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2f44c007550bdf388940b6a09da1eeaa9caa3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2f44c007550bdf388940b6a09da1eeaa9caa3f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f65940dd1ba4a5d305a9efa4d44a5af15518af1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f65940dd1ba4a5d305a9efa4d44a5af15518af1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f65940dd1ba4a5d305a9efa4d44a5af15518af1"}], "stats": {"total": 98, "additions": 80, "deletions": 18}, "files": [{"sha": "7376b8bbc199c26f983c91a98efc984c22f32851", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2f44c007550bdf388940b6a09da1eeaa9caa3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2f44c007550bdf388940b6a09da1eeaa9caa3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f2f44c007550bdf388940b6a09da1eeaa9caa3f", "patch": "@@ -1,5 +1,13 @@\n 2010-04-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.c (add_var_loc_to_decl): Add LABEL argument.  Drop\n+\tlast chain entry if it starts with the still current label.\n+\t(add_location_or_const_value_attribute): Check that\n+\tloc_list->first->next is NULL instead of comparing ->first with\n+\t->last.\n+\t(dwarf2out_var_location): Pass last_label resp. last_postcall_label\n+\tto add_var_loc_to_decl.\n+\n \t* dwarf2out.c (output_call_frame_info): For dw_cie_version\n \t>= 4 add also address size and segment size fields into CIE\n \theader."}, {"sha": "8d569384f30a3836301691fd9fc655f4bba728db", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 72, "deletions": 18, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2f44c007550bdf388940b6a09da1eeaa9caa3f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2f44c007550bdf388940b6a09da1eeaa9caa3f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0f2f44c007550bdf388940b6a09da1eeaa9caa3f", "patch": "@@ -5748,8 +5748,12 @@ struct GTY ((chain_next (\"%h.next\"))) var_loc_node {\n struct GTY (()) var_loc_list_def {\n   struct var_loc_node * GTY (()) first;\n \n-  /* Do not mark the last element of the chained list because\n-     it is marked through the chain.  */\n+  /* Pointer to the last but one or last element of the\n+     chained list.  If the list is empty, both first and\n+     last are NULL, if the list contains just one node\n+     or the last node certainly is not redundant, it points\n+     to the last node, otherwise points to the last but one.\n+     Do not mark it for GC because it is marked through the chain.  */\n   struct var_loc_node * GTY ((skip (\"%h\"))) last;\n \n   /* DECL_UID of the variable decl.  */\n@@ -5991,7 +5995,7 @@ static hashval_t decl_loc_table_hash (const void *);\n static int decl_loc_table_eq (const void *, const void *);\n static var_loc_list *lookup_decl_loc (const_tree);\n static void equate_decl_number_to_die (tree, dw_die_ref);\n-static struct var_loc_node *add_var_loc_to_decl (tree, rtx);\n+static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *);\n static void print_spaces (FILE *);\n static void print_die (dw_die_ref, FILE *);\n static void print_dwarf_line_table (FILE *);\n@@ -7755,7 +7759,7 @@ equate_decl_number_to_die (tree decl, dw_die_ref decl_die)\n /* Add a variable location node to the linked list for DECL.  */\n \n static struct var_loc_node *\n-add_var_loc_to_decl (tree decl, rtx loc_note)\n+add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n {\n   unsigned int decl_id = DECL_UID (decl);\n   var_loc_list *temp;\n@@ -7774,23 +7778,62 @@ add_var_loc_to_decl (tree decl, rtx loc_note)\n \n   if (temp->last)\n     {\n+      struct var_loc_node *last = temp->last, *unused = NULL;\n+      if (last->next)\n+\t{\n+\t  last = last->next;\n+\t  gcc_assert (last->next == NULL);\n+\t}\n+      /* TEMP->LAST here is either pointer to the last but one or\n+\t last element in the chained list, LAST is pointer to the\n+\t last element.  */\n+      /* If the last note doesn't cover any instructions, remove it.  */\n+      if (label && strcmp (last->label, label) == 0)\n+\t{\n+\t  if (temp->last != last)\n+\t    {\n+\t      temp->last->next = NULL;\n+\t      unused = last;\n+\t      last = temp->last;\n+\t      gcc_assert (strcmp (last->label, label) != 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (temp->first == temp->last);\n+\t      memset (temp->last, '\\0', sizeof (*temp->last));\n+\t      return temp->last;\n+\t    }\n+\t}\n       /* If the current location is the same as the end of the list,\n \t and either both or neither of the locations is uninitialized,\n \t we have nothing to do.  */\n-      if ((!rtx_equal_p (NOTE_VAR_LOCATION_LOC (temp->last->var_loc_note),\n+      if ((!rtx_equal_p (NOTE_VAR_LOCATION_LOC (last->var_loc_note),\n \t\t\t NOTE_VAR_LOCATION_LOC (loc_note)))\n-\t  || ((NOTE_VAR_LOCATION_STATUS (temp->last->var_loc_note)\n+\t  || ((NOTE_VAR_LOCATION_STATUS (last->var_loc_note)\n \t       != NOTE_VAR_LOCATION_STATUS (loc_note))\n-\t      && ((NOTE_VAR_LOCATION_STATUS (temp->last->var_loc_note)\n+\t      && ((NOTE_VAR_LOCATION_STATUS (last->var_loc_note)\n \t\t   == VAR_INIT_STATUS_UNINITIALIZED)\n \t\t  || (NOTE_VAR_LOCATION_STATUS (loc_note)\n \t\t      == VAR_INIT_STATUS_UNINITIALIZED))))\n \t{\n-\t  /* Add LOC to the end of list and update LAST.  */\n-\t  loc = GGC_CNEW (struct var_loc_node);\n-\t  temp->last->next = loc;\n-\t  temp->last = loc;\n+\t  /* Add LOC to the end of list and update LAST.  If the last\n+\t     element of the list has been removed above, reuse its\n+\t     memory for the new node, otherwise allocate a new one.  */\n+\t  if (unused)\n+\t    {\n+\t      loc = unused;\n+\t      memset (loc, '\\0', sizeof (*loc));\n+\t    }\n+\t  else\n+\t    loc = GGC_CNEW (struct var_loc_node);\n+\t  last->next = loc;\n+\t  /* Ensure TEMP->LAST will point either to the new last but one\n+\t     element of the chain, or to the last element in it.  */\n+\t  if (last != temp->last)\n+\t    temp->last = last;\n \t}\n+      else if (unused)\n+\tggc_free (unused);\n     }\n   else\n     {\n@@ -15925,7 +15968,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n   loc_list = lookup_decl_loc (decl);\n   if (loc_list\n       && loc_list->first\n-      && loc_list->first == loc_list->last\n+      && loc_list->first->next == NULL\n       && NOTE_VAR_LOCATION (loc_list->first->var_loc_note)\n       && NOTE_VAR_LOCATION_LOC (loc_list->first->var_loc_note))\n     {\n@@ -20384,22 +20427,33 @@ dwarf2out_var_location (rtx loc_note)\n   if (next_real == NULL_RTX)\n     return;\n \n+  /* If there were any real insns between note we processed last time\n+     and this note (or if it is the first note), clear\n+     last_{,postcall_}label so that they are not reused this time.  */\n+  if (last_var_location_insn == NULL_RTX\n+      || last_var_location_insn != next_real\n+      || last_in_cold_section_p != in_cold_section_p)\n+    {\n+      last_label = NULL;\n+      last_postcall_label = NULL;\n+    }\n+\n   decl = NOTE_VAR_LOCATION_DECL (loc_note);\n-  newloc = add_var_loc_to_decl (decl, loc_note);\n+  newloc = add_var_loc_to_decl (decl, loc_note,\n+\t\t\t\tNOTE_DURING_CALL_P (loc_note)\n+\t\t\t\t? last_postcall_label : last_label);\n   if (newloc == NULL)\n     return;\n \n   /* If there were no real insns between note we processed last time\n-     and this note, use the label we emitted last time.  */\n-  if (last_var_location_insn == NULL_RTX\n-      || last_var_location_insn != next_real\n-      || last_in_cold_section_p != in_cold_section_p)\n+     and this note, use the label we emitted last time.  Otherwise\n+     create a new label and emit it.  */\n+  if (last_label == NULL)\n     {\n       ASM_GENERATE_INTERNAL_LABEL (loclabel, \"LVL\", loclabel_num);\n       ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LVL\", loclabel_num);\n       loclabel_num++;\n       last_label = ggc_strdup (loclabel);\n-      last_postcall_label = NULL;\n     }\n   newloc->var_loc_note = loc_note;\n   newloc->next = NULL;"}]}