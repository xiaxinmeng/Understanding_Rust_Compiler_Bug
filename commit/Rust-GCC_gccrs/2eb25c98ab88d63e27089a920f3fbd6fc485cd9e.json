{"sha": "2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmViMjVjOThhYjg4ZDYzZTI3MDg5YTkyMGYzZmJkNmZjNDg1Y2Q5ZQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2009-05-26T10:35:16Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2009-05-26T10:35:16Z"}, "message": "re PR c++/40007 (specialization causes access problem in primary template)\n\nFix PR c++/40007\n\n    gcc/cp/ChangeLog:\n    \tPR c++/40007\n    \t* cp-tree.h (MEMBER_TYPES_NEEDING_ACCESS_CHECK): Remove this accessor.\n    \t(TI_TYPEDEFS_NEEDING_ACCESS_CHECKING): New accessor.\n    \t(get_types_needing_access_check): Declare new entry point.\n    \t* pt.c (append_type_to_template_for_access_check_1,\n    \tget_types_needing_access_check): New functions.\n    \t(perform_typedefs_access_check): Accept FUNCTION_DECLs and\n    \tRECORD_TYPEs rather than TEMPLATE_DECLs. Use the new\n    \tget_types_needing_access_check, no more\n    \tMEMBER_TYPES_NEEDING_ACCESS_CHECK.\n    \t(instantiate_class_template): Set input_location to the source\n    \tlocation of the most specialized template definition.\n    \tPerform access check using the RECORD_TYPE of the template, not its\n    \tassociated most generic TEMPLATE_DECL.\n    \t(append_type_to_template_for_access_check): Augment function\n    \tcomments. Use the new get_types_needing_access_check, not\n    \tMEMBER_TYPE_NEEDING_ACCESS_CHECK. Use the new\n    \tappend_type_to_template_for_access_check_1 subroutine.\n\n    gcc/testsuite/ChangeLog:\n    \tPR c++/40007\n    \t* g++.dg/template/typedef18.C: New test.\n    \t* g++.dg/template/typedef19.C: Likewise.\n    \t* g++.dg/template/typedef20.C: Likewise.\n    \t* g++.dg/template/access11.C: Adjust.\n\nFrom-SVN: r147866", "tree": {"sha": "3d65d44a42717c7f7d4a2537e6e32c193c7d5fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d65d44a42717c7f7d4a2537e6e32c193c7d5fae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/comments", "author": null, "committer": null, "parents": [{"sha": "52c3075d2b966a735dd2052437ddc00ce335aa85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c3075d2b966a735dd2052437ddc00ce335aa85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c3075d2b966a735dd2052437ddc00ce335aa85"}], "stats": {"total": 247, "additions": 212, "deletions": 35}, "files": [{"sha": "20230dfba01e4bb4f0071320bdb293fd2b4d8867", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -1,3 +1,24 @@\n+2009-05-26  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/40007\n+\t* cp-tree.h (MEMBER_TYPES_NEEDING_ACCESS_CHECK): Remove this accessor.\n+\t(TI_TYPEDEFS_NEEDING_ACCESS_CHECKING): New accessor.\n+\t(get_types_needing_access_check): Declare new entry point.\n+\t* pt.c (append_type_to_template_for_access_check_1,\n+\tget_types_needing_access_check): New functions.\n+\t(perform_typedefs_access_check): Accept FUNCTION_DECLs and\n+\tRECORD_TYPEs rather than TEMPLATE_DECLs. Use the new\n+\tget_types_needing_access_check, no more\n+\tMEMBER_TYPES_NEEDING_ACCESS_CHECK.\n+\t(instantiate_class_template): Set input_location to the source\n+\tlocation of the most specialized template definition.\n+\tPerform access check using the RECORD_TYPE of the template, not its\n+\tassociated most generic TEMPLATE_DECL.\n+\t(append_type_to_template_for_access_check): Augment function\n+\tcomments. Use the new get_types_needing_access_check, not\n+\tMEMBER_TYPE_NEEDING_ACCESS_CHECK. Use the new\n+\tappend_type_to_template_for_access_check_1 subroutine.\n+\n 2009-05-22  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/38064"}, {"sha": "79bc9284b0a5232a34b35022cca1a14330fb5fc8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -2232,6 +2232,9 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n #define TI_ARGS(NODE) (TREE_VALUE (NODE))\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+/* The list of typedefs - used in the template - that need\n+   access checking at template instantiation time.  */\n+#define TI_TYPEDEFS_NEEDING_ACCESS_CHECKING(NODE) (TREE_CHAIN (NODE))\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -3160,11 +3163,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == TYPE_DECL \\\n    && !DECL_TEMPLATE_TEMPLATE_PARM_P (NODE))\n \n-/* The chained list of typedefs that are referenced in templates.\n-   These typedefs need to be access checked at template instantiation time.\n-   There are put here at parsing time.  */\n-#define MEMBER_TYPES_NEEDING_ACCESS_CHECK(NODE) DECL_ACCESS (NODE)\n-\n /* Nonzero if NODE which declares a type.  */\n #define DECL_DECLARES_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == TYPE_DECL || DECL_CLASS_TEMPLATE_P (NODE))\n@@ -4572,6 +4570,7 @@ extern bool template_parameter_pack_p           (const_tree);\n extern tree make_pack_expansion                 (tree);\n extern bool check_for_bare_parameter_packs      (tree);\n extern tree get_template_info\t\t\t(tree);\n+extern tree get_types_needing_access_check\t(tree);\n extern int template_class_depth\t\t\t(tree);\n extern int is_specialization_of\t\t\t(tree, tree);\n extern bool is_specialization_of_friend\t\t(tree, tree);"}, {"sha": "41813772d1e31a4af1cb029ced00816c8311180d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 106, "deletions": 29, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -175,6 +175,7 @@ static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n static tree tsubst_pack_expansion (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_decl (tree, tree, tsubst_flags_t);\n static void perform_typedefs_access_check (tree tmpl, tree targs);\n+static void append_type_to_template_for_access_check_1 (tree, tree, tree);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -6941,10 +6942,12 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n {\n   tree t;\n \n-  if (!tmpl || TREE_CODE (tmpl) != TEMPLATE_DECL)\n+  if (!tmpl\n+      || (TREE_CODE (tmpl) != RECORD_TYPE\n+\t  && TREE_CODE (tmpl) != FUNCTION_DECL))\n     return;\n \n-  for (t = MEMBER_TYPES_NEEDING_ACCESS_CHECK (tmpl); t; t = TREE_CHAIN (t))\n+  for (t = get_types_needing_access_check (tmpl); t; t = TREE_CHAIN (t))\n     {\n       tree type_decl = TREE_PURPOSE (t);\n       tree type_scope = TREE_VALUE (t);\n@@ -6957,7 +6960,8 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n       if (uses_template_parms (type_scope))\n \ttype_scope = tsubst (type_scope, targs, tf_error, NULL_TREE);\n \n-      perform_or_defer_access_check (TYPE_BINFO (type_scope), type_decl, type_decl);\n+      perform_or_defer_access_check (TYPE_BINFO (type_scope),\n+\t\t\t\t     type_decl, type_decl);\n     }\n }\n \n@@ -7031,9 +7035,9 @@ instantiate_class_template (tree type)\n \n   SET_CLASSTYPE_INTERFACE_UNKNOWN (type);\n \n-  /* Set the input location to the template definition. This is needed\n-     if tsubsting causes an error.  */\n-  typedecl = TYPE_MAIN_DECL (type);\n+  /* Set the input location to the most specialized template definition.\n+     This is needed if tsubsting causes an error.  */\n+  typedecl = TYPE_MAIN_DECL (pattern);\n   input_location = DECL_SOURCE_LOCATION (typedecl);\n \n   TYPE_HAS_USER_CONSTRUCTOR (type) = TYPE_HAS_USER_CONSTRUCTOR (pattern);\n@@ -7439,8 +7443,8 @@ instantiate_class_template (tree type)\n   /* Some typedefs referenced from within the template code need to be access\n      checked at template instantiation time, i.e now. These types were\n      added to the template at parsing time. Let's get those and perform\n-     the acces checks then.  */\n-  perform_typedefs_access_check (templ, args);\n+     the access checks then.  */\n+  perform_typedefs_access_check (pattern, args);\n   perform_deferred_access_checks ();\n   pop_nested_class ();\n   pop_from_top_level ();\n@@ -12163,7 +12167,7 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n      checked at template instantiation time, i.e now. These types were\n      added to the template at parsing time. Let's get those and perfom\n      the acces checks then.  */\n-  perform_typedefs_access_check (tmpl, targ_ptr);\n+  perform_typedefs_access_check (DECL_TEMPLATE_RESULT (tmpl), targ_ptr);\n   perform_deferred_access_checks ();\n   pop_access_scope (fndecl);\n   pop_deferring_access_checks ();\n@@ -17267,33 +17271,108 @@ type_uses_auto (tree type)\n   return NULL_TREE;\n }\n \n+/* For a given template T, return the list of typedefs referenced\n+   in T for which access check is needed at T instantiation time.\n+   T is either  a FUNCTION_DECL or a RECORD_TYPE.\n+   Those typedefs were added to T by the function\n+   append_type_to_template_for_access_check.  */\n+\n+tree\n+get_types_needing_access_check (tree t)\n+{\n+  tree ti, result = NULL_TREE;\n+\n+  if (!t || t == error_mark_node)\n+    return t;\n+\n+  if (!(ti = get_template_info (t)))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (t) == RECORD_TYPE || TREE_CODE (t) == FUNCTION_DECL)\n+    {\n+      if (!TI_TEMPLATE (ti))\n+\treturn NULL_TREE;\n+\n+      result = TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti);\n+    }\n+\n+  return result;\n+}\n+\n+/* Append the typedef TYPE_DECL used in template T to a list of typedefs\n+   tied to T. That list of typedefs will be access checked at\n+   T instantiation time.\n+   T is either a FUNCTION_DECL or a RECORD_TYPE.\n+   TYPE_DECL is a TYPE_DECL node representing a typedef.\n+   SCOPE is the scope through which TYPE_DECL is accessed.\n+\n+   This function is a subroutine of\n+   append_type_to_template_for_access_check.  */\n+\n+static void\n+append_type_to_template_for_access_check_1 (tree t,\n+\t\t\t\t\t    tree type_decl,\n+\t\t\t\t\t    tree scope)\n+{\n+  tree ti;\n+\n+  if (!t || t == error_mark_node)\n+    return;\n+\n+  gcc_assert ((TREE_CODE (t) == FUNCTION_DECL\n+\t       || TREE_CODE (t) == RECORD_TYPE)\n+\t      && type_decl\n+\t      && TREE_CODE (type_decl) == TYPE_DECL\n+\t      && scope);\n+\n+  if (!(ti = get_template_info (t)))\n+    return;\n+\n+  gcc_assert (TI_TEMPLATE (ti));\n+\n+  TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti) =\n+    tree_cons (type_decl, scope, TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti));\n+}\n+\n /* Append TYPE_DECL to the template TEMPL.\n-   TEMPL is either a class type or a FUNCTION_DECL associated\n-   to a TEMPLATE_DECL.\n+   TEMPL is either a class type, a FUNCTION_DECL or a a TEMPLATE_DECL.\n    At TEMPL instanciation time, TYPE_DECL will be checked to see\n-   if it can be accessed through SCOPE.  */\n+   if it can be accessed through SCOPE.\n+\n+   e.g. consider the following code snippet:\n+\n+     class C\n+     {\n+       typedef int myint;\n+     };\n+\n+     template<class U> struct S\n+     {\n+       C::myint mi;\n+     };\n+\n+     S<char> s;\n+\n+   At S<char> instantiation time, we need to check the access of C::myint\n+   In other words, we need to check the access of the myint typedef through\n+   the C scope. For that purpose, this function will add the myint typedef\n+   and the scope C through which its being accessed to a list of typedefs\n+   tied to the template S. That list will be walked at template instantiation\n+   time and access check performed on each typedefs it contains.\n+   Note that this particular code snippet should yield an error because\n+   myint is private to C.  */\n \n void\n append_type_to_template_for_access_check (tree templ,\n                                           tree type_decl,\n \t\t\t\t\t  tree scope)\n {\n-  tree node, templ_decl;\n-\n-  gcc_assert (templ\n-\t      && get_template_info (templ)\n-\t      && TI_TEMPLATE (get_template_info (templ))\n-\t      && type_decl\n-\t      && (TREE_CODE (type_decl) == TYPE_DECL));\n+  tree node;\n \n-  templ_decl = TI_TEMPLATE (get_template_info (templ));\n-  gcc_assert (templ_decl);\n+  gcc_assert (type_decl && (TREE_CODE (type_decl) == TYPE_DECL));\n \n-  /* Make sure we don't append the type to the template twice.\n-     If this appears to be too slow, the\n-     MEMBER_TYPE_NEEDING_ACCESS_CHECK property\n-     of templ should be a hash table instead.  */\n-  for (node = MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl);\n+  /* Make sure we don't append the type to the template twice.  */\n+  for (node = get_types_needing_access_check (templ);\n        node;\n        node = TREE_CHAIN (node))\n     {\n@@ -17304,9 +17383,7 @@ append_type_to_template_for_access_check (tree templ,\n \treturn;\n     }\n \n-  MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl) =\n-    tree_cons (type_decl, scope,\n-\t       MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl));\n+  append_type_to_template_for_access_check_1 (templ, type_decl, scope);\n }\n \n #include \"gt-cp-pt.h\""}, {"sha": "dd806ec646efe7218cd1fabada0389f5b33a6f92", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -1,3 +1,11 @@\n+2009-05-26  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/40007\n+\t* g++.dg/template/typedef18.C: New test.\n+\t* g++.dg/template/typedef19.C: Likewise.\n+\t* g++.dg/template/typedef20.C: Likewise.\n+\t* g++.dg/template/access11.C: Adjust.\n+\n 2009-05-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR testsuite/40247"}, {"sha": "c9364a823999b9b2dd77967947213c170c928f26", "filename": "gcc/testsuite/g++.dg/template/access11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -17,7 +17,7 @@ template <> struct X::Y<int> {\n   A::X x;\t\t\t// { dg-error \"this context\" }\n };\n \n-template <typename T> struct X::Y { // { dg-error \"this context\" }\n+template <typename T> struct X::Y {\n   typename T::X x;\t\t// { dg-error \"this context\" }\n };\n "}, {"sha": "8ea3c736a0a26f24a557d773b4538d27c5ac01f0", "filename": "gcc/testsuite/g++.dg/template/typedef18.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef18.C?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -0,0 +1,24 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin PR c++/40007\n+// { dg-do compile }\n+\n+template<typename T>\n+struct x\n+{\n+  protected:\n+  typedef int type;\n+};\n+\n+template<typename T>\n+struct y : public x<T>\n+{\n+  typename x<T>::type z;\n+};\n+\n+template<>\n+struct y<void> : public x<void>\n+{\n+  typedef x<void>::type z;\n+};\n+\n+template class y<int>;"}, {"sha": "f576d4828e432ec467ecb4b8b5802e5fbe91fe55", "filename": "gcc/testsuite/g++.dg/template/typedef19.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef19.C?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -0,0 +1,21 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin PR c++/40007\n+// { dg-do compile }\n+\n+class A\n+{\n+  typedef int mytype; // { dg-error \"'typedef int A::mytype' is private\" }\n+};\n+\n+template <class T>\n+class B : public A\n+{\n+};\n+\n+template<class T>\n+class B<T*> : public A\n+{ // { dg-error \"within this context\" }\n+  mytype mem;\n+};\n+\n+B<int*> b;"}, {"sha": "a5cbdeb236bae072f355c6004109af8ae977782f", "filename": "gcc/testsuite/g++.dg/template/typedef20.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb25c98ab88d63e27089a920f3fbd6fc485cd9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef20.C?ref=2eb25c98ab88d63e27089a920f3fbd6fc485cd9e", "patch": "@@ -0,0 +1,27 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin PR c++/40007\n+// { dg-do compile }\n+\n+class x\n+{\n+  typedef int privtype; // { dg-error \"is private\" }\n+\n+protected:\n+  typedef int type;\n+};\n+\n+template<typename T>\n+struct y : public x\n+{\n+  typename x::type z;\n+};\n+\n+template<typename T>\n+struct y<T*> : public x\n+{ // { dg-error \"within this context\" }\n+  typedef x::type good;\n+  typedef x::privtype bad;\n+};\n+\n+template class y<int>;\n+template class y<int*>;"}]}