{"sha": "8223b65461fbeeb58f4753c23748b64daa84c10e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIyM2I2NTQ2MWZiZWViNThmNDc1M2MyMzc0OGI2NGRhYTg0YzEwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T13:18:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T13:18:05Z"}, "message": "[multiple changes]\n\n2017-09-08  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Op_Divide): Reordering code that handles\n\tdivisions with fixed point results to avoid generating twice\n\tthe runtime check on divide by zero.\n\t* checks.adb (Apply_Divide_Checks): Ensure that operands are\n\tnot evaluated twice (once for their runtime checks and once for\n\ttheir regular computation).\n\n2017-09-08  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb (Analyze_Part_Of): Add missing\n\treturn statements after issuing errors.  Add detection of\n\tout-of-order item and single concurrent type.\n\nFrom-SVN: r251892", "tree": {"sha": "9d2f1271bbeb68636f8cefd5f336b29f95329ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d2f1271bbeb68636f8cefd5f336b29f95329ae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8223b65461fbeeb58f4753c23748b64daa84c10e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8223b65461fbeeb58f4753c23748b64daa84c10e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8223b65461fbeeb58f4753c23748b64daa84c10e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8223b65461fbeeb58f4753c23748b64daa84c10e/comments", "author": null, "committer": null, "parents": [{"sha": "cfc29a96f8909d8112d7b3e81984801eb3bb505e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc29a96f8909d8112d7b3e81984801eb3bb505e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfc29a96f8909d8112d7b3e81984801eb3bb505e"}], "stats": {"total": 95, "additions": 82, "deletions": 13}, "files": [{"sha": "067d2751cb8d2e17eccbe026b553259e524db39d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8223b65461fbeeb58f4753c23748b64daa84c10e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8223b65461fbeeb58f4753c23748b64daa84c10e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8223b65461fbeeb58f4753c23748b64daa84c10e", "patch": "@@ -1,3 +1,18 @@\n+2017-09-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Divide): Reordering code that handles\n+\tdivisions with fixed point results to avoid generating twice\n+\tthe runtime check on divide by zero.\n+\t* checks.adb (Apply_Divide_Checks): Ensure that operands are\n+\tnot evaluated twice (once for their runtime checks and once for\n+\ttheir regular computation).\n+\n+2017-09-08  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Part_Of): Add missing\n+\treturn statements after issuing errors.  Add detection of\n+\tout-of-order item and single concurrent type.\n+\n 2017-09-08  Nicolas Roche  <roche@adacore.com>\n \n \t* gcc-interface/Makefile.in, a-extiti.ads, s-taprop-linux.adb,"}, {"sha": "236b300b10cdfa4c61ea17451f4127dd62360726", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8223b65461fbeeb58f4753c23748b64daa84c10e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8223b65461fbeeb58f4753c23748b64daa84c10e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8223b65461fbeeb58f4753c23748b64daa84c10e", "patch": "@@ -7114,13 +7114,26 @@ package body Exp_Ch4 is\n \n       if Is_Fixed_Point_Type (Typ) then\n \n+         --  No special processing if Treat_Fixed_As_Integer is set, since\n+         --  from a semantic point of view such operations are simply integer\n+         --  operations and will be treated that way.\n+\n+         if not Treat_Fixed_As_Integer (N) then\n+            if Is_Integer_Type (Rtyp) then\n+               Expand_Divide_Fixed_By_Integer_Giving_Fixed (N);\n+            else\n+               Expand_Divide_Fixed_By_Fixed_Giving_Fixed (N);\n+            end if;\n+         end if;\n+\n          --  Deal with divide-by-zero check if back end cannot handle them\n          --  and the flag is set indicating that we need such a check. Note\n          --  that we don't need to bother here with the case of mixed-mode\n          --  (Right operand an integer type), since these will be rewritten\n          --  with conversions to a divide with a fixed-point right operand.\n \n-         if Do_Division_Check (N)\n+         if Nkind (N) = N_Op_Divide\n+           and then Do_Division_Check (N)\n            and then not Backend_Divide_Checks_On_Target\n            and then not Is_Integer_Type (Rtyp)\n          then\n@@ -7134,18 +7147,6 @@ package body Exp_Ch4 is\n                   Reason  => CE_Divide_By_Zero));\n          end if;\n \n-         --  No special processing if Treat_Fixed_As_Integer is set, since\n-         --  from a semantic point of view such operations are simply integer\n-         --  operations and will be treated that way.\n-\n-         if not Treat_Fixed_As_Integer (N) then\n-            if Is_Integer_Type (Rtyp) then\n-               Expand_Divide_Fixed_By_Integer_Giving_Fixed (N);\n-            else\n-               Expand_Divide_Fixed_By_Fixed_Giving_Fixed (N);\n-            end if;\n-         end if;\n-\n       --  Other cases of division of fixed-point operands. Again we exclude the\n       --  case where Treat_Fixed_As_Integer is set.\n "}, {"sha": "a8eed864a33c9e0c9330f2d514c08e3e6f8f40e0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8223b65461fbeeb58f4753c23748b64daa84c10e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8223b65461fbeeb58f4753c23748b64daa84c10e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8223b65461fbeeb58f4753c23748b64daa84c10e", "patch": "@@ -3247,6 +3247,7 @@ package body Sem_Prag is\n             SPARK_Msg_NE\n               (\"\\& is not part of the hidden state of package %\",\n                Indic, Item_Id);\n+            return;\n \n          --  The item appears in the visible state space of some package. In\n          --  general this scenario does not warrant Part_Of except when the\n@@ -3283,6 +3284,7 @@ package body Sem_Prag is\n                     (\"indicator Part_Of must denote abstract state or public \"\n                      & \"descendant of & (SPARK RM 7.2.6(3))\",\n                      Indic, Parent_Unit);\n+                  return;\n \n                elsif Scope (Encap_Id) = Parent_Unit\n                  or else\n@@ -3296,6 +3298,7 @@ package body Sem_Prag is\n                     (\"indicator Part_Of must denote abstract state or public \"\n                      & \"descendant of & (SPARK RM 7.2.6(3))\",\n                      Indic, Parent_Unit);\n+                  return;\n                end if;\n \n             --  Indicator Part_Of is not needed when the related package is not\n@@ -3309,6 +3312,7 @@ package body Sem_Prag is\n                SPARK_Msg_NE\n                  (\"\\& is declared in the visible part of package %\",\n                   Indic, Item_Id);\n+               return;\n             end if;\n \n          --  When the item appears in the private state space of a package, the\n@@ -3323,6 +3327,7 @@ package body Sem_Prag is\n                SPARK_Msg_NE\n                  (\"\\& is declared in the private part of package %\",\n                   Indic, Item_Id);\n+               return;\n             end if;\n \n          --  Items declared in the body state space of a package do not need\n@@ -3338,6 +3343,8 @@ package body Sem_Prag is\n                SPARK_Msg_NE\n                  (\"\\& is declared in the body of package %\", Indic, Item_Id);\n             end if;\n+\n+            return;\n          end if;\n \n       --  The encapsulator is a single concurrent type\n@@ -3358,6 +3365,7 @@ package body Sem_Prag is\n             SPARK_Msg_NE\n               (Fix_Msg (Encap_Typ, \"constant & cannot act as constituent of \"\n                & \"single protected type %\"), Indic, Item_Id);\n+            return;\n \n          --  The constituent is a package instantiation\n \n@@ -3366,6 +3374,7 @@ package body Sem_Prag is\n             SPARK_Msg_NE\n               (Fix_Msg (Encap_Typ, \"package instantiation & cannot act as \"\n                & \"constituent of single protected type %\"), Indic, Item_Id);\n+            return;\n          end if;\n \n          --  When the item denotes an abstract state of a nested package, use\n@@ -3392,7 +3401,51 @@ package body Sem_Prag is\n               (Fix_Msg (Encap_Typ, \"constituent & must be declared \"\n                & \"immediately within the same region as single protected \"\n                & \"type %\"), Indic, Item_Id);\n+            return;\n          end if;\n+\n+         --  The declaration of the item should follow the declaration of its\n+         --  encapsulating single concurrent type and must appear in the same\n+         --  declarative region (SPARK RM 9.3).\n+\n+         declare\n+            N : Node_Id;\n+\n+         begin\n+            N := Next (Declaration_Node (Encap_Id));\n+            while Present (N) loop\n+               exit when N = Item_Decl;\n+               Next (N);\n+            end loop;\n+\n+            --  The single concurrent type might be in the visible part of a\n+            --  package, and the declaration of the item in the private part\n+            --  of the same package.\n+\n+            if No (N) then\n+               declare\n+                  Pack : constant Node_Id :=\n+                    Parent (Declaration_Node (Encap_Id));\n+               begin\n+                  if Nkind (Pack) = N_Package_Specification\n+                    and then not In_Private_Part (Encap_Id)\n+                  then\n+                     N := First (Private_Declarations (Pack));\n+                     while Present (N) loop\n+                        exit when N = Item_Decl;\n+                        Next (N);\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+\n+            if No (N) then\n+               SPARK_Msg_N\n+                 (\"indicator Part_Of must denote a previously declared \"\n+                  & \"single protected type or single task type\", Encap);\n+               return;\n+            end if;\n+         end;\n       end if;\n \n       Legal := True;"}]}