{"sha": "bb7e6d55dac07daafb45645002be2798f78c87b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI3ZTZkNTVkYWMwN2RhYWZiNDU2NDUwMDJiZTI3OThmNzhjODdiMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2011-02-17T16:18:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-02-17T16:18:24Z"}, "message": "re PR debug/47106 (-fcompare-debug failure (length) with  -fpartial-inlining -flto -fconserve-stack)\n\n\n\tPR debug/47106\n\tPR debug/47402\n\t* cfgexpand.c (account_used_vars_for_block): Remove.\n\t(estimated_stack_frame_size): Use referenced vars.\n\t* tree-inline.c (remap_decl): Only mark VAR_DECLs as referenced\n\tthat were referenced in the original function.  Test src_fn\n\trather than cfun.  Drop redundant get_var_ann.\n\t(setup_one_parameter): Drop redundant get_var_ann.\n\t(declare_return_variable): Likewise.\n\t(copy_decl_for_dup_finish): Mark VAR_DECLs referenced in src_fn.\n\t(copy_arguments_for_versioning): Drop redundant get_var_ann.\n\t* ipa-inline.c (compute_inline_parameters): Do not compute\n\tdisregard_inline_limits here.\n\tare not available.\n\t(compute_inlinable_for_current, pass_inlinable): New.\n\t(pass_inline_parameters): Require PROP_referenced_vars.\n\t* cgraphunit.c (cgraph_process_new_functions): Don't run\n\tcompute_inline_parameters explicitly unless function is in\n\tSSA form.\n\t(cgraph_analyze_function): Set .disregard_inline_limits.\n\t* tree-sra.c (convert_callers): Compute inliner parameters\n\tonly for functions already in SSA form.\n\t* g++.dg/debug/pr47106.C: New.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r170249", "tree": {"sha": "a5366c0ffa8ef61e2d0da52de00aa6d5a7cf2871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5366c0ffa8ef61e2d0da52de00aa6d5a7cf2871"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb7e6d55dac07daafb45645002be2798f78c87b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7e6d55dac07daafb45645002be2798f78c87b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb7e6d55dac07daafb45645002be2798f78c87b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7e6d55dac07daafb45645002be2798f78c87b2/comments", "author": null, "committer": null, "parents": [{"sha": "f181a8a73f8b1e0a36659eddcdd94f89ce897561", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f181a8a73f8b1e0a36659eddcdd94f89ce897561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f181a8a73f8b1e0a36659eddcdd94f89ce897561"}], "stats": {"total": 177, "additions": 109, "deletions": 68}, "files": [{"sha": "9b6168c0035d02ab291982a54c1c61fe764ea931", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -1,3 +1,29 @@\n+2011-02-17  Alexandre Oliva  <aoliva@redhat.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\tPR debug/47106\n+\tPR debug/47402\n+\t* cfgexpand.c (account_used_vars_for_block): Remove.\n+\t(estimated_stack_frame_size): Use referenced vars.\n+\t* tree-inline.c (remap_decl): Only mark VAR_DECLs as referenced\n+\tthat were referenced in the original function.  Test src_fn\n+\trather than cfun.  Drop redundant get_var_ann.\n+\t(setup_one_parameter): Drop redundant get_var_ann.\n+\t(declare_return_variable): Likewise.\n+\t(copy_decl_for_dup_finish): Mark VAR_DECLs referenced in src_fn.\n+\t(copy_arguments_for_versioning): Drop redundant get_var_ann.\n+\t* ipa-inline.c (compute_inline_parameters): Do not compute\n+\tdisregard_inline_limits here.\n+\tare not available.\n+\t(compute_inlinable_for_current, pass_inlinable): New.\n+\t(pass_inline_parameters): Require PROP_referenced_vars.\n+\t* cgraphunit.c (cgraph_process_new_functions): Don't run\n+\tcompute_inline_parameters explicitly unless function is in\n+\tSSA form.\n+\t(cgraph_analyze_function): Set .disregard_inline_limits.\n+\t* tree-sra.c (convert_callers): Compute inliner parameters\n+\tonly for functions already in SSA form.\n+\n 2011-02-17  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/sparc/sparc.h (CPP_ENDIAN_SPEC): Don't handle"}, {"sha": "897d0f9f2b3af7eee91f8861e60ff6d30f194aa5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 7, "deletions": 37, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -1311,30 +1311,6 @@ create_stack_guard (void)\n   crtl->stack_protect_guard = guard;\n }\n \n-/* A subroutine of expand_used_vars.  Walk down through the BLOCK tree\n-   expanding variables.  Those variables that can be put into registers\n-   are allocated pseudos; those that can't are put on the stack.\n-\n-   TOPLEVEL is true if this is the outermost BLOCK.  */\n-\n-static HOST_WIDE_INT\n-account_used_vars_for_block (tree block, bool toplevel)\n-{\n-  tree t;\n-  HOST_WIDE_INT size = 0;\n-\n-  /* Expand all variables at this level.  */\n-  for (t = BLOCK_VARS (block); t ; t = DECL_CHAIN (t))\n-    if (var_ann (t) && is_used_p (t))\n-      size += expand_one_var (t, toplevel, false);\n-\n-  /* Expand all variables at containing levels.  */\n-  for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n-    size += account_used_vars_for_block (t, false);\n-\n-  return size;\n-}\n-\n /* Prepare for expanding variables.  */\n static void\n init_vars_expansion (void)\n@@ -1379,23 +1355,17 @@ estimated_stack_frame_size (struct cgraph_node *node)\n {\n   HOST_WIDE_INT size = 0;\n   size_t i;\n-  tree var, outer_block = DECL_INITIAL (current_function_decl);\n-  unsigned ix;\n+  tree var;\n   tree old_cur_fun_decl = current_function_decl;\n+  referenced_var_iterator rvi;\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n \n   current_function_decl = node->decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\n-  init_vars_expansion ();\n+  push_cfun (fn);\n \n-  FOR_EACH_LOCAL_DECL (cfun, ix, var)\n-    {\n-      /* TREE_USED marks local variables that do not appear in lexical\n-\t blocks.  We don't want to expand those that do twice.  */\n-      if (TREE_USED (var))\n-        size += expand_one_var (var, true, false);\n-    }\n-  size += account_used_vars_for_block (outer_block, true);\n+  gcc_checking_assert (gimple_referenced_vars (fn));\n+  FOR_EACH_REFERENCED_VAR (fn, var, rvi)\n+    size += expand_one_var (var, true, false);\n \n   if (stack_vars_num > 0)\n     {"}, {"sha": "049d1b9f7b60e998cb670647f519fc5382a9f9cc", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -246,13 +246,14 @@ cgraph_process_new_functions (void)\n \t    cgraph_analyze_function (node);\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t  current_function_decl = fndecl;\n-\t  compute_inline_parameters (node);\n \t  if ((cgraph_state == CGRAPH_STATE_IPA_SSA\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n \t      /* When not optimizing, be sure we run early local passes anyway\n \t\t to expand OMP.  */\n \t      || !optimize)\n \t    execute_pass_list (pass_early_local_passes.pass.sub);\n+\t  else\n+\t    compute_inline_parameters (node);\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  free_dominance_info (CDI_DOMINATORS);\n \t  pop_cfun ();\n@@ -783,6 +784,11 @@ cgraph_analyze_function (struct cgraph_node *node)\n \n   assign_assembler_name_if_neeeded (node->decl);\n \n+  /* disregard_inline_limits affects topological order of the early optimization,\n+     so we need to compute it ahead of rest of inline parameters.  */\n+  node->local.disregard_inline_limits\n+    = DECL_DISREGARD_INLINE_LIMITS (node->decl);\n+\n   /* Make sure to gimplify bodies only once.  During analyzing a\n      function we lower it, which will require gimplified nested\n      functions, so we can end up here with an already gimplified"}, {"sha": "176f994bb0826a5d2972082add12772180ca0289", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -2006,9 +2006,6 @@ compute_inline_parameters (struct cgraph_node *node)\n \t  break;\n       node->local.can_change_signature = !e;\n     }\n-  if (node->local.inlinable && !node->local.disregard_inline_limits)\n-    node->local.disregard_inline_limits\n-      = DECL_DISREGARD_INLINE_LIMITS (node->decl);\n   estimate_function_body_sizes (node);\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n   node->global.time = inline_summary (node)->self_time;"}, {"sha": "a33a6afa643607f37be084ed1c28dcd3bd538c5d", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -729,7 +729,6 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_build_cfg);\n   NEXT_PASS (pass_warn_function_return);\n   NEXT_PASS (pass_build_cgraph_edges);\n-  NEXT_PASS (pass_inline_parameters);\n   *p = NULL;\n \n   /* Interprocedural optimization passes.  */\n@@ -747,12 +746,8 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_build_ssa);\n       NEXT_PASS (pass_lower_vector);\n       NEXT_PASS (pass_early_warn_uninitialized);\n-      /* Note that it is not strictly necessary to schedule an early\n-\t inline pass here.  However, some test cases (e.g.,\n-\t g++.dg/other/p334435.C g++.dg/other/i386-1.C) expect extern\n-\t inline functions to be inlined even at -O0.  This does not\n-\t happen during the first early inline pass.  */\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n+      NEXT_PASS (pass_inline_parameters);\n       NEXT_PASS (pass_early_inline);\n       NEXT_PASS (pass_all_early_optimizations);\n \t{"}, {"sha": "ad376c2bb65104b41f3c14dc7414a22939338e8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -1,3 +1,10 @@\n+2011-02-17  Alexandre Oliva  <aoliva@redhat.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\tPR debug/47106\n+\tPR debug/47402\n+\t* g++.dg/debug/pr47106.C: New.\n+\n 2011-02-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/43653"}, {"sha": "079f424536a52487881783318610f24a63ca6c38", "filename": "gcc/testsuite/g++.dg/debug/pr47106.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr47106.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr47106.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr47106.C?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-O -fpartial-inlining -flto -fconserve-stack -fcompare-debug\" }\n+\n+void end (int, int) __attribute__ ((__noreturn__));\n+\n+struct S\n+{\n+  int i;\n+  S *s;\n+};\n+\n+inline bool f (S *s)\n+{\n+  if (!s->s)\n+    end (0, 0);\n+  return s->s == s;\n+}\n+\n+inline bool\n+baz (S s1, S)\n+{\n+  while (f (&s1));\n+}\n+\n+inline bool\n+bar (S s1, S s2, S)\n+{\n+  baz (s1, s2);\n+}\n+\n+S getS ();\n+\n+bool\n+foo ()\n+{\n+  bar (getS (), getS (), getS ());\n+}"}, {"sha": "de30cfd67ef64a41170eb46e787a2c62dd457b73", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -312,13 +312,17 @@ remap_decl (tree decl, copy_body_data *id)\n \t    walk_tree (&DECL_QUALIFIER (t), copy_tree_body_r, id, NULL);\n \t}\n \n-      if (cfun && gimple_in_ssa_p (cfun)\n-\t  && (TREE_CODE (t) == VAR_DECL\n-\t      || TREE_CODE (t) == RESULT_DECL || TREE_CODE (t) == PARM_DECL))\n-\t{\n-\t  get_var_ann (t);\n-\t  add_referenced_var (t);\n-\t}\n+      if ((TREE_CODE (t) == VAR_DECL\n+\t   || TREE_CODE (t) == RESULT_DECL\n+\t   || TREE_CODE (t) == PARM_DECL)\n+\t  && id->src_fn && DECL_STRUCT_FUNCTION (id->src_fn)\n+\t  && gimple_referenced_vars (DECL_STRUCT_FUNCTION (id->src_fn))\n+\t  /* We don't want to mark as referenced VAR_DECLs that were\n+\t     not marked as such in the src function.  */\n+\t  && (TREE_CODE (decl) != VAR_DECL\n+\t      || referenced_var_lookup (DECL_STRUCT_FUNCTION (id->src_fn),\n+\t\t\t\t\tDECL_UID (decl))))\n+\tadd_referenced_var (t);\n       return t;\n     }\n \n@@ -2547,10 +2551,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \n   /* We're actually using the newly-created var.  */\n   if (gimple_in_ssa_p (cfun) && TREE_CODE (var) == VAR_DECL)\n-    {\n-      get_var_ann (var);\n-      add_referenced_var (var);\n-    }\n+    add_referenced_var (var);\n \n   /* Declare this new variable.  */\n   DECL_CHAIN (var) = *vars;\n@@ -2857,10 +2858,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n \n   var = copy_result_decl_to_var (result, id);\n   if (gimple_in_ssa_p (cfun))\n-    {\n-      get_var_ann (var);\n-      add_referenced_var (var);\n-    }\n+    add_referenced_var (var);\n \n   DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n \n@@ -2896,10 +2894,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n     {\n       tree temp = create_tmp_var (TREE_TYPE (result), \"retvalptr\");\n       if (gimple_in_ssa_p (id->src_cfun))\n-\t{\n-\t  get_var_ann (temp);\n-\t  add_referenced_var (temp);\n-\t}\n+\tadd_referenced_var (temp);\n       insert_decl_map (id, result, temp);\n       /* When RESULT_DECL is in SSA form, we need to use it's default_def\n \t SSA_NAME.  */\n@@ -4753,6 +4748,14 @@ copy_decl_for_dup_finish (copy_body_data *id, tree decl, tree copy)\n        new function.  */\n     DECL_CONTEXT (copy) = id->dst_fn;\n \n+  if (TREE_CODE (decl) == VAR_DECL\n+      /* C++ clones functions during parsing, before\n+\t referenced_vars.  */\n+      && gimple_referenced_vars (DECL_STRUCT_FUNCTION (id->src_fn))\n+      && referenced_var_lookup (DECL_STRUCT_FUNCTION (id->src_fn),\n+\t\t\t\tDECL_UID (decl)))\n+    add_referenced_var (copy);\n+\n   return copy;\n }\n \n@@ -4864,7 +4867,6 @@ copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n \t   as temporary variable later in function, the uses will be\n \t   replaced by local variable.  */\n \ttree var = copy_decl_to_var (arg, id);\n-\tget_var_ann (var);\n \tadd_referenced_var (var);\n \tinsert_decl_map (id, arg, var);\n         /* Declare this new variable.  */"}, {"sha": "f28719f5fe616b5f732ac98534fac66afd614095", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7e6d55dac07daafb45645002be2798f78c87b2/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=bb7e6d55dac07daafb45645002be2798f78c87b2", "patch": "@@ -4362,7 +4362,8 @@ convert_callers (struct cgraph_node *node, tree old_decl,\n     }\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (bitmap_set_bit (recomputed_callers, cs->caller->uid))\n+    if (bitmap_set_bit (recomputed_callers, cs->caller->uid)\n+\t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->decl)))\n       compute_inline_parameters (cs->caller);\n   BITMAP_FREE (recomputed_callers);\n "}]}