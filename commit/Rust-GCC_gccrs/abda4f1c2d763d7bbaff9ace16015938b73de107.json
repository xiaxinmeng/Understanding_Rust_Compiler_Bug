{"sha": "abda4f1c2d763d7bbaff9ace16015938b73de107", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkYTRmMWMyZDc2M2Q3YmJhZmY5YWNlMTYwMTU5MzhiNzNkZTEwNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-02-28T19:48:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-02-28T19:48:40Z"}, "message": "ia64.c (ia64_adjust_cost): All non-MM consumers have 4 cycle latency from MM producers.\n\n        * config/ia64/ia64.c (ia64_adjust_cost): All non-MM consumers have\n        4 cycle latency from MM producers.\n        (ia64_internal_sched_reorder): Likewise with pipeline flush.\n\nFrom-SVN: r50160", "tree": {"sha": "19373285dcb52e8445f8a8e8a3ecc1e64f47b5b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19373285dcb52e8445f8a8e8a3ecc1e64f47b5b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abda4f1c2d763d7bbaff9ace16015938b73de107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abda4f1c2d763d7bbaff9ace16015938b73de107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abda4f1c2d763d7bbaff9ace16015938b73de107", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abda4f1c2d763d7bbaff9ace16015938b73de107/comments", "author": null, "committer": null, "parents": [{"sha": "c0f0864904e86ae4a63125196a3cab6f553a783b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0f0864904e86ae4a63125196a3cab6f553a783b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0f0864904e86ae4a63125196a3cab6f553a783b"}], "stats": {"total": 59, "additions": 36, "deletions": 23}, "files": [{"sha": "20680cd5009c8659c6096634882201ffed9de9c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abda4f1c2d763d7bbaff9ace16015938b73de107/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abda4f1c2d763d7bbaff9ace16015938b73de107/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abda4f1c2d763d7bbaff9ace16015938b73de107", "patch": "@@ -1,3 +1,9 @@\n+2002-02-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_adjust_cost): All non-MM consumers have\n+\t4 cycle latency from MM producers.\n+\t(ia64_internal_sched_reorder): Likewise with pipeline flush.\n+\n 2002-02-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* mklibgcc.in: Don't use GNU make extension."}, {"sha": "c4b6afb7ba5fb8158c5b56d47509bc159cae442a", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abda4f1c2d763d7bbaff9ace16015938b73de107/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abda4f1c2d763d7bbaff9ace16015938b73de107/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=abda4f1c2d763d7bbaff9ace16015938b73de107", "patch": "@@ -5348,32 +5348,36 @@ ia64_adjust_cost (insn, link, dep_insn, cost)\n       if (reg_overlap_mentioned_p (SET_DEST (set), addr))\n \treturn cost + 1;\n     }\n+\n   if ((dep_class == ITANIUM_CLASS_IALU\n        || dep_class == ITANIUM_CLASS_ILOG\n        || dep_class == ITANIUM_CLASS_LD)\n       && (insn_class == ITANIUM_CLASS_MMMUL\n \t  || insn_class == ITANIUM_CLASS_MMSHF\n \t  || insn_class == ITANIUM_CLASS_MMSHFI))\n     return 3;\n+\n   if (dep_class == ITANIUM_CLASS_FMAC\n       && (insn_class == ITANIUM_CLASS_FMISC\n \t  || insn_class == ITANIUM_CLASS_FCVTFX\n \t  || insn_class == ITANIUM_CLASS_XMPY))\n     return 7;\n+\n   if ((dep_class == ITANIUM_CLASS_FMAC\n        || dep_class == ITANIUM_CLASS_FMISC\n        || dep_class == ITANIUM_CLASS_FCVTFX\n        || dep_class == ITANIUM_CLASS_XMPY)\n       && insn_class == ITANIUM_CLASS_STF)\n     return 8;\n+\n+  /* Intel docs say only LD, ST, IALU, ILOG, ISHF consumers have latency 4,\n+     but HP engineers say any non-MM operation.  */\n   if ((dep_class == ITANIUM_CLASS_MMMUL\n        || dep_class == ITANIUM_CLASS_MMSHF\n        || dep_class == ITANIUM_CLASS_MMSHFI)\n-      && (insn_class == ITANIUM_CLASS_LD\n-\t  || insn_class == ITANIUM_CLASS_ST\n-\t  || insn_class == ITANIUM_CLASS_IALU\n-\t  || insn_class == ITANIUM_CLASS_ILOG\n-\t  || insn_class == ITANIUM_CLASS_ISHF))\n+      && insn_class != ITANIUM_CLASS_MMMUL\n+      && insn_class != ITANIUM_CLASS_MMSHF\n+      && insn_class != ITANIUM_CLASS_MMSHFI)\n     return 4;\n \n   return cost;\n@@ -6185,31 +6189,34 @@ ia64_internal_sched_reorder (dump, sched_verbose, ready, pn_ready,\n       dump_current_packet (dump);\n     }\n \n+  /* Work around the pipeline flush that will occurr if the results of\n+     an MM instruction are accessed before the result is ready.  Intel\n+     documentation says this only happens with IALU, ISHF, ILOG, LD,\n+     and ST consumers, but experimental evidence shows that *any* non-MM\n+     type instruction will incurr the flush.  */\n   if (reorder_type == 0 && clock_var > 0 && ia64_final_schedule)\n     {\n       for (insnp = ready; insnp < e_ready; insnp++)\n \t{\n-\t  rtx insn = *insnp;\n+\t  rtx insn = *insnp, link;\n \t  enum attr_itanium_class t = ia64_safe_itanium_class (insn);\n-\t  if (t == ITANIUM_CLASS_IALU || t == ITANIUM_CLASS_ISHF\n-\t      || t == ITANIUM_CLASS_ILOG\n-\t      || t == ITANIUM_CLASS_LD || t == ITANIUM_CLASS_ST)\n-\t    {\n-\t      rtx link;\n-\t      for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) != REG_DEP_OUTPUT\n-\t\t    && REG_NOTE_KIND (link) != REG_DEP_ANTI)\n+\n+\t  if (t == ITANIUM_CLASS_MMMUL\n+\t      || t == ITANIUM_CLASS_MMSHF\n+\t      || t == ITANIUM_CLASS_MMSHFI)\n+\t    continue;\n+\n+\t  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+\t    if (REG_NOTE_KIND (link) == 0)\n+\t      {\n+\t\trtx other = XEXP (link, 0);\n+\t\tenum attr_itanium_class t0 = ia64_safe_itanium_class (other);\n+\t\tif (t0 == ITANIUM_CLASS_MMSHF || t0 == ITANIUM_CLASS_MMMUL)\n \t\t  {\n-\t\t    rtx other = XEXP (link, 0);\n-\t\t    enum attr_itanium_class t0 = ia64_safe_itanium_class (other);\n-\t\t    if (t0 == ITANIUM_CLASS_MMSHF\n-\t\t\t|| t0 == ITANIUM_CLASS_MMMUL)\n-\t\t      {\n-\t\t\tnop_cycles_until (clock_var, sched_verbose ? dump : NULL);\n-\t\t\tgoto out;\n-\t\t      }\n+\t\t    nop_cycles_until (clock_var, sched_verbose ? dump : NULL);\n+\t\t    goto out;\n \t\t  }\n-\t    }\n+\t      }\n \t}\n     }\n  out:"}]}