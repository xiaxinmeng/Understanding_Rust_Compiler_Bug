{"sha": "5743331e9d1e1168cab132e2021cfef4d91c3c0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc0MzMzMWU5ZDFlMTE2OGNhYjEzMmUyMDIxY2ZlZjRkOTFjM2MwZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-11-02T05:04:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-02T05:04:42Z"}, "message": "godump.c (struct macro_hash_value): Define.\n\n\t* godump.c (struct macro_hash_value): Define.\n\t(macro_hash_hashval): New static function.\n\t(macro_hash_eq, macro_hash_del): New static functions.\n\t(go_define): Use macro_hash_value to store values in macro_hash.\n\tReplace an old value on a redefinition.  Don't print anything to\n\tgo_dump_file.\n\t(go_undef): Delete the entry from the hash table.\n\t(go_output_typedef): For an enum, use macro_hash_value, and don't\n\tprint anything to go_dump_file.\n\t(go_print_macro): New static function.\n\t(go_finish): Traverse macro_hash with go_print_macro.\n\t(dump_go_spec_init): Update macro_hash creation for\n\tmacro_hash_value.\n\nFrom-SVN: r180762", "tree": {"sha": "a8945039b52fc173fcbdf531d5cfd5b326aeef8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8945039b52fc173fcbdf531d5cfd5b326aeef8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5743331e9d1e1168cab132e2021cfef4d91c3c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5743331e9d1e1168cab132e2021cfef4d91c3c0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5743331e9d1e1168cab132e2021cfef4d91c3c0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5743331e9d1e1168cab132e2021cfef4d91c3c0f/comments", "author": null, "committer": null, "parents": [{"sha": "1834883a343cb330ff22005cb078b12d1d94f2de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1834883a343cb330ff22005cb078b12d1d94f2de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1834883a343cb330ff22005cb078b12d1d94f2de"}], "stats": {"total": 171, "additions": 131, "deletions": 40}, "files": [{"sha": "fc8704d8502d056ce55ff9896d06600733ca3c4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5743331e9d1e1168cab132e2021cfef4d91c3c0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5743331e9d1e1168cab132e2021cfef4d91c3c0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5743331e9d1e1168cab132e2021cfef4d91c3c0f", "patch": "@@ -1,3 +1,19 @@\n+2011-11-01  Ian Lance Taylor  <iant@google.com>\n+\n+\t* godump.c (struct macro_hash_value): Define.\n+\t(macro_hash_hashval): New static function.\n+\t(macro_hash_eq, macro_hash_del): New static functions.\n+\t(go_define): Use macro_hash_value to store values in macro_hash.\n+\tReplace an old value on a redefinition.  Don't print anything to\n+\tgo_dump_file.\n+\t(go_undef): Delete the entry from the hash table.\n+\t(go_output_typedef): For an enum, use macro_hash_value, and don't\n+\tprint anything to go_dump_file.\n+\t(go_print_macro): New static function.\n+\t(go_finish): Traverse macro_hash with go_print_macro.\n+\t(dump_go_spec_init): Update macro_hash creation for\n+\tmacro_hash_value.\n+\n 2011-11-02  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_code_end): Declare ATTRIBUTE_UNUSED."}, {"sha": "a42e641d18121629a545420f4100bb5244f73b33", "filename": "gcc/godump.c", "status": "modified", "additions": 115, "deletions": 40, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5743331e9d1e1168cab132e2021cfef4d91c3c0f/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5743331e9d1e1168cab132e2021cfef4d91c3c0f/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=5743331e9d1e1168cab132e2021cfef4d91c3c0f", "patch": "@@ -62,7 +62,47 @@ static GTY(()) VEC(tree,gc) *queue;\n \n static htab_t macro_hash;\n \n-/* For the hash tables.  */\n+/* The type of a value in macro_hash.  */\n+\n+struct macro_hash_value\n+{\n+  /* The name stored in the hash table.  */\n+  char *name;\n+  /* The value of the macro.  */\n+  char *value;\n+};\n+\n+/* Calculate the hash value for an entry in the macro hash table.  */\n+\n+static hashval_t\n+macro_hash_hashval (const void *val)\n+{\n+  const struct macro_hash_value *mhval = (const struct macro_hash_value *) val;\n+  return htab_hash_string (mhval->name);\n+}\n+\n+/* Compare values in the macro hash table for equality.  */\n+\n+static int\n+macro_hash_eq (const void *v1, const void *v2)\n+{\n+  const struct macro_hash_value *mhv1 = (const struct macro_hash_value *) v1;\n+  const struct macro_hash_value *mhv2 = (const struct macro_hash_value *) v2;\n+  return strcmp (mhv1->name, mhv2->name) == 0;\n+}\n+\n+/* Free values deleted from the macro hash table.  */\n+\n+static void\n+macro_hash_del (void *v)\n+{\n+  struct macro_hash_value *mhv = (struct macro_hash_value *) v;\n+  XDELETEVEC (mhv->name);\n+  XDELETEVEC (mhv->value);\n+  XDELETE (mhv);\n+}\n+\n+/* For the string hash tables.  */\n \n static int\n string_hash_eq (const void *y1, const void *y2)\n@@ -77,10 +117,12 @@ go_define (unsigned int lineno, const char *buffer)\n {\n   const char *p;\n   const char *name_end;\n+  size_t out_len;\n   char *out_buffer;\n   char *q;\n   bool saw_operand;\n   bool need_operand;\n+  struct macro_hash_value *mhval;\n   char *copy;\n   hashval_t hashval;\n   void **slot;\n@@ -105,17 +147,17 @@ go_define (unsigned int lineno, const char *buffer)\n   memcpy (copy, buffer, name_end - buffer);\n   copy[name_end - buffer] = '\\0';\n \n+  mhval = XNEW (struct macro_hash_value);\n+  mhval->name = copy;\n+  mhval->value = NULL;\n+\n   hashval = htab_hash_string (copy);\n-  slot = htab_find_slot_with_hash (macro_hash, copy, hashval, NO_INSERT);\n-  if (slot != NULL)\n-    {\n-      XDELETEVEC (copy);\n-      return;\n-    }\n+  slot = htab_find_slot_with_hash (macro_hash, mhval, hashval, NO_INSERT);\n \n   /* For simplicity, we force all names to be hidden by adding an\n      initial underscore, and let the user undo this as needed.  */\n-  out_buffer = XNEWVEC (char, strlen (p) * 2 + 1);\n+  out_len = strlen (p) * 2 + 1;\n+  out_buffer = XNEWVEC (char, out_len);\n   q = out_buffer;\n   saw_operand = false;\n   need_operand = false;\n@@ -141,6 +183,7 @@ go_define (unsigned int lineno, const char *buffer)\n \t       don't worry about them.  */\n \t    const char *start;\n \t    char *n;\n+\t    struct macro_hash_value idval;\n \n \t    if (saw_operand)\n \t      goto unknown;\n@@ -151,8 +194,9 @@ go_define (unsigned int lineno, const char *buffer)\n \t    n = XALLOCAVEC (char, p - start + 1);\n \t    memcpy (n, start, p - start);\n \t    n[p - start] = '\\0';\n-\t    slot = htab_find_slot (macro_hash, n, NO_INSERT);\n-\t    if (slot == NULL || *slot == NULL)\n+\t    idval.name = n;\n+\t    idval.value = NULL;\n+\t    if (htab_find (macro_hash, &idval) == NULL)\n \t      {\n \t\t/* This is a reference to a name which was not defined\n \t\t   as a macro.  */\n@@ -382,18 +426,30 @@ go_define (unsigned int lineno, const char *buffer)\n   if (need_operand)\n     goto unknown;\n \n+  gcc_assert ((size_t) (q - out_buffer) < out_len);\n   *q = '\\0';\n \n-  slot = htab_find_slot_with_hash (macro_hash, copy, hashval, INSERT);\n-  *slot = copy;\n+  mhval->value = out_buffer;\n \n-  fprintf (go_dump_file, \"const _%s = %s\\n\", copy, out_buffer);\n+  if (slot == NULL)\n+    {\n+      slot = htab_find_slot_with_hash (macro_hash, mhval, hashval, INSERT);\n+      gcc_assert (slot != NULL && *slot == NULL);\n+    }\n+  else\n+    {\n+      if (*slot != NULL)\n+\tmacro_hash_del (*slot);\n+    }\n+\n+  *slot = mhval;\n \n-  XDELETEVEC (out_buffer);\n   return;\n \n  unknown:\n   fprintf (go_dump_file, \"// unknowndefine %s\\n\", buffer);\n+  if (slot != NULL)\n+    htab_clear_slot (macro_hash, slot);\n   XDELETEVEC (out_buffer);\n   XDELETEVEC (copy);\n }\n@@ -403,16 +459,16 @@ go_define (unsigned int lineno, const char *buffer)\n static void\n go_undef (unsigned int lineno, const char *buffer)\n {\n+  struct macro_hash_value mhval;\n   void **slot;\n \n   real_debug_hooks->undef (lineno, buffer);\n \n-  slot = htab_find_slot (macro_hash, buffer, NO_INSERT);\n-  if (slot == NULL)\n-    return;\n-  fprintf (go_dump_file, \"// undef _%s\\n\", buffer);\n-  /* We don't delete the slot from the hash table because that will\n-     cause a duplicate const definition.  */\n+  mhval.name = CONST_CAST (char *, buffer);\n+  mhval.value = NULL;\n+  slot = htab_find_slot (macro_hash, &mhval, NO_INSERT);\n+  if (slot != NULL)\n+    htab_clear_slot (macro_hash, slot);\n }\n \n /* A function or variable decl.  */\n@@ -909,32 +965,37 @@ go_output_typedef (struct godump_container *container, tree decl)\n \t   element = TREE_CHAIN (element))\n \t{\n \t  const char *name;\n+\t  struct macro_hash_value *mhval;\n \t  void **slot;\n+\t  char buf[100];\n \n \t  name = IDENTIFIER_POINTER (TREE_PURPOSE (element));\n \n \t  /* Sometimes a name will be defined as both an enum constant\n \t     and a macro.  Avoid duplicate definition errors by\n \t     treating enum constants as macros.  */\n-\t  slot = htab_find_slot (macro_hash, name, INSERT);\n-\t  if (*slot == NULL)\n-\t    {\n-\t      *slot = CONST_CAST (char *, name);\n-\t      fprintf (go_dump_file, \"const _%s = \", name);\n-\t      if (host_integerp (TREE_VALUE (element), 0))\n-\t\tfprintf (go_dump_file, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t tree_low_cst (TREE_VALUE (element), 0));\n-\t      else if (host_integerp (TREE_VALUE (element), 1))\n-\t\tfprintf (go_dump_file, HOST_WIDE_INT_PRINT_UNSIGNED,\n-\t\t\t ((unsigned HOST_WIDE_INT)\n-\t\t\t  tree_low_cst (TREE_VALUE (element), 1)));\n-\t      else\n-\t\tfprintf (go_dump_file, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n-\t\t\t ((unsigned HOST_WIDE_INT)\n-\t\t\t  TREE_INT_CST_HIGH (TREE_VALUE (element))),\n-\t\t\t TREE_INT_CST_LOW (TREE_VALUE (element)));\n-\t      fprintf (go_dump_file, \"\\n\");\n-\t    }\n+\t  mhval = XNEW (struct macro_hash_value);\n+\t  mhval->name = xstrdup (name);\n+\t  mhval->value = NULL;\n+\t  slot = htab_find_slot (macro_hash, mhval, INSERT);\n+\t  if (*slot != NULL)\n+\t    macro_hash_del (*slot);\n+\n+\t  if (host_integerp (TREE_VALUE (element), 0))\n+\t    snprintf (buf, sizeof buf, HOST_WIDE_INT_PRINT_DEC,\n+\t\t     tree_low_cst (TREE_VALUE (element), 0));\n+\t  else if (host_integerp (TREE_VALUE (element), 1))\n+\t    snprintf (buf, sizeof buf, HOST_WIDE_INT_PRINT_UNSIGNED,\n+\t\t     ((unsigned HOST_WIDE_INT)\n+\t\t      tree_low_cst (TREE_VALUE (element), 1)));\n+\t  else\n+\t    snprintf (buf, sizeof buf, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n+\t\t     ((unsigned HOST_WIDE_INT)\n+\t\t      TREE_INT_CST_HIGH (TREE_VALUE (element))),\n+\t\t     TREE_INT_CST_LOW (TREE_VALUE (element)));\n+\n+\t  mhval->value = xstrdup (buf);\n+\t  *slot = mhval;\n \t}\n       pointer_set_insert (container->decls_seen, TREE_TYPE (decl));\n       if (TYPE_CANONICAL (TREE_TYPE (decl)) != NULL_TREE)\n@@ -1039,6 +1100,17 @@ go_output_var (struct godump_container *container, tree decl)\n     }\n }\n \n+/* Output the final value of a preprocessor macro or enum constant.\n+   This is called via htab_traverse_noresize.  */\n+\n+static int\n+go_print_macro (void **slot, void *arg ATTRIBUTE_UNUSED)\n+{\n+  struct macro_hash_value *mhval = (struct macro_hash_value *) *slot;\n+  fprintf (go_dump_file, \"const _%s = %s\\n\", mhval->name, mhval->value);\n+  return 1;\n+}\n+\n /* Build a hash table with the Go keywords.  */\n \n static const char * const keywords[] = {\n@@ -1123,6 +1195,8 @@ go_finish (const char *filename)\n \t}\n     }\n \n+  htab_traverse_noresize (macro_hash, go_print_macro, NULL);\n+\n   /* To emit dummy definitions.  */\n   pointer_set_traverse (container.pot_dummy_types, find_dummy_types,\n                         (void *) &container);\n@@ -1163,7 +1237,8 @@ dump_go_spec_init (const char *filename, const struct gcc_debug_hooks *hooks)\n   go_debug_hooks.global_decl = go_global_decl;\n   go_debug_hooks.type_decl = go_type_decl;\n \n-  macro_hash = htab_create (100, htab_hash_string, string_hash_eq, NULL);\n+  macro_hash = htab_create (100, macro_hash_hashval, macro_hash_eq,\n+\t\t\t    macro_hash_del);\n \n   return &go_debug_hooks;\n }"}]}