{"sha": "7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "node_id": "C_kwDOANBUbNoAKDdiZmZlYTg5ZjFmMTY0ZWZjMTBkZDM3ZDk3OWE4M2M0YzVmYmZhN2U", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-01-26T14:12:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-01-26T14:12:21Z"}, "message": "analyzer: fix false positives from -Wanalyzer-infinite-recursion [PR108524]\n\nReject -Wanalyzer-infinite-recursion diagnostics in which control flow\nhas been affected by conjured_svalues between the initial call to a\nfunction and the subsequent entry to that function.  This prevents false\npositives such as in qemu's recursive JSON parser where function calls are\nchanging state in the rest of the program (e.g. consuming tokens), despite\nthe modelled state being effectively identical at both nested entrypoints.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/108524\n\t* analyzer.h (class feasible_node): New forward decl.\n\t* diagnostic-manager.cc (epath_finder::get_best_epath): Add \"pd\"\n\tparam.\n\t(epath_finder::explore_feasible_paths): Likewise.\n\t(epath_finder::process_worklist_item): Likewise.  Use it to call\n\tpending_diagnostic::check_valid_fpath_p on the final fpath to\n\tgive pending_diagnostic a way to add additional restrictions on\n\tfeasibility.\n\t(saved_diagnostic::calc_best_epath): Pass pending_diagnostic to\n\tepath_finder::get_best_epath.\n\t* infinite-recursion.cc: Include \"analyzer/feasible-graph.h\".\n\t(infinite_recursion_diagnostic::check_valid_fpath_p): New.\n\t(infinite_recursion_diagnostic::fedge_uses_conjured_svalue_p): New.\n\t(infinite_recursion_diagnostic::expr_uses_conjured_svalue_p): New.\n\t* pending-diagnostic.h (pending_diagnostic::check_valid_fpath_p):\n\tNew vfunc.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108524\n\t* gcc.dg/analyzer/infinite-recursion-pr108524-1.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-pr108524-2.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-pr108524-qobject-json-parser.c:\n\tNew test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "43016790064bdf55f9225fe531fb1996c15f6abd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43016790064bdf55f9225fe531fb1996c15f6abd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e445d9e99814644e7edabac4c3feb5df50303d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e445d9e99814644e7edabac4c3feb5df50303d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e445d9e99814644e7edabac4c3feb5df50303d9"}], "stats": {"total": 717, "additions": 712, "deletions": 5}, "files": [{"sha": "a1619525afaf9322f1ef6d6ec387d6eea70f7c0f", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "patch": "@@ -126,6 +126,8 @@ class call_summary_replay;\n struct per_function_data;\n struct interesting_t;\n \n+class feasible_node;\n+\n /* Forward decls of functions.  */\n \n extern void dump_tree (pretty_printer *pp, tree t);"}, {"sha": "4f036a6c28aa4996832a2ae5b198f8a7bfbaa424", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "patch": "@@ -88,6 +88,7 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   get_best_epath (const exploded_node *target_enode,\n+\t\t  const pending_diagnostic &pd,\n \t\t  const char *desc, unsigned diag_idx,\n \t\t  std::unique_ptr<feasibility_problem> *out_problem);\n \n@@ -96,12 +97,14 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t  const pending_diagnostic &pd,\n \t\t\t  const char *desc, unsigned diag_idx);\n   bool\n   process_worklist_item (feasible_worklist *worklist,\n \t\t\t const trimmed_graph &tg,\n \t\t\t feasible_graph *fg,\n \t\t\t const exploded_node *target_enode,\n+\t\t\t const pending_diagnostic &pd,\n \t\t\t unsigned diag_idx,\n \t\t\t std::unique_ptr<exploded_path> *out_best_path) const;\n   void dump_trimmed_graph (const exploded_node *target_enode,\n@@ -138,6 +141,7 @@ class epath_finder\n \n std::unique_ptr<exploded_path>\n epath_finder::get_best_epath (const exploded_node *enode,\n+\t\t\t      const pending_diagnostic &pd,\n \t\t\t      const char *desc, unsigned diag_idx,\n \t\t\t      std::unique_ptr<feasibility_problem> *out_problem)\n {\n@@ -161,7 +165,7 @@ epath_finder::get_best_epath (const exploded_node *enode,\n       if (logger)\n \tlogger->log (\"trying to find shortest feasible path\");\n       if (std::unique_ptr<exploded_path> epath\n-\t    = explore_feasible_paths (enode, desc, diag_idx))\n+\t    = explore_feasible_paths (enode, pd, desc, diag_idx))\n \t{\n \t  if (logger)\n \t    logger->log (\"accepting %qs at EN: %i, SN: %i (sd: %i)\"\n@@ -374,6 +378,7 @@ class auto_checking_feasibility\n \n std::unique_ptr<exploded_path>\n epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t\t      const pending_diagnostic &pd,\n \t\t\t\t      const char *desc, unsigned diag_idx)\n {\n   logger *logger = get_logger ();\n@@ -415,8 +420,8 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n   {\n     auto_checking_feasibility sentinel (mgr);\n \n-    while (process_worklist_item (&worklist, tg, &fg, target_enode, diag_idx,\n-\t\t\t\t  &best_path))\n+    while (process_worklist_item (&worklist, tg, &fg, target_enode, pd,\n+\t\t\t\t  diag_idx, &best_path))\n       {\n \t/* Empty; the work is done within process_worklist_item.  */\n       }\n@@ -449,14 +454,18 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n    Return false if the processing of the worklist should stop\n    (either due to reaching TARGET_ENODE, or hitting a limit).\n    Write to *OUT_BEST_PATH if stopping due to finding a feasible path\n-   to TARGET_ENODE.  */\n+   to TARGET_ENODE.\n+   Use PD to provide additional restrictions on feasibility of\n+   the final path in the feasible_graph before converting to\n+   an exploded_path.  */\n \n bool\n epath_finder::\n process_worklist_item (feasible_worklist *worklist,\n \t\t       const trimmed_graph &tg,\n \t\t       feasible_graph *fg,\n \t\t       const exploded_node *target_enode,\n+\t\t       const pending_diagnostic &pd,\n \t\t       unsigned diag_idx,\n \t\t       std::unique_ptr<exploded_path> *out_best_path) const\n {\n@@ -514,6 +523,13 @@ process_worklist_item (feasible_worklist *worklist,\n \t\t\t     \" (length: %i)\",\n \t\t\t     target_enode->m_index, diag_idx,\n \t\t\t     succ_fnode->get_path_length ());\n+\t      if (!pd.check_valid_fpath_p (succ_fnode))\n+\t\t{\n+\t\t  if (logger)\n+\t\t    logger->log (\"rejecting feasible path due to\"\n+\t\t\t\t \" pending_diagnostic\");\n+\t\t  return false;\n+\t\t}\n \t      *out_best_path = fg->make_epath (succ_fnode);\n \t      if (flag_dump_analyzer_feasibility)\n \t\tdump_feasible_path (target_enode, diag_idx, *fg, *succ_fnode);\n@@ -808,7 +824,7 @@ saved_diagnostic::calc_best_epath (epath_finder *pf)\n   LOG_SCOPE (logger);\n   m_problem = NULL;\n \n-  m_best_epath = pf->get_best_epath (m_enode, m_d->get_kind (), m_idx,\n+  m_best_epath = pf->get_best_epath (m_enode, *m_d, m_d->get_kind (), m_idx,\n \t\t\t\t     &m_problem);\n \n   /* Handle failure to find a feasible path.  */"}, {"sha": "8d101d14fd0034f3b235b60b4eba850bf6eb5f70", "filename": "gcc/analyzer/infinite-recursion.cc", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Finfinite-recursion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Finfinite-recursion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Finfinite-recursion.cc?ref=7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/exploded-graph.h\"\n #include \"make-unique.h\"\n #include \"analyzer/checker-path.h\"\n+#include \"analyzer/feasible-graph.h\"\n \n /* A subclass of pending_diagnostic for complaining about suspected\n    infinite recursion.  */\n@@ -199,7 +200,106 @@ class infinite_recursion_diagnostic\n \tNULL, NULL, NULL));\n   }\n \n+  /* Reject paths in which conjured svalues have affected control flow\n+     since m_prev_entry_enode.  */\n+\n+  bool check_valid_fpath_p (const feasible_node *final_fnode)\n+    const final override\n+  {\n+    /* Reject paths in which calls with unknown side effects have occurred\n+       since m_prev_entry_enode.\n+       Find num calls with side effects.  Walk backward until we reach the\n+       pref */\n+    gcc_assert (final_fnode->get_inner_node () == m_new_entry_enode);\n+\n+    /* FG is actually a tree.  Walk backwards from FINAL_FNODE until we\n+       reach the prev_entry_enode (or the origin).  */\n+    const feasible_node *iter_fnode = final_fnode;\n+    while (iter_fnode->get_inner_node ()->m_index != 0)\n+      {\n+\tgcc_assert (iter_fnode->m_preds.length () == 1);\n+\n+\tfeasible_edge *pred_fedge\n+\t  = static_cast <feasible_edge *> (iter_fnode->m_preds[0]);\n+\n+\t/* Determine if conjured svalues have affected control flow\n+\t   since the prev entry node.  */\n+\tif (fedge_uses_conjured_svalue_p (pred_fedge))\n+\t  /* If so, then reject this diagnostic.  */\n+\t  return false;\n+\titer_fnode = static_cast <feasible_node *> (pred_fedge->m_src);\n+\tif (iter_fnode->get_inner_node () == m_prev_entry_enode)\n+\t  /* Accept this diagnostic.  */\n+\t  return true;\n+    }\n+\n+    /* We shouldn't get here; if we do, reject the diagnostic.  */\n+    gcc_unreachable ();\n+    return false;\n+  }\n+\n private:\n+  /* Return true iff control flow along FEDGE was affected by\n+     a conjured_svalue.  */\n+  static bool fedge_uses_conjured_svalue_p (feasible_edge *fedge)\n+  {\n+    const exploded_edge *eedge = fedge->get_inner_edge ();\n+    const superedge *sedge = eedge->m_sedge;\n+    if (!sedge)\n+      return false;\n+    const cfg_superedge *cfg_sedge = sedge->dyn_cast_cfg_superedge ();\n+    if (!cfg_sedge)\n+      return false;\n+    const gimple *last_stmt = sedge->m_src->get_last_stmt ();\n+    if (!last_stmt)\n+      return false;\n+\n+    const feasible_node *dst_fnode\n+      = static_cast<const feasible_node *> (fedge->m_dest);\n+    const region_model &model = dst_fnode->get_state ().get_model ();\n+\n+    if (const gcond *cond_stmt = dyn_cast <const gcond *> (last_stmt))\n+      {\n+\tif (expr_uses_conjured_svalue_p (model, gimple_cond_lhs (cond_stmt)))\n+\t  return true;\n+\tif (expr_uses_conjured_svalue_p (model, gimple_cond_rhs (cond_stmt)))\n+\t  return true;\n+      }\n+    else if (const gswitch *switch_stmt\n+\t       = dyn_cast <const gswitch *> (last_stmt))\n+      {\n+\tif (expr_uses_conjured_svalue_p (model,\n+\t\t\t\t\t gimple_switch_index (switch_stmt)))\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n+  /* Return true iff EXPR is affected by a conjured_svalue.  */\n+  static bool expr_uses_conjured_svalue_p (const region_model &model,\n+\t\t\t\t\t   tree expr)\n+  {\n+    class conjured_svalue_finder : public visitor\n+    {\n+    public:\n+      conjured_svalue_finder () : m_found_conjured_svalues (false)\n+      {\n+      }\n+      void\n+      visit_conjured_svalue (const conjured_svalue *) final override\n+      {\n+\tm_found_conjured_svalues = true;\n+      }\n+\n+      bool m_found_conjured_svalues;\n+    };\n+\n+    const svalue *sval = model.get_rvalue (expr, NULL);\n+    conjured_svalue_finder v;\n+    sval->accept (&v);\n+    return v.m_found_conjured_svalues;\n+  }\n+\n   const exploded_node *m_prev_entry_enode;\n   const exploded_node *m_new_entry_enode;\n   tree m_callee_fndecl;"}, {"sha": "b919d5b9099192b901e7cc278d994dee870175b9", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "patch": "@@ -347,6 +347,15 @@ class pending_diagnostic\n   {\n     /* Default no-op implementation.  */\n   }\n+\n+  /* Vfunc to give diagnostic subclasses the opportunity to reject diagnostics\n+     by imposing their own additional feasibility checks on the path to a\n+     given feasible_node.  */\n+  virtual bool check_valid_fpath_p (const feasible_node *) const\n+  {\n+    /* Default implementation: accept this path.  */\n+    return true;\n+  }\n };\n \n /* A template to make it easier to make subclasses of pending_diagnostic."}, {"sha": "d9221fa8dc5a5ce3d762eb49382b1de0e9e421ef", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-pr108524-1.c", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-1.c?ref=7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "patch": "@@ -0,0 +1,145 @@\n+/* Reduced from qemu-7.2.0's qobject/json-parser.c, which\n+   is licensed under LGPLv2.1 or later.  */\n+\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -Wno-analyzer-too-complex\" } */\n+\n+#define NULL ((void *)0)\n+typedef __builtin_va_list va_list;\n+\n+typedef struct _GQueue GQueue;\n+typedef struct Error Error;\n+typedef struct QList QList;\n+typedef struct QObject QObject;\n+\n+struct QObjectBase_ {\n+  /* [...snip...] */\n+};\n+\n+\n+struct QObject {\n+  struct QObjectBase_ base;\n+};\n+\n+#define QOBJECT(obj) ((QObject *)obj)\n+#define qobject_unref(OBJ) /* [...snip...] */\n+\n+typedef struct QTailQLink {\n+  void *tql_next;\n+  struct QTailQLink *tql_prev;\n+} QTailQLink;\n+\n+struct QList {\n+  struct QObjectBase_ base;\n+  union {\n+    struct QListEntry *tqh_first;\n+    QTailQLink tqh_circ;\n+  } head;\n+};\n+QList *qlist_new(void);\n+void qlist_append_obj(QList *qlist, QObject *obj);\n+\n+typedef enum json_token_type {\n+  /* [...snip...] */\t\t\t      \n+  JSON_LSQUARE,\n+  JSON_RSQUARE,\n+  /* [...snip...] */\t\t\t      \n+  JSON_COMMA,\n+  /* [...snip...] */\t\t\t      \n+  JSON_KEYWORD,\n+  /* [...snip...] */\t\t\t      \n+} JSONTokenType;\n+typedef struct JSONToken JSONToken;\n+\n+struct JSONToken {\n+  JSONTokenType type;\n+  int x;\n+  int y;\n+  char str[];\n+};\n+\n+typedef struct JSONParserContext {\n+  Error *err;\n+  JSONToken *current;\n+  GQueue *buf;\n+  va_list *ap;\n+} JSONParserContext;\n+static QObject *parse_value(JSONParserContext *ctxt);\n+\n+JSONToken *parser_context_pop_token(JSONParserContext *ctxt);\n+JSONToken *parser_context_peek_token(JSONParserContext *ctxt);\n+\n+static QObject *parse_array(JSONParserContext *ctxt) {\n+  QList *list = NULL;\n+  JSONToken *token, *peek;\n+\n+  token = parser_context_pop_token(ctxt);\n+\n+  list = qlist_new();\n+\n+  peek = parser_context_peek_token(ctxt);\n+  if (peek == NULL) {\n+    goto out;\n+  }\n+\n+  if (peek->type != JSON_RSQUARE) {\n+    QObject *obj;\n+\n+    obj = parse_value(ctxt); /* { dg-bogus \"infinite recursion\" } */\n+    if (obj == NULL) {\n+      goto out;\n+    }\n+\n+    qlist_append_obj(list, obj);\n+\n+    token = parser_context_pop_token(ctxt);\n+    if (token == NULL) {\n+      goto out;\n+    }\n+\n+    while (token->type != JSON_RSQUARE) {\n+      if (token->type != JSON_COMMA) {\n+        goto out;\n+      }\n+\n+      obj = parse_value(ctxt);\n+      if (obj == NULL) {\n+        goto out;\n+      }\n+\n+      qlist_append_obj(list, obj);\n+\n+      token = parser_context_pop_token(ctxt);\n+      if (token == NULL) {\n+        goto out;\n+      }\n+    }\n+  } else {\n+    (void)parser_context_pop_token(ctxt);\n+  }\n+\n+  return QOBJECT(list);\n+\n+out:\n+  qobject_unref(list);\n+  return NULL;\n+}\n+\n+QObject *parse_keyword(JSONParserContext *ctxt);\n+\n+QObject *parse_value(JSONParserContext *ctxt) {\n+  JSONToken *token;\n+\n+  token = parser_context_peek_token(ctxt);\n+  if (token == NULL) {\n+    return NULL;\n+  }\n+\n+  switch (token->type) {\n+  case JSON_LSQUARE:\n+    return parse_array(ctxt); /* { dg-bogus \"infinite recursion\" } */\n+  case JSON_KEYWORD:\n+    return parse_keyword(ctxt);\n+  default:\n+    return NULL;\n+  }\n+}"}, {"sha": "58f6d2f4463698b7fd288c8ce22085605d366b21", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-pr108524-2.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-2.c?ref=7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "patch": "@@ -0,0 +1,113 @@\n+struct st1;\n+\n+int foo (struct st1 *p);\n+int bar (struct st1 *p);\n+\n+void test_1 (struct st1 *p)\n+{\n+  test_1 (p); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+void test_2_if (struct st1 *p)\n+{\n+  if (foo (p))\n+    test_2_if (p); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+void test_2_switch (struct st1 *p)\n+{\n+  switch (foo (p))\n+    {\n+    case 0 ... 9:\n+      test_2_switch (p); /* { dg-bogus \"infinite recursion\" } */\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+void test_2_if_compound (struct st1 *p)\n+{\n+  if ((foo (p) + bar (p)) >= 0)\n+    test_2_if_compound (p); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+void test_3 (struct st1 *p)\n+{\n+  foo (p);\n+  test_3 (p); /* { dg-warning \"infinite recursion\" } */\n+  /* The content of *p never affects control flow, so we should\n+     report this.  */\n+}\n+\n+struct st2\n+{\n+  int i;\n+};\n+\n+void test_4 (struct st2 *p)\n+{\n+  if (p->i > 0)\n+    test_4 (p); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+void test_5 (struct st2 *p)\n+{\n+  if (p->i-- > 0)\n+    test_5 (p); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+/* Mixtures of heap allocation and recursion.  It's not clear what we\n+   should do for such cases, but make sure we don't ICE.  */\n+\n+void test_6 (struct st2 *p)\n+{\n+  struct st2 *q = __builtin_malloc (p->i);\n+  if (!q)\n+    return;\n+  q->i = p->i;\n+  test_6 (q);\n+  __builtin_free (q);\n+}\n+\n+void test_7 (struct st2 *p)\n+{\n+  struct st2 *q = __builtin_malloc (p->i);\n+  q->i = p->i; /* { dg-warning \"dereference of possibly-NULL 'q'\" } */\n+  test_7 (q);\n+  __builtin_free (q);\n+}\n+\n+void test_switch_1 (int i)\n+{\n+  int j;\n+  switch (i)\n+    {\n+    case 0:\n+      j = 1066;\n+      break;\n+    case 1:\n+      j = 1776;\n+      break;\n+    default:\n+      j = 1492;\n+      break;\n+    }\n+  test_switch_1 (j);  /* { dg-warning \"infinite recursion\" \"\" { xfail *-*-* } } */\n+}\n+\n+void test_switch_2 (int i)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      test_switch_2 (1066);\n+      break;\n+    case 1:\n+      test_switch_2 (1776);\n+      break;\n+    default:\n+      test_switch_2 (1492); /* { dg-warning \"infinite recursion\" \"\" { xfail *-*-* } } */\n+      break;\n+    }\n+}"}, {"sha": "b40326fc252dcf146a9248569c04da5a2e6b7375", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-pr108524-qobject-json-parser.c", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-qobject-json-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bffea89f1f164efc10dd37d979a83c4c5fbfa7e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-qobject-json-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108524-qobject-json-parser.c?ref=7bffea89f1f164efc10dd37d979a83c4c5fbfa7e", "patch": "@@ -0,0 +1,322 @@\n+/* Reduced from qemu-7.2.0's qobject/json-parser.c, which\n+   is licensed under LGPLv2.1 or later.  */\n+\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -Wno-analyzer-too-complex\" } */\n+\n+#define NULL ((void *)0)\n+typedef __builtin_va_list va_list;\n+typedef __SIZE_TYPE__ size_t;\n+\n+typedef struct _GString GString;\n+typedef struct _GQueue GQueue;\n+typedef struct Error Error;\n+typedef struct QDict QDict;\n+typedef struct QList QList;\n+typedef struct QObject QObject;\n+typedef struct QString QString;\n+\n+typedef enum QType {\n+  /* [...snip...] */\n+  QTYPE_QSTRING,\n+  /* [...snip...] */\n+} QType;\n+\n+struct QObjectBase_ {\n+  QType type;\n+};\n+\n+struct QObject {\n+  struct QObjectBase_ base;\n+};\n+\n+#define QOBJECT(obj) ((QObject *)obj)\n+#define qobject_unref(OBJ) /* [...snip...] */\n+\n+void qobject_ref_impl(QObject *obj);\n+QType qobject_type(const QObject *obj);\n+QObject *qobject_check_type(const QObject *obj, QType type);\n+\n+typedef struct QTailQLink {\n+  void *tql_next;\n+  struct QTailQLink *tql_prev;\n+} QTailQLink;\n+\n+typedef struct QDictEntry {\n+  char *key;\n+  QObject *value;\n+  struct {\n+    struct QDictEntry *le_next;\n+    struct QDictEntry **le_prev;\n+  } next;\n+} QDictEntry;\n+\n+struct QDict {\n+  struct QObjectBase_ base;\n+  size_t size;\n+  struct {\n+    struct QDictEntry *lh_first;\n+  } table[512];\n+};\n+\n+QDict *qdict_new(void);\n+void qdict_put_obj(QDict *qdict, const char *key, QObject *value);\n+int qdict_haskey(const QDict *qdict, const char *key);\n+typedef struct QListEntry {\n+  QObject *value;\n+  union {\n+    struct QListEntry *tqe_next;\n+    QTailQLink tqe_circ;\n+  } next;\n+} QListEntry;\n+\n+struct QList {\n+  struct QObjectBase_ base;\n+  union {\n+    struct QListEntry *tqh_first;\n+    QTailQLink tqh_circ;\n+  } head;\n+};\n+QList *qlist_new(void);\n+void qlist_append_obj(QList *qlist, QObject *obj);\n+\n+struct QString {\n+  struct QObjectBase_ base;\n+  const char *string;\n+};\n+QString *qstring_from_str(const char *str);\n+const char *qstring_get_str(const QString *qstring);\n+\n+typedef enum json_token_type {\n+  JSON_ERROR = 0,\n+\n+  JSON_LCURLY = 100,\n+  JSON_MIN = JSON_LCURLY,\n+  JSON_RCURLY,\n+  JSON_LSQUARE,\n+  JSON_RSQUARE,\n+  JSON_COLON,\n+  JSON_COMMA,\n+  JSON_INTEGER,\n+  JSON_FLOAT,\n+  JSON_KEYWORD,\n+  JSON_STRING,\n+  JSON_INTERP,\n+  JSON_END_OF_INPUT,\n+  JSON_MAX = JSON_END_OF_INPUT\n+} JSONTokenType;\n+typedef struct JSONToken JSONToken;\n+\n+struct JSONToken {\n+  JSONTokenType type;\n+  int x;\n+  int y;\n+  char str[];\n+};\n+\n+typedef struct JSONParserContext {\n+  Error *err;\n+  JSONToken *current;\n+  GQueue *buf;\n+  va_list *ap;\n+} JSONParserContext;\n+static QObject *parse_value(JSONParserContext *ctxt);\n+\n+void __attribute__((__format__(gnu_printf, 3, 4)))\n+parse_error(JSONParserContext *ctxt, JSONToken *token, const char *msg, ...);\n+\n+JSONToken *parser_context_pop_token(JSONParserContext *ctxt);\n+JSONToken *parser_context_peek_token(JSONParserContext *ctxt);\n+\n+static int parse_pair(JSONParserContext *ctxt, QDict *dict) {\n+  QObject *key_obj = NULL;\n+  QString *key;\n+  QObject *value;\n+  JSONToken *peek, *token;\n+\n+  peek = parser_context_peek_token(ctxt);\n+  if (peek == NULL) {\n+    parse_error(ctxt, NULL, \"premature EOI\");\n+    goto out;\n+  }\n+\n+  key_obj = parse_value(ctxt); /* { dg-bogus \"infinite recursion\" } */\n+  key = ((QString *)qobject_check_type(key_obj, QTYPE_QSTRING));\n+  if (!key) {\n+    parse_error(ctxt, peek, \"key is not a string in object\");\n+    goto out;\n+  }\n+\n+  token = parser_context_pop_token(ctxt);\n+  if (token == NULL) {\n+    parse_error(ctxt, NULL, \"premature EOI\");\n+    goto out;\n+  }\n+\n+  if (token->type != JSON_COLON) {\n+    parse_error(ctxt, token, \"missing : in object pair\");\n+    goto out;\n+  }\n+\n+  value = parse_value(ctxt);\n+  if (value == NULL) {\n+    parse_error(ctxt, token, \"Missing value in dict\");\n+    goto out;\n+  }\n+\n+  if (qdict_haskey(dict, qstring_get_str(key))) {\n+    parse_error(ctxt, token, \"duplicate key\");\n+    goto out;\n+  }\n+\n+  qdict_put_obj(dict, qstring_get_str(key), value);\n+\n+  qobject_unref(key_obj);\n+  return 0;\n+\n+out:\n+  qobject_unref(key_obj);\n+  return -1;\n+}\n+\n+static QObject *parse_object(JSONParserContext *ctxt) {\n+  QDict *dict = NULL;\n+  JSONToken *token, *peek;\n+\n+  token = parser_context_pop_token(ctxt);\n+\n+  dict = qdict_new();\n+\n+  peek = parser_context_peek_token(ctxt);\n+  if (peek == NULL) {\n+    parse_error(ctxt, NULL, \"premature EOI\");\n+    goto out;\n+  }\n+\n+  if (peek->type != JSON_RCURLY) {\n+    if (parse_pair(ctxt, dict) == -1) {\n+      goto out;\n+    }\n+\n+    token = parser_context_pop_token(ctxt);\n+    if (token == NULL) {\n+      parse_error(ctxt, NULL, \"premature EOI\");\n+      goto out;\n+    }\n+\n+    while (token->type != JSON_RCURLY) {\n+      if (token->type != JSON_COMMA) {\n+        parse_error(ctxt, token, \"expected separator in dict\");\n+        goto out;\n+      }\n+\n+      if (parse_pair(ctxt, dict) == -1) {\n+        goto out;\n+      }\n+\n+      token = parser_context_pop_token(ctxt);\n+      if (token == NULL) {\n+        parse_error(ctxt, NULL, \"premature EOI\");\n+        goto out;\n+      }\n+    }\n+  } else {\n+    (void)parser_context_pop_token(ctxt);\n+  }\n+\n+  return QOBJECT(dict);\n+\n+out:\n+  qobject_unref (dict);\n+  return NULL;\n+}\n+\n+static QObject *parse_array(JSONParserContext *ctxt) {\n+  QList *list = NULL;\n+  JSONToken *token, *peek;\n+\n+  token = parser_context_pop_token(ctxt);\n+\n+  list = qlist_new();\n+\n+  peek = parser_context_peek_token(ctxt);\n+  if (peek == NULL) {\n+    parse_error(ctxt, NULL, \"premature EOI\");\n+    goto out;\n+  }\n+\n+  if (peek->type != JSON_RSQUARE) {\n+    QObject *obj;\n+\n+    obj = parse_value(ctxt); /* { dg-bogus \"infinite recursion\" } */\n+    if (obj == NULL) {\n+      parse_error(ctxt, token, \"expecting value\");\n+      goto out;\n+    }\n+\n+    qlist_append_obj(list, obj);\n+\n+    token = parser_context_pop_token(ctxt);\n+    if (token == NULL) {\n+      parse_error(ctxt, NULL, \"premature EOI\");\n+      goto out;\n+    }\n+\n+    while (token->type != JSON_RSQUARE) {\n+      if (token->type != JSON_COMMA) {\n+        parse_error(ctxt, token, \"expected separator in list\");\n+        goto out;\n+      }\n+\n+      obj = parse_value(ctxt);\n+      if (obj == NULL) {\n+        parse_error(ctxt, token, \"expecting value\");\n+        goto out;\n+      }\n+\n+      qlist_append_obj(list, obj);\n+\n+      token = parser_context_pop_token(ctxt);\n+      if (token == NULL) {\n+        parse_error(ctxt, NULL, \"premature EOI\");\n+        goto out;\n+      }\n+    }\n+  } else {\n+    (void)parser_context_pop_token(ctxt);\n+  }\n+\n+  return QOBJECT(list);\n+\n+out:\n+  qobject_unref(list);\n+  return NULL;\n+}\n+\n+QObject *parse_keyword(JSONParserContext *ctxt);\n+QObject *parse_literal(JSONParserContext *ctxt);\n+\n+QObject *parse_value(JSONParserContext *ctxt) {\n+  JSONToken *token;\n+\n+  token = parser_context_peek_token(ctxt);\n+  if (token == NULL) {\n+    parse_error(ctxt, NULL, \"premature EOI\");\n+    return NULL;\n+  }\n+\n+  switch (token->type) {\n+  case JSON_LCURLY:\n+    return parse_object(ctxt); /* { dg-bogus \"infinite recursion\" } */\n+  case JSON_LSQUARE:\n+    return parse_array(ctxt); /* { dg-bogus \"infinite recursion\" } */\n+  case JSON_INTEGER:\n+  case JSON_FLOAT:\n+  case JSON_STRING:\n+    return parse_literal(ctxt);\n+  case JSON_KEYWORD:\n+    return parse_keyword(ctxt);\n+  default:\n+    parse_error(ctxt, token, \"expecting value\");\n+    return NULL;\n+  }\n+}"}]}