{"sha": "f8071c056663dad2458c96705b459561cd5ea130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgwNzFjMDU2NjYzZGFkMjQ1OGM5NjcwNWI0NTk1NjFjZDVlYTEzMA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2016-06-03T15:08:00Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2016-06-03T15:08:00Z"}, "message": "Implement x86 interrupt attribute\n\nThe interrupt and exception handlers are called by x86 processors.  X86\nhardware pushes information onto stack and calls the handler.  The\nrequirements are\n\n1. Both interrupt and exception handlers must use the 'IRET' instruction,\ninstead of the 'RET' instruction, to return from the handlers.\n2. All registers are callee-saved in interrupt and exception handlers.\n3. The difference between interrupt and exception handlers is the\nexception handler must pop 'ERROR_CODE' off the stack before the 'IRET'\ninstruction.\n\nThe design goals of interrupt and exception handlers for x86 processors\nare:\n\n1. Support both 32-bit and 64-bit modes.\n2. Flexible for compilers to optimize.\n3. Easy to use by programmers.\n\nTo implement interrupt and exception handlers for x86 processors, a\ncompiler should support:\n\n'interrupt' attribute\n\nUse this attribute to indicate that the specified function with\nmandatory arguments is an interrupt or exception handler.  The compiler\ngenerates function entry and exit sequences suitable for use in an\ninterrupt handler when this attribute is present.  The 'IRET' instruction,\ninstead of the 'RET' instruction, is used to return from interrupt or\nexception handlers.  All registers, except for the EFLAGS register which\nis restored by the 'IRET' instruction, are preserved by the compiler.\nSince GCC doesn't preserve MPX, SSE, MMX nor x87 states, the GCC option,\n-mgeneral-regs-only, should be used to compile interrupt and exception\nhandlers.\n\nNote for compiler implementers: If the compiler generates MPX, SSE, MMX\nor x87 instructions in an interrupt or exception handler, or functions\ncalled from an interrupt or exception handler may contain MPX, SSE, MMX\nor x87 instructions, the compiler must save and restore the corresponding\nstate.\n\nSince the direction flag in the FLAGS register in interrupt (exception)\nhandlers is undetermined, cld instruction must be emitted in function\nprologue if rep string instructions are used in interrupt (exception)\nhandler or interrupt (exception) handler isn't a leaf function.\n\nAny interruptible-without-stack-switch code must be compiled with\n-mno-red-zone since interrupt handlers can and will, because of the\nhardware design, touch the red zone.\n\n1. interrupt handler must be declared with a mandatory pointer argument:\n\nstruct interrupt_frame;\n\n__attribute__ ((interrupt))\nvoid\nf (struct interrupt_frame *frame)\n{\n...\n}\n\nand user must properly define the structure the pointer pointing to.\n\n2. exception handler:\n\nThe exception handler is very similar to the interrupt handler with\na different mandatory function signature:\n\ntypedef unsigned int uword_t __attribute__ ((mode (__word__)));\n\nstruct interrupt_frame;\n\n__attribute__ ((interrupt))\nvoid\nf (struct interrupt_frame *frame, uword_t error_code)\n{\n...\n}\n\nand compiler pops the error code off stack before the 'IRET' instruction.\n\nThe exception handler should only be used for exceptions which push an\nerror code and all other exceptions must use the interrupt handler.\nThe system will crash if the wrong handler is used.\n\n'no_caller_saved_registers' attribute\n\nUse this attribute to indicate that the specified function has no\ncaller-saved registers.  That is, all registers are callee-saved.\nThe compiler generates proper function entry and exit sequences to\nsave and restore any modified registers, except for the EFLAGS register.\nSince GCC doesn't preserve MPX, SSE, MMX nor x87 states, the GCC option,\n-mgeneral-regs-only, should be used to compile functions with\n'no_caller_saved_registers'attribute.\n\nNote for compiler implementers: If the compiler generates MPX, SSE,\nMMX or x87 instructions in a function with 'no_caller_saved_registers'\nattribute or functions called from a function with\n'no_caller_saved_registers' attribute may contain MPX, SSE, MMX or x87\ninstructions, the compiler must save and restore the corresponding state.\n\nThe user can call functions specified with 'no_caller_saved_registers'\nattribute from an interrupt handler without saving and restoring all\ncall clobbered registers.\n\nOn x86, interrupt handlers are only called by processors which push\ninterrupt data onto stack at the address where the normal return address\nis.  Interrupt handlers must access interrupt data via pointers so that\nthey can update interrupt data.\n\ngcc/\n\n\tPR target/66960\n\tPR target/67630\n\tPR target/67634\n\tPR target/67841\n\tPR target/68037\n\tPR target/68618\n\tPR target/68661\n\tPR target/69575\n\tPR target/69596\n\tPR target/69734\n\t* config/i386/i386-protos.h (ix86_epilogue_uses): New prototype.\n\t* config/i386/i386.c (ix86_conditional_register_usage): Preserve\n\tall registers, except for function return registers if there are\n\tno caller-saved registers.\n\t(ix86_set_func_type): New function.\n\t(ix86_set_current_function): Call ix86_set_func_type to set\n\tno_caller_saved_registers and func_type.  Call reinit_regs if\n\tcaller-saved registers are changed.  Don't allow MPX, SSE, MMX\n\tnor x87 instructions in interrupt handler nor function with\n\tno_caller_saved_registers attribute.\n\t(ix86_function_ok_for_sibcall): Return false if there are no\n\tcaller-saved registers.\n\t(type_natural_mode): Don't warn ABI change for MMX in interrupt\n\thandler.\n\t(ix86_function_arg_advance): Skip for callee in interrupt\n\thandler.\n\t(ix86_function_arg): Return special arguments in interrupt\n\thandler.\n\t(ix86_promote_function_mode): Promote pointer to word_mode only\n\tfor normal functions.\n\t(ix86_can_use_return_insn_p): Don't use `ret' instruction in\n\tinterrupt handler.\n\t(ix86_epilogue_uses): New function.\n\t(ix86_hard_regno_scratch_ok): Likewise.\n\t(ix86_save_reg): Preserve all registers in interrupt handler\n\tafter reload.  Preserve all registers, except for function\n\treturn registers, if there are no caller-saved registers after\n\treload.\n\t(find_drap_reg): Always use callee-saved register if there are\n\tno caller-saved registers.\n\t(ix86_minimum_incoming_stack_boundary): Return MIN_STACK_BOUNDARY\n\tfor interrupt handler.\n\t(ix86_expand_prologue): Don't allow DRAP in interrupt handler.\n\tEmit cld instruction if stringops are used in interrupt handler\n\tor interrupt handler isn't a leaf function.\n\t(ix86_expand_epilogue): Generate interrupt return for interrupt\n\thandler and pop the 'ERROR_CODE' off the stack before interrupt\n\treturn in exception handler.\n\t(ix86_expand_call): Disallow calling interrupt handler directly.\n\tIf there are no caller-saved registers, mark all registers that\n\tare clobbered by the call which returns as clobbered.\n\t(ix86_handle_no_caller_saved_registers_attribute): New function.\n\t(ix86_handle_interrupt_attribute): Likewise.\n\t(ix86_attribute_table): Add interrupt and no_caller_saved_registers\n\tattributes.\n\t(TARGET_HARD_REGNO_SCRATCH_OK): Likewise.\n\t* config/i386/i386.h (ACCUMULATE_OUTGOING_ARGS): Use argument\n\taccumulation in interrupt function if stack may be realigned to\n\tavoid DRAP.\n\t(EPILOGUE_USES): New.\n\t(function_type): New enum.\n\t(machine_function): Add func_type and no_caller_saved_registers.\n\t* config/i386/i386.md (UNSPEC_INTERRUPT_RETURN): New.\n\t(interrupt_return): New pattern.\n\t* doc/extend.texi: Document x86 interrupt and\n\tno_caller_saved_registers attributes.\n\ngcc/testsuite/\n\n\tPR target/66960\n\tPR target/67630\n\tPR target/67634\n\tPR target/67841\n\tPR target/68037\n\tPR target/68618\n\tPR target/68661\n\tPR target/69575\n\tPR target/69596\n\tPR target/69734\n\t* gcc.dg/guality/pr68037-1.c: New test.\n\t* gcc.dg/guality/pr68037-2.c: Likewise.\n\t* gcc.dg/guality/pr68037-3.c: Likewise.\n\t* gcc.dg/torture/pr68037-1.c: Likewise.\n\t* gcc.dg/torture/pr68037-2.c: Likewise.\n\t* gcc.dg/torture/pr68037-3.c: Likewise.\n\t* gcc.dg/torture/pr68661-1a.c: Likewise.\n\t* gcc.dg/torture/pr68661-1b.c: Likewise.\n\t* gcc.target/i386/interrupt-1.c: Likewise.\n\t* gcc.target/i386/interrupt-2.c: Likewise.\n\t* gcc.target/i386/interrupt-3.c: Likewise.\n\t* gcc.target/i386/interrupt-4.c: Likewise.\n\t* gcc.target/i386/interrupt-5.c: Likewise.\n\t* gcc.target/i386/interrupt-6.c: Likewise.\n\t* gcc.target/i386/interrupt-7.c: Likewise.\n\t* gcc.target/i386/interrupt-8.c: Likewise.\n\t* gcc.target/i386/interrupt-9.c: Likewise.\n\t* gcc.target/i386/interrupt-10.c: Likewise.\n\t* gcc.target/i386/interrupt-11.c: Likewise.\n\t* gcc.target/i386/interrupt-12.c: Likewise.\n\t* gcc.target/i386/interrupt-13.c: Likewise.\n\t* gcc.target/i386/interrupt-14.c: Likewise.\n\t* gcc.target/i386/interrupt-15.c: Likewise.\n\t* gcc.target/i386/interrupt-16.c: Likewise.\n\t* gcc.target/i386/interrupt-17.c: Likewise.\n\t* gcc.target/i386/interrupt-18.c: Likewise.\n\t* gcc.target/i386/interrupt-19.c: Likewise.\n\t* gcc.target/i386/interrupt-20.c: Likewise.\n\t* gcc.target/i386/interrupt-21.c: Likewise.\n\t* gcc.target/i386/interrupt-22.c: Likewise.\n\t* gcc.target/i386/interrupt-23.c: Likewise.\n\t* gcc.target/i386/interrupt-24.c: Likewise.\n\t* gcc.target/i386/interrupt-25.c: Likewise.\n\t* gcc.target/i386/interrupt-26.c: Likewise.\n\t* gcc.target/i386/interrupt-27.c: Likewise.\n\t* gcc.target/i386/interrupt-28.c: Likewise.\n\t* gcc.target/i386/interrupt-387-err-1.c: Likewise.\n\t* gcc.target/i386/interrupt-387-err-2.c: Likewise.\n\t* gcc.target/i386/interrupt-bnd-err-1.c: Likewise.\n\t* gcc.target/i386/interrupt-bnd-err-2.c: Likewise.\n\t* gcc.target/i386/interrupt-iamcu.c: Likewise.\n\t* gcc.target/i386/interrupt-mmx-err-1.c: Likewise.\n\t* gcc.target/i386/interrupt-mmx-err-2.c: Likewise.\n\t* gcc.target/i386/interrupt-redzone-1.c: Likewise.\n\t* gcc.target/i386/interrupt-redzone-2.c: Likewise.\n\t* gcc.target/i386/interrupt-sibcall-1.c: Likewise.\n\t* gcc.target/i386/interrupt-sibcall-2.c: Likewise.\n\t* gcc.target/i386/interrupt-switch-abi.c: Likewise.\n\nCo-Authored-By: Julia Koval <julia.koval@intel.com>\n\nFrom-SVN: r237073", "tree": {"sha": "bff8c00070b6ba84e83a3307dfe627df01162770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bff8c00070b6ba84e83a3307dfe627df01162770"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8071c056663dad2458c96705b459561cd5ea130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8071c056663dad2458c96705b459561cd5ea130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8071c056663dad2458c96705b459561cd5ea130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8071c056663dad2458c96705b459561cd5ea130/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9de2e7955be61ac143788fd7bc7bedc0f6890e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de2e7955be61ac143788fd7bc7bedc0f6890e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de2e7955be61ac143788fd7bc7bedc0f6890e93"}], "stats": {"total": 2046, "additions": 2031, "deletions": 15}, "files": [{"sha": "59b11c3d8d6131bc9975eab96fee4a3ce40dd6c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -1,3 +1,73 @@\n+2016-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Julia Koval  <julia.koval@intel.com>\n+\n+\tPR target/66960\n+\tPR target/67630\n+\tPR target/67634\n+\tPR target/67841\n+\tPR target/68037\n+\tPR target/68618\n+\tPR target/68661\n+\tPR target/69575\n+\tPR target/69596\n+\tPR target/69734\n+\t* config/i386/i386-protos.h (ix86_epilogue_uses): New prototype.\n+\t* config/i386/i386.c (ix86_conditional_register_usage): Preserve\n+\tall registers, except for function return registers if there are\n+\tno caller-saved registers.\n+\t(ix86_set_func_type): New function.\n+\t(ix86_set_current_function): Call ix86_set_func_type to set\n+\tno_caller_saved_registers and func_type.  Call reinit_regs if\n+\tcaller-saved registers are changed.  Don't allow MPX, SSE, MMX\n+\tnor x87 instructions in interrupt handler nor function with\n+\tno_caller_saved_registers attribute.\n+\t(ix86_function_ok_for_sibcall): Return false if there are no\n+\tcaller-saved registers.\n+\t(type_natural_mode): Don't warn ABI change for MMX in interrupt\n+\thandler.\n+\t(ix86_function_arg_advance): Skip for callee in interrupt\n+\thandler.\n+\t(ix86_function_arg): Return special arguments in interrupt\n+\thandler.\n+\t(ix86_promote_function_mode): Promote pointer to word_mode only\n+\tfor normal functions.\n+\t(ix86_can_use_return_insn_p): Don't use `ret' instruction in\n+\tinterrupt handler.\n+\t(ix86_epilogue_uses): New function.\n+\t(ix86_hard_regno_scratch_ok): Likewise.\n+\t(ix86_save_reg): Preserve all registers in interrupt handler\n+\tafter reload.  Preserve all registers, except for function\n+\treturn registers, if there are no caller-saved registers after\n+\treload.\n+\t(find_drap_reg): Always use callee-saved register if there are\n+\tno caller-saved registers.\n+\t(ix86_minimum_incoming_stack_boundary): Return MIN_STACK_BOUNDARY\n+\tfor interrupt handler.\n+\t(ix86_expand_prologue): Don't allow DRAP in interrupt handler.\n+\tEmit cld instruction if stringops are used in interrupt handler\n+\tor interrupt handler isn't a leaf function.\n+\t(ix86_expand_epilogue): Generate interrupt return for interrupt\n+\thandler and pop the 'ERROR_CODE' off the stack before interrupt\n+\treturn in exception handler.\n+\t(ix86_expand_call): Disallow calling interrupt handler directly.\n+\tIf there are no caller-saved registers, mark all registers that\n+\tare clobbered by the call which returns as clobbered.\n+\t(ix86_handle_no_caller_saved_registers_attribute): New function.\n+\t(ix86_handle_interrupt_attribute): Likewise.\n+\t(ix86_attribute_table): Add interrupt and no_caller_saved_registers\n+\tattributes.\n+\t(TARGET_HARD_REGNO_SCRATCH_OK): Likewise.\n+\t* config/i386/i386.h (ACCUMULATE_OUTGOING_ARGS): Use argument\n+\taccumulation in interrupt function if stack may be realigned to\n+\tavoid DRAP.\n+\t(EPILOGUE_USES): New.\n+\t(function_type): New enum.\n+\t(machine_function): Add func_type and no_caller_saved_registers.\n+\t* config/i386/i386.md (UNSPEC_INTERRUPT_RETURN): New.\n+\t(interrupt_return): New pattern.\n+\t* doc/extend.texi: Document x86 interrupt and\n+\tno_caller_saved_registers attributes.\n+\n 2016-06-03  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR tree-optimization/52171"}, {"sha": "9fd14f65756251980d8a09b75024a152747396ec", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -286,6 +286,8 @@ extern rtx maybe_get_pool_constant (rtx);\n extern char internal_label_prefix[16];\n extern int internal_label_prefix_len;\n \n+extern bool ix86_epilogue_uses (int);\n+\n struct ix86_address\n {\n   rtx base, index, disp;"}, {"sha": "0873ac749f58f6464d8916e82ef701df2888953b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 343, "deletions": 12, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -6024,6 +6024,15 @@ ix86_conditional_register_usage (void)\n {\n   int i, c_mask;\n \n+  /* If there are no caller-saved registers, preserve all registers.\n+     except fixed_regs and registers used for function return value\n+     since aggregate_value_p checks call_used_regs[regno] on return\n+     value.  */\n+  if (cfun && cfun->machine->no_caller_saved_registers)\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (!fixed_regs[i] && !ix86_function_value_regno_p (i))\n+\tcall_used_regs[i] = 0;\n+\n   /* For 32-bit targets, squash the REX registers.  */\n   if (! TARGET_64BIT)\n     {\n@@ -6795,6 +6804,40 @@ ix86_reset_previous_fndecl (void)\n   ix86_previous_fndecl = NULL_TREE;\n }\n \n+/* Set the func_type field from the function FNDECL.  */\n+\n+static void\n+ix86_set_func_type (tree fndecl)\n+{\n+  if (cfun->machine->func_type == TYPE_UNKNOWN)\n+    {\n+      if (lookup_attribute (\"interrupt\",\n+\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n+\t{\n+\t  int nargs = 0;\n+\t  for (tree arg = DECL_ARGUMENTS (fndecl);\n+\t       arg;\n+\t       arg = TREE_CHAIN (arg))\n+\t    nargs++;\n+\t  cfun->machine->no_caller_saved_registers = true;\n+\t  cfun->machine->func_type\n+\t    = nargs == 2 ? TYPE_EXCEPTION : TYPE_INTERRUPT;\n+\n+\t  /* Only dwarf2out.c can handle -WORD(AP) as a pointer argument.  */\n+\t  if (write_symbols != NO_DEBUG && write_symbols != DWARF2_DEBUG)\n+\t    sorry (\"Only DWARF debug format is supported for interrupt \"\n+\t\t   \"service routine.\");\n+\t}\n+      else\n+\t{\n+\t  cfun->machine->func_type = TYPE_NORMAL;\n+\t  if (lookup_attribute (\"no_caller_saved_registers\",\n+\t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n+\t    cfun->machine->no_caller_saved_registers = true;\n+\t}\n+    }\n+}\n+\n /* Establish appropriate back-end context for processing the function\n    FNDECL.  The argument might be NULL to indicate processing at top\n    level, outside of any function scope.  */\n@@ -6805,7 +6848,14 @@ ix86_set_current_function (tree fndecl)\n      several times in the course of compiling a function, and we don't want to\n      slow things down too much or call target_reinit when it isn't safe.  */\n   if (fndecl == ix86_previous_fndecl)\n-    return;\n+    {\n+      /* There may be 2 function bodies for the same function FNDECL,\n+\t one is extern inline and one isn't.  Call ix86_set_func_type\n+\t to set the func_type field.  */\n+      if (fndecl != NULL_TREE)\n+\tix86_set_func_type (fndecl);\n+      return;\n+    }\n \n   tree old_tree;\n   if (ix86_previous_fndecl == NULL_TREE)\n@@ -6822,6 +6872,8 @@ ix86_set_current_function (tree fndecl)\n       return;\n     }\n \n+  ix86_set_func_type (fndecl);\n+\n   tree new_tree = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);\n   if (new_tree == NULL_TREE)\n     new_tree = target_option_default_node;\n@@ -6838,13 +6890,54 @@ ix86_set_current_function (tree fndecl)\n     }\n   ix86_previous_fndecl = fndecl;\n \n+  static bool prev_no_caller_saved_registers;\n+\n   /* 64-bit MS and SYSV ABI have different set of call used registers.\n      Avoid expensive re-initialization of init_regs each time we switch\n      function context.  */\n   if (TARGET_64BIT\n       && (call_used_regs[SI_REG]\n \t  == (cfun->machine->call_abi == MS_ABI)))\n     reinit_regs ();\n+  /* Need to re-initialize init_regs if caller-saved registers are\n+     changed.  */\n+  else if (prev_no_caller_saved_registers\n+\t   != cfun->machine->no_caller_saved_registers)\n+    reinit_regs ();\n+\n+  if (cfun->machine->func_type != TYPE_NORMAL\n+      || cfun->machine->no_caller_saved_registers)\n+    {\n+      /* Don't allow MPX, SSE, MMX nor x87 instructions since they\n+\t may change processor state.  */\n+      const char *isa;\n+      if (TARGET_MPX)\n+\tisa = \"MPX\";\n+      else if (TARGET_SSE)\n+\tisa = \"SSE\";\n+      else if (TARGET_MMX)\n+\tisa = \"MMX/3Dnow\";\n+      else if (TARGET_80387)\n+\tisa = \"80387\";\n+      else\n+\tisa = NULL;\n+      if (isa != NULL)\n+\t{\n+\t  if (cfun->machine->func_type != TYPE_NORMAL)\n+\t    sorry (\"%s instructions aren't allowed in %s service routine\",\n+\t\t   isa, (cfun->machine->func_type == TYPE_EXCEPTION\n+\t\t\t ? \"exception\" : \"interrupt\"));\n+\t  else\n+\t    sorry (\"%s instructions aren't allowed in function with \"\n+\t\t   \"no_caller_saved_registers attribute\", isa);\n+\t  /* Don't issue the same error twice.  */\n+\t  cfun->machine->func_type = TYPE_NORMAL;\n+\t  cfun->machine->no_caller_saved_registers = false;\n+\t}\n+    }\n+\n+  prev_no_caller_saved_registers\n+    = cfun->machine->no_caller_saved_registers;\n }\n \n \f\n@@ -7126,6 +7219,11 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n   rtx a, b;\n   bool bind_global = decl && !targetm.binds_local_p (decl);\n \n+  /* Sibling call isn't OK if there are no caller-saved registers\n+     since all registers must be preserved before return.  */\n+  if (cfun->machine->no_caller_saved_registers)\n+    return false;\n+\n   /* If we are generating position-independent code, we cannot sibcall\n      optimize direct calls to global functions, as the PLT requires\n      %ebx be live. (Darwin does not have a PLT.)  */\n@@ -8294,6 +8392,8 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \t\t      }\n \t\t  }\n \t\telse if ((size == 8 && !TARGET_64BIT)\n+\t\t\t && (!cfun\n+\t\t\t     || cfun->machine->func_type == TYPE_NORMAL)\n \t\t\t && !TARGET_MMX\n \t\t\t && !TARGET_IAMCU)\n \t\t  {\n@@ -9272,6 +9372,11 @@ ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n   HOST_WIDE_INT bytes, words;\n   int nregs;\n \n+  /* The argument of interrupt handler is a special case and is\n+     handled in ix86_function_arg.  */\n+  if (!cum->caller && cfun->machine->func_type != TYPE_NORMAL)\n+    return;\n+\n   if (mode == BLKmode)\n     bytes = int_size_in_bytes (type);\n   else\n@@ -9588,6 +9693,36 @@ ix86_function_arg (cumulative_args_t cum_v, machine_mode omode,\n   HOST_WIDE_INT bytes, words;\n   rtx arg;\n \n+  if (!cum->caller && cfun->machine->func_type != TYPE_NORMAL)\n+    {\n+      gcc_assert (type != NULL_TREE);\n+      if (POINTER_TYPE_P (type))\n+\t{\n+\t  /* This is the pointer argument.  */\n+\t  gcc_assert (TYPE_MODE (type) == Pmode);\n+\t  if (cfun->machine->func_type == TYPE_INTERRUPT)\n+\t    /* -WORD(AP) in the current frame in interrupt handler.  */\n+\t    arg = plus_constant (Pmode, arg_pointer_rtx,\n+\t\t\t\t -UNITS_PER_WORD);\n+\t  else\n+\t    /* (AP) in the current frame in exception handler.  */\n+\t    arg = arg_pointer_rtx;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (cfun->machine->func_type == TYPE_EXCEPTION\n+\t\t      && TREE_CODE (type) == INTEGER_TYPE\n+\t\t      && TYPE_MODE (type) == word_mode);\n+\t  /* The integer argument is the error code at -WORD(AP) in\n+\t     the current frame in exception handler.  */\n+\t  arg = gen_rtx_MEM (word_mode,\n+\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t    arg_pointer_rtx,\n+\t\t\t\t\t    -UNITS_PER_WORD));\n+\t}\n+      return arg;\n+    }\n+\n   /* All pointer bounds arguments are handled separately here.  */\n   if ((type && POINTER_BOUNDS_TYPE_P (type))\n       || POINTER_BOUNDS_MODE_P (mode))\n@@ -10149,14 +10284,16 @@ ix86_function_value_bounds (const_tree valtype,\n }\n \n /* Pointer function arguments and return values are promoted to\n-   word_mode.  */\n+   word_mode for normal functions.  */\n \n static machine_mode\n ix86_promote_function_mode (const_tree type, machine_mode mode,\n \t\t\t    int *punsignedp, const_tree fntype,\n \t\t\t    int for_return)\n {\n-  if (type != NULL_TREE && POINTER_TYPE_P (type))\n+  if (cfun->machine->func_type == TYPE_NORMAL\n+      && type != NULL_TREE\n+      && POINTER_TYPE_P (type))\n     {\n       *punsignedp = POINTERS_EXTEND_UNSIGNED;\n       return word_mode;\n@@ -11367,7 +11504,10 @@ ix86_can_use_return_insn_p (void)\n {\n   struct ix86_frame frame;\n \n-  if (! reload_completed || frame_pointer_needed)\n+  /* Don't use `ret' instruction in interrupt handler.  */\n+  if (! reload_completed\n+      || frame_pointer_needed\n+      || cfun->machine->func_type != TYPE_NORMAL)\n     return 0;\n \n   /* Don't allow more than 32k pop, since that's all we can do\n@@ -11682,11 +11822,77 @@ ix86_select_alt_pic_regnum (void)\n   return INVALID_REGNUM;\n }\n \n+/* Return true if REGNO is used by the epilogue.  */\n+\n+bool\n+ix86_epilogue_uses (int regno)\n+{\n+  /* If there are no caller-saved registers, we preserve all registers,\n+     except for MMX and x87 registers which aren't supported when saving\n+     and restoring registers.  Don't explicitly save SP register since\n+     it is always preserved.  */\n+  return (epilogue_completed\n+\t  && cfun->machine->no_caller_saved_registers\n+\t  && !fixed_regs[regno]\n+\t  && !STACK_REGNO_P (regno)\n+\t  && !MMX_REGNO_P (regno));\n+}\n+\n+/* Return nonzero if register REGNO can be used as a scratch register\n+   in peephole2.  */\n+\n+static bool\n+ix86_hard_regno_scratch_ok (unsigned int regno)\n+{\n+  /* If there are no caller-saved registers, we can't use any register\n+     as a scratch register after epilogue and use REGNO as scratch\n+     register only if it has been used before to avoid saving and\n+     restoring it.  */\n+  return (!cfun->machine->no_caller_saved_registers\n+\t  || (!epilogue_completed\n+\t      && df_regs_ever_live_p (regno)));\n+}\n+\n /* Return TRUE if we need to save REGNO.  */\n \n static bool\n ix86_save_reg (unsigned int regno, bool maybe_eh_return)\n {\n+  /* If there are no caller-saved registers, we preserve all registers,\n+     except for MMX and x87 registers which aren't supported when saving\n+     and restoring registers.  Don't explicitly save SP register since\n+     it is always preserved.  */\n+  if (cfun->machine->no_caller_saved_registers)\n+    {\n+      /* Don't preserve registers used for function return value.  */\n+      rtx reg = crtl->return_rtx;\n+      if (reg)\n+\t{\n+\t  unsigned int i = REGNO (reg);\n+\t  unsigned int nregs = hard_regno_nregs[i][GET_MODE (reg)];\n+\t  while (nregs-- > 0)\n+\t    if ((i + nregs) == regno)\n+\t      return false;\n+\n+\t  reg = crtl->return_bnd;\n+\t  if (reg)\n+\t    {\n+\t      i = REGNO (reg);\n+\t      nregs = hard_regno_nregs[i][GET_MODE (reg)];\n+\t      while (nregs-- > 0)\n+\t\tif ((i + nregs) == regno)\n+\t\t  return false;\n+\t    }\n+\t}\n+\n+      return (df_regs_ever_live_p (regno)\n+\t      && !fixed_regs[regno]\n+\t      && !STACK_REGNO_P (regno)\n+\t      && !MMX_REGNO_P (regno)\n+\t      && (regno != HARD_FRAME_POINTER_REGNUM\n+\t\t  || !frame_pointer_needed));\n+    }\n+\n   if (regno == REAL_PIC_OFFSET_TABLE_REGNUM\n       && pic_offset_table_rtx)\n     {\n@@ -12400,13 +12606,17 @@ find_drap_reg (void)\n {\n   tree decl = cfun->decl;\n \n+  /* Always use callee-saved register if there are no caller-saved\n+     registers.  */\n   if (TARGET_64BIT)\n     {\n       /* Use R13 for nested function or function need static chain.\n \t Since function with tail call may use any caller-saved\n \t registers in epilogue, DRAP must not use caller-saved\n \t register in such case.  */\n-      if (DECL_STATIC_CHAIN (decl) || crtl->tail_call_emit)\n+      if (DECL_STATIC_CHAIN (decl)\n+\t  || cfun->machine->no_caller_saved_registers\n+\t  || crtl->tail_call_emit)\n \treturn R13_REG;\n \n       return R10_REG;\n@@ -12417,7 +12627,9 @@ find_drap_reg (void)\n \t Since function with tail call may use any caller-saved\n \t registers in epilogue, DRAP must not use caller-saved\n \t register in such case.  */\n-      if (DECL_STATIC_CHAIN (decl) || crtl->tail_call_emit)\n+      if (DECL_STATIC_CHAIN (decl)\n+\t  || cfun->machine->no_caller_saved_registers\n+\t  || crtl->tail_call_emit)\n \treturn DI_REG;\n \n       /* Reuse static chain register if it isn't used for parameter\n@@ -12458,8 +12670,12 @@ ix86_minimum_incoming_stack_boundary (bool sibcall)\n {\n   unsigned int incoming_stack_boundary;\n \n+  /* Stack of interrupt handler is always aligned to MIN_STACK_BOUNDARY.\n+   */\n+  if (cfun->machine->func_type != TYPE_NORMAL)\n+    incoming_stack_boundary = MIN_STACK_BOUNDARY;\n   /* Prefer the one specified at command line. */\n-  if (ix86_user_incoming_stack_boundary)\n+  else if (ix86_user_incoming_stack_boundary)\n     incoming_stack_boundary = ix86_user_incoming_stack_boundary;\n   /* In 32bit, use MIN_STACK_BOUNDARY for incoming stack boundary\n      if -mstackrealign is used, it isn't used for sibcall check and\n@@ -13220,6 +13436,12 @@ ix86_expand_prologue (void)\n     {\n       int align_bytes = crtl->stack_alignment_needed / BITS_PER_UNIT;\n \n+      /* Can't use DRAP in interrupt function.  */\n+      if (cfun->machine->func_type != TYPE_NORMAL)\n+\tsorry (\"Dynamic Realign Argument Pointer (DRAP) not supported \"\n+\t       \"in interrupt service routine.  This may be worked \"\n+\t       \"around by avoiding functions with aggregate return.\");\n+\n       /* Only need to push parameter pointer reg if it is caller saved.  */\n       if (!call_used_regs[REGNO (crtl->drap_reg)])\n \t{\n@@ -13595,8 +13817,14 @@ ix86_expand_prologue (void)\n   if (frame_pointer_needed && frame.red_zone_size)\n     emit_insn (gen_memory_blockage ());\n \n-  /* Emit cld instruction if stringops are used in the function.  */\n-  if (TARGET_CLD && ix86_current_function_needs_cld)\n+  /* Emit cld instruction if stringops are used in the function.  Since\n+     we can't assume the direction flag in interrupt handler, we must\n+     emit cld instruction if stringops are used in interrupt handler or\n+     interrupt handler isn't a leaf function.  */\n+  if ((TARGET_CLD && ix86_current_function_needs_cld)\n+      || (!TARGET_CLD\n+\t  && cfun->machine->func_type != TYPE_NORMAL\n+\t  && (ix86_current_function_needs_cld || !crtl->is_leaf)))\n     emit_insn (gen_cld ());\n \n   /* SEH requires that the prologue end within 256 bytes of the start of\n@@ -14079,7 +14307,20 @@ ix86_expand_epilogue (int style)\n       return;\n     }\n \n-  if (crtl->args.pops_args && crtl->args.size)\n+  if (cfun->machine->func_type != TYPE_NORMAL)\n+    {\n+      /* Return with the \"IRET\" instruction from interrupt handler.\n+\t Pop the 'ERROR_CODE' off the stack before the 'IRET'\n+\t instruction in exception handler.  */\n+      if (cfun->machine->func_type == TYPE_EXCEPTION)\n+\t{\n+\t  rtx r = plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t UNITS_PER_WORD);\n+\t  emit_insn (gen_rtx_SET (stack_pointer_rtx, r));\n+\t}\n+      emit_jump_insn (gen_interrupt_return ());\n+    }\n+  else if (crtl->args.pops_args && crtl->args.size)\n     {\n       rtx popc = GEN_INT (crtl->args.pops_args);\n \n@@ -27399,6 +27640,18 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   rtx vec[3];\n   rtx use = NULL, call;\n   unsigned int vec_len = 0;\n+  tree fndecl;\n+\n+  if (GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF)\n+    {\n+      fndecl = SYMBOL_REF_DECL (XEXP (fnaddr, 0));\n+      if (fndecl\n+\t  && (lookup_attribute (\"interrupt\",\n+\t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (fndecl)))))\n+\terror (\"interrupt service routine can't be called directly\");\n+    }\n+  else\n+    fndecl = NULL_TREE;\n \n   if (pop == const0_rtx)\n     pop = NULL;\n@@ -27535,8 +27788,30 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       vec[vec_len++] = pop;\n     }\n \n-  if (TARGET_64BIT_MS_ABI\n-      && (!callarg2 || INTVAL (callarg2) != -2))\n+  if (cfun->machine->no_caller_saved_registers\n+      && (!fndecl\n+\t  || (!TREE_THIS_VOLATILE (fndecl)\n+\t      && !lookup_attribute (\"no_caller_saved_registers\",\n+\t\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))))\n+    {\n+      static const char ix86_call_used_regs[] = CALL_USED_REGISTERS;\n+      bool is_64bit_ms_abi = (TARGET_64BIT\n+\t\t\t      && ix86_function_abi (fndecl) == MS_ABI);\n+      char c_mask = CALL_USED_REGISTERS_MASK (is_64bit_ms_abi);\n+\n+      /* If there are no caller-saved registers, add all registers\n+\t that are clobbered by the call which returns.  */\n+      for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (!fixed_regs[i]\n+\t    && (ix86_call_used_regs[i] == 1\n+\t\t|| (ix86_call_used_regs[i] & c_mask))\n+\t    && !STACK_REGNO_P (i)\n+\t    && !MMX_REGNO_P (i))\n+\t  clobber_reg (&use,\n+\t\t       gen_rtx_REG (GET_MODE (regno_reg_rtx[i]), i));\n+    }\n+  else if (TARGET_64BIT_MS_ABI\n+\t   && (!callarg2 || INTVAL (callarg2) != -2))\n     {\n       int const cregs_size\n \t= ARRAY_SIZE (x86_64_ms_sysv_extra_clobbered_registers);\n@@ -44906,6 +45181,54 @@ ix86_handle_fndecl_attribute (tree *node, tree name, tree, int,\n   return NULL_TREE;\n }\n \n+static tree\n+ix86_handle_no_caller_saved_registers_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t int, bool *)\n+{\n+  return NULL_TREE;\n+}\n+\n+static tree\n+ix86_handle_interrupt_attribute (tree *node, tree, tree, int, bool *)\n+{\n+  /* DECL_RESULT and DECL_ARGUMENTS do not exist there yet,\n+     but the function type contains args and return type data.  */\n+  tree func_type = *node;\n+  tree return_type = TREE_TYPE (func_type);\n+\n+  int nargs = 0;\n+  tree current_arg_type = TYPE_ARG_TYPES (func_type);\n+  while (current_arg_type\n+\t && ! VOID_TYPE_P (TREE_VALUE (current_arg_type)))\n+    {\n+      if (nargs == 0)\n+\t{\n+\t  if (! POINTER_TYPE_P (TREE_VALUE (current_arg_type)))\n+\t    error (\"interrupt service routine should have a pointer \"\n+\t\t   \"as the first argument\");\n+\t}\n+      else if (nargs == 1)\n+\t{\n+\t  if (TREE_CODE (TREE_VALUE (current_arg_type)) != INTEGER_TYPE\n+\t      || TYPE_MODE (TREE_VALUE (current_arg_type)) != word_mode)\n+\t    error (\"interrupt service routine should have unsigned %s\"\n+\t\t   \"int as the second argument\",\n+\t\t   TARGET_64BIT\n+\t\t   ? (TARGET_X32 ? \"long long \" : \"long \")\n+\t\t   : \"\");\n+\t}\n+      nargs++;\n+      current_arg_type = TREE_CHAIN (current_arg_type);\n+    }\n+  if (!nargs || nargs > 2)\n+    error (\"interrupt service routine can only have a pointer argument \"\n+\t   \"and an optional integer argument\");\n+  if (! VOID_TYPE_P (return_type))\n+    error (\"interrupt service routine can't have non-void return value\");\n+\n+  return NULL_TREE;\n+}\n+\n static bool\n ix86_ms_bitfield_layout_p (const_tree record_type)\n {\n@@ -49121,6 +49444,11 @@ static const struct attribute_spec ix86_attribute_table[] =\n     false },\n   { \"callee_pop_aggregate_return\", 1, 1, false, true, true,\n     ix86_handle_callee_pop_aggregate_return, true },\n+  { \"interrupt\", 0, 0, false, true, true,\n+    ix86_handle_interrupt_attribute, false },\n+  { \"no_caller_saved_registers\", 0, 0, false, true, true,\n+    ix86_handle_no_caller_saved_registers_attribute, false },\n+\n   /* End element.  */\n   { NULL,        0, 0, false, false, false, NULL, false }\n };\n@@ -55182,6 +55510,9 @@ ix86_addr_space_zero_address_valid (addr_space_t as)\n #undef TARGET_OPTAB_SUPPORTED_P\n #define TARGET_OPTAB_SUPPORTED_P ix86_optab_supported_p\n \n+#undef TARGET_HARD_REGNO_SCRATCH_OK\n+#define TARGET_HARD_REGNO_SCRATCH_OK ix86_hard_regno_scratch_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "f1fa02c3302831ac2dcc650895d43ff0dd319033", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -1637,11 +1637,18 @@ enum reg_class\n \n    If stack probes are required, the space used for large function\n    arguments on the stack must also be probed, so enable\n-   -maccumulate-outgoing-args so this happens in the prologue.  */\n+   -maccumulate-outgoing-args so this happens in the prologue.\n+\n+   We must use argument accumulation in interrupt function if stack\n+   may be realigned to avoid DRAP.  */\n \n #define ACCUMULATE_OUTGOING_ARGS \\\n-  ((TARGET_ACCUMULATE_OUTGOING_ARGS && optimize_function_for_speed_p (cfun)) \\\n-   || TARGET_STACK_PROBE || TARGET_64BIT_MS_ABI \\\n+  ((TARGET_ACCUMULATE_OUTGOING_ARGS \\\n+    && optimize_function_for_speed_p (cfun)) \\\n+   || (cfun->machine->func_type != TYPE_NORMAL \\\n+       && crtl->stack_realign_needed) \\\n+   || TARGET_STACK_PROBE \\\n+   || TARGET_64BIT_MS_ABI \\\n    || (TARGET_MACHO && crtl->profile))\n \n /* If defined, a C expression whose value is nonzero when we want to use PUSH\n@@ -1751,6 +1758,11 @@ typedef struct ix86_args {\n \n #define EXIT_IGNORE_STACK 1\n \n+/* Define this macro as a C expression that is nonzero for registers\n+   used by the epilogue or the `return' pattern.  */\n+\n+#define EPILOGUE_USES(REGNO) ix86_epilogue_uses (REGNO)\n+\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n \n@@ -2466,6 +2478,19 @@ struct GTY(()) machine_frame_state\n /* Private to winnt.c.  */\n struct seh_frame_state;\n \n+enum function_type\n+{\n+  TYPE_UNKNOWN = 0,\n+  TYPE_NORMAL,\n+  /* The current function is an interrupt service routine with a\n+     pointer argument as specified by the \"interrupt\" attribute.  */\n+  TYPE_INTERRUPT,\n+  /* The current function is an interrupt service routine with a\n+     pointer argument and an integer argument as specified by the\n+     \"interrupt\" attribute.  */\n+  TYPE_EXCEPTION\n+};\n+\n struct GTY(()) machine_function {\n   struct stack_local_entry *stack_locals;\n   const char *some_ld_name;\n@@ -2520,6 +2545,13 @@ struct GTY(()) machine_function {\n   /* If true, it is safe to not save/restore DRAP register.  */\n   BOOL_BITFIELD no_drap_save_restore : 1;\n \n+  /* Function type.  */\n+  ENUM_BITFIELD(function_type) func_type : 2;\n+\n+  /* If true, the current function is a function specified with\n+     the \"interrupt\" or \"no_caller_saved_registers\" attribute.  */\n+  BOOL_BITFIELD no_caller_saved_registers : 1;\n+\n   /* If true, there is register available for argument passing.  This\n      is used only in ix86_function_ok_for_sibcall by 32-bit to determine\n      if there is scratch register available for indirect sibcall.  In"}, {"sha": "e4ae4f214bd168b3afc03d4299ea429a111f4e4b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -194,6 +194,9 @@\n   UNSPEC_BNDCU\n   UNSPEC_BNDCN\n   UNSPEC_MPX_FENCE\n+\n+  ;; IRET support\n+  UNSPEC_INTERRUPT_RETURN\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -12437,6 +12440,14 @@\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"maybe_prefix_bnd\" \"1\")])\n \n+(define_insn \"interrupt_return\"\n+  [(simple_return)\n+   (unspec [(const_int 0)] UNSPEC_INTERRUPT_RETURN)]\n+  \"reload_completed\"\n+{\n+  return TARGET_64BIT ? \"iretq\" : \"iret\";\n+})\n+\n ;; Used by x86_machine_dependent_reorg to avoid penalty on single byte RET\n ;; instruction Athlon and K8 have.\n "}, {"sha": "727a694a35504d6960fc90543b438d1f8121d7ec", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -5266,6 +5266,79 @@ On x86-32 targets, the @code{stdcall} attribute causes the compiler to\n assume that the called function pops off the stack space used to\n pass arguments, unless it takes a variable number of arguments.\n \n+@item no_caller_saved_registers\n+@cindex @code{no_caller_saved_registers} function attribute, x86\n+Use this attribute to indicate that the specified function has no\n+caller-saved registers. That is, all registers are callee-saved. For\n+example, this attribute can be used for a function called from an\n+interrupt handler. The compiler generates proper function entry and\n+exit sequences to save and restore any modified registers, except for\n+the EFLAGS register.  Since GCC doesn't preserve MPX, SSE, MMX nor x87\n+states, the GCC option @option{-mgeneral-regs-only} should be used to\n+compile functions with @code{no_caller_saved_registers} attribute.\n+\n+@item interrupt\n+@cindex @code{interrupt} function attribute, x86\n+Use this attribute to indicate that the specified function is an\n+interrupt handler or an exception handler (depending on parameters passed\n+to the function, explained further).  The compiler generates function\n+entry and exit sequences suitable for use in an interrupt handler when\n+this attribute is present.  The @code{IRET} instruction, instead of the\n+@code{RET} instruction, is used to return from interrupt handlers.  All\n+registers, except for the EFLAGS register which is restored by the\n+@code{IRET} instruction, are preserved by the compiler.  Since GCC\n+doesn't preserve MPX, SSE, MMX nor x87 states, the GCC option\n+@option{-mgeneral-regs-only} should be used to compile interrupt and\n+exception handlers.\n+\n+Any interruptible-without-stack-switch code must be compiled with\n+@option{-mno-red-zone} since interrupt handlers can and will, because\n+of the hardware design, touch the red zone.\n+\n+An interrupt handler must be declared with a mandatory pointer\n+argument:\n+\n+@smallexample\n+struct interrupt_frame;\n+\n+__attribute__ ((interrupt))\n+void\n+f (struct interrupt_frame *frame)\n+@{\n+@}\n+@end smallexample\n+\n+@noindent\n+and you must define @code{struct interrupt_frame} as described in the\n+processor's manual.\n+\n+Exception handlers differ from interrupt handlers because the system\n+pushes an error code on the stack.  An exception handler declaration is\n+similar to that for an interrupt handler, but with a different mandatory\n+function signature.  The compiler arranges to pop the error code off the\n+stack before the @code{IRET} instruction.\n+\n+@smallexample\n+#ifdef __x86_64__\n+typedef unsigned long long int uword_t;\n+#else\n+typedef unsigned int uword_t;\n+#endif\n+\n+struct interrupt_frame;\n+\n+__attribute__ ((interrupt))\n+void\n+f (struct interrupt_frame *frame, uword_t error_code)\n+@{\n+  ...\n+@}\n+@end smallexample\n+\n+Exception handlers should only be used for exceptions that push an error\n+code; you should use an interrupt handler in other cases.  The system\n+will crash if the wrong kind of handler is used.\n+\n @item target (@var{options})\n @cindex @code{target} function attribute\n As discussed in @ref{Common Function Attributes}, this attribute "}, {"sha": "cd05a0e9af5c5682745d256b7a434eca5ee0fcb4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -1,3 +1,65 @@\n+2016-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Julia Koval  <julia.koval@intel.com>\n+\n+\tPR target/66960\n+\tPR target/67630\n+\tPR target/67634\n+\tPR target/67841\n+\tPR target/68037\n+\tPR target/68618\n+\tPR target/68661\n+\tPR target/69575\n+\tPR target/69596\n+\tPR target/69734\n+\t* gcc.dg/guality/pr68037-1.c: New test.\n+\t* gcc.dg/guality/pr68037-2.c: Likewise.\n+\t* gcc.dg/guality/pr68037-3.c: Likewise.\n+\t* gcc.dg/torture/pr68037-1.c: Likewise.\n+\t* gcc.dg/torture/pr68037-2.c: Likewise.\n+\t* gcc.dg/torture/pr68037-3.c: Likewise.\n+\t* gcc.dg/torture/pr68661-1a.c: Likewise.\n+\t* gcc.dg/torture/pr68661-1b.c: Likewise.\n+\t* gcc.target/i386/interrupt-1.c: Likewise.\n+\t* gcc.target/i386/interrupt-2.c: Likewise.\n+\t* gcc.target/i386/interrupt-3.c: Likewise.\n+\t* gcc.target/i386/interrupt-4.c: Likewise.\n+\t* gcc.target/i386/interrupt-5.c: Likewise.\n+\t* gcc.target/i386/interrupt-6.c: Likewise.\n+\t* gcc.target/i386/interrupt-7.c: Likewise.\n+\t* gcc.target/i386/interrupt-8.c: Likewise.\n+\t* gcc.target/i386/interrupt-9.c: Likewise.\n+\t* gcc.target/i386/interrupt-10.c: Likewise.\n+\t* gcc.target/i386/interrupt-11.c: Likewise.\n+\t* gcc.target/i386/interrupt-12.c: Likewise.\n+\t* gcc.target/i386/interrupt-13.c: Likewise.\n+\t* gcc.target/i386/interrupt-14.c: Likewise.\n+\t* gcc.target/i386/interrupt-15.c: Likewise.\n+\t* gcc.target/i386/interrupt-16.c: Likewise.\n+\t* gcc.target/i386/interrupt-17.c: Likewise.\n+\t* gcc.target/i386/interrupt-18.c: Likewise.\n+\t* gcc.target/i386/interrupt-19.c: Likewise.\n+\t* gcc.target/i386/interrupt-20.c: Likewise.\n+\t* gcc.target/i386/interrupt-21.c: Likewise.\n+\t* gcc.target/i386/interrupt-22.c: Likewise.\n+\t* gcc.target/i386/interrupt-23.c: Likewise.\n+\t* gcc.target/i386/interrupt-24.c: Likewise.\n+\t* gcc.target/i386/interrupt-25.c: Likewise.\n+\t* gcc.target/i386/interrupt-26.c: Likewise.\n+\t* gcc.target/i386/interrupt-27.c: Likewise.\n+\t* gcc.target/i386/interrupt-28.c: Likewise.\n+\t* gcc.target/i386/interrupt-387-err-1.c: Likewise.\n+\t* gcc.target/i386/interrupt-387-err-2.c: Likewise.\n+\t* gcc.target/i386/interrupt-bnd-err-1.c: Likewise.\n+\t* gcc.target/i386/interrupt-bnd-err-2.c: Likewise.\n+\t* gcc.target/i386/interrupt-iamcu.c: Likewise.\n+\t* gcc.target/i386/interrupt-mmx-err-1.c: Likewise.\n+\t* gcc.target/i386/interrupt-mmx-err-2.c: Likewise.\n+\t* gcc.target/i386/interrupt-redzone-1.c: Likewise.\n+\t* gcc.target/i386/interrupt-redzone-2.c: Likewise.\n+\t* gcc.target/i386/interrupt-sibcall-1.c: Likewise.\n+\t* gcc.target/i386/interrupt-sibcall-2.c: Likewise.\n+\t* gcc.target/i386/interrupt-switch-abi.c: Likewise.\n+\n 2016-06-03  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR tree-optimization/52171"}, {"sha": "c3ea645e92cd72a528f84b903bb93357d17217da", "filename": "gcc/testsuite/gcc.dg/guality/pr68037-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-g -mgeneral-regs-only\" } */\n+\n+extern void exit (int);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+#define ERROR\t\t0x12345670\n+#define IP\t\t0x12345671\n+#define CS\t\t0x12345672\n+#define FLAGS\t\t0x12345673\n+#define SP\t\t0x12345674\n+#define SS\t\t0x12345675\n+\n+#define STRING(x)\tXSTRING(x)\n+#define XSTRING(x)\t#x\n+\n+struct interrupt_frame\n+{\n+  uword_t ip;\n+  uword_t cs;\n+  uword_t flags;\n+  uword_t sp;\n+  uword_t ss;\n+};\n+\n+__attribute__((interrupt, used))\n+void\n+fn (struct interrupt_frame *frame, uword_t error)\n+{\n+  if (ERROR != error)\t\t/* BREAK */\n+    __builtin_abort ();\n+  if (IP != frame->ip)\n+    __builtin_abort ();\n+  if (CS != frame->cs)\n+    __builtin_abort ();\n+  if (FLAGS != frame->flags)\n+    __builtin_abort ();\n+  if (SP != frame->sp)\n+    __builtin_abort ();\n+  if (SS != frame->ss)\n+    __builtin_abort ();\n+\n+  exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  asm (\"push\t$\" STRING (SS) \";\t\t\\\n+\tpush\t$\" STRING (SP) \";\t\t\\\n+\tpush\t$\" STRING (FLAGS) \";\t\t\\\n+\tpush\t$\" STRING (CS) \";\t\t\\\n+\tpush\t$\" STRING (IP) \";\t\t\\\n+\tpush\t$\" STRING (ERROR) \";\t\t\\\n+\tjmp\tfn\");\n+  return 0;\n+}\n+\n+/* { dg-final { gdb-test 31 \"error\" \"0x12345670\" } } */\n+/* { dg-final { gdb-test 31 \"frame->ip\" \"0x12345671\" } } */\n+/* { dg-final { gdb-test 31 \"frame->cs\" \"0x12345672\" } } */\n+/* { dg-final { gdb-test 31 \"frame->flags\" \"0x12345673\" } } */\n+/* { dg-final { gdb-test 31 \"frame->sp\" \"0x12345674\" } } */\n+/* { dg-final { gdb-test 31 \"frame->ss\" \"0x12345675\" } } */"}, {"sha": "6f7e920d1067ab70fc74ddede2375f1d28f65f7f", "filename": "gcc/testsuite/gcc.dg/guality/pr68037-2.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-g -mgeneral-regs-only\" } */\n+\n+extern void exit (int);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+#define IP\t\t0x12345671\n+#define CS\t\t0x12345672\n+#define FLAGS\t\t0x12345673\n+#define SP\t\t0x12345674\n+#define SS\t\t0x12345675\n+\n+#define STRING(x)\tXSTRING(x)\n+#define XSTRING(x)\t#x\n+\n+struct interrupt_frame\n+{\n+  uword_t ip;\n+  uword_t cs;\n+  uword_t flags;\n+  uword_t sp;\n+  uword_t ss;\n+};\n+\n+__attribute__((interrupt, used))\n+void\n+fn (struct interrupt_frame *frame)\n+{\n+  if (IP != frame->ip)\t\t/* BREAK */\n+    __builtin_abort ();\n+  if (CS != frame->cs)\n+    __builtin_abort ();\n+  if (FLAGS != frame->flags)\n+    __builtin_abort ();\n+  if (SP != frame->sp)\n+    __builtin_abort ();\n+  if (SS != frame->ss)\n+    __builtin_abort ();\n+\n+  exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  asm (\"push\t$\" STRING (SS) \";\t\t\\\n+\tpush\t$\" STRING (SP) \";\t\t\\\n+\tpush\t$\" STRING (FLAGS) \";\t\t\\\n+\tpush\t$\" STRING (CS) \";\t\t\\\n+\tpush\t$\" STRING (IP) \";\t\t\\\n+\tjmp\tfn\");\n+  return 0;\n+}\n+\n+/* { dg-final { gdb-test 30 \"frame->ip\" \"0x12345671\" } } */\n+/* { dg-final { gdb-test 30 \"frame->cs\" \"0x12345672\" } } */\n+/* { dg-final { gdb-test 30 \"frame->flags\" \"0x12345673\" } } */\n+/* { dg-final { gdb-test 30 \"frame->sp\" \"0x12345674\" } } */\n+/* { dg-final { gdb-test 30 \"frame->ss\" \"0x12345675\" } } */"}, {"sha": "504a931eb33942cc0e9aa140b98b629f85655ea8", "filename": "gcc/testsuite/gcc.dg/guality/pr68037-3.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68037-3.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-g -mgeneral-regs-only\" } */\n+\n+#include <stddef.h>\n+\n+extern void exit (int);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+typedef int aligned __attribute__((aligned(64)));\n+\n+#define IP\t\t0x12345671\n+#define CS\t\t0x12345672\n+#define FLAGS\t\t0x12345673\n+#define SP\t\t0x12345674\n+#define SS\t\t0x12345675\n+\n+#define STRING(x)\tXSTRING(x)\n+#define XSTRING(x)\t#x\n+\n+struct interrupt_frame\n+{\n+  uword_t ip;\n+  uword_t cs;\n+  uword_t flags;\n+  uword_t sp;\n+  uword_t ss;\n+};\n+\n+int\n+check_int (int *i, int align)\n+{\n+  *i = 20;\n+  if ((((ptrdiff_t) i) & (align - 1)) != 0)\n+    __builtin_abort ();\n+  return *i;\n+}\n+\n+__attribute__((interrupt, used))\n+void\n+fn (struct interrupt_frame *frame)\n+{\n+  aligned i;\n+  if (check_int (&i, __alignof__(i)) != i)\n+    __builtin_abort ();\n+\n+  if (IP != frame->ip)\t\t/* BREAK */\n+    __builtin_abort ();\n+  if (CS != frame->cs)\n+    __builtin_abort ();\n+  if (FLAGS != frame->flags)\n+    __builtin_abort ();\n+  if (SP != frame->sp)\n+    __builtin_abort ();\n+  if (SS != frame->ss)\n+    __builtin_abort ();\n+\n+  exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  asm (\"push\t$\" STRING (SS) \";\t\t\\\n+\tpush\t$\" STRING (SP) \";\t\t\\\n+\tpush\t$\" STRING (FLAGS) \";\t\t\\\n+\tpush\t$\" STRING (CS) \";\t\t\\\n+\tpush\t$\" STRING (IP) \";\t\t\\\n+\tjmp\tfn\");\n+  return 0;\n+}\n+\n+/* { dg-final { gdb-test 46 \"frame->ip\" \"0x12345671\" } } */\n+/* { dg-final { gdb-test 46 \"frame->cs\" \"0x12345672\" } } */\n+/* { dg-final { gdb-test 46 \"frame->flags\" \"0x12345673\" } } */\n+/* { dg-final { gdb-test 46 \"frame->sp\" \"0x12345674\" } } */\n+/* { dg-final { gdb-test 46 \"frame->ss\" \"0x12345675\" } } */"}, {"sha": "15fe08c156fd1f0c1437c1e9aa7c1309015ce869", "filename": "gcc/testsuite/gcc.dg/torture/pr68037-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-mgeneral-regs-only\" } */\n+\n+extern void exit (int);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+#define ERROR\t\t0x12345670\n+#define IP\t\t0x12345671\n+#define CS\t\t0x12345672\n+#define FLAGS\t\t0x12345673\n+#define SP\t\t0x12345674\n+#define SS\t\t0x12345675\n+\n+#define STRING(x)\tXSTRING(x)\n+#define XSTRING(x)\t#x\n+\n+struct interrupt_frame\n+{\n+  uword_t ip;\n+  uword_t cs;\n+  uword_t flags;\n+  uword_t sp;\n+  uword_t ss;\n+};\n+\n+__attribute__((interrupt, used))\n+void\n+fn (struct interrupt_frame *frame, uword_t error)\n+{\n+  if (ERROR != error)\n+    __builtin_abort ();\n+  if (IP != frame->ip)\n+    __builtin_abort ();\n+  if (CS != frame->cs)\n+    __builtin_abort ();\n+  if (FLAGS != frame->flags)\n+    __builtin_abort ();\n+  if (SP != frame->sp)\n+    __builtin_abort ();\n+  if (SS != frame->ss)\n+    __builtin_abort ();\n+\n+  exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  asm (\"push\t$\" STRING (SS) \";\t\t\\\n+\tpush\t$\" STRING (SP) \";\t\t\\\n+\tpush\t$\" STRING (FLAGS) \";\t\t\\\n+\tpush\t$\" STRING (CS) \";\t\t\\\n+\tpush\t$\" STRING (IP) \";\t\t\\\n+\tpush\t$\" STRING (ERROR) \";\t\t\\\n+\tjmp\tfn\");\n+  return 0;\n+}"}, {"sha": "00ba7d45464837058737e08f4bbfe5f976b8a8da", "filename": "gcc/testsuite/gcc.dg/torture/pr68037-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-mgeneral-regs-only\" } */\n+\n+extern void exit (int);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+#define IP\t\t0x12345671\n+#define CS\t\t0x12345672\n+#define FLAGS\t\t0x12345673\n+#define SP\t\t0x12345674\n+#define SS\t\t0x12345675\n+\n+#define STRING(x)\tXSTRING(x)\n+#define XSTRING(x)\t#x\n+\n+struct interrupt_frame\n+{\n+  uword_t ip;\n+  uword_t cs;\n+  uword_t flags;\n+  uword_t sp;\n+  uword_t ss;\n+};\n+\n+__attribute__((interrupt, used))\n+void\n+fn (struct interrupt_frame *frame)\n+{\n+  if (IP != frame->ip)\n+    __builtin_abort ();\n+  if (CS != frame->cs)\n+    __builtin_abort ();\n+  if (FLAGS != frame->flags)\n+    __builtin_abort ();\n+  if (SP != frame->sp)\n+    __builtin_abort ();\n+  if (SS != frame->ss)\n+    __builtin_abort ();\n+\n+  exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  asm (\"push\t$\" STRING (SS) \";\t\t\\\n+\tpush\t$\" STRING (SP) \";\t\t\\\n+\tpush\t$\" STRING (FLAGS) \";\t\t\\\n+\tpush\t$\" STRING (CS) \";\t\t\\\n+\tpush\t$\" STRING (IP) \";\t\t\\\n+\tjmp\tfn\");\n+  return 0;\n+}"}, {"sha": "abf8adbc73435d3058c2c9516d34573ff1919b4c", "filename": "gcc/testsuite/gcc.dg/torture/pr68037-3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68037-3.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-mgeneral-regs-only\" } */\n+\n+#include <stddef.h>\n+\n+extern void exit (int);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+typedef int aligned __attribute__((aligned(64)));\n+\n+#define IP\t\t0x12345671\n+#define CS\t\t0x12345672\n+#define FLAGS\t\t0x12345673\n+#define SP\t\t0x12345674\n+#define SS\t\t0x12345675\n+\n+#define STRING(x)\tXSTRING(x)\n+#define XSTRING(x)\t#x\n+\n+struct interrupt_frame\n+{\n+  uword_t ip;\n+  uword_t cs;\n+  uword_t flags;\n+  uword_t sp;\n+  uword_t ss;\n+};\n+\n+int\n+check_int (int *i, int align)\n+{\n+  *i = 20;\n+  if ((((ptrdiff_t) i) & (align - 1)) != 0)\n+    __builtin_abort ();\n+  return *i;\n+}\n+\n+__attribute__((interrupt, used))\n+void\n+fn (struct interrupt_frame *frame)\n+{\n+  aligned i;\n+  if (check_int (&i, __alignof__(i)) != i)\n+    __builtin_abort ();\n+\n+  if (IP != frame->ip)\n+    __builtin_abort ();\n+  if (CS != frame->cs)\n+    __builtin_abort ();\n+  if (FLAGS != frame->flags)\n+    __builtin_abort ();\n+  if (SP != frame->sp)\n+    __builtin_abort ();\n+  if (SS != frame->ss)\n+    __builtin_abort ();\n+\n+  exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  asm (\"push\t$\" STRING (SS) \";\t\t\\\n+\tpush\t$\" STRING (SP) \";\t\t\\\n+\tpush\t$\" STRING (FLAGS) \";\t\t\\\n+\tpush\t$\" STRING (CS) \";\t\t\\\n+\tpush\t$\" STRING (IP) \";\t\t\\\n+\tjmp\tfn\");\n+  return 0;\n+}"}, {"sha": "b343844185fc6cba63cfa01b665c9538a69b371e", "filename": "gcc/testsuite/gcc.dg/torture/pr68661-1a.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68661-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68661-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68661-1a.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-mgeneral-regs-only\" } */\n+/* { dg-additional-sources pr68661-1b.c } */\n+\n+extern void bar0 (int, int, int, int, int, int, int, int, int)\n+   __attribute__ ((no_caller_saved_registers));\n+\n+void\n+foo (void)\n+{\n+  bar0 (0, 1, 2, 3, 4, 5, 6, 7, 8);\n+}\n+\n+void\n+bad (void)\n+{\n+  __builtin_abort ();\n+}"}, {"sha": "863c16a73653b437b9341e7947609e0c4b6561e6", "filename": "gcc/testsuite/gcc.dg/torture/pr68661-1b.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68661-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68661-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68661-1b.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-mgeneral-regs-only\" } */\n+\n+extern void foo (void);\n+extern void bad (void);\n+\n+void\n+__attribute__ ((no_caller_saved_registers))\n+bar0 (int i0, int i1, int i2, int i3, int i4, int i5, int i6,\n+      int i7, int i8)\n+{\n+  if (i0 != 0)\n+     bad ();\n+\n+  if (i1 != 1)\n+     bad ();\n+\n+  if (i2 != 2)\n+     bad ();\n+\n+  if (i3 != 3)\n+     bad ();\n+\n+  if (i4 != 4)\n+     bad ();\n+\n+  if (i5 != 5)\n+     bad ();\n+\n+  if (i6 != 6)\n+     bad ();\n+\n+  if (i7 != 7)\n+     bad ();\n+\n+  if (i8 != 8)\n+     bad ();\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  return 0;\n+}"}, {"sha": "3dfe3d8996d7135a71a7bf3cb3f108efc26c5f1b", "filename": "gcc/testsuite/gcc.target/i386/interrupt-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-push-args -maccumulate-outgoing-args\" } */\n+\n+extern void foo (void *) __attribute__ ((interrupt));\n+extern int bar (int);\n+\n+void foo (void *frame)\n+{\n+  int a,b,c,d,e,f,i;\n+  a = bar (5);\n+  b = bar (a);\n+  c = bar (b);\n+  d = bar (c);\n+  e = bar (d);\n+  f = bar (e);\n+  for (i = 1; i < 10; i++)\n+  {\n+    a += bar (a + i) + bar (b + i) +\n+\t bar (c + i) + bar (d + i) +\n+\t bar (e + i) + bar (f + i);\n+  }\n+}\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)bx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)si\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%edi\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r12\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r13\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r14\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r15\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)bx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)si\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%edi\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r12\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r13\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r14\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r15\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "a88e948ec4ca7fae3c7a350a4b597c184c940201", "filename": "gcc/testsuite/gcc.target/i386/interrupt-10.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-10.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld\" } */\n+\n+extern int check_int (int *i, void *, int align);\n+typedef int aligned __attribute__((aligned(64)));\n+\n+__attribute__((interrupt))\n+void\n+foo (void *frame)\n+{\n+  aligned j;\n+  if (check_int (frame, &j, __alignof__(j)))\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"and\\[lq\\]?\\[^\\\\n\\]*-64,\\[^\\\\n\\]*sp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "ded589e0cd0d7d99a71487ea20feba7da68f7a22", "filename": "gcc/testsuite/gcc.target/i386/interrupt-11.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-11.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mno-sse4 -mno-popcnt -maccumulate-outgoing-args\" } */\n+\n+extern int i, cnt;\n+\n+void\n+ __attribute__ ((interrupt))\n+foo (void *frame)\n+{\n+  cnt = __builtin_popcount (i);\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t .\\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"kmov.\\[\\\\t \\]*%k\\[0-7\\]+,\\[\\\\t \\]*\\[\\\\-]?\\[0-9\\]*\\\\(%\\[re\\]?sp\\\\)\" } } */\n+/* { dg-final { scan-assembler-not \"kmov.\\[\\\\t \\]*\\[0-9\\]*\\\\(%\\[re\\]?sp\\\\),\\[\\\\t \\]*%k\\[0-7\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"pushq\\[\\\\t \\]*%rbx\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"pushq\\[\\\\t \\]*%r1\\[2-5\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"pushl\\[\\\\t \\]*%ebx\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"pushl\\[\\\\t \\]*%edi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"pushl\\[\\\\t \\]*%esi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rsi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rsi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "b04de5fa75d8cee10cdd2ed4385f6f8047cde46a", "filename": "gcc/testsuite/gcc.target/i386/interrupt-12.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-12.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mpush-args -maccumulate-outgoing-args\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+extern void bar (int) __attribute__ ((no_caller_saved_registers));\n+\n+void\n+ __attribute__ ((interrupt))\n+fn1 (void *frame, uword_t error)\n+{\n+  bar (error);\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t .\\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(b|c|d)x\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)si\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)l\\[\\\\t \\]*%edi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%rax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r\\[0-9\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:r|e)bp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"leave\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%eax\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"movl\\[\\\\t \\]*-4\\\\(%ebp\\\\),\\[\\\\t \\]*%eax\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"movq\\[\\\\t \\]*-8\\\\(%(?:r|e)bp\\\\),\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"addl\\[\\\\t \\]*\\\\\\$4,\\[\\\\t \\]*%esp\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"add(?:l|q)\\[\\\\t \\]*\\\\\\$8,\\[\\\\t \\]*%\\[re\\]?sp\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "018602fd0137be563fe034d2f9d68190a2f98628", "filename": "gcc/testsuite/gcc.target/i386/interrupt-13.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-13.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mno-push-args -maccumulate-outgoing-args\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+extern void bar (int) __attribute__ ((no_caller_saved_registers));\n+\n+void\n+ __attribute__ ((interrupt))\n+fn1 (void *frame, uword_t error)\n+{\n+  bar (error);\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t .\\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(b|c|d)x\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)si\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)l\\[\\\\t \\]*%edi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%rax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r\\[0-9\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:r|e)bp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"leave\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%eax\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"movl\\[\\\\t \\]*-4\\\\(%ebp\\\\),\\[\\\\t \\]*%eax\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"movq\\[\\\\t \\]*-8\\\\(%(?:r|e)bp\\\\),\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"addl\\[\\\\t \\]*\\\\\\$4,\\[\\\\t \\]*%esp\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"add(?:l|q)\\[\\\\t \\]*\\\\\\$8,\\[\\\\t \\]*%\\[re\\]?sp\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "6ed2cf2e42a80281445caaa4b561b7b4aa397b93", "filename": "gcc/testsuite/gcc.target/i386/interrupt-14.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-14.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mpush-args -mno-accumulate-outgoing-args\" } */\n+\n+extern void bar (int) __attribute__ ((no_caller_saved_registers));\n+\n+void\n+ __attribute__ ((interrupt))\n+fn1 (void *frame)\n+{\n+  bar (3);\n+}\n+\n+void\n+ __attribute__ ((interrupt))\n+fn2 (void *frame)\n+{\n+  bar (3);\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t .\\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(a|b|c|d)x\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)l\\[\\\\t \\]*%edi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)si\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r\\[8-9\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r1\\[0-5\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:r|e)bp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"leave\" 2 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"movq\\[\\\\t \\]*-8\\\\(%(?:r|e)bp\\\\),\\[\\\\t \\]*%rdi\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 2 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 2 } } */"}, {"sha": "9b53abee6522c8691066a29204a238c51c1fc217", "filename": "gcc/testsuite/gcc.target/i386/interrupt-15.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-15.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mpush-args -maccumulate-outgoing-args\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+extern void bar (int) __attribute__ ((no_caller_saved_registers));\n+\n+void\n+ __attribute__ ((interrupt))\n+fn1 (void *frame, uword_t error)\n+{\n+  bar (error);\n+}\n+\n+void\n+ __attribute__ ((interrupt))\n+fn2 (void *frame, uword_t error)\n+{\n+  bar (error);\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t .\\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(b|c|d)x\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)si\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)l\\[\\\\t \\]*%edi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%rax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r\\[0-9\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:r|e)bp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"leave\" 2 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%eax\" 2 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"movl\\[\\\\t \\]*-4\\\\(%ebp\\\\),\\[\\\\t \\]*%eax\" 2 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"movq\\[\\\\t \\]*-8\\\\(%(?:r|e)bp\\\\),\\[\\\\t \\]*%rdi\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"addl\\[\\\\t \\]*\\\\\\$4,\\[\\\\t \\]*%esp\" 2 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"add(?:l|q)\\[\\\\t \\]*\\\\\\$8,\\[\\\\t \\]*%\\[re\\]?sp\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 2 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 2 } } */"}, {"sha": "bc929c657a21f28f215288c08bc7129efbcd5659", "filename": "gcc/testsuite/gcc.target/i386/interrupt-16.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-16.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mno-push-args -maccumulate-outgoing-args\" } */\n+\n+extern int foo (int) __attribute__ ((no_caller_saved_registers));\n+extern int bar (int) __attribute__ ((no_caller_saved_registers));\n+\n+int\n+foo (int i)\n+{\n+  return bar (i);\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t \\]*%(x|y|z)mm\\[0-9\\]+,\\[\\\\t \\]-*\\[0-9\\]*\\\\(%\\[re\\]?bp\\\\)\" } } */\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t \\]*-\\[0-9\\]*\\\\(%\\[re\\]?bp\\\\),\\[\\\\t \\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(a|b|c|d)x\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)si\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)bp\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)l\\[\\\\t \\]*%edi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r\\[0-9\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */"}, {"sha": "5d5b59e2890972f37a25736ae59439b326aa7056", "filename": "gcc/testsuite/gcc.target/i386/interrupt-17.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-17.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O3 -mgeneral-regs-only -mno-cld -mno-iamcu -mno-push-args\" } */\n+\n+extern int foo (int) __attribute__ ((no_caller_saved_registers));\n+extern int bar (int) __attribute__ ((no_caller_saved_registers));\n+\n+int\n+foo (int i)\n+{\n+  return bar (i + 1);\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t \\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(a|b|c|d)x\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)si\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)bp\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)l\\[\\\\t \\]*%edi\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%rdx\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r\\[0-9\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"jmp\" } }*/"}, {"sha": "9f21a23b3377cb7862b4d8f2348af0721d7414cc", "filename": "gcc/testsuite/gcc.target/i386/interrupt-18.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-18.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -Wall -g\" } */\n+\n+void\n+__attribute__((interrupt))\n+fn (void *frame)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"add(l|q)\\[\\\\t \\]*\\\\$\\[0-9\\]*,\\[\\\\t \\]*%\\[re\\]?sp\" } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"\\tcld\" } } */"}, {"sha": "c3b2097fbcae92f385fc9a74aed2255c69583833", "filename": "gcc/testsuite/gcc.target/i386/interrupt-19.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-19.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu\" } */\n+\n+struct ret\n+{\n+  int i[8];\n+};\n+\n+extern struct ret bar (void);\n+\n+void\n+ __attribute__ ((interrupt))\n+fn (void *frame)\n+{\n+  bar ();\n+} /* { dg-message \"sorry, unimplemented: Dynamic Realign Argument Pointer\" } */"}, {"sha": "3899d529a5f4353784791e575c8029b541b4c279", "filename": "gcc/testsuite/gcc.target/i386/interrupt-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -Wall -g\" } */\n+\n+void\n+__attribute__((interrupt))\n+fn (void *frame)\n+{\n+}\n+\n+typedef void (*fn_t) (void *) __attribute__((interrupt));\n+\n+fn_t fns[] =\n+{\n+  fn,\n+};\n+\n+/* { dg-final { scan-assembler-not \"add(l|q)\\[\\\\t \\]*\\\\$\\[0-9\\]*,\\[\\\\t \\]*%\\[re\\]?sp\" } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"\\tcld\" } } */"}, {"sha": "0861ffe3185783bf546cce4a6fffc12897a89765", "filename": "gcc/testsuite/gcc.target/i386/interrupt-20.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-20.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2  -mgeneral-regs-only -mno-cld -miamcu -maccumulate-outgoing-args\" } */\n+\n+struct interrupt_frame;\n+\n+void (*callback[1])(unsigned int id, unsigned int len);\n+unsigned int remaining;\n+\n+void\n+handler(int uart)\n+{\n+  while (1) {\n+    if (remaining) {\n+      callback[uart](0, 0);\n+      break;\n+    }\n+  }\n+}\n+\n+int uart;\n+\n+void\n+__attribute__((interrupt))\n+my_isr(struct interrupt_frame *frame)\n+{\n+  handler(uart);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "5bb397ea414e7a3b3d62d024f8a705578a5a7237", "filename": "gcc/testsuite/gcc.target/i386/interrupt-21.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-21.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -miamcu -maccumulate-outgoing-args\" } */\n+\n+struct interrupt_frame;\n+\n+void (*callback[1])(unsigned int id, unsigned int len);\n+unsigned int remaining;\n+\n+void\n+__attribute__((no_caller_saved_registers))\n+handler(int uart)\n+{\n+  while (1) {\n+    if (remaining) {\n+      callback[uart](0, 0);\n+      break;\n+    }\n+  }\n+}\n+\n+int uart;\n+\n+void\n+__attribute__((interrupt))\n+my_isr(struct interrupt_frame *frame)\n+{\n+  handler(uart);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "a51ba635414ca85ea258a24f9885373a9a190914", "filename": "gcc/testsuite/gcc.target/i386/interrupt-22.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-22.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -miamcu -maccumulate-outgoing-args\" } */\n+\n+struct interrupt_frame;\n+\n+void (*callback) (unsigned int id, unsigned int len)\n+  __attribute__((no_caller_saved_registers));\n+unsigned int remaining;\n+\n+void\n+__attribute__((no_caller_saved_registers))\n+handler(void)\n+{\n+  while (1) {\n+    if (remaining) {\n+      callback(0, 0);\n+      break;\n+    }\n+  }\n+}\n+\n+void\n+__attribute__((interrupt))\n+my_isr(struct interrupt_frame *frame)\n+{\n+  handler();\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "95c211a54d580806450820a52ece5af8d76d986f", "filename": "gcc/testsuite/gcc.target/i386/interrupt-23.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-23.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -miamcu -maccumulate-outgoing-args\" } */\n+\n+struct interrupt_frame;\n+\n+extern void callback0 (unsigned int id, unsigned int len)\n+  __attribute__((no_caller_saved_registers));\n+extern void callback1 (unsigned int id, unsigned int len)\n+  __attribute__((no_caller_saved_registers));\n+extern void callback2 (unsigned int id, unsigned int len)\n+  __attribute__((no_caller_saved_registers));\n+\n+typedef void (*callback_t) (unsigned int id, unsigned int len)\n+  __attribute__((no_caller_saved_registers));\n+\n+callback_t callback[] =\n+{\n+  callback0,\n+  callback1,\n+  callback2,\n+};\n+\n+unsigned int remaining;\n+\n+void\n+__attribute__((no_caller_saved_registers))\n+handler(int uart)\n+{\n+  while (1) {\n+    if (remaining) {\n+      callback[uart](0, 0);\n+      break;\n+    }\n+  }\n+}\n+\n+int uart;\n+\n+void\n+__attribute__((interrupt))\n+my_isr(struct interrupt_frame *frame)\n+{\n+  handler(uart);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "0b95660128e663542f808d41c93759aebff94198", "filename": "gcc/testsuite/gcc.target/i386/interrupt-24.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-24.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mno-push-args\" } */\n+\n+extern void bar (void) __attribute__ ((noreturn));\n+\n+void\n+__attribute__ ((no_caller_saved_registers))\n+foo (int i0, int i1, int i2, int i3, int i4, int i5, int i6,\n+     int i7, int i8)\n+{\n+  if (i7)\n+    bar ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t \\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(a|b|c|d)x\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)(d|s)i\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)(l|q)\\[\\\\t \\]*%(r|e)bp\" } } */\n+/* { dg-final { scan-assembler-not \"(push|pop)q\\[\\\\t \\]*%r\\[0-9\\]+\" { target { ! ia32 } } } } */"}, {"sha": "9c25fed36e0ae600769b45cc123592431cec9ab4", "filename": "gcc/testsuite/gcc.target/i386/interrupt-25.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-25.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-push-args -maccumulate-outgoing-args\" } */\n+\n+extern int bar (int);\n+\n+__attribute__((no_caller_saved_registers))\n+void\n+foo (void)\n+{\n+  int a,b,c,d,e,f,i;\n+  a = bar (5);\n+  b = bar (a);\n+  c = bar (b);\n+  d = bar (c);\n+  e = bar (d);\n+  f = bar (e);\n+  for (i = 1; i < 10; i++)\n+  {\n+    a += bar (a + i) + bar (b + i) +\n+\t bar (c + i) + bar (d + i) +\n+\t bar (e + i) + bar (f + i);\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)bx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)si\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%edi\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r12\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r13\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r14\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r15\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)bx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)si\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%edi\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r12\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r13\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r14\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r15\" 1 { target { ! ia32 } } } } */"}, {"sha": "10cc3e1b16da565d8978cc1b385f986ff52d8722", "filename": "gcc/testsuite/gcc.target/i386/interrupt-26.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-26.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -mgeneral-regs-only -mno-cld\" } */\n+\n+\n+extern void *a;\n+extern int b;\n+\n+__attribute__ ((interrupt))\n+void\n+foo (void *frame)\n+{\n+  __builtin_memset (a, b, 40);\n+}\n+\n+/* { dg-final { scan-assembler \"stosb\" } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "4e1643abc76dd54a08d7d9c709a8ad44495a344d", "filename": "gcc/testsuite/gcc.target/i386/interrupt-27.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-27.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mcld\" } */\n+\n+extern void bar (void);\n+\n+void\n+__attribute__ ((interrupt))\n+foo (void *frame)\n+{\n+  bar ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"\\tcld\" } } */"}, {"sha": "8690535cdc973849a8b7cf737e86e0515eeffb4c", "filename": "gcc/testsuite/gcc.target/i386/interrupt-28.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-28.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mcld\" } */\n+\n+__attribute__ ((interrupt))\n+void\n+foo (void *frame)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"\\tcld\" } } */"}, {"sha": "ec7dc71cfbc5ffc9f41c73f9639776d3f0776897", "filename": "gcc/testsuite/gcc.target/i386/interrupt-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-3.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -g\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+void\n+__attribute__((interrupt))\n+fn (void* frame, uword_t error)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-times \"add(?:l|q)\\[\\\\t \\]*\\\\\\$8,\\[\\\\t \\]*%\\[re\\]?sp\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"addl\\[\\\\t \\]*\\\\\\$4,\\[\\\\t \\]*%esp\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"\\tcld\" } } */"}, {"sha": "3fbdc881dda5bbd71d536de953c8a7b484ef8869", "filename": "gcc/testsuite/gcc.target/i386/interrupt-387-err-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-387-err-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-387-err-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-387-err-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -m80387\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+void\n+__attribute__((interrupt))\n+fn1 (void *frame, uword_t error)\n+{ /* { dg-message \"80387 instructions aren't allowed in exception service routine\" } */\n+}\n+\n+void\n+__attribute__((interrupt))\n+fn2 (void *frame)\n+{ /* { dg-message \"80387 instructions aren't allowed in interrupt service routine\" } */\n+}"}, {"sha": "3203d644419e16fa8205f23d857968548fa1a202", "filename": "gcc/testsuite/gcc.target/i386/interrupt-387-err-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-387-err-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-387-err-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-387-err-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -m80387 -mlong-double-80 -mno-iamcu\" } */\n+\n+void\n+__attribute__((no_caller_saved_registers))\n+fn1 (void)\n+{ /* { dg-message \"80387 instructions aren't allowed in function with no_caller_saved_registers attribute\" } */\n+}"}, {"sha": "0cb8d3cbda6f257a59c415b1d34da2d4a3224820", "filename": "gcc/testsuite/gcc.target/i386/interrupt-4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-4.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O -mgeneral-regs-only -mno-cld -g\" } */\n+\n+#include <stdint.h>\n+\n+extern void link_error (void);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+struct interrupt_frame\n+{\n+  uword_t ip;\n+  uword_t cs;\n+  uword_t flags;\n+  uword_t sp;\n+  uword_t ss;\n+};\n+\n+__attribute__ ((used, interrupt))\n+void\n+foo (struct interrupt_frame *frame)\n+{\n+  void *ra = __builtin_return_address (0);\n+  if ((uintptr_t) ra != (uintptr_t) frame->ip)\n+    link_error ();\n+}\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"}, {"sha": "803c06362999c9f801bcb82dc34d7d7f3be12016", "filename": "gcc/testsuite/gcc.target/i386/interrupt-5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-5.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O -mgeneral-regs-only -mno-cld -g\" } */\n+\n+#include <stdint.h>\n+\n+extern void link_error (void);\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+__attribute__ ((used, interrupt))\n+void\n+foo (void *frame, uword_t error)\n+{\n+  void *ra = __builtin_return_address (0);\n+  if ((uintptr_t) ra != (uintptr_t) error)\n+    link_error ();\n+}\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"}, {"sha": "2a0266ad576471a3db59cea069b1566183b5d7fe", "filename": "gcc/testsuite/gcc.target/i386/interrupt-6.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-6.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+extern int error;\n+\n+__attribute__((interrupt))\n+void\n+fn1 (void *p, short error_code)\n+{ /* { dg-error \"interrupt service routine should have unsigned \\(long long |long |\\)int as the second argument\" } */\n+}\n+\n+__attribute__((interrupt))\n+void\n+fn2 (void)\n+{ /* { dg-error \"interrupt service routine can only have a pointer argument and an optional integer argument\" } */\n+}\n+\n+__attribute__((interrupt))\n+void\n+fn3 (uword_t error_code)\n+{ /* { dg-error \"interrupt service routine should have a pointer as the first argument\" } */\n+  error = error_code;\n+}\n+\n+__attribute__((interrupt))\n+void\n+fn4 (uword_t error_code, void *frame)\n+{ /* { dg-error \"interrupt service routine should have .* the .* argument\" } */\n+  error = error_code;\n+}\n+\n+extern int fn5 (void *) __attribute__ ((interrupt)); /* { dg-error \"interrupt service routine can't have non-void return value\" } */\n+\n+int\n+fn5 (void *frame)\n+{\n+  return 0;\n+}"}, {"sha": "506f61afa853c6a2c527d27c3163f8626fcad3d7", "filename": "gcc/testsuite/gcc.target/i386/interrupt-7.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-7.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld\" } */\n+\n+extern int error;\n+\n+extern void fn (void *) __attribute__((interrupt));\n+\n+void\n+foo (void)\n+{\n+  fn (&error); /* { dg-error \"interrupt service routine can't be called directly\" } */\n+}"}, {"sha": "34536d135eeebf282051f40d1002f1b8439a37f0", "filename": "gcc/testsuite/gcc.target/i386/interrupt-8.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-8.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -maccumulate-outgoing-args\" } */\n+\n+extern void bar (void);\n+\n+void\n+ __attribute__ ((interrupt))\n+foo (void *frame)\n+{\n+  bar ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"movups\\[\\\\t .\\]*%(x|y|z)mm\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"kmov.\\[\\\\t \\]*%k\\[0-7\\]+,\\[\\\\t \\]*\\[\\\\-]?\\[0-9\\]*\\\\(%\\[re\\]?sp\\\\)\" } } */\n+/* { dg-final { scan-assembler-not \"kmov.\\[\\\\t \\]*\\[0-9\\]*\\\\(%\\[re\\]?sp\\\\),\\[\\\\t \\]*%k\\[0-7\\]+\" } } */\n+/* { dg-final { scan-assembler-not \"pushq\\[\\\\t \\]*%rbx\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"pushq\\[\\\\t \\]*%r1\\[2-5\\]+\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"pushl\\[\\\\t \\]*%ebx\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"pushl\\[\\\\t \\]*%e(s|d)i\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"push(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%rsi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pushq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)ax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)cx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop(?:l|q)\\[\\\\t \\]*%(?:e|r)dx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rdi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%rsi\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r8\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r9\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r10\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"popq\\[\\\\t \\]*%r11\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "490fb9c423bc91349511e38078e196e55318098c", "filename": "gcc/testsuite/gcc.target/i386/interrupt-9.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-9.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld\" } */\n+\n+extern int check_int (int *i, void *, int align);\n+typedef int aligned __attribute__((aligned(64)));\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+__attribute__((interrupt))\n+void\n+foo (void *frame, uword_t error_code)\n+{\n+  aligned j;\n+  if (check_int (frame, &j, __alignof__(j)))\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"and\\[lq\\]?\\[^\\\\n\\]*-64,\\[^\\\\n\\]*sp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"add(?:l|q)\\[\\\\t \\]*\\\\\\$8,\\[\\\\t \\]*%\\[re\\]?sp\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"addl\\[\\\\t \\]*\\\\\\$4,\\[\\\\t \\]*%esp\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "e07688e7ee20ca12e6bd0c152422465fee495520", "filename": "gcc/testsuite/gcc.target/i386/interrupt-bnd-err-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-bnd-err-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-bnd-err-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-bnd-err-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { ! x32 } } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mmpx\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+void\n+__attribute__((interrupt))\n+fn1 (void *frame)\n+{ /* { dg-message \"MPX instructions aren't allowed in interrupt service routine\" } */\n+}\n+\n+void\n+__attribute__((interrupt))\n+fn2 (void *frame, uword_t error)\n+{ /* { dg-message \"MPX instructions aren't allowed in exception service routine\" } */\n+}"}, {"sha": "641ca637f8c82fd5f0dc0a71f9f44e9b054710df", "filename": "gcc/testsuite/gcc.target/i386/interrupt-bnd-err-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-bnd-err-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-bnd-err-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-bnd-err-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile { target { ! x32 } } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mno-iamcu -mmpx\" } */\n+\n+void\n+__attribute__((no_caller_saved_registers))\n+fn (void *frame)\n+{ /* { dg-message \"MPX instructions aren't allowed in function with no_caller_saved_registers attribute\" } */\n+}"}, {"sha": "c2256ef1192cedf0193f61901e5773e0730e8990", "filename": "gcc/testsuite/gcc.target/i386/interrupt-iamcu.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-iamcu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-iamcu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-iamcu.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -miamcu -maccumulate-outgoing-args\" } */\n+\n+extern void foo (void *) __attribute__ ((interrupt));\n+extern int bar (int);\n+\n+void foo (void *frame)\n+{\n+  int a,b,c,d,e,f,i;\n+  a = bar (5);\n+  b = bar (a);\n+  c = bar (b);\n+  d = bar (c);\n+  e = bar (d);\n+  f = bar (e);\n+  for (i = 1; i < 10; i++)\n+    a += bar (a + i) + bar (b + i) +\n+\t bar (c + i) + bar (d + i) +\n+\t bar (e + i) + bar (f+i);\n+}\n+\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%eax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%ebx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%ecx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%edx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%edi\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%esi\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pushl\\[\\\\t \\]*%ebp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%eax\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%ecx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%edx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%edi\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%esi\" 1 } } */\n+/* { dg-final { scan-assembler-times \"popl\\[\\\\t \\]*%ebp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "cd1367b54a4127ccac0849970fa8daa9fb30546d", "filename": "gcc/testsuite/gcc.target/i386/interrupt-mmx-err-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-mmx-err-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-mmx-err-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-mmx-err-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mmmx -mno-cld -mno-iamcu\" } */\n+\n+typedef unsigned int uword_t __attribute__ ((mode (__word__)));\n+\n+void\n+__attribute__((interrupt))\n+fn1 (void *frame)\n+{ /* { dg-message \"MMX/3Dnow instructions aren't allowed in interrupt service routine\" } */\n+}\n+\n+void\n+__attribute__((interrupt))\n+fn2 (void *frame, uword_t error)\n+{ /* { dg-message \"MMX/3Dnow instructions aren't allowed in exception service routine\" } */\n+}"}, {"sha": "3e9f70c389ed94cf043337bad83a277751c8297a", "filename": "gcc/testsuite/gcc.target/i386/interrupt-mmx-err-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-mmx-err-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-mmx-err-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-mmx-err-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mmmx -mno-cld -mno-iamcu\" } */\n+\n+void\n+__attribute__((no_caller_saved_registers))\n+fn1 (void)\n+{ /* { dg-message \"MMX/3Dnow instructions aren't allowed in function with no_caller_saved_registers attribute\" } */\n+}"}, {"sha": "10098848c506007c5ff3dcafd41df44233ddcdc5", "filename": "gcc/testsuite/gcc.target/i386/interrupt-redzone-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-redzone-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-redzone-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-redzone-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mred-zone\" } */\n+\n+void\n+__attribute__((interrupt))\n+fn (void *frame)\n+{\n+  /* No need to adjust stack if less than 128 bytes are used on stack\n+     with a 128-byte red zone.  */\n+  long long int i0;\n+  long long int i1;\n+  long long int i2;\n+  long long int i3;\n+  long long int i4;\n+  long long int i5;\n+  long long int i6;\n+  long long int i7;\n+  long long int i8;\n+  long long int i9;\n+  long long int i10;\n+  long long int i11;\n+  long long int i12;\n+  long long int i13;\n+  asm (\"# %0, %1, %2, %3, %4, %5, %6, %7\"\n+       : \"=m\" (i0), \"=m\" (i1), \"=m\" (i2), \"=m\" (i3),\n+         \"=m\" (i4), \"=m\" (i5), \"=m\" (i6), \"=m\" (i7),\n+         \"=m\" (i8), \"=m\" (i9), \"=m\" (i10), \"=m\" (i11),\n+\t \"=m\" (i12), \"=m\" (i13));\n+}\n+\n+/* { dg-final { scan-assembler-not \"(sub|add)(l|q)\\[\\\\t \\]*\\\\$\\[0-9\\]*,\\[\\\\t \\]*%\\[re\\]?sp\" } } */\n+/* { dg-final { scan-assembler-not \"\\tcld\" } } */"}, {"sha": "a3fa776e2db36b5915ffec5cadcea4bb6cd612d7", "filename": "gcc/testsuite/gcc.target/i386/interrupt-redzone-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-redzone-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-redzone-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-redzone-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld -mred-zone\" } */\n+\n+void\n+__attribute__((interrupt))\n+fn (void *frame)\n+{\n+  /* Need to adjust stack if more than 128 bytes are used on stack\n+     with a 128-byte red zone.  */\n+  long long int i0;\n+  long long int i1;\n+  long long int i2;\n+  long long int i3;\n+  long long int i4;\n+  long long int i5;\n+  long long int i6;\n+  long long int i7;\n+  long long int i8;\n+  long long int i9;\n+  long long int i10;\n+  long long int i11;\n+  long long int i12;\n+  long long int i13;\n+  char c;\n+  asm (\"# %0, %1, %2, %3, %4, %5, %6, %7\"\n+       : \"=m\" (i0), \"=m\" (i1), \"=m\" (i2), \"=m\" (i3),\n+         \"=m\" (i4), \"=m\" (i5), \"=m\" (i6), \"=m\" (i7),\n+         \"=m\" (i8), \"=m\" (i9), \"=m\" (i10), \"=m\" (i11),\n+\t \"=m\" (i12), \"=m\" (i13), \"=m\" (c));\n+}\n+\n+/* { dg-final { scan-assembler-times \"(?:sub|add)(?:l|q)\\[\\\\t \\]*\\\\\\$\\[0-9\\]*,\\[\\\\t \\]*%\\[re\\]?sp\" 2 } } */\n+/* { dg-final { scan-assembler-not \"\\tcld\" } } */"}, {"sha": "e2cda619a042dcc4227662854922641dc23a3e6f", "filename": "gcc/testsuite/gcc.target/i386/interrupt-sibcall-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-sibcall-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-sibcall-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-sibcall-1.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mgeneral-regs-only -mno-cld\" } */\n+\n+extern void foo (void *) __attribute__ ((interrupt));\n+extern void bar (void);\n+\n+void foo (void *frame)\n+{\n+  bar ();\n+}\n+/* { dg-final { scan-assembler-not \"jmp\" } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "f59253a5d5d6c7117ae25dd40e24c1630c862ef1", "filename": "gcc/testsuite/gcc.target/i386/interrupt-sibcall-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-sibcall-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-sibcall-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-sibcall-2.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mgeneral-regs-only -mno-cld -mpreferred-stack-boundary=3\" { target { ! { ia32 } } } } */\n+/* { dg-options \"-O3 -mgeneral-regs-only -mno-cld -mpreferred-stack-boundary=2\" { target { ia32 } } } */\n+\n+extern void foo (void *) __attribute__ ((interrupt));\n+extern void bar (void) __attribute__ ((no_caller_saved_registers));\n+\n+void foo (void *frame)\n+{\n+  bar ();\n+}\n+/* { dg-final { scan-assembler-not \"jmp\" } } */\n+/* { dg-final { scan-assembler-times \"iret\" 1 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 1 } } */"}, {"sha": "a7aa0a80171c2302ef4e08dedbbb039b9e737f64", "filename": "gcc/testsuite/gcc.target/i386/interrupt-switch-abi.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-switch-abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8071c056663dad2458c96705b459561cd5ea130/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-switch-abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Finterrupt-switch-abi.c?ref=f8071c056663dad2458c96705b459561cd5ea130", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgeneral-regs-only -mno-cld\" } */\n+\n+extern void bar (int);\n+\n+void f1 (void){  bar (1); }\n+__attribute__((interrupt))\n+void f2 (void *frame){  bar (2); }\n+void f3 (void){  bar (3); }\n+__attribute__((interrupt))\n+void f4 (void *frame){  bar (4); }\n+void f5 (void){  bar (5); }\n+\n+/* { dg-final { scan-assembler-times \"push.\\t%.ax\" 2 } } */\n+/* { dg-final { scan-assembler-times \"pop.\\t%.ax\" 2 } } */\n+/* { dg-final { scan-assembler-times \"iret\" 2 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"iretq\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\tcld\" 2 } } */"}]}