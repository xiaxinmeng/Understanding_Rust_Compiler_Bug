{"sha": "1353681247458baa6a3df8375b786df8ace7664c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM1MzY4MTI0NzQ1OGJhYTZhM2RmODM3NWI3ODZkZjhhY2U3NjY0Yw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-17T15:37:04Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-17T15:37:04Z"}, "message": "machmode.h: PROTO -> PARAMS.\n\n        * machmode.h: PROTO -> PARAMS.\n        * mbchar.h: Likewise.\n        * mips-tdump.c: Likewise.\n        * mips-tfile.c: Likewise.\n        * optabs.c: Likewise.\n        * output.h: Likewise.\n        * prefix.c: Likewise.\n        * profile.c: Likewise.\n        * protoize.c: Likewise.\n        * real.h: Likewise.\n        * recog.c: Likewise.\n        * recog.h: Likewise.\n        * regclass.c: Likewise.\n        * regmove.c: Likewise.\n        * regs.h: Likewise.\n\nFrom-SVN: r31459", "tree": {"sha": "2c932fb63a8aa3c1db1b432e880202b0e3f267b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c932fb63a8aa3c1db1b432e880202b0e3f267b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1353681247458baa6a3df8375b786df8ace7664c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1353681247458baa6a3df8375b786df8ace7664c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1353681247458baa6a3df8375b786df8ace7664c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1353681247458baa6a3df8375b786df8ace7664c/comments", "author": null, "committer": null, "parents": [{"sha": "3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677"}], "stats": {"total": 512, "additions": 265, "deletions": 247}, "files": [{"sha": "ec453a6a451fb0bcb64af102d1250d4646dc0ccb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -1,3 +1,21 @@\n+2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* machmode.h: PROTO -> PARAMS.\n+\t* mbchar.h: Likewise.\n+\t* mips-tdump.c: Likewise.\n+\t* mips-tfile.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t* output.h: Likewise.\n+\t* prefix.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* protoize.c: Likewise.\n+\t* real.h: Likewise.\n+\t* recog.c: Likewise.\n+\t* recog.h: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* regs.h: Likewise.\n+\n 2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* ggc-common.c: PROTO -> PARAMS."}, {"sha": "bcb3c065fe7b9a8df75cb7884a8881f90512abb3", "filename": "gcc/machmode.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -105,22 +105,22 @@ extern const unsigned char mode_wider_mode[];\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n    The value is BLKmode if no other mode is found.  */\n \n-extern enum machine_mode mode_for_size PROTO((unsigned int, enum mode_class, int));\n+extern enum machine_mode mode_for_size PARAMS ((unsigned int, enum mode_class, int));\n \n /* Similar, but find the smallest mode for a given width.  */\n \n-extern enum machine_mode smallest_mode_for_size  PROTO((unsigned int,\n+extern enum machine_mode smallest_mode_for_size  PARAMS ((unsigned int,\n                                                         enum mode_class));\n \n \n /* Return an integer mode of the exact same size as the input mode,\n    or BLKmode on failure.  */\n \n-extern enum machine_mode int_mode_for_mode PROTO((enum machine_mode));\n+extern enum machine_mode int_mode_for_mode PARAMS ((enum machine_mode));\n \n /* Find the best mode to use to access a bit field.  */\n \n-extern enum machine_mode get_best_mode PROTO((int, int, int, enum machine_mode, int));\n+extern enum machine_mode get_best_mode PARAMS ((int, int, int, enum machine_mode, int));\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n "}, {"sha": "fe441355f89ece7a31709fa66c98f94398046bb2", "filename": "gcc/mbchar.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmbchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmbchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.h?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -31,9 +31,9 @@ Boston, MA 02111-1307, USA.  */\n #define ISEUCJP(c)   ((c) >= 0xa1 && (c) <= 0xfe)\n #define ISJIS(c)     ((c) >= 0x21 && (c) <= 0x7e)\n \n-extern int local_mbtowc     PROTO ((wchar_t *, const char *, size_t));\n-extern int local_mblen      PROTO ((const char *, size_t));\n-extern int local_mb_cur_max PROTO ((void));\n+extern int local_mbtowc     PARAMS ((wchar_t *, const char *, size_t));\n+extern int local_mblen      PARAMS ((const char *, size_t));\n+extern int local_mb_cur_max PARAMS ((void));\n \n /* The locale being used for multibyte characters in string/char literals.  */\n extern const char *literal_codeset;"}, {"sha": "26643a86962205d1fe90aa8698fa9fa9031338c9", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -56,8 +56,8 @@ typedef const PTR_T CPTR_T;\n #define uint\tunsigned int\n #define ulong\tunsigned long\n \n-void fatal PROTO ((const char *)) ATTRIBUTE_NORETURN;\n-void fancy_abort PROTO ((void)) ATTRIBUTE_NORETURN;\n+void fatal PARAMS ((const char *)) ATTRIBUTE_NORETURN;\n+void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n   \n void\n fatal(s)\n@@ -1441,7 +1441,7 @@ read_tfile __proto((void))\n \n \f\n \n-extern int main PROTO ((int, char **));\n+extern int main PARAMS ((int, char **));\n \n int\n main (argc, argv)"}, {"sha": "01c933ebe0fa04565d9b89039f70f26110f88685", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -637,8 +637,8 @@ extern void\tpfatal_with_name\n extern void\tfancy_abort\t__proto((void)) ATTRIBUTE_NORETURN;\n        void\tbotch\t\t__proto((const char *)) ATTRIBUTE_NORETURN;\n \n-extern void\tfatal\t\tPVPROTO((const char *format, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void\terror\t\tPVPROTO((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n+extern void\tfatal\t\tPARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void\terror\t\tPARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n \f\n #ifndef MIPS_DEBUGGING_INFO\n \n@@ -4801,7 +4801,7 @@ copy_object __proto((void))\n \f\n /* Ye olde main program.  */\n \n-extern int main PROTO ((int, char **));\n+extern int main PARAMS ((int, char **));\n \n int\n main (argc, argv)\n@@ -5554,7 +5554,7 @@ free_thead (ptr)\n \n /*VARARGS*/\n void\n-fatal VPROTO((const char *format, ...))\n+fatal VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *format;\n@@ -5584,7 +5584,7 @@ fatal VPROTO((const char *format, ...))\n \n /*VARARGS*/\n void\n-error VPROTO((const char *format, ...))\n+error VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;"}, {"sha": "14fd87e26d025bb3a7e3c843b25f5641c351c295", "filename": "gcc/optabs.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -83,32 +83,32 @@ enum insn_code setcc_gen_code[NUM_RTX_CODE];\n enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n #endif\n \n-static int add_equal_note\tPROTO((rtx, rtx, enum rtx_code, rtx, rtx));\n-static rtx widen_operand\tPROTO((rtx, enum machine_mode,\n+static int add_equal_note\tPARAMS ((rtx, rtx, enum rtx_code, rtx, rtx));\n+static rtx widen_operand\tPARAMS ((rtx, enum machine_mode,\n \t\t\t\t       enum machine_mode, int, int));\n-static int expand_cmplxdiv_straight PROTO((rtx, rtx, rtx, rtx,\n+static int expand_cmplxdiv_straight PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t\t   rtx, rtx, enum machine_mode,\n \t\t\t\t\t   int, enum optab_methods,\n \t\t\t\t\t   enum mode_class, optab));\n-static int expand_cmplxdiv_wide PROTO((rtx, rtx, rtx, rtx,\n+static int expand_cmplxdiv_wide PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t       rtx, rtx, enum machine_mode,\n \t\t\t\t       int, enum optab_methods,\n \t\t\t\t       enum mode_class, optab));\n-static enum insn_code can_fix_p\tPROTO((enum machine_mode, enum machine_mode,\n+static enum insn_code can_fix_p\tPARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int *));\n-static enum insn_code can_float_p PROTO((enum machine_mode, enum machine_mode,\n+static enum insn_code can_float_p PARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t\t int));\n-static rtx ftruncify\tPROTO((rtx));\n-static optab init_optab\tPROTO((enum rtx_code));\n-static void init_libfuncs PROTO((optab, int, int, const char *, int));\n-static void init_integral_libfuncs PROTO((optab, const char *, int));\n-static void init_floating_libfuncs PROTO((optab, const char *, int));\n+static rtx ftruncify\tPARAMS ((rtx));\n+static optab init_optab\tPARAMS ((enum rtx_code));\n+static void init_libfuncs PARAMS ((optab, int, int, const char *, int));\n+static void init_integral_libfuncs PARAMS ((optab, const char *, int));\n+static void init_floating_libfuncs PARAMS ((optab, const char *, int));\n #ifdef HAVE_conditional_trap\n-static void init_traps PROTO((void));\n+static void init_traps PARAMS ((void));\n #endif\n-static void emit_cmp_and_jump_insn_1 PROTO((rtx, rtx, enum machine_mode,\n+static void emit_cmp_and_jump_insn_1 PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t    enum rtx_code, int, rtx));\n-static void prepare_float_lib_cmp PROTO((rtx *, rtx *, enum rtx_code *,\n+static void prepare_float_lib_cmp PARAMS ((rtx *, rtx *, enum rtx_code *,\n \t\t\t\t\t enum machine_mode *, int *));\n \f\n /* Add a REG_EQUAL note to the last insn in SEQ.  TARGET is being set to"}, {"sha": "dbc373d0c8cb9762f7bce6c5f90734ab29a9589e", "filename": "gcc/output.h", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -20,144 +20,144 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* Initialize data in final at the beginning of a compilation.  */\n-extern void init_final\t\tPROTO((const char *));\n+extern void init_final\t\tPARAMS ((const char *));\n \n /* Called at end of source file,\n    to output the block-profiling table for this entire compilation.  */\n-extern void end_final\t\tPROTO((const char *));\n+extern void end_final\t\tPARAMS ((const char *));\n \n /* Enable APP processing of subsequent output.\n    Used before the output from an `asm' statement.  */\n-extern void app_enable\t\tPROTO((void));\n+extern void app_enable\t\tPARAMS ((void));\n \n /* Disable APP processing of subsequent output.\n    Called from varasm.c before most kinds of output.  */\n-extern void app_disable\t\tPROTO((void));\n+extern void app_disable\t\tPARAMS ((void));\n \n /* Return the number of slots filled in the current \n    delayed branch sequence (we don't count the insn needing the\n    delay slot).   Zero if not in a delayed branch sequence.  */\n-extern int dbr_sequence_length\tPROTO((void));\n+extern int dbr_sequence_length\tPARAMS ((void));\n \n /* Indicate that branch shortening hasn't yet been done.  */\n-extern void init_insn_lengths\tPROTO((void));\n+extern void init_insn_lengths\tPARAMS ((void));\n \n #ifdef RTX_CODE\n /* Obtain the current length of an insn.  If branch shortening has been done,\n    get its actual length.  Otherwise, get its maximum length.  */\n-extern int get_attr_length\tPROTO((rtx));\n+extern int get_attr_length\tPARAMS ((rtx));\n \n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n-extern void shorten_branches\tPROTO((rtx));\n+extern void shorten_branches\tPARAMS ((rtx));\n \n /* Output assembler code for the start of a function,\n    and initialize some of the variables in this file\n    for the new function.  The label for the function and associated\n    assembler pseudo-ops have already been output in\n    `assemble_start_function'.  */\n-extern void final_start_function  PROTO((rtx, FILE *, int));\n+extern void final_start_function  PARAMS ((rtx, FILE *, int));\n \n /* Output assembler code for the end of a function.\n    For clarity, args are same as those of `final_start_function'\n    even though not all of them are needed.  */\n-extern void final_end_function  PROTO((rtx, FILE *, int));\n+extern void final_end_function  PARAMS ((rtx, FILE *, int));\n \n /* Output assembler code for some insns: all or part of a function.  */\n-extern void final\t\tPROTO((rtx, FILE *, int, int));\n+extern void final\t\tPARAMS ((rtx, FILE *, int, int));\n \n /* The final scan for one insn, INSN.  Args are same as in `final', except\n    that INSN is the insn being scanned.  Value returned is the next insn to\n    be scanned.  */\n-extern rtx final_scan_insn\tPROTO((rtx, FILE *, int, int, int));\n+extern rtx final_scan_insn\tPARAMS ((rtx, FILE *, int, int, int));\n \n /* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n    subreg of.  */\n-extern rtx alter_subreg PROTO((rtx));\n+extern rtx alter_subreg PARAMS ((rtx));\n \n /* Report inconsistency between the assembler template and the operands.\n    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\n-extern void output_operand_lossage  PROTO((const char *));\n+extern void output_operand_lossage  PARAMS ((const char *));\n \n /* Output a string of assembler code, substituting insn operands.\n    Defined in final.c.  */\n-extern void output_asm_insn\tPROTO((const char *, rtx *));\n+extern void output_asm_insn\tPARAMS ((const char *, rtx *));\n \n /* Compute a worst-case reference address of a branch so that it\n    can be safely used in the presence of aligned labels.\n    Defined in final.c.  */\n-extern int insn_current_reference_address\tPROTO((rtx));\n+extern int insn_current_reference_address\tPARAMS ((rtx));\n \n /* Find the alignment associated with a CODE_LABEL.\n    Defined in final.c.  */\n-extern int label_to_alignment\tPROTO((rtx));\n+extern int label_to_alignment\tPARAMS ((rtx));\n \n /* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\n-extern void output_asm_label\tPROTO((rtx));\n+extern void output_asm_label\tPARAMS ((rtx));\n \n /* Print a memory reference operand for address X\n    using machine-dependent assembler syntax.  */\n-extern void output_address\tPROTO((rtx));\n+extern void output_address\tPARAMS ((rtx));\n \n /* Print an integer constant expression in assembler syntax.\n    Addition and subtraction are the only arithmetic\n    that may appear in these expressions.  */\n-extern void output_addr_const PROTO((FILE *, rtx));\n+extern void output_addr_const PARAMS ((FILE *, rtx));\n \n /* Output a string of assembler code, substituting numbers, strings\n    and fixed syntactic prefixes.  */\n-extern void asm_fprintf\t\tPVPROTO((FILE *file, const char *p, ...));\n+extern void asm_fprintf\t\tPARAMS ((FILE *file, const char *p, ...));\n \n /* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n    words.  */\n-extern void split_double\tPROTO((rtx, rtx *, rtx *));\n+extern void split_double\tPARAMS ((rtx, rtx *, rtx *));\n \n /* Return nonzero if this function has no function calls.  */\n-extern int leaf_function_p\tPROTO((void));\n+extern int leaf_function_p\tPARAMS ((void));\n \n /* Return 1 if this function uses only the registers that can be\n    safely renumbered.  */\n-extern int only_leaf_regs_used\tPROTO((void));\n+extern int only_leaf_regs_used\tPARAMS ((void));\n \n /* Scan IN_RTX and its subexpressions, and renumber all regs into those\n    available in leaf functions.  */\n-extern void leaf_renumber_regs_insn PROTO((rtx));\n+extern void leaf_renumber_regs_insn PARAMS ((rtx));\n \n /* Locate the proper template for the given insn-code.  */\n-extern const char *get_insn_template PROTO((int, rtx));\n+extern const char *get_insn_template PARAMS ((int, rtx));\n \n /* Functions in flow.c */\n-extern void allocate_for_life_analysis\tPROTO((void));\n-extern int regno_uninitialized\t\tPROTO((int));\n-extern int regno_clobbered_at_setjmp\tPROTO((int));\n-extern void dump_flow_info\t\tPROTO((FILE *));\n-extern void find_basic_blocks         PROTO((rtx, int, FILE *, int));\n-extern void calculate_loop_depth      PROTO((FILE *));\n-extern void free_basic_block_vars     PROTO((int));\n-extern void set_block_num             PROTO((rtx, int));\n-extern void life_analysis             PROTO((rtx, int, FILE *, int));\n+extern void allocate_for_life_analysis\tPARAMS ((void));\n+extern int regno_uninitialized\t\tPARAMS ((int));\n+extern int regno_clobbered_at_setjmp\tPARAMS ((int));\n+extern void dump_flow_info\t\tPARAMS ((FILE *));\n+extern void find_basic_blocks         PARAMS ((rtx, int, FILE *, int));\n+extern void calculate_loop_depth      PARAMS ((FILE *));\n+extern void free_basic_block_vars     PARAMS ((int));\n+extern void set_block_num             PARAMS ((rtx, int));\n+extern void life_analysis             PARAMS ((rtx, int, FILE *, int));\n #endif\n \n /* Functions in varasm.c.  */\n \n /* Tell assembler to switch to text section.  */\n-extern void text_section\t\tPROTO((void));\n+extern void text_section\t\tPARAMS ((void));\n \n /* Tell assembler to switch to data section.  */\n-extern void data_section\t\tPROTO((void));\n+extern void data_section\t\tPARAMS ((void));\n \n /* Tell assembler to make sure its in the data section.  */\n-extern void force_data_section\t\tPROTO((void));\n+extern void force_data_section\t\tPARAMS ((void));\n \n /* Tell assembler to switch to read-only data section.  This is normally\n    the text section.  */\n-extern void readonly_data_section\tPROTO((void));\n+extern void readonly_data_section\tPARAMS ((void));\n \n /* Determine if we're in the text section. */\n-extern int in_text_section\t\tPROTO((void));\n+extern int in_text_section\t\tPARAMS ((void));\n \n #ifdef EH_FRAME_SECTION_ASM_OP\n-extern void eh_frame_section\t\tPROTO ((void));\n+extern void eh_frame_section\t\tPARAMS ((void));\n #endif\n \n #ifdef CTORS_SECTION_ASM_OP\n@@ -193,25 +193,25 @@ extern void tdesc_section PARAMS ((void));\n    If DECL is NULL, just switch to section NAME.\n    If NAME is NULL, get the name from DECL.\n    If RELOC is 1, the initializer for DECL contains relocs.  */\n-extern void named_section\t\tPROTO((tree, const char *, int));\n+extern void named_section\t\tPARAMS ((tree, const char *, int));\n \n /* Tell assembler to switch to the section for function DECL.  */\n-extern void function_section\t\tPROTO((tree));\n+extern void function_section\t\tPARAMS ((tree));\n \n /* Tell assembler to switch to the section for the exception table.  */\n-extern void exception_section\t\tPROTO((void));\n+extern void exception_section\t\tPARAMS ((void));\n \n /* Create the rtl to represent a function, for a function definition.\n    DECL is a FUNCTION_DECL node which describes which function.\n    The rtl is stored into DECL.  */\n-extern void make_function_rtl\t\tPROTO((tree));\n+extern void make_function_rtl\t\tPARAMS ((tree));\n \n /* Declare DECL to be a weak symbol.  */\n-extern void declare_weak\t\tPROTO ((tree));\n+extern void declare_weak\t\tPARAMS ((tree));\n #endif /* TREE_CODE */\n \n /* Emit any pending weak declarations.  */\n-extern void weak_finish\t\t\tPROTO ((void));\n+extern void weak_finish\t\t\tPARAMS ((void));\n \n /* Decode an `asm' spec for a declaration as a register name.\n    Return the register number, or -1 if nothing specified,\n@@ -220,7 +220,7 @@ extern void weak_finish\t\t\tPROTO ((void));\n    or -4 if ASMSPEC is `memory' and is not recognized.\n    Accept an exact spelling or a decimal number.\n    Prefixes such as % are optional.  */\n-extern int decode_reg_name\t\tPROTO((const char *));\n+extern int decode_reg_name\t\tPARAMS ((const char *));\n \n #ifdef TREE_CODE\n /* Create the DECL_RTL for a declaration for a static or external variable\n@@ -230,30 +230,30 @@ extern int decode_reg_name\t\tPROTO((const char *));\n    TOP_LEVEL is nonzero if this is a file-scope variable.\n \n    This is never called for PARM_DECL nodes.  */\n-extern void make_decl_rtl\t\tPROTO((tree, const char *, int));\n+extern void make_decl_rtl\t\tPARAMS ((tree, const char *, int));\n \n /* Make the rtl for variable VAR be volatile.\n    Use this only for static variables.  */\n-extern void make_var_volatile\t\tPROTO((tree));\n+extern void make_var_volatile\t\tPARAMS ((tree));\n \n /* Output alignment directive to align for constant expression EXP.  */\n-extern void assemble_constant_align\tPROTO((tree));\n+extern void assemble_constant_align\tPARAMS ((tree));\n \n-extern void assemble_alias\t\tPROTO((tree, tree));\n+extern void assemble_alias\t\tPARAMS ((tree, tree));\n \n /* Output a string of literal assembler code\n    for an `asm' keyword used between functions.  */\n-extern void assemble_asm\t\tPROTO((tree));\n+extern void assemble_asm\t\tPARAMS ((tree));\n \n /* Output assembler code for the constant pool of a function and associated\n    with defining the name of the function.  DECL describes the function.\n    NAME is the function's name.  For the constant pool, we use the current\n    constant pool data.  */\n-extern void assemble_start_function\tPROTO((tree, char *));\n+extern void assemble_start_function\tPARAMS ((tree, char *));\n \n /* Output assembler code associated with defining the size of the\n    function.  DECL describes the function.  NAME is the function's name.  */\n-extern void assemble_end_function\tPROTO((tree, const char *));\n+extern void assemble_end_function\tPARAMS ((tree, const char *));\n \n /* Assemble everything that is needed for a variable or function declaration.\n    Not used for automatic variables, and not used for function definitions.\n@@ -264,12 +264,12 @@ extern void assemble_end_function\tPROTO((tree, const char *));\n    to define things that have had only tentative definitions.\n    DONT_OUTPUT_DATA if nonzero means don't actually output the\n    initial value (that will be done by the caller).  */\n-extern void assemble_variable\t\tPROTO((tree, int, int, int));\n+extern void assemble_variable\t\tPARAMS ((tree, int, int, int));\n \n /* Output something to declare an external symbol to the assembler.\n    (Most assemblers don't need this, so we normally output nothing.)\n    Do nothing if DECL is not external.  */\n-extern void assemble_external\t\tPROTO((tree));\n+extern void assemble_external\t\tPARAMS ((tree));\n #endif /* TREE_CODE */\n \n /* Record an element in the table of global destructors.\n@@ -278,79 +278,79 @@ extern void assemble_external\t\tPROTO((tree));\n \n    NAME should be the name of a global function to be called\n    at exit time.  This name is output using assemble_name.  */\n-extern void assemble_destructor\t\tPROTO((const char *));\n+extern void assemble_destructor\t\tPARAMS ((const char *));\n \n /* Likewise for global constructors.  */\n-extern void assemble_constructor\tPROTO((const char *));\n+extern void assemble_constructor\tPARAMS ((const char *));\n \n /* Likewise for entries we want to record for garbage collection.\n    Garbage collection is still under development.  */\n-extern void assemble_gc_entry\t\tPROTO((const char *));\n+extern void assemble_gc_entry\t\tPARAMS ((const char *));\n \n /* Assemble code to leave SIZE bytes of zeros.  */\n-extern void assemble_zeros\t\tPROTO((int));\n+extern void assemble_zeros\t\tPARAMS ((int));\n \n /* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n-extern void assemble_align\t\tPROTO((int));\n+extern void assemble_align\t\tPARAMS ((int));\n \n /* Assemble a string constant with the specified C string as contents.  */\n-extern void assemble_string\t\tPROTO((const char *, int));\n+extern void assemble_string\t\tPARAMS ((const char *, int));\n \n #ifdef RTX_CODE\n /* Similar, for calling a library function FUN.  */\n-extern void assemble_external_libcall\tPROTO((rtx));\n+extern void assemble_external_libcall\tPARAMS ((rtx));\n #endif\n \n /* Declare the label NAME global.  */\n-extern void assemble_global\t\tPROTO((const char *));\n+extern void assemble_global\t\tPARAMS ((const char *));\n \n /* Assemble a label named NAME.  */\n-extern void assemble_label\t\tPROTO((const char *));\n+extern void assemble_label\t\tPARAMS ((const char *));\n \n /* Output to FILE a reference to the assembler name of a C-level name NAME.\n    If NAME starts with a *, the rest of NAME is output verbatim.\n    Otherwise NAME is transformed in an implementation-defined way\n    (usually by the addition of an underscore).\n    Many macros in the tm file are defined to call this function.  */\n-extern void assemble_name\t\tPROTO((FILE *, const char *));\n+extern void assemble_name\t\tPARAMS ((FILE *, const char *));\n \n #ifdef RTX_CODE\n /* Assemble the integer constant X into an object of SIZE bytes.\n    X must be either a CONST_INT or CONST_DOUBLE.\n \n    Return 1 if we were able to output the constant, otherwise 0.  If FORCE is\n    non-zero, abort if we can't output the constant.  */\n-extern int assemble_integer\t\tPROTO((rtx, int, int));\n+extern int assemble_integer\t\tPARAMS ((rtx, int, int));\n \n #ifdef EMUSHORT\n /* Assemble the floating-point constant D into an object of size MODE.  */\n-extern void assemble_real\t\tPROTO((REAL_VALUE_TYPE,\n+extern void assemble_real\t\tPARAMS ((REAL_VALUE_TYPE,\n \t\t\t\t\t       enum machine_mode));\n #endif\n #endif\n \n /* At the end of a function, forget the memory-constants\n    previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.\n    Also clear out real_constant_chain and clear out all the chain-pointers.  */\n-extern void clear_const_double_mem\tPROTO((void));\n+extern void clear_const_double_mem\tPARAMS ((void));\n \n /* Start deferring output of subconstants.  */\n-extern void defer_addressed_constants\tPROTO((void));\n+extern void defer_addressed_constants\tPARAMS ((void));\n \n /* Stop deferring output of subconstants,\n    and output now all those that have been deferred.  */\n-extern void output_deferred_addressed_constants PROTO((void));\n+extern void output_deferred_addressed_constants PARAMS ((void));\n \n /* Return the size of the constant pool.  */\n-extern int get_pool_size\t\tPROTO((void));\n+extern int get_pool_size\t\tPARAMS ((void));\n \n #ifdef HAVE_peephole\n-extern rtx peephole\t\t\tPROTO((rtx));\n+extern rtx peephole\t\t\tPARAMS ((rtx));\n #endif\n \n #ifdef TREE_CODE\n /* Write all the constants in the constant pool.  */\n-extern void output_constant_pool\tPROTO((const char *, tree));\n+extern void output_constant_pool\tPARAMS ((const char *, tree));\n \n /* Return nonzero if VALUE is a valid constant-valued expression\n    for use in initializing a static variable; one that can be an\n@@ -361,15 +361,15 @@ extern void output_constant_pool\tPROTO((const char *, tree));\n    We assume that VALUE has been folded as much as possible;\n    therefore, we do not need to check for such things as\n    arithmetic-combinations of integers.  */\n-extern tree initializer_constant_valid_p\tPROTO((tree, tree));\n+extern tree initializer_constant_valid_p\tPARAMS ((tree, tree));\n \n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n    Assumes output_addressed_constants has been done on EXP already.\n \n    Generate exactly SIZE bytes of assembler data, padding at the end\n    with zeros if necessary.  SIZE must always be specified.  */\n-extern void output_constant\t\tPROTO((tree, int));\n+extern void output_constant\t\tPARAMS ((tree, int));\n #endif\n \n /* When outputting assembler code, indicates which alternative"}, {"sha": "febec06bfee18981950d458eba4ab04b3df916dc", "filename": "gcc/prefix.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -73,12 +73,12 @@ Boston, MA 02111-1307, USA.  */\n \n static const char *std_prefix = PREFIX;\n \n-static const char *get_key_value\tPROTO((char *));\n-static const char *translate_name\tPROTO((const char *));\n-static char *save_string\t\tPROTO((const char *, int));\n+static const char *get_key_value\tPARAMS ((char *));\n+static const char *translate_name\tPARAMS ((const char *));\n+static char *save_string\t\tPARAMS ((const char *, int));\n \n #if defined(_WIN32) && defined(ENABLE_WIN32_REGISTRY)\n-static char *lookup_key\t\tPROTO((char *));\n+static char *lookup_key\t\tPARAMS ((char *));\n static HKEY reg_key = (HKEY) INVALID_HANDLE_VALUE;\n #endif\n \n@@ -112,7 +112,7 @@ get_key_value (key)\n    This function is based on the one in libiberty.  */\n \n char *\n-concat VPROTO((const char *first, ...))\n+concat VPARAMS ((const char *first, ...))\n {\n   register int length;\n   register char *newstr;"}, {"sha": "d19b37b4cf797b2194b4193c6fabfb9a04714128", "filename": "gcc/profile.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -150,16 +150,16 @@ static int total_num_never_executed;\n static int total_num_branches;\n \n /* Forward declarations.  */\n-static void init_arc PROTO((struct adj_list *, int, int, rtx));\n-static void find_spanning_tree PROTO((int));\n-static void expand_spanning_tree PROTO((int));\n-static void fill_spanning_tree PROTO((int));\n-static void init_arc_profiler PROTO((void));\n-static void output_arc_profiler PROTO((int, rtx));\n-static void instrument_arcs PROTO((rtx, int, FILE *));\n-static void output_gcov_string PROTO((const char *, long));\n-static int tablejump_entry_p PROTO((rtx, rtx));\n-static void compute_branch_probabilities PROTO((int, FILE *));\n+static void init_arc PARAMS ((struct adj_list *, int, int, rtx));\n+static void find_spanning_tree PARAMS ((int));\n+static void expand_spanning_tree PARAMS ((int));\n+static void fill_spanning_tree PARAMS ((int));\n+static void init_arc_profiler PARAMS ((void));\n+static void output_arc_profiler PARAMS ((int, rtx));\n+static void instrument_arcs PARAMS ((rtx, int, FILE *));\n+static void output_gcov_string PARAMS ((const char *, long));\n+static int tablejump_entry_p PARAMS ((rtx, rtx));\n+static void compute_branch_probabilities PARAMS ((int, FILE *));\n \n #ifndef LONG_TYPE_SIZE\n #define LONG_TYPE_SIZE BITS_PER_WORD"}, {"sha": "c63dae5256ab288c9febf68e160f09ca23ae08c5", "filename": "gcc/protoize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -74,7 +74,7 @@ static int directory_specified_p PARAMS ((const char *));\n static int file_excluded_p PARAMS ((const char *));\n static char *unexpand_if_needed PARAMS ((const char *));\n static char *abspath PARAMS ((const char *, const char *));\n-static int is_abspath PVPROTO ((const char *));\n+static int is_abspath PARAMS ((const char *));\n static void check_aux_info PARAMS ((int));\n static const char *find_corresponding_lparen PARAMS ((const char *));\n static int referenced_file_is_newer PARAMS ((const char *, time_t));"}, {"sha": "dd40e89f6dc763d9e0e97b32a9ac062e16a49cbe", "filename": "gcc/real.h", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -115,7 +115,7 @@ typedef struct {\n #endif /* no TFmode support */\n #endif /* no XFmode support */\n \n-extern int significand_size\tPROTO((enum machine_mode));\n+extern int significand_size\tPARAMS ((enum machine_mode));\n \n /* If emulation has been enabled by defining REAL_ARITHMETIC or by\n    setting LONG_DOUBLE_TYPE_SIZE to 96 or 128, then define macros so that\n@@ -128,36 +128,36 @@ extern int significand_size\tPROTO((enum machine_mode));\n   earith (&(value), (code), &(d1), &(d2))\n \n /* Declare functions in real.c. */\n-extern void earith\t\tPROTO((REAL_VALUE_TYPE *, int,\n+extern void earith\t\tPARAMS ((REAL_VALUE_TYPE *, int,\n \t\t\t\t       REAL_VALUE_TYPE *, REAL_VALUE_TYPE *));\n-extern REAL_VALUE_TYPE etrunci\tPROTO((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE etruncui\tPROTO((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_atof PROTO((const char *, enum machine_mode));\n-extern REAL_VALUE_TYPE ereal_negate PROTO((REAL_VALUE_TYPE));\n-extern HOST_WIDE_INT efixi\tPROTO((REAL_VALUE_TYPE));\n-extern unsigned HOST_WIDE_INT efixui PROTO((REAL_VALUE_TYPE));\n-extern void ereal_from_int\tPROTO((REAL_VALUE_TYPE *,\n+extern REAL_VALUE_TYPE etrunci\tPARAMS ((REAL_VALUE_TYPE));\n+extern REAL_VALUE_TYPE etruncui\tPARAMS ((REAL_VALUE_TYPE));\n+extern REAL_VALUE_TYPE ereal_atof PARAMS ((const char *, enum machine_mode));\n+extern REAL_VALUE_TYPE ereal_negate PARAMS ((REAL_VALUE_TYPE));\n+extern HOST_WIDE_INT efixi\tPARAMS ((REAL_VALUE_TYPE));\n+extern unsigned HOST_WIDE_INT efixui PARAMS ((REAL_VALUE_TYPE));\n+extern void ereal_from_int\tPARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       enum machine_mode));\n-extern void ereal_from_uint\tPROTO((REAL_VALUE_TYPE *,\n+extern void ereal_from_uint\tPARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t       unsigned HOST_WIDE_INT,\n \t\t\t\t       unsigned HOST_WIDE_INT,\n \t\t\t\t       enum machine_mode));\n-extern void ereal_to_int\tPROTO((HOST_WIDE_INT *, HOST_WIDE_INT *,\n+extern void ereal_to_int\tPARAMS ((HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t       REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_ldexp PROTO((REAL_VALUE_TYPE, int));\n-\n-extern void etartdouble\t\tPROTO((REAL_VALUE_TYPE, long *));\n-extern void etarldouble\t\tPROTO((REAL_VALUE_TYPE, long *));\n-extern void etardouble\t\tPROTO((REAL_VALUE_TYPE, long *));\n-extern long etarsingle\t\tPROTO((REAL_VALUE_TYPE));\n-extern void ereal_to_decimal\tPROTO((REAL_VALUE_TYPE, char *));\n-extern int ereal_cmp\t\tPROTO((REAL_VALUE_TYPE, REAL_VALUE_TYPE));\n-extern int ereal_isneg\t\tPROTO((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_unto_float PROTO((long));\n-extern REAL_VALUE_TYPE ereal_unto_double PROTO((long *));\n-extern REAL_VALUE_TYPE ereal_from_float PROTO((HOST_WIDE_INT));\n-extern REAL_VALUE_TYPE ereal_from_double PROTO((HOST_WIDE_INT *));\n+extern REAL_VALUE_TYPE ereal_ldexp PARAMS ((REAL_VALUE_TYPE, int));\n+\n+extern void etartdouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\n+extern void etarldouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\n+extern void etardouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\n+extern long etarsingle\t\tPARAMS ((REAL_VALUE_TYPE));\n+extern void ereal_to_decimal\tPARAMS ((REAL_VALUE_TYPE, char *));\n+extern int ereal_cmp\t\tPARAMS ((REAL_VALUE_TYPE, REAL_VALUE_TYPE));\n+extern int ereal_isneg\t\tPARAMS ((REAL_VALUE_TYPE));\n+extern REAL_VALUE_TYPE ereal_unto_float PARAMS ((long));\n+extern REAL_VALUE_TYPE ereal_unto_double PARAMS ((long *));\n+extern REAL_VALUE_TYPE ereal_from_float PARAMS ((HOST_WIDE_INT));\n+extern REAL_VALUE_TYPE ereal_from_double PARAMS ((HOST_WIDE_INT *));\n \n #define REAL_VALUES_EQUAL(x, y) (ereal_cmp ((x), (y)) == 0)\n /* true if x < y : */\n@@ -167,7 +167,7 @@ extern REAL_VALUE_TYPE ereal_from_double PROTO((HOST_WIDE_INT *));\n /* These return REAL_VALUE_TYPE: */\n #define REAL_VALUE_RNDZINT(x) (etrunci (x))\n #define REAL_VALUE_UNSIGNED_RNDZINT(x) (etruncui (x))\n-extern REAL_VALUE_TYPE real_value_truncate\tPROTO ((enum machine_mode,\n+extern REAL_VALUE_TYPE real_value_truncate\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t\tREAL_VALUE_TYPE));\n #define REAL_VALUE_TRUNCATE(mode, x)  real_value_truncate (mode, x)\n \n@@ -357,7 +357,7 @@ extern double ldexp ();\n #ifndef REAL_VALUE_ATOF\n #if 1\n /* Use real.c to convert decimal numbers to binary, ... */\n-extern REAL_VALUE_TYPE ereal_atof PROTO((const char *, enum machine_mode));\n+extern REAL_VALUE_TYPE ereal_atof PARAMS ((const char *, enum machine_mode));\n #define REAL_VALUE_ATOF(x, s) ereal_atof (x, s)\n /* Could use ereal_atof here for hexadecimal floats too, but real_hex_to_f\n    is OK and it uses faster native fp arithmetic.  */\n@@ -379,7 +379,7 @@ extern double (atof) ();\n /* Hexadecimal floating constant input for use with host computer's\n    fp arithmetic.  */\n #ifndef REAL_VALUE_HTOF\n-extern REAL_VALUE_TYPE real_hex_to_f PROTO((char *, enum machine_mode));\n+extern REAL_VALUE_TYPE real_hex_to_f PARAMS ((char *, enum machine_mode));\n #define REAL_VALUE_HTOF(s,m) real_hex_to_f(s,m)\n #endif\n \n@@ -393,7 +393,7 @@ extern REAL_VALUE_TYPE real_hex_to_f PROTO((char *, enum machine_mode));\n    size and where `float' is SFmode.  */\n \n /* Don't use REAL_VALUE_TRUNCATE directly--always call real_value_truncate.  */\n-extern REAL_VALUE_TYPE real_value_truncate PROTO((enum machine_mode,\n+extern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n \t\t\t\t\t\t  REAL_VALUE_TYPE));\n \n #ifndef REAL_VALUE_TRUNCATE\n@@ -417,9 +417,9 @@ extern REAL_VALUE_TYPE real_value_truncate PROTO((enum machine_mode,\n #define REAL_VALUE_NEGATIVE(x) (target_negative (x))\n #endif\n \n-extern int target_isnan\t\t\tPROTO((REAL_VALUE_TYPE));\n-extern int target_isinf\t\t\tPROTO((REAL_VALUE_TYPE));\n-extern int target_negative\t\tPROTO((REAL_VALUE_TYPE));\n+extern int target_isnan\t\t\tPARAMS ((REAL_VALUE_TYPE));\n+extern int target_isinf\t\t\tPARAMS ((REAL_VALUE_TYPE));\n+extern int target_negative\t\tPARAMS ((REAL_VALUE_TYPE));\n \n /* Determine whether a floating-point value X is minus 0. */\n #ifndef REAL_VALUE_MINUS_ZERO\n@@ -463,7 +463,7 @@ union real_extract\n /* Function to return a real value (not a tree node)\n    from a given integer constant.  */\n union tree_node;\n-REAL_VALUE_TYPE real_value_from_int_cst\tPROTO ((union tree_node *,\n+REAL_VALUE_TYPE real_value_from_int_cst\tPARAMS ((union tree_node *,\n \t\t\t\t\t\tunion tree_node *));\n \n #define REAL_VALUE_FROM_CONST_DOUBLE(to, from)\t\t\\\n@@ -474,7 +474,7 @@ do { union real_extract u;\t\t\t\t\\\n /* Return a CONST_DOUBLE with value R and mode M.  */\n \n #define CONST_DOUBLE_FROM_REAL_VALUE(r, m) immed_real_const_1 (r,  m)\n-extern struct rtx_def *immed_real_const_1\tPROTO((REAL_VALUE_TYPE,\n+extern struct rtx_def *immed_real_const_1\tPARAMS ((REAL_VALUE_TYPE,\n \t\t\t\t\t\t       enum machine_mode));\n \n \n@@ -486,18 +486,18 @@ extern struct rtx_def *immed_real_const_1\tPROTO((REAL_VALUE_TYPE,\n #endif\n \n /* Replace R by 1/R in the given machine mode, if the result is exact.  */\n-extern int exact_real_inverse\tPROTO((enum machine_mode, REAL_VALUE_TYPE *));\n-extern int target_isnan\t\tPROTO((REAL_VALUE_TYPE));\n-extern int target_isinf\t\tPROTO((REAL_VALUE_TYPE));\n-extern int target_negative\tPROTO((REAL_VALUE_TYPE));\n-extern void debug_real\t\tPROTO((REAL_VALUE_TYPE));\n+extern int exact_real_inverse\tPARAMS ((enum machine_mode, REAL_VALUE_TYPE *));\n+extern int target_isnan\t\tPARAMS ((REAL_VALUE_TYPE));\n+extern int target_isinf\t\tPARAMS ((REAL_VALUE_TYPE));\n+extern int target_negative\tPARAMS ((REAL_VALUE_TYPE));\n+extern void debug_real\t\tPARAMS ((REAL_VALUE_TYPE));\n \n /* In varasm.c */\n-extern void assemble_real\t\tPROTO((REAL_VALUE_TYPE,\n+extern void assemble_real\t\tPARAMS ((REAL_VALUE_TYPE,\n \t\t\t\t\t       enum machine_mode));\n-extern void debug_real\t\t\tPROTO((REAL_VALUE_TYPE));\n+extern void debug_real\t\t\tPARAMS ((REAL_VALUE_TYPE));\n \n /* In varasm.c */\n-extern void assemble_real\t\tPROTO((REAL_VALUE_TYPE,\n+extern void assemble_real\t\tPARAMS ((REAL_VALUE_TYPE,\n \t\t\t\t\t       enum machine_mode));\n #endif /* Not REAL_H_INCLUDED */"}, {"sha": "007e4fab86c9f9e11f98b424ce13876d76a8e882", "filename": "gcc/recog.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -54,10 +54,10 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #endif\n \n-static void validate_replace_rtx_1\tPROTO((rtx *, rtx, rtx, rtx));\n-static rtx *find_single_use_1\t\tPROTO((rtx, rtx *));\n-static rtx *find_constant_term_loc\tPROTO((rtx *));\n-static int insn_invalid_p\t\tPROTO((rtx));\n+static void validate_replace_rtx_1\tPARAMS ((rtx *, rtx, rtx, rtx));\n+static rtx *find_single_use_1\t\tPARAMS ((rtx, rtx *));\n+static rtx *find_constant_term_loc\tPARAMS ((rtx *));\n+static int insn_invalid_p\t\tPARAMS ((rtx));\n \n /* Nonzero means allow operands to be volatile.\n    This should be 0 if you are generating rtl, such as if you are calling\n@@ -1846,7 +1846,7 @@ offsettable_address_p (strictp, mode, y)\n   register rtx z;\n   rtx y1 = y;\n   rtx *y2;\n-  int (*addressp) PROTO ((enum machine_mode, rtx)) =\n+  int (*addressp) PARAMS ((enum machine_mode, rtx)) =\n     (strictp ? strict_memory_address_p : memory_address_p);\n \n   if (CONSTANT_ADDRESS_P (y))"}, {"sha": "eaee0cbaf7f79291f38ece4d5a5ef792910a1454", "filename": "gcc/recog.h", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -66,58 +66,58 @@ struct operand_alternative\n };\n \n \n-extern void init_recog\t\t\tPROTO((void));\n-extern void init_recog_no_volatile\tPROTO((void));\n-extern int recog_memoized\t\tPROTO((rtx));\n-extern int check_asm_operands\t\tPROTO((rtx));\n-extern int asm_operand_ok\t\tPROTO((rtx, const char *));\n-extern int validate_change\t\tPROTO((rtx, rtx *, rtx, int));\n-extern int apply_change_group\t\tPROTO((void));\n-extern int num_validated_changes\tPROTO((void));\n-extern void cancel_changes\t\tPROTO((int));\n-extern int constrain_operands\t\tPROTO((int));\n-extern int memory_address_p\t\tPROTO((enum machine_mode, rtx));\n-extern int strict_memory_address_p\tPROTO((enum machine_mode, rtx));\n-extern int validate_replace_rtx\t\tPROTO((rtx, rtx, rtx));\n-extern void validate_replace_rtx_group\tPROTO((rtx, rtx, rtx));\n-extern int validate_replace_src\t\tPROTO((rtx, rtx, rtx));\n+extern void init_recog\t\t\tPARAMS ((void));\n+extern void init_recog_no_volatile\tPARAMS ((void));\n+extern int recog_memoized\t\tPARAMS ((rtx));\n+extern int check_asm_operands\t\tPARAMS ((rtx));\n+extern int asm_operand_ok\t\tPARAMS ((rtx, const char *));\n+extern int validate_change\t\tPARAMS ((rtx, rtx *, rtx, int));\n+extern int apply_change_group\t\tPARAMS ((void));\n+extern int num_validated_changes\tPARAMS ((void));\n+extern void cancel_changes\t\tPARAMS ((int));\n+extern int constrain_operands\t\tPARAMS ((int));\n+extern int memory_address_p\t\tPARAMS ((enum machine_mode, rtx));\n+extern int strict_memory_address_p\tPARAMS ((enum machine_mode, rtx));\n+extern int validate_replace_rtx\t\tPARAMS ((rtx, rtx, rtx));\n+extern void validate_replace_rtx_group\tPARAMS ((rtx, rtx, rtx));\n+extern int validate_replace_src\t\tPARAMS ((rtx, rtx, rtx));\n #ifdef HAVE_cc0\n-extern int next_insn_tests_no_inequality PROTO ((rtx));\n+extern int next_insn_tests_no_inequality PARAMS ((rtx));\n #endif\n-extern int reg_fits_class_p\t\tPROTO((rtx, enum reg_class, int,\n+extern int reg_fits_class_p\t\tPARAMS ((rtx, enum reg_class, int,\n \t\t\t\t\t       enum machine_mode));\n-extern rtx *find_single_use\t\tPROTO((rtx, rtx, rtx *));\n-\n-extern int general_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int address_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int register_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int pmode_register_operand\tPROTO((rtx, enum machine_mode));\n-extern int scratch_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int immediate_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int const_int_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int const_double_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int nonimmediate_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int nonmemory_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int push_operand\t\t\tPROTO((rtx, enum machine_mode));\n-extern int pop_operand\t\t\tPROTO((rtx, enum machine_mode));\n-extern int memory_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int indirect_operand\t\tPROTO((rtx, enum machine_mode));\n-extern int mode_independent_operand\tPROTO((rtx, enum machine_mode));\n-extern int comparison_operator\t\tPROTO((rtx, enum machine_mode));\n-\n-extern int offsettable_memref_p\t\tPROTO((rtx));\n-extern int offsettable_nonstrict_memref_p\tPROTO((rtx));\n-extern int offsettable_address_p\tPROTO((int, enum machine_mode, rtx));\n-extern int mode_dependent_address_p\tPROTO((rtx));\n-\n-extern int recog\t\t\tPROTO((rtx, rtx, int *));\n-extern void add_clobbers\t\tPROTO((rtx, int));\n-extern void insn_extract\t\tPROTO((rtx));\n-extern void extract_insn\t\tPROTO((rtx));\n-extern void preprocess_constraints\tPROTO((void));\n-extern rtx recog_next_insn\t\tPROTO((rtx, int));\n-extern void peephole2_optimize\t\tPROTO((FILE *));\n-extern rtx peephole2_insns\t\tPROTO((rtx, rtx, rtx *));\n+extern rtx *find_single_use\t\tPARAMS ((rtx, rtx, rtx *));\n+\n+extern int general_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int address_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int register_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int pmode_register_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int scratch_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int immediate_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int const_int_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int const_double_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int nonimmediate_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int nonmemory_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int push_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n+extern int pop_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n+extern int memory_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int indirect_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int mode_independent_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int comparison_operator\t\tPARAMS ((rtx, enum machine_mode));\n+\n+extern int offsettable_memref_p\t\tPARAMS ((rtx));\n+extern int offsettable_nonstrict_memref_p\tPARAMS ((rtx));\n+extern int offsettable_address_p\tPARAMS ((int, enum machine_mode, rtx));\n+extern int mode_dependent_address_p\tPARAMS ((rtx));\n+\n+extern int recog\t\t\tPARAMS ((rtx, rtx, int *));\n+extern void add_clobbers\t\tPARAMS ((rtx, int));\n+extern void insn_extract\t\tPARAMS ((rtx));\n+extern void extract_insn\t\tPARAMS ((rtx));\n+extern void preprocess_constraints\tPARAMS ((void));\n+extern rtx recog_next_insn\t\tPARAMS ((rtx, int));\n+extern void peephole2_optimize\t\tPARAMS ((FILE *));\n+extern rtx peephole2_insns\t\tPARAMS ((rtx, rtx, rtx *));\n \n /* Nonzero means volatile operands are recognized.  */\n extern int volatile_ok;\n@@ -192,10 +192,10 @@ extern struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS][MAX_RECOG_ALT\n /* A table defined in insn-output.c that give information about\n    each insn-code value.  */\n \n-typedef int (*insn_operand_predicate_fn) PROTO ((rtx, enum machine_mode));\n-typedef const char * (*insn_output_fn) PROTO ((rtx *, rtx));\n+typedef int (*insn_operand_predicate_fn) PARAMS ((rtx, enum machine_mode));\n+typedef const char * (*insn_output_fn) PARAMS ((rtx *, rtx));\n #ifndef NO_MD_PROTOTYPES\n-typedef rtx (*insn_gen_fn) PROTO ((rtx, ...));\n+typedef rtx (*insn_gen_fn) PARAMS ((rtx, ...));\n #else\n typedef rtx (*insn_gen_fn) ();\n #endif"}, {"sha": "8780ec64da0f84c52c734134ff8fbf43fcac4907", "filename": "gcc/regclass.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -44,8 +44,8 @@ Boston, MA 02111-1307, USA.  */\n #define REGISTER_MOVE_COST(x, y) 2\n #endif\n \n-static void init_reg_sets_1\tPROTO((void));\n-static void init_reg_modes\tPROTO((void));\n+static void init_reg_sets_1\tPARAMS ((void));\n+static void init_reg_modes\tPARAMS ((void));\n \n /* If we have auto-increment or auto-decrement and we can have secondary\n    reloads, we are not allowed to use classes requiring secondary\n@@ -717,19 +717,19 @@ static struct reg_pref *reg_pref_buffer;\n \n static int loop_cost;\n \n-static rtx scan_one_insn\tPROTO((rtx, int));\n-static void record_operand_costs PROTO((rtx, struct costs *, struct reg_pref *));\n-static void dump_regclass\tPROTO((FILE *));\n-static void record_reg_classes\tPROTO((int, int, rtx *, enum machine_mode *,\n+static rtx scan_one_insn\tPARAMS ((rtx, int));\n+static void record_operand_costs PARAMS ((rtx, struct costs *, struct reg_pref *));\n+static void dump_regclass\tPARAMS ((FILE *));\n+static void record_reg_classes\tPARAMS ((int, int, rtx *, enum machine_mode *,\n \t\t\t\t       char *, const char **, rtx,\n \t\t\t\t       struct costs *, struct reg_pref *));\n-static int copy_cost\t\tPROTO((rtx, enum machine_mode, \n+static int copy_cost\t\tPARAMS ((rtx, enum machine_mode, \n \t\t\t\t       enum reg_class, int));\n-static void record_address_regs\tPROTO((rtx, enum reg_class, int));\n+static void record_address_regs\tPARAMS ((rtx, enum reg_class, int));\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-static int auto_inc_dec_reg_p\tPROTO((rtx, enum machine_mode));\n+static int auto_inc_dec_reg_p\tPARAMS ((rtx, enum machine_mode));\n #endif\n-static void reg_scan_mark_refs\tPROTO((rtx, rtx, int, int));\n+static void reg_scan_mark_refs\tPARAMS ((rtx, rtx, int, int));\n \n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed."}, {"sha": "10b933f28883164fb0251643bf94fc6e553c6fb2", "filename": "gcc/regmove.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -41,11 +41,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"basic-block.h\"\n #include \"toplev.h\"\n \n-static int optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n-static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n-static void optimize_reg_copy_3\tPROTO((rtx, rtx, rtx));\n-static rtx gen_add3_insn\tPROTO((rtx, rtx, rtx));\n-static void copy_src_to_dest\tPROTO((rtx, rtx, rtx, int));\n+static int optimize_reg_copy_1\tPARAMS ((rtx, rtx, rtx));\n+static void optimize_reg_copy_2\tPARAMS ((rtx, rtx, rtx));\n+static void optimize_reg_copy_3\tPARAMS ((rtx, rtx, rtx));\n+static rtx gen_add3_insn\tPARAMS ((rtx, rtx, rtx));\n+static void copy_src_to_dest\tPARAMS ((rtx, rtx, rtx, int));\n static int *regmove_bb_head;\n \n struct match {\n@@ -55,19 +55,19 @@ struct match {\n   int early_clobber[MAX_RECOG_OPERANDS];\n };\n \n-static rtx discover_flags_reg PROTO((void));\n-static void mark_flags_life_zones PROTO((rtx));\n-static void flags_set_1 PROTO((rtx, rtx, void *));\n+static rtx discover_flags_reg PARAMS ((void));\n+static void mark_flags_life_zones PARAMS ((rtx));\n+static void flags_set_1 PARAMS ((rtx, rtx, void *));\n \n-static int try_auto_increment PROTO((rtx, rtx, rtx, rtx, HOST_WIDE_INT, int));\n-static int find_matches PROTO((rtx, struct match *));\n-static int fixup_match_1 PROTO((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n+static int try_auto_increment PARAMS ((rtx, rtx, rtx, rtx, HOST_WIDE_INT, int));\n+static int find_matches PARAMS ((rtx, struct match *));\n+static int fixup_match_1 PARAMS ((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n ;\n-static int reg_is_remote_constant_p PROTO((rtx, rtx, rtx));\n-static int stable_and_no_regs_but_for_p PROTO((rtx, rtx, rtx));\n-static int regclass_compatible_p PROTO((int, int));\n-static int replacement_quality PROTO((rtx));\n-static int fixup_match_2 PROTO((rtx, rtx, rtx, rtx, FILE *));\n+static int reg_is_remote_constant_p PARAMS ((rtx, rtx, rtx));\n+static int stable_and_no_regs_but_for_p PARAMS ((rtx, rtx, rtx));\n+static int regclass_compatible_p PARAMS ((int, int));\n+static int replacement_quality PARAMS ((rtx));\n+static int fixup_match_2 PARAMS ((rtx, rtx, rtx, rtx, FILE *));\n \n /* Return non-zero if registers with CLASS1 and CLASS2 can be merged without\n    causing too much register allocation problems.  */"}, {"sha": "7cd1ab8c46b3dd198050f3932a8ed58abc5b4319", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1353681247458baa6a3df8375b786df8ace7664c/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=1353681247458baa6a3df8375b786df8ace7664c", "patch": "@@ -202,4 +202,4 @@ extern int caller_save_needed;\n #endif\n \n /* Allocate reg_n_info tables */\n-extern void allocate_reg_info PROTO((size_t, int, int));\n+extern void allocate_reg_info PARAMS ((size_t, int, int));"}]}