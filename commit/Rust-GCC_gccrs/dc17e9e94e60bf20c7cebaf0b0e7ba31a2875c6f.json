{"sha": "dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxN2U5ZTk0ZTYwYmYyMGM3Y2ViYWYwYjBlN2JhMzFhMjg3NWM2Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-07T04:32:07Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-07T04:32:07Z"}, "message": "Initial revision\n\nFrom-SVN: r407", "tree": {"sha": "8dbae5d132b72b280a08f1783b66bb32f3d97a54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dbae5d132b72b280a08f1783b66bb32f3d97a54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f/comments", "author": null, "committer": null, "parents": [{"sha": "e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8bbfc4e2344f007bbbb63e02257cce4bba1697c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8bbfc4e2344f007bbbb63e02257cce4bba1697c"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "8ecb9fa27db9e349158f4893dd2b4da64626e411", "filename": "gcc/crtstuff.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=dc17e9e94e60bf20c7cebaf0b0e7ba31a2875c6f", "patch": "@@ -0,0 +1,140 @@\n+/* Specialized bits of code needed to support construction and\n+   destruction of file-scope objects in C++ code.\n+\n+   Written by Ron Guilmette (rfg@ncd.com) with help from Richard Stallman.\n+\n+Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* This file is a bit like libgcc1.c/libgcc2.c in that it is compiled\n+   multiple times and yields multiple .o files.\n+\n+   This file is useful on target machines where the object file format\n+   supports multiple \"user-defined\" sections (e.g. COFF, ELF, ROSE).  On\n+   such systems, this file allows us to avoid running collect (or any\n+   other such slow and painful kludge).  Additionally, if the target\n+   system supports a .init section, this file allows us to support the\n+   linking of C++ code with a non-C++ main program.\n+\n+   Note that if INIT_SECTION_ASM_OP is defined in the tm.h file, then\n+   this file *will* make use of the .init section.  If that symbol is\n+   not defined however, then the .init section will not be used.\n+\n+   Currently, only ELF is actually supported.\n+   The other formats probably need just alternative macro definitions.\n+\n+   This file must be compiled with gcc.  */\n+\n+/* It is incorrect to include config.h here, because this file is being\n+   compiled for the target, and hence definitions concerning only the host\n+   do not apply.  */\n+\n+#include \"tm.h\"\n+\n+#ifndef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"a\\\",@progbits\"\n+#endif\n+#ifndef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"a\\\",@progbits\"\n+#endif\n+\n+#include \"gbl-ctors.h\"\n+\n+#ifndef ON_EXIT\n+#define ON_EXIT(a, b)\n+#endif\n+\n+#ifdef CRT_BEGIN\n+\n+#ifdef INIT_SECTION_ASM_OP\n+\n+/* Force cc1 to switch to .text section.  */\n+static void force_to_text () { }\n+\n+asm (INIT_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n+\n+/* A routine to invoke all of the global constructors upon entry to the\n+   program.  We put this into the .init section (for systems that have\n+   such a thing) so that we can properly perform the construction of\n+   file-scope static-storage C++ objects within shared libraries.   */\n+\n+static void\n+__do_global_ctors ()\t\t/* prologue goes in .init section */\n+{\n+  asm (TEXT_SECTION_ASM_OP);\t/* don't put epilogue and body in .init */\n+  DO_GLOBAL_CTORS_BODY;\n+  ON_EXIT (__do_global_dtors, 0);\n+}\n+\n+#endif /* defined(INIT_SECTION_ASM_OP) */\n+\n+/* Force cc1 to switch to .data section.  */\n+static func_ptr force_to_data[0] = { };\n+\n+/* The -1 is a flag to __do_global_[cd]tors\n+   indicating that this table does not start with a count of elements.  */\n+asm (CTORS_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n+func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) };\n+\n+asm (DTORS_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n+func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };\n+\n+#endif /* defined(CRT_BEGIN) */\n+\n+#ifdef CRT_END\n+\n+#ifdef INIT_SECTION_ASM_OP\n+\n+/* A routine to invoke all of the global constructors upon entry to the\n+   program.  We put this into the .init section (for systems that have\n+   such a thing) so that we can properly perform the construction of\n+   file-scope static-storage C++ objects within shared libraries.\n+\n+   This must be virtually identical to the one above so that we can\n+   insure that the function prologue from the one above works correctly\n+   with the epilogue from this one.  (They will both go into the .init\n+   section as the first and last things (respectively) that the linker\n+   will put in that section.)\n+*/\n+\n+static void\n+__do_global_ctors ()\t\t/* prologue goes in .text section */\n+{\n+  asm (INIT_SECTION_ASM_OP);\n+  DO_GLOBAL_CTORS_BODY;\n+  ON_EXIT (__do_global_dtors, 0);\n+}\t\t\t\t/* epilogue and body go in .init section */\n+\n+#endif /* defined(INIT_SECTION_ASM_OP) */\n+\n+/* Force cc1 to switch to .data section.  */\n+static func_ptr force_to_data[0] = { };\n+\n+asm (CTORS_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n+func_ptr __CTOR_END__[1] = { (func_ptr) 0 };\n+\n+asm (DTORS_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n+func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n+\n+#endif /* defined(CRT_END) */"}]}