{"sha": "be1d3f9370fef7950058801d924fd6e0b1f860e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUxZDNmOTM3MGZlZjc5NTAwNTg4MDFkOTI0ZmQ2ZTBiMWY4NjBlNw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-02-08T12:23:33Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-02-08T12:23:33Z"}, "message": "Fix for PR 18535 - enforce -mlong-calls option\n\nFrom-SVN: r25084", "tree": {"sha": "3a66bf546f4480aecd3a3efe721bc2042dbd42b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a66bf546f4480aecd3a3efe721bc2042dbd42b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be1d3f9370fef7950058801d924fd6e0b1f860e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1d3f9370fef7950058801d924fd6e0b1f860e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1d3f9370fef7950058801d924fd6e0b1f860e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1d3f9370fef7950058801d924fd6e0b1f860e7/comments", "author": null, "committer": null, "parents": [{"sha": "7ff140c597657d58af2d0b41ddab6fd7886a24b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ff140c597657d58af2d0b41ddab6fd7886a24b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ff140c597657d58af2d0b41ddab6fd7886a24b1"}], "stats": {"total": 150, "additions": 124, "deletions": 26}, "files": [{"sha": "1b044b4afc1a4285fae41081559011e0d977a559", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1d3f9370fef7950058801d924fd6e0b1f860e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1d3f9370fef7950058801d924fd6e0b1f860e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be1d3f9370fef7950058801d924fd6e0b1f860e7", "patch": "@@ -1,3 +1,9 @@\n+1999-02-08  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/v850/v850.md: Enforce TARGET_LONG_CALLS option.\n+\t* config/v850/v850.c (construct_restore_jr, construct_save_jarl):\n+\tEnforce TARGET_LONG_CALLS option. \n+\n Mon Feb  8 11:43:07 1999  Donn Terry <donn@interix.com>\n \n \t* real.c (PUT_REAL) [XFmode]: Zero the balance of the structure."}, {"sha": "15867ac48928ff4af3971d6f84ff98df30c3fc74", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1d3f9370fef7950058801d924fd6e0b1f860e7/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1d3f9370fef7950058801d924fd6e0b1f860e7/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=be1d3f9370fef7950058801d924fd6e0b1f860e7", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for NEC V850 series\n-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -2350,11 +2350,26 @@ construct_restore_jr (op)\n      be popping more registers than is strictly necessary, but\n      it does save code space.  */\n   \n-  if (first == last)\n-    sprintf (buff, \"jr __return_%s\", reg_names [first]);\n+  if (TARGET_LONG_CALLS)\n+    {\n+      char name[40];\n+      \n+      if (first == last)\n+\tsprintf (name, \"__return_%s\", reg_names [first]);\n+      else\n+\tsprintf (name, \"__return_%s_%s\", reg_names [first], reg_names [last]);\n+      \n+      sprintf (buff, \"movhi hi(%s), r0, r6\\n\\tmovea lo(%s), r6, r6\\n\\tjmp r6\",\n+\t       name, name);\n+    }\n   else\n-    sprintf (buff, \"jr __return_%s_%s\", reg_names [first], reg_names [last]);\n-\n+    {\n+      if (first == last)\n+\tsprintf (buff, \"jr __return_%s\", reg_names [first]);\n+      else\n+\tsprintf (buff, \"jr __return_%s_%s\", reg_names [first], reg_names [last]);\n+    }\n+  \n   return buff;\n }\n \n@@ -2536,11 +2551,26 @@ construct_save_jarl (op)\n      be pushing more registers than is strictly necessary, but\n      it does save code space.  */\n   \n-  if (first == last)\n-    sprintf (buff, \"jarl __save_%s, r10\", reg_names [first]);\n+  if (TARGET_LONG_CALLS)\n+    {\n+      char name[40];\n+      \n+      if (first == last)\n+\tsprintf (name, \"__save_%s\", reg_names [first]);\n+      else\n+\tsprintf (name, \"__save_%s_%s\", reg_names [first], reg_names [last]);\n+      \n+      sprintf (buff, \"movhi hi(%s), r0, r11\\n\\tmovea lo(%s), r11, r11\\n\\tjarl .+4, r10\\n\\tadd 4, r10\\n\\tjmp r11\",\n+\t       name, name);\n+    }\n   else\n-    sprintf (buff, \"jarl __save_%s_%s, r10\", reg_names [first],\n-\t     reg_names [last]);\n+    {\n+      if (first == last)\n+\tsprintf (buff, \"jarl __save_%s, r10\", reg_names [first]);\n+      else\n+\tsprintf (buff, \"jarl __save_%s_%s, r10\", reg_names [first],\n+\t\t reg_names [last]);\n+    }\n \n   return buff;\n }"}, {"sha": "daea8b731c4e3fd1df8d038fb052dce66a813f7c", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1d3f9370fef7950058801d924fd6e0b1f860e7/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1d3f9370fef7950058801d924fd6e0b1f860e7/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=be1d3f9370fef7950058801d924fd6e0b1f860e7", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for NEC V850\n-;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+;; Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.\n \n ;;   Contributed by Jeff Law (law@cygnus.com).\n \n@@ -36,6 +36,11 @@\n (define_attr \"length\" \"\"\n   (const_int 200))\n \n+(define_attr \"long_calls\" \"yes,no\"\n+  (const (if_then_else (symbol_ref \"TARGET_LONG_CALLS\")\n+\t\t       (const_string \"yes\")\n+\t\t       (const_string \"no\"))))\n+\t    \n ;; Types of instructions (for scheduling purposes).\n \n (define_attr \"type\" \"load,mult,other\"\n@@ -969,19 +974,44 @@\n   if (! call_address_operand (XEXP (operands[0], 0))\n       || TARGET_LONG_CALLS)\n     XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));\n-  emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));\n+  if (TARGET_LONG_CALLS)\n+    emit_call_insn (gen_call_internal_long (XEXP (operands[0], 0), operands[1]));\n+  else\n+    emit_call_insn (gen_call_internal_short (XEXP (operands[0], 0), operands[1]));\n+  \n   DONE;\n }\")\n \n-(define_insn \"call_internal\"\n+(define_insn \"call_internal_short\"\n   [(call (mem:QI (match_operand:SI 0 \"call_address_operand\" \"S,r\"))\n \t (match_operand:SI 1 \"general_operand\" \"g,g\"))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"! TARGET_LONG_CALLS\"\n   \"@\n   jarl %0,r31\n   jarl .+4,r31\\\\n\\\\tadd 4,r31\\\\n\\\\tjmp %0\"\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"length\" \"4,8\")]\n+)\n+\n+(define_insn \"call_internal_long\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_address_operand\" \"S,r\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g,g\"))\n+   (clobber (reg:SI 31))]\n+  \"TARGET_LONG_CALLS\"\n+  \"*\n+  {\n+  if (which_alternative == 0)\n+    {\n+      if (GET_CODE (operands[0]) == REG)\n+        return \\\"jarl %0,r31\\\";\n+      else\n+        return \\\"movhi hi(%0), r0, r11\\\\n\\\\tmovea lo(%0), r11, r11\\\\n\\\\tjarl .+4,r31\\\\n\\\\tadd 4, r31\\\\n\\\\tjmp r11\\\";\n+    }\n+  else\n+    return \\\"jarl .+4,r31\\\\n\\\\tadd 4,r31\\\\n\\\\tjmp %0\\\";\n+  }\"\n+  [(set_attr \"length\" \"16,8\")]\n+)\n \n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n@@ -996,22 +1026,50 @@\n   if (! call_address_operand (XEXP (operands[1], 0))\n       || TARGET_LONG_CALLS)\n     XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));\n-  emit_call_insn (gen_call_value_internal (operands[0],\n-\t\t\t\t\t   XEXP (operands[1], 0),\n-\t\t\t\t\t   operands[2]));\n+  if (TARGET_LONG_CALLS)\n+    emit_call_insn (gen_call_value_internal_long (operands[0],\n+\t \t\t\t\t          XEXP (operands[1], 0),\n+\t\t\t\t\t          operands[2]));\n+  else\n+    emit_call_insn (gen_call_value_internal_short (operands[0],\n+\t \t\t\t\t           XEXP (operands[1], 0),\n+\t\t\t\t\t           operands[2]));\n   DONE;\n }\")\n \n-(define_insn \"call_value_internal\"\n+(define_insn \"call_value_internal_short\"\n   [(set (match_operand 0 \"\" \"=r,r\")\n \t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"S,r\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g,g\")))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"! TARGET_LONG_CALLS\"\n   \"@\n   jarl %1,r31\n   jarl .+4,r31\\\\n\\\\tadd 4,r31\\\\n\\\\tjmp %1\"\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"length\" \"4,8\")]\n+)\n+\n+(define_insn \"call_value_internal_long\"\n+  [(set (match_operand 0 \"\" \"=r,r\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"S,r\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g,g\")))\n+   (clobber (reg:SI 31))]\n+  \"TARGET_LONG_CALLS\"\n+  \"*\n+  {\n+  if (which_alternative == 0)\n+    {\n+      if (GET_CODE (operands[1]) == REG)\n+        return \\\"jarl %1, r31\\\";\n+      else\n+      /* Reload can generate this pattern... */\n+        return \\\"movhi hi(%1), r0, r11\\\\n\\\\tmovea lo(%1), r11, r11\\\\n\\\\tjarl .+4, r31\\\\n\\\\tadd 4, r31\\\\n\\\\tjmp r11\\\";\n+    }\n+  else\n+    return \\\"jarl .+4, r31\\\\n\\\\tadd 4, r31\\\\n\\\\tjmp %1\\\";\n+  }\"\n+  [(set_attr \"length\" \"16,8\")]\n+)\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -1180,7 +1238,9 @@\n  \"TARGET_PROLOG_FUNCTION\"\n  \"* return construct_save_jarl (operands[0]);\n  \"\n- [(set_attr \"length\" \"4\")\n+ [(set (attr \"length\") (if_then_else (eq_attr \"long_calls\" \"yes\")\n+\t\t\t\t     (const_string \"16\")\n+\t\t\t\t     (const_string \"4\")))\n   (set_attr \"cc\"     \"clobber\")])\n \n ;; This pattern will match a return RTX followed by any number of pop RTXs\n@@ -1198,7 +1258,9 @@\n  \"TARGET_PROLOG_FUNCTION && TARGET_V850\"\n  \"* return construct_restore_jr (operands[0]);\n  \"\n- [(set_attr \"length\" \"4\")\n+ [(set (attr \"length\") (if_then_else (eq_attr \"long_calls\" \"yes\")\n+\t\t\t\t     (const_string \"12\")\n+\t\t\t\t     (const_string \"4\")))\n   (set_attr \"cc\"     \"clobber\")])\n \n ;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n@@ -1208,7 +1270,7 @@\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 10))\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 4))\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 1))]\n-  \"TARGET_V850\"\n+  \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n   \"add -16,sp\\;st.w r10,12[sp]\\;jarl __save_interrupt,r10\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -1236,7 +1298,7 @@\n \n (define_insn \"save_all_interrupt\"\n   [(unspec_volatile [(const_int 0)] 0)]\n-  \"TARGET_V850\"\n+  \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n   \"jarl __save_all_interrupt,r10\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -1250,7 +1312,7 @@\n \n (define_insn \"restore_all_interrupt\"\n   [(unspec_volatile [(const_int 0)] 1)]\n-  \"TARGET_V850\"\n+  \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n   \"jarl __restore_all_interrupt,r10\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -1262,7 +1324,7 @@\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int 8))) (reg:SI 8))\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int 12))) (reg:SI 9))\n    (clobber (reg:SI 10))]\n-  \"TARGET_PROLOG_FUNCTION\"\n+  \"TARGET_PROLOG_FUNCTION && ! TARGET_LONG_CALLS\"\n   \"jarl __save_r6_r9,r10\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])"}]}