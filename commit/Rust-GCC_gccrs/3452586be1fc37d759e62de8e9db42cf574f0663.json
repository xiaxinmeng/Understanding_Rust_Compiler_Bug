{"sha": "3452586be1fc37d759e62de8e9db42cf574f0663", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1MjU4NmJlMWZjMzdkNzU5ZTYyZGU4ZTlkYjQyY2Y1NzRmMDY2Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-09-22T15:16:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-09-22T15:16:49Z"}, "message": "re PR target/41246 (should \"sorry\" when regparm=3 and nested functions are encountered)\n\n\tPR target/41246\n\t* config/i386/i386.c (ix86_function_regparm): Do not issue an\n\terror for nested functions with regparm=3.\n\t(ix86_compute_frame_layout): Adjust frame pointer offset for\n\tix86_static_chain_on_stack.\n\t(ix86_expand_prologue): Handle ix86_static_chain_on_stack.\n\t(ix86_emit_restore_reg_using_pop): Increment ix86_cfa_state->offset,\n\tdon't reset to UNITS_PER_WORD.\n\t(ix86_emit_leave): Adjust ix86_cfa_state.\n\t(ix86_expand_epilogue): Handle ix86_static_chain_on_stack.\n\t(ix86_static_chain): New.\n\t(ix86_trampoline_init): Rename from x86_initialize_trampoline;\n\tmake static; update for target hook parameters; use ix86_static_chain.\n\t(TARGET_STATIC_CHAIN, TARGET_TRAMPOLINE_INIT): New.\n\t* config/i386/i386.h (STATIC_CHAIN_REGNUM): Remove.\n\t(INITIALIZE_TRAMPOLINE): Remove.\n\t(TRAMPOLINE_SIZE): Use 24 for 64-bit.\n\t(struct machine_function): Use BOOL_BITFIELD; rearrange bitfields\n\tto the end.  Add static_chain_on_stack.\n\t(ix86_static_chain_on_stack): New.\n\nFrom-SVN: r152018", "tree": {"sha": "d7ed31230832c3072e574e4ad2c28ef2af15c05f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7ed31230832c3072e574e4ad2c28ef2af15c05f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3452586be1fc37d759e62de8e9db42cf574f0663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3452586be1fc37d759e62de8e9db42cf574f0663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3452586be1fc37d759e62de8e9db42cf574f0663", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3452586be1fc37d759e62de8e9db42cf574f0663/comments", "author": null, "committer": null, "parents": [{"sha": "3c1229cb545da35578b7df31316b0e60377054d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c1229cb545da35578b7df31316b0e60377054d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c1229cb545da35578b7df31316b0e60377054d4"}], "stats": {"total": 363, "additions": 265, "deletions": 98}, "files": [{"sha": "9a9a00517a4284dea5f44051a25a409738b4ec3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3452586be1fc37d759e62de8e9db42cf574f0663/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3452586be1fc37d759e62de8e9db42cf574f0663/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3452586be1fc37d759e62de8e9db42cf574f0663", "patch": "@@ -302,6 +302,26 @@\n \t* config/xtensa/xtensa.h (TRAMPOLINE_TEMPLATE): Remove.\n \t(INITIALIZE_TRAMPOLINE): Remove.\n \n+\t* config/i386/i386.c (ix86_function_regparm): Do not issue an\n+\terror for nested functions with regparm=3.\n+\t(ix86_compute_frame_layout): Adjust frame pointer offset for\n+\tix86_static_chain_on_stack.\n+\t(ix86_expand_prologue): Handle ix86_static_chain_on_stack.\n+\t(ix86_emit_restore_reg_using_pop): Increment ix86_cfa_state->offset,\n+\tdon't reset to UNITS_PER_WORD.\n+\t(ix86_emit_leave): Adjust ix86_cfa_state.\n+\t(ix86_expand_epilogue): Handle ix86_static_chain_on_stack.\n+\t(ix86_static_chain): New.\n+\t(ix86_trampoline_init): Rename from x86_initialize_trampoline;\n+\tmake static; update for target hook parameters; use ix86_static_chain.\n+\t(TARGET_STATIC_CHAIN, TARGET_TRAMPOLINE_INIT): New.\n+\t* config/i386/i386.h (STATIC_CHAIN_REGNUM): Remove.\n+\t(INITIALIZE_TRAMPOLINE): Remove.\n+\t(TRAMPOLINE_SIZE): Use 24 for 64-bit.\n+\t(struct machine_function): Use BOOL_BITFIELD; rearrange bitfields\n+\tto the end.  Add static_chain_on_stack.\n+\t(ix86_static_chain_on_stack): New.\n+\n 2009-09-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/rs6000/rs6000.c (bdesc_2arg): Fix CODE_FOR_vector_gt* codes"}, {"sha": "bda1c5f3507c8e8270718879eb6199a71c66138d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 218, "deletions": 74, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3452586be1fc37d759e62de8e9db42cf574f0663/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3452586be1fc37d759e62de8e9db42cf574f0663/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3452586be1fc37d759e62de8e9db42cf574f0663", "patch": "@@ -1879,6 +1879,7 @@ static bool ext_80387_constants_init = 0;\n \f\n static struct machine_function * ix86_init_machine_status (void);\n static rtx ix86_function_value (const_tree, const_tree, bool);\n+static rtx ix86_static_chain (const_tree, bool);\n static int ix86_function_regparm (const_tree, const_tree);\n static void ix86_compute_frame_layout (struct ix86_frame *);\n static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n@@ -4472,8 +4473,6 @@ ix86_function_regparm (const_tree type, const_tree decl)\n   tree attr;\n   int regparm;\n \n-  static bool error_issued;\n-\n   if (TARGET_64BIT)\n     return (ix86_function_type_abi (type) == SYSV_ABI\n \t    ? X86_64_REGPARM_MAX : X86_64_MS_REGPARM_MAX);\n@@ -4482,23 +4481,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n   attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n   if (attr)\n     {\n-      regparm\n-\t= TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n-\n-      if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  /* We can't use regparm(3) for nested functions because\n-\t     these pass static chain pointer in %ecx register.  */\n-\t  if (!error_issued && regparm == 3\n-\t      && decl_function_context (decl)\n-\t      && !DECL_NO_STATIC_CHAIN (decl))\n-\t    {\n-\t      error (\"nested functions are limited to 2 register parameters\");\n-\t      error_issued = true;\n-\t      return 0;\n-\t    }\n-\t}\n-\n+      regparm = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n       return regparm;\n     }\n \n@@ -4512,7 +4495,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n       && !profile_flag)\n     {\n       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n-      struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));\n+      struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE (decl));\n       if (i && i->local)\n \t{\n \t  int local_regparm, globals = 0, regno;\n@@ -4523,8 +4506,8 @@ ix86_function_regparm (const_tree type, const_tree decl)\n \t    if (fixed_regs[local_regparm])\n \t      break;\n \n-\t  /* We can't use regparm(3) for nested functions as these use\n-\t     static chain pointer in third argument.  */\n+\t  /* We don't want to use regparm(3) for nested functions as\n+\t     these use a static chain pointer in the third argument.  */\n \t  if (local_regparm == 3\n \t      && decl_function_context (decl)\n \t      && !DECL_NO_STATIC_CHAIN (decl))\n@@ -7873,9 +7856,16 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   else\n     frame->save_regs_using_mov = false;\n \n+  /* Skip return address.  */\n+  offset = UNITS_PER_WORD;\n \n-  /* Skip return address and saved base pointer.  */\n-  offset = frame_pointer_needed ? UNITS_PER_WORD * 2 : UNITS_PER_WORD;\n+  /* Skip pushed static chain.  */\n+  if (ix86_static_chain_on_stack)\n+    offset += UNITS_PER_WORD;\n+\n+  /* Skip saved base pointer.  */\n+  if (frame_pointer_needed)\n+    offset += UNITS_PER_WORD;\n \n   frame->hard_frame_pointer_offset = offset;\n \n@@ -8297,20 +8287,42 @@ ix86_expand_prologue (void)\n \n   ix86_compute_frame_layout (&frame);\n \n+  /* The first insn of a function that accepts its static chain on the\n+     stack is to push the register that would be filled in by a direct\n+     call.  This insn will be skipped by the trampoline.  */\n+  if (ix86_static_chain_on_stack)\n+    {\n+      rtx t;\n+\n+      insn = emit_insn (gen_push (ix86_static_chain (cfun->decl, false)));\n+      emit_insn (gen_blockage ());\n+\n+      /* We don't want to interpret this push insn as a register save,\n+\t only as a stack adjustment.  The real copy of the register as\n+\t a save will be done later, if needed.  */\n+      t = plus_constant (stack_pointer_rtx, -UNITS_PER_WORD);\n+      t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, t);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n   /* Emit prologue code to adjust stack alignment and setup DRAP, in case\n      of DRAP is needed and stack realignment is really needed after reload */\n   if (crtl->drap_reg && crtl->stack_realign_needed)\n     {\n       rtx x, y;\n       int align_bytes = crtl->stack_alignment_needed / BITS_PER_UNIT;\n-      int param_ptr_offset = (call_used_regs[REGNO (crtl->drap_reg)]\n-\t\t\t      ? 0 : UNITS_PER_WORD);\n+      int param_ptr_offset = UNITS_PER_WORD;\n+\n+      if (ix86_static_chain_on_stack)\n+\tparam_ptr_offset += UNITS_PER_WORD;\n+      if (!call_used_regs[REGNO (crtl->drap_reg)])\n+\tparam_ptr_offset += UNITS_PER_WORD;\n \n       gcc_assert (stack_realign_drap);\n \n       /* Grab the argument pointer.  */\n-      x = plus_constant (stack_pointer_rtx, \n-                         (UNITS_PER_WORD + param_ptr_offset));\n+      x = plus_constant (stack_pointer_rtx, param_ptr_offset);\n       y = crtl->drap_reg;\n \n       /* Only need to push parameter pointer reg if it is caller\n@@ -8519,14 +8531,18 @@ ix86_expand_prologue (void)\n       /* vDRAP is setup but after reload it turns out stack realign\n          isn't necessary, here we will emit prologue to setup DRAP\n          without stack realign adjustment */\n+      rtx x;\n       int drap_bp_offset = UNITS_PER_WORD * 2;\n-      rtx x = plus_constant (hard_frame_pointer_rtx, drap_bp_offset);\n+\n+      if (ix86_static_chain_on_stack)\n+\tdrap_bp_offset += UNITS_PER_WORD;\n+      x = plus_constant (hard_frame_pointer_rtx, drap_bp_offset);\n       insn = emit_insn (gen_rtx_SET (VOIDmode, crtl->drap_reg, x));\n     }\n \n   /* Prevent instructions from being scheduled into register save push\n      sequence when access to the redzone area is done through frame pointer.\n-     The offset betweeh the frame pointer and the stack pointer is calculated\n+     The offset between the frame pointer and the stack pointer is calculated\n      relative to the value of the stack pointer at the end of the function\n      prologue, and moving instructions that access redzone area via frame\n      pointer inside push sequence violates this assumption.  */\n@@ -8575,11 +8591,11 @@ ix86_emit_restore_reg_using_pop (rtx reg, HOST_WIDE_INT red_offset)\n \t   && reg == hard_frame_pointer_rtx)\n     {\n       ix86_cfa_state->reg = stack_pointer_rtx;\n-      ix86_cfa_state->offset = UNITS_PER_WORD;\n+      ix86_cfa_state->offset -= UNITS_PER_WORD;\n \n       add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t    gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (UNITS_PER_WORD)));\n+\t\t\t\t  GEN_INT (ix86_cfa_state->offset)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -8613,6 +8629,9 @@ ix86_emit_leave (HOST_WIDE_INT red_offset)\n \n   if (ix86_cfa_state->reg == hard_frame_pointer_rtx)\n     {\n+      ix86_cfa_state->reg = stack_pointer_rtx;\n+      ix86_cfa_state->offset -= UNITS_PER_WORD;\n+\n       add_reg_note (insn, REG_CFA_ADJUST_CFA, \n \t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 0)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -8757,6 +8776,8 @@ ix86_expand_epilogue (int style)\n   else if (stack_realign_fp)\n     red_offset -= crtl->stack_alignment_needed / BITS_PER_UNIT\n \t\t  - UNITS_PER_WORD;\n+  if (ix86_static_chain_on_stack)\n+    red_offset -= UNITS_PER_WORD;\n   if (frame_pointer_needed)\n     red_offset -= UNITS_PER_WORD;\n \n@@ -8829,6 +8850,8 @@ ix86_expand_epilogue (int style)\n \n \t  /* Stack align doesn't work with eh_return.  */\n \t  gcc_assert (!crtl->stack_realign_needed);\n+\t  /* Neither does regparm nested functions.  */\n+\t  gcc_assert (!ix86_static_chain_on_stack);\n \n \t  if (frame_pointer_needed)\n \t    {\n@@ -8961,29 +8984,50 @@ ix86_expand_epilogue (int style)\n \n   if (using_drap)\n     {\n-      int param_ptr_offset = (call_used_regs[REGNO (crtl->drap_reg)]\n-\t\t\t      ? 0 : UNITS_PER_WORD);\n+      int param_ptr_offset = UNITS_PER_WORD;\n       rtx insn;\n \n       gcc_assert (stack_realign_drap);\n \n+      if (ix86_static_chain_on_stack)\n+\tparam_ptr_offset += UNITS_PER_WORD;\n+      if (!call_used_regs[REGNO (crtl->drap_reg)])\n+\tparam_ptr_offset += UNITS_PER_WORD;\n+\n       insn = emit_insn ((*ix86_gen_add3) (stack_pointer_rtx,\n \t\t\t\t\t  crtl->drap_reg,\n-\t\t\t\t\t  GEN_INT (-(UNITS_PER_WORD\n-\t\t\t\t\t\t     + param_ptr_offset))));\n+\t\t\t\t\t  GEN_INT (-param_ptr_offset)));\n \n       ix86_cfa_state->reg = stack_pointer_rtx;\n-      ix86_cfa_state->offset = UNITS_PER_WORD + param_ptr_offset;\n+      ix86_cfa_state->offset = param_ptr_offset;\n \n       add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t    gen_rtx_PLUS (Pmode, ix86_cfa_state->reg,\n \t\t\t\t  GEN_INT (ix86_cfa_state->offset)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      if (param_ptr_offset)\n+      if (!call_used_regs[REGNO (crtl->drap_reg)])\n \tix86_emit_restore_reg_using_pop (crtl->drap_reg, -UNITS_PER_WORD);\n     }\n \n+  /* Remove the saved static chain from the stack.  The use of ECX is\n+     merely as a scratch register, not as the actual static chain.  */\n+  if (ix86_static_chain_on_stack)\n+    {\n+      rtx r, insn;\n+\n+      gcc_assert (ix86_cfa_state->reg == stack_pointer_rtx);\n+      ix86_cfa_state->offset += UNITS_PER_WORD;\n+    \n+      r = gen_rtx_REG (Pmode, CX_REG);\n+      insn = emit_insn (ix86_gen_pop1 (r));\n+\n+      r = plus_constant (stack_pointer_rtx, UNITS_PER_WORD);\n+      r = gen_rtx_SET (VOIDmode, stack_pointer_rtx, r);\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, r);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n   /* Sibcall epilogues don't want a return instruction.  */\n   if (style == 0)\n     {\n@@ -19759,66 +19803,162 @@ ix86_minimum_alignment (tree exp, enum machine_mode mode,\n   return align;\n }\n \f\n+/* Find a location for the static chain incoming to a nested function.\n+   This is a register, unless all free registers are used by arguments.  */\n+\n+static rtx\n+ix86_static_chain (const_tree fndecl, bool incoming_p)\n+{\n+  unsigned regno;\n+\n+  if (DECL_NO_STATIC_CHAIN (fndecl))\n+    return NULL;\n+\n+  if (TARGET_64BIT)\n+    {\n+      /* We always use R10 in 64-bit mode.  */\n+      regno = R10_REG;\n+    }\n+  else\n+    {\n+      tree fntype;\n+      /* By default in 32-bit mode we use ECX to pass the static chain.  */\n+      regno = CX_REG;\n+\n+      fntype = TREE_TYPE (fndecl);\n+      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (fntype)))\n+\t{\n+\t  /* Fastcall functions use ecx/edx for arguments, which leaves\n+\t     us with EAX for the static chain.  */\n+\t  regno = AX_REG;\n+\t}\n+      else if (ix86_function_regparm (fntype, fndecl) == 3)\n+\t{\n+\t  /* For regparm 3, we have no free call-clobbered registers in\n+\t     which to store the static chain.  In order to implement this,\n+\t     we have the trampoline push the static chain to the stack.\n+\t     However, we can't push a value below the return address when\n+\t     we call the nested function directly, so we have to use an\n+\t     alternate entry point.  For this we use ESI, and have the\n+\t     alternate entry point push ESI, so that things appear the\n+\t     same once we're executing the nested function.  */\n+\t  if (incoming_p)\n+\t    {\n+\t      if (fndecl == current_function_decl)\n+\t\tix86_static_chain_on_stack = true;\n+\t      return gen_frame_mem (SImode,\n+\t\t\t\t    plus_constant (arg_pointer_rtx, -8));\n+\t    }\n+\t  regno = SI_REG;\n+\t}\n+    }\n+\n+  return gen_rtx_REG (Pmode, regno);\n+}\n+\n /* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-void\n-x86_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n+   FNDECL is the decl of the target address; M_TRAMP is a MEM for \n+   the trampoline, and CHAIN_VALUE is an RTX for the static chain\n+   to be passed to the target function.  */\n+\n+static void\n+ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n+  rtx mem, fnaddr;\n+\n+  fnaddr = XEXP (DECL_RTL (fndecl), 0);\n+\n   if (!TARGET_64BIT)\n     {\n-      /* Compute offset from the end of the jmp to the target function.  */\n-      rtx disp = expand_binop (SImode, sub_optab, fnaddr,\n-\t\t\t       plus_constant (tramp, 10),\n-\t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n-      emit_move_insn (gen_rtx_MEM (QImode, tramp),\n-\t\t      gen_int_mode (0xb9, QImode));\n-      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 1)), cxt);\n-      emit_move_insn (gen_rtx_MEM (QImode, plus_constant (tramp, 5)),\n-\t\t      gen_int_mode (0xe9, QImode));\n-      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 6)), disp);\n+      rtx disp, chain;\n+      int opcode;\n+\n+      /* Depending on the static chain location, either load a register\n+\t with a constant, or push the constant to the stack.  All of the\n+\t instructions are the same size.  */\n+      chain = ix86_static_chain (fndecl, true);\n+      if (REG_P (chain))\n+\t{\n+\t  if (REGNO (chain) == CX_REG)\n+\t    opcode = 0xb9;\n+\t  else if (REGNO (chain) == AX_REG)\n+\t    opcode = 0xb8;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+      else\n+\topcode = 0x68;\n+\n+      mem = adjust_address (m_tramp, QImode, 0);\n+      emit_move_insn (mem, gen_int_mode (opcode, QImode));\n+\n+      mem = adjust_address (m_tramp, SImode, 1);\n+      emit_move_insn (mem, chain_value);\n+\n+      /* Compute offset from the end of the jmp to the target function.\n+\t In the case in which the trampoline stores the static chain on\n+\t the stack, we need to skip the first insn which pushes the\n+\t (call-saved) register static chain; this push is 1 byte.  */\n+      disp = expand_binop (SImode, sub_optab, fnaddr,\n+\t\t\t   plus_constant (XEXP (m_tramp, 0),\n+\t\t\t\t\t  MEM_P (chain) ? 9 : 10),\n+\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n+\n+      mem = adjust_address (m_tramp, QImode, 5);\n+      emit_move_insn (mem, gen_int_mode (0xe9, QImode));\n+\n+      mem = adjust_address (m_tramp, SImode, 6);\n+      emit_move_insn (mem, disp);\n     }\n   else\n     {\n       int offset = 0;\n-      /* Try to load address using shorter movl instead of movabs.\n-         We may want to support movq for kernel mode, but kernel does not use\n-         trampolines at the moment.  */\n+\n+      /* Load the function address to r11.  Try to load address using\n+\t the shorter movl instead of movabs.  We may want to support\n+\t movq for kernel mode, but kernel does not use trampolines at\n+\t the moment.  */\n       if (x86_64_zext_immediate_operand (fnaddr, VOIDmode))\n \t{\n \t  fnaddr = copy_to_mode_reg (DImode, fnaddr);\n-\t  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t\t  gen_int_mode (0xbb41, HImode));\n-\t  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, offset + 2)),\n-\t\t\t  gen_lowpart (SImode, fnaddr));\n+\n+\t  mem = adjust_address (m_tramp, HImode, offset);\n+\t  emit_move_insn (mem, gen_int_mode (0xbb41, HImode));\n+\n+\t  mem = adjust_address (m_tramp, SImode, offset + 2);\n+\t  emit_move_insn (mem, gen_lowpart (SImode, fnaddr));\n \t  offset += 6;\n \t}\n       else\n \t{\n-\t  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t\t  gen_int_mode (0xbb49, HImode));\n-\t  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, offset + 2)),\n-\t\t\t  fnaddr);\n+\t  mem = adjust_address (m_tramp, HImode, offset);\n+\t  emit_move_insn (mem, gen_int_mode (0xbb49, HImode));\n+\n+\t  mem = adjust_address (m_tramp, DImode, offset + 2);\n+\t  emit_move_insn (mem, fnaddr);\n \t  offset += 10;\n \t}\n+\n       /* Load static chain using movabs to r10.  */\n-      emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t      gen_int_mode (0xba49, HImode));\n-      emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, offset + 2)),\n-\t\t      cxt);\n+      mem = adjust_address (m_tramp, HImode, offset);\n+      emit_move_insn (mem, gen_int_mode (0xba49, HImode));\n+\n+      mem = adjust_address (m_tramp, DImode, offset + 2);\n+      emit_move_insn (mem, chain_value);\n       offset += 10;\n-      /* Jump to the r11 */\n-      emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t      gen_int_mode (0xff49, HImode));\n-      emit_move_insn (gen_rtx_MEM (QImode, plus_constant (tramp, offset+2)),\n-\t\t      gen_int_mode (0xe3, QImode));\n-      offset += 3;\n+\n+      /* Jump to r11; the last (unused) byte is a nop, only there to\n+\t pad the write out to a single 32-bit store.  */\n+      mem = adjust_address (m_tramp, SImode, offset);\n+      emit_move_insn (mem, gen_int_mode (0x90e3ff49, SImode));\n+      offset += 4;\n+\n       gcc_assert (offset <= TRAMPOLINE_SIZE);\n     }\n \n #ifdef ENABLE_EXECUTE_STACK\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n-\t\t     LCT_NORMAL, VOIDmode, 1, tramp, Pmode);\n+\t\t     LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);\n #endif\n }\n \f\n@@ -29229,6 +29369,10 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #define TARGET_GET_DRAP_RTX ix86_get_drap_rtx\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n+#undef TARGET_STATIC_CHAIN\n+#define TARGET_STATIC_CHAIN ix86_static_chain\n+#undef TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT ix86_trampoline_init\n \n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg"}, {"sha": "f825948048ac904afcac03db0e0f380e6dbfd645", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3452586be1fc37d759e62de8e9db42cf574f0663/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3452586be1fc37d759e62de8e9db42cf574f0663/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3452586be1fc37d759e62de8e9db42cf574f0663", "patch": "@@ -1131,11 +1131,6 @@ enum target_cpu_default\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 16\n \n-/* Register in which static-chain is passed to a function.\n-   We do use ECX as static chain register for 32 bit ABI.  On the\n-   64bit ABI, ECX is an argument register, so we use R10 instead.  */\n-#define STATIC_CHAIN_REGNUM (TARGET_64BIT ? R10_REG : CX_REG)\n-\n /* Register to hold the addressing base for position independent\n    code access to data items.  We don't use PIC pointer for 64bit\n    mode.  Define the regnum to dummy value to prevent gcc from\n@@ -1659,14 +1654,7 @@ typedef struct ix86_args {\n \n /* Length in units of the trampoline for entering a nested function.  */\n \n-#define TRAMPOLINE_SIZE (TARGET_64BIT ? 23 : 10)\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n-  x86_initialize_trampoline ((TRAMP), (FNADDR), (CXT))\n+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 24 : 10)\n \f\n /* Definitions for register eliminations.\n \n@@ -2365,15 +2353,29 @@ struct GTY(()) machine_function {\n   const char *some_ld_name;\n   int varargs_gpr_size;\n   int varargs_fpr_size;\n-  int accesses_prev_frame;\n   int optimize_mode_switching[MAX_386_ENTITIES];\n-  int needs_cld;\n+\n+  /* Number of saved registers USE_FAST_PROLOGUE_EPILOGUE\n+     has been computed for.  */\n+  int use_fast_prologue_epilogue_nregs;\n+\n+  /* The CFA state at the end of the prologue.  */\n+  struct machine_cfa_state cfa;\n+\n+  /* This value is used for amd64 targets and specifies the current abi\n+     to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */\n+  enum calling_abi call_abi;\n+\n+  /* Nonzero if the function accesses a previous frame.  */\n+  BOOL_BITFIELD accesses_prev_frame : 1;\n+\n+  /* Nonzero if the function requires a CLD in the prologue.  */\n+  BOOL_BITFIELD needs_cld : 1;\n+\n   /* Set by ix86_compute_frame_layout and used by prologue/epilogue\n      expander to determine the style used.  */\n-  int use_fast_prologue_epilogue;\n-  /* Number of saved registers USE_FAST_PROLOGUE_EPILOGUE has been computed\n-     for.  */\n-  int use_fast_prologue_epilogue_nregs;\n+  BOOL_BITFIELD use_fast_prologue_epilogue : 1;\n+\n   /* If true, the current function needs the default PIC register, not\n      an alternate register (on x86) and must not use the red zone (on\n      x86_64), even if it's a leaf function.  We don't want the\n@@ -2383,11 +2385,11 @@ struct GTY(()) machine_function {\n      if all such instructions are optimized away.  Use the\n      ix86_current_function_calls_tls_descriptor macro for a better\n      approximation.  */\n-  int tls_descriptor_call_expanded_p;\n-  /* This value is used for amd64 targets and specifies the current abi\n-     to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */\n-  enum calling_abi call_abi;\n-  struct machine_cfa_state cfa;\n+  BOOL_BITFIELD tls_descriptor_call_expanded_p : 1;\n+\n+  /* If true, the current function has a STATIC_CHAIN is placed on the\n+     stack below the return address.  */\n+  BOOL_BITFIELD static_chain_on_stack : 1;\n };\n #endif\n \n@@ -2406,6 +2408,7 @@ struct GTY(()) machine_function {\n #define ix86_current_function_calls_tls_descriptor \\\n   (ix86_tls_descriptor_calls_expanded_in_cfun && df_regs_ever_live_p (SP_REG))\n #define ix86_cfa_state (&cfun->machine->cfa)\n+#define ix86_static_chain_on_stack (cfun->machine->static_chain_on_stack)\n \n /* Control behavior of x86_file_start.  */\n #define X86_FILE_START_VERSION_DIRECTIVE false"}]}