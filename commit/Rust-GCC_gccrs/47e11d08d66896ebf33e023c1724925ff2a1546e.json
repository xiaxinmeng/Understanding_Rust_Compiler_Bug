{"sha": "47e11d08d66896ebf33e023c1724925ff2a1546e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdlMTFkMDhkNjY4OTZlYmYzM2UwMjNjMTcyNDkyNWZmMmExNTQ2ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-01T10:27:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-01T10:27:49Z"}, "message": "[multiple changes]\n\n2011-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.ads: Minor comment fix.\n\t* a-stwifi.adb, a-stzfix.adb, a-strfix.adb, a-ztexio.ads, a-textio.ads,\n\ta-witeio.ads, sem_prag.adb: Minor reformatting.\n\n2011-08-01  Doug Rupp  <rupp@adacore.com>\n\n\t* env.c (__gnat_setenv) [VMS]: Force 32bit on item list structure\n\tpointers. Use descrip.h header file for convenience. Add some\n\tcomments.\n\n2011-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Call Check_Aspect_At_Freeze_Point\n\t(Freeze_All): Call Check_Aspect_At_End_Of_Declarations\n\t* sem_ch13.ads, sem_ch13.adb (Check_Aspect_At_Freeze_Point):\n\tNew procedure.\n\t(Check_Aspect_At_End_Of_Declarations): New procedure\n\t(Analye_Aspect_Specification): Minor changes for above procedures\n\t* sinfo.ads, sinfo.adb (Is_Delayed_Aspect): Now set in aspect\n\tspecification node as well.\n\n2011-08-01  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.c (_gnat_stat): GetFilesAttributesEx() would fail on special\n\tWindows files. Use GetFilesAttributes() in this case to check for file\n\texistence instead of returning with an error code.\n\nFrom-SVN: r177008", "tree": {"sha": "4cb0f919732a8780906712f099f44e28f97f78a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cb0f919732a8780906712f099f44e28f97f78a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47e11d08d66896ebf33e023c1724925ff2a1546e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e11d08d66896ebf33e023c1724925ff2a1546e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e11d08d66896ebf33e023c1724925ff2a1546e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e11d08d66896ebf33e023c1724925ff2a1546e/comments", "author": null, "committer": null, "parents": [{"sha": "a3a16b218709b07f98329f42bc805d1c7731f71b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a16b218709b07f98329f42bc805d1c7731f71b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a16b218709b07f98329f42bc805d1c7731f71b"}], "stats": {"total": 439, "additions": 373, "deletions": 66}, "files": [{"sha": "270f4193c82f5fb0e813d302e1ef6384d72168a7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -1,3 +1,32 @@\n+2011-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.ads: Minor comment fix.\n+\t* a-stwifi.adb, a-stzfix.adb, a-strfix.adb, a-ztexio.ads, a-textio.ads,\n+\ta-witeio.ads, sem_prag.adb: Minor reformatting.\n+\n+2011-08-01  Doug Rupp  <rupp@adacore.com>\n+\n+\t* env.c (__gnat_setenv) [VMS]: Force 32bit on item list structure\n+\tpointers. Use descrip.h header file for convenience. Add some\n+\tcomments.\n+\n+2011-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Call Check_Aspect_At_Freeze_Point\n+\t(Freeze_All): Call Check_Aspect_At_End_Of_Declarations\n+\t* sem_ch13.ads, sem_ch13.adb (Check_Aspect_At_Freeze_Point):\n+\tNew procedure.\n+\t(Check_Aspect_At_End_Of_Declarations): New procedure\n+\t(Analye_Aspect_Specification): Minor changes for above procedures\n+\t* sinfo.ads, sinfo.adb (Is_Delayed_Aspect): Now set in aspect\n+\tspecification node as well.\n+\n+2011-08-01  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c (_gnat_stat): GetFilesAttributesEx() would fail on special\n+\tWindows files. Use GetFilesAttributes() in this case to check for file\n+\texistence instead of returning with an error code.\n+\n 2011-08-01  Vincent Celier  <celier@adacore.com>\n \n \t* a-stzfix.adb, a-stwifi.adb (Replace_Slice): Fixed computation when"}, {"sha": "0f3395899b309b9621fc15473721176adc31f3c2", "filename": "gcc/ada/a-strfix.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-strfix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-strfix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strfix.adb?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -485,8 +485,8 @@ package body Ada.Strings.Fixed is\n                           Integer'Max (0, Low - Source'First);\n             --  Length of prefix of Source copied to result\n \n-            Back_Len  : constant Integer :=\n-                          Integer'Max (0, Source'Last - High);\n+            Back_Len : constant Integer :=\n+                         Integer'Max (0, Source'Last - High);\n             --  Length of suffix of Source copied to result\n \n             Result_Length : constant Integer :=\n@@ -496,13 +496,10 @@ package body Ada.Strings.Fixed is\n             Result : String (1 .. Result_Length);\n \n          begin\n-            Result (1 .. Front_Len) :=\n-              Source (Source'First .. Low - 1);\n-            Result (Front_Len + 1 .. Front_Len + By'Length) :=\n-              By;\n+            Result (1 .. Front_Len) := Source (Source'First .. Low - 1);\n+            Result (Front_Len + 1 .. Front_Len + By'Length) := By;\n             Result (Front_Len + By'Length + 1 .. Result'Length) :=\n               Source (High + 1 .. Source'Last);\n-\n             return Result;\n          end;\n "}, {"sha": "afb443de399f633b387eea4ea831f1895ad569f8", "filename": "gcc/ada/a-stwifi.adb", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-stwifi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-stwifi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwifi.adb?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -455,27 +455,24 @@ package body Ada.Strings.Wide_Fixed is\n       if High >= Low then\n          declare\n             Front_Len : constant Integer :=\n-              Integer'Max (0, Low - Source'First);\n+                          Integer'Max (0, Low - Source'First);\n             --  Length of prefix of Source copied to result\n \n-            Back_Len  : constant Integer :=\n-              Integer'Max (0, Source'Last - High);\n+            Back_Len : constant Integer :=\n+                         Integer'Max (0, Source'Last - High);\n             --  Length of suffix of Source copied to result\n \n             Result_Length : constant Integer :=\n-              Front_Len + By'Length + Back_Len;\n+                              Front_Len + By'Length + Back_Len;\n             --  Length of result\n \n-            Result    : Wide_String (1 .. Result_Length);\n+            Result : Wide_String (1 .. Result_Length);\n \n          begin\n-            Result (1 .. Front_Len) :=\n-              Source (Source'First .. Low - 1);\n-            Result (Front_Len + 1 .. Front_Len + By'Length) :=\n-              By;\n+            Result (1 .. Front_Len) := Source (Source'First .. Low - 1);\n+            Result (Front_Len + 1 .. Front_Len + By'Length) := By;\n             Result (Front_Len + By'Length + 1 .. Result'Length) :=\n               Source (High + 1 .. Source'Last);\n-\n             return Result;\n          end;\n "}, {"sha": "67c2fe56cec943f8203c94c1c4448e8bed01b2d1", "filename": "gcc/ada/a-stzfix.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-stzfix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-stzfix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzfix.adb?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -460,8 +460,8 @@ package body Ada.Strings.Wide_Wide_Fixed is\n                           Integer'Max (0, Low - Source'First);\n             --  Length of prefix of Source copied to result\n \n-            Back_Len  : constant Integer :=\n-                          Integer'Max (0, Source'Last - High);\n+            Back_Len : constant Integer :=\n+                         Integer'Max (0, Source'Last - High);\n             --  Length of suffix of Source copied to result\n \n             Result_Length : constant Integer :=\n@@ -471,13 +471,10 @@ package body Ada.Strings.Wide_Wide_Fixed is\n             Result : Wide_Wide_String (1 .. Result_Length);\n \n          begin\n-            Result (1 .. Front_Len) :=\n-              Source (Source'First .. Low - 1);\n-            Result (Front_Len + 1 .. Front_Len + By'Length) :=\n-              By;\n+            Result (1 .. Front_Len) := Source (Source'First .. Low - 1);\n+            Result (Front_Len + 1 .. Front_Len + By'Length) := By;\n             Result (Front_Len + By'Length + 1 .. Result'Length) :=\n               Source (High + 1 .. Source'Last);\n-\n             return Result;\n          end;\n "}, {"sha": "3794cb9c01541162d2ea5849d6ece1e75aca279a", "filename": "gcc/ada/a-textio.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-textio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-textio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.ads?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -71,9 +71,9 @@ package Ada.Text_IO is\n    --  Line and page length\n \n    subtype Field is Integer range 0 .. 255;\n-   --  Note: if for any reason, there is a need to increase this value,\n-   --  then it will be necessary to change the corresponding value in\n-   --  System.Img_Real in file s-imgrea.adb.\n+   --  Note: if for any reason, there is a need to increase this value, then it\n+   --  will be necessary to change the corresponding value in System.Img_Real\n+   --  in file s-imgrea.adb.\n \n    subtype Number_Base is Integer range 2 .. 16;\n "}, {"sha": "463207b7ce38921a2c3bf5cee466787f02c7c8b4", "filename": "gcc/ada/a-witeio.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-witeio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-witeio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.ads?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -73,9 +73,9 @@ package Ada.Wide_Text_IO is\n    --  Line and page length\n \n    subtype Field is Integer range 0 .. 255;\n-   --  Note: if for any reason, there is a need to increase this value,\n-   --  then it will be necessary to change the corresponding value in\n-   --  System.Img_Real in file s-imgrea.adb.\n+   --  Note: if for any reason, there is a need to increase this value, then it\n+   --  will be necessary to change the corresponding value in System.Img_Real\n+   --  in file s-imgrea.adb.\n \n    subtype Number_Base is Integer range 2 .. 16;\n "}, {"sha": "c95b3c4a2eff126864ffa12b1a489489e55cb5fa", "filename": "gcc/ada/a-ztexio.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-ztexio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fa-ztexio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztexio.ads?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -73,9 +73,9 @@ package Ada.Wide_Wide_Text_IO is\n    --  Line and page length\n \n    subtype Field is Integer range 0 .. 255;\n-   --  Note: if for any reason, there is a need to increase this value,\n-   --  then it will be necessary to change the corresponding value in\n-   --  System.Img_Real in file s-imgrea.adb.\n+   --  Note: if for any reason, there is a need to increase this value, then it\n+   --  will be necessary to change the corresponding value in System.Img_Real\n+   --  in file s-imgrea.adb.\n \n    subtype Number_Base is Integer range 2 .. 16;\n "}, {"sha": "c1e97c64b40c9a51ee1fefcbf90c9f5bc5da7f50", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -1697,6 +1697,7 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n   int name_len;\n   BOOL res;\n+  DWORD error;\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n   name_len = _tcslen (wname);\n@@ -1708,8 +1709,19 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n \n   res = GetFileAttributesEx (wname, GetFileExInfoStandard, &fad);\n \n-  if (res == FALSE)\n-    switch (GetLastError()) {\n+  if (res == FALSE) {\n+    error = GetLastError();\n+\n+    /* Check file existence using GetFileAttributes() which does not fail on\n+       special Windows files like con:, aux:, nul: etc...  */\n+\n+    if (GetFileAttributes(wname) != INVALID_FILE_ATTRIBUTES) {\n+      /* Just pretend that it is a regular and readable file  */\n+      statbuf->st_mode = S_IFREG | S_IREAD | S_IWRITE;\n+      return 0;\n+    }\n+\n+    switch (error) {\n       case ERROR_ACCESS_DENIED:\n       case ERROR_SHARING_VIOLATION:\n       case ERROR_LOCK_VIOLATION:\n@@ -1722,6 +1734,7 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n       default:\n \treturn ENOENT;\n     }\n+  }\n \n   f2t (&fad.ftCreationTime, &statbuf->st_ctime);\n   f2t (&fad.ftLastWriteTime, &statbuf->st_mtime);"}, {"sha": "386dcefa8207db76f5a2ca499f2ea69bf068b54a", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -404,16 +404,16 @@ package Atree is\n    --  with copying aspect specifications where this is required.\n \n    function New_Copy (Source : Node_Id) return Node_Id;\n-   --  This function allocates a completely new node, and then initializes\n-   --  it by copying the contents of the source node into it. The contents\n-   --  of the source node is not affected. The target node is always marked\n-   --  as not being in a list (even if the source is a list member). The\n-   --  new node will have an extension if the source has an extension.\n-   --  New_Copy (Empty) returns Empty and New_Copy (Error) returns Error.\n-   --  Note that, unlike New_Copy_Tree, New_Copy does not recursively copy any\n-   --  descendents, so in general parent pointers are not set correctly for\n-   --  the descendents of the copied node. Both normal and extended nodes\n-   --  (entities) may be copied using New_Copy.\n+   --  This function allocates a completely new node, and then initializes it\n+   --  by copying the contents of the source node into it. The contents of the\n+   --  source node is not affected. The target node is always marked as not\n+   --  being in a list (even if the source is a list member). The new node will\n+   --  have an extension if the source has an extension. New_Copy (Empty)\n+   --  returns Empty and New_Copy (Error) returns Error. Note that, unlike\n+   --  Copy_Separate_Tree, New_Copy does not recursively copy any descendents,\n+   --  so in general parent pointers are not set correctly for the descendents\n+   --  of the copied node. Both normal and extended nodes (entities) may be\n+   --  copied using New_Copy.\n \n    function Relocate_Node (Source : Node_Id) return Node_Id;\n    --  Source is a non-entity node that is to be relocated. A new node is"}, {"sha": "8115442cc9a35198bb77d45e14572be359301b1a", "filename": "gcc/ada/env.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fenv.c?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -50,6 +50,7 @@ extern \"C\" {\n #include <time.h>\n #ifdef VMS\n #include <unixio.h>\n+#include <vms/descrip.h>\n #endif\n \n #if defined (__MINGW32__)\n@@ -93,17 +94,11 @@ __gnat_getenv (char *name, int *len, char **value)\n \n static char *to_host_path_spec (char *);\n \n-struct descriptor_s\n-{\n-  unsigned short len, mbz;\n-  __char_ptr32 adr;\n-};\n-\n typedef struct _ile3\n {\n   unsigned short len, code;\n   __char_ptr32 adr;\n-  unsigned short *retlen_adr;\n+  __char_ptr32 retlen_adr;\n } ile_s;\n \n #endif\n@@ -112,18 +107,19 @@ void\n __gnat_setenv (char *name, char *value)\n {\n #if defined (VMS)\n-  struct descriptor_s name_desc;\n+  struct dsc$descriptor_s name_desc;\n   /* Put in JOB table for now, so that the project stuff at least works.  */\n-  struct descriptor_s table_desc = {7, 0, \"LNM$JOB\"};\n+  $DESCRIPTOR (table_desc, \"LNM$JOB\");\n   char *host_pathspec = value;\n   char *copy_pathspec;\n   int num_dirs_in_pathspec = 1;\n   char *ptr;\n   long status;\n \n-  name_desc.len = strlen (name);\n-  name_desc.mbz = 0;\n-  name_desc.adr = name;\n+  name_desc.dsc$w_length = strlen (name);\n+  name_desc.dsc$b_dtype = DSC$K_DTYPE_T;\n+  name_desc.dsc$b_class = DSC$K_CLASS_S;\n+  name_desc.dsc$a_pointer = name; /* ??? Danger, not 64bit safe.  */\n \n   if (*host_pathspec == 0)\n     /* deassign */\n@@ -141,6 +137,7 @@ __gnat_setenv (char *name, char *value)\n \n   {\n     int i, status;\n+    /* Alloca is guaranteed to be 32bit.  */\n     ile_s *ile_array = alloca (sizeof (ile_s) * (num_dirs_in_pathspec + 1));\n     char *copy_pathspec = alloca (strlen (host_pathspec) + 1);\n     char *curr, *next;"}, {"sha": "438029212474c6dec7b04a89bc039eabf3d6d8a2", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -1323,6 +1323,27 @@ package body Freeze is\n             if not Is_Frozen (E) then\n                Flist := Freeze_Entity (E, After);\n                Process_Flist;\n+\n+            --  If already frozen, and there are delayed aspects, this is where\n+            --  we do the visibility check for these aspects (see Sem_Ch13 spec\n+            --  for a description of how we handle aspect visibility).\n+\n+            elsif Has_Delayed_Aspects (E) then\n+               declare\n+                  Ritem : Node_Id;\n+\n+               begin\n+                  Ritem := First_Rep_Item (E);\n+                  while Present (Ritem) loop\n+                     if Nkind (Ritem) = N_Aspect_Specification\n+                       and then Is_Delayed_Aspect (Ritem)\n+                     then\n+                        Check_Aspect_At_End_Of_Declarations (Ritem);\n+                     end if;\n+\n+                     Ritem := Next_Rep_Item (Ritem);\n+                  end loop;\n+               end;\n             end if;\n \n             --  If an incomplete type is still not frozen, this may be a\n@@ -2390,9 +2411,9 @@ package body Freeze is\n             while Present (Ritem) loop\n                if Nkind (Ritem) = N_Aspect_Specification\n                  and then Entity (Ritem) = E\n+                 and then Is_Delayed_Aspect (Ritem)\n                then\n                   Aitem := Aspect_Rep_Item (Ritem);\n-                  pragma Assert (Is_Delayed_Aspect (Aitem));\n                   Set_Parent (Aitem, Ritem);\n \n                   --  Deal with Boolean case, if no expression, True, otherwise\n@@ -2423,6 +2444,10 @@ package body Freeze is\n                   --  Analyze the pragma after possibly setting Aspect_Cancel\n \n                   Analyze (Aitem);\n+\n+                  --  Do visibility analysis for aspect at freeze point\n+\n+                  Check_Aspect_At_Freeze_Point (Ritem);\n                end if;\n \n                Next_Rep_Item (Ritem);"}, {"sha": "ef50ec4b59d30051830cde105b39811748cfe36c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 169, "deletions": 5, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -700,11 +700,10 @@ package body Sem_Ch13 is\n       --  one of two things happens:\n \n       --  If we are required to delay the evaluation of this aspect to the\n-      --  freeze point, we preanalyze the relevant argument, and then attach\n-      --  the corresponding pragma/attribute definition clause to the aspect\n-      --  specification node, which is then placed in the Rep Item chain.\n-      --  In this case we mark the entity with the Has_Delayed_Aspects flag,\n-      --  and we evaluate the rep item at the freeze point.\n+      --  freeze point, we attach the corresponding pragma/attribute definition\n+      --  clause to the aspect specification node, which is then placed in the\n+      --  Rep Item chain. In this case we mark the entity by setting the flag\n+      --  Has_Delayed_Aspects and we evaluate the rep item at the freeze point.\n \n       --  If no delay is required, we just insert the pragma or attribute\n       --  after the declaration, and it will get processed by the normal\n@@ -800,6 +799,11 @@ package body Sem_Ch13 is\n                Next (Anod);\n             end loop;\n \n+            --  Copy expression for later processing by the procedures\n+            --  Check_Aspect_At_[Freeze_Point | End_Of_Declarations]\n+\n+            Set_Entity (Id, New_Copy_Tree (Expr));\n+\n             --  Processing based on specific aspect\n \n             case A_Id is\n@@ -836,6 +840,7 @@ package body Sem_Ch13 is\n \n                   else\n                      Delay_Required := True;\n+                     Set_Is_Delayed_Aspect (Aspect);\n                   end if;\n \n                --  Aspects corresponding to attribute definition clauses\n@@ -868,6 +873,7 @@ package body Sem_Ch13 is\n                   --  Here a delay is required\n \n                   Delay_Required := True;\n+                  Set_Is_Delayed_Aspect (Aspect);\n \n                --  Aspects corresponding to pragmas with two arguments, where\n                --  the first argument is a local name referring to the entity,\n@@ -981,6 +987,7 @@ package body Sem_Ch13 is\n                   end if;\n \n                   Set_From_Aspect_Specification (Aitem, True);\n+                  Set_Is_Delayed_Aspect (Aspect);\n \n                   --  For Pre/Post cases, insert immediately after the entity\n                   --  declaration, since that is the required pragma placement.\n@@ -1032,6 +1039,7 @@ package body Sem_Ch13 is\n                   end if;\n \n                   Set_From_Aspect_Specification (Aitem, True);\n+                  Set_Is_Delayed_Aspect (Aspect);\n \n                   --  For Invariant case, insert immediately after the entity\n                   --  declaration. We do not have to worry about delay issues\n@@ -1065,6 +1073,7 @@ package body Sem_Ch13 is\n                   --  have a place to build the predicate function).\n \n                   Ensure_Freeze_Node (E);\n+                  Set_Is_Delayed_Aspect (Aspect);\n \n                   --  For Predicate case, insert immediately after the entity\n                   --  declaration. We do not have to worry about delay issues\n@@ -4850,6 +4859,161 @@ package body Sem_Ch13 is\n          return;\n    end Build_Static_Predicate;\n \n+   -----------------------------------------\n+   -- Check_Aspect_At_End_Of_Declarations --\n+   -----------------------------------------\n+\n+   procedure Check_Aspect_At_End_Of_Declarations (ASN : Node_Id) is\n+      Ent   : constant Entity_Id := Entity     (ASN);\n+      Ident : constant Node_Id   := Identifier (ASN);\n+\n+      Freeze_Expr : constant Node_Id := Expression (ASN);\n+      --  Preanalyzed expression from call to Check_Aspect_At_Freeze_Point\n+\n+      End_Decl_Expr : constant Node_Id := Entity (Ident);\n+      --  Expression to be analyzed at end of declarations\n+\n+      T : constant Entity_Id := Etype (Freeze_Expr);\n+      --  Type required for preanalyze call\n+\n+      A_Id : constant Aspect_Id := Get_Aspect_Id (Chars (Ident));\n+\n+      Err : Boolean;\n+      --  Set False if error\n+\n+      --  On entry to this procedure, Entity (Ident) contains a copy of the\n+      --  original expression from the aspect, saved for this purpose, and\n+      --  but Expression (Ident) is a preanalyzed copy of the expression,\n+      --  preanalyzed just after the freeze point.\n+\n+   begin\n+      --  Case of stream attributes, just have to compare entities\n+\n+      if A_Id = Aspect_Input  or else\n+         A_Id = Aspect_Output or else\n+         A_Id = Aspect_Read   or else\n+         A_Id = Aspect_Write\n+      then\n+         Analyze (End_Decl_Expr);\n+         Err := Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n+\n+      --  All other cases\n+\n+      else\n+         Preanalyze_Spec_Expression (End_Decl_Expr, T);\n+         Err := not Fully_Conformant_Expressions (End_Decl_Expr, Freeze_Expr);\n+      end if;\n+\n+      --  Output error message if error\n+\n+      if Err then\n+         Error_Msg_NE\n+           (\"visibility of aspect for& changes after freeze point\",\n+            ASN, Ent);\n+         Error_Msg_NE\n+           (\"?info: & is frozen here, aspects evaluated at this point\",\n+            Freeze_Node (Ent), Ent);\n+      end if;\n+   end Check_Aspect_At_End_Of_Declarations;\n+\n+   ----------------------------------\n+   -- Check_Aspect_At_Freeze_Point --\n+   ----------------------------------\n+\n+   procedure Check_Aspect_At_Freeze_Point (ASN : Node_Id) is\n+      Ident : constant Node_Id := Identifier (ASN);\n+      --  Identifier (use Entity field to save expression)\n+\n+      T : Entity_Id;\n+      --  Type required for preanalyze call\n+\n+      A_Id : constant Aspect_Id := Get_Aspect_Id (Chars (Ident));\n+\n+   begin\n+      --  On entry to this procedure, Entity (Ident) contains a copy of the\n+      --  original expression from the aspect, saved for this purpose.\n+\n+      --  On exit from this procedure Entity (Ident) is unchanged, still\n+      --  containing that copy, but Expression (Ident) is a preanalyzed copy\n+      --  of the expression, preanalyzed just after the freeze point.\n+\n+      --  Make a copy of the expression to be preanalyed\n+\n+      Set_Expression (ASN, New_Copy_Tree (Entity (Ident)));\n+\n+      --  Find type for preanalyze call\n+\n+      case A_Id is\n+\n+         --  No_Aspect should be impossible\n+\n+         when No_Aspect =>\n+            raise Program_Error;\n+\n+         --  Aspects taking an optional boolean argument. Note that we will\n+         --  never be called with an empty expression, because such aspects\n+         --  never need to be delayed anyway.\n+\n+         when Boolean_Aspects =>\n+            pragma Assert (Present (Expression (ASN)));\n+            T := Standard_Boolean;\n+\n+         --  Aspects corresponding to attribute definition clauses\n+\n+         when Aspect_Address      =>\n+            T := RTE (RE_Address);\n+\n+         when Aspect_Bit_Order    =>\n+            T := RTE (RE_Bit_Order);\n+\n+         when Aspect_External_Tag =>\n+            T := Standard_String;\n+\n+         when Aspect_Storage_Pool =>\n+            T := Class_Wide_Type (RTE (RE_Root_Storage_Pool));\n+\n+         when\n+              Aspect_Alignment      |\n+              Aspect_Component_Size |\n+              Aspect_Machine_Radix  |\n+              Aspect_Object_Size    |\n+              Aspect_Size           |\n+              Aspect_Storage_Size   |\n+              Aspect_Stream_Size    |\n+              Aspect_Value_Size     =>\n+            T := Any_Integer;\n+\n+         --  Stream attribute. Special case, the expression is just an entity\n+         --  that does not need any resolution, so just analyze.\n+\n+         when Aspect_Input  |\n+              Aspect_Output |\n+              Aspect_Read   |\n+              Aspect_Write  =>\n+            Analyze (Expression (ASN));\n+            return;\n+\n+         --  Suppress/Unsupress/Warnings should never be delayed\n+\n+         when Aspect_Suppress   |\n+              Aspect_Unsuppress |\n+              Aspect_Warnings   =>\n+            raise Program_Error;\n+\n+         --  Pre/Post/Invariant/Predicate take boolean expressions\n+\n+         when Aspect_Pre       |\n+              Aspect_Post      |\n+              Aspect_Invariant |\n+              Aspect_Predicate =>\n+            T := Standard_Boolean;\n+      end case;\n+\n+      --  Do the preanalyze call\n+\n+      Preanalyze_Spec_Expression (Expression (ASN), T);\n+   end Check_Aspect_At_Freeze_Point;\n+\n    -----------------------------------\n    -- Check_Constant_Address_Clause --\n    -----------------------------------"}, {"sha": "b2c66ff2f3099e7eb876593d0bd0c037bddc4e66", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -236,4 +236,81 @@ package Sem_Ch13 is\n      Table_Increment      => 200,\n      Table_Name           => \"Independence_Checks\");\n \n+   -----------------------------------\n+   -- Handling of Aspect Visibility --\n+   -----------------------------------\n+\n+   --  The visibility of aspects is tricky. First, the visibility is delayed\n+   --  to the freeze point. This is not too complicated, what we do is simply\n+   --  to leave the aspect \"laying in wait\" for the freeze point, and at that\n+   --  point materialize and analye the corresponding attribute definition\n+   --  clause or pragma. There is some special processing for preconditions\n+   --  and postonditions, where the pragmas themselves deal with the required\n+   --  delay, but basically the approach is the same, delay analysis of the\n+   --  expression to the freeze point.\n+\n+   --  Much harder is the requirement for diagnosing cases in which an early\n+   --  freeze causes a change in visibility. Consider:\n+\n+   --    package AspectVis is\n+   --       R_Size : constant Integer := 32;\n+   --\n+   --       package Inner is\n+   --          type R is new Integer with\n+   --            Size => R_Size;\n+   --          F : R; -- freezes\n+   --          R_Size : constant Integer := 64;\n+   --          S : constant Integer := R'Size; -- 32 not 64\n+   --       end Inner;\n+   --    end AspectVis;\n+\n+   --  Here the 32 not 64 shows what would be expected if this program were\n+   --  legal, since the evaluation of R_Size has to be done at the freeze\n+   --  point and gets the outer definition not the inner one.\n+\n+   --  But the language rule requires this program to be diagnosed as illegal\n+   --  because the visibility changes between the freeze point and the end of\n+   --  the declarative region.\n+\n+   --  To meet this requirement, we first note that the Expression field of the\n+   --  N_Aspect_Specification node holds the raw unanalyzed expression, which\n+   --  will get used in processing the aspect. At the time of analyzing the\n+   --  N_Aspect_Specification node, we create a complete copy of the expression\n+   --  and store it in the entity field of the Identifier (an odd usage, but\n+   --  the identifier is not used except to identify the aspect, so its Entity\n+   --  field is otherwise unused, and we are short of room in the node).\n+\n+   --  This copy stays unanalyzed up to the freeze point, where we analyze the\n+   --  resulting pragma or attribute definition clause, except that in the\n+   --  case of invariants and predicates, we mark occurrences of the subtype\n+   --  name as having the entity of the subprogram parameter, so that they\n+   --  will not cause trouble in the following steps.\n+\n+   --  Then at the freeze point, we create another copy of this unanalyzed\n+   --  expression. By this time we no longer need the Expression field for\n+   --  other purposes, so we can store it there. Now we have two copies of\n+   --  the original unanalyzed expression. One of them gets preanalyzed at\n+   --  the freeze point to capture the visibility at the freeze point.\n+\n+   --  Now when we hit the freeze all at the end of the declarative part, if\n+   --  we come across a frozen entity with delayed aspects, we still have one\n+   --  copy of the unanalyzed expression available in the node, and we again\n+   --  do a preanalysis using that copy and the visibility at the end of the\n+   --  declarative part. Now we have two preanalyzed expression (preanalysis\n+   --  is good enough, since we are only interested in referenced entities).\n+   --  One captures the visibility at the freeze point, the other captures the\n+   --  visibility at the end of the declarative part. We see if the entities\n+   --  in these two expressions are the same, by seeing if the two expressions\n+   --  are fully conformant, and if not, issue appropriate error messages.\n+\n+   --  Quite an awkward procedure, but this is an awkard requirement!\n+\n+   procedure Check_Aspect_At_Freeze_Point (ASN : Node_Id);\n+   --  Performs the processing described above at the freeze point, ASN is the\n+   --  N_Aspect_Specification node for the aspect.\n+\n+   procedure Check_Aspect_At_End_Of_Declarations (ASN : Node_Id);\n+   --  Performs the processing described above at the freeze all point, and\n+   --  issues appropriate error messages if the visibility has indeed changed.\n+   --  Again, ASN is the N_Aspect_Specification node for the aspect.\n end Sem_Ch13;"}, {"sha": "abee1331106aa021489d878372838b5cb6f50ba8", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -11243,8 +11243,8 @@ package body Sem_Prag is\n          ---------------\n \n          --  pragma Predicate\n-         --    ([Entity =>]    type_LOCAL_NAME,\n-         --     [Check  =>]    EXPRESSION);\n+         --    ([Entity =>] type_LOCAL_NAME,\n+         --     [Check  =>] EXPRESSION);\n \n          when Pragma_Predicate => Predicate : declare\n             Type_Id : Node_Id;"}, {"sha": "3d8e184b733f84c6b3494db4f63e95c399dd4e16", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -1732,6 +1732,7 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Attribute_Definition_Clause\n         or else NT (N).Nkind = N_Pragma);\n       return Flag14 (N);\n@@ -4760,6 +4761,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Attribute_Definition_Clause\n         or else NT (N).Nkind = N_Pragma);\n       Set_Flag14 (N, Val);"}, {"sha": "c7e6f474c8860871b9108ce21bd35301137fa276", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e11d08d66896ebf33e023c1724925ff2a1546e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=47e11d08d66896ebf33e023c1724925ff2a1546e", "patch": "@@ -1265,7 +1265,8 @@ package Sinfo is\n    --  Is_Delayed_Aspect (Flag14-Sem)\n    --    Present in N_Pragma and N_Attribute_Definition_Clause nodes which\n    --    come from aspect specifications, where the evaluation of the aspect\n-   --    must be delayed to the freeze point.\n+   --    must be delayed to the freeze point. This flag is also set True in\n+   --    the corresponding N_Aspect_Specification node.\n \n    --  Is_Controlling_Actual (Flag16-Sem)\n    --    This flag is set on in an expression that is a controlling argument in\n@@ -6548,9 +6549,17 @@ package Sinfo is\n       --  Next_Rep_Item (Node5-Sem)\n       --  Split_PPC (Flag17) Set if split pre/post attribute\n       --  Is_Boolean_Aspect (Flag16-Sem)\n+      --  Is_Delayed_Aspect (Flag14-Sem)\n \n       --  Note: Aspect_Specification is an Ada 2012 feature\n \n+      --  Note: The Identifier serves to identify the aspect involved (it\n+      --  is the aspect whose name corresponds to the Chars field). This\n+      --  means that the other fields of this identifier are unused, and\n+      --  in particular we use the Entity field of this identifier to save\n+      --  a copy of the expression for visibility analysis, see spec of\n+      --  Sem_Ch13 for full details of this usage.\n+\n       --  Note: When a Pre or Post aspect specification is processed, it is\n       --  broken into AND THEN sections. The left most section has Split_PPC\n       --  set to False, indicating that it is the original specification (e.g."}]}