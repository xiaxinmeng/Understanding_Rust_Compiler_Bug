{"sha": "589005ff217dde6c3c22842e27315d597a8fe710", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg5MDA1ZmYyMTdkZGU2YzNjMjI4NDJlMjczMTVkNTk3YThmZTcxMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-06-04T11:30:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-06-04T11:30:46Z"}, "message": "gbl-ctors.h: Fix formatting.\n\n\t* gbl-ctors.h: Fix formatting.\n\t* gcc.c: Likewise.\n\t* gccspec.c: Likewise.\n\t* gcov.c: Likewise.\n\t* gcov-io.h: Likewise.\n\t* gcse.c: Likewise.\n\t* ggc-common.c: Likewise.\n\t* ggc.h: Likewise.\n\t* ggc-page.c: Likewise.\n\t* ggc-simple.c: Likewise.\n\t* global.c: Likewise.\n\t* graph.h: Likewise.\n\t* gthr-dce.h: Likewise.\n\t* gthr.h: Likewise.\n\t* gthr-posix.h: Likewise.\n\t* gthr-rtems.h: Likewise.\n\t* gthr-solaris.h: Likewise.\n\t* gthr-win32.h: Likewise.\n\nFrom-SVN: r54240", "tree": {"sha": "e46147f472cc001827083ec7631a1140948ce7c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e46147f472cc001827083ec7631a1140948ce7c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/589005ff217dde6c3c22842e27315d597a8fe710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/589005ff217dde6c3c22842e27315d597a8fe710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/589005ff217dde6c3c22842e27315d597a8fe710", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/589005ff217dde6c3c22842e27315d597a8fe710/comments", "author": null, "committer": null, "parents": [{"sha": "94213cff2aab4c3107aad20145838219caa829e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94213cff2aab4c3107aad20145838219caa829e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94213cff2aab4c3107aad20145838219caa829e0"}], "stats": {"total": 795, "additions": 408, "deletions": 387}, "files": [{"sha": "3f2df697a8fff5e270ff7bdeb2c38c406926a817", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -1,3 +1,24 @@\n+2002-06-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* gbl-ctors.h: Fix formatting.\n+\t* gcc.c: Likewise.\n+\t* gccspec.c: Likewise.\n+\t* gcov.c: Likewise.\n+\t* gcov-io.h: Likewise.\n+\t* gcse.c: Likewise.\n+\t* ggc-common.c: Likewise.\n+\t* ggc.h: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* ggc-simple.c: Likewise.\n+\t* global.c: Likewise.\n+\t* graph.h: Likewise.\n+\t* gthr-dce.h: Likewise.\n+\t* gthr.h: Likewise.\n+\t* gthr-posix.h: Likewise.\n+\t* gthr-rtems.h: Likewise.\n+\t* gthr-solaris.h: Likewise.\n+\t* gthr-win32.h: Likewise.\n+\n 2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n \n \tMerge from pch-branch:\n@@ -1206,7 +1227,7 @@ Mon Jun  3 11:53:01 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-06-02  Kazu Hirata  <kazu@cs.umass.edu>\n \n-\t* emit-rtl.c: Likewise.\n+\t* emit-rtl.c: Fix formatting.\n \t* errors.h: Likewise.\n \t* except.c: Likewise.\n \t* explow.c: Likewise."}, {"sha": "3cc363d29d95743282711135d7cac90d9fb50813", "filename": "gcc/gbl-ctors.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgbl-ctors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgbl-ctors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgbl-ctors.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -78,6 +78,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n     for (nptrs = 0; __CTOR_LIST__[nptrs + 1] != 0; nptrs++);\t\t\\\n   for (i = nptrs; i >= 1; i--)\t\t\t\t\t\t\\\n     __CTOR_LIST__[i] ();\t\t\t\t\t\t\\\n-} while (0) \n+} while (0)\n #endif\n "}, {"sha": "3c18f1a21e4ad27df403915be5b4af161c8fd676", "filename": "gcc/gcc.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -242,7 +242,7 @@ static const struct modify_target\n }\n modify_target[] = MODIFY_TARGET_NAME;\n #endif\n- \n+\n /* The number of errors that have occurred; the link phase will not be\n    run if this is non-zero.  */\n static int error_count = 0;\n@@ -1522,12 +1522,12 @@ init_spec ()\n   {\n     const char *p = libgcc_spec;\n     int in_sep = 1;\n- \n+\n     /* Transform the extant libgcc_spec into one that uses the shared libgcc\n        when given the proper command line arguments.  */\n     while (*p)\n       {\n-        if (in_sep && *p == '-' && strncmp (p, \"-lgcc\", 5) == 0)\n+\tif (in_sep && *p == '-' && strncmp (p, \"-lgcc\", 5) == 0)\n \t  {\n \t    init_gcc_specs (&obstack,\n #ifdef NO_SHARED_LIBGCC_MULTILIB\n@@ -2758,8 +2758,8 @@ execute ()\n \t{\n \t  const char *const *j;\n \n-     \t  if (verbose_only_flag)\n-     \t    {\n+\t  if (verbose_only_flag)\n+\t    {\n \t      for (j = commands[i].argv; *j; j++)\n \t\t{\n \t\t  const char *p;\n@@ -2772,8 +2772,8 @@ execute ()\n \t\t    }\n \t\t  fputc ('\"', stderr);\n \t\t}\n-     \t    }\n-     \t  else\n+\t    }\n+\t  else\n \t    for (j = commands[i].argv; *j; j++)\n \t      fprintf (stderr, \" %s\", *j);\n \n@@ -2784,7 +2784,7 @@ execute ()\n \t}\n       fflush (stderr);\n       if (verbose_only_flag != 0)\n-        return 0;\n+\treturn 0;\n #ifdef DEBUG\n       notice (\"\\nGo ahead? (y or n) \");\n       fflush (stderr);\n@@ -3384,20 +3384,20 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t  add_linker_option (\"--help\", 6);\n \t}\n       else if (strcmp (argv[i], \"-ftarget-help\") == 0)\n-        {\n-          /* translate_options() has turned --target-help into -ftarget-help.  */\n-          target_help_flag = 1;\n+\t{\n+\t  /* translate_options() has turned --target-help into -ftarget-help.  */\n+\t  target_help_flag = 1;\n \n-          /* We will be passing a dummy file on to the sub-processes.  */\n-          n_infiles++;\n-          n_switches++;\n+\t  /* We will be passing a dummy file on to the sub-processes.  */\n+\t  n_infiles++;\n+\t  n_switches++;\n \n \t  /* CPP driver cannot obtain switch from cc1_options.  */\n \t  if (is_cpp_driver)\n \t    add_preprocessor_option (\"--target-help\", 13);\n-          add_assembler_option (\"--target-help\", 13);\n-          add_linker_option (\"--target-help\", 13);\n-        }\n+\t  add_assembler_option (\"--target-help\", 13);\n+\t  add_linker_option (\"--target-help\", 13);\n+\t}\n       else if (! strcmp (argv[i], \"-pass-exit-codes\"))\n \t{\n \t  pass_exit_codes = 1;\n@@ -3572,7 +3572,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t\t    tmp[++ len] = 0;\n \t\t    value = tmp;\n \t\t  }\n-\t\t\n+\n \t\t/* As a kludge, if the arg is \"[foo/]stageN/\", just\n \t\t   add \"[foo/]include\" to the include prefix.  */\n \t\tif ((len == 7\n@@ -3703,7 +3703,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \n \t      if (is_modify_target_name)\n \t\tbreak;\n-#endif\t\t      \n+#endif\n \n \t      n_switches++;\n \n@@ -3893,7 +3893,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t  /* -save-temps overrides -pipe, so that temp files are produced */\n \t  if (save_temps_flag)\n \t    error (\"warning: -pipe ignored because -save-temps specified\");\n-          /* -time overrides -pipe because we can't get correct stats when\n+\t  /* -time overrides -pipe because we can't get correct stats when\n \t     multiple children are running at once.  */\n \t  else if (report_times)\n \t    error (\"warning: -pipe ignored because -time specified\");\n@@ -4509,15 +4509,15 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      }\n \t\t    suffix_length += strlen (TARGET_OBJECT_SUFFIX);\n \t\t  }\n-\t\t\n+\n \t\t/* If the input_filename has the same suffix specified\n \t\t   for the %g, %u, or %U, and -save-temps is specified,\n \t\t   we could end up using that file as an intermediate\n \t\t   thus clobbering the user's source file (.e.g.,\n \t\t   gcc -save-temps foo.s would clobber foo.s with the\n \t\t   output of cpp0).  So check for this condition and\n \t\t   generate a temp file as the intermediate.  */\n-\t\t   \n+\n \t\tif (save_temps_flag)\n \t\t  {\n \t\t    temp_filename_length = basename_length + suffix_length;\n@@ -4529,25 +4529,25 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t    if (strcmp (temp_filename, input_filename) != 0)\n \t\t      {\n \t\t      \tstruct stat st_temp;\n-\t\t      \t\n+\n \t\t      \t/* Note, set_input() resets input_stat_set to 0.  */\n \t\t      \tif (input_stat_set == 0)\n \t\t      \t  {\n \t\t      \t    input_stat_set = stat (input_filename, &input_stat);\n \t\t      \t    if (input_stat_set >= 0)\n \t\t      \t      input_stat_set = 1;\n \t\t      \t  }\n-\t\t      \t  \n+\n \t\t      \t/* If we have the stat for the input_filename\n \t\t      \t   and we can do the stat for the temp_filename\n \t\t      \t   then the they could still refer to the same\n \t\t      \t   file if st_dev/st_ino's are the same.  */\n-\t\t      \t\n+\n \t\t\tif (input_stat_set != 1\n \t\t\t    || stat (temp_filename, &st_temp) < 0\n \t\t\t    || input_stat.st_dev != st_temp.st_dev\n \t\t\t    || input_stat.st_ino != st_temp.st_ino)\n- \t\t      \t  {\n+\t\t\t  {\n \t\t\t    temp_filename = save_string (temp_filename,\n \t\t\t\t\t\t\t temp_filename_length + 1);\n \t\t\t    obstack_grow (&obstack, temp_filename,\n@@ -4755,8 +4755,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t  case 'C':\n \t    {\n \t      const char *const spec\n-\t\t= (input_file_compiler->cpp_spec \n-\t\t   ? input_file_compiler->cpp_spec \n+\t\t= (input_file_compiler->cpp_spec\n+\t\t   ? input_file_compiler->cpp_spec\n \t\t   : cpp_spec);\n \t      value = do_spec_1 (spec, 0, NULL);\n \t      if (value != 0)\n@@ -4984,17 +4984,17 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    obstack_1grow (&obstack, '%');\n \t    break;\n \n-         case '.':\n-\t   {\n-\t     unsigned len = 0;\n+\t  case '.':\n+\t    {\n+\t      unsigned len = 0;\n \n-\t     while (p[len] && p[len] != ' ' && p[len] != '%')\n-\t       len++;\n-             suffix_subst = save_string (p - 1, len + 1);\n-             p += len;\n-           }\n+\t      while (p[len] && p[len] != ' ' && p[len] != '%')\n+\t\tlen++;\n+\t      suffix_subst = save_string (p - 1, len + 1);\n+\t      p += len;\n+\t    }\n \t   break;\n-          \n+\n \t  case '*':\n \t    if (soft_matched_part)\n \t      {\n@@ -5693,7 +5693,7 @@ set_input (filename)\n     }\n   else\n     input_suffix = \"\";\n-  \n+\n   /* If a spec for 'g', 'u', or 'U' is seen with -save-temps then\n      we will need to do a stat on the input_filename.  The\n      INPUT_STAT_SET signals that the stat is needed.  */\n@@ -6095,7 +6095,7 @@ main (argc, argv)\n       input_file_compiler\n \t= lookup_compiler (infiles[i].name, input_filename_length,\n \t\t\t   infiles[i].language);\n-      \n+\n       if (input_file_compiler)\n \t{\n \t  /* Ok, we found an applicable compiler.  Run its spec.  */\n@@ -6234,7 +6234,7 @@ lookup_compiler (name, length, language)\n \t      && !strcmp (cp->suffix,\n \t\t\t  name + length - strlen (cp->suffix))\n \t ))\n-        break;\n+\tbreak;\n     }\n \n #if defined (OS2) ||defined (HAVE_DOS_BASED_FILE_SYSTEM)"}, {"sha": "79f3d667d5ebf4f38367b96a7adaff21d6135535", "filename": "gcc/gccspec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgccspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgccspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgccspec.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -57,7 +57,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t}\n       else\n \t{\n-\t  int len; \n+\t  int len;\n \n \t  /* If the filename ends in .m or .mi, we are compiling ObjC\n \t     and want to pass -shared-libgcc.  */"}, {"sha": "4c547b5969db3508dbf9324ac17c8cb1dcc80c9f", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -74,7 +74,7 @@ __store_gcov_type (value, dest, bytes)\n   if (value && value != -1)\n     return 1;\n \n-  for(; i < bytes ; i++) \n+  for(; i < bytes ; i++)\n     dest[i] = 0;\n   dest[bytes - 1] |= upper_bit;\n   return 0;"}, {"sha": "01e1a1dd77e93763713f256094a3eb3d09b5fadf", "filename": "gcc/gcov.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -687,15 +687,15 @@ create_program_flow_graph (bptr)\n   __read_long (&function_name_len, bbg_file, 4);\n   function_name = xmalloc (function_name_len + 1);\n   fread (function_name, 1, function_name_len + 1, bbg_file);\n-  \n+\n   /* Skip padding.  */\n   tmp = (function_name_len + 1) % 4;\n \n   if (tmp)\n     fseek (bbg_file, 4 - tmp, SEEK_CUR);\n \n   __read_long (&tmp, bbg_file, 4);   /* ignore -1.  */\n-  \n+\n   /* Read the cfg checksum.  */\n   __read_long (&cfg_checksum, bbg_file, 4);\n \n@@ -729,7 +729,7 @@ create_program_flow_graph (bptr)\n \t  __read_long (&flag_bits, bbg_file, 4);\n \t  if (flag_bits & 0x1)\n \t    arcptr->on_tree++;\n-\t  else \n+\t  else\n \t    instr_arcs++;\n \t  arcptr->fake = !! (flag_bits & 0x2);\n \t  arcptr->fall_through = !! (flag_bits & 0x4);\n@@ -1063,9 +1063,9 @@ calculate_branch_probs (current_graph, block_num, branch_probs, last_line_num)\n       a_ptr = (struct arcdata *) xmalloc (sizeof (struct arcdata));\n       a_ptr->total = total;\n       if (total == 0)\n-          a_ptr->hits = 0;\n+\ta_ptr->hits = 0;\n       else\n-          a_ptr->hits = arcptr->arc_count;\n+\ta_ptr->hits = arcptr->arc_count;\n       a_ptr->call_insn = arcptr->fake;\n \n       if (output_function_summary)\n@@ -1565,8 +1565,8 @@ output_data ()\n \t\t\t\t\t   ((a_ptr->hits * 100)\n \t\t\t\t\t    + (a_ptr->total >> 1))\n \t\t\t\t\t   / a_ptr->total);\n-                                fnotice (gcov_file,\n-                                         \"branch %d taken = %s%%\\n\", i, c);\n+\t\t\t\t  fnotice (gcov_file,\n+\t\t\t\t\t   \"branch %d taken = %s%%\\n\", i, c);\n \t\t\t\t}\n \t\t\t    }\n \t\t\t}"}, {"sha": "531a0fc0a3753bddb4d4bc48133f0310d2224a6e", "filename": "gcc/gcse.c", "status": "modified", "additions": 175, "deletions": 175, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -158,7 +158,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"output.h\"\n #include \"function.h\"\n-#include \"expr.h\" \n+#include \"expr.h\"\n #include \"except.h\"\n #include \"ggc.h\"\n #include \"params.h\"\n@@ -454,13 +454,13 @@ static int reg_set_table_size;\n #define REG_SET_TABLE_SLOP 100\n \n /* This is a list of expressions which are MEMs and will be used by load\n-   or store motion. \n+   or store motion.\n    Load motion tracks MEMs which aren't killed by\n    anything except itself. (ie, loads and stores to a single location).\n-   We can then allow movement of these MEM refs with a little special \n+   We can then allow movement of these MEM refs with a little special\n    allowance. (all stores copy the same value to the reaching reg used\n    for the loads).  This means all values used to store into memory must have\n-   no side effects so we can re-issue the setter value.  \n+   no side effects so we can re-issue the setter value.\n    Store Motion uses this structure as an expression table to track stores\n    which look interesting, and might be moveable towards the exit block.  */\n \n@@ -622,7 +622,7 @@ static int bypass_conditional_jumps PARAMS ((void));\n static void alloc_pre_mem\tPARAMS ((int, int));\n static void free_pre_mem\tPARAMS ((void));\n static void compute_pre_data\tPARAMS ((void));\n-static int pre_expr_reaches_here_p PARAMS ((basic_block, struct expr *, \n+static int pre_expr_reaches_here_p PARAMS ((basic_block, struct expr *,\n \t\t\t\t\t    basic_block));\n static void insert_insn_end_bb\tPARAMS ((struct expr *, basic_block, int));\n static void pre_insert_copy_insn PARAMS ((struct expr *, rtx));\n@@ -635,7 +635,7 @@ static void alloc_code_hoist_mem PARAMS ((int, int));\n static void free_code_hoist_mem\tPARAMS ((void));\n static void compute_code_hoist_vbeinout\tPARAMS ((void));\n static void compute_code_hoist_data PARAMS ((void));\n-static int hoist_expr_reaches_here_p PARAMS ((basic_block, int, basic_block, \n+static int hoist_expr_reaches_here_p PARAMS ((basic_block, int, basic_block,\n \t\t\t\t\t      char *));\n static void hoist_code\t\tPARAMS ((void));\n static int one_code_hoisting_pass PARAMS ((void));\n@@ -677,7 +677,7 @@ static inline struct ls_expr * first_ls_expr PARAMS ((void));\n static inline struct ls_expr * next_ls_expr  PARAMS ((struct ls_expr *));\n static int simple_mem\t\t\tPARAMS ((rtx));\n static void invalidate_any_buried_refs\tPARAMS ((rtx));\n-static void compute_ld_motion_mems\tPARAMS ((void)); \n+static void compute_ld_motion_mems\tPARAMS ((void));\n static void trim_ld_motion_mems\t\tPARAMS ((void));\n static void update_ld_motion_stores\tPARAMS ((struct expr *));\n static void reg_set_info\t\tPARAMS ((rtx, rtx, void *));\n@@ -693,7 +693,7 @@ static void build_store_vectors\t\tPARAMS ((void));\n static void insert_insn_start_bb\tPARAMS ((rtx, basic_block));\n static int insert_store\t\t\tPARAMS ((struct ls_expr *, edge));\n static void replace_store_insn\t\tPARAMS ((rtx, rtx, basic_block));\n-static void delete_store\t\tPARAMS ((struct ls_expr *, \n+static void delete_store\t\tPARAMS ((struct ls_expr *,\n \t\t\t\t\t\t basic_block));\n static void free_store_memory\t\tPARAMS ((void));\n static void store_motion\t\tPARAMS ((void));\n@@ -726,7 +726,7 @@ gcse_main (f, file)\n      setjmp, so just punt to be safe.  */\n   if (current_function_calls_setjmp)\n     return 0;\n-   \n+\n   /* Assume that we do not need to run jump optimizations after gcse.  */\n   run_jump_opt_after_gcse = 0;\n \n@@ -764,7 +764,7 @@ gcse_main (f, file)\n \n   /* If allocating memory for the cprop bitmap would take up too much\n      storage it's better just to disable the optimization.  */\n-  if ((n_basic_blocks \n+  if ((n_basic_blocks\n        * SBITMAP_SET_SIZE (max_gcse_regno)\n        * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n     {\n@@ -826,7 +826,7 @@ gcse_main (f, file)\n       if (optimize_size)\n \tchanged |= one_classic_gcse_pass (pass + 1);\n       else\n-        {\n+\t{\n \t  changed |= one_pre_gcse_pass (pass + 1);\n \t  /* We may have just created new basic blocks.  Release and\n \t     recompute various things which are sized on the number of\n@@ -863,15 +863,15 @@ gcse_main (f, file)\n \t for space, we use a classic gcse algorithm instead of partial\n \t redundancy algorithms).  */\n       if (optimize_size)\n-        {\n+\t{\n \t  max_gcse_regno = max_reg_num ();\n \t  alloc_gcse_mem (f);\n \t  changed |= one_code_hoisting_pass ();\n \t  free_gcse_mem ();\n \n \t  if (max_pass_bytes < bytes_used)\n \t    max_pass_bytes = bytes_used;\n-        }\n+\t}\n \n       if (file)\n \t{\n@@ -1118,7 +1118,7 @@ get_bitmap_width (n, x, y)\n    the expr hash table; if nonzero this routine looks at the set hash table.\n    Additionally, TRANSP is computed as ~TRANSP, since this is really cprop's\n    ABSALTERED.  */\n- \n+\n static void\n compute_local_properties (transp, comp, antloc, setp)\n      sbitmap *transp;\n@@ -1128,7 +1128,7 @@ compute_local_properties (transp, comp, antloc, setp)\n {\n   unsigned int i, hash_table_size;\n   struct expr **hash_table;\n-  \n+\n   /* Initialize any bitmaps that were passed in.  */\n   if (transp)\n     {\n@@ -1378,7 +1378,7 @@ oprs_unchanged_p (x, insn, avail_p)\n \n \tif (info->last_bb != current_bb)\n \t  return 1;\n-        if (avail_p)\n+\tif (avail_p)\n \t  return info->last_set < INSN_CUID (insn);\n \telse\n \t  return info->first_set >= INSN_CUID (insn);\n@@ -1470,8 +1470,8 @@ mems_conflict_for_gcse_p (dest, setter, data)\n     return;\n \n   /* If we are setting a MEM in our list of specially recognized MEMs,\n-     don't mark as killed this time.  */ \n-  \n+     don't mark as killed this time.  */\n+\n   if (dest == gcse_mem_operand && pre_ldst_mems != NULL)\n     {\n       if (!find_rtx_in_ldst (dest))\n@@ -1522,7 +1522,7 @@ load_killed_in_block_p (bb, uid_limit, x, avail_p)\n \treturn 1;\n \n       /* SETTER must be an INSN of some kind that sets memory.  Call\n-\t note_stores to examine each hunk of memory that is modified. \n+\t note_stores to examine each hunk of memory that is modified.\n \n \t The note_stores interface is pretty limited, so we have to\n \t communicate via global variables.  Yuk.  */\n@@ -1587,7 +1587,7 @@ hash_string_1 (ps)\n {\n   unsigned hash = 0;\n   const unsigned char *p = (const unsigned char *) ps;\n-  \n+\n   if (p)\n     while (*p)\n       hash += *p++;\n@@ -1995,7 +1995,7 @@ insert_expr_in_table (x, mode, insn, antic_p, avail_p)\n \t/* Add EXPR to end of this hash chain.  */\n \tlast_expr->next_same_hash = cur_expr;\n \n-      /* Set the fields of the expr element.  */ \n+      /* Set the fields of the expr element.  */\n       cur_expr->expr = x;\n       cur_expr->bitmap_index = n_exprs++;\n       cur_expr->next_same_hash = NULL;\n@@ -2318,7 +2318,7 @@ dump_hash_table (file, name, table, table_size, total_size)\n   unsigned int *hash_val;\n   struct expr *expr;\n \n-  flat_table \n+  flat_table\n     = (struct expr **) xcalloc (total_size, sizeof (struct expr *));\n   hash_val = (unsigned int *) xmalloc (total_size * sizeof (unsigned int));\n \n@@ -2384,7 +2384,7 @@ record_last_reg_set_info (insn, regno)\n    Note we store a pair of elements in the list, so they have to be\n    taken off pairwise.  */\n \n-static void \n+static void\n canon_list_insert (dest, unused1, v_insn)\n      rtx    dest ATTRIBUTE_UNUSED;\n      rtx    unused1 ATTRIBUTE_UNUSED;\n@@ -2408,12 +2408,12 @@ canon_list_insert (dest, unused1, v_insn)\n \n   dest_addr = get_addr (XEXP (dest, 0));\n   dest_addr = canon_rtx (dest_addr);\n-  insn = (rtx) v_insn;  \n+  insn = (rtx) v_insn;\n   bb = BLOCK_NUM (insn);\n \n-  canon_modify_mem_list[bb] = \n+  canon_modify_mem_list[bb] =\n     alloc_EXPR_LIST (VOIDmode, dest_addr, canon_modify_mem_list[bb]);\n-  canon_modify_mem_list[bb] = \n+  canon_modify_mem_list[bb] =\n     alloc_EXPR_LIST (VOIDmode, dest, canon_modify_mem_list[bb]);\n   bitmap_set_bit (canon_modify_mem_list_set, bb);\n }\n@@ -2438,8 +2438,8 @@ record_last_mem_set_info (insn)\n       /* Note that traversals of this loop (other than for free-ing)\n \t will break after encountering a CALL_INSN.  So, there's no\n \t need to insert a pair of items, as canon_list_insert does.  */\n-      canon_modify_mem_list[bb] = \n-        alloc_INSN_LIST (insn, canon_modify_mem_list[bb]);\n+      canon_modify_mem_list[bb] =\n+\talloc_INSN_LIST (insn, canon_modify_mem_list[bb]);\n       bitmap_set_bit (canon_modify_mem_list_set, bb);\n     }\n   else\n@@ -2527,7 +2527,7 @@ compute_hash_table (set_p)\n \t  if (GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      bool clobbers_all = false;\n-#ifdef NON_SAVING_SETJMP \n+#ifdef NON_SAVING_SETJMP\n \t      if (NON_SAVING_SETJMP\n \t\t  && find_reg_note (insn, REG_SETJMP, NULL_RTX))\n \t\tclobbers_all = true;\n@@ -2552,12 +2552,12 @@ compute_hash_table (set_p)\n \tif (INSN_P (insn))\n \t  {\n \t    if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-              in_libcall_block = 1;\n-            else if (set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-              in_libcall_block = 0;\n-            hash_scan_insn (insn, set_p, in_libcall_block);\n-            if (!set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-              in_libcall_block = 0;\n+\t      in_libcall_block = 1;\n+\t    else if (set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t      in_libcall_block = 0;\n+\t    hash_scan_insn (insn, set_p, in_libcall_block);\n+\t    if (!set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t      in_libcall_block = 0;\n \t  }\n     }\n \n@@ -2814,7 +2814,7 @@ oprs_not_set_p (x, insn)\n       return 1;\n \n     case MEM:\n-      if (load_killed_in_block_p (BLOCK_FOR_INSN (insn), \n+      if (load_killed_in_block_p (BLOCK_FOR_INSN (insn),\n \t\t\t\t  INSN_CUID (insn), x, 0))\n \treturn 0;\n       else\n@@ -3030,7 +3030,7 @@ compute_kill_rd ()\n \t}\n }\n \n-/* Compute the reaching definitions as in \n+/* Compute the reaching definitions as in\n    Compilers Principles, Techniques, and Tools. Aho, Sethi, Ullman,\n    Chapter 10.  It is the same algorithm as used for computing available\n    expressions but applied to the gens and kills of reaching definitions.  */\n@@ -3263,7 +3263,7 @@ expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited)\n       else\n \t{\n \t  visited[pred_bb->index] = 1;\n-\t  if (expr_reaches_here_p_work (occr, expr, pred_bb, check_self_loop, \n+\t  if (expr_reaches_here_p_work (occr, expr, pred_bb, check_self_loop,\n \t      visited))\n \n \t    return 1;\n@@ -3288,7 +3288,7 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop)\n   char *visited = (char *) xcalloc (last_basic_block, 1);\n \n   rval = expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited);\n-  \n+\n   free (visited);\n   return rval;\n }\n@@ -3306,7 +3306,7 @@ computing_insn (expr, insn)\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n   if (expr->avail_occr->next == NULL)\n-    {    \n+    {\n       if (BLOCK_FOR_INSN (expr->avail_occr->insn) == bb)\n \t/* The available expression is actually itself\n \t   (i.e. a loop in the flow graph) so do nothing.  */\n@@ -3319,7 +3319,7 @@ computing_insn (expr, insn)\n   else\n     {\n       /* Pattern is computed more than once.\n-\t Search backwards from this insn to see how many of these \n+\t Search backwards from this insn to see how many of these\n \t computations actually reach this insn.  */\n       struct occr *occr;\n       rtx insn_computes_expr = NULL;\n@@ -3437,7 +3437,7 @@ can_disregard_other_sets (addr_this_reg, insn, for_combine)\n \t      return 0;\n \t  }\n \n-\t*addr_this_reg = this_reg; \n+\t*addr_this_reg = this_reg;\n       }\n \n   return number_of_reaching_defs;\n@@ -3593,7 +3593,7 @@ handle_avail_expr (insn, expr)\n \t\t       REGNO (SET_DEST (PATTERN (NEXT_INSN\n \t\t\t\t\t\t (insn_computes_expr)))));\n \t      fprintf (gcse_file, \"set in insn %d\\n\",\n-\t\t       INSN_UID (insn_computes_expr)); \n+\t\t       INSN_UID (insn_computes_expr));\n \t    }\n \t}\n     }\n@@ -3826,7 +3826,7 @@ compute_transp (x, indx, bmap, set_p)\n \t      dest = XEXP (list_entry, 0);\n \t      list_entry = XEXP (list_entry, 1);\n \t      dest_addr = XEXP (list_entry, 0);\n-\t      \n+\n \t      if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,\n \t\t\t\t\t x, rtx_addr_varies_p))\n \t\t{\n@@ -4016,7 +4016,7 @@ find_avail_set (regno, insn)\n   /* SET1 contains the last set found that can be returned to the caller for\n      use in a substitution.  */\n   struct expr *set1 = 0;\n- \n+\n   /* Loops are not possible here.  To get a loop we would need two sets\n      available at the start of the block containing INSN.  ie we would\n      need two sets like this available at the start of the block:\n@@ -4043,7 +4043,7 @@ find_avail_set (regno, insn)\n       /* If no available set was found we've reached the end of the\n \t (possibly empty) copy chain.  */\n       if (set == 0)\n- \tbreak;\n+\tbreak;\n \n       if (GET_CODE (set->expr) != SET)\n \tabort ();\n@@ -4052,7 +4052,7 @@ find_avail_set (regno, insn)\n \n       /* We know the set is available.\n \t Now check that SRC is ANTLOC (i.e. none of the source operands\n-\t have changed since the start of the block).  \n+\t have changed since the start of the block).\n \n          If the source operand changed, we may still use it for the next\n          iteration of this loop, but we may not use it for substitutions.  */\n@@ -4080,7 +4080,7 @@ find_avail_set (regno, insn)\n    it is the instruction that immediately preceeds JUMP, and must be a\n    single SET of a register.  FROM is what we will try to replace,\n    SRC is the constant we will try to substitute for it.  Returns nonzero\n-   if a change was made. */\n+   if a change was made.  */\n \n static int\n cprop_jump (bb, setcc, jump, from, src)\n@@ -4111,7 +4111,7 @@ cprop_jump (bb, setcc, jump, from, src)\n      register.  */\n   if (rtx_equal_p (new, new_set))\n     return 0;\n- \n+\n   /* If this is now a no-op delete it, otherwise this must be a valid insn.  */\n   if (new == pc_rtx)\n     delete_insn (jump);\n@@ -4167,7 +4167,7 @@ cprop_insn (bb, insn, alter_jumps)\n \n   reg_use_count = 0;\n   note_uses (&PATTERN (insn), find_used_regs, NULL);\n-  \n+\n   note = find_reg_equal_equiv_note (insn);\n \n   /* We may win even when propagating constants into notes.  */\n@@ -4196,7 +4196,7 @@ cprop_insn (bb, insn, alter_jumps)\n       set = find_avail_set (regno, insn);\n       if (! set)\n \tcontinue;\n-  \n+\n       pat = set->expr;\n       /* ??? We might be able to handle PARALLELs.  Later.  */\n       if (GET_CODE (pat) != SET)\n@@ -4214,7 +4214,7 @@ cprop_insn (bb, insn, alter_jumps)\n \t  if (alter_jumps\n \t      && (sset = single_set (insn)) != NULL\n \t      && any_condjump_p (NEXT_INSN (insn))\n-              && onlyjump_p (NEXT_INSN (insn)))\n+\t      && onlyjump_p (NEXT_INSN (insn)))\n \t    {\n \t      rtx dest = SET_DEST (sset);\n \t      if ((REG_P (dest) || CC0_P (dest))\n@@ -4449,30 +4449,30 @@ bypass_block (bb, setcc, jump)\n       for (i = 0; i < reg_use_count; i++)\n \t{\n \t  struct reg_use *reg_used = &reg_use_table[i];\n-          unsigned int regno = REGNO (reg_used->reg_rtx);\n+\t  unsigned int regno = REGNO (reg_used->reg_rtx);\n \t  basic_block dest, old_dest;\n-          struct expr *set;\n-          rtx src, new;\n+\t  struct expr *set;\n+\t  rtx src, new;\n \n-          if (regno >= max_gcse_regno)\n-            continue;\n+\t  if (regno >= max_gcse_regno)\n+\t    continue;\n \n-          set = find_bypass_set (regno, e->src->index);\n+\t  set = find_bypass_set (regno, e->src->index);\n \n \t  if (! set)\n \t    continue;\n \n-          src = SET_SRC (pc_set (jump));\n+\t  src = SET_SRC (pc_set (jump));\n \n \t  if (setcc != NULL)\n \t      src = simplify_replace_rtx (src,\n-                                          SET_DEST (PATTERN (setcc)),\n-                                          SET_SRC (PATTERN (setcc)));\n+\t\t\t\t\t  SET_DEST (PATTERN (setcc)),\n+\t\t\t\t\t  SET_SRC (PATTERN (setcc)));\n \n \t  new = simplify_replace_rtx (src, reg_used->reg_rtx,\n-                                      SET_SRC (set->expr));\n+\t\t\t\t      SET_SRC (set->expr));\n \n-          if (new == pc_rtx)\n+\t  if (new == pc_rtx)\n \t    dest = FALLTHRU_EDGE (bb)->dest;\n \t  else if (GET_CODE (new) == LABEL_REF)\n \t    dest = BRANCH_EDGE (bb)->dest;\n@@ -4530,7 +4530,7 @@ bypass_conditional_jumps ()\n \n   changed = 0;\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb,\n-                  EXIT_BLOCK_PTR, next_bb)\n+\t\t  EXIT_BLOCK_PTR, next_bb)\n     {\n       /* Check for more than one predecessor.  */\n       if (bb->pred && bb->pred->pred_next)\n@@ -4710,7 +4710,7 @@ compute_pre_data ()\n   sbitmap_vector_free (antloc);\n   antloc = NULL;\n   sbitmap_vector_free (ae_kill);\n-  ae_kill = NULL; \n+  ae_kill = NULL;\n   sbitmap_free (trapping_expr);\n }\n \f\n@@ -4795,7 +4795,7 @@ pre_expr_reaches_here_p (occr_bb, expr, bb)\n \f\n \n /* Given an expr, generate RTL which we can insert at the end of a BB,\n-   or on an edge.  Set the block number of any insns generated to \n+   or on an edge.  Set the block number of any insns generated to\n    the value of BB.  */\n \n static rtx\n@@ -4818,13 +4818,13 @@ process_insert_insn (expr)\n      expression to make sure we don't have any sharing issues.  */\n   else if (insn_invalid_p (emit_insn (gen_rtx_SET (VOIDmode, reg, exp))))\n     abort ();\n-  \n+\n   pat = gen_sequence ();\n   end_sequence ();\n \n   return pat;\n }\n-  \n+\n /* Add EXPR to the end of basic block BB.\n \n    This is used by both the PRE and code hoisting.\n@@ -4864,7 +4864,7 @@ insert_insn_end_bb (expr, bb, pre)\n \t Check this.  */\n       if (GET_CODE (insn) == INSN && pre\n \t  && !TEST_BIT (antloc[bb->index], expr->bitmap_index)\n-          && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n+\t  && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n \tabort ();\n \n       /* If this is a jump table, then we can't insert stuff here.  Since\n@@ -4901,15 +4901,15 @@ insert_insn_end_bb (expr, bb, pre)\n       /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n \t we search backward and place the instructions before the first\n \t parameter is loaded.  Do this for everyone for consistency and a\n-\t presumtion that we'll get better code elsewhere as well.  \n+\t presumtion that we'll get better code elsewhere as well.\n \n \t It should always be the case that we can put these instructions\n \t anywhere in the basic block with performing PRE optimizations.\n \t Check this.  */\n \n       if (pre\n \t  && !TEST_BIT (antloc[bb->index], expr->bitmap_index)\n-          && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n+\t  && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n \tabort ();\n \n       /* Since different machines initialize their parameter registers\n@@ -5129,7 +5129,7 @@ pre_insert_copies ()\n \t\t  continue;\n \n \t\t/* Or if the expression doesn't reach the deleted one.  */\n-\t\tif (! pre_expr_reaches_here_p (BLOCK_FOR_INSN (avail->insn), \n+\t\tif (! pre_expr_reaches_here_p (BLOCK_FOR_INSN (avail->insn),\n \t\t\t\t\t       expr,\n \t\t\t\t\t       BLOCK_FOR_INSN (occr->insn)))\n \t\t  continue;\n@@ -5377,7 +5377,7 @@ add_label_notes (x, insn)\n       REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, XEXP (x, 0),\n \t\t\t\t\t    REG_NOTES (insn));\n       if (LABEL_P (XEXP (x, 0)))\n-        LABEL_NUSES (XEXP (x, 0))++;\n+\tLABEL_NUSES (XEXP (x, 0))++;\n       return;\n     }\n \n@@ -5428,7 +5428,7 @@ compute_transpout ()\n \t      if (GET_CODE (XEXP (expr->expr, 0)) == SYMBOL_REF\n \t\t  && CONSTANT_POOL_ADDRESS_P (XEXP (expr->expr, 0)))\n \t\tcontinue;\n-\t\t\n+\n \t      /* ??? Optimally, we would use interprocedural alias\n \t\t analysis to determine if this mem is actually killed\n \t\t by this call.  */\n@@ -5484,7 +5484,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n   basic_block bb, current_block;\n   sbitmap *nonnull_local = npi->nonnull_local;\n   sbitmap *nonnull_killed = npi->nonnull_killed;\n-  \n+\n   /* Compute local properties, nonnull and killed.  A register will have\n      the nonnull property if at the end of the current block its value is\n      known to be nonnull.  The killed property indicates that somewhere in\n@@ -5607,11 +5607,11 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \n       delete_insn (last_insn);\n       if (compare_and_branch == 2)\n-        delete_insn (earliest);\n+\tdelete_insn (earliest);\n       purge_dead_edges (bb);\n \n       /* Don't check this block again.  (Note that BLOCK_END is\n-\t invalid here; we deleted the last instruction in the \n+\t invalid here; we deleted the last instruction in the\n \t block.)  */\n       block_reg[bb->index] = 0;\n     }\n@@ -5629,7 +5629,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \n    So, if every path leading to a conditional branch has an available memory\n    reference of that form, then we know the register can not have the value\n-   zero at the conditional branch.  \n+   zero at the conditional branch.\n \n    So we merely need to compute the local properies and propagate that data\n    around the cfg, then optimize where possible.\n@@ -5702,7 +5702,7 @@ delete_null_pointer_checks (f)\n       if (!condition\n \t  || (GET_CODE (condition) != NE && GET_CODE (condition) != EQ)\n \t  || GET_CODE (XEXP (condition, 1)) != CONST_INT\n-\t  || (XEXP (condition, 1) \n+\t  || (XEXP (condition, 1)\n \t      != CONST0_RTX (GET_MODE (XEXP (condition, 0)))))\n \tcontinue;\n \n@@ -5860,7 +5860,7 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n {\n   edge pred;\n   int visited_allocated_locally = 0;\n-  \n+\n \n   if (visited == NULL)\n     {\n@@ -5892,7 +5892,7 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n \t    break;\n \t}\n     }\n-  if (visited_allocated_locally) \n+  if (visited_allocated_locally)\n     free (visited);\n \n   return (pred == NULL);\n@@ -5950,7 +5950,7 @@ hoist_code ()\n \t\t    continue;\n \n \t\t  /* Note if the expression would reach the dominated block\n-\t\t     unimpared if it was placed at the end of BB. \n+\t\t     unimpared if it was placed at the end of BB.\n \n \t\t     Keep track of how many times this expression is hoistable\n \t\t     from a dominated block into BB.  */\n@@ -5975,7 +5975,7 @@ hoist_code ()\n \t\t}\n \t    }\n \t}\n-\t\t\n+\n       /* If we found nothing to hoist, then quit now.  */\n       if (! found)\n \tcontinue;\n@@ -6027,7 +6027,7 @@ hoist_code ()\n \t\t\tabort ();\n \n \t\t      insn = occr->insn;\n-\t\t \n+\n \t\t      set = single_set (insn);\n \t\t      if (! set)\n \t\t\tabort ();\n@@ -6098,10 +6098,10 @@ one_code_hoisting_pass ()\n \t    }\n \n     'i' is both loaded and stored to in the loop. Normally, gcse cannot move\n-    the load out since its live around the loop, and stored at the bottom \n-    of the loop. \n+    the load out since its live around the loop, and stored at the bottom\n+    of the loop.\n \n-      The 'Load Motion' referred to and implemented in this file is \n+      The 'Load Motion' referred to and implemented in this file is\n     an enhancement to gcse which when using edge based lcm, recognizes\n     this situation and allows gcse to move the load out of the loop.\n \n@@ -6137,13 +6137,13 @@ ldst_entry (x)\n       ptr->hash_index   = 0;\n       pre_ldst_mems     = ptr;\n     }\n-  \n+\n   return ptr;\n }\n \n /* Free up an individual ldst entry.  */\n \n-static void \n+static void\n free_ldst_entry (ptr)\n      struct ls_expr * ptr;\n {\n@@ -6158,7 +6158,7 @@ free_ldst_entry (ptr)\n static void\n free_ldst_mems ()\n {\n-  while (pre_ldst_mems) \n+  while (pre_ldst_mems)\n     {\n       struct ls_expr * tmp = pre_ldst_mems;\n \n@@ -6213,7 +6213,7 @@ find_rtx_in_ldst (x)\n      rtx x;\n {\n   struct ls_expr * ptr;\n-  \n+\n   for (ptr = pre_ldst_mems; ptr != NULL; ptr = ptr->next)\n     if (expr_equiv_p (ptr->pattern, x) && ! ptr->invalid)\n       return ptr;\n@@ -6258,31 +6258,31 @@ next_ls_expr (ptr)\n    side effects. These are the types of loads we consider for the\n    ld_motion list, otherwise we let the usual aliasing take care of it.  */\n \n-static int \n+static int\n simple_mem (x)\n      rtx x;\n {\n   if (GET_CODE (x) != MEM)\n     return 0;\n-  \n+\n   if (MEM_VOLATILE_P (x))\n     return 0;\n-  \n+\n   if (GET_MODE (x) == BLKmode)\n     return 0;\n \n   if (!rtx_varies_p (XEXP (x, 0), 0))\n     return 1;\n-  \n+\n   return 0;\n }\n \n-/* Make sure there isn't a buried reference in this pattern anywhere.  \n-   If there is, invalidate the entry for it since we're not capable \n-   of fixing it up just yet.. We have to be sure we know about ALL \n+/* Make sure there isn't a buried reference in this pattern anywhere.\n+   If there is, invalidate the entry for it since we're not capable\n+   of fixing it up just yet.. We have to be sure we know about ALL\n    loads since the aliasing code will allow all entries in the\n    ld_motion list to not-alias itself.  If we miss a load, we will get\n-   the wrong value since gcse might common it and we won't know to \n+   the wrong value since gcse might common it and we won't know to\n    fix it up.  */\n \n static void\n@@ -6302,7 +6302,7 @@ invalidate_any_buried_refs (x)\n \n   /* Recursively process the insn.  */\n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  \n+\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n@@ -6315,17 +6315,17 @@ invalidate_any_buried_refs (x)\n \n /* Find all the 'simple' MEMs which are used in LOADs and STORES. Simple\n    being defined as MEM loads and stores to symbols, with no\n-   side effects and no registers in the expression. If there are any \n+   side effects and no registers in the expression. If there are any\n    uses/defs which don't match this criteria, it is invalidated and\n    trimmed out later.  */\n \n-static void \n+static void\n compute_ld_motion_mems ()\n {\n   struct ls_expr * ptr;\n   basic_block bb;\n   rtx insn;\n-  \n+\n   pre_ldst_mems = NULL;\n \n   FOR_EACH_BB (bb)\n@@ -6355,15 +6355,15 @@ compute_ld_motion_mems ()\n \t\t      /* Make sure there isn't a buried load somewhere.  */\n \t\t      invalidate_any_buried_refs (src);\n \t\t    }\n-\t\t  \n+\n \t\t  /* Check for stores. Don't worry about aliased ones, they\n \t\t     will block any movement we might do later. We only care\n \t\t     about this exact pattern since those are the only\n \t\t     circumstance that we will ignore the aliasing info.  */\n \t\t  if (GET_CODE (dest) == MEM && simple_mem (dest))\n \t\t    {\n \t\t      ptr = ldst_entry (dest);\n-\t\t      \n+\n \t\t      if (GET_CODE (src) != MEM\n \t\t\t  && GET_CODE (src) != ASM_OPERANDS)\n \t\t\tptr->stores = alloc_INSN_LIST (insn, ptr->stores);\n@@ -6378,7 +6378,7 @@ compute_ld_motion_mems ()\n     }\n }\n \n-/* Remove any references that have been either invalidated or are not in the \n+/* Remove any references that have been either invalidated or are not in the\n    expression list for pre gcse.  */\n \n static void\n@@ -6391,18 +6391,18 @@ trim_ld_motion_mems ()\n     {\n       int del = ptr->invalid;\n       struct expr * expr = NULL;\n-      \n+\n       /* Delete if entry has been made invalid.  */\n-      if (!del) \n+      if (!del)\n \t{\n \t  unsigned int i;\n-\t  \n+\n \t  del = 1;\n \t  /* Delete if we cannot find this mem in the expression list.  */\n \t  for (i = 0; i < expr_hash_table_size && del; i++)\n \t    {\n-\t      for (expr = expr_hash_table[i]; \n-\t\t   expr != NULL; \n+\t      for (expr = expr_hash_table[i];\n+\t\t   expr != NULL;\n \t\t   expr = expr->next_same_hash)\n \t\tif (expr_equiv_p (expr->expr, ptr->pattern))\n \t\t  {\n@@ -6411,7 +6411,7 @@ trim_ld_motion_mems ()\n \t\t  }\n \t    }\n \t}\n-      \n+\n       if (del)\n \t{\n \t  if (last != NULL)\n@@ -6456,16 +6456,16 @@ update_ld_motion_stores (expr)\n \n   if ((mem_ptr = find_rtx_in_ldst (expr->expr)))\n     {\n-      /* We can try to find just the REACHED stores, but is shouldn't \n-\t matter to set the reaching reg everywhere...  some might be \n+      /* We can try to find just the REACHED stores, but is shouldn't\n+\t matter to set the reaching reg everywhere...  some might be\n \t dead and should be eliminated later.  */\n \n       /* We replace  SET mem = expr   with\n \t   SET reg = expr\n-\t   SET mem = reg , where reg is the \n+\t   SET mem = reg , where reg is the\n \t   reaching reg used in the load.  */\n       rtx list = mem_ptr->stores;\n-      \n+\n       for ( ; list != NULL_RTX; list = XEXP (list, 1))\n \t{\n \t  rtx insn = XEXP (list, 0);\n@@ -6477,7 +6477,7 @@ update_ld_motion_stores (expr)\n \t  /* If we've already copied it, continue.  */\n \t  if (expr->reaching_reg == src)\n \t    continue;\n-\t  \n+\n \t  if (gcse_file)\n \t    {\n \t      fprintf (gcse_file, \"PRE:  store updated with reaching reg \");\n@@ -6486,7 +6486,7 @@ update_ld_motion_stores (expr)\n \t      print_inline_rtx (gcse_file, insn, 8);\n \t      fprintf (gcse_file, \"\\n\");\n \t    }\n-\t  \n+\n \t  copy = gen_move_insn ( reg, SET_SRC (pat));\n \t  new = emit_insn_before (copy, insn);\n \t  record_one_set (REGNO (reg), new);\n@@ -6501,7 +6501,7 @@ update_ld_motion_stores (expr)\n \f\n /* Store motion code.  */\n \n-/* This is used to communicate the target bitvector we want to use in the \n+/* This is used to communicate the target bitvector we want to use in the\n    reg_set_info routine when called via the note_stores mechanism.  */\n static sbitmap * regvec;\n \n@@ -6525,7 +6525,7 @@ reg_set_info (dest, setter, data)\n     SET_BIT (*regvec, REGNO (dest));\n }\n \n-/* Return non-zero if the register operands of expression X are killed \n+/* Return non-zero if the register operands of expression X are killed\n    anywhere in basic block BB.  */\n \n static int\n@@ -6579,7 +6579,7 @@ store_ops_ok (x, bb)\n \n   i = GET_RTX_LENGTH (code) - 1;\n   fmt = GET_RTX_FORMAT (code);\n-  \n+\n   for (; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n@@ -6594,14 +6594,14 @@ store_ops_ok (x, bb)\n \t      x = tem;\n \t      goto repeat;\n \t    }\n-\t  \n+\n \t  if (! store_ops_ok (tem, bb))\n \t    return 0;\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n-\t  \n+\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n \t      if (! store_ops_ok (XVECEXP (x, i, j), bb))\n@@ -6627,7 +6627,7 @@ find_moveable_store (insn)\n     return;\n \n   dest = SET_DEST (dest);\n-  \n+\n   if (GET_CODE (dest) != MEM || MEM_VOLATILE_P (dest)\n       || GET_MODE (dest) == BLKmode)\n     return;\n@@ -6675,7 +6675,7 @@ compute_store_table ()\n \t  if (GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      bool clobbers_all = false;\n-#ifdef NON_SAVING_SETJMP \n+#ifdef NON_SAVING_SETJMP\n \t      if (NON_SAVING_SETJMP\n \t\t  && find_reg_note (insn, REG_SETJMP, NULL_RTX))\n \t\tclobbers_all = true;\n@@ -6686,24 +6686,24 @@ compute_store_table ()\n \t\t    || TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n \t\t  SET_BIT (reg_set_in_block[bb->index], regno);\n \t    }\n-\t  \n+\n \t  pat = PATTERN (insn);\n \t  note_stores (pat, reg_set_info, NULL);\n-\t  \n+\n \t  /* Now that we've marked regs, look for stores.  */\n \t  if (GET_CODE (pat) == SET)\n \t    find_moveable_store (insn);\n \t}\n     }\n \n   ret = enumerate_ldsts ();\n-  \n+\n   if (gcse_file)\n     {\n       fprintf (gcse_file, \"Store Motion Expressions.\\n\");\n       print_ldst_list (gcse_file);\n     }\n-  \n+\n   return ret;\n }\n \n@@ -6718,7 +6718,7 @@ load_kills_store (x, store_pattern)\n   return 0;\n }\n \n-/* Go through the entire insn X, looking for any loads which might alias \n+/* Go through the entire insn X, looking for any loads which might alias\n    STORE_PATTERN.  Return 1 if found.  */\n \n static int\n@@ -6732,7 +6732,7 @@ find_loads (x, store_pattern)\n   if (!x)\n     return 0;\n \n-  if (GET_CODE (x) == SET) \n+  if (GET_CODE (x) == SET)\n     x = SET_SRC (x);\n \n   if (GET_CODE (x) == MEM)\n@@ -6743,7 +6743,7 @@ find_loads (x, store_pattern)\n \n   /* Recursively process the insn.  */\n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  \n+\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0 && !ret; i--)\n     {\n       if (fmt[i] == 'e')\n@@ -6755,23 +6755,23 @@ find_loads (x, store_pattern)\n   return ret;\n }\n \n-/* Check if INSN kills the store pattern X (is aliased with it).  \n+/* Check if INSN kills the store pattern X (is aliased with it).\n    Return 1 if it it does.  */\n \n-static int \n+static int\n store_killed_in_insn (x, insn)\n      rtx x, insn;\n {\n   if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n     return 0;\n-  \n+\n   if (GET_CODE (insn) == CALL_INSN)\n     {\n       /* A normal or pure call might read from pattern,\n \t but a const call will not.  */\n       return ! CONST_OR_PURE_CALL_P (insn) || pure_call_p (insn);\n     }\n-  \n+\n   if (GET_CODE (PATTERN (insn)) == SET)\n     {\n       rtx pat = PATTERN (insn);\n@@ -6789,19 +6789,19 @@ store_killed_in_insn (x, insn)\n /* Returns 1 if the expression X is loaded or clobbered on or after INSN\n    within basic block BB.  */\n \n-static int \n+static int\n store_killed_after (x, insn, bb)\n      rtx x, insn;\n      basic_block bb;\n {\n   rtx last = bb->end;\n-   \n+\n   if (insn == last)\n     return 0;\n \n   /* Check if the register operands of the store are OK in this block.\n-     Note that if registers are changed ANYWHERE in the block, we'll \n-     decide we can't move it, regardless of whether it changed above \n+     Note that if registers are changed ANYWHERE in the block, we'll\n+     decide we can't move it, regardless of whether it changed above\n      or below the store. This could be improved by checking the register\n      operands while lookinng for aliasing in each insn.  */\n   if (!store_ops_ok (XEXP (x, 0), bb))\n@@ -6810,13 +6810,13 @@ store_killed_after (x, insn, bb)\n   for ( ; insn && insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n     if (store_killed_in_insn (x, insn))\n       return 1;\n-   \n+\n   return 0;\n }\n \n /* Returns 1 if the expression X is loaded or clobbered on or before INSN\n    within basic block BB.  */\n-static int \n+static int\n store_killed_before (x, insn, bb)\n      rtx x, insn;\n      basic_block bb;\n@@ -6825,10 +6825,10 @@ store_killed_before (x, insn, bb)\n \n   if (insn == first)\n     return store_killed_in_insn (x, insn);\n-   \n+\n   /* Check if the register operands of the store are OK in this block.\n-     Note that if registers are changed ANYWHERE in the block, we'll \n-     decide we can't move it, regardless of whether it changed above \n+     Note that if registers are changed ANYWHERE in the block, we'll\n+     decide we can't move it, regardless of whether it changed above\n      or below the store. This could be improved by checking the register\n      operands while lookinng for aliasing in each insn.  */\n   if (!store_ops_ok (XEXP (x, 0), bb))\n@@ -6837,7 +6837,7 @@ store_killed_before (x, insn, bb)\n   for ( ; insn && insn != PREV_INSN (first); insn = PREV_INSN (insn))\n     if (store_killed_in_insn (x, insn))\n       return 1;\n-   \n+\n   return 0;\n }\n \n@@ -6848,7 +6848,7 @@ store_killed_before (x, insn, bb)\n    determine which ones are not killed by aliasing, and generate\n    the appropriate vectors for gen and killed.  */\n static void\n-build_store_vectors () \n+build_store_vectors ()\n {\n   basic_block bb, b;\n   rtx insn, st;\n@@ -6863,7 +6863,7 @@ build_store_vectors ()\n   sbitmap_vector_zero (st_antloc, last_basic_block);\n \n   for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n-    { \n+    {\n       /* Put all the stores into either the antic list, or the avail list,\n \t or both.  */\n       rtx store_list = ptr->stores;\n@@ -6873,7 +6873,7 @@ build_store_vectors ()\n \t{\n \t  insn = XEXP (st, 0);\n \t  bb = BLOCK_FOR_INSN (insn);\n-\t  \n+\n \t  if (!store_killed_after (ptr->pattern, insn, bb))\n \t    {\n \t      /* If we've already seen an availale expression in this block,\n@@ -6902,19 +6902,19 @@ build_store_vectors ()\n \t      AVAIL_STORE_LIST (ptr) = alloc_INSN_LIST (insn,\n \t\t\t\t\t\t\tAVAIL_STORE_LIST (ptr));\n \t    }\n-\t  \n+\n \t  if (!store_killed_before (ptr->pattern, insn, bb))\n \t    {\n \t      SET_BIT (st_antloc[BLOCK_NUM (insn)], ptr->index);\n \t      ANTIC_STORE_LIST (ptr) = alloc_INSN_LIST (insn,\n \t\t\t\t\t\t\tANTIC_STORE_LIST (ptr));\n \t    }\n \t}\n-      \n+\n       /* Free the original list of store insns.  */\n       free_INSN_LIST_list (&store_list);\n     }\n-\t  \n+\n   ae_kill = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n   sbitmap_vector_zero (ae_kill, last_basic_block);\n \n@@ -6928,15 +6928,15 @@ build_store_vectors ()\n \t  {\n \t    /* The anticipatable expression is not killed if it's gen'd.  */\n \t    /*\n-\t      We leave this check out for now. If we have a code sequence \n+\t      We leave this check out for now. If we have a code sequence\n \t      in a block which looks like:\n \t\t\tST MEMa = x\n \t\t\tL     y = MEMa\n \t\t\tST MEMa = z\n \t      We should flag this as having an ANTIC expression, NOT\n \t      transparent, NOT killed, and AVAIL.\n \t      Unfortunately, since we haven't re-written all loads to\n-\t      use the reaching reg, we'll end up doing an incorrect \n+\t      use the reaching reg, we'll end up doing an incorrect\n \t      Load in the middle here if we push the store down. It happens in\n \t\t    gcc.c-torture/execute/960311-1.c with -O3\n \t      If we always kill it in this case, we'll sometimes do\n@@ -6952,7 +6952,7 @@ build_store_vectors ()\n      we better mark the store killed here, or we might not store to\n      it at all.  If we knew it was abort, we wouldn't have to store,\n      but we don't know that for sure.  */\n-  if (gcse_file) \n+  if (gcse_file)\n     {\n       fprintf (gcse_file, \"ST_avail and ST_antic (shown under loads..)\\n\");\n       print_ldst_list (gcse_file);\n@@ -6963,10 +6963,10 @@ build_store_vectors ()\n     }\n }\n \n-/* Insert an instruction at the begining of a basic block, and update \n+/* Insert an instruction at the begining of a basic block, and update\n    the BLOCK_HEAD if needed.  */\n \n-static void \n+static void\n insert_insn_start_bb (insn, bb)\n      rtx insn;\n      basic_block bb;\n@@ -7017,7 +7017,7 @@ insert_store (expr, e)\n \n   reg = expr->reaching_reg;\n   insn = gen_move_insn (expr->pattern, reg);\n-  \n+\n   /* If we are inserting this expression on ALL predecessor edges of a BB,\n      insert it at the start of the BB, and reset the insert bits on the other\n      edges so we don't try to insert it on the other edges.  */\n@@ -7043,7 +7043,7 @@ insert_store (expr, e)\n       insert_insn_start_bb (insn, bb);\n       return 0;\n     }\n-  \n+\n   /* We can't insert on this edge, so we'll insert at the head of the\n      successors block.  See Morgan, sec 10.5.  */\n   if ((e->flags & EDGE_ABNORMAL) == EDGE_ABNORMAL)\n@@ -7053,15 +7053,15 @@ insert_store (expr, e)\n     }\n \n   insert_insn_on_edge (insn, e);\n-  \n+\n   if (gcse_file)\n     {\n       fprintf (gcse_file, \"STORE_MOTION  insert insn on edge (%d, %d):\\n\",\n \t       e->src->index, e->dest->index);\n       print_inline_rtx (gcse_file, insn, 6);\n       fprintf (gcse_file, \"\\n\");\n     }\n-  \n+\n   return 1;\n }\n \n@@ -7073,20 +7073,20 @@ replace_store_insn (reg, del, bb)\n      basic_block bb;\n {\n   rtx insn;\n-  \n+\n   insn = gen_move_insn (reg, SET_SRC (PATTERN (del)));\n   insn = emit_insn_after (insn, del);\n-  \n+\n   if (gcse_file)\n     {\n-      fprintf (gcse_file, \n+      fprintf (gcse_file,\n \t       \"STORE_MOTION  delete insn in BB %d:\\n      \", bb->index);\n       print_inline_rtx (gcse_file, del, 6);\n       fprintf (gcse_file, \"\\nSTORE MOTION  replaced with insn:\\n      \");\n       print_inline_rtx (gcse_file, insn, 6);\n       fprintf (gcse_file, \"\\n\");\n     }\n-  \n+\n   delete_insn (del);\n }\n \n@@ -7103,18 +7103,18 @@ delete_store (expr, bb)\n \n   if (expr->reaching_reg == NULL_RTX)\n     expr->reaching_reg = gen_reg_rtx (GET_MODE (expr->pattern));\n-  \n \n-  /* If there is more than 1 store, the earlier ones will be dead, \n-     but it doesn't hurt to replace them here.  */  \n+\n+  /* If there is more than 1 store, the earlier ones will be dead,\n+     but it doesn't hurt to replace them here.  */\n   reg = expr->reaching_reg;\n-  \n+\n   for (i = AVAIL_STORE_LIST (expr); i; i = XEXP (i, 1))\n     {\n       del = XEXP (i, 0);\n       if (BLOCK_FOR_INSN (del) == bb)\n \t{\n-\t  /* We know there is only one since we deleted redundant \n+\t  /* We know there is only one since we deleted redundant\n \t     ones during the available computation.  */\n \t  replace_store_insn (reg, del, bb);\n \t  break;\n@@ -7124,11 +7124,11 @@ delete_store (expr, bb)\n \n /* Free memory used by store motion.  */\n \n-static void \n+static void\n free_store_memory ()\n {\n   free_ldst_mems ();\n-  \n+\n   if (ae_gen)\n     sbitmap_vector_free (ae_gen);\n   if (ae_kill)\n@@ -7143,7 +7143,7 @@ free_store_memory ()\n     sbitmap_vector_free (pre_delete_map);\n   if (reg_set_in_block)\n     sbitmap_vector_free (reg_set_in_block);\n-  \n+\n   ae_gen = ae_kill = transp = st_antloc = NULL;\n   pre_insert_map = pre_delete_map = reg_set_in_block = NULL;\n }\n@@ -7181,8 +7181,8 @@ store_motion ()\n   add_noreturn_fake_exit_edges ();\n   build_store_vectors ();\n \n-  edge_list = pre_edge_rev_lcm (gcse_file, num_stores, transp, ae_gen, \n-\t\t\t\tst_antloc, ae_kill, &pre_insert_map, \n+  edge_list = pre_edge_rev_lcm (gcse_file, num_stores, transp, ae_gen,\n+\t\t\t\tst_antloc, ae_kill, &pre_insert_map,\n \t\t\t\t&pre_delete_map);\n \n   /* Now we want to insert the new stores which are going to be needed.  */"}, {"sha": "978ae96aa0fdb907ce6b83163a8dd5284631a9bc", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -53,7 +53,7 @@ struct ggc_root\n static struct ggc_root *roots;\n \n /* Add BASE as a new garbage collection root.  It is an array of\n-   length NELT with each element SIZE bytes long.  CB is a \n+   length NELT with each element SIZE bytes long.  CB is a\n    function that will be called with a pointer to each element\n    of the array; it is the intention that CB call the appropriate\n    routine to mark gc-able memory for that element.  */\n@@ -103,7 +103,7 @@ ggc_mark_roots ()\n   const struct ggc_cache_tab *const *ct;\n   const struct ggc_cache_tab *cti;\n   size_t i;\n-  \n+\n   for (rt = gt_ggc_deletable_rtab; *rt; rt++)\n     for (rti = *rt; rti->base != NULL; rti++)\n       memset (rti->base, 0, rti->stride);\n@@ -179,7 +179,7 @@ ggc_mark_rtx_children_1 (r)\n   int i;\n   rtx next_rtx;\n \n-  do \n+  do\n     {\n       enum rtx_code code = GET_CODE (r);\n       /* This gets set to a child rtx to eliminate tail recursion.  */\n@@ -244,12 +244,12 @@ ggc_mark_rtx_children_1 (r)\n \t    case 'e': case 'u':\n \t      exp = XEXP (r, i);\n \t      if (ggc_test_and_set_mark (exp))\n-\t\t{ \n-\t\t  if (next_rtx == NULL) \n-\t\t    next_rtx = exp; \n-\t\t  else \n+\t\t{\n+\t\t  if (next_rtx == NULL)\n+\t\t    next_rtx = exp;\n+\t\t  else\n \t\t    ggc_mark_rtx_children (exp);\n-\t\t} \n+\t\t}\n \t      break;\n \t    case 'V': case 'E':\n \t      gt_ggc_m_rtvec_def (XVEC (r, i));\n@@ -342,17 +342,17 @@ ggc_print_common_statistics (stream, stats)\n     }\n \n   /* Print the statistics for trees.  */\n-  fprintf (stream, \"\\n%-17s%10s %16s %10s\\n\", \"Tree\", \n+  fprintf (stream, \"\\n%-17s%10s %16s %10s\\n\", \"Tree\",\n \t   \"Number\", \"Bytes\", \"% Total\");\n   for (code = 0; code < MAX_TREE_CODES; ++code)\n-    if (ggc_stats->num_trees[code]) \n+    if (ggc_stats->num_trees[code])\n       {\n \tfprintf (stream, \"%-17s%10u%16ld%c %10.3f\\n\",\n \t\t tree_code_name[code],\n \t\t ggc_stats->num_trees[code],\n \t\t SCALE (ggc_stats->size_trees[code]),\n \t\t LABEL (ggc_stats->size_trees[code]),\n-\t\t (100 * ((double) ggc_stats->size_trees[code]) \n+\t\t (100 * ((double) ggc_stats->size_trees[code])\n \t\t  / ggc_stats->total_size_trees));\n       }\n   fprintf (stream,\n@@ -362,17 +362,17 @@ ggc_print_common_statistics (stream, stats)\n \t   LABEL (ggc_stats->total_size_trees));\n \n   /* Print the statistics for RTL.  */\n-  fprintf (stream, \"\\n%-17s%10s %16s %10s\\n\", \"RTX\", \n+  fprintf (stream, \"\\n%-17s%10s %16s %10s\\n\", \"RTX\",\n \t   \"Number\", \"Bytes\", \"% Total\");\n   for (code = 0; code < NUM_RTX_CODE; ++code)\n-    if (ggc_stats->num_rtxs[code]) \n+    if (ggc_stats->num_rtxs[code])\n       {\n \tfprintf (stream, \"%-17s%10u%16ld%c %10.3f\\n\",\n \t\t rtx_name[code],\n \t\t ggc_stats->num_rtxs[code],\n \t\t SCALE (ggc_stats->size_rtxs[code]),\n \t\t LABEL (ggc_stats->size_rtxs[code]),\n-\t\t (100 * ((double) ggc_stats->size_rtxs[code]) \n+\t\t (100 * ((double) ggc_stats->size_rtxs[code])\n \t\t  / ggc_stats->total_size_rtxs));\n       }\n   fprintf (stream,"}, {"sha": "0f59153ad36e700c96aea199032602b2286ff82f", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -59,7 +59,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define USING_MALLOC_PAGE_GROUPS\n #endif\n \n-/* Stategy: \n+/* Stategy:\n \n    This garbage-collecting allocator allocates objects on one of a set\n    of pages.  Each page can allocate objects of a single size only;\n@@ -74,7 +74,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Each page-entry also has a context depth, which is used to track\n    pushing and popping of allocation contexts.  Only objects allocated\n-   in the current (highest-numbered) context may be collected.  \n+   in the current (highest-numbered) context may be collected.\n \n    Page entries are arranged in an array of singly-linked lists.  The\n    array is indexed by the allocation size, in bits, of the pages on\n@@ -133,7 +133,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    The bottommost HOST_PAGE_SIZE_BITS are ignored, since page-entry\n    pages are aligned on system page boundaries.  The next most\n    significant PAGE_L2_BITS and PAGE_L1_BITS are the second and first\n-   index values in the lookup table, respectively.  \n+   index values in the lookup table, respectively.\n \n    For 32-bit architectures and the settings below, there are no\n    leftover bits.  For architectures with wider pointers, the lookup\n@@ -206,7 +206,7 @@ static size_t object_size_table[NUM_ORDERS];\n \n /* A page_entry records the status of an allocation page.  This\n    structure is dynamically sized to fit the bitmap in_use_p.  */\n-typedef struct page_entry \n+typedef struct page_entry\n {\n   /* The next page-entry with objects of the same size, or NULL if\n      this is the last page-entry.  */\n@@ -411,7 +411,7 @@ ggc_allocated_p (p)\n   return base[L1] && base[L1][L2];\n }\n \n-/* Traverse the page table and find the entry for a page. \n+/* Traverse the page table and find the entry for a page.\n    Die (probably) if the object wasn't allocated via GC.  */\n \n static inline page_entry *\n@@ -731,7 +731,7 @@ alloc_page (order)\n   set_page_table_entry (page, entry);\n \n   if (GGC_DEBUG_LEVEL >= 2)\n-    fprintf (G.debug_file, \n+    fprintf (G.debug_file,\n \t     \"Allocating page at %p, object size=%lu, data %p-%p\\n\",\n \t     (PTR) entry, (unsigned long) OBJECT_SIZE (order), page,\n \t     page + entry_size - 1);\n@@ -746,7 +746,7 @@ free_page (entry)\n      page_entry *entry;\n {\n   if (GGC_DEBUG_LEVEL >= 2)\n-    fprintf (G.debug_file, \n+    fprintf (G.debug_file,\n \t     \"Deallocating page at %p, data %p-%p\\n\", (PTR) entry,\n \t     entry->page, entry->page + entry->bytes - 1);\n \n@@ -816,7 +816,7 @@ release_pages ()\n     if (g->in_use == 0)\n       {\n \t*gp = g->next;\n-        G.bytes_mapped -= g->alloc_size;\n+\tG.bytes_mapped -= g->alloc_size;\n \tfree (g->allocation);\n       }\n     else\n@@ -827,16 +827,16 @@ release_pages ()\n /* This table provides a fast way to determine ceil(log_2(size)) for\n    allocation requests.  The minimum allocation size is eight bytes.  */\n \n-static unsigned char size_lookup[257] = \n+static unsigned char size_lookup[257] =\n {\n-  3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, \n-  4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, \n-  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, \n-  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, \n-  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, \n-  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, \n+  3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,\n+  4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n-  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, \n   7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n@@ -878,11 +878,11 @@ ggc_alloc (size)\n     {\n       struct page_entry *new_entry;\n       new_entry = alloc_page (order);\n-      \n+\n       /* If this is the only entry, it's also the tail.  */\n       if (entry == NULL)\n \tG.page_tails[order] = new_entry;\n-     \n+\n       /* Put new pages at the head of the page list.  */\n       new_entry->next = entry;\n       entry = new_entry;\n@@ -904,7 +904,7 @@ ggc_alloc (size)\n       unsigned hint = entry->next_bit_hint;\n       word = hint / HOST_BITS_PER_LONG;\n       bit = hint % HOST_BITS_PER_LONG;\n-      \n+\n       /* If the hint didn't work, scan the bitmap from the beginning.  */\n       if ((entry->in_use_p[word] >> bit) & 1)\n \t{\n@@ -953,7 +953,7 @@ ggc_alloc (size)\n   G.allocated += OBJECT_SIZE (order);\n \n   if (GGC_DEBUG_LEVEL >= 3)\n-    fprintf (G.debug_file, \n+    fprintf (G.debug_file,\n \t     \"Allocating object, requested size=%lu, actual=%lu at %p on %p\\n\",\n \t     (unsigned long) size, (unsigned long) OBJECT_SIZE (order), result,\n \t     (PTR) entry);\n@@ -986,7 +986,7 @@ ggc_set_mark (p)\n   bit = (((const char *) p) - entry->page) / OBJECT_SIZE (entry->order);\n   word = bit / HOST_BITS_PER_LONG;\n   mask = (unsigned long) 1 << (bit % HOST_BITS_PER_LONG);\n-  \n+\n   /* If the bit was previously set, skip it.  */\n   if (entry->in_use_p[word] & mask)\n     return 1;\n@@ -1001,7 +1001,7 @@ ggc_set_mark (p)\n   return 0;\n }\n \n-/* Return 1 if P has been marked, zero otherwise. \n+/* Return 1 if P has been marked, zero otherwise.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */\n \n@@ -1026,7 +1026,7 @@ ggc_marked_p (p)\n   bit = (((const char *) p) - entry->page) / OBJECT_SIZE (entry->order);\n   word = bit / HOST_BITS_PER_LONG;\n   mask = (unsigned long) 1 << (bit % HOST_BITS_PER_LONG);\n-  \n+\n   return (entry->in_use_p[word] & mask) != 0;\n }\n \n@@ -1150,15 +1150,15 @@ ggc_recalculate_in_use_p (p)\n   unsigned int i;\n   size_t num_objects;\n \n-  /* Because the past-the-end bit in in_use_p is always set, we \n+  /* Because the past-the-end bit in in_use_p is always set, we\n      pretend there is one additional object.  */\n   num_objects = OBJECTS_PER_PAGE (p->order) + 1;\n \n   /* Reset the free object count.  */\n   p->num_free_objects = num_objects;\n \n   /* Combine the IN_USE_P and SAVE_IN_USE_P arrays.  */\n-  for (i = 0; \n+  for (i = 0;\n        i < CEIL (BITMAP_SIZE (num_objects),\n \t\t sizeof (*p->in_use_p));\n        ++i)\n@@ -1178,7 +1178,7 @@ ggc_recalculate_in_use_p (p)\n     abort ();\n }\n \n-/* Decrement the `GC context'.  All objects allocated since the \n+/* Decrement the `GC context'.  All objects allocated since the\n    previous ggc_push_context are migrated to the outer context.  */\n \n void\n@@ -1249,7 +1249,7 @@ clear_marks ()\n \t  memset (p->in_use_p, 0, bitmap_size);\n \n \t  /* Make sure the one-past-the-end bit is always set.  */\n-\t  p->in_use_p[num_objects / HOST_BITS_PER_LONG] \n+\t  p->in_use_p[num_objects / HOST_BITS_PER_LONG]\n \t    = ((unsigned long) 1 << (num_objects % HOST_BITS_PER_LONG));\n \t}\n     }\n@@ -1273,7 +1273,7 @@ sweep_pages ()\n       size_t live_objects;\n       page_entry *p, *previous;\n       int done;\n-\t\n+\n       p = G.pages[order];\n       if (p == NULL)\n \tcontinue;\n@@ -1351,7 +1351,7 @@ sweep_pages ()\n \n \t  previous = p;\n \t  p = next;\n-\t} \n+\t}\n       while (! done);\n \n       /* Now, restore the in_use_p vectors for any pages from contexts\n@@ -1421,13 +1421,13 @@ ggc_collect ()\n      sweep phase.  */\n   G.allocated = 0;\n \n-  /* Release the pages we freed the last time we collected, but didn't \n+  /* Release the pages we freed the last time we collected, but didn't\n      reuse in the interim.  */\n   release_pages ();\n \n   clear_marks ();\n   ggc_mark_roots ();\n-  \n+\n #ifdef GGC_POISON\n   poison_pages ();\n #endif\n@@ -1461,7 +1461,7 @@ ggc_print_statistics ()\n \n   /* Clear the statistics.  */\n   memset (&stats, 0, sizeof (stats));\n-  \n+\n   /* Make sure collection will really occur.  */\n   G.allocated_last_gc = 0;\n \n@@ -1472,7 +1472,7 @@ ggc_print_statistics ()\n      there as part of the total allocated memory.  */\n   release_pages ();\n \n-  /* Collect some information about the various sizes of \n+  /* Collect some information about the various sizes of\n      allocation.  */\n   fprintf (stderr, \"\\n%-5s %10s  %10s  %10s\\n\",\n \t   \"Size\", \"Allocated\", \"Used\", \"Overhead\");\n@@ -1495,7 +1495,7 @@ ggc_print_statistics ()\n       for (p = G.pages[i]; p; p = p->next)\n \t{\n \t  allocated += p->bytes;\n-\t  in_use += \n+\t  in_use +=\n \t    (OBJECTS_PER_PAGE (i) - p->num_free_objects) * OBJECT_SIZE (i);\n \n \t  overhead += (sizeof (page_entry) - sizeof (long)"}, {"sha": "d3b53279241f1efc211efd2db34bd9749443af9a", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -251,7 +251,7 @@ size_t\n ggc_get_size (p)\n      const void *p;\n {\n-  struct ggc_mem *x \n+  struct ggc_mem *x\n     = (struct ggc_mem *) ((const char *)p - offsetof (struct ggc_mem, u));\n   return x->size;\n }\n@@ -360,7 +360,7 @@ ggc_collect ()\n \n /* Called once to initialize the garbage collector.  */\n \n-void \n+void\n init_ggc ()\n {\n   G.allocated_last_gc = GGC_MIN_LAST_ALLOCATED;\n@@ -383,7 +383,7 @@ ggc_push_context ()\n /* Finish a GC context.  Any uncollected memory in the new context\n    will be merged with the old context.  */\n \n-void \n+void\n ggc_pop_context ()\n {\n   G.context--;\n@@ -425,7 +425,7 @@ debug_ggc_tree (p, indent)\n   for (i = 0; i < indent; ++i)\n     putc (' ', stderr);\n   fprintf (stderr, \"%lx %p\\n\", (unsigned long)PTR_KEY (p), p);\n- \n+\n   if (p->sub[1])\n     debug_ggc_tree (p->sub[1], indent + 1);\n }\n@@ -490,7 +490,7 @@ ggc_print_statistics ()\n \n   /* Clear the statistics.  */\n   memset (&stats, 0, sizeof (stats));\n-  \n+\n   /* Make sure collection will really occur.  */\n   G.allocated_last_gc = 0;\n "}, {"sha": "b28e11a88e654a04172b25aa75274ffd253a8f69", "filename": "gcc/ggc.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -33,7 +33,7 @@ extern const char digit_vector[];\t/* \"0\" .. \"9\" */\n extern void ggc_add_root\t\tPARAMS ((void *base, int nelt,\n \t\t\t\t\t\t int size, void (*)(void *)));\n \n-/* Structures for the easy way to mark roots.  \n+/* Structures for the easy way to mark roots.\n    In an array, terminated by having base == NULL.*/\n struct ggc_root_tab {\n   void *base;\n@@ -142,7 +142,7 @@ extern void ggc_collect\t\t\tPARAMS ((void));\n    pointers in this data structure should not be traversed.  */\n extern int ggc_set_mark\t\t\tPARAMS ((const void *));\n \n-/* Return 1 if P has been marked, zero otherwise. \n+/* Return 1 if P has been marked, zero otherwise.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */\n extern int ggc_marked_p\t\t\tPARAMS ((const void *));\n@@ -151,16 +151,16 @@ extern int ggc_marked_p\t\t\tPARAMS ((const void *));\n \n /* This structure contains the statistics common to all collectors.\n    Particular collectors can extend this structure.  */\n-typedef struct ggc_statistics \n+typedef struct ggc_statistics\n {\n   /* The Ith element is the number of nodes allocated with code I.  */\n   unsigned num_trees[256];\n-  /* The Ith element is the number of bytes allocated by nodes with \n+  /* The Ith element is the number of bytes allocated by nodes with\n      code I.  */\n   size_t size_trees[256];\n   /* The Ith element is the number of nodes allocated with code I.  */\n   unsigned num_rtxs[256];\n-  /* The Ith element is the number of bytes allocated by nodes with \n+  /* The Ith element is the number of bytes allocated by nodes with\n      code I.  */\n   size_t size_rtxs[256];\n   /* The total size of the tree nodes allocated.  */"}, {"sha": "aaa789607c09a32901c614681a9b910acc871481", "filename": "gcc/global.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -52,7 +52,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    1. Assign allocation-numbers (allocnos) to the pseudo-registers\n    still needing allocations and to the pseudo-registers currently\n    allocated by local-alloc which may be spilled by reload.\n-   Set up tables reg_allocno and allocno_reg to map \n+   Set up tables reg_allocno and allocno_reg to map\n    reg numbers to allocnos and vice versa.\n    max_allocno gets the number of allocnos in use.\n \n@@ -483,7 +483,7 @@ global_alloc (file)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (regs_ever_live[i])\n       local_reg_n_refs[i] = 0, local_reg_freq[i] = 0;\n-\t\n+\n   allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n \n   /* We used to use alloca here, but the size of what it would try to\n@@ -549,7 +549,7 @@ global_alloc (file)\n \t}\n \n       qsort (allocno_order, max_allocno, sizeof (int), allocno_compare);\n-      \n+\n       prune_preferences ();\n \n       if (file)\n@@ -884,18 +884,18 @@ expand_preferences ()\n \f\n /* Prune the preferences for global registers to exclude registers that cannot\n    be used.\n-   \n+\n    Compute `regs_someone_prefers', which is a bitmask of the hard registers\n    that are preferred by conflicting registers of lower priority.  If possible,\n    we will avoid using these registers.  */\n-   \n+\n static void\n prune_preferences ()\n {\n   int i;\n   int num;\n   int *allocno_to_order = (int *) xmalloc (max_allocno * sizeof (int));\n-  \n+\n   /* Scan least most important to most important.\n      For each allocno, remove from preferences registers that cannot be used,\n      either because of conflicts or register type.  Then compute all registers\n@@ -1028,7 +1028,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n   COPY_HARD_REG_SET (used, used1);\n   IOR_COMPL_HARD_REG_SET (used, regs_used_so_far);\n   IOR_HARD_REG_SET (used, allocno[num].regs_someone_prefers);\n-  \n+\n   best_reg = -1;\n   for (i = FIRST_PSEUDO_REGISTER, pass = 0;\n        pass <= 1 && i >= FIRST_PSEUDO_REGISTER;\n@@ -1073,7 +1073,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \n      Remove from the preferred registers and conflicting registers.  Note that\n      additional conflicts may have been added after `prune_preferences' was\n-     called. \n+     called.\n \n      First do this for those register with copy preferences, then all\n      preferred registers.  */\n@@ -1156,7 +1156,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n     }\n  no_prefs:\n \n-  /* If we haven't succeeded yet, try with caller-saves. \n+  /* If we haven't succeeded yet, try with caller-saves.\n      We need not check to see if the current function has nonlocal\n      labels because we don't put any pseudos that are live over calls in\n      registers in that case.  */\n@@ -1176,7 +1176,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t    CLEAR_HARD_REG_SET (new_losers);\n \t  else\n \t    COPY_HARD_REG_SET (new_losers, losers);\n-\t    \n+\n \t  IOR_HARD_REG_SET(new_losers, losing_caller_save_reg_set);\n \t  find_reg (num, new_losers, alt_regs_p, 1, retrying);\n \t  if (reg_renumber[allocno[num].reg] >= 0)\n@@ -1223,7 +1223,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t      /* We explicitly evaluate the divide results into temporary\n \t\t variables so as to avoid excess precision problems that occur\n \t\t on an i386-unknown-sysv4.2 (unixware) host.  */\n-\t\t \n+\n \t      double tmp1 = ((double) local_reg_freq[regno]\n \t\t\t    / local_reg_live_length[regno]);\n \t      double tmp2 = ((double) allocno[num].freq\n@@ -1593,7 +1593,7 @@ mark_reg_live_nc (regno, mode)\n    that SRC is a register.  If SRC or the first operand of SRC is a register,\n    try to set a preference.  If one of the two is a hard register and the other\n    is a pseudo-register, mark the preference.\n-   \n+\n    Note that we are not as aggressive as local-alloc in trying to tie a\n    pseudo-register to a hard register.  */\n \n@@ -1713,7 +1713,7 @@ mark_elimination (from, to)\n \n   FOR_EACH_BB (bb)\n     {\n-      regset r = bb->global_live_at_start; \n+      regset r = bb->global_live_at_start;\n       if (REGNO_REG_SET_P (r, from))\n \t{\n \t  CLEAR_REGNO_REG_SET (r, from);\n@@ -1741,7 +1741,7 @@ reg_becomes_live (reg, setter, regs_set)\n \n   if (GET_CODE (reg) != REG)\n     return;\n-  \n+\n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n@@ -1818,7 +1818,7 @@ build_insn_chain (first)\n \t\t   : reg_renumber[i] >= 0)\n \t\t SET_REGNO_REG_SET (live_relevant_regs, i);\n \t     });\n- \t}\n+\t}\n \n       if (GET_CODE (first) != NOTE && GET_CODE (first) != BARRIER)\n \t{\n@@ -1906,7 +1906,7 @@ dump_conflicts (file)\n   for (i = 0; i < max_allocno; i++)\n     {\n       if (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n-        continue;\n+\tcontinue;\n       nregs++;\n     }\n   fprintf (file, \";; %d regs to allocate:\", nregs);\n@@ -1958,13 +1958,13 @@ dump_global_regs (file)\n      FILE *file;\n {\n   int i, j;\n-  \n+\n   fprintf (file, \";; Register dispositions:\\n\");\n   for (i = FIRST_PSEUDO_REGISTER, j = 0; i < max_regno; i++)\n     if (reg_renumber[i] >= 0)\n       {\n \tfprintf (file, \"%d in %d  \", i, reg_renumber[i]);\n-        if (++j % 6 == 0)\n+\tif (++j % 6 == 0)\n \t  fprintf (file, \"\\n\");\n       }\n "}, {"sha": "1033df38928cd53772c9fd678330bba1cc673b79", "filename": "gcc/graph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -1,4 +1,4 @@\n-/* Header file for graph routines.  \n+/* Header file for graph routines.\n    Copyright (C) 1999 Free Software Foundation, Inc.\n \n This file is part of GCC."}, {"sha": "273393b34df847f50aa042491bdbac7aac6e8b95", "filename": "gcc/gthr-dce.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-dce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-dce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-dce.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -146,17 +146,17 @@ __gthread_objc_thread_detach(void (*func)(void *), void *arg)\n \n   if (!__gthread_active_p ())\n     return NULL;\n- \n+\n   if ( !(pthread_create(&new_thread_handle, pthread_attr_default,\n-  \t\t\t(void *)func, arg)) )\n+\t\t\t(void *)func, arg)) )\n     {\n       /* ??? May not work! (64bit) */\n       thread_id = *(objc_thread_t *)&new_thread_handle;\n       pthread_detach(&new_thread_handle); /* Fully detach thread.  */\n     }\n   else\n     thread_id = NULL;\n-  \n+\n   return thread_id;\n }\n \n@@ -182,7 +182,7 @@ __gthread_objc_thread_set_priority(int priority)\n       sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n       break;\n     }\n-    \n+\n   /* Change the priority.  */\n   if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n     return 0;\n@@ -200,7 +200,7 @@ __gthread_objc_thread_get_priority(void)\n   if (__gthread_active_p ())\n     {\n       if ((sys_priority = pthread_getprio(pthread_self())) >= 0)\n-        {\n+\t{\n \t  if (sys_priority >= PRI_FG_MIN_NP\n \t      && sys_priority <= PRI_FG_MAX_NP)\n \t    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n@@ -292,12 +292,12 @@ __gthread_objc_mutex_allocate(objc_mutex_t mutex)\n       mutex->backend = objc_malloc(sizeof(pthread_mutex_t));\n \n       if (pthread_mutex_init((pthread_mutex_t *)mutex->backend,\n-      \t\t\t    pthread_mutexattr_default))\n-        {\n-          objc_free(mutex->backend);\n-          mutex->backend = NULL;\n-          return -1;\n-        }\n+\t\t\t     pthread_mutexattr_default))\n+\t{\n+\t  objc_free(mutex->backend);\n+\t  mutex->backend = NULL;\n+\t  return -1;\n+\t}\n     }\n \n   return 0;\n@@ -310,7 +310,7 @@ __gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n   if (__gthread_active_p ())\n     {\n       if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n-        return -1;\n+\treturn -1;\n \n       objc_free(mutex->backend);\n       mutex->backend = NULL;"}, {"sha": "ecd4f97fd6e58d0ce4432033da87bcc9ae772291", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -52,9 +52,9 @@ typedef pthread_mutex_t __gthread_mutex_t;\n #pragma weak pthread_setspecific\n #pragma weak pthread_create\n \n-#pragma weak pthread_mutex_lock \n-#pragma weak pthread_mutex_trylock \n-#pragma weak pthread_mutex_unlock \n+#pragma weak pthread_mutex_lock\n+#pragma weak pthread_mutex_trylock\n+#pragma weak pthread_mutex_unlock\n \n #ifdef _LIBOBJC\n /* Objective C.  */\n@@ -120,15 +120,15 @@ __gthread_objc_init_thread_system(void)\n     {\n       /* Initialize the thread storage key */\n       if (pthread_key_create(&_objc_thread_storage, NULL) == 0)\n-        {\n-          /* The normal default detach state for threads is\n-           * PTHREAD_CREATE_JOINABLE which causes threads to not die\n-           * when you think they should.  */\n-          if (pthread_attr_init(&_objc_thread_attribs) == 0\n-              && pthread_attr_setdetachstate(&_objc_thread_attribs, \n-                                             PTHREAD_CREATE_DETACHED) == 0)\n-            return 0;\n-        }\n+\t{\n+\t  /* The normal default detach state for threads is\n+\t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n+\t   * when you think they should.  */\n+\t  if (pthread_attr_init(&_objc_thread_attribs) == 0\n+\t      && pthread_attr_setdetachstate(&_objc_thread_attribs,\n+\t\t\t\t\t     PTHREAD_CREATE_DETACHED) == 0)\n+\t    return 0;\n+\t}\n     }\n \n   return -1;\n@@ -157,12 +157,12 @@ __gthread_objc_thread_detach(void (*func)(void *), void *arg)\n \n   if (!__gthread_active_p ())\n     return NULL;\n- \n+\n   if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n     thread_id = (objc_thread_t) new_thread_handle;\n   else\n     thread_id = NULL;\n-  \n+\n   return thread_id;\n }\n \n@@ -180,25 +180,25 @@ __gthread_objc_thread_set_priority(int priority)\n \n     if (pthread_getschedparam(thread_id, &policy, &params) == 0)\n       {\n-        if ((priority_max = sched_get_priority_max(policy)) != 0)\n-          return -1;\n-\n-        if ((priority_min = sched_get_priority_min(policy)) != 0)\n-          return -1;\n-\n-        if (priority > priority_max)\n-          priority = priority_max;\n-        else if (priority < priority_min)\n-          priority = priority_min;\n-        params.sched_priority = priority;\n-\n-        /*\n-         * The solaris 7 and several other man pages incorrectly state that\n-         * this should be a pointer to policy but pthread.h is universally\n-         * at odds with this.\n-         */\n-        if (pthread_setschedparam(thread_id, policy, &params) == 0)\n-          return 0;\n+\tif ((priority_max = sched_get_priority_max(policy)) != 0)\n+\t  return -1;\n+\n+\tif ((priority_min = sched_get_priority_min(policy)) != 0)\n+\t  return -1;\n+\n+\tif (priority > priority_max)\n+\t  priority = priority_max;\n+\telse if (priority < priority_min)\n+\t  priority = priority_min;\n+\tparams.sched_priority = priority;\n+\n+\t/*\n+\t * The solaris 7 and several other man pages incorrectly state that\n+\t * this should be a pointer to policy but pthread.h is universally\n+\t * at odds with this.\n+\t */\n+\tif (pthread_setschedparam(thread_id, policy, &params) == 0)\n+\t  return 0;\n       }\n     return -1;\n   }\n@@ -214,9 +214,9 @@ __gthread_objc_thread_get_priority(void)\n       struct sched_param params;\n \n       if (pthread_getschedparam(pthread_self(), &policy, &params) == 0)\n-        return params.sched_priority;\n+\treturn params.sched_priority;\n       else\n-        return -1;\n+\treturn -1;\n     }\n   else\n     return OBJC_THREAD_INTERACTIVE_PRIORITY;\n@@ -330,7 +330,7 @@ __gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n static inline int\n __gthread_objc_mutex_lock(objc_mutex_t mutex)\n {\n-  if (__gthread_active_p () \n+  if (__gthread_active_p ()\n       && pthread_mutex_lock((pthread_mutex_t *)mutex->backend) != 0)\n     {\n       return -1;\n@@ -343,7 +343,7 @@ __gthread_objc_mutex_lock(objc_mutex_t mutex)\n static inline int\n __gthread_objc_mutex_trylock(objc_mutex_t mutex)\n {\n-  if (__gthread_active_p () \n+  if (__gthread_active_p ()\n       && pthread_mutex_trylock((pthread_mutex_t *)mutex->backend) != 0)\n     {\n       return -1;\n@@ -356,7 +356,7 @@ __gthread_objc_mutex_trylock(objc_mutex_t mutex)\n static inline int\n __gthread_objc_mutex_unlock(objc_mutex_t mutex)\n {\n-  if (__gthread_active_p () \n+  if (__gthread_active_p ()\n       && pthread_mutex_unlock((pthread_mutex_t *)mutex->backend) != 0)\n     {\n       return -1;"}, {"sha": "23e35d7403f6ba1363e645d5c1320ac94f996b64", "filename": "gcc/gthr-rtems.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-rtems.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -45,7 +45,7 @@ typedef int   __gthread_once_t;\n typedef void *__gthread_mutex_t;\n \n /*\n- * External functions provided by RTEMS. They are very similar to their POSIX \n+ * External functions provided by RTEMS. They are very similar to their POSIX\n  * counterparts. A \"Wrapper API\" is being use to avoid dependency on any RTEMS\n  * header files.\n  */"}, {"sha": "0ad6194081b1426ba04f5f1c0c81ea7691eb7d0f", "filename": "gcc/gthr-solaris.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-solaris.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -141,14 +141,14 @@ __gthread_objc_thread_detach(void (*func)(void *), void *arg)\n \n   if (!__gthread_active_p ())\n     return NULL;\n- \n+\n   if (thr_create(NULL, 0, (void *)func, arg,\n-  \t\t THR_DETACHED | THR_NEW_LWP,\n+\t\t THR_DETACHED | THR_NEW_LWP,\n \t\t &new_thread_id) == 0)\n     thread_id = *(objc_thread_t *)&new_thread_id;\n   else\n     thread_id = NULL;\n-  \n+\n   return thread_id;\n }\n \n@@ -190,7 +190,7 @@ __gthread_objc_thread_get_priority(void)\n \n   if (!__gthread_active_p ())\n     return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-                                                   \n+\n   if (thr_getprio(thr_self(), &sys_priority) == 0)\n     {\n       if (sys_priority >= 250)\n@@ -333,7 +333,7 @@ __gthread_objc_condition_allocate(objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n     return cond_init((cond_t *)(&(condition->backend)), USYNC_THREAD,\n-    \t\t     NULL);\n+\t\t     NULL);\n   else\n     return 0;\n }\n@@ -354,7 +354,7 @@ __gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n     return cond_wait((cond_t *)(&(condition->backend)),\n-    \t\t     (mutex_t *)(&(mutex->backend)));\n+\t\t     (mutex_t *)(&(mutex->backend)));\n   else\n     return 0;\n }"}, {"sha": "a4ff4e0edde108b9287303195ef606df2b2593aa", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -31,12 +31,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define GCC_GTHR_WIN32_H\n \n /* Windows32 threads specific definitions. The windows32 threading model\n-   does not map well into pthread-inspired gcc's threading model, and so \n+   does not map well into pthread-inspired gcc's threading model, and so\n    there are caveats one needs to be aware of.\n \n    1. The destructor supplied to __gthread_key_create is ignored for\n-      generic x86-win32 ports. This will certainly cause memory leaks \n-      due to unreclaimed eh contexts (sizeof (eh_context) is at least \n+      generic x86-win32 ports. This will certainly cause memory leaks\n+      due to unreclaimed eh contexts (sizeof (eh_context) is at least\n       24 bytes for x86 currently).\n \n       This memory leak may be significant for long-running applications\n@@ -47,18 +47,18 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       linked in if -mthreads option is specified, that runs the dtors in\n       the reverse order of registration when each thread exits. If\n       -mthreads option is not given, a stub is linked in instead of the\n-      DLL, which results in memory leak. Other x86-win32 ports can use \n+      DLL, which results in memory leak. Other x86-win32 ports can use\n       the same technique of course to avoid the leak.\n \n    2. The error codes returned are non-POSIX like, and cast into ints.\n-      This may cause incorrect error return due to truncation values on \n+      This may cause incorrect error return due to truncation values on\n       hw where sizeof (DWORD) > sizeof (int).\n-   \n-   3. We might consider using Critical Sections instead of Windows32 \n-      mutexes for better performance, but emulating __gthread_mutex_trylock \n+\n+   3. We might consider using Critical Sections instead of Windows32\n+      mutexes for better performance, but emulating __gthread_mutex_trylock\n       interface becomes more complicated (Win9x does not support\n       TryEnterCriticalSectioni, while NT does).\n-  \n+\n    The basic framework should work well enough. In the long term, GCC\n    needs to use Structured Exception Handling on Windows32.  */\n \n@@ -72,12 +72,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifdef _LIBOBJC\n \n /* This is necessary to prevent windef.h (included from windows.h) from\n-   defining it's own BOOL as a typedef.  */\t\n+   defining it's own BOOL as a typedef.  */\n #ifndef __OBJC__\n #define __OBJC__\n #endif\n #include <windows.h>\n-/* Now undef the windows BOOL.  */ \n+/* Now undef the windows BOOL.  */\n #undef BOOL\n \n /* Key structure for maintaining thread specific storage */\n@@ -115,9 +115,9 @@ __gthread_objc_thread_detach(void (*func)(void *arg), void *arg)\n   HANDLE win32_handle;\n \n   if (!(win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n-                                   arg, 0, &thread_id)))\n+\t\t\t\t    arg, 0, &thread_id)))\n     thread_id = 0;\n-  \n+\n   return (objc_thread_t)thread_id;\n }\n \n@@ -155,7 +155,7 @@ __gthread_objc_thread_get_priority(void)\n   int sys_priority;\n \n   sys_priority = GetThreadPriority(GetCurrentThread());\n-  \n+\n   switch (sys_priority)\n     {\n     case THREAD_PRIORITY_HIGHEST:\n@@ -167,7 +167,7 @@ __gthread_objc_thread_get_priority(void)\n     default:\n     case THREAD_PRIORITY_BELOW_NORMAL:\n       return OBJC_THREAD_BACKGROUND_PRIORITY;\n-    \n+\n     case THREAD_PRIORITY_IDLE:\n     case THREAD_PRIORITY_LOWEST:\n       return OBJC_THREAD_LOW_PRIORITY;\n@@ -355,7 +355,7 @@ extern int __mingwthr_key_dtor (DWORD, void (*) (void *));\n #endif\n \n /* Mingw runtime >= v0.3 provides a magic variable that is set to non-zero\n-   if -mthreads option was specified, or 0 otherwise. This is to get around \n+   if -mthreads option was specified, or 0 otherwise. This is to get around\n    the lack of weak symbols in PE-COFF.  */\n extern int _CRT_MT;\n #endif\n@@ -381,27 +381,27 @@ __gthread_once (__gthread_once_t *once, void (*func) (void))\n   if (! once->done)\n     {\n       if (InterlockedIncrement (&(once->started)) == 0)\n-        {\n+\t{\n \t  (*func) ();\n \t  once->done = TRUE;\n \t}\n       else\n \t{\n-\t  /* Another thread is currently executing the code, so wait for it \n-\t     to finish; yield the CPU in the meantime.  If performance \n-\t     does become an issue, the solution is to use an Event that \n-\t     we wait on here (and set above), but that implies a place to \n-\t     create the event before this routine is called.  */ \n+\t  /* Another thread is currently executing the code, so wait for it\n+\t     to finish; yield the CPU in the meantime.  If performance\n+\t     does become an issue, the solution is to use an Event that\n+\t     we wait on here (and set above), but that implies a place to\n+\t     create the event before this routine is called.  */\n \t  while (! once->done)\n \t    Sleep (0);\n \t}\n     }\n-  \n+\n   return 0;\n }\n \n /* Windows32 thread local keys don't support destructors; this leads to\n-   leaks, especially in threaded applications making extensive use of \n+   leaks, especially in threaded applications making extensive use of\n    C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\n static inline int\n __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n@@ -423,7 +423,7 @@ __gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n }\n \n /* Currently, this routine is called only for Mingw runtime, and if\n-   -mthreads option is chosen to link in the thread support DLL.  */ \n+   -mthreads option is chosen to link in the thread support DLL.  */\n static inline int\n __gthread_key_dtor (__gthread_key_t key, void *ptr)\n {\n@@ -461,7 +461,7 @@ __gthread_setspecific (__gthread_key_t key, const void *ptr)\n static inline void\n __gthread_mutex_init_function (__gthread_mutex_t *mutex)\n {\n-  /* Create unnamed mutex with default security attr and no initial owner.  */ \n+  /* Create unnamed mutex with default security attr and no initial owner.  */\n   *mutex = CreateMutex (NULL, 0, NULL);\n }\n "}, {"sha": "b436bb6bb91791834fe31a67f9f1e0597955601c", "filename": "gcc/gthr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/589005ff217dde6c3c22842e27315d597a8fe710/gcc%2Fgthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr.h?ref=589005ff217dde6c3c22842e27315d597a8fe710", "patch": "@@ -32,7 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* If this file is compiled with threads support, it must\n        #define __GTHREADS 1\n    to indicate that threads support is present.  Also it has define\n-   function \n+   function\n      int __gthread_active_p ()\n    that returns 1 if thread system is active, 0 if not.\n "}]}