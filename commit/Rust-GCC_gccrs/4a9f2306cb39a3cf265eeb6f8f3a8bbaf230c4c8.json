{"sha": "4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE5ZjIzMDZjYjM5YTNjZjI2NWVlYjZmOGYzYThiYmFmMjMwYzRjOA==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-05-28T06:11:45Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-05-28T06:11:45Z"}, "message": "forwprop: Enhance vec perm fed by CTOR and CTOR/CST [PR99398]\n\nVEC_PERM_EXPR requires the number of MASK elements must be the\nsame with the number of elements in operands V0 and V1.  In\nsome cases, like with Power altivec built-in function vec_perm,\nVIEW_CONVERT_EXPR has to be used to guarantee this requirement,\nbut it can prevent some simplifications which don't consider\nthis well.\n\nFor the cases that the permutated operands of vector\npermutation are from two same type CTOR and CTOR, or one CTOR\nand one VECTOR CST, this patch is to enhance forwprop to look\nthrough intermediate VIEW_CONVERT_EXPR and further simplify\nthem if possible.\n\nBootstrapped/regtested on powerpc64le-linux-gnu P9,\npowerpc64-linux-gnu P8, x86_64-redhat-linux and\naarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/99398\n\t* tree-ssa-forwprop.c (simplify_permutation): Optimize some cases\n\twhere the fed operands are CTOR/CST and propagated through\n\tVIEW_CONVERT_EXPR.  Call vec_perm_indices::new_shrunk_vector.\n\t* vec-perm-indices.c (vec_perm_indices::new_shrunk_vector): New\n\tfunction.\n\t* vec-perm-indices.h (vec_perm_indices::new_shrunk_vector): New\n\tdeclare.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/99398\n\t* gcc.target/powerpc/vec-perm-ctor-run.c: New test.\n\t* gcc.target/powerpc/vec-perm-ctor.c: New test.\n\t* gcc.target/powerpc/vec-perm-ctor.h: New test.", "tree": {"sha": "c37b0fcc9092378d662e6de5c0445ae8a9d8c617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c37b0fcc9092378d662e6de5c0445ae8a9d8c617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd62d089f6021fd1ad4537b8182836d15b14514f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd62d089f6021fd1ad4537b8182836d15b14514f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd62d089f6021fd1ad4537b8182836d15b14514f"}], "stats": {"total": 497, "additions": 482, "deletions": 15}, "files": [{"sha": "987d6db999c2f14675402d0079d1a1b27fbb70f1", "filename": "gcc/testsuite/gcc.target/powerpc/vec-perm-ctor-run.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor-run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor-run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor-run.c?ref=4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "patch": "@@ -0,0 +1,124 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#include \"vec-perm-ctor.h\"\n+\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  du a_du = 100ULL;\n+  du b_du = 200ULL;\n+\n+  di a_di = -100;\n+  di b_di = 200;\n+\n+  df a_df = 10.0;\n+  df b_df = 20.0;\n+\n+  si a_si = 12;\n+  si b_si = -25;\n+  si c_si = -37;\n+  si d_si = 50;\n+\n+  sf a_sf = 30.0f;\n+  sf b_sf = 40.0f;\n+  sf c_sf = 50.0f;\n+  sf d_sf = 60.0f;\n+\n+  hu a_hu = 10;\n+  hu b_hu = 20;\n+  hu c_hu = 30;\n+  hu d_hu = 40;\n+  hu e_hu = 50;\n+  hu f_hu = 60;\n+  hu g_hu = 70;\n+  hu h_hu = 80;\n+\n+  qi a_qi = 10;\n+  qi b_qi = 20;\n+  qi c_qi = -30;\n+  qi d_qi = 40;\n+  qi e_qi = -50;\n+  qi f_qi = 60;\n+  qi g_qi = 70;\n+  qi h_qi = -80;\n+\n+  v2du res1 = test_ctor_ctor_same_du (a_du, b_du);\n+  if (res1[0] != a_du || res1[1] != b_du)\n+    abort ();\n+\n+  v2df res2 = test_ctor_ctor_same_df (a_df, b_df);\n+  if (res2[0] != a_df || res2[1] != b_df)\n+    abort ();\n+\n+  v4si res3 = test_ctor_ctor_same_si (a_si, b_si, c_si, d_si);\n+  if (res3[0] != a_si || res3[1] != b_si || res3[2] != c_si || res3[3] != d_si)\n+    abort ();\n+\n+  v4sf res4 = test_ctor_ctor_same_sf (a_sf, b_sf, c_sf, d_sf);\n+  if (res4[0] != a_sf || res4[1] != b_sf || res4[2] != c_sf || res4[3] != d_sf)\n+    abort ();\n+\n+  v8hu res5\n+    = test_ctor_ctor_same_hu (a_hu, b_hu, c_hu, d_hu, e_hu, f_hu, g_hu, h_hu);\n+\n+  if (res5[0] != a_hu || res5[1] != b_hu || res5[2] != c_hu || res5[3] != d_hu\n+      || res5[4] != e_hu || res5[5] != f_hu || res5[6] != g_hu\n+      || res5[7] != h_hu)\n+    abort ();\n+\n+  v16qi res6\n+    = test_ctor_ctor_same_qi (a_qi, b_qi, c_qi, d_qi, e_qi, f_qi, g_qi, h_qi);\n+\n+  if (res6[0] != a_qi || res6[1] != b_qi || res6[2] != c_qi || res6[3] != d_qi\n+      || res6[4] != a_qi || res6[5] != b_qi || res6[6] != c_qi\n+      || res6[7] != d_qi || res6[8] != e_qi || res6[9] != f_qi\n+      || res6[10] != g_qi || res6[11] != h_qi || res6[12] != e_qi\n+      || res6[13] != f_qi || res6[14] != g_qi || res6[15] != h_qi)\n+    abort ();\n+\n+  v2du res7 = test_ctor_cst_same_du (a_du, b_du);\n+  if (res7[0] != a_du || res7[1] != 100)\n+    abort ();\n+\n+  v4sf res8 = test_ctor_cst_same_sf (a_sf, b_sf);\n+  if (res8[0] != a_sf || res8[1] != 2.0f || res8[2] != b_sf || res8[3] != 4.0f)\n+    abort ();\n+\n+  v2df res9 = test_ctor_cst_same_df (a_df, b_df);\n+  if (res9[0] != b_df || res9[1] != 200.0)\n+    abort ();\n+\n+  v4si res10 = test_cst_ctor_same_si (a_si, b_si);\n+  if (res10[0] != 1 || res10[1] != 3 || res10[2] != a_si || res10[3] != b_si)\n+    abort ();\n+\n+  v2di res11 = test_ctor_cst_diff_di_si (a_di, b_di);\n+  /* Need to take care of the endianness since the function converts vector\n+     const to one different vector type (element size), the endianness\n+     determines the reinterpreted layout.  Same reason for res12 below.  */\n+  if (res11[0] != -100 ||\n+#ifdef __LITTLE_ENDIAN__\n+      res11[1] != 3\n+#else\n+      res11[1] != 0x300000000LL\n+#endif\n+  )\n+    abort ();\n+\n+  v2du res12 = test_cst_ctor_diff_sf_du (a_du, b_du);\n+  if (\n+#ifdef __LITTLE_ENDIAN__\n+    res12[0] != 0x400000003f800000ULL\n+#else\n+    res12[0] != 0x3f80000040000000ULL\n+#endif\n+    || res12[1] != 100)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "cc59e60035fc36213b14e406551781307e284202", "filename": "gcc/testsuite/gcc.target/powerpc/vec-perm-ctor.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor.c?ref=4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx -fdump-tree-optimized\" } */\n+\n+/* To test all permutations fed by CTOR and CST can be optimized away.  */\n+\n+#include \"vec-perm-ctor.h\"\n+\n+/* { dg-final { scan-tree-dump-not \"VIEW_CONVERT_EXPR\" \"optimized\" } } */"}, {"sha": "18782701e5189edb0154639fc9392b715623f48f", "filename": "gcc/testsuite/gcc.target/powerpc/vec-perm-ctor.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-perm-ctor.h?ref=4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "patch": "@@ -0,0 +1,163 @@\n+#include \"altivec.h\"\n+\n+typedef vector unsigned long long v2du;\n+typedef vector signed long long v2di;\n+typedef vector unsigned int v4su;\n+typedef vector signed int v4si;\n+typedef vector unsigned short v8hu;\n+typedef vector signed short v8hi;\n+typedef vector unsigned char v16qu;\n+typedef vector signed char v16qi;\n+typedef vector double v2df;\n+typedef vector float v4sf;\n+\n+typedef unsigned long long du;\n+typedef signed long long di;\n+typedef unsigned int su;\n+typedef signed int si;\n+typedef unsigned short hu;\n+typedef signed short hi;\n+typedef unsigned char qu;\n+typedef signed char qi;\n+typedef double df;\n+typedef float sf;\n+\n+/* To test whether we can optimize vector permutation away when\n+   the two inputs are same type CTOR or one input is CTOR and the\n+   other is CST.  */\n+\n+/* CTOR + CTOR part (only same type supported).  */\n+\n+/* Test both operands are same type CTOR (type unsigned long long).  */\n+__attribute__ ((noipa)) v2du\n+test_ctor_ctor_same_du (du a, du b)\n+{\n+  v2du v1 = {a, 0};\n+  v2du v2 = {b, 0};\n+  v16qu vc = {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23};\n+  v2du vres = (v2du) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* Test both operands are same type CTOR (type double).  */\n+__attribute__ ((noipa)) v2df\n+test_ctor_ctor_same_df (df a, df b)\n+{\n+  v2df v1 = {0.0, a};\n+  v2df v2 = {0.0, b};\n+  v16qu vc = {8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31};\n+  v2df vres = (v2df) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* Test both operands are same type CTOR (type signed int).  */\n+__attribute__ ((noipa)) v4si\n+test_ctor_ctor_same_si (si a, si b, si c, si d)\n+{\n+  v4si v1 = {0, a, 0, c};\n+  v4si v2 = {0, b, 0, d};\n+  v16qu vc = {4, 5, 6, 7, 20, 21, 22, 23, 12, 13, 14, 15, 28, 29, 30, 31};\n+  v4si vres = (v4si) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* Test both operands are same type CTOR (type float).  */\n+__attribute__ ((noipa)) v4sf\n+test_ctor_ctor_same_sf (sf a, sf b, sf c, sf d)\n+{\n+  v4sf v1 = {c, 0.0f, d, 0.0f};\n+  v4sf v2 = {a, 0.0f, b, 0.0f};\n+  v16qu vc = {16, 17, 18, 19, 24, 25, 26, 27, 0, 1, 2, 3, 8, 9, 10, 11};\n+  v4sf vres = (v4sf) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* Test both operands are same type CTOR (type unsigned short).  */\n+__attribute__ ((noipa)) v8hu\n+test_ctor_ctor_same_hu (hu a, hu b, hu c, hu d, hu e, hu f, hu g, hu h)\n+{\n+  v8hu v1 = {0, a, 0, b, 0, c, 0, d};\n+  v8hu v2 = {0, e, 0, f, 0, g, 0, h};\n+  v16qu vc = {2, 3, 6, 7, 10, 11, 14, 15, 18, 19, 22, 23, 26, 27, 30, 31};\n+  v8hu vres = (v8hu) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* Test both operands are same type CTOR (type signed char).  */\n+__attribute__ ((noipa)) v16qi\n+test_ctor_ctor_same_qi (qi a, qi b, qi c, qi d, qi e, qi f, qi g, qi h)\n+{\n+  v16qi v1 = {0, a, 0, b, 0, c, 0, d, 0, a, 0, b, 0, c, 0, d};\n+  v16qi v2 = {0, e, 0, f, 0, g, 0, h, 0, e, 0, f, 0, g, 0, h};\n+  v16qu vc = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31};\n+  v16qi vres = (v16qi) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* CTOR + CST part (same type).  */\n+\n+__attribute__ ((noipa)) v2du\n+test_ctor_cst_same_du (du a, du b)\n+{\n+  v2du v1 = {a, b};\n+  v2du v2 = {100, 200};\n+  v16qu vc = {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23};\n+  v2du vres = (v2du) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+__attribute__ ((noipa)) v4sf\n+test_ctor_cst_same_sf (sf a, sf b)\n+{\n+  v4sf v1 = {0.0f, a, 0.0f, b};\n+  v4sf v2 = {1.0f, 2.0f, 3.0f, 4.0f};\n+  v16qu vc = {4, 5, 6, 7, 20, 21, 22, 23, 12, 13, 14, 15, 28, 29, 30, 31};\n+  v4sf vres = (v4sf) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* CST + CTOR part (same type).  */\n+\n+__attribute__ ((noipa)) v2df\n+test_ctor_cst_same_df (df a, df b)\n+{\n+  v2df v1 = {a, b};\n+  v2df v2 = {100.0, 200.0};\n+  v16qu vc = {8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31};\n+  v2df vres = (v2df) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+__attribute__ ((noipa)) v4si\n+test_cst_ctor_same_si (si a, si b)\n+{\n+  v4si v1 = {a, 0, b, 0};\n+  v4si v2 = {1, 2, 3, 4};\n+  v16qu vc = {16, 17, 18, 19, 24, 25, 26, 27, 0, 1, 2, 3, 8, 9, 10, 11};\n+  v4si vres = (v4si) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* CTOR + CST part (different types).  */\n+\n+__attribute__ ((noipa)) v2di\n+test_ctor_cst_diff_di_si (di a, di b)\n+{\n+  v2di v1 = {a, b};\n+  v4si v2 = {3, 0, 4, 0};\n+  v16qu vc = {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23};\n+  v2di vres = (v2di) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}\n+\n+/* CST + CTOR part (different types).  */\n+\n+__attribute__ ((noipa)) v2du\n+test_cst_ctor_diff_sf_du (du a, du b)\n+{\n+  v4sf v1 = {1.0f, 2.0f, 3.0f, 4.0f};\n+  v2du v2 = {a, b};\n+  v16qu vc = {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23};\n+  v2du vres = (v2du) vec_perm ((v16qu) v1, (v16qu) v2, vc);\n+  return vres;\n+}"}, {"sha": "beb2702f3b6a184632a762342e2a2f51f3701d7f", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 126, "deletions": 15, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "patch": "@@ -2120,9 +2120,9 @@ static int\n simplify_permutation (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n-  gimple *def_stmt;\n+  gimple *def_stmt = NULL;\n   tree op0, op1, op2, op3, arg0, arg1;\n-  enum tree_code code;\n+  enum tree_code code, code2 = ERROR_MARK;\n   bool single_use_op0 = false;\n \n   gcc_checking_assert (gimple_assign_rhs_code (stmt) == VEC_PERM_EXPR);\n@@ -2142,10 +2142,28 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n   else if (TREE_CODE (op0) == SSA_NAME)\n     {\n       def_stmt = get_prop_source_stmt (op0, false, &single_use_op0);\n-      if (!def_stmt || !can_propagate_from (def_stmt))\n+      if (!def_stmt)\n \treturn 0;\n-\n       code = gimple_assign_rhs_code (def_stmt);\n+      if (code == VIEW_CONVERT_EXPR)\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t  tree name = TREE_OPERAND (rhs, 0);\n+\t  if (TREE_CODE (name) != SSA_NAME)\n+\t    return 0;\n+\t  if (!has_single_use (name))\n+\t    single_use_op0 = false;\n+\t  /* Here we update the def_stmt through this VIEW_CONVERT_EXPR,\n+\t     but still keep the code to indicate it comes from\n+\t     VIEW_CONVERT_EXPR.  */\n+\t  def_stmt = SSA_NAME_DEF_STMT (name);\n+\t  if (!def_stmt || !is_gimple_assign (def_stmt))\n+\t    return 0;\n+\t  if (gimple_assign_rhs_code (def_stmt) != CONSTRUCTOR)\n+\t    return 0;\n+\t}\n+      if (!can_propagate_from (def_stmt))\n+\treturn 0;\n       arg0 = gimple_assign_rhs1 (def_stmt);\n     }\n   else\n@@ -2173,12 +2191,10 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n       update_stmt (stmt);\n       return remove_prop_source_from_use (op0) ? 2 : 1;\n     }\n-\n-  /* Shuffle of a constructor.  */\n-  else if (code == CONSTRUCTOR || code == VECTOR_CST)\n+  else if (code == CONSTRUCTOR\n+\t   || code == VECTOR_CST\n+\t   || code == VIEW_CONVERT_EXPR)\n     {\n-      tree opt;\n-      bool ret = false;\n       if (op0 != op1)\n \t{\n \t  if (TREE_CODE (op0) == SSA_NAME && !single_use_op0)\n@@ -2188,14 +2204,27 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n \t    arg1 = op1;\n \t  else if (TREE_CODE (op1) == SSA_NAME)\n \t    {\n-\t      enum tree_code code2;\n-\n \t      gimple *def_stmt2 = get_prop_source_stmt (op1, true, NULL);\n-\t      if (!def_stmt2 || !can_propagate_from (def_stmt2))\n+\t      if (!def_stmt2)\n \t\treturn 0;\n-\n \t      code2 = gimple_assign_rhs_code (def_stmt2);\n-\t      if (code2 != CONSTRUCTOR && code2 != VECTOR_CST)\n+\t      if (code2 == VIEW_CONVERT_EXPR)\n+\t\t{\n+\t\t  tree rhs = gimple_assign_rhs1 (def_stmt2);\n+\t\t  tree name = TREE_OPERAND (rhs, 0);\n+\t\t  if (TREE_CODE (name) != SSA_NAME)\n+\t\t    return 0;\n+\t\t  if (!has_single_use (name))\n+\t\t    return 0;\n+\t\t  def_stmt2 = SSA_NAME_DEF_STMT (name);\n+\t\t  if (!def_stmt2 || !is_gimple_assign (def_stmt2))\n+\t\t    return 0;\n+\t\t  if (gimple_assign_rhs_code (def_stmt2) != CONSTRUCTOR)\n+\t\t    return 0;\n+\t\t}\n+\t      else if (code2 != CONSTRUCTOR && code2 != VECTOR_CST)\n+\t\treturn 0;\n+\t      if (!can_propagate_from (def_stmt2))\n \t\treturn 0;\n \t      arg1 = gimple_assign_rhs1 (def_stmt2);\n \t    }\n@@ -2209,10 +2238,92 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n \t    return 0;\n \t  arg1 = arg0;\n \t}\n-      opt = fold_ternary (VEC_PERM_EXPR, TREE_TYPE (op0), arg0, arg1, op2);\n+\n+      /* If there are any VIEW_CONVERT_EXPRs found when finding permutation\n+\t operands source, check whether it's valid to transform and prepare\n+\t the required new operands.  */\n+      if (code == VIEW_CONVERT_EXPR || code2 == VIEW_CONVERT_EXPR)\n+\t{\n+\t  /* Figure out the target vector type to which operands should be\n+\t     converted.  If both are CONSTRUCTOR, the types should be the\n+\t     same, otherwise, use the one of CONSTRUCTOR.  */\n+\t  tree tgt_type = NULL_TREE;\n+\t  if (code == VIEW_CONVERT_EXPR)\n+\t    {\n+\t      gcc_assert (gimple_assign_rhs_code (def_stmt) == CONSTRUCTOR);\n+\t      code = CONSTRUCTOR;\n+\t      tgt_type = TREE_TYPE (arg0);\n+\t    }\n+\t  if (code2 == VIEW_CONVERT_EXPR)\n+\t    {\n+\t      tree arg1_type = TREE_TYPE (arg1);\n+\t      if (tgt_type == NULL_TREE)\n+\t\ttgt_type = arg1_type;\n+\t      else if (tgt_type != arg1_type)\n+\t\treturn 0;\n+\t    }\n+\n+\t  if (!VECTOR_TYPE_P (tgt_type))\n+\t    return 0;\n+\t  tree op2_type = TREE_TYPE (op2);\n+\t  /* Should have folded this before.  */\n+\t  gcc_assert (op2_type != tgt_type);\n+\n+\t  /* Figure out the shrunk factor.  */\n+\t  poly_uint64 tgt_units = TYPE_VECTOR_SUBPARTS (tgt_type);\n+\t  poly_uint64 op2_units = TYPE_VECTOR_SUBPARTS (op2_type);\n+\t  if (maybe_gt (tgt_units, op2_units))\n+\t    return 0;\n+\t  unsigned int factor;\n+\t  if (!constant_multiple_p (op2_units, tgt_units, &factor))\n+\t    return 0;\n+\n+\t  /* Build the new permutation control vector as target vector.  */\n+\t  vec_perm_builder builder;\n+\t  if (!tree_to_vec_perm_builder (&builder, op2))\n+\t    return 0;\n+\t  vec_perm_indices indices (builder, 2, op2_units);\n+\t  vec_perm_indices new_indices;\n+\t  if (new_indices.new_shrunk_vector (indices, factor))\n+\t    {\n+\t      tree mask_type = tgt_type;\n+\t      if (!VECTOR_INTEGER_TYPE_P (mask_type))\n+\t\t{\n+\t\t  tree elem_type = TREE_TYPE (mask_type);\n+\t\t  unsigned elem_size = TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n+\t\t  tree int_type = build_nonstandard_integer_type (elem_size, 0);\n+\t\t  mask_type = build_vector_type (int_type, tgt_units);\n+\t\t}\n+\t      op2 = vec_perm_indices_to_tree (mask_type, new_indices);\n+\t    }\n+\t  else\n+\t    return 0;\n+\n+\t  /* Convert the VECTOR_CST to the appropriate vector type.  */\n+\t  if (tgt_type != TREE_TYPE (arg0))\n+\t    arg0 = fold_build1 (VIEW_CONVERT_EXPR, tgt_type, arg0);\n+\t  else if (tgt_type != TREE_TYPE (arg1))\n+\t    arg1 = fold_build1 (VIEW_CONVERT_EXPR, tgt_type, arg1);\n+\t}\n+\n+      /* VIEW_CONVERT_EXPR should be updated to CONSTRUCTOR before.  */\n+      gcc_assert (code == CONSTRUCTOR || code == VECTOR_CST);\n+\n+      /* Shuffle of a constructor.  */\n+      bool ret = false;\n+      tree res_type = TREE_TYPE (arg0);\n+      tree opt = fold_ternary (VEC_PERM_EXPR, res_type, arg0, arg1, op2);\n       if (!opt\n \t  || (TREE_CODE (opt) != CONSTRUCTOR && TREE_CODE (opt) != VECTOR_CST))\n \treturn 0;\n+      /* Found VIEW_CONVERT_EXPR before, need one explicit conversion.  */\n+      if (res_type != TREE_TYPE (op0))\n+\t{\n+\t  tree name = make_ssa_name (TREE_TYPE (opt));\n+\t  gimple *ass_stmt = gimple_build_assign (name, opt);\n+\t  gsi_insert_before (gsi, ass_stmt, GSI_SAME_STMT);\n+\t  opt = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (op0), name);\n+\t}\n       gimple_assign_set_rhs_from_tree (gsi, opt);\n       update_stmt (gsi_stmt (*gsi));\n       if (TREE_CODE (op0) == SSA_NAME)"}, {"sha": "31b32ea05896c4228457819f903de28943f98dc8", "filename": "gcc/vec-perm-indices.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Fvec-perm-indices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Fvec-perm-indices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.c?ref=4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "patch": "@@ -101,6 +101,65 @@ vec_perm_indices::new_expanded_vector (const vec_perm_indices &orig,\n   m_encoding.finalize ();\n }\n \n+/* Check whether we can switch to a new permutation vector that\n+   selects the same input elements as ORIG, but with each element\n+   built up from FACTOR pieces.  Return true if yes, otherwise\n+   return false.  Every FACTOR permutation indexes should be\n+   continuous separately and the first one of each batch should\n+   be able to exactly modulo FACTOR.  For example, if ORIG is\n+   { 2, 3, 4, 5, 0, 1, 6, 7 } and FACTOR is 2, the new permutation\n+   is { 1, 2, 0, 3 }.  */\n+\n+bool\n+vec_perm_indices::new_shrunk_vector (const vec_perm_indices &orig,\n+\t\t\t\t     unsigned int factor)\n+{\n+  gcc_assert (factor > 0);\n+\n+  if (maybe_lt (orig.m_nelts_per_input, factor))\n+    return false;\n+\n+  poly_uint64 nelts;\n+  /* Invalid if vector units number isn't multiple of factor.  */\n+  if (!multiple_p (orig.m_nelts_per_input, factor, &nelts))\n+    return false;\n+\n+  /* Only handle the case that npatterns is multiple of factor.\n+     FIXME: Try to see whether we can reshape it by factor npatterns.  */\n+  if (orig.m_encoding.npatterns () % factor != 0)\n+    return false;\n+\n+  unsigned int encoded_nelts = orig.m_encoding.encoded_nelts ();\n+  auto_vec<element_type, 32> encoding (encoded_nelts);\n+  /* Separate all encoded elements into batches by size factor,\n+     then ensure the first element of each batch is multiple of\n+     factor and all elements in each batch is consecutive from\n+     the first one.  */\n+  for (unsigned int i = 0; i < encoded_nelts; i += factor)\n+    {\n+      element_type first = orig.m_encoding[i];\n+      element_type new_index;\n+      if (!multiple_p (first, factor, &new_index))\n+\treturn false;\n+      for (unsigned int j = 1; j < factor; ++j)\n+\tif (maybe_ne (first + j, orig.m_encoding[i + j]))\n+\t  return false;\n+      encoding.quick_push (new_index);\n+    }\n+\n+  m_ninputs = orig.m_ninputs;\n+  m_nelts_per_input = nelts;\n+  poly_uint64 full_nelts = exact_div (orig.m_encoding.full_nelts (), factor);\n+  unsigned int npatterns = orig.m_encoding.npatterns () / factor;\n+\n+  m_encoding.new_vector (full_nelts, npatterns,\n+\t\t\t orig.m_encoding.nelts_per_pattern ());\n+  m_encoding.splice (encoding);\n+  m_encoding.finalize ();\n+\n+  return true;\n+}\n+\n /* Rotate the inputs of the permutation right by DELTA inputs.  This changes\n    the values of the permutation vector but it doesn't change the way that\n    the elements are encoded.  */"}, {"sha": "98d27f0ec423cfbf5b13cf025cdff86e4b64ac67", "filename": "gcc/vec-perm-indices.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Fvec-perm-indices.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8/gcc%2Fvec-perm-indices.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.h?ref=4a9f2306cb39a3cf265eeb6f8f3a8bbaf230c4c8", "patch": "@@ -57,6 +57,7 @@ class vec_perm_indices\n \n   void new_vector (const vec_perm_builder &, unsigned int, poly_uint64);\n   void new_expanded_vector (const vec_perm_indices &, unsigned int);\n+  bool new_shrunk_vector (const vec_perm_indices &, unsigned int);\n   void rotate_inputs (int delta);\n \n   /* Return the underlying vector encoding.  */"}]}