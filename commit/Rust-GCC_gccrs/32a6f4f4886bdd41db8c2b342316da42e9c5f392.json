{"sha": "32a6f4f4886bdd41db8c2b342316da42e9c5f392", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhNmY0ZjQ4ODZiZGQ0MWRiOGMyYjM0MjMxNmRhNDJlOWM1ZjM5Mg==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-03-04T16:27:34Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-03-04T16:27:34Z"}, "message": "[NDS32] Refine load_multiple and store_multiple.\n\ngcc/\n\t* config/nds32/nds32-protos.h\n\t(nds32_expand_load_multiple): New arguments.\n\t(nds32_expand_store_multiple): Ditto.\n\t(nds32_valid_multiple_load_store): Rename ...\n\t(nds32_valid_multiple_load_store_p): ... to this.\n\t* config/nds32/nds32-memory-manipulation.c\n\t(nds32_expand_load_multiple): Refine implementation.\n\t(nds32_expand_store_multiple): Ditto.\n\t* config/nds32/nds32-multiple.md\n\t(load_multiple): Update nds32_expand_load_multiple interface.\n\t(store_multiple): Update nds32_expand_store_multiple interface.\n\t* config/nds32/nds32-predicates.c\n\t(nds32_valid_multiple_load_store): Rename ...\n\t(nds32_valid_multiple_load_store_p): ... to this and refine\n\timplementation.\n\t* config/nds32/predicates.md\n\t(nds32_load_multiple_and_update_address_operation): New predicate.\n\t(nds32_store_multiple_and_update_address_operation): New predicate.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r258234", "tree": {"sha": "b6c54673de41634c966103d1f89bc9c25d333fc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6c54673de41634c966103d1f89bc9c25d333fc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32a6f4f4886bdd41db8c2b342316da42e9c5f392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a6f4f4886bdd41db8c2b342316da42e9c5f392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32a6f4f4886bdd41db8c2b342316da42e9c5f392", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a6f4f4886bdd41db8c2b342316da42e9c5f392/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "264159d28c22a8d6eb35b47b65427654614772b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/264159d28c22a8d6eb35b47b65427654614772b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/264159d28c22a8d6eb35b47b65427654614772b9"}], "stats": {"total": 3762, "additions": 3613, "deletions": 149}, "files": [{"sha": "c5dffdaf882ea860fcfcfbc11314ed3e24de68bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32a6f4f4886bdd41db8c2b342316da42e9c5f392", "patch": "@@ -1,3 +1,26 @@\n+2018-03-04  Kito Cheng  <kito.cheng@gmail.com>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32-protos.h\n+\t(nds32_expand_load_multiple): New arguments.\n+\t(nds32_expand_store_multiple): Ditto.\n+\t(nds32_valid_multiple_load_store): Rename ...\n+\t(nds32_valid_multiple_load_store_p): ... to this.\n+\t* config/nds32/nds32-memory-manipulation.c\n+\t(nds32_expand_load_multiple): Refine implementation.\n+\t(nds32_expand_store_multiple): Ditto.\n+\t* config/nds32/nds32-multiple.md\n+\t(load_multiple): Update nds32_expand_load_multiple interface.\n+\t(store_multiple): Update nds32_expand_store_multiple interface.\n+\t* config/nds32/nds32-predicates.c\n+\t(nds32_valid_multiple_load_store): Rename ...\n+\t(nds32_valid_multiple_load_store_p): ... to this and refine\n+\timplementation.\n+\t* config/nds32/predicates.md\n+\t(nds32_load_multiple_and_update_address_operation): New predicate.\n+\t(nds32_store_multiple_and_update_address_operation): New predicate.\n+\n 2018-03-04  Kito Cheng  <kito.cheng@gmail.com>\n \t    Chung-Ju Wu  <jasonwucj@gmail.com>\n "}, {"sha": "da01fc60c21db3e278ea1b7687119485fb1b28a4", "filename": "gcc/config/nds32/nds32-memory-manipulation.c", "status": "modified", "additions": 79, "deletions": 8, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c?ref=32a6f4f4886bdd41db8c2b342316da42e9c5f392", "patch": "@@ -40,16 +40,50 @@\n    Check nds32-multiple.md file for the patterns.  */\n rtx\n nds32_expand_load_multiple (int base_regno, int count,\n-\t\t\t    rtx base_addr, rtx basemem)\n+\t\t\t    rtx base_addr, rtx basemem,\n+\t\t\t    bool update_base_reg_p,\n+\t\t\t    rtx *update_base_reg)\n {\n   int par_index;\n   int offset;\n+  int start_idx;\n   rtx result;\n   rtx new_addr, mem, reg;\n \n+  /* Generate a unaligned load to prevent load instruction pull out from\n+     parallel, and then it will generate lwi, and lose unaligned acces */\n+  if (count == 1)\n+    {\n+      reg = gen_rtx_REG (SImode, base_regno);\n+      if (update_base_reg_p)\n+\t{\n+\t  *update_base_reg = gen_reg_rtx (SImode);\n+\t  return gen_unaligned_load_update_base_w (*update_base_reg, reg, base_addr);\n+\t}\n+      else\n+\treturn gen_unaligned_load_w (reg, gen_rtx_MEM (SImode, base_addr));\n+    }\n+\n   /* Create the pattern that is presented in nds32-multiple.md.  */\n+  if (update_base_reg_p)\n+    {\n+      result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n+      start_idx = 1;\n+    }\n+  else\n+    {\n+      result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+      start_idx = 0;\n+    }\n+\n+  if (update_base_reg_p)\n+    {\n+      offset           = count * 4;\n+      new_addr         = plus_constant (Pmode, base_addr, offset);\n+      *update_base_reg = gen_reg_rtx (SImode);\n \n-  result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+      XVECEXP (result, 0, 0) = gen_rtx_SET (*update_base_reg, new_addr);\n+    }\n \n   for (par_index = 0; par_index < count; par_index++)\n     {\n@@ -60,24 +94,57 @@ nds32_expand_load_multiple (int base_regno, int count,\n \t\t\t\t\t       new_addr, offset);\n       reg      = gen_rtx_REG (SImode, base_regno + par_index);\n \n-      XVECEXP (result, 0, par_index) = gen_rtx_SET (reg, mem);\n+      XVECEXP (result, 0, (par_index + start_idx)) = gen_rtx_SET (reg, mem);\n     }\n \n   return result;\n }\n \n rtx\n nds32_expand_store_multiple (int base_regno, int count,\n-\t\t\t     rtx base_addr, rtx basemem)\n+\t\t\t     rtx base_addr, rtx basemem,\n+\t\t\t     bool update_base_reg_p,\n+\t\t\t     rtx *update_base_reg)\n {\n   int par_index;\n   int offset;\n+  int start_idx;\n   rtx result;\n   rtx new_addr, mem, reg;\n \n+  if (count == 1)\n+    {\n+      reg = gen_rtx_REG (SImode, base_regno);\n+      if (update_base_reg_p)\n+\t{\n+\t  *update_base_reg = gen_reg_rtx (SImode);\n+\t  return gen_unaligned_store_update_base_w (*update_base_reg, base_addr, reg);\n+\t}\n+      else\n+\treturn gen_unaligned_store_w (gen_rtx_MEM (SImode, base_addr), reg);\n+    }\n+\n   /* Create the pattern that is presented in nds32-multiple.md.  */\n \n-  result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+  if (update_base_reg_p)\n+    {\n+      result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n+      start_idx = 1;\n+    }\n+  else\n+    {\n+      result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+      start_idx = 0;\n+    }\n+\n+  if (update_base_reg_p)\n+    {\n+      offset           = count * 4;\n+      new_addr         = plus_constant (Pmode, base_addr, offset);\n+      *update_base_reg = gen_reg_rtx (SImode);\n+\n+      XVECEXP (result, 0, 0) = gen_rtx_SET (*update_base_reg, new_addr);\n+    }\n \n   for (par_index = 0; par_index < count; par_index++)\n     {\n@@ -88,7 +155,7 @@ nds32_expand_store_multiple (int base_regno, int count,\n \t\t\t\t\t       new_addr, offset);\n       reg      = gen_rtx_REG (SImode, base_regno + par_index);\n \n-      XVECEXP (result, 0, par_index) = gen_rtx_SET (mem, reg);\n+      XVECEXP (result, 0, par_index + start_idx) = gen_rtx_SET (mem, reg);\n     }\n \n   return result;\n@@ -135,8 +202,12 @@ nds32_expand_movmemqi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n \n   out_words = in_words = INTVAL (total_bytes) / UNITS_PER_WORD;\n \n-  emit_insn (nds32_expand_load_multiple (0, in_words, src_base_reg, srcmem));\n-  emit_insn (nds32_expand_store_multiple (0, out_words, dst_base_reg, dstmem));\n+  emit_insn (\n+    nds32_expand_load_multiple (0, in_words, src_base_reg,\n+\t\t\t\tsrcmem, false, NULL));\n+  emit_insn (\n+    nds32_expand_store_multiple (0, out_words, dst_base_reg,\n+\t\t\t\t dstmem, false, NULL));\n \n   /* Successfully create patterns, return 1.  */\n   return 1;"}, {"sha": "c0265914ec840c6d6cb04a904392c793785f49b3", "filename": "gcc/config/nds32/nds32-multiple.md", "status": "modified", "additions": 3451, "deletions": 129, "changes": 3580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md?ref=32a6f4f4886bdd41db8c2b342316da42e9c5f392"}, {"sha": "c54eefba027d9d35f073b801aac16d83e66d1151", "filename": "gcc/config/nds32/nds32-predicates.c", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c?ref=32a6f4f4886bdd41db8c2b342316da42e9c5f392", "patch": "@@ -101,21 +101,33 @@ nds32_consecutive_registers_load_store_p (rtx op,\n    We have to extract reg and mem of every element and\n    check if the information is valid for multiple load/store operation.  */\n bool\n-nds32_valid_multiple_load_store (rtx op, bool load_p)\n+nds32_valid_multiple_load_store_p (rtx op, bool load_p, bool bim_p)\n {\n   int count;\n   int first_elt_regno;\n+  int update_base_elt_idx;\n+  int offset;\n   rtx elt;\n+  rtx update_base;\n \n-  /* Get the counts of elements in the parallel rtx.  */\n-  count = XVECLEN (op, 0);\n-  /* Pick up the first element.  */\n-  elt = XVECEXP (op, 0, 0);\n+  /* Get the counts of elements in the parallel rtx.\n+     Last one is update base register if bim_p.\n+     and pick up the first element.  */\n+  if (bim_p)\n+    {\n+      count = XVECLEN (op, 0) - 1;\n+      elt = XVECEXP (op, 0, 1);\n+    }\n+  else\n+    {\n+      count = XVECLEN (op, 0);\n+      elt = XVECEXP (op, 0, 0);\n+    }\n \n   /* Perform some quick check for the first element in the parallel rtx.  */\n   if (GET_CODE (elt) != SET\n       || count <= 1\n-      || count > 8)\n+      || count > 25)\n     return false;\n \n   /* Pick up regno of first element for further detail checking.\n@@ -141,11 +153,29 @@ nds32_valid_multiple_load_store (rtx op, bool load_p)\n      Refer to nds32-multiple.md for more information\n      about following checking.\n      The starting element of parallel rtx is index 0.  */\n-  if (!nds32_consecutive_registers_load_store_p (op, load_p, 0,\n+  if (!nds32_consecutive_registers_load_store_p (op, load_p, bim_p ? 1 : 0,\n \t\t\t\t\t\t first_elt_regno,\n \t\t\t\t\t\t count))\n     return false;\n \n+  if (bim_p)\n+    {\n+      update_base_elt_idx = 0;\n+      update_base = XVECEXP (op, 0, update_base_elt_idx);\n+      if (!REG_P (SET_DEST (update_base)))\n+\treturn false;\n+      if (GET_CODE (SET_SRC (update_base)) != PLUS)\n+\treturn false;\n+      else\n+\t{\n+\t  offset = count * UNITS_PER_WORD;\n+\t  elt = XEXP (SET_SRC (update_base), 1);\n+\t  if (GET_CODE (elt) != CONST_INT\n+\t      || (INTVAL (elt) != offset))\n+\t    return false;\n+\t}\n+    }\n+\n   /* Pass all test, this is a valid rtx.  */\n   return true;\n }"}, {"sha": "d51d55949ab7cde979925555b9b471ac0f071d53", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=32a6f4f4886bdd41db8c2b342316da42e9c5f392", "patch": "@@ -66,8 +66,8 @@ extern bool nds32_valid_smw_lwm_base_p (rtx);\n \n /* Auxiliary functions for expanding rtl used in nds32-multiple.md.  */\n \n-extern rtx nds32_expand_load_multiple (int, int, rtx, rtx);\n-extern rtx nds32_expand_store_multiple (int, int, rtx, rtx);\n+extern rtx nds32_expand_load_multiple (int, int, rtx, rtx, bool, rtx *);\n+extern rtx nds32_expand_store_multiple (int, int, rtx, rtx, bool, rtx *);\n extern int nds32_expand_movmemqi (rtx, rtx, rtx, rtx);\n \n /* Auxiliary functions for expand unalign load instruction.  */\n@@ -80,7 +80,7 @@ extern void nds32_expand_unaligned_store (rtx *, enum machine_mode);\n \n /* Auxiliary functions for multiple load/store predicate checking.  */\n \n-extern bool nds32_valid_multiple_load_store (rtx, bool);\n+extern bool nds32_valid_multiple_load_store_p (rtx, bool, bool);\n \n /* Auxiliary functions for stack operation predicate checking.  */\n "}, {"sha": "bff37c71c4a53a44f47115fc563619d0f30ccbdf", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a6f4f4886bdd41db8c2b342316da42e9c5f392/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=32a6f4f4886bdd41db8c2b342316da42e9c5f392", "patch": "@@ -66,15 +66,33 @@\n {\n   /* To verify 'load' operation, pass 'true' for the second argument.\n      See the implementation in nds32.c for details.  */\n-  return nds32_valid_multiple_load_store (op, true);\n+  return nds32_valid_multiple_load_store_p (op, true, false);\n+})\n+\n+(define_special_predicate \"nds32_load_multiple_and_update_address_operation\"\n+  (match_code \"parallel\")\n+{\n+  /* To verify 'load' operation, pass 'true' for the second argument.\n+     to verify 'update address' operation, pass 'true' for the third argument\n+     See the implementation in nds32.c for details.  */\n+  return nds32_valid_multiple_load_store_p (op, true, true);\n })\n \n (define_special_predicate \"nds32_store_multiple_operation\"\n   (match_code \"parallel\")\n {\n   /* To verify 'store' operation, pass 'false' for the second argument.\n      See the implementation in nds32.c for details.  */\n-  return nds32_valid_multiple_load_store (op, false);\n+  return nds32_valid_multiple_load_store_p (op, false, false);\n+})\n+\n+(define_special_predicate \"nds32_store_multiple_and_update_address_operation\"\n+  (match_code \"parallel\")\n+{\n+  /* To verify 'store' operation, pass 'false' for the second argument,\n+     to verify 'update address' operation, pass 'true' for the third argument\n+     See the implementation in nds32.c for details.  */\n+  return nds32_valid_multiple_load_store_p (op, false, true);\n })\n \n (define_special_predicate \"nds32_stack_push_operation\""}]}