{"sha": "cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YzY2Q0M2Q1YWM1NmFlNzM2NzlmMGJiOGI3NjgwN2FhYWY4NjhkZA==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2018-06-02T14:22:12Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-06-02T14:22:12Z"}, "message": "[NDS32] Support Linux target for nds32.\n\ngcc/\n\t* config.gcc (nds32*): Use nds32-linux.opt and nds32-elf.opt.\n\t(nds32le-*-*, nds32be-*-*): Integrate checking process.\n\t(nds32*-*-*): Add glibc and uclibc conditions.\n\t* common/config/nds32/nds32-common.c (nds32_except_unwind_info): New.\n\t(TARGET_EXCEPT_UNWIND_INFO): Define.\n\t* config/nds32/elf.h: New file.\n\t* config/nds32/linux.h: New file.\n\t* config/nds32/nds32-elf.opt: New file.\n\t* config/nds32/nds32-linux.opt: New file.\n\t* config/nds32/nds32-fp-as-gp.c\n\t(pass_nds32_fp_as_gp::gate): Consider TARGET_LINUX_ABI.\n\t* config/nds32/nds32.c (nds32_conditional_register_usage): Consider\n\tTARGET_LINUX_ABI.\n\t(nds32_asm_file_end): Ditto.\n\t(nds32_print_operand): Ditto.\n\t(nds32_insert_attributes): Ditto.\n\t(nds32_init_libfuncs): New function.\n\t(TARGET_HAVE_TLS): Define.\n\t(TARGET_INIT_LIBFUNCS): Define.\n\t* config/nds32/nds32.h (TARGET_DEFAULT_RELAX): Apply different relax\n\tspec content.\n\t(TARGET_ELF): Apply different mcmodel setting.\n\t(LINK_SPEC, LIB_SPEC, STARTFILE_SPEC, ENDFILE_SPEC): The content has\n\tbeen migrated into elf.h and linux.h files.\n\t* config/nds32/nds32.md (add_pc): Consider TARGET_LINUX_ABI.\n\t* config/nds32/nds32.opt (mvh): Consider TARGET_LINUX_ABI.\n\t(mcmodel): The content has been migrated into nds32-elf.opt and\n\tnds32-linux.opt files.\n\t* config/nds32/t-elf: New file.\n\t* config/nds32/t-linux: New file.\n\nlibgcc/\n\t* config.host (nds32*-linux*): New.\n\t* config/nds32/linux-atomic.c: New file.\n\t* config/nds32/linux-unwind.h: New file.\n\nCo-Authored-By: Kito Cheng <kito.cheng@gmail.com>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r261116", "tree": {"sha": "90aef7941c0537da42c7844369f7e4133fc7bb9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90aef7941c0537da42c7844369f7e4133fc7bb9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b"}], "stats": {"total": 948, "additions": 876, "deletions": 72}, "files": [{"sha": "0e6eef70fbb6e32bd692e5edd803b00e40043c12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -1,3 +1,37 @@\n+2018-06-02  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito.cheng@gmail.com>\n+\n+\t* config.gcc (nds32*): Use nds32-linux.opt and nds32-elf.opt.\n+\t(nds32le-*-*, nds32be-*-*): Integrate checking process.\n+\t(nds32*-*-*): Add glibc and uclibc conditions.\n+\t* common/config/nds32/nds32-common.c (nds32_except_unwind_info): New.\n+\t(TARGET_EXCEPT_UNWIND_INFO): Define.\n+\t* config/nds32/elf.h: New file.\n+\t* config/nds32/linux.h: New file.\n+\t* config/nds32/nds32-elf.opt: New file.\n+\t* config/nds32/nds32-linux.opt: New file.\n+\t* config/nds32/nds32-fp-as-gp.c\n+\t(pass_nds32_fp_as_gp::gate): Consider TARGET_LINUX_ABI.\n+\t* config/nds32/nds32.c (nds32_conditional_register_usage): Consider\n+\tTARGET_LINUX_ABI.\n+\t(nds32_asm_file_end): Ditto.\n+\t(nds32_print_operand): Ditto.\n+\t(nds32_insert_attributes): Ditto.\n+\t(nds32_init_libfuncs): New function.\n+\t(TARGET_HAVE_TLS): Define.\n+\t(TARGET_INIT_LIBFUNCS): Define.\n+\t* config/nds32/nds32.h (TARGET_DEFAULT_RELAX): Apply different relax\n+\tspec content.\n+\t(TARGET_ELF): Apply different mcmodel setting.\n+\t(LINK_SPEC, LIB_SPEC, STARTFILE_SPEC, ENDFILE_SPEC): The content has\n+\tbeen migrated into elf.h and linux.h files.\n+\t* config/nds32/nds32.md (add_pc): Consider TARGET_LINUX_ABI.\n+\t* config/nds32/nds32.opt (mvh): Consider TARGET_LINUX_ABI.\n+\t(mcmodel): The content has been migrated into nds32-elf.opt and\n+\tnds32-linux.opt files.\n+\t* config/nds32/t-elf: New file.\n+\t* config/nds32/t-linux: New file.\n+\n 2018-06-02  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Shiva Chen  <shiva0217@gmail.com>\n "}, {"sha": "e4478f166c51ec9a724dd75684fab4b171762dad", "filename": "gcc/common/config/nds32/nds32-common.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fcommon%2Fconfig%2Fnds32%2Fnds32-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fcommon%2Fconfig%2Fnds32%2Fnds32-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fnds32%2Fnds32-common.c?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -87,6 +87,19 @@ static const struct default_options nds32_option_optimization_table[] =\n };\n \n /* ------------------------------------------------------------------------ */\n+\n+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */\n+static enum unwind_info_type\n+nds32_except_unwind_info (struct gcc_options *opts ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_LINUX_ABI)\n+    return UI_DWARF2;\n+\n+  return UI_SJLJ;\n+}\n+\n+/* ------------------------------------------------------------------------ */\n+\n \f\n /* Run-time Target Specification.  */\n \n@@ -127,7 +140,7 @@ static const struct default_options nds32_option_optimization_table[] =\n /* Defining the Output Assembler Language.  */\n \n #undef TARGET_EXCEPT_UNWIND_INFO\n-#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n+#define TARGET_EXCEPT_UNWIND_INFO nds32_except_unwind_info\n \n /* ------------------------------------------------------------------------ */\n "}, {"sha": "c3aecbfe764e62a945ddf6db3529a56625d70bf3", "filename": "gcc/config.gcc", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -448,6 +448,16 @@ mips*-*-*)\n nds32*)\n \tcpu_type=nds32\n \textra_headers=\"nds32_intrinsic.h\"\n+\tcase ${target} in\n+\t  nds32*-*-linux*)\n+\t    extra_options=\"${extra_options} nds32/nds32-linux.opt\"\n+\t    ;;\n+\t  nds32*-*-elf*)\n+\t    extra_options=\"${extra_options} nds32/nds32-elf.opt\"\n+\t    ;;\n+\t  *)\n+\t    ;;\n+\tesac\n \textra_objs=\"nds32-cost.o nds32-intrinsic.o nds32-isr.o nds32-md-auxiliary.o nds32-pipelines-auxiliary.o nds32-predicates.o nds32-memory-manipulation.o nds32-fp-as-gp.o nds32-relax-opt.o nds32-utils.o\"\n \t;;\n nios2-*-*)\n@@ -2335,18 +2345,32 @@ msp430*-*-*)\n \ttmake_file=\"${tmake_file} msp430/t-msp430\"\n \textra_gcc_objs=\"driver-msp430.o\"\n \t;;\n-nds32le-*-*)\n+nds32*-*-*)\n \ttarget_cpu_default=\"0\"\n \ttm_defines=\"${tm_defines}\"\n-\ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file} nds32/nds32_intrinsic.h\"\n-\ttmake_file=\"nds32/t-nds32 nds32/t-mlibs\"\n-\t;;\n-nds32be-*-*)\n-\ttarget_cpu_default=\"0|MASK_BIG_ENDIAN\"\n-\ttm_defines=\"${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1\"\n-\ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file} nds32/nds32_intrinsic.h\"\n-\ttmake_file=\"nds32/t-nds32 nds32/t-mlibs\"\n+\tcase ${target} in\n+\t  nds32le*-*-*)\n+\t    ;;\n+\t  nds32be-*-*)\n+\t    target_cpu_default=\"${target_cpu_default}|MASK_BIG_ENDIAN\"\n+\t    tm_defines=\"${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1\"\n+\t    ;;\n+\tesac\n+\tcase ${target} in\n+\t  nds32*-*-elf*)\n+\t    tm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file} nds32/elf.h nds32/nds32_intrinsic.h\"\n+\t    tmake_file=\"nds32/t-nds32 nds32/t-elf\"\n+\t    ;;\n+\t  nds32*-*-linux*)\n+\t    tm_file=\"dbxelf.h elfos.h ${tm_file} gnu-user.h linux.h glibc-stdint.h nds32/linux.h nds32/nds32_intrinsic.h\"\n+\t    tmake_file=\"${tmake_file} nds32/t-nds32 nds32/t-linux\"\n+\t    ;;\n+\tesac\n \n+\t# Handle --enable-default-relax setting.\n+\tif test x${enable_default_relax} = xyes; then\n+\t\ttm_defines=\"${tm_defines} TARGET_DEFAULT_RELAX=1\"\n+\tfi\n \t# Handle --with-ext-dsp\n \tif test x${with_ext_dsp} = xyes; then\n \t\ttm_defines=\"${tm_defines} TARGET_DEFAULT_EXT_DSP=1\"\n@@ -4383,15 +4407,30 @@ case \"${target}\" in\n \t\t\"\")\n \t\t\t# the default library is newlib\n \t\t\twith_nds32_lib=newlib\n+\t\t\ttm_defines=\"${tm_defines} TARGET_DEFAULT_CTOR_DTOR=1\"\n \t\t\t;;\n \t\tnewlib)\n \t\t\t# OK\n+\t\t\ttm_defines=\"${tm_defines} TARGET_DEFAULT_CTOR_DTOR=1\"\n \t\t\t;;\n \t\tmculib)\n \t\t\t# OK\n+\t\t\t# for the arch=v3f or arch=v3s under mculib toolchain,\n+\t\t\t# we would like to set -fno-math-errno as default\n+\t\t\tcase \"${with_arch}\" in\n+\t\t\tv3f | v3s)\n+\t\t\t\ttm_defines=\"${tm_defines} TARGET_DEFAULT_NO_MATH_ERRNO=1\"\n+\t\t\t\t;;\n+\t\t\tesac\n+\t\t\t;;\n+\t\tglibc)\n+\t\t\t# OK\n+\t\t\ttm_defines=\"${tm_defines} TARGET_DEFAULT_TLSDESC_TRAMPOLINE=1\"\n+\t\t\t;;\n+\t\tuclibc)\n \t\t\t;;\n \t\t*)\n-\t\t\techo \"Cannot accept --with-nds32-lib=$with_nds32_lib, available values are: newlib mculib\" 1>&2\n+\t\t\techo \"Cannot accept --with-nds32-lib=$with_nds32_lib, available values are: newlib mculib glibc uclibc\" 1>&2\n \t\t\texit 1\n \t\t\t;;\n \t\tesac"}, {"sha": "66397ac2e30f0c56479a7a065f3b303be8ce93d2", "filename": "gcc/config/nds32/elf.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Felf.h?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,81 @@\n+/* Definitions of target machine of Andes NDS32 cpu for GNU compiler\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Contributed by Andes Technology Corporation.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#define TARGET_LINUX_ABI 0\n+\n+/* In the configure stage we may use options --enable-default-relax,\n+   --enable-Os-default-ifc and --enable-Os-default-ex9.  They effect\n+   the default spec of passing --relax, --mifc, and --mex9 to linker.\n+   We use NDS32_RELAX_SPEC, NDS32_IFC_SPEC, and NDS32_EX9_SPEC\n+   so that we can customize them conveniently.  */\n+#define LINK_SPEC \\\n+  \" %{G*}\" \\\n+  \" %{mbig-endian:-EB} %{mlittle-endian:-EL}\" \\\n+  \" %{shared:-shared}\" \\\n+  NDS32_RELAX_SPEC\n+\n+#define LIB_SPEC \\\n+  \" -lc -lgloss\"\n+\n+#define LIBGCC_SPEC \\\n+  \" -lgcc\"\n+\n+/* The option -mno-ctor-dtor can disable constructor/destructor feature\n+   by applying different crt stuff.  In the convention, crt0.o is the\n+   startup file without constructor/destructor;\n+   crt1.o, crti.o, crtbegin.o, crtend.o, and crtn.o are the\n+   startup files with constructor/destructor.\n+   Note that crt0.o, crt1.o, crti.o, and crtn.o are provided\n+   by newlib/mculib/glibc/ublic, while crtbegin.o and crtend.o are\n+   currently provided by GCC for nds32 target.\n+\n+   For nds32 target so far:\n+   If -mno-ctor-dtor, we are going to link\n+   \"crt0.o [user objects]\".\n+   If -mctor-dtor, we are going to link\n+   \"crt1.o crtbegin1.o [user objects] crtend1.o\".\n+\n+   Note that the TARGET_DEFAULT_CTOR_DTOR would effect the\n+   default behavior.  Check gcc/config.gcc for more information.  */\n+#ifdef TARGET_DEFAULT_CTOR_DTOR\n+  #define STARTFILE_SPEC \\\n+    \" %{!mno-ctor-dtor:crt1.o%s;:crt0.o%s}\" \\\n+    \" %{!mno-ctor-dtor:crtbegin1.o%s}\" \\\n+    \" %{mcrt-arg:crtarg.o%s}\"\n+  #define ENDFILE_SPEC \\\n+    \" %{!mno-ctor-dtor:crtend1.o%s}\"\n+#else\n+  #define STARTFILE_SPEC \\\n+    \" %{mctor-dtor|coverage:crt1.o%s;:crt0.o%s}\" \\\n+    \" %{mctor-dtor|coverage:crtbegin1.o%s}\" \\\n+    \" %{mcrt-arg:crtarg.o%s}\"\n+  #define ENDFILE_SPEC \\\n+    \" %{mctor-dtor|coverage:crtend1.o%s}\"\n+#endif\n+\n+#define STARTFILE_CXX_SPEC \\\n+  \" %{!mno-ctor-dtor:crt1.o%s;:crt0.o%s}\" \\\n+  \" %{!mno-ctor-dtor:crtbegin1.o%s}\" \\\n+  \" %{mcrt-arg:crtarg.o%s}\"\n+#define ENDFILE_CXX_SPEC \\\n+  \" %{!mno-ctor-dtor:crtend1.o%s}\""}, {"sha": "a0ec1b2bfd4291d2a569c40f4abbb8f66725f845", "filename": "gcc/config/nds32/linux.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Flinux.h?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,77 @@\n+/* Definitions of target machine of Andes NDS32 cpu for GNU compiler\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Contributed by Andes Technology Corporation.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#define TARGET_LINUX_ABI 1\n+\n+#undef  SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#ifdef TARGET_DEFAULT_TLSDESC_TRAMPOLINE\n+  #define NDS32_TLSDESC_TRAMPOLINE_SPEC \\\n+    \" %{!mno-tlsdesc-trampoline:--mtlsdesc-trampoline}\"\n+#else\n+  #define NDS32_TLSDESC_TRAMPOLINE_SPEC \"\"\n+#endif\n+\n+#define TARGET_OS_CPP_BUILTINS()                \\\n+  do                                            \\\n+    {                                           \\\n+      GNU_USER_TARGET_OS_CPP_BUILTINS();           \\\n+    }                                           \\\n+  while (0)\n+\n+#define GLIBC_DYNAMIC_LINKER \"/lib/ld.so.1\"\n+\n+/* In the configure stage we may use options --enable-default-relax,\n+   --enable-Os-default-ifc and --enable-Os-default-ex9.  They effect\n+   the default spec of passing --relax, --mifc, and --mex9 to linker.\n+   We use NDS32_RELAX_SPEC, NDS32_IFC_SPEC, and NDS32_EX9_SPEC\n+   so that we can customize them conveniently.  */\n+#define LINK_SPEC \\\n+ \" %{G*}\" \\\n+ \" %{mbig-endian:-EB} %{mlittle-endian:-EL}\" \\\n+ \" %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      -dynamic-linker \" GNU_USER_DYNAMIC_LINKER \"} \\\n+    %{static:-static}}\" \\\n+  NDS32_RELAX_SPEC \\\n+  NDS32_TLSDESC_TRAMPOLINE_SPEC\n+\n+#define LINK_PIE_SPEC \"%{pie:%{!fno-pie:%{!fno-PIE:%{!static:-pie}}}} \"\n+\n+#define CPP_SPEC \"%{pthread:-D_REENTRANT}\"\n+\n+/* The SYNC operations are implemented as library functions, not\n+   INSN patterns.  As a result, the HAVE defines for the patterns are\n+   not defined.  We need to define them to generate the corresponding\n+   __GCC_HAVE_SYNC_COMPARE_AND_SWAP_* and __GCC_ATOMIC_*_LOCK_FREE\n+   defines.\n+   Ref: https://sourceware.org/ml/libc-alpha/2014-09/msg00322.html  */\n+#define HAVE_sync_compare_and_swapqi 1\n+#define HAVE_sync_compare_and_swaphi 1\n+#define HAVE_sync_compare_and_swapsi 1"}, {"sha": "afe6aadd089660f36111e016b086d6e0f54536c6", "filename": "gcc/config/nds32/nds32-elf.opt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32-elf.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32-elf.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-elf.opt?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,16 @@\n+mcmodel=\n+Target RejectNegative Joined Enum(nds32_cmodel_type) Var(nds32_cmodel_option) Init(CMODEL_MEDIUM)\n+Specify the address generation strategy for code model.\n+\n+Enum\n+Name(nds32_cmodel_type) Type(enum nds32_cmodel_type)\n+Known cmodel types (for use with the -mcmodel= option):\n+\n+EnumValue\n+Enum(nds32_cmodel_type) String(small) Value(CMODEL_SMALL)\n+\n+EnumValue\n+Enum(nds32_cmodel_type) String(medium) Value(CMODEL_MEDIUM)\n+\n+EnumValue\n+Enum(nds32_cmodel_type) String(large) Value(CMODEL_LARGE)"}, {"sha": "26d2865d450b1d6caae227f5212040deb192fd6d", "filename": "gcc/config/nds32/nds32-fp-as-gp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -265,7 +265,8 @@ class pass_nds32_fp_as_gp : public rtl_opt_pass\n   /* opt_pass methods: */\n   bool gate (function *)\n   {\n-    return TARGET_16_BIT\n+    return !TARGET_LINUX_ABI\n+\t   && TARGET_16_BIT\n \t   && optimize_size;\n   }\n   unsigned int execute (function *) { return nds32_fp_as_gp (); }"}, {"sha": "75ccd7625a29acf0ad0024055db7554bdaa342df", "filename": "gcc/config/nds32/nds32-linux.opt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32-linux.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32-linux.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-linux.opt?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,16 @@\n+mcmodel=\n+Target RejectNegative Joined Enum(nds32_cmodel_type) Var(nds32_cmodel_option) Init(CMODEL_LARGE)\n+Specify the address generation strategy for code model.\n+\n+Enum\n+Name(nds32_cmodel_type) Type(enum nds32_cmodel_type)\n+Known cmodel types (for use with the -mcmodel= option):\n+\n+EnumValue\n+Enum(nds32_cmodel_type) String(small) Value(CMODEL_SMALL)\n+\n+EnumValue\n+Enum(nds32_cmodel_type) String(medium) Value(CMODEL_MEDIUM)\n+\n+EnumValue\n+Enum(nds32_cmodel_type) String(large) Value(CMODEL_LARGE)"}, {"sha": "a0b6443e5d21930874fd69f64511bce3a07b28eb", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -1698,6 +1698,9 @@ nds32_conditional_register_usage (void)\n {\n   int regno;\n \n+  if (TARGET_LINUX_ABI)\n+    fixed_regs[TP_REGNUM] = 1;\n+\n   if (TARGET_HARD_FLOAT)\n     {\n       for (regno = NDS32_FIRST_FPR_REGNUM;\n@@ -3120,21 +3123,30 @@ nds32_asm_file_start (void)\n   fprintf (asm_out_file, \"\\t! This asm file is generated by compiler\\n\");\n   fprintf (asm_out_file, \"\\t.flag\\tverbatim\\n\");\n \n-  if (TARGET_ICT_MODEL_LARGE)\n-    fprintf (asm_out_file, \"\\t.ict_model\\tlarge\\n\");\n-  else\n-    fprintf (asm_out_file, \"\\t.ict_model\\tsmall\\n\");\n-  /* Give assembler the size of each vector for interrupt handler.  */\n-  fprintf (asm_out_file, \"\\t! This vector size directive is required \"\n-\t\t\t \"for checking inconsistency on interrupt handler\\n\");\n-  fprintf (asm_out_file, \"\\t.vec_size\\t%d\\n\", nds32_isr_vector_size);\n+  /* Insert directive for linker to distinguish object's ict flag.  */\n+  if (!TARGET_LINUX_ABI)\n+    {\n+      if (TARGET_ICT_MODEL_LARGE)\n+\tfprintf (asm_out_file, \"\\t.ict_model\\tlarge\\n\");\n+      else\n+\tfprintf (asm_out_file, \"\\t.ict_model\\tsmall\\n\");\n+    }\n+\n+  /* We need to provide the size of each vector for interrupt handler\n+     under elf toolchain.  */\n+  if (!TARGET_LINUX_ABI)\n+    {\n+      fprintf (asm_out_file, \"\\t! This vector size directive is required \"\n+\t\t\t     \"for checking inconsistency on interrupt handler\\n\");\n+      fprintf (asm_out_file, \"\\t.vec_size\\t%d\\n\", nds32_isr_vector_size);\n+    }\n \n   /* If user enables '-mforce-fp-as-gp' or compiles programs with -Os,\n      the compiler may produce 'la $fp,_FP_BASE_' instruction\n      at prologue for fp-as-gp optimization.\n      We should emit weak reference of _FP_BASE_ to avoid undefined reference\n      in case user does not pass '--relax' option to linker.  */\n-  if (TARGET_FORCE_FP_AS_GP || optimize_size)\n+  if (!TARGET_LINUX_ABI && (TARGET_FORCE_FP_AS_GP || optimize_size))\n     {\n       fprintf (asm_out_file, \"\\t! This weak reference is required to do \"\n \t\t\t     \"fp-as-gp link time optimization\\n\");\n@@ -3270,6 +3282,11 @@ nds32_asm_file_end (void)\n {\n   nds32_asm_file_end_for_isr ();\n \n+  /* The NDS32 Linux stack is mapped non-executable by default, so add a\n+     .note.GNU-stack section.  */\n+  if (TARGET_LINUX_ABI)\n+    file_end_indicate_exec_stack ();\n+\n   fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n }\n \n@@ -3497,7 +3514,7 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n     case SYMBOL_REF:\n       output_addr_const (stream, x);\n \n-      if (nds32_indirect_call_referenced_p (x))\n+      if (!TARGET_LINUX_ABI && nds32_indirect_call_referenced_p (x))\n \tfprintf (stream, \"@ICT\");\n \n       break;\n@@ -3912,6 +3929,9 @@ nds32_insert_attributes (tree decl, tree *attributes)\n     {\n       tree new_attrs = *attributes;\n \n+      if (TARGET_LINUX_ABI)\n+\terror(\"cannot use indirect_call attribute under linux toolchain\");\n+\n       if (lookup_attribute (\"noinline\", new_attrs) == NULL)\n \tnew_attrs = tree_cons (get_identifier (\"noinline\"), NULL, new_attrs);\n       if (lookup_attribute (\"noclone\", new_attrs) == NULL)\n@@ -4166,6 +4186,13 @@ nds32_expand_builtin (tree exp,\n   return nds32_expand_builtin_impl (exp, target, subtarget, mode, ignore);\n }\n \n+/* Implement TARGET_INIT_LIBFUNCS.  */\n+static void\n+nds32_init_libfuncs (void)\n+{\n+  if (TARGET_LINUX_ABI)\n+    init_sync_libfuncs (UNITS_PER_WORD);\n+}\n \n /* ------------------------------------------------------------------------ */\n \n@@ -5758,6 +5785,9 @@ nds32_use_blocks_for_constant_p (machine_mode mode,\n \f\n /* Emulating TLS.  */\n \n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS TARGET_LINUX_ABI\n+\n \f\n /* Defining coprocessor specifics for MIPS targets.  */\n \n@@ -5785,6 +5815,8 @@ nds32_use_blocks_for_constant_p (machine_mode mode,\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN nds32_expand_builtin\n \n+#undef TARGET_INIT_LIBFUNCS\n+#define TARGET_INIT_LIBFUNCS nds32_init_libfuncs\n \n #undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n #define TARGET_USE_BLOCKS_FOR_CONSTANT_P nds32_use_blocks_for_constant_p"}, {"sha": "84fae7d09dfaf82f86741fa0d800abfb5c188796", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -922,6 +922,14 @@ enum nds32_builtins\n \n #define TARGET_CONFIG_FPU_DEFAULT NDS32_CONFIG_FPU_2\n \n+/* ------------------------------------------------------------------------ */\n+\n+#ifdef TARGET_DEFAULT_RELAX\n+#  define NDS32_RELAX_SPEC \" %{!mno-relax:--relax}\"\n+#else\n+#  define NDS32_RELAX_SPEC \" %{mrelax:--relax}\"\n+#endif\n+\n #ifdef TARGET_DEFAULT_EXT_DSP\n #  define NDS32_EXT_DSP_SPEC \" %{!mno-ext-dsp:-mext-dsp}\"\n #else\n@@ -963,34 +971,6 @@ enum nds32_builtins\n   \" %{mext-dsp:-mdsp-ext}\" \\\n   \" %{O|O1|O2|O3|Ofast:-O1;:-Os}\"\n \n-/* If user issues -mrelax, we need to pass '--relax' to linker.  */\n-#define LINK_SPEC \\\n-  \" %{mbig-endian:-EB} %{mlittle-endian:-EL}\" \\\n-  \" %{mrelax:--relax}\"\n-\n-#define LIB_SPEC \\\n-  \" -lc -lgloss\"\n-\n-/* The option -mno-ctor-dtor can disable constructor/destructor feature\n-   by applying different crt stuff.  In the convention, crt0.o is the\n-   startup file without constructor/destructor;\n-   crt1.o, crti.o, crtbegin.o, crtend.o, and crtn.o are the\n-   startup files with constructor/destructor.\n-   Note that crt0.o, crt1.o, crti.o, and crtn.o are provided\n-   by newlib/mculib/glibc/ublic, while crtbegin.o and crtend.o are\n-   currently provided by GCC for nds32 target.\n-\n-   For nds32 target so far:\n-   If -mno-ctor-dtor, we are going to link\n-   \"crt0.o [user objects]\".\n-   If general cases, we are going to link\n-   \"crt1.o crtbegin1.o [user objects] crtend1.o\".  */\n-#define STARTFILE_SPEC \\\n-  \" %{!mno-ctor-dtor:crt1.o%s;:crt0.o%s}\" \\\n-  \" %{!mno-ctor-dtor:crtbegin1.o%s}\"\n-#define ENDFILE_SPEC \\\n-  \" %{!mno-ctor-dtor:crtend1.o%s}\"\n-\n /* The TARGET_BIG_ENDIAN_DEFAULT is defined if we\n    configure gcc with --target=nds32be-* setting.\n    Check gcc/config.gcc for more information.  */\n@@ -1000,9 +980,11 @@ enum nds32_builtins\n #  define NDS32_ENDIAN_DEFAULT \"mlittle-endian\"\n #endif\n \n-/* Currently we only have elf toolchain,\n-   where -mcmodel=medium is always the default.  */\n-#define NDS32_CMODEL_DEFAULT \"mcmodel=medium\"\n+#if TARGET_ELF\n+#  define NDS32_CMODEL_DEFAULT \"mcmodel=medium\"\n+#else\n+#  define NDS32_CMODEL_DEFAULT \"mcmodel=large\"\n+#endif\n \n #define MULTILIB_DEFAULTS \\\n   { NDS32_ENDIAN_DEFAULT, NDS32_CMODEL_DEFAULT }"}, {"sha": "92e90dda1afe8e338b651c185a79f16e1225d350", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -2221,7 +2221,7 @@\n   [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\"  \"0\")\n \t\t (pc)))]\n-  \"flag_pic\"\n+  \"TARGET_LINUX_ABI || flag_pic\"\n   \"add5.pc\\t%0\"\n   [(set_attr \"type\"    \"alu\")\n    (set_attr \"length\"    \"4\")]"}, {"sha": "871ae1e07ca84c6e991aae63eae71cccb3032686", "filename": "gcc/config/nds32/nds32.opt", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.opt?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -151,7 +151,7 @@ Target Report Mask(RELAX_HINT)\n Insert relax hint for linker to do relaxation.\n \n mvh\n-Target Report Mask(VH)\n+Target Report Mask(VH) Condition(!TARGET_LINUX_ABI)\n Enable Virtual Hosting support.\n \n misr-vector-size=\n@@ -185,23 +185,6 @@ Enum(nds32_arch_type) String(v3f) Value(ARCH_V3F)\n EnumValue\n Enum(nds32_arch_type) String(v3s) Value(ARCH_V3S)\n \n-mcmodel=\n-Target RejectNegative Joined Enum(nds32_cmodel_type) Var(nds32_cmodel_option) Init(CMODEL_LARGE)\n-Specify the address generation strategy for code model.\n-\n-Enum\n-Name(nds32_cmodel_type) Type(enum nds32_cmodel_type)\n-Known cmodel types (for use with the -mcmodel= option):\n-\n-EnumValue\n-Enum(nds32_cmodel_type) String(small) Value(CMODEL_SMALL)\n-\n-EnumValue\n-Enum(nds32_cmodel_type) String(medium) Value(CMODEL_MEDIUM)\n-\n-EnumValue\n-Enum(nds32_cmodel_type) String(large) Value(CMODEL_LARGE)\n-\n mcpu=\n Target RejectNegative Joined Enum(nds32_cpu_type) Var(nds32_cpu_option) Init(CPU_N9)\n Specify the cpu for pipeline model."}, {"sha": "3401dae48810731deba29e716558081960d3133f", "filename": "gcc/config/nds32/t-elf", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Ft-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Ft-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Ft-elf?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,42 @@\n+# The multilib settings of Andes NDS32 cpu for GNU compiler\n+# Copyright (C) 2012-2018 Free Software Foundation, Inc.\n+# Contributed by Andes Technology Corporation.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# We also define a macro MULTILIB_DEFAULTS in nds32.h that tells the\n+# driver program which options are defaults for this target and thus\n+# do not need to be handled specially.\n+MULTILIB_OPTIONS += mcmodel=small/mcmodel=medium/mcmodel=large mvh\n+\n+ifneq ($(filter graywolf,$(TM_MULTILIB_CONFIG)),)\n+MULTILIB_OPTIONS += mcpu=graywolf\n+endif\n+\n+ifneq ($(filter dsp,$(TM_MULTILIB_CONFIG)),)\n+MULTILIB_OPTIONS += mext-dsp\n+endif\n+\n+ifneq ($(filter zol,$(TM_MULTILIB_CONFIG)),)\n+MULTILIB_OPTIONS += mext-zol\n+endif\n+\n+ifneq ($(filter v3m+,$(TM_MULTILIB_CONFIG)),)\n+MULTILIB_OPTIONS += march=v3m+\n+endif\n+\n+# ------------------------------------------------------------------------"}, {"sha": "33328f65e7b3ea8792893ad8187495d9ec05af73", "filename": "gcc/config/nds32/t-linux", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/gcc%2Fconfig%2Fnds32%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Ft-linux?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,26 @@\n+# The multilib settings of Andes NDS32 cpu for GNU compiler\n+# Copyright (C) 2012-2018 Free Software Foundation, Inc.\n+# Contributed by Andes Technology Corporation.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# We also define a macro MULTILIB_DEFAULTS in nds32.h that tells the\n+# driver program which options are defaults for this target and thus\n+# do not need to be handled specially.\n+MULTILIB_OPTIONS +=\n+\n+# ------------------------------------------------------------------------"}, {"sha": "d75d9340a089a83145cf403891da5c7869b96066", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -1,3 +1,10 @@\n+2018-06-02  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\n+\t* config.host (nds32*-linux*): New.\n+\t* config/nds32/linux-atomic.c: New file.\n+\t* config/nds32/linux-unwind.h: New file.\n+\n 2018-05-31  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/85591"}, {"sha": "18cabaf24f6c9c038b149737271d02a8ffbcde7b", "filename": "libgcc/config.host", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -979,6 +979,23 @@ msp430*-*-elf)\n \ttmake_file=\"$tm_file t-crtstuff t-fdpbit msp430/t-msp430\"\n         extra_parts=\"$extra_parts libmul_none.a libmul_16.a libmul_32.a libmul_f5.a\"\n \t;;\n+nds32*-linux*)\n+\t# Basic makefile fragment and extra_parts for crt stuff.\n+\t# We also append c-isr library implementation.\n+\ttmake_file=\"${tmake_file} t-slibgcc-libgcc\"\n+\ttmake_file=\"${tmake_file} nds32/t-nds32-glibc nds32/t-crtstuff t-softfp-sfdf t-softfp\"\n+\t# The header file of defining MD_FALLBACK_FRAME_STATE_FOR.\n+\tmd_unwind_header=nds32/linux-unwind.h\n+\t# Append library definition makefile fragment according to --with-nds32-lib=X setting.\n+\tcase \"${with_nds32_lib}\" in\n+\t\"\" | glibc | uclibc )\n+\t\t;;\n+\t*)\n+\t\techo \"Cannot accept --with-nds32-lib=$with_nds32_lib, available values are: glibc uclibc\" 1>&2\n+\t\texit 1\n+\t\t;;\n+\tesac\n+\t;;\n nds32*-elf*)\n \t# Basic makefile fragment and extra_parts for crt stuff.\n \t# We also append c-isr library implementation."}, {"sha": "6da7be9a6535e699fbe04f352f5724ec147e5c93", "filename": "libgcc/config/nds32/linux-atomic.c", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2Fconfig%2Fnds32%2Flinux-atomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2Fconfig%2Fnds32%2Flinux-atomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnds32%2Flinux-atomic.c?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,282 @@\n+/* Linux-specific atomic operations for NDS32 Linux.\n+   Copyright (C) 2012-2018 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* We implement byte, short and int versions of each atomic operation\n+   using the kernel helper defined below.  There is no support for\n+   64-bit operations yet.  */\n+\n+/* This function copy form NDS32 Linux-kernal. */\n+static inline int\n+__kernel_cmpxchg (int oldval, int newval, int *mem)\n+{\n+  int temp1, temp2, temp3, offset;\n+\n+  asm volatile (\"msync\\tall\\n\"\n+\t\t\"movi\\t%0, #0\\n\"\n+\t\t\"1:\\n\"\n+\t\t\"\\tllw\\t%1, [%4+%0]\\n\"\n+\t\t\"\\tsub\\t%3, %1, %6\\n\"\n+\t\t\"\\tcmovz\\t%2, %5, %3\\n\"\n+\t\t\"\\tcmovn\\t%2, %1, %3\\n\"\n+\t\t\"\\tscw\\t%2, [%4+%0]\\n\"\n+\t\t\"\\tbeqz\\t%2, 1b\\n\"\n+\t\t: \"=&r\" (offset), \"=&r\" (temp3), \"=&r\" (temp2), \"=&r\" (temp1)\n+\t\t: \"r\" (mem), \"r\" (newval), \"r\" (oldval) : \"memory\");\n+\n+  return temp1;\n+}\n+\n+#define HIDDEN __attribute__ ((visibility (\"hidden\")))\n+\n+#ifdef __NDS32_EL__\n+#define INVERT_MASK_1 0\n+#define INVERT_MASK_2 0\n+#else\n+#define INVERT_MASK_1 24\n+#define INVERT_MASK_2 16\n+#endif\n+\n+#define MASK_1 0xffu\n+#define MASK_2 0xffffu\n+\n+#define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)\t\t\t\t\\\n+  int HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_fetch_and_##OP##_4 (int *ptr, int val)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int failure, tmp;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\t\\\n+      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return tmp;\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FETCH_AND_OP_WORD (add,   , +)\n+FETCH_AND_OP_WORD (sub,   , -)\n+FETCH_AND_OP_WORD (or,    , |)\n+FETCH_AND_OP_WORD (and,   , &)\n+FETCH_AND_OP_WORD (xor,   , ^)\n+FETCH_AND_OP_WORD (nand, ~, &)\n+\n+#define NAME_oldval(OP, WIDTH) __sync_fetch_and_##OP##_##WIDTH\n+#define NAME_newval(OP, WIDTH) __sync_##OP##_and_fetch_##WIDTH\n+\n+/* Implement both __sync_<op>_and_fetch and __sync_fetch_and_<op> for\n+   subword-sized quantities.  */\n+\n+#define SUBWORD_SYNC_OP(OP, PFX_OP, INF_OP, TYPE, WIDTH, RETURN)\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  NAME##_##RETURN (OP, WIDTH) (TYPE *ptr, TYPE val)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int *wordptr = (int *) ((unsigned long) ptr & ~3);\t\t\t\\\n+    unsigned int mask, shift, oldval, newval;\t\t\t\t\\\n+    int failure;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      oldval = __atomic_load_n (wordptr, __ATOMIC_SEQ_CST);\t\t\\\n+      newval = ((PFX_OP (((oldval & mask) >> shift)\t\t\t\\\n+\t\t\t INF_OP (unsigned int) val)) << shift) & mask;\t\\\n+      newval |= oldval & ~mask;\t\t\t\t\t\t\\\n+      failure = __kernel_cmpxchg (oldval, newval, wordptr);\t\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return (RETURN & mask) >> shift;\t\t\t\t\t\\\n+  }\n+\n+\n+SUBWORD_SYNC_OP (add,   , +, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (sub,   , -, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (or,    , |, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (and,   , &, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (xor,   , ^, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, oldval)\n+\n+SUBWORD_SYNC_OP (add,   , +, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (sub,   , -, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (or,    , |, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (and,   , &, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (xor,   , ^, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, oldval)\n+\n+#define OP_AND_FETCH_WORD(OP, PFX_OP, INF_OP)\t\t\t\t\\\n+  int HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_##OP##_and_fetch_4 (int *ptr, int val)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int tmp, failure;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\t\\\n+      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return PFX_OP (tmp INF_OP val);\t\t\t\t\t\\\n+  }\n+\n+OP_AND_FETCH_WORD (add,   , +)\n+OP_AND_FETCH_WORD (sub,   , -)\n+OP_AND_FETCH_WORD (or,    , |)\n+OP_AND_FETCH_WORD (and,   , &)\n+OP_AND_FETCH_WORD (xor,   , ^)\n+OP_AND_FETCH_WORD (nand, ~, &)\n+\n+SUBWORD_SYNC_OP (add,   , +, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (sub,   , -, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (or,    , |, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (and,   , &, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (xor,   , ^, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, newval)\n+\n+SUBWORD_SYNC_OP (add,   , +, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (sub,   , -, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (or,    , |, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (and,   , &, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (xor,   , ^, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, newval)\n+\n+int HIDDEN\n+__sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)\n+{\n+  int actual_oldval, fail;\n+\n+  while (1)\n+    {\n+      actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\n+\n+      if (oldval != actual_oldval)\n+\treturn actual_oldval;\n+\n+      fail = __kernel_cmpxchg (actual_oldval, newval, ptr);\n+\n+      if (!fail)\n+\treturn oldval;\n+    }\n+}\n+\n+#define SUBWORD_VAL_CAS(TYPE, WIDTH)\t\t\t\t\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,\t\t\\\n+\t\t\t\t       TYPE newval)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int *wordptr = (int *)((unsigned long) ptr & ~3), fail;\t\t\\\n+    unsigned int mask, shift, actual_oldval, actual_newval;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    while (1)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tactual_oldval = __atomic_load_n (wordptr, __ATOMIC_SEQ_CST); \t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (((actual_oldval & mask) >> shift) != (unsigned int) oldval)\t\\\n+\t  return (actual_oldval & mask) >> shift;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tactual_newval = (actual_oldval & ~mask)\t\t\t\t\\\n+\t\t\t| (((unsigned int) newval << shift) & mask);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfail = __kernel_cmpxchg (actual_oldval, actual_newval,\t\t\\\n+\t\t\t\t wordptr);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (!fail)\t\t\t\t\t\t\t\\\n+\t  return oldval;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_VAL_CAS (unsigned short, 2)\n+SUBWORD_VAL_CAS (unsigned char,  1)\n+\n+typedef unsigned char bool;\n+\n+bool HIDDEN\n+__sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)\n+{\n+  int failure = __kernel_cmpxchg (oldval, newval, ptr);\n+  return (failure == 0);\n+}\n+\n+#define SUBWORD_BOOL_CAS(TYPE, WIDTH)\t\t\t\t\t\\\n+  bool HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,\t\t\\\n+\t\t\t\t\tTYPE newval)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE actual_oldval\t\t\t\t\t\t\t\\\n+      = __sync_val_compare_and_swap_##WIDTH (ptr, oldval, newval);\t\\\n+    return (oldval == actual_oldval);\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_BOOL_CAS (unsigned short, 2)\n+SUBWORD_BOOL_CAS (unsigned char,  1)\n+\n+int HIDDEN\n+__sync_lock_test_and_set_4 (int *ptr, int val)\n+{\n+  int failure, oldval;\n+\n+  do {\n+    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\n+    failure = __kernel_cmpxchg (oldval, val, ptr);\n+  } while (failure != 0);\n+\n+  return oldval;\n+}\n+\n+#define SUBWORD_TEST_AND_SET(TYPE, WIDTH)\t\t\t\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int failure;\t\t\t\t\t\t\t\\\n+    unsigned int oldval, newval, shift, mask;\t\t\t\t\\\n+    int *wordptr = (int *) ((unsigned long) ptr & ~3);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      oldval = __atomic_load_n (wordptr, __ATOMIC_SEQ_CST);\t\t\\\n+      newval = (oldval & ~mask)\t\t\t\t\t\t\\\n+\t       | (((unsigned int) val << shift) & mask);\t\t\\\n+      failure = __kernel_cmpxchg (oldval, newval, wordptr);\t\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return (oldval & mask) >> shift;\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_TEST_AND_SET (unsigned short, 2)\n+SUBWORD_TEST_AND_SET (unsigned char,  1)\n+\n+#define SYNC_LOCK_RELEASE(TYPE, WIDTH)\t\t\t\t\t\\\n+  void HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_lock_release_##WIDTH (TYPE *ptr)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    /* All writes before this point must be seen before we release\t\\\n+       the lock itself.  */\t\t\t\t\t\t\\\n+    __builtin_nds32_msync_all ();\t\t\t\t\t\\\n+    *ptr = 0;\t\t\t\t\t\t\t\t\\\n+  }\n+\n+SYNC_LOCK_RELEASE (int,   4)\n+SYNC_LOCK_RELEASE (short, 2)\n+SYNC_LOCK_RELEASE (char,  1)"}, {"sha": "921edf906ea7a6b55335710f5cc883a1ce7984cc", "filename": "libgcc/config/nds32/linux-unwind.h", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2Fconfig%2Fnds32%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd/libgcc%2Fconfig%2Fnds32%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnds32%2Flinux-unwind.h?ref=cf3cd43d5ac56ae73679f0bb8b76807aaaf868dd", "patch": "@@ -0,0 +1,156 @@\n+/* DWARF2 EH unwinding support for NDS32 Linux signal frame.\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+   Contributed by Andes Technology Corporation.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef inhibit_libc\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.\n+   The corresponding bits in the Linux kernel are in\n+   arch/nds32/kernel/signal.c.  */\n+\n+#include <signal.h>\n+#include <asm/unistd.h>\n+\n+/* Exactly the same layout as the kernel structures, unique names.  */\n+\n+/* arch/nds32/kernel/signal.c */\n+struct _sigframe {\n+    struct ucontext uc;\n+    unsigned long retcode;\n+};\n+\n+struct _rt_sigframe {\n+  siginfo_t info;\n+  struct _sigframe sig;\n+};\n+#define SIGRETURN 0xeb0e0a64\n+#define RT_SIGRETURN 0xab150a64\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR nds32_fallback_frame_state\n+\n+/* This function is supposed to be invoked by uw_frame_state_for()\n+   when there is no unwind data available.\n+\n+   Generally, given the _Unwind_Context CONTEXT for a stack frame,\n+   we need to look up its caller and decode information into FS.\n+   However, if the exception handling happens within a signal handler,\n+   the return address of signal handler is a special module, which\n+   contains signal return syscall and has no FDE in the .eh_frame section.\n+   We need to implement MD_FALLBACK_FRAME_STATE_FOR so that we can\n+   unwind through signal frames.  */\n+static _Unwind_Reason_Code\n+nds32_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t    _Unwind_FrameState *fs)\n+{\n+  u_int32_t *pc = (u_int32_t *) context->ra;\n+  struct sigcontext *sc_;\n+  _Unwind_Ptr new_cfa;\n+\n+#ifdef __NDS32_EB__\n+#error \"Signal handler is not supported for force unwind.\"\n+#endif\n+\n+  if ((_Unwind_Ptr) pc & 3)\n+    return _URC_END_OF_STACK;\n+\n+  /* Check if we are going through a signal handler.\n+     See arch/nds32/kernel/signal.c implementation.\n+       SWI_SYS_SIGRETURN    -> (0xeb0e0a64)\n+       SWI_SYS_RT_SIGRETURN -> (0xab150a64)\n+     FIXME: Currently we only handle little endian (EL) case.  */\n+  if (pc[0] == SIGRETURN)\n+    {\n+      /* Using '_sigfame' memory address to locate kernal's sigcontext.\n+\t The sigcontext structures in arch/nds32/include/asm/sigcontext.h.  */\n+      struct _sigframe *rt_;\n+      rt_ = context->cfa;\n+      sc_ = &rt_->uc.uc_mcontext;\n+    }\n+  else if (pc[0] == RT_SIGRETURN)\n+    {\n+      /* Using '_sigfame' memory address to locate kernal's sigcontext.  */\n+      struct _rt_sigframe *rt_;\n+      rt_ = context->cfa;\n+      sc_ = &rt_->sig.uc.uc_mcontext;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  /* Update cfa from sigcontext.  */\n+  new_cfa = (_Unwind_Ptr) sc_;\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;\n+  fs->regs.cfa_offset = new_cfa - (_Unwind_Ptr) context->cfa;\n+\n+#define NDS32_PUT_FS_REG(NUM, NAME) \\\n+  (fs->regs.reg[NUM].how = REG_SAVED_OFFSET, \\\n+   fs->regs.reg[NUM].loc.offset = (_Unwind_Ptr) &(sc_->NAME) - new_cfa)\n+\n+  /* Restore all registers value.  */\n+  NDS32_PUT_FS_REG (0, nds32_r0);\n+  NDS32_PUT_FS_REG (1, nds32_r1);\n+  NDS32_PUT_FS_REG (2, nds32_r2);\n+  NDS32_PUT_FS_REG (3, nds32_r3);\n+  NDS32_PUT_FS_REG (4, nds32_r4);\n+  NDS32_PUT_FS_REG (5, nds32_r5);\n+  NDS32_PUT_FS_REG (6, nds32_r6);\n+  NDS32_PUT_FS_REG (7, nds32_r7);\n+  NDS32_PUT_FS_REG (8, nds32_r8);\n+  NDS32_PUT_FS_REG (9, nds32_r9);\n+  NDS32_PUT_FS_REG (10, nds32_r10);\n+  NDS32_PUT_FS_REG (11, nds32_r11);\n+  NDS32_PUT_FS_REG (12, nds32_r12);\n+  NDS32_PUT_FS_REG (13, nds32_r13);\n+  NDS32_PUT_FS_REG (14, nds32_r14);\n+  NDS32_PUT_FS_REG (15, nds32_r15);\n+  NDS32_PUT_FS_REG (16, nds32_r16);\n+  NDS32_PUT_FS_REG (17, nds32_r17);\n+  NDS32_PUT_FS_REG (18, nds32_r18);\n+  NDS32_PUT_FS_REG (19, nds32_r19);\n+  NDS32_PUT_FS_REG (20, nds32_r20);\n+  NDS32_PUT_FS_REG (21, nds32_r21);\n+  NDS32_PUT_FS_REG (22, nds32_r22);\n+  NDS32_PUT_FS_REG (23, nds32_r23);\n+  NDS32_PUT_FS_REG (24, nds32_r24);\n+  NDS32_PUT_FS_REG (25, nds32_r25);\n+\n+  NDS32_PUT_FS_REG (28, nds32_fp);\n+  NDS32_PUT_FS_REG (29, nds32_gp);\n+  NDS32_PUT_FS_REG (30, nds32_lp);\n+  NDS32_PUT_FS_REG (31, nds32_sp);\n+\n+  /* Restore PC, point to trigger signal instruction.  */\n+  NDS32_PUT_FS_REG (32, nds32_ipc);\n+\n+#undef NDS32_PUT_FS_REG\n+\n+  /* The retaddr is PC, use PC to find FDE.  */\n+  fs->retaddr_column = 32;\n+  fs->signal_frame = 1;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+#endif"}]}