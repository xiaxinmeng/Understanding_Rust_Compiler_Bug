{"sha": "009070260dd9ac941d30b119638a6f3839eb2e6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA5MDcwMjYwZGQ5YWM5NDFkMzBiMTE5NjM4YTZmMzgzOWViMmU2Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-08-12T09:01:33Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-12T09:01:33Z"}, "message": "[Ada] Fix internal error on comparison of unaligned slices\n\nThis fixes an internal error in the code generator when it is trying to\ntake the address of a slice which does not start on a byte boundary, in\norder to generate a comparison between slices with a dynamic length.\n\nThis case is not supported by the code generator and comes from an\nexplicit representation clause on a record type, so it must be detected\nand handled by the front-end by expanding the comparison on an\nelement-by-element basis.\n\n2019-08-12  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Op_Eq): Expand the array equality if\n\teither operand is a possibly unaligned slice.\n\t* exp_ch6.adb (Expand_Simple_Function_Return): Do not generate a\n\tcopy for a possibly unaligned object if it is represented as a\n\tscalar.\n\t* exp_util.adb (Is_Possibly_Unaligned_Slice): Do not always\n\treturn false if the target doesn't have strict alignment.\n\ngcc/testsuite/\n\n\t* gnat.dg/slice10.adb: New testcase.\n\nFrom-SVN: r274303", "tree": {"sha": "b23510c1664e59ed694e7ecd7a92ff0171fe8549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b23510c1664e59ed694e7ecd7a92ff0171fe8549"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/009070260dd9ac941d30b119638a6f3839eb2e6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009070260dd9ac941d30b119638a6f3839eb2e6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009070260dd9ac941d30b119638a6f3839eb2e6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009070260dd9ac941d30b119638a6f3839eb2e6b/comments", "author": null, "committer": null, "parents": [{"sha": "ad430786085ad3e5fee751414799d8ccae60fbc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad430786085ad3e5fee751414799d8ccae60fbc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad430786085ad3e5fee751414799d8ccae60fbc3"}], "stats": {"total": 68, "additions": 54, "deletions": 14}, "files": [{"sha": "fa543dfb803f0d555997a4bda73171ed20cddbb8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=009070260dd9ac941d30b119638a6f3839eb2e6b", "patch": "@@ -1,3 +1,13 @@\n+2019-08-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Eq): Expand the array equality if\n+\teither operand is a possibly unaligned slice.\n+\t* exp_ch6.adb (Expand_Simple_Function_Return): Do not generate a\n+\tcopy for a possibly unaligned object if it is represented as a\n+\tscalar.\n+\t* exp_util.adb (Is_Possibly_Unaligned_Slice): Do not always\n+\treturn false if the target doesn't have strict alignment.\n+\n 2019-08-12  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch12.adb (Instantiate_Package_Body): Remove suppression of"}, {"sha": "6f2fe32550743cef64c139513217a303136d7561", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=009070260dd9ac941d30b119638a6f3839eb2e6b", "patch": "@@ -8068,7 +8068,9 @@ package body Exp_Ch4 is\n            and then not Is_Floating_Point_Type (Component_Type (Typl))\n            and then not Is_Atomic_Or_VFA (Component_Type (Typl))\n            and then not Is_Possibly_Unaligned_Object (Lhs)\n+           and then not Is_Possibly_Unaligned_Slice (Lhs)\n            and then not Is_Possibly_Unaligned_Object (Rhs)\n+           and then not Is_Possibly_Unaligned_Slice (Rhs)\n            and then Support_Composite_Compare_On_Target\n          then\n             null;"}, {"sha": "4ba9d84804bcb5918b6519dec2c74b85931e0be5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=009070260dd9ac941d30b119638a6f3839eb2e6b", "patch": "@@ -203,8 +203,8 @@ package body Exp_Ch6 is\n    --  For all parameter modes, actuals that denote components and slices of\n    --  packed arrays are expanded into suitable temporaries.\n    --\n-   --  For non-scalar objects that are possibly unaligned, add call by copy\n-   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n+   --  For nonscalar objects that are possibly unaligned, add call by copy code\n+   --  (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n    --\n    --  For OUT and IN OUT parameters, add predicate checks after the call\n    --  based on the predicates of the actual type.\n@@ -2019,7 +2019,7 @@ package body Exp_Ch6 is\n             elsif Is_Ref_To_Bit_Packed_Array (Actual) then\n                Add_Simple_Call_By_Copy_Code;\n \n-            --  If a non-scalar actual is possibly bit-aligned, we need a copy\n+            --  If a nonscalar actual is possibly bit-aligned, we need a copy\n             --  because the back-end cannot cope with such objects. In other\n             --  cases where alignment forces a copy, the back-end generates\n             --  it properly. It should not be generated unconditionally in the\n@@ -2235,7 +2235,7 @@ package body Exp_Ch6 is\n             elsif Is_Ref_To_Bit_Packed_Array (Actual) then\n                Add_Simple_Call_By_Copy_Code;\n \n-            --  If a non-scalar actual is possibly unaligned, we need a copy\n+            --  If a nonscalar actual is possibly unaligned, we need a copy\n \n             elsif Is_Possibly_Unaligned_Object (Actual)\n               and then not Represented_As_Scalar (Etype (Formal))\n@@ -7413,12 +7413,13 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n-      --  If we are returning an object that may not be bit-aligned, then copy\n-      --  the value into a temporary first. This copy may need to expand to a\n-      --  loop of component operations.\n+      --  If we are returning a nonscalar object that is possibly unaligned,\n+      --  then copy the value into a temporary first. This copy may need to\n+      --  expand to a loop of component operations.\n \n       if Is_Possibly_Unaligned_Slice (Exp)\n-        or else Is_Possibly_Unaligned_Object (Exp)\n+        or else (Is_Possibly_Unaligned_Object (Exp)\n+                  and then not Represented_As_Scalar (Etype (Exp)))\n       then\n          declare\n             ExpR : constant Node_Id   := Relocate_Node (Exp);"}, {"sha": "2a3132b06054ad78671127bf547b8f2cdc7888ea", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=009070260dd9ac941d30b119638a6f3839eb2e6b", "patch": "@@ -8485,12 +8485,6 @@ package body Exp_Util is\n          return False;\n       end if;\n \n-      --  We only need to worry if the target has strict alignment\n-\n-      if not Target_Strict_Alignment then\n-         return False;\n-      end if;\n-\n       --  If it is a slice, then look at the array type being sliced\n \n       declare"}, {"sha": "ee65d1b47894c93fa6f429f66a4b5aadf1eb0873", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=009070260dd9ac941d30b119638a6f3839eb2e6b", "patch": "@@ -1,3 +1,7 @@\n+2019-08-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/slice10.adb: New testcase.\n+\n 2019-08-12  Gary Dismukes  <dismukes@adacore.com>\n \n \t* gnat.dg/generic_inst7.adb, gnat.dg/generic_inst7_pkg.adb,"}, {"sha": "4793258003d4c0ca2647336e72f72f9f84cef7df", "filename": "gcc/testsuite/gnat.dg/slice10.adb", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Ftestsuite%2Fgnat.dg%2Fslice10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009070260dd9ac941d30b119638a6f3839eb2e6b/gcc%2Ftestsuite%2Fgnat.dg%2Fslice10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fslice10.adb?ref=009070260dd9ac941d30b119638a6f3839eb2e6b", "patch": "@@ -0,0 +1,29 @@\n+--  { dg-do run }\n+\n+procedure Slice10 is\n+\n+   subtype Str is String (1 .. 3);\n+\n+   type T is record\n+      B : Boolean;\n+      S : Str;\n+   end record;\n+\n+   for T use record\n+      B at 0 range 0 .. 0;\n+      S at 0 range 1 .. 24;\n+   end record;\n+\n+   function Match (X, Y: T; Length : Positive) return Boolean is\n+   begin\n+      return X.S (1 .. Length) = Y.S (1 .. Length);\n+   end;\n+\n+   X, Y : T := (B => True, S => \"123\");\n+\n+begin\n+   X.B := False;\n+   if not match (X, Y, 3) then\n+      raise Program_Error;\n+   end if;\n+end;"}]}