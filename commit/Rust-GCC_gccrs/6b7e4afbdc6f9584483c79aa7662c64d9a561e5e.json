{"sha": "6b7e4afbdc6f9584483c79aa7662c64d9a561e5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI3ZTRhZmJkYzZmOTU4NDQ4M2M3OWFhNzY2MmM2NGQ5YTU2MWU1ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-02-28T16:45:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-02-28T16:45:44Z"}, "message": "re PR lto/88585 (ICE in fld_incomplete_type_of, at tree.c:5295)\n\n\tPR lto/88585\n\t* tree.c (find_atomic_core_type): Move ahead in file.\n\t(check_base_type): Correctly compare alignments of atomic types.\n\nFrom-SVN: r269282", "tree": {"sha": "cb5b05691925eecd10f8d84a90af355f2ece7889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb5b05691925eecd10f8d84a90af355f2ece7889"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e/comments", "author": null, "committer": null, "parents": [{"sha": "0c0c7049a0b1424d3f4b7a18bbe90190f99d704b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0c7049a0b1424d3f4b7a18bbe90190f99d704b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0c7049a0b1424d3f4b7a18bbe90190f99d704b"}], "stats": {"total": 100, "additions": 59, "deletions": 41}, "files": [{"sha": "6d91746c5d0c1c989f1453515a64295537f47098", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b7e4afbdc6f9584483c79aa7662c64d9a561e5e", "patch": "@@ -1,3 +1,9 @@\n+2019-02-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/88585\n+\t* tree.c (find_atomic_core_type): Move ahead in file.\n+\t(check_base_type): Correctly compare alignments of atomic types.\n+\n 2019-02-28  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/89455"}, {"sha": "6528057524c7ca09eeefd0aa94cb5551d6896984", "filename": "gcc/tree.c", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b7e4afbdc6f9584483c79aa7662c64d9a561e5e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6b7e4afbdc6f9584483c79aa7662c64d9a561e5e", "patch": "@@ -6329,51 +6329,11 @@ check_lang_type (const_tree cand, const_tree base)\n   return lang_hooks.types.type_hash_eq (cand, base);\n }\n \n-/* Returns true iff unqualified CAND and BASE are equivalent.  */\n-\n-bool\n-check_base_type (const_tree cand, const_tree base)\n-{\n-  return (TYPE_NAME (cand) == TYPE_NAME (base)\n-\t  /* Apparently this is needed for Objective-C.  */\n-\t  && TYPE_CONTEXT (cand) == TYPE_CONTEXT (base)\n-\t  /* Check alignment.  */\n-\t  && TYPE_ALIGN (cand) == TYPE_ALIGN (base)\n-\t  && attribute_list_equal (TYPE_ATTRIBUTES (cand),\n-\t\t\t\t   TYPE_ATTRIBUTES (base)));\n-}\n-\n-/* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */\n-\n-bool\n-check_qualified_type (const_tree cand, const_tree base, int type_quals)\n-{\n-  return (TYPE_QUALS (cand) == type_quals\n-\t  && check_base_type (cand, base)\n-\t  && check_lang_type (cand, base));\n-}\n-\n-/* Returns true iff CAND is equivalent to BASE with ALIGN.  */\n-\n-static bool\n-check_aligned_type (const_tree cand, const_tree base, unsigned int align)\n-{\n-  return (TYPE_QUALS (cand) == TYPE_QUALS (base)\n-\t  && TYPE_NAME (cand) == TYPE_NAME (base)\n-\t  /* Apparently this is needed for Objective-C.  */\n-\t  && TYPE_CONTEXT (cand) == TYPE_CONTEXT (base)\n-\t  /* Check alignment.  */\n-\t  && TYPE_ALIGN (cand) == align\n-\t  && attribute_list_equal (TYPE_ATTRIBUTES (cand),\n-\t\t\t\t   TYPE_ATTRIBUTES (base))\n-\t  && check_lang_type (cand, base));\n-}\n-\n /* This function checks to see if TYPE matches the size one of the built-in \n    atomic types, and returns that core atomic type.  */\n \n static tree\n-find_atomic_core_type (tree type)\n+find_atomic_core_type (const_tree type)\n {\n   tree base_atomic_type;\n \n@@ -6410,6 +6370,58 @@ find_atomic_core_type (tree type)\n   return base_atomic_type;\n }\n \n+/* Returns true iff unqualified CAND and BASE are equivalent.  */\n+\n+bool\n+check_base_type (const_tree cand, const_tree base)\n+{\n+  if (TYPE_NAME (cand) != TYPE_NAME (base)\n+      /* Apparently this is needed for Objective-C.  */\n+      || TYPE_CONTEXT (cand) != TYPE_CONTEXT (base)\n+      || !attribute_list_equal (TYPE_ATTRIBUTES (cand),\n+\t\t\t        TYPE_ATTRIBUTES (base)))\n+    return false;\n+  /* Check alignment.  */\n+  if (TYPE_ALIGN (cand) == TYPE_ALIGN (base))\n+    return true;\n+  /* Atomic types increase minimal alignment.  We must to do so as well\n+     or we get duplicated canonical types. See PR88686.  */\n+  if ((TYPE_QUALS (cand) & TYPE_QUAL_ATOMIC))\n+    {\n+      /* See if this object can map to a basic atomic type.  */\n+      tree atomic_type = find_atomic_core_type (cand);\n+      if (atomic_type && TYPE_ALIGN (atomic_type) == TYPE_ALIGN (cand))\n+       return true;\n+    }\n+  return false;\n+}\n+\n+/* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */\n+\n+bool\n+check_qualified_type (const_tree cand, const_tree base, int type_quals)\n+{\n+  return (TYPE_QUALS (cand) == type_quals\n+\t  && check_base_type (cand, base)\n+\t  && check_lang_type (cand, base));\n+}\n+\n+/* Returns true iff CAND is equivalent to BASE with ALIGN.  */\n+\n+static bool\n+check_aligned_type (const_tree cand, const_tree base, unsigned int align)\n+{\n+  return (TYPE_QUALS (cand) == TYPE_QUALS (base)\n+\t  && TYPE_NAME (cand) == TYPE_NAME (base)\n+\t  /* Apparently this is needed for Objective-C.  */\n+\t  && TYPE_CONTEXT (cand) == TYPE_CONTEXT (base)\n+\t  /* Check alignment.  */\n+\t  && TYPE_ALIGN (cand) == align\n+\t  && attribute_list_equal (TYPE_ATTRIBUTES (cand),\n+\t\t\t\t   TYPE_ATTRIBUTES (base))\n+\t  && check_lang_type (cand, base));\n+}\n+\n /* Return a version of the TYPE, qualified as indicated by the\n    TYPE_QUALS, if one exists.  If no qualified version exists yet,\n    return NULL_TREE.  */"}]}