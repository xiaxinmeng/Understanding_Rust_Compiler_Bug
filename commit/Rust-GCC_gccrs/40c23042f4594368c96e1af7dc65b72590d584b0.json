{"sha": "40c23042f4594368c96e1af7dc65b72590d584b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBjMjMwNDJmNDU5NDM2OGM5NmUxYWY3ZGM2NWI3MjU5MGQ1ODRiMA==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-02-08T21:02:53Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-08T21:02:53Z"}, "message": "ByteBuffer.java (shiftDown): New helper method.\n\n\n\t* java/nio/ByteBuffer.java (shiftDown):  New helper method.\n\t* java/nio/natDirectByteBufferImpl.cc (shiftDown):  New implementation.\n\t* java/nio/ByteBufferImpl.java (compact):  Use new shiftDown method.\n\t* sava/nio/ByteBufferHelper.java:  Remove redundant 'final' specifiers.\n\tPass ByteOrder parameter to most methods, since the underlying\n\tByteBuffer's order isn't always what we should use.\n\t* java/nio/ByteBufferImpl.java:  Pass byte-order various places.\n\t* java/nio/DirectByteBufferImpl.java:  Likewise.\n\tUse ByteBufferHelper methods.\n\t* java/nio/MappedByteBufferImpl.java:  Likewise.\n\t(compact):  Use shiftDown.\n\t* java/nio/CharViewBufferImpl.java (<init>):  Pass byte-order.\n\t(get, put):  Use ByteBufferHelper.\n\t(compact):  Use new shiftDown method.\n\t(duplicate(boolean)):  New helper method.\n\t(duplicate, asReadOnlyBuffer):  Use it.\n\t(order):  Return endian field.\n\t* java/nio/DoubleViewBufferImpl.java:  Likewise.\n\t* java/nio/FloatViewBufferImpl.java:  Likewise.\n\t* java/nio/IntViewBufferImpl.java:  Likewise.\n\t* java/nio/LongViewBufferImpl.java:  Likewise.\n\t* java/nio/ShortViewBufferImpl.java:  Likewise.\n\t* java/nio/CharViewBufferImpl.java (subsequence):  Redundant test.\n\t* java/nio/DirectByteBufferImpl.java (shiftDown):  New native method.\n\t(compact):  Re-implement using shiftDown.\n\nFrom-SVN: r77501", "tree": {"sha": "a1e145e7726c0c5b674ef91a6ecd841daaa826ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1e145e7726c0c5b674ef91a6ecd841daaa826ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40c23042f4594368c96e1af7dc65b72590d584b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c23042f4594368c96e1af7dc65b72590d584b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c23042f4594368c96e1af7dc65b72590d584b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c23042f4594368c96e1af7dc65b72590d584b0/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b46b8fb40cf29c5f724d87f6022c6c8242e50bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46b8fb40cf29c5f724d87f6022c6c8242e50bf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46b8fb40cf29c5f724d87f6022c6c8242e50bf2"}], "stats": {"total": 1037, "additions": 489, "deletions": 548}, "files": [{"sha": "f3038dac87b1497769f06a27a549795f26c7b1ee", "filename": "libjava/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,3 +1,31 @@\n+2004-02-08  Per Bothner  <per@bothner.com>\n+\n+\t* java/nio/ByteBuffer.java (shiftDown):  New helper method.\n+\t* java/nio/natDirectByteBufferImpl.cc (shiftDown):  New implementation.\n+\t* java/nio/ByteBufferImpl.java (compact):  Use new shiftDown method.\n+\t* sava/nio/ByteBufferHelper.java:  Remove redundant 'final' specifiers.\n+\tPass ByteOrder parameter to most methods, since the underlying\n+\tByteBuffer's order isn't always what we should use.\n+\t* java/nio/ByteBufferImpl.java:  Pass byte-order various places.\n+\t* java/nio/DirectByteBufferImpl.java:  Likewise.\n+\tUse ByteBufferHelper methods.\n+\t* java/nio/MappedByteBufferImpl.java:  Likewise.\n+\t(compact):  Use shiftDown.\n+\t* java/nio/CharViewBufferImpl.java (<init>):  Pass byte-order.\n+\t(get, put):  Use ByteBufferHelper.\n+\t(compact):  Use new shiftDown method.\n+\t(duplicate(boolean)):  New helper method.\n+\t(duplicate, asReadOnlyBuffer):  Use it.\n+\t(order):  Return endian field.\n+\t* java/nio/DoubleViewBufferImpl.java:  Likewise.\n+\t* java/nio/FloatViewBufferImpl.java:  Likewise.\n+\t* java/nio/IntViewBufferImpl.java:  Likewise.\n+\t* java/nio/LongViewBufferImpl.java:  Likewise.\n+\t* java/nio/ShortViewBufferImpl.java:  Likewise.\n+\t* java/nio/CharViewBufferImpl.java (subsequence):  Redundant test.\n+\t* java/nio/DirectByteBufferImpl.java (shiftDown):  New native method.\n+\t(compact):  Re-implement using shiftDown.\n+\n 2004-02-08  Andreas Jaeger  <aj@suse.de>\n \n \t* include/x86_64-signal.h: Fix typo."}, {"sha": "9ca20618c457b52023804a3c1388309da0f5d9da", "filename": "libjava/java/nio/ByteBuffer.java", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FByteBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FByteBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBuffer.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* ByteBuffer.java -- \n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -382,8 +382,14 @@ public final ByteBuffer order (ByteOrder endian)\n    */\n   public abstract ByteBuffer compact ();\n \n+  void shiftDown (int dst_offset, int src_offset, int count)\n+  {\n+    for (int i = 0; i < count; i++)\n+      put(dst_offset + i, get(src_offset + i));\n+  }\n+\n   /**\n-   * Tells wether or not this buffer is direct.\n+   * Tells whether or not this buffer is direct.\n    */\n   public abstract boolean isDirect ();\n "}, {"sha": "c3dcfbe4f2fa4163aa78c02335602538fbe69e6e", "filename": "libjava/java/nio/ByteBufferHelper.java", "status": "modified", "additions": 62, "deletions": 74, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FByteBufferHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FByteBufferHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBufferHelper.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* ByteBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,58 +42,58 @@\n  */\n final class ByteBufferHelper\n {\n-  private static final void checkRemainingForRead (ByteBuffer buffer, int bytes)\n+  private static void checkRemainingForRead (ByteBuffer buffer, int bytes)\n   {\n     if (buffer.remaining() < bytes)\n       throw new BufferUnderflowException();\n   }\n   \n-  private static final void checkRemainingForWrite (ByteBuffer buffer, int bytes)\n+  private static void checkRemainingForWrite (ByteBuffer buffer, int bytes)\n   {\n     if (buffer.remaining() < bytes)\n       throw new BufferOverflowException();\n   }\n \n-  private static final void checkAvailableForRead (ByteBuffer buffer,\n-                                                   int index, int bytes)\n+  private static void checkAvailableForRead (ByteBuffer buffer,\n+\t\t\t\t\t     int index, int bytes)\n   {\n     if (buffer.limit() < (index + bytes))\n       throw new BufferUnderflowException();\n   }\n   \n-  private static final void checkAvailableForWrite (ByteBuffer buffer,\n-                                                    int index, int bytes)\n+  private static void checkAvailableForWrite (ByteBuffer buffer,\n+\t\t\t\t\t      int index, int bytes)\n   {\n     if (buffer.limit() < (index + bytes))\n       throw new BufferOverflowException();\n   }\n   \n-  public static final char getChar (ByteBuffer buffer)\n+  public static char getChar (ByteBuffer buffer, ByteOrder order)\n   {\n-    return (char) getShort (buffer);\n+    return (char) getShort (buffer, order);\n   }\n   \n-  public static final ByteBuffer putChar (ByteBuffer buffer, char value)\n+  public static void putChar (ByteBuffer buffer, char value, ByteOrder order)\n   {\n-    return putShort (buffer, (short) value);\n+    putShort (buffer, (short) value, order);\n   }\n   \n-  public static final char getChar (ByteBuffer buffer, int index)\n+  public static char getChar (ByteBuffer buffer, int index, ByteOrder order)\n   {\n-    return (char) getShort (buffer, index);\n+    return (char) getShort (buffer, index, order);\n   }\n   \n-  public static final ByteBuffer putChar (ByteBuffer buffer, int index,\n-                                          char value)\n+  public static void putChar (ByteBuffer buffer, int index,\n+\t\t\t      char value, ByteOrder order)\n   {\n-    return putShort (buffer, index, (short) value);\n+    putShort (buffer, index, (short) value, order);\n   }\n \n-  public static final short getShort (ByteBuffer buffer)\n+  public static short getShort (ByteBuffer buffer, ByteOrder order)\n   {\n     checkRemainingForRead (buffer, 2);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         return (short) ((buffer.get() & 0xff)\n                         + (buffer.get() << 8));\n@@ -103,11 +103,11 @@ public static final short getShort (ByteBuffer buffer)\n                     + (buffer.get() & 0xff));\n   }\n   \n-  public static final ByteBuffer putShort (ByteBuffer buffer, short value)\n+  public static void putShort (ByteBuffer buffer, short value, ByteOrder order)\n   {\n     checkRemainingForWrite (buffer, 2);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         buffer.put ((byte) value);\n         buffer.put ((byte) (value >> 8));\n@@ -117,15 +117,14 @@ public static final ByteBuffer putShort (ByteBuffer buffer, short value)\n         buffer.put ((byte) (value >> 8));\n         buffer.put ((byte) value);\n       }\n-\n-    return buffer;\n   }\n   \n-  public static final short getShort (ByteBuffer buffer, int index)\n+  public static short getShort (ByteBuffer buffer,\n+\t\t\t\t      int index, ByteOrder order)\n   {\n     checkAvailableForRead (buffer, index, 2);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         return (short) ((buffer.get (index) & 0xff)\n                         + (buffer.get (++index) << 8));\n@@ -135,12 +134,12 @@ public static final short getShort (ByteBuffer buffer, int index)\n                     + (buffer.get (++index) & 0xff));\n   }\n   \n-  public static final ByteBuffer putShort (ByteBuffer buffer, int index,\n-                                           short value)\n+  public static void putShort (ByteBuffer buffer, int index,\n+\t\t\t       short value, ByteOrder order)\n   {\n     checkAvailableForWrite (buffer, index, 2);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         buffer.put (index, (byte) value);\n         buffer.put (++index, (byte) (value >> 8));\n@@ -150,15 +149,13 @@ public static final ByteBuffer putShort (ByteBuffer buffer, int index,\n         buffer.put (index, (byte) (value >> 8));\n         buffer.put (++index, (byte) value);\n       }\n-    \n-    return buffer;\n   }\n \n-  public static final int getInt (ByteBuffer buffer)\n+  public static int getInt (ByteBuffer buffer, ByteOrder order)\n   {\n     checkRemainingForRead (buffer, 4);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         return ((buffer.get() & 0xff)\n                 + ((buffer.get() & 0xff) << 8)\n@@ -172,11 +169,11 @@ public static final int getInt (ByteBuffer buffer)\n                   + (buffer.get() & 0xff));\n   }\n   \n-  public static final ByteBuffer putInt (ByteBuffer buffer, int value)\n+  public static void putInt (ByteBuffer buffer, int value, ByteOrder order)\n   {\n     checkRemainingForWrite (buffer, 4);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         buffer.put ((byte) value);\n         buffer.put ((byte) (value >> 8));\n@@ -190,15 +187,13 @@ public static final ByteBuffer putInt (ByteBuffer buffer, int value)\n         buffer.put ((byte) (value >> 8));\n         buffer.put ((byte) value);\n       }\n-    \n-    return buffer;\n   }\n   \n-  public static final int getInt (ByteBuffer buffer, int index)\n+  public static int getInt (ByteBuffer buffer, int index, ByteOrder order)\n   {\n     checkAvailableForRead (buffer, index, 4);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         return ((buffer.get (index) & 0xff)\n                 + ((buffer.get (++index) & 0xff) << 8)\n@@ -212,12 +207,12 @@ public static final int getInt (ByteBuffer buffer, int index)\n             + (buffer.get (++index) & 0xff));\n   }\n   \n-  public static final ByteBuffer putInt (ByteBuffer buffer, int index,\n-                                         int value)\n+  public static void putInt (ByteBuffer buffer, int index,\n+\t\t\t\t   int value, ByteOrder order)\n   {\n     checkAvailableForWrite (buffer, index, 4);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         buffer.put (index, (byte) value);\n         buffer.put (++index, (byte) (value >> 8));\n@@ -231,15 +226,13 @@ public static final ByteBuffer putInt (ByteBuffer buffer, int index,\n         buffer.put (++index, (byte) (value >> 8));\n         buffer.put (++index, (byte) value);\n       }\n-  \n-    return buffer;\n   }\n \n-  public static final long getLong (ByteBuffer buffer)\n+  public static long getLong (ByteBuffer buffer, ByteOrder order)\n   {\n     checkRemainingForRead (buffer, 8);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         return ((buffer.get() & 0xff)\n                 + (((buffer.get() & 0xff)) << 8)\n@@ -261,11 +254,11 @@ public static final long getLong (ByteBuffer buffer)\n             + (buffer.get() & 0xff));\n   }\n   \n-  public static final ByteBuffer putLong (ByteBuffer buffer, long value)\n+  public static void putLong (ByteBuffer buffer, long value, ByteOrder order)\n   {\n     checkRemainingForWrite (buffer, 8);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         buffer.put ((byte) value);\n         buffer.put ((byte) (value >> 8));\n@@ -287,15 +280,13 @@ public static final ByteBuffer putLong (ByteBuffer buffer, long value)\n         buffer.put ((byte) (value >> 8));\n         buffer.put ((byte) value);\n       }\n-    \n-    return buffer;\n   }\n   \n-  public static final long getLong (ByteBuffer buffer, int index)\n+  public static long getLong (ByteBuffer buffer, int index, ByteOrder order)\n   {\n     checkAvailableForRead (buffer, index, 8);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         return ((buffer.get (index) & 0xff)\n                 + ((buffer.get (++index) & 0xff) << 8)\n@@ -317,12 +308,12 @@ public static final long getLong (ByteBuffer buffer, int index)\n             + (buffer.get (++index) & 0xff));\n   }\n   \n-  public static final ByteBuffer putLong (ByteBuffer buffer, int index,\n-                                          long value)\n+  public static void putLong (ByteBuffer buffer, int index,\n+\t\t\t\t    long value, ByteOrder order)\n   {\n     checkAvailableForWrite (buffer, index, 8);\n \n-    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+    if (order == ByteOrder.LITTLE_ENDIAN)\n       {\n         buffer.put (index, (byte) value);\n         buffer.put (++index, (byte) (value >> 8));\n@@ -344,50 +335,47 @@ public static final ByteBuffer putLong (ByteBuffer buffer, int index,\n         buffer.put (++index, (byte) (value >> 8));\n         buffer.put (++index, (byte) value);\n       }\n-    \n-    return buffer;\n   }\n \n-  public static final float getFloat (ByteBuffer buffer)\n+  public static float getFloat (ByteBuffer buffer, ByteOrder order)\n   {\n-    return Float.intBitsToFloat (getInt (buffer));\n+    return Float.intBitsToFloat (getInt (buffer, order));\n   }\n   \n-  public static final ByteBuffer putFloat (ByteBuffer buffer, float value)\n+  public static void putFloat (ByteBuffer buffer, float value, ByteOrder order)\n   {\n-    return putInt (buffer, Float.floatToRawIntBits (value));\n+    putInt (buffer, Float.floatToRawIntBits (value), order);\n   }\n   \n-  public static final float getFloat (ByteBuffer buffer, int index)\n+  public static float getFloat (ByteBuffer buffer, int index, ByteOrder order)\n   {\n-    return Float.intBitsToFloat (getInt (buffer, index));\n+    return Float.intBitsToFloat (getInt (buffer, index, order));\n   }\n \n-  public static final ByteBuffer putFloat (ByteBuffer buffer, int index,\n-                                           float value)\n+  public static void putFloat (ByteBuffer buffer, int index,\n+\t\t\t\t     float value, ByteOrder order)\n   {\n-    return putInt (buffer, index, Float.floatToRawIntBits (value));\n+    putInt (buffer, index, Float.floatToRawIntBits (value), order);\n   }\n \n-  public static final double getDouble (ByteBuffer buffer)\n+  public static double getDouble (ByteBuffer buffer, ByteOrder order)\n   {\n-    return Double.longBitsToDouble (getLong (buffer));\n+    return Double.longBitsToDouble (getLong (buffer, order));\n   }\n \n-  public static final ByteBuffer putDouble (ByteBuffer buffer, double value)\n+  public static void putDouble (ByteBuffer buffer, double value, ByteOrder order)\n   {\n-    return putLong (buffer, Double.doubleToLongBits (value));\n+    putLong (buffer, Double.doubleToLongBits (value), order);\n   }\n   \n-  public static final double getDouble (ByteBuffer buffer, int index)\n+  public static double getDouble (ByteBuffer buffer, int index, ByteOrder order)\n   {\n-    return Double.longBitsToDouble (getLong (buffer, index));\n+    return Double.longBitsToDouble (getLong (buffer, index, order));\n   }\n   \n-  public static final ByteBuffer putDouble (ByteBuffer buffer, int index,\n-                                            double value)\n+  public static void putDouble (ByteBuffer buffer, int index,\n+\t\t\t\tdouble value, ByteOrder order)\n   {\n-    return putLong (buffer, index, Double.doubleToLongBits (value));\n+    putLong (buffer, index, Double.doubleToLongBits (value), order);\n   }\n-\n } // ByteBufferHelper"}, {"sha": "6a3814862c986fcf21994001343903b96e6feeff", "filename": "libjava/java/nio/ByteBufferImpl.java", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* ByteBufferImpl.java -- \n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -58,32 +58,32 @@ final class ByteBufferImpl extends ByteBuffer\n   \n   public CharBuffer asCharBuffer ()\n   {\n-    return new CharViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new CharViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public ShortBuffer asShortBuffer ()\n   {\n-    return new ShortViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new ShortViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public IntBuffer asIntBuffer ()\n   {\n-    return new IntViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new IntViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public LongBuffer asLongBuffer ()\n   {\n-    return new LongViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new LongViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public FloatBuffer asFloatBuffer ()\n   {\n-    return new FloatViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new FloatViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public DoubleBuffer asDoubleBuffer ()\n   {\n-    return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public boolean isReadOnly ()\n@@ -108,15 +108,14 @@ public ByteBuffer asReadOnlyBuffer ()\n   \n   public ByteBuffer compact ()\n   {\n-    int copied = 0;\n-    \n-    while (remaining () > 0)\n+    int pos = position();\n+    if (pos > 0)\n       {\n-\tput (copied, get ());\n-\tcopied++;\n+\tint count = remaining();\n+\tshiftDown(0, pos, count);\n+\tposition(count);\n+\tlimit(capacity());\n       }\n-\n-    position (copied);\n     return this;\n   }\n   \n@@ -182,121 +181,133 @@ final public ByteBuffer put (int index, byte value)\n   \n   final public char getChar ()\n   {\n-    return ByteBufferHelper.getChar (this);\n+    return ByteBufferHelper.getChar(this, order());\n   }\n   \n   final public ByteBuffer putChar (char value)\n   {\n-    return ByteBufferHelper.putChar (this, value);\n+    ByteBufferHelper.putChar(this, value, order());\n+    return this;\n   }\n   \n   final public char getChar (int index)\n   {\n-    return ByteBufferHelper.getChar (this, index);\n+    return ByteBufferHelper.getChar(this, index, order());\n   }\n   \n   final public ByteBuffer putChar (int index, char value)\n   {\n-    return ByteBufferHelper.putChar (this, index, value);\n+    ByteBufferHelper.putChar(this, index, value, order());\n+    return this;\n   }\n \n   final public short getShort ()\n   {\n-    return ByteBufferHelper.getShort (this);\n+    return ByteBufferHelper.getShort(this, order());\n   }\n   \n   final public ByteBuffer putShort (short value)\n   {\n-    return ByteBufferHelper.putShort (this, value);\n+    ByteBufferHelper.putShort(this, value, order());\n+    return this;\n   }\n   \n   final public short getShort (int index)\n   {\n-    return ByteBufferHelper.getShort (this, index);\n+    return ByteBufferHelper.getShort(this, index, order());\n   }\n   \n   final public ByteBuffer putShort (int index, short value)\n   {\n-    return ByteBufferHelper.putShort (this, index, value);\n+    ByteBufferHelper.putShort(this, index, value, order());\n+    return this;\n   }\n \n   final public int getInt ()\n   {\n-    return ByteBufferHelper.getInt (this);\n+    return ByteBufferHelper.getInt(this, order());\n   }\n   \n   final public ByteBuffer putInt (int value)\n   {\n-    return ByteBufferHelper.putInt (this, value);\n+    ByteBufferHelper.putInt(this, value, order());\n+    return this;\n   }\n   \n   final public int getInt (int index)\n   {\n-    return ByteBufferHelper.getInt (this, index);\n+    return ByteBufferHelper.getInt(this, index, order());\n   }\n   \n   final public ByteBuffer putInt (int index, int value)\n   {\n-    return ByteBufferHelper.putInt (this, index, value);\n+    ByteBufferHelper.putInt(this, index, value, order());\n+    return this;\n   }\n \n   final public long getLong ()\n   {\n-    return ByteBufferHelper.getLong (this);\n+    return ByteBufferHelper.getLong(this, order());\n   }\n   \n   final public ByteBuffer putLong (long value)\n   {\n-    return ByteBufferHelper.putLong (this, value);\n+    ByteBufferHelper.putLong (this, value, order());\n+    return this;\n   }\n   \n   final public long getLong (int index)\n   {\n-    return ByteBufferHelper.getLong (this, index);\n+    return ByteBufferHelper.getLong (this, index, order());\n   }\n   \n   final public ByteBuffer putLong (int index, long value)\n   {\n-    return ByteBufferHelper.putLong (this, index, value);\n+    ByteBufferHelper.putLong (this, index, value, order());\n+    return this;\n   }\n \n   final public float getFloat ()\n   {\n-    return ByteBufferHelper.getFloat (this);\n+    return ByteBufferHelper.getFloat (this, order());\n   }\n   \n   final public ByteBuffer putFloat (float value)\n   {\n-    return ByteBufferHelper.putFloat (this, value);\n+    ByteBufferHelper.putFloat (this, value, order());\n+    return this;\n   }\n   \n-  final public float getFloat (int index)\n+  public final float getFloat (int index)\n   {\n-    return ByteBufferHelper.getFloat (this, index);\n+    return ByteBufferHelper.getFloat (this, index, order());\n   }\n \n-  public final ByteBuffer putFloat (int index, float value)\n+  final public ByteBuffer putFloat (int index, float value)\n   {\n-    return ByteBufferHelper.putFloat (this, index, value);\n+    ByteBufferHelper.putFloat (this, index, value, order());\n+    return this;\n   }\n \n   final public double getDouble ()\n   {\n-    return ByteBufferHelper.getDouble (this);\n+    return ByteBufferHelper.getDouble (this, order());\n   }\n \n   final public ByteBuffer putDouble (double value)\n   {\n-    return ByteBufferHelper.putDouble (this, value);\n+    ByteBufferHelper.putDouble (this, value, order());\n+    return this;\n   }\n   \n   final public double getDouble (int index)\n   {\n-    return ByteBufferHelper.getDouble (this, index);\n+    return ByteBufferHelper.getDouble (this, index, order());\n   }\n   \n   final public ByteBuffer putDouble (int index, double value)\n   {\n-    return ByteBufferHelper.putDouble (this, index, value);\n+    ByteBufferHelper.putDouble (this, index, value, order());\n+    return this;\n   }\n }"}, {"sha": "b1cc9071724b5480122a60338fc2b2d59ac128ec", "filename": "libjava/java/nio/CharViewBufferImpl.java", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FCharViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FCharViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FCharViewBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* CharViewBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,114 +40,102 @@\n \n class CharViewBufferImpl extends CharBuffer\n {\n-  private boolean readOnly;\n+  /** Position in bb (i.e. a byte offset) where this buffer starts. */\n   private int offset;\n   private ByteBuffer bb;\n+  private boolean readOnly;\n   private ByteOrder endian;\n   \n-  public CharViewBufferImpl (ByteBuffer bb, boolean readOnly)\n-  {\n-    super (bb.remaining () >> 1, bb.remaining () >> 1, bb.position (), 0);\n-    this.bb = bb;\n-    this.readOnly = readOnly;\n-    // FIXME: What if this is called from CharByteBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n-  }\n-\n   public CharViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n-                               int limit, int position, int mark,\n-                               boolean readOnly)\n+\t\t\t     int limit, int position, int mark,\n+\t\t\t     boolean readOnly, ByteOrder endian)\n   {\n     super (limit >> 1, limit >> 1, position >> 1, mark >> 1);\n     this.bb = bb;\n     this.offset = offset;\n     this.readOnly = readOnly;\n-    // FIXME: What if this is called from CharViewBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n+    this.endian = endian;\n   }\n \n   public char get ()\n   {\n-    char result = bb.getChar ((position () << 1) + offset);\n-    position (position () + 1);\n+    int p = position();\n+    char result = ByteBufferHelper.getChar(bb, (p << 1) + offset, endian);\n+    position(p + 1);\n     return result;\n   }\n \n   public char get (int index)\n   {\n-    return bb.getChar ((index << 1) + offset);\n+    return ByteBufferHelper.getChar(bb, (index << 1) + offset, endian);\n   }\n \n   public CharBuffer put (char value)\n   {\n-    bb.putChar ((position () << 1) + offset, value);\n-    position (position () + 1);\n+    int p = position();\n+    ByteBufferHelper.putChar(bb, (p << 1) + offset, value, endian);\n+    position(p + 1);\n     return this;\n   }\n   \n   public CharBuffer put (int index, char value)\n   {\n-    bb.putChar ((index << 1) + offset, value);\n+    ByteBufferHelper.putChar(bb, (index << 1) + offset, value, endian);\n     return this;\n   }\n \n   public CharBuffer compact ()\n   {\n     if (position () > 0)\n       {\n-        // Copy all data from position() to limit() to the beginning of the\n-        // buffer, set position to end of data and limit to capacity\n-        // XXX: This can surely be optimized, for direct and non-direct buffers\n-        \n         int count = limit () - position ();\n-              \n-        for (int i = 0; i < count; i++)\n-          {\n-            bb.putChar ((i >> 1) + offset,\n-                          bb.getChar (((i + position ()) >> 1) + offset));\n-          }\n-\n+\tbb.shiftDown(offset, offset + 2 * position(), 2 * count);\n         position (count);\n         limit (capacity ());\n       }\n-\n     return this;\n   }\n   \n-  public CharBuffer duplicate ()\n-  {\n-    // Create a copy of this object that shares its content\n-    // FIXME: mark is not correct\n-    return new CharViewBufferImpl (bb, offset, capacity (), limit (),\n-                                     position (), -1, isReadOnly ());\n-  }\n-  \n   public CharBuffer slice ()\n   {\n     // Create a sliced copy of this object that shares its content.\n     return new CharViewBufferImpl (bb, (position () >> 1) + offset,\n-                                      remaining (), remaining (), 0, -1,\n-                                     isReadOnly ());\n+\t\t\t\t   remaining (), remaining (), 0, -1,\n+\t\t\t\t   isReadOnly (), endian);\n   }\n   \n+  CharBuffer duplicate (boolean readOnly)\n+  {\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    return new CharViewBufferImpl (bb, offset, capacity(), limit(),\n+                                     pos, mark, readOnly, endian);\n+  }\n+  \n+  public CharBuffer duplicate ()\n+  {\n+    return duplicate(readOnly);\n+  }\n+\n+  public CharBuffer asReadOnlyBuffer ()\n+  {\n+    return duplicate(true);\n+  }\n+\n   public CharSequence subSequence (int start, int end)\n   {\n     if (start < 0\n-        || start > length ()\n         || end < start\n         || end > length ())\n       throw new IndexOutOfBoundsException ();\n \n-    return new CharViewBufferImpl (bb, array_offset, capacity (), position () + end, position () + start, -1, isReadOnly ());\n+    return new CharViewBufferImpl (bb, array_offset, capacity (),\n+\t\t\t\t   position () + end, position () + start,\n+\t\t\t\t   -1, isReadOnly (), endian);\n   }\n \n-  public CharBuffer asReadOnlyBuffer ()\n-  {\n-    // Create a copy of this object that shares its content and is read-only\n-    return new CharViewBufferImpl (bb, (position () >> 1) + offset,\n-                                     remaining (), remaining (), 0, -1, true);\n-  }\n-  \n   public boolean isReadOnly ()\n   {\n     return readOnly;\n@@ -160,6 +148,6 @@ public boolean isDirect ()\n   \n   public ByteOrder order ()\n   {\n-    return ByteOrder.LITTLE_ENDIAN;\n+    return endian;\n   }\n }"}, {"sha": "37b96a7c02eb94c1bc61943aa0e64bdc0255ab3c", "filename": "libjava/java/nio/DirectByteBufferImpl.java", "status": "modified", "additions": 45, "deletions": 79, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* DirectByteBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -117,18 +117,18 @@ public ByteBuffer put (int index, byte value)\n     return this;\n   }\n   \n+  native void shiftDown (int dst_offset, int src_offset, int count);\n+\n   public ByteBuffer compact ()\n   {\n-    // FIXME this can sure be optimized using memcpy()  \n-    int copied = 0;\n-    \n-    while (remaining () > 0)\n+    int pos = position();\n+    if (pos > 0)\n       {\n-\tput (copied, get ());\n-\tcopied++;\n+\tint count = remaining();\n+\tshiftDown(0, pos, count);\n+\tposition(count);\n+\tlimit(capacity());\n       }\n-\n-    position (copied);\n     return this;\n   }\n \n@@ -161,197 +161,163 @@ public boolean isDirect ()\n \n   public CharBuffer asCharBuffer ()\n   {\n-    return new CharViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+    return new CharViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n   }\n   \n   public DoubleBuffer asDoubleBuffer ()\n   {\n-    return new DoubleViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+    return new DoubleViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n   }\n   \n   public FloatBuffer asFloatBuffer ()\n   {\n-    return new FloatViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+    return new FloatViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n   }\n   \n   public IntBuffer asIntBuffer ()\n   {\n-    return new IntViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+    return new IntViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n   }\n   \n   public LongBuffer asLongBuffer ()\n   {\n-    return new LongViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+    return new LongViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n   }\n   \n   public ShortBuffer asShortBuffer ()\n   {\n-    return new ShortViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+    return new ShortViewBufferImpl (this, position (), remaining (), remaining (), 0, -1, isReadOnly (), order());\n   }\n   \n   final public char getChar ()\n   {\n-    // FIXME: this handles little endian only\n-    return (char) (((get () & 0xff) << 8)\n-                   + (get () & 0xff));\n+    return ByteBufferHelper.getChar(this, order());\n   }\n   \n   final public ByteBuffer putChar (char value)\n   {\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((int) value) & 0xff00) >> 8));\n-    put ((byte) (((int) value) & 0x00ff));\n+    ByteBufferHelper.putChar(this, value, order());\n     return this;\n   }\n   \n   final public char getChar (int index)\n   {\n-    // FIXME: this handles little endian only\n-    return (char) (((get (index) & 0xff) << 8)\n-                   + (get (index + 1) & 0xff));\n+    return ByteBufferHelper.getChar(this, index, order());\n   }\n   \n   final public ByteBuffer putChar (int index, char value)\n   {\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n-    put (index + 1, (byte) (((int) value) & 0x00ff));\n+    ByteBufferHelper.putChar(this, index, value, order());\n     return this;\n   }\n \n   final public short getShort ()\n   {\n-    // FIXME: this handles little endian only\n-    return (short) (((get () & 0xff) << 8)\n-                    + (get () & 0xff));\n+    return ByteBufferHelper.getShort(this, order());\n   }\n   \n   final public ByteBuffer putShort (short value)\n   {\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((int) value) & 0xff00) >> 8));\n-    put ((byte) (((int) value) & 0x00ff));\n+    ByteBufferHelper.putShort(this, value, order());\n     return this;\n   }\n   \n   final public short getShort (int index)\n   {\n-    // FIXME: this handles little endian only\n-    return (short) (((get (index) & 0xff) << 8)\n-                    + (get (index + 1) & 0xff));\n+    return ByteBufferHelper.getShort(this, index, order());\n   }\n   \n   final public ByteBuffer putShort (int index, short value)\n   {\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n-    put (index + 1, (byte) (((int) value) & 0x00ff));\n+    ByteBufferHelper.putShort(this, index, value, order());\n     return this;\n   }\n \n   final public int getInt ()\n   {\n-    // FIXME: this handles little endian only\n-    return (int) (((get () & 0xff) << 24)\n-                  + ((get () & 0xff) << 16)\n-                  + ((get () & 0xff) << 8)\n-                  + (get () & 0xff));\n+    return ByteBufferHelper.getInt(this, order());\n   }\n   \n   final public ByteBuffer putInt (int value)\n   {\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((int) value) & 0xff000000) >> 24));\n-    put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n-    put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n-    put ((byte) (((int) value) & 0x000000ff));\n+    ByteBufferHelper.putInt(this, value, order());\n     return this;\n   }\n   \n   final public int getInt (int index)\n   {\n-    // FIXME: this handles little endian only\n-    return (int) (((get (index) & 0xff) << 24)\n-                  + ((get (index + 1) & 0xff) << 16)\n-                  + ((get (index + 2) & 0xff) << 8)\n-                  + (get (index + 3) & 0xff));\n+    return ByteBufferHelper.getInt(this, index, order());\n   }\n   \n   final public ByteBuffer putInt (int index, int value)\n   {\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n-    put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n-    put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n-    put (index + 3, (byte) (((int) value) & 0x000000ff));\n+    ByteBufferHelper.putInt(this, index, value, order());\n     return this;\n   }\n \n   final public long getLong ()\n   {\n-    // FIXME: this handles little endian only\n-    return (long) (((get () & 0xff) << 56)\n-                   + ((get () & 0xff) << 48)\n-                   + ((get () & 0xff) << 40)\n-                   + ((get () & 0xff) << 32)\n-                   + ((get () & 0xff) << 24)\n-                   + ((get () & 0xff) << 16)\n-                   + ((get () & 0xff) << 8)\n-                   + (get () & 0xff));\n+    return ByteBufferHelper.getLong(this, order());\n   }\n   \n   final public ByteBuffer putLong (long value)\n   {\n-    return ByteBufferHelper.putLong (this, value);\n+    ByteBufferHelper.putLong (this, value, order());\n+    return this;\n   }\n   \n   final public long getLong (int index)\n   {\n-    return ByteBufferHelper.getLong (this, index);\n+    return ByteBufferHelper.getLong (this, index, order());\n   }\n   \n   final public ByteBuffer putLong (int index, long value)\n   {\n-    return ByteBufferHelper.putLong (this, index, value);\n+    ByteBufferHelper.putLong (this, index, value, order());\n+    return this;\n   }\n \n   final public float getFloat ()\n   {\n-    return ByteBufferHelper.getFloat (this);\n+    return ByteBufferHelper.getFloat (this, order());\n   }\n   \n   final public ByteBuffer putFloat (float value)\n   {\n-    return ByteBufferHelper.putFloat (this, value);\n+    ByteBufferHelper.putFloat (this, value, order());\n+    return this;\n   }\n   \n   public final float getFloat (int index)\n   {\n-    return ByteBufferHelper.getFloat (this, index);\n+    return ByteBufferHelper.getFloat (this, index, order());\n   }\n \n   final public ByteBuffer putFloat (int index, float value)\n   {\n-    return ByteBufferHelper.putFloat (this, index, value);\n+    ByteBufferHelper.putFloat (this, index, value, order());\n+    return this;\n   }\n \n   final public double getDouble ()\n   {\n-    return ByteBufferHelper.getDouble (this);\n+    return ByteBufferHelper.getDouble (this, order());\n   }\n \n   final public ByteBuffer putDouble (double value)\n   {\n-    return ByteBufferHelper.putDouble (this, value);\n+    ByteBufferHelper.putDouble (this, value, order());\n+    return this;\n   }\n   \n   final public double getDouble (int index)\n   {\n-    return ByteBufferHelper.getDouble (this, index);\n+    return ByteBufferHelper.getDouble (this, index, order());\n   }\n   \n   final public ByteBuffer putDouble (int index, double value)\n   {\n-    return ByteBufferHelper.putDouble (this, index, value);\n+    ByteBufferHelper.putDouble (this, index, value, order());\n+    return this;\n   }\n }"}, {"sha": "ac27746ba0d366b47241a200e88a029b8ca942eb", "filename": "libjava/java/nio/DoubleViewBufferImpl.java", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FDoubleViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FDoubleViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FDoubleViewBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* DoubleViewBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,103 +40,89 @@\n \n class DoubleViewBufferImpl extends DoubleBuffer\n {\n-  private boolean readOnly;\n+  /** Position in bb (i.e. a byte offset) where this buffer starts. */\n   private int offset;\n   private ByteBuffer bb;\n+  private boolean readOnly;\n   private ByteOrder endian;\n   \n-  public DoubleViewBufferImpl (ByteBuffer bb, boolean readOnly)\n-  {\n-    super (bb.remaining () >> 3, bb.remaining () >> 3, bb.position (), 0);\n-    this.bb = bb;\n-    this.readOnly = readOnly;\n-    // FIXME: What if this is called from DoubleByteBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n-  }\n-\n   public DoubleViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n                                int limit, int position, int mark,\n-                               boolean readOnly)\n+                               boolean readOnly, ByteOrder endian)\n   {\n     super (limit >> 3, limit >> 3, position >> 3, mark >> 3);\n     this.bb = bb;\n     this.offset = offset;\n     this.readOnly = readOnly;\n-    // FIXME: What if this is called from DoubleViewBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n+    this.endian = endian;\n   }\n \n   public double get ()\n   {\n-    double result = bb.getDouble ((position () << 3) + offset);\n-    position (position () + 1);\n+    int p = position();\n+    double result = ByteBufferHelper.getDouble(bb, (p << 3) + offset, endian);\n+    position(p + 1);\n     return result;\n   }\n \n   public double get (int index)\n   {\n-    return bb.getDouble ((index << 3) + offset);\n+    return ByteBufferHelper.getDouble(bb, (index << 3) + offset, endian);\n   }\n \n   public DoubleBuffer put (double value)\n   {\n-    bb.putDouble ((position () << 3) + offset, value);\n-    position (position () + 1);\n+    int p = position();\n+    ByteBufferHelper.putDouble(bb, (p << 3) + offset, value, endian);\n+    position(p + 1);\n     return this;\n   }\n   \n   public DoubleBuffer put (int index, double value)\n   {\n-    bb.putDouble ((index << 3) + offset, value);\n+    ByteBufferHelper.putDouble(bb, (index << 3) + offset, value, endian);\n     return this;\n   }\n \n   public DoubleBuffer compact ()\n   {\n     if (position () > 0)\n       {\n-        // Copy all data from position() to limit() to the beginning of the\n-        // buffer, set position to end of data and limit to capacity\n-        // XXX: This can surely be optimized, for direct and non-direct buffers\n-        \n         int count = limit () - position ();\n-              \n-        for (int i = 0; i < count; i++)\n-          {\n-            bb.putDouble ((i >> 3) + offset,\n-                          bb.getDouble (((i + position ()) >> 3) + offset));\n-          }\n-\n+\tbb.shiftDown(offset, offset + 8 * position(), 8 * count);\n         position (count);\n         limit (capacity ());\n       }\n-\n     return this;\n   }\n   \n-  public DoubleBuffer duplicate ()\n+  public DoubleBuffer slice ()\n   {\n-    // Create a copy of this object that shares its content\n-    // FIXME: mark is not correct\n-    return new DoubleViewBufferImpl (bb, offset, capacity (), limit (),\n-                                     position (), -1, isReadOnly ());\n+    return new DoubleViewBufferImpl (bb, (position () >> 3) + offset,\n+\t\t\t\t     remaining(), remaining(), 0, -1,\n+                                     readOnly, endian);\n   }\n   \n-  public DoubleBuffer slice ()\n+  DoubleBuffer duplicate (boolean readOnly)\n   {\n-    // Create a sliced copy of this object that shares its content.\n-    return new DoubleViewBufferImpl (bb, (position () >> 3) + offset,\n-                                      remaining (), remaining (), 0, -1,\n-                                     isReadOnly ());\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    return new DoubleViewBufferImpl (bb, offset, capacity(), limit(),\n+                                     pos, mark, readOnly, endian);\n   }\n   \n+  public DoubleBuffer duplicate ()\n+  {\n+    return duplicate(readOnly);\n+  }\n+\n   public DoubleBuffer asReadOnlyBuffer ()\n   {\n-    // Create a copy of this object that shares its content and is read-only\n-    return new DoubleViewBufferImpl (bb, (position () >> 3) + offset,\n-                                     remaining (), remaining (), 0, -1, true);\n+    return duplicate(true);\n   }\n-  \n+\n   public boolean isReadOnly ()\n   {\n     return readOnly;\n@@ -149,6 +135,6 @@ public boolean isDirect ()\n   \n   public ByteOrder order ()\n   {\n-    return ByteOrder.LITTLE_ENDIAN;\n+    return endian;\n   }\n }"}, {"sha": "88bc92553ab6f02ed4a762b74403ec8072afd862", "filename": "libjava/java/nio/FloatViewBufferImpl.java", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FFloatViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FFloatViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FFloatViewBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* FloatViewBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,103 +40,90 @@\n \n class FloatViewBufferImpl extends FloatBuffer\n {\n-  private boolean readOnly;\n+  /** Position in bb (i.e. a byte offset) where this buffer starts. */\n   private int offset;\n   private ByteBuffer bb;\n+  private boolean readOnly;\n   private ByteOrder endian;\n   \n-  public FloatViewBufferImpl (ByteBuffer bb, boolean readOnly)\n-  {\n-    super (bb.remaining () >> 2, bb.remaining () >> 2, bb.position (), 0);\n-    this.bb = bb;\n-    this.readOnly = readOnly;\n-    // FIXME: What if this is called from FloatByteBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n-  }\n-\n   public FloatViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n-                               int limit, int position, int mark,\n-                               boolean readOnly)\n+\t\t\t      int limit, int position, int mark,\n+\t\t\t      boolean readOnly, ByteOrder endian)\n   {\n     super (limit >> 2, limit >> 2, position >> 2, mark >> 2);\n     this.bb = bb;\n     this.offset = offset;\n     this.readOnly = readOnly;\n-    // FIXME: What if this is called from FloatViewBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n+    this.endian = endian;\n   }\n \n   public float get ()\n   {\n-    float result = bb.getFloat ((position () << 2) + offset);\n-    position (position () + 1);\n+    int p = position();\n+    float result = ByteBufferHelper.getFloat(bb, (p << 2) + offset, endian);\n+    position(p + 1);\n     return result;\n   }\n \n   public float get (int index)\n   {\n-    return bb.getFloat ((index << 2) + offset);\n+    return ByteBufferHelper.getFloat(bb, (index << 2) + offset, endian);\n   }\n \n   public FloatBuffer put (float value)\n   {\n-    bb.putFloat ((position () << 2) + offset, value);\n-    position (position () + 1);\n+    int p = position();\n+    ByteBufferHelper.putFloat(bb, (p << 2) + offset, value, endian);\n+    position(p + 1);\n     return this;\n   }\n   \n   public FloatBuffer put (int index, float value)\n   {\n-    bb.putFloat ((index << 2) + offset, value);\n+    ByteBufferHelper.putFloat(bb, (index << 2) + offset, value, endian);\n     return this;\n   }\n \n   public FloatBuffer compact ()\n   {\n     if (position () > 0)\n       {\n-        // Copy all data from position() to limit() to the beginning of the\n-        // buffer, set position to end of data and limit to capacity\n-        // XXX: This can surely be optimized, for direct and non-direct buffers\n-        \n         int count = limit () - position ();\n-              \n-        for (int i = 0; i < count; i++)\n-          {\n-            bb.putFloat ((i >> 2) + offset,\n-                          bb.getFloat (((i + position ()) >> 2) + offset));\n-          }\n-\n+\tbb.shiftDown(offset, offset + 4 * position(), 4 * count);\n         position (count);\n         limit (capacity ());\n       }\n-\n     return this;\n   }\n   \n-  public FloatBuffer duplicate ()\n-  {\n-    // Create a copy of this object that shares its content\n-    // FIXME: mark is not correct\n-    return new FloatViewBufferImpl (bb, offset, capacity (), limit (),\n-                                     position (), -1, isReadOnly ());\n-  }\n-  \n   public FloatBuffer slice ()\n   {\n     // Create a sliced copy of this object that shares its content.\n     return new FloatViewBufferImpl (bb, (position () >> 2) + offset,\n-                                      remaining (), remaining (), 0, -1,\n-                                     isReadOnly ());\n+\t\t\t\t    remaining(), remaining(), 0, -1,\n+\t\t\t\t    readOnly, endian);\n   }\n   \n-  public FloatBuffer asReadOnlyBuffer ()\n+  FloatBuffer duplicate (boolean readOnly)\n   {\n-    // Create a copy of this object that shares its content and is read-only\n-    return new FloatViewBufferImpl (bb, (position () >> 2) + offset,\n-                                     remaining (), remaining (), 0, -1, true);\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    return new FloatViewBufferImpl (bb, offset, capacity(), limit(),\n+\t\t\t\t    pos, mark, readOnly, endian);\n   }\n   \n+  public FloatBuffer duplicate ()\n+  {\n+    return duplicate(readOnly);\n+  }\n+\n+  public FloatBuffer asReadOnlyBuffer ()\n+  {\n+    return duplicate(true);\n+  }\n+\n   public boolean isReadOnly ()\n   {\n     return readOnly;\n@@ -149,6 +136,6 @@ public boolean isDirect ()\n   \n   public ByteOrder order ()\n   {\n-    return ByteOrder.LITTLE_ENDIAN;\n+    return endian;\n   }\n }"}, {"sha": "8e384c9017d0641ea8e6683352bb12f8f1de43f6", "filename": "libjava/java/nio/IntViewBufferImpl.java", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FIntViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FIntViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FIntViewBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* IntViewBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,103 +40,90 @@\n \n class IntViewBufferImpl extends IntBuffer\n {\n-  private boolean readOnly;\n+  /** Position in bb (i.e. a byte offset) where this buffer starts. */\n   private int offset;\n   private ByteBuffer bb;\n+  private boolean readOnly;\n   private ByteOrder endian;\n   \n-  public IntViewBufferImpl (ByteBuffer bb, boolean readOnly)\n-  {\n-    super (bb.remaining () >> 2, bb.remaining () >> 2, bb.position (), 0);\n-    this.bb = bb;\n-    this.readOnly = readOnly;\n-    // FIXME: What if this is called from IntByteBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n-  }\n-\n   public IntViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n-                               int limit, int position, int mark,\n-                               boolean readOnly)\n+\t\t\t    int limit, int position, int mark,\n+\t\t\t    boolean readOnly, ByteOrder endian)\n   {\n     super (limit >> 2, limit >> 2, position >> 2, mark >> 2);\n     this.bb = bb;\n     this.offset = offset;\n     this.readOnly = readOnly;\n-    // FIXME: What if this is called from IntViewBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n+    this.endian = endian;\n   }\n \n   public int get ()\n   {\n-    int result = bb.getInt ((position () << 2) + offset);\n-    position (position () + 1);\n+    int p = position();\n+    int result = ByteBufferHelper.getInt(bb, (p << 2) + offset, endian);\n+    position(p + 1);\n     return result;\n   }\n \n   public int get (int index)\n   {\n-    return bb.getInt ((index << 2) + offset);\n+    return ByteBufferHelper.getInt(bb, (index << 2) + offset, endian);\n   }\n \n   public IntBuffer put (int value)\n   {\n-    bb.putInt ((position () << 2) + offset, value);\n-    position (position () + 1);\n+    int p = position();\n+    ByteBufferHelper.putInt(bb, (p << 2) + offset, value, endian);\n+    position(p + 1);\n     return this;\n   }\n   \n   public IntBuffer put (int index, int value)\n   {\n-    bb.putInt ((index << 2) + offset, value);\n+    ByteBufferHelper.putInt(bb, (index << 2) + offset, value, endian);\n     return this;\n   }\n \n   public IntBuffer compact ()\n   {\n     if (position () > 0)\n       {\n-        // Copy all data from position() to limit() to the beginning of the\n-        // buffer, set position to end of data and limit to capacity\n-        // XXX: This can surely be optimized, for direct and non-direct buffers\n-        \n         int count = limit () - position ();\n-              \n-        for (int i = 0; i < count; i++)\n-          {\n-            bb.putInt ((i >> 2) + offset,\n-                          bb.getInt (((i + position ()) >> 2) + offset));\n-          }\n-\n+\tbb.shiftDown(offset, offset + 4 * position(), 4 * count);\n         position (count);\n         limit (capacity ());\n       }\n-\n     return this;\n   }\n   \n-  public IntBuffer duplicate ()\n-  {\n-    // Create a copy of this object that shares its content\n-    // FIXME: mark is not correct\n-    return new IntViewBufferImpl (bb, offset, capacity (), limit (),\n-                                     position (), -1, isReadOnly ());\n-  }\n-  \n   public IntBuffer slice ()\n   {\n     // Create a sliced copy of this object that shares its content.\n     return new IntViewBufferImpl (bb, (position () >> 2) + offset,\n-                                      remaining (), remaining (), 0, -1,\n-                                     isReadOnly ());\n+\t\t\t\t  remaining(), remaining(), 0, -1,\n+\t\t\t\t  readOnly, endian);\n   }\n   \n-  public IntBuffer asReadOnlyBuffer ()\n+  IntBuffer duplicate (boolean readOnly)\n   {\n-    // Create a copy of this object that shares its content and is read-only\n-    return new IntViewBufferImpl (bb, (position () >> 2) + offset,\n-                                     remaining (), remaining (), 0, -1, true);\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    return new IntViewBufferImpl (bb, offset, capacity(), limit(),\n+\t\t\t\t  pos, mark, readOnly, endian);\n   }\n   \n+  public IntBuffer duplicate ()\n+  {\n+    return duplicate(readOnly);\n+  }\n+\n+  public IntBuffer asReadOnlyBuffer ()\n+  {\n+    return duplicate(true);\n+  }\n+\n   public boolean isReadOnly ()\n   {\n     return readOnly;\n@@ -149,6 +136,6 @@ public boolean isDirect ()\n   \n   public ByteOrder order ()\n   {\n-    return ByteOrder.LITTLE_ENDIAN;\n+    return endian;\n   }\n }"}, {"sha": "a405ec871a52d843cdab30e0ab4cbada9f64d8c1", "filename": "libjava/java/nio/LongViewBufferImpl.java", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FLongViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FLongViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FLongViewBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* LongViewBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,103 +40,90 @@\n \n class LongViewBufferImpl extends LongBuffer\n {\n-  private boolean readOnly;\n+  /** Position in bb (i.e. a byte offset) where this buffer starts. */\n   private int offset;\n   private ByteBuffer bb;\n+  private boolean readOnly;\n   private ByteOrder endian;\n   \n-  public LongViewBufferImpl (ByteBuffer bb, boolean readOnly)\n-  {\n-    super (bb.remaining () >> 3, bb.remaining () >> 3, bb.position (), 0);\n-    this.bb = bb;\n-    this.readOnly = readOnly;\n-    // FIXME: What if this is called from LongByteBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n-  }\n-\n   public LongViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n-                               int limit, int position, int mark,\n-                               boolean readOnly)\n+\t\t\t     int limit, int position, int mark,\n+\t\t\t     boolean readOnly, ByteOrder endian)\n   {\n     super (limit >> 3, limit >> 3, position >> 3, mark >> 3);\n     this.bb = bb;\n     this.offset = offset;\n     this.readOnly = readOnly;\n-    // FIXME: What if this is called from LongViewBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n+    this.endian = endian;\n   }\n \n   public long get ()\n   {\n-    long result = bb.getLong ((position () << 3) + offset);\n-    position (position () + 1);\n+    int p = position();\n+    long result = ByteBufferHelper.getLong(bb, (p << 3) + offset, endian);\n+    position(p + 1);\n     return result;\n   }\n \n   public long get (int index)\n   {\n-    return bb.getLong ((index << 3) + offset);\n+    return ByteBufferHelper.getLong(bb, (index << 3) + offset, endian);\n   }\n \n   public LongBuffer put (long value)\n   {\n-    bb.putLong ((position () << 3) + offset, value);\n-    position (position () + 1);\n+    int p = position();\n+    ByteBufferHelper.putLong(bb, (p << 3) + offset, value, endian);\n+    position(p + 1);\n     return this;\n   }\n   \n   public LongBuffer put (int index, long value)\n   {\n-    bb.putLong ((index << 3) + offset, value);\n+    ByteBufferHelper.putLong(bb, (index << 3) + offset, value, endian);\n     return this;\n   }\n \n   public LongBuffer compact ()\n   {\n     if (position () > 0)\n       {\n-        // Copy all data from position() to limit() to the beginning of the\n-        // buffer, set position to end of data and limit to capacity\n-        // XXX: This can surely be optimized, for direct and non-direct buffers\n-        \n         int count = limit () - position ();\n-              \n-        for (int i = 0; i < count; i++)\n-          {\n-            bb.putLong ((i >> 3) + offset,\n-                          bb.getLong (((i + position ()) >> 3) + offset));\n-          }\n-\n+\tbb.shiftDown(offset, offset + 8 * position(), 8 * count);\n         position (count);\n         limit (capacity ());\n       }\n-\n     return this;\n   }\n   \n-  public LongBuffer duplicate ()\n-  {\n-    // Create a copy of this object that shares its content\n-    // FIXME: mark is not correct\n-    return new LongViewBufferImpl (bb, offset, capacity (), limit (),\n-                                     position (), -1, isReadOnly ());\n-  }\n-  \n   public LongBuffer slice ()\n   {\n     // Create a sliced copy of this object that shares its content.\n     return new LongViewBufferImpl (bb, (position () >> 3) + offset,\n-                                      remaining (), remaining (), 0, -1,\n-                                     isReadOnly ());\n+\t\t\t\t   remaining(), remaining(), 0, -1,\n+\t\t\t\t   readOnly, endian);\n   }\n   \n-  public LongBuffer asReadOnlyBuffer ()\n+  LongBuffer duplicate (boolean readOnly)\n   {\n-    // Create a copy of this object that shares its content and is read-only\n-    return new LongViewBufferImpl (bb, (position () >> 3) + offset,\n-                                     remaining (), remaining (), 0, -1, true);\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    return new LongViewBufferImpl (bb, offset, capacity(), limit(),\n+\t\t\t\t   pos, mark, readOnly, endian);\n   }\n   \n+  public LongBuffer duplicate ()\n+  {\n+    return duplicate(readOnly);\n+  }\n+\n+  public LongBuffer asReadOnlyBuffer ()\n+  {\n+    return duplicate(true);\n+  }\n+\n   public boolean isReadOnly ()\n   {\n     return readOnly;\n@@ -149,6 +136,6 @@ public boolean isDirect ()\n   \n   public ByteOrder order ()\n   {\n-    return ByteOrder.LITTLE_ENDIAN;\n+    return endian;\n   }\n }"}, {"sha": "f1d892f146fa8ce79db94347d529e06d451ced41", "filename": "libjava/java/nio/MappedByteBufferImpl.java", "status": "modified", "additions": 72, "deletions": 61, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* MappedByteBufferImpl.java -- \n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -111,15 +111,14 @@ public ByteBuffer put (int index, byte value)\n \n   public ByteBuffer compact ()\n   {\n-    int copied = 0;\n-    \n-    while (remaining () > 0)\n+    int pos = position();\n+    if (pos > 0)\n       {\n-\tput (copied, get ());\n-\tcopied++;\n+\tint count = remaining();\n+\tshiftDown(0, pos, count);\n+\tposition(count);\n+\tlimit(capacity());\n       }\n-\n-    position (copied);\n     return this;\n   }\n \n@@ -145,151 +144,163 @@ public ByteBuffer asReadOnlyBuffer ()\n \n   public CharBuffer asCharBuffer ()\n   {\n-    return new CharViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new CharViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public ShortBuffer asShortBuffer ()\n   {\n-    return new ShortViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new ShortViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public IntBuffer asIntBuffer ()\n   {\n-    return new IntViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new IntViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n   \n   public LongBuffer asLongBuffer ()\n   {\n-    return new LongViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new LongViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public FloatBuffer asFloatBuffer ()\n   {\n-    return new FloatViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new FloatViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n   public DoubleBuffer asDoubleBuffer ()\n   {\n-    return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n+    return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly (), order());\n   }\n \n-  public final char getChar()\n+  final public char getChar ()\n   {\n-    return ByteBufferHelper.getChar (this);\n+    return ByteBufferHelper.getChar(this, order());\n   }\n   \n-  public final ByteBuffer putChar (char value)\n+  final public ByteBuffer putChar (char value)\n   {\n-    return ByteBufferHelper.putChar (this, value);\n+    ByteBufferHelper.putChar(this, value, order());\n+    return this;\n   }\n   \n-  public final char getChar (int index)\n+  final public char getChar (int index)\n   {\n-    return ByteBufferHelper.getChar (this, index);\n+    return ByteBufferHelper.getChar(this, index, order());\n   }\n   \n-  public final ByteBuffer putChar (int index, char value)\n+  final public ByteBuffer putChar (int index, char value)\n   {\n-    return ByteBufferHelper.putChar (this, index, value);\n+    ByteBufferHelper.putChar(this, index, value, order());\n+    return this;\n   }\n \n-  public final short getShort()\n+  final public short getShort ()\n   {\n-    return ByteBufferHelper.getShort (this);\n+    return ByteBufferHelper.getShort(this, order());\n   }\n   \n-  public final ByteBuffer putShort (short value)\n+  final public ByteBuffer putShort (short value)\n   {\n-    return ByteBufferHelper.putShort (this, value);\n+    ByteBufferHelper.putShort(this, value, order());\n+    return this;\n   }\n   \n-  public final short getShort (int index)\n+  final public short getShort (int index)\n   {\n-    return ByteBufferHelper.getShort (this, index);\n+    return ByteBufferHelper.getShort(this, index, order());\n   }\n   \n-  public final ByteBuffer putShort (int index, short value)\n+  final public ByteBuffer putShort (int index, short value)\n   {\n-    return ByteBufferHelper.putShort (this, index, value);\n+    ByteBufferHelper.putShort(this, index, value, order());\n+    return this;\n   }\n \n-  public final int getInt()\n+  final public int getInt ()\n   {\n-    return ByteBufferHelper.getInt (this);\n+    return ByteBufferHelper.getInt(this, order());\n   }\n   \n-  public final ByteBuffer putInt (int value)\n+  final public ByteBuffer putInt (int value)\n   {\n-    return ByteBufferHelper.putInt (this, value);\n+    ByteBufferHelper.putInt(this, value, order());\n+    return this;\n   }\n   \n-  public final int getInt (int index)\n+  final public int getInt (int index)\n   {\n-    return ByteBufferHelper.getInt (this, index);\n+    return ByteBufferHelper.getInt(this, index, order());\n   }\n   \n-  public final ByteBuffer putInt (int index, int value)\n+  final public ByteBuffer putInt (int index, int value)\n   {\n-    return ByteBufferHelper.putInt (this, index, value);\n+    ByteBufferHelper.putInt(this, index, value, order());\n+    return this;\n   }\n \n-  public final long getLong()\n+  final public long getLong ()\n   {\n-    return ByteBufferHelper.getLong (this);\n+    return ByteBufferHelper.getLong(this, order());\n   }\n   \n-  public final ByteBuffer putLong (long value)\n+  final public ByteBuffer putLong (long value)\n   {\n-    return ByteBufferHelper.putLong (this, value);\n+    ByteBufferHelper.putLong (this, value, order());\n+    return this;\n   }\n   \n-  public final long getLong (int index)\n+  final public long getLong (int index)\n   {\n-    return ByteBufferHelper.getLong (this, index);\n+    return ByteBufferHelper.getLong (this, index, order());\n   }\n   \n-  public final ByteBuffer putLong (int index, long value)\n+  final public ByteBuffer putLong (int index, long value)\n   {\n-    return ByteBufferHelper.putLong (this, index, value);\n+    ByteBufferHelper.putLong (this, index, value, order());\n+    return this;\n   }\n \n-  public final float getFloat()\n+  final public float getFloat ()\n   {\n-    return ByteBufferHelper.getFloat (this);\n+    return ByteBufferHelper.getFloat (this, order());\n   }\n   \n-  public final ByteBuffer putFloat (float value)\n+  final public ByteBuffer putFloat (float value)\n   {\n-    return ByteBufferHelper.putFloat (this, value);\n+    ByteBufferHelper.putFloat (this, value, order());\n+    return this;\n   }\n   \n   public final float getFloat (int index)\n   {\n-    return ByteBufferHelper.getFloat (this, index);\n+    return ByteBufferHelper.getFloat (this, index, order());\n   }\n \n-  public final ByteBuffer putFloat (int index, float value)\n+  final public ByteBuffer putFloat (int index, float value)\n   {\n-    return ByteBufferHelper.putFloat (this, index, value);\n+    ByteBufferHelper.putFloat (this, index, value, order());\n+    return this;\n   }\n \n-  public final double getDouble()\n+  final public double getDouble ()\n   {\n-    return ByteBufferHelper.getDouble (this);\n+    return ByteBufferHelper.getDouble (this, order());\n   }\n \n-  public final ByteBuffer putDouble (double value)\n+  final public ByteBuffer putDouble (double value)\n   {\n-    return ByteBufferHelper.putDouble (this, value);\n+    ByteBufferHelper.putDouble (this, value, order());\n+    return this;\n   }\n   \n-  public final double getDouble (int index)\n+  final public double getDouble (int index)\n   {\n-    return ByteBufferHelper.getDouble (this, index);\n+    return ByteBufferHelper.getDouble (this, index, order());\n   }\n   \n-  public final ByteBuffer putDouble (int index, double value)\n+  final public ByteBuffer putDouble (int index, double value)\n   {\n-    return ByteBufferHelper.putDouble (this, index, value);\n+    ByteBufferHelper.putDouble (this, index, value, order());\n+    return this;\n   }\n }"}, {"sha": "b217f1cb5536a0b131426f8c3c039356197ae410", "filename": "libjava/java/nio/ShortViewBufferImpl.java", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FShortViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FShortViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FShortViewBufferImpl.java?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -1,5 +1,5 @@\n /* ShortViewBufferImpl.java -- \n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,103 +40,90 @@\n \n class ShortViewBufferImpl extends ShortBuffer\n {\n-  private boolean readOnly;\n+  /** Position in bb (i.e. a byte offset) where this buffer starts. */\n   private int offset;\n   private ByteBuffer bb;\n+  private boolean readOnly;\n   private ByteOrder endian;\n   \n-  public ShortViewBufferImpl (ByteBuffer bb, boolean readOnly)\n-  {\n-    super (bb.remaining () >> 1, bb.remaining () >> 1, bb.position (), 0);\n-    this.bb = bb;\n-    this.readOnly = readOnly;\n-    // FIXME: What if this is called from ShortByteBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n-  }\n-\n   public ShortViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n-                               int limit, int position, int mark,\n-                               boolean readOnly)\n+\t\t\t      int limit, int position, int mark,\n+\t\t\t      boolean readOnly, ByteOrder endian)\n   {\n     super (limit >> 1, limit >> 1, position >> 1, mark >> 1);\n     this.bb = bb;\n     this.offset = offset;\n     this.readOnly = readOnly;\n-    // FIXME: What if this is called from ShortViewBufferImpl and ByteBuffer has changed its endianess ?\n-    this.endian = bb.order ();\n+    this.endian = endian;\n   }\n \n   public short get ()\n   {\n-    short result = bb.getShort ((position () << 1) + offset);\n-    position (position () + 1);\n+    int p = position();\n+    short result = ByteBufferHelper.getShort(bb, (p << 1) + offset, endian);\n+    position(p + 1);\n     return result;\n   }\n \n   public short get (int index)\n   {\n-    return bb.getShort ((index << 1) + offset);\n+    return ByteBufferHelper.getShort(bb, (index << 1) + offset, endian);\n   }\n \n   public ShortBuffer put (short value)\n   {\n-    bb.putShort ((position () << 1) + offset, value);\n-    position (position () + 1);\n+    int p = position();\n+    ByteBufferHelper.putShort(bb, (p << 1) + offset, value, endian);\n+    position(p + 1);\n     return this;\n   }\n   \n   public ShortBuffer put (int index, short value)\n   {\n-    bb.putShort ((index << 1) + offset, value);\n+    ByteBufferHelper.putShort(bb, (index << 1) + offset, value, endian);\n     return this;\n   }\n \n   public ShortBuffer compact ()\n   {\n     if (position () > 0)\n       {\n-        // Copy all data from position() to limit() to the beginning of the\n-        // buffer, set position to end of data and limit to capacity\n-        // XXX: This can surely be optimized, for direct and non-direct buffers\n-        \n         int count = limit () - position ();\n-              \n-        for (int i = 0; i < count; i++)\n-          {\n-            bb.putShort ((i >> 1) + offset,\n-                          bb.getShort (((i + position ()) >> 1) + offset));\n-          }\n-\n+\tbb.shiftDown(offset, offset + 2 * position(), 2 * count);\n         position (count);\n         limit (capacity ());\n       }\n-\n     return this;\n   }\n   \n-  public ShortBuffer duplicate ()\n-  {\n-    // Create a copy of this object that shares its content\n-    // FIXME: mark is not correct\n-    return new ShortViewBufferImpl (bb, offset, capacity (), limit (),\n-                                     position (), -1, isReadOnly ());\n-  }\n-  \n   public ShortBuffer slice ()\n   {\n     // Create a sliced copy of this object that shares its content.\n     return new ShortViewBufferImpl (bb, (position () >> 1) + offset,\n-                                      remaining (), remaining (), 0, -1,\n-                                     isReadOnly ());\n+\t\t\t\t    remaining(), remaining(), 0, -1,\n+\t\t\t\t    readOnly, endian);\n   }\n   \n-  public ShortBuffer asReadOnlyBuffer ()\n+  ShortBuffer duplicate (boolean readOnly)\n   {\n-    // Create a copy of this object that shares its content and is read-only\n-    return new ShortViewBufferImpl (bb, (position () >> 1) + offset,\n-                                     remaining (), remaining (), 0, -1, true);\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    return new ShortViewBufferImpl (bb, offset, capacity(), limit(),\n+\t\t\t\t    pos, mark, readOnly, endian);\n   }\n   \n+  public ShortBuffer duplicate ()\n+  {\n+    return duplicate(readOnly);\n+  }\n+\n+  public ShortBuffer asReadOnlyBuffer ()\n+  {\n+    return duplicate(true);\n+  }\n+\n   public boolean isReadOnly ()\n   {\n     return readOnly;\n@@ -149,6 +136,6 @@ public boolean isDirect ()\n   \n   public ByteOrder order ()\n   {\n-    return ByteOrder.LITTLE_ENDIAN;\n+    return endian;\n   }\n }"}, {"sha": "7ff06ffa030849c8e1275d5534706983421309c0", "filename": "libjava/java/nio/natDirectByteBufferImpl.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c23042f4594368c96e1af7dc65b72590d584b0/libjava%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc?ref=40c23042f4594368c96e1af7dc65b72590d584b0", "patch": "@@ -43,3 +43,12 @@ java::nio::DirectByteBufferImpl::putImpl (jint index, jbyte value)\n   jbyte* pointer = reinterpret_cast<jbyte*> (address) + offset + index;\n   *pointer = value;\n }\n+\n+void\n+java::nio::DirectByteBufferImpl::shiftDown\n+(jint dst_offset, jint src_offset, jint count)\n+{\n+  jbyte* dst = reinterpret_cast<jbyte*> (address) + offset + dst_offset;\n+  jbyte* src = reinterpret_cast<jbyte*> (address) + offset + src_offset;\n+  ::memmove(dst, src, count);\n+}"}]}