{"sha": "b89e4559950c79d8933013305c19d7014a39cdb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg5ZTQ1NTk5NTBjNzlkODkzMzAxMzMwNWMxOWQ3MDE0YTM5Y2RiMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-26T06:12:44Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-26T06:12:44Z"}, "message": "Track arguments pointing to local or readonly memory in ipa-fnsummary\n\nthis patch implement tracking wehther argument points to readonly memory. This\nis is useful for ipa-modref as well as for inline heuristics.  It is desirable\nto inline functions that dereference pointers to local variables in order\nto support SRA.  We always did the oposite heuristics (guessing that the\ndereferences will be optimized out with 50% probability) but here we could\nincrease the probability for cases where we can track that argument is indeed\na local memory (or readonly which is also good)\n\n\t* ipa-fnsummary.c (dump_ipa_call_summary): Dump\n\tpoints_to_local_or_readonly_memory flag.\n\t(analyze_function_body): Compute points_to_local_or_readonly_memory\n\tflag.\n\t(remap_edge_change_prob): Rename to ...\n\t(remap_edge_params): ... this one; update\n\tpoints_to_local_or_readonly_memory.\n\t(remap_edge_summaries): Update.\n\t(read_ipa_call_summary): Stream the new flag.\n\t(write_ipa_call_summary): Likewise.\n\t* ipa-predicate.h (struct inline_param_summary): Add\n\tpoints_to_local_or_readonly_memory.\n\t(inline_param_summary::equal_to): Update.\n\t(inline_param_summary::useless_p): Update.", "tree": {"sha": "b669a4d78420aed0632b161bf8ff2cb1cead65c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b669a4d78420aed0632b161bf8ff2cb1cead65c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b89e4559950c79d8933013305c19d7014a39cdb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89e4559950c79d8933013305c19d7014a39cdb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89e4559950c79d8933013305c19d7014a39cdb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89e4559950c79d8933013305c19d7014a39cdb1/comments", "author": null, "committer": null, "parents": [{"sha": "5a90a18668fef8d51e5b3fe9f69123f53cbd8f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25"}], "stats": {"total": 53, "additions": 42, "deletions": 11}, "files": [{"sha": "4c1c1f91482d0639f8fc8aed1bf22c8e8c76ebe4", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89e4559950c79d8933013305c19d7014a39cdb1/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89e4559950c79d8933013305c19d7014a39cdb1/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=b89e4559950c79d8933013305c19d7014a39cdb1", "patch": "@@ -980,6 +980,9 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t    else if (prob != REG_BR_PROB_BASE)\n \t      fprintf (f, \"%*s op%i change %f%% of time\\n\", indent + 2, \"\", i,\n \t\t       prob * 100.0 / REG_BR_PROB_BASE);\n+\t    if (es->param[i].points_to_local_or_readonly_memory)\n+\t      fprintf (f, \"%*s op%i points to local or readonly memory\\n\",\n+\t\t       indent + 2, \"\", i);\n \t  }\n       if (!edge->inline_failed)\n \t{\n@@ -2671,6 +2674,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t      int prob = param_change_prob (&fbi, stmt, i);\n \t\t      gcc_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n \t\t      es->param[i].change_prob = prob;\n+\t\t      es->param[i].points_to_local_or_readonly_memory\n+\t\t\t = points_to_local_or_readonly_memory_p\n+\t\t\t     (gimple_call_arg (stmt, i));\n \t\t    }\n \t\t}\n \n@@ -3781,15 +3787,17 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)\n     ipa_call_summaries->get (e)->loop_depth += depth;\n }\n \n-/* Update change_prob of EDGE after INLINED_EDGE has been inlined.\n+/* Update change_prob and points_to_local_or_readonly_memory of EDGE after\n+   INLINED_EDGE has been inlined.\n+\n    When function A is inlined in B and A calls C with parameter that\n    changes with probability PROB1 and C is known to be passthrough\n    of argument if B that change with probability PROB2, the probability\n    of change is now PROB1*PROB2.  */\n \n static void\n-remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n-\t\t\tstruct cgraph_edge *edge)\n+remap_edge_params (struct cgraph_edge *inlined_edge,\n+\t\t   struct cgraph_edge *edge)\n {\n   if (ipa_node_params_sum)\n     {\n@@ -3823,7 +3831,16 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n \t\t    prob = 1;\n \n \t\t  es->param[i].change_prob = prob;\n+\n+\t\t  if (inlined_es\n+\t\t\t->param[id].points_to_local_or_readonly_memory)\n+\t\t    es->param[i].points_to_local_or_readonly_memory = true;\n \t\t}\n+\t      if (!es->param[i].points_to_local_or_readonly_memory\n+\t\t  && jfunc->type == IPA_JF_CONST\n+\t\t  && points_to_local_or_readonly_memory_p\n+\t\t\t (ipa_get_jf_constant (jfunc)))\n+\t\tes->param[i].points_to_local_or_readonly_memory = true;\n \t    }\n \t}\n     }\n@@ -3856,7 +3873,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n       if (e->inline_failed)\n \t{\n           class ipa_call_summary *es = ipa_call_summaries->get (e);\n-\t  remap_edge_change_prob (inlined_edge, e);\n+\t  remap_edge_params (inlined_edge, e);\n \n \t  if (es->predicate)\n \t    {\n@@ -3882,7 +3899,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n       predicate p;\n       next = e->next_callee;\n \n-      remap_edge_change_prob (inlined_edge, e);\n+      remap_edge_params (inlined_edge, e);\n       if (es->predicate)\n \t{\n \t  p = es->predicate->remap_after_inlining\n@@ -4208,12 +4225,19 @@ read_ipa_call_summary (class lto_input_block *ib, struct cgraph_edge *e,\n     {\n       es->param.safe_grow_cleared (length, true);\n       for (i = 0; i < length; i++)\n-\tes->param[i].change_prob = streamer_read_uhwi (ib);\n+\t{\n+\t  es->param[i].change_prob = streamer_read_uhwi (ib);\n+\t  es->param[i].points_to_local_or_readonly_memory\n+\t    = streamer_read_uhwi (ib);\n+\t}\n     }\n   else\n     {\n       for (i = 0; i < length; i++)\n-\tstreamer_read_uhwi (ib);\n+\t{\n+\t  streamer_read_uhwi (ib);\n+\t  streamer_read_uhwi (ib);\n+\t}\n     }\n }\n \n@@ -4438,7 +4462,10 @@ write_ipa_call_summary (struct output_block *ob, struct cgraph_edge *e)\n     streamer_write_uhwi (ob, 0);\n   streamer_write_uhwi (ob, es->param.length ());\n   for (i = 0; i < (int) es->param.length (); i++)\n-    streamer_write_uhwi (ob, es->param[i].change_prob);\n+    {\n+      streamer_write_uhwi (ob, es->param[i].change_prob);\n+      streamer_write_uhwi (ob, es->param[i].points_to_local_or_readonly_memory);\n+    }\n }\n \n "}, {"sha": "05e37073817cb2e02e066194a3ac668415b836bb", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89e4559950c79d8933013305c19d7014a39cdb1/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89e4559950c79d8933013305c19d7014a39cdb1/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=b89e4559950c79d8933013305c19d7014a39cdb1", "patch": "@@ -76,14 +76,18 @@ struct inline_param_summary\n      parameters REG_BR_PROB_BASE.\n \n      Value 0 is reserved for compile time invariants. */\n-  int change_prob;\n+  short change_prob;\n+  unsigned points_to_local_or_readonly_memory : 1;\n   bool equal_to (const inline_param_summary &other) const\n   {\n-    return change_prob == other.change_prob;\n+    return change_prob == other.change_prob\n+\t   && points_to_local_or_readonly_memory\n+\t      == other.points_to_local_or_readonly_memory;\n   }\n   bool useless_p (void) const\n   {\n-    return change_prob == REG_BR_PROB_BASE;\n+    return change_prob == REG_BR_PROB_BASE\n+\t   && !points_to_local_or_readonly_memory;\n   }\n };\n "}]}