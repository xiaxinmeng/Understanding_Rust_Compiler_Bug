{"sha": "4f22942841edabbdda8a15b172a5c143da7bdafe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYyMjk0Mjg0MWVkYWJiZGRhOGExNWIxNzJhNWMxNDNkYTdiZGFmZQ==", "commit": {"author": {"name": "Matthias Kretz", "email": "kretz@kde.org", "date": "2021-02-03T15:49:29Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-02-03T15:49:29Z"}, "message": "libstdc++: Fix NEON intrinsic types usage\n\nIntrinsics types for NEON differ from gnu::vector_size types now. This\nrequires explicit specializations for __intrinsic_type and a new\n__is_intrinsic_type trait.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/experimental/bits/simd.h (__is_intrinsic_type): New\n\tinternal type trait. Alias for __is_vector_type on x86.\n\t(_VectorTraitsImpl): Enable for __intrinsic_type in addition for\n\t__vector_type.\n\t(__intrin_bitcast): Allow casting to & from vector & intrinsic\n\ttypes.\n\t(__intrinsic_type): Explicitly specialize for NEON intrinsic\n\tvector types.", "tree": {"sha": "b3d363978810514694acbe3b7e396acb8f13575c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3d363978810514694acbe3b7e396acb8f13575c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f22942841edabbdda8a15b172a5c143da7bdafe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f22942841edabbdda8a15b172a5c143da7bdafe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f22942841edabbdda8a15b172a5c143da7bdafe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f22942841edabbdda8a15b172a5c143da7bdafe/comments", "author": {"login": "mattkretz", "id": 3306474, "node_id": "MDQ6VXNlcjMzMDY0NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3306474?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattkretz", "html_url": "https://github.com/mattkretz", "followers_url": "https://api.github.com/users/mattkretz/followers", "following_url": "https://api.github.com/users/mattkretz/following{/other_user}", "gists_url": "https://api.github.com/users/mattkretz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattkretz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattkretz/subscriptions", "organizations_url": "https://api.github.com/users/mattkretz/orgs", "repos_url": "https://api.github.com/users/mattkretz/repos", "events_url": "https://api.github.com/users/mattkretz/events{/privacy}", "received_events_url": "https://api.github.com/users/mattkretz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa89c53c7370128ed8d8ce348cd0ef97c26af59b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa89c53c7370128ed8d8ce348cd0ef97c26af59b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa89c53c7370128ed8d8ce348cd0ef97c26af59b"}], "stats": {"total": 70, "additions": 66, "deletions": 4}, "files": [{"sha": "c379721c7bec2c7f7602607bee33e8363f3274f3", "filename": "libstdc++-v3/include/experimental/bits/simd.h", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f22942841edabbdda8a15b172a5c143da7bdafe/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f22942841edabbdda8a15b172a5c143da7bdafe/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fsimd.h?ref=4f22942841edabbdda8a15b172a5c143da7bdafe", "patch": "@@ -1379,13 +1379,35 @@ template <typename _Tp>\n template <typename _Tp>\n   inline constexpr bool __is_vector_type_v = __is_vector_type<_Tp>::value;\n \n+// }}}\n+// __is_intrinsic_type {{{\n+#if _GLIBCXX_SIMD_HAVE_SSE_ABI\n+template <typename _Tp>\n+  using __is_intrinsic_type = __is_vector_type<_Tp>;\n+#else // not SSE (x86)\n+template <typename _Tp, typename = void_t<>>\n+  struct __is_intrinsic_type : false_type {};\n+\n+template <typename _Tp>\n+  struct __is_intrinsic_type<\n+    _Tp, void_t<typename __intrinsic_type<\n+\t   remove_reference_t<decltype(declval<_Tp>()[0])>, sizeof(_Tp)>::type>>\n+    : is_same<_Tp, typename __intrinsic_type<\n+\t\t     remove_reference_t<decltype(declval<_Tp>()[0])>,\n+\t\t     sizeof(_Tp)>::type> {};\n+#endif\n+\n+template <typename _Tp>\n+  inline constexpr bool __is_intrinsic_type_v = __is_intrinsic_type<_Tp>::value;\n+\n // }}}\n // _VectorTraits{{{\n template <typename _Tp, typename = void_t<>>\n   struct _VectorTraitsImpl;\n \n template <typename _Tp>\n-  struct _VectorTraitsImpl<_Tp, enable_if_t<__is_vector_type_v<_Tp>>>\n+  struct _VectorTraitsImpl<_Tp, enable_if_t<__is_vector_type_v<_Tp>\n+\t\t\t\t\t      || __is_intrinsic_type_v<_Tp>>>\n   {\n     using type = _Tp;\n     using value_type = remove_reference_t<decltype(declval<_Tp>()[0])>;\n@@ -1457,7 +1479,8 @@ template <typename _To, typename _From>\n   _GLIBCXX_SIMD_INTRINSIC constexpr _To\n   __intrin_bitcast(_From __v)\n   {\n-    static_assert(__is_vector_type_v<_From> && __is_vector_type_v<_To>);\n+    static_assert((__is_vector_type_v<_From> || __is_intrinsic_type_v<_From>)\n+\t\t    && (__is_vector_type_v<_To> || __is_intrinsic_type_v<_To>));\n     if constexpr (sizeof(_To) == sizeof(_From))\n       return reinterpret_cast<_To>(__v);\n     else if constexpr (sizeof(_From) > sizeof(_To))\n@@ -2183,16 +2206,55 @@ template <typename _Tp, size_t _Bytes>\n #endif // _GLIBCXX_SIMD_HAVE_SSE_ABI\n // __intrinsic_type (ARM){{{\n #if _GLIBCXX_SIMD_HAVE_NEON\n+template <>\n+  struct __intrinsic_type<float, 8, void>\n+  { using type = float32x2_t; };\n+\n+template <>\n+  struct __intrinsic_type<float, 16, void>\n+  { using type = float32x4_t; };\n+\n+#if _GLIBCXX_SIMD_HAVE_NEON_A64\n+template <>\n+  struct __intrinsic_type<double, 8, void>\n+  { using type = float64x1_t; };\n+\n+template <>\n+  struct __intrinsic_type<double, 16, void>\n+  { using type = float64x2_t; };\n+#endif\n+\n+#define _GLIBCXX_SIMD_ARM_INTRIN(_Bits, _Np)                                   \\\n+template <>                                                                    \\\n+  struct __intrinsic_type<__int_with_sizeof_t<_Bits / 8>,                      \\\n+\t\t\t  _Np * _Bits / 8, void>                               \\\n+  { using type = int##_Bits##x##_Np##_t; };                                    \\\n+template <>                                                                    \\\n+  struct __intrinsic_type<make_unsigned_t<__int_with_sizeof_t<_Bits / 8>>,     \\\n+\t\t\t  _Np * _Bits / 8, void>                               \\\n+  { using type = uint##_Bits##x##_Np##_t; }\n+_GLIBCXX_SIMD_ARM_INTRIN(8, 8);\n+_GLIBCXX_SIMD_ARM_INTRIN(8, 16);\n+_GLIBCXX_SIMD_ARM_INTRIN(16, 4);\n+_GLIBCXX_SIMD_ARM_INTRIN(16, 8);\n+_GLIBCXX_SIMD_ARM_INTRIN(32, 2);\n+_GLIBCXX_SIMD_ARM_INTRIN(32, 4);\n+_GLIBCXX_SIMD_ARM_INTRIN(64, 1);\n+_GLIBCXX_SIMD_ARM_INTRIN(64, 2);\n+#undef _GLIBCXX_SIMD_ARM_INTRIN\n+\n template <typename _Tp, size_t _Bytes>\n   struct __intrinsic_type<_Tp, _Bytes,\n \t\t\t  enable_if_t<__is_vectorizable_v<_Tp> && _Bytes <= 16>>\n   {\n-    static constexpr int _S_VBytes = _Bytes <= 8 ? 8 : 16;\n+    static constexpr int _SVecBytes = _Bytes <= 8 ? 8 : 16;\n     using _Ip = __int_for_sizeof_t<_Tp>;\n     using _Up = conditional_t<\n       is_floating_point_v<_Tp>, _Tp,\n       conditional_t<is_unsigned_v<_Tp>, make_unsigned_t<_Ip>, _Ip>>;\n-    using type [[__gnu__::__vector_size__(_S_VBytes)]] = _Up;\n+    static_assert(!is_same_v<_Tp, _Up> || _SVecBytes != _Bytes,\n+\t\t  \"should use explicit specialization above\");\n+    using type = typename __intrinsic_type<_Up, _SVecBytes>::type;\n   };\n #endif // _GLIBCXX_SIMD_HAVE_NEON\n "}]}