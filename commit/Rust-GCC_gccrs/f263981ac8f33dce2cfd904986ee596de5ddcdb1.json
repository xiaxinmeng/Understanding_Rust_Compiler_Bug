{"sha": "f263981ac8f33dce2cfd904986ee596de5ddcdb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI2Mzk4MWFjOGYzM2RjZTJjZmQ5MDQ5ODZlZTU5NmRlNWRkY2RiMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-05-19T10:30:20Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-05-19T10:30:20Z"}, "message": "[multiple changes]\n\n2011-05-19  Daniel Krugler  <daniel.kruegler@googlemail.com>\n\n\t* testsuite/util/testsuite_tr1.h: Add test classes.\n\t* testsuite/20_util/is_nothrow_assignable/value.cc: Add.\n\n2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/std/type_traits (is_assignable, is_copy_assignable,\n\tis_move_assignable, is_nothrow_assignable, is_nothrow_copy_assignable,\n\tis_nothrow_move_assignable): Add; minor tweaks elsewhere.\n\t(has_nothrow_copy_assign): Remove.\n\t* testsuite/util/testsuite_tr1.h: Add test classes.\n\t* testsuite/20_util/is_assignable/requirements/typedefs.cc: Add.\n\t* testsuite/20_util/is_assignable/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_assignable/value.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_assignable/requirements/typedefs.cc:\n\tLikewise.\n\t* testsuite/20_util/is_nothrow_assignable/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_move_assignable/value.cc: Likewise.\n\t* testsuite/20_util/is_move_assignable/requirements/typedefs.cc:\n\tLikewise.\n\t* testsuite/20_util/is_move_assignable/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_copy_assignable/value.cc: Likewise.\n\t* testsuite/20_util/is_copy_assignable/requirements/typedefs.cc:\n\tLikewise.\n\t* testsuite/20_util/is_copy_assignable/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_move_assignable/value.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_move_assignable/requirements/\n\ttypedefs.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_move_assignable/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_copy_assignable/value.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_copy_assignable/requirements/\n\ttypedefs.cc: Likewise.\n\t* testsuite/20_util/is_nothrow_copy_assignable/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n\tdg-error line numbers.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\nFrom-SVN: r173899", "tree": {"sha": "90c5eb2af8a67cc63a34a871db67b5c2f1fd1c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90c5eb2af8a67cc63a34a871db67b5c2f1fd1c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f263981ac8f33dce2cfd904986ee596de5ddcdb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f263981ac8f33dce2cfd904986ee596de5ddcdb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f263981ac8f33dce2cfd904986ee596de5ddcdb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f263981ac8f33dce2cfd904986ee596de5ddcdb1/comments", "author": null, "committer": null, "parents": [{"sha": "5fea7e8b43d2ad5b7f76a65e5f4fdb6b84d98dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fea7e8b43d2ad5b7f76a65e5f4fdb6b84d98dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fea7e8b43d2ad5b7f76a65e5f4fdb6b84d98dab"}], "stats": {"total": 1798, "additions": 1722, "deletions": 76}, "files": [{"sha": "344d1853d878806c2125a06c03495800120f8fd4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -1,3 +1,49 @@\n+2011-05-19  Daniel Krugler  <daniel.kruegler@googlemail.com>\n+\n+\t* testsuite/util/testsuite_tr1.h: Add test classes.\n+\t* testsuite/20_util/is_nothrow_assignable/value.cc: Add.\n+\n+2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/std/type_traits (is_assignable, is_copy_assignable,\n+\tis_move_assignable, is_nothrow_assignable, is_nothrow_copy_assignable,\n+\tis_nothrow_move_assignable): Add; minor tweaks elsewhere.\n+\t(has_nothrow_copy_assign): Remove.\n+\t* testsuite/util/testsuite_tr1.h: Add test classes.\n+\t* testsuite/20_util/is_assignable/requirements/typedefs.cc: Add.\n+\t* testsuite/20_util/is_assignable/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_assignable/value.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_assignable/requirements/typedefs.cc:\n+\tLikewise.\n+\t* testsuite/20_util/is_nothrow_assignable/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_move_assignable/value.cc: Likewise.\n+\t* testsuite/20_util/is_move_assignable/requirements/typedefs.cc:\n+\tLikewise.\n+\t* testsuite/20_util/is_move_assignable/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_copy_assignable/value.cc: Likewise.\n+\t* testsuite/20_util/is_copy_assignable/requirements/typedefs.cc:\n+\tLikewise.\n+\t* testsuite/20_util/is_copy_assignable/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_move_assignable/value.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_move_assignable/requirements/\n+\ttypedefs.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_move_assignable/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_copy_assignable/value.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_copy_assignable/requirements/\n+\ttypedefs.cc: Likewise.\n+\t* testsuite/20_util/is_nothrow_copy_assignable/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n+\tdg-error line numbers.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\n 2011-05-18  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/bits/shared_ptr_base.h: Use noexcept. Define special member"}, {"sha": "184e28ba8dcf4de93ca048f3e395a865fa242dd5", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 107, "deletions": 7, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -988,10 +988,110 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __is_nothrow_move_constructible_impl<_Tp>\n     { };\n \n-  /// has_nothrow_copy_assign\n+  template<typename _Tp, typename _Up>\n+    class __is_assignable_helper\n+    : public __sfinae_types\n+    {\n+      template<typename _Tp1, typename _Up1>\n+        static decltype(declval<_Tp1>() = declval<_Up1>(), __one())\n+\t__test(int);\n+\n+      template<typename, typename>\n+        static __two __test(...);\n+\n+    public:\n+      static constexpr bool value = sizeof(__test<_Tp, _Up>(0)) == 1;\n+    };\n+\n+  /// is_assignable\n+  template<typename _Tp, typename _Up>\n+    struct is_assignable\n+    : public integral_constant<bool,\n+                               __is_assignable_helper<_Tp, _Up>::value>\n+    { };\n+\n+  template<typename _Tp, bool = is_void<_Tp>::value>\n+    struct __is_copy_assignable_impl;\n+\n+  template<typename _Tp>\n+    struct __is_copy_assignable_impl<_Tp, true>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_copy_assignable_impl<_Tp, false>\n+    : public is_assignable<_Tp&, const _Tp&&>\n+    { };\n+\n+  /// is_copy_assignable\n+  template<typename _Tp>\n+    struct is_copy_assignable\n+    : public __is_copy_assignable_impl<_Tp>\n+    { };\n+\n+  template<typename _Tp, bool = is_void<_Tp>::value>\n+    struct __is_move_assignable_impl;\n+\n+  template<typename _Tp>\n+    struct __is_move_assignable_impl<_Tp, true>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_move_assignable_impl<_Tp, false>\n+    : public is_assignable<_Tp&, _Tp&&>\n+    { };\n+\n+  /// is_move_assignable\n+  template<typename _Tp>\n+    struct is_move_assignable\n+    : public __is_move_assignable_impl<_Tp>\n+    { };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __is_nt_assignable_impl\n+    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>\n+    { };\n+\n+  /// is_nothrow_assignable\n+  template<typename _Tp, typename _Up>\n+    struct is_nothrow_assignable\n+    : public __and_<is_assignable<_Tp, _Up>,\n+\t\t    __is_nt_assignable_impl<_Tp, _Up>>::type\n+    { };\n+\n+  template<typename _Tp, bool = is_void<_Tp>::value>\n+    struct __is_nt_copy_assignable_impl;\n+\n+  template<typename _Tp>\n+    struct __is_nt_copy_assignable_impl<_Tp, true>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_nt_copy_assignable_impl<_Tp, false>\n+    : public is_nothrow_assignable<_Tp&, const _Tp&&>\n+    { };\n+\n+  /// is_nothrow_copy_assignable\n+  template<typename _Tp>\n+    struct is_nothrow_copy_assignable\n+    : public __is_nt_copy_assignable_impl<_Tp>\n+    { };\n+\n+  template<typename _Tp, bool = is_void<_Tp>::value>\n+    struct __is_nt_move_assignable_impl;\n+\n+  template<typename _Tp>\n+    struct __is_nt_move_assignable_impl<_Tp, true>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_nt_move_assignable_impl<_Tp, false>\n+    : public is_nothrow_assignable<_Tp&, _Tp&&>\n+    { };\n+\n+  /// is_nothrow_move_assignable\n   template<typename _Tp>\n-    struct has_nothrow_copy_assign\n-    : public integral_constant<bool, __has_nothrow_assign(_Tp)>\n+    struct is_nothrow_move_assignable\n+    : public __is_nt_move_assignable_impl<_Tp>\n     { };\n \n   /// has_trivial_default_constructor\n@@ -1086,7 +1186,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n            bool = __or_<is_void<_From>, is_function<_To>,\n                         is_array<_To>>::value>\n     struct __is_convertible_helper\n-    { static const bool __value = is_void<_To>::value; };\n+    { static constexpr bool value = is_void<_To>::value; };\n \n   template<typename _From, typename _To>\n     class __is_convertible_helper<_From, _To, false>\n@@ -1103,14 +1203,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         static __two __test(...);\n \n     public:\n-      static const bool __value = sizeof(__test<_From, _To>(0)) == 1;\n+      static constexpr bool value = sizeof(__test<_From, _To>(0)) == 1;\n     };\n \n   /// is_convertible\n   template<typename _From, typename _To>\n     struct is_convertible\n     : public integral_constant<bool,\n-\t\t\t       __is_convertible_helper<_From, _To>::__value>\n+\t\t\t       __is_convertible_helper<_From, _To>::value>\n     { };\n \n   /// is_explicitly_convertible\n@@ -1729,7 +1829,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         static __two __test(...);                                \\\n                                                                  \\\n     public:                                                      \\\n-      static const bool value = sizeof(__test<_Tp>(0)) == 1;     \\\n+      static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; \\\n     };                                                           \\\n                                                                  \\\n   template<typename _Tp>                                         \\"}, {"sha": "3ca56e9c3338828267dd6895d205845304d919f3", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1615 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1715 }\n \n #include <utility>\n "}, {"sha": "0201c9cb91dccf29381405176f723b22db1bad43", "filename": "libstdc++-v3/testsuite/20_util/has_nothrow_copy_assign/value.cc", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fea7e8b43d2ad5b7f76a65e5f4fdb6b84d98dab/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_copy_assign%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fea7e8b43d2ad5b7f76a65e5f4fdb6b84d98dab/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_copy_assign%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_copy_assign%2Fvalue.cc?ref=5fea7e8b43d2ad5b7f76a65e5f4fdb6b84d98dab", "patch": "@@ -1,57 +0,0 @@\n-// { dg-options \"-std=gnu++0x\" }\n-// 2010-06-08  Paolo Carlini  <paolo.carlini@oracle.com>\n-//\n-// Copyright (C) 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-//\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-//\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include <type_traits>\n-#include <testsuite_hooks.h>\n-#include <testsuite_tr1.h>\n-\n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using std::has_nothrow_copy_assign;\n-  using namespace __gnu_test;\n-\n-  VERIFY( (test_property<has_nothrow_copy_assign, int>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, float>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, EnumType>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, int*>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, int(*)(int)>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, int (ClassType::*)>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign,\n-\t   int (ClassType::*) (int)>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, int[2]>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, float[][3]>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, EnumType[2][3][4]>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, int*[3]>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, int(*[][2])(int)>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign,\n-\t   int (ClassType::*[2][3])>(true)) );\n-  VERIFY( (test_property<has_nothrow_copy_assign, \n-\t   int (ClassType::*[][2][3]) (int)>(true)) );\n-\n-  // Negative tests.\n-  VERIFY( (test_property<has_nothrow_copy_assign, void>(false)) );\n-}\n-\n-int main()\n-{\n-  test01();\n-  return 0;\n-}"}, {"sha": "f4c0e2a6430d0c0de4cc39bf54ddf16b4e162aeb", "filename": "libstdc++-v3/testsuite/20_util/is_assignable/requirements/explicit_instantiation.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Frequirements%2Fexplicit_instantiation.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_assignable<test_type, test_type>;\n+}"}, {"sha": "d73c0c9a5ff24283493e44fb793e9a5c70d67d39", "filename": "libstdc++-v3/testsuite/20_util/is_assignable/requirements/typedefs.cc", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Frequirements%2Ftypedefs.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -1,7 +1,9 @@\n // { dg-options \"-std=gnu++0x\" }\n-// 2010-06-08  Paolo Carlini  <paolo.carlini@oracle.com>\n+// { dg-do compile }\n+\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n //\n-// Copyright (C) 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -23,12 +25,10 @@\n \n #include <type_traits>\n \n-// { dg-do compile }\n-\n void test01()\n {\n   // Check for required typedefs\n-  typedef std::has_nothrow_copy_assign<int>   test_type;\n+  typedef std::is_assignable<int, int>        test_type;\n   typedef test_type::value_type               value_type;\n   typedef test_type::type                     type;\n   typedef test_type::type::value_type         type_value_type;", "previous_filename": "libstdc++-v3/testsuite/20_util/has_nothrow_copy_assign/requirements/typedefs.cc"}, {"sha": "547f732bcc540704e1ee207ae121cbf61c502421", "filename": "libstdc++-v3/testsuite/20_util/is_assignable/value.cc", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_assignable%2Fvalue.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,675 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <initializer_list>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test::assign;\n+\n+static_assert(std::is_assignable<int&, int>::value, \"Error\");\n+static_assert(std::is_assignable<int&, const int>::value, \"Error\");\n+static_assert(std::is_assignable<int&, int&>::value, \"Error\");\n+static_assert(std::is_assignable<int&, const int&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<int, int>::value, \"Error\");\n+static_assert(!std::is_assignable<int, const int>::value, \"Error\");\n+static_assert(!std::is_assignable<int, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<int, const int&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<const int, int>::value, \"Error\");\n+static_assert(!std::is_assignable<const int, const int>::value, \"Error\");\n+static_assert(!std::is_assignable<const int, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<const int, const int&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<const int&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&, const int>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&, const int&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<Empty&, Empty>::value, \"Error\");\n+static_assert(std::is_assignable<Empty&, const Empty>::value, \"Error\");\n+static_assert(std::is_assignable<Empty&, Empty&>::value, \"Error\");\n+static_assert(std::is_assignable<Empty&, const Empty&>::value, \"Error\");\n+static_assert(std::is_assignable<Empty, Empty>::value, \"Error\");\n+static_assert(std::is_assignable<Empty, const Empty>::value, \"Error\");\n+static_assert(std::is_assignable<Empty, Empty&>::value, \"Error\");\n+static_assert(std::is_assignable<Empty, const Empty&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<B&, B>::value, \"Error\");\n+static_assert(std::is_assignable<B&, const B>::value, \"Error\");\n+static_assert(std::is_assignable<B&, B&>::value, \"Error\");\n+static_assert(std::is_assignable<B&, const B&>::value, \"Error\");\n+static_assert(std::is_assignable<B, B>::value, \"Error\");\n+static_assert(std::is_assignable<B, const B>::value, \"Error\");\n+static_assert(std::is_assignable<B, B&>::value, \"Error\");\n+static_assert(std::is_assignable<B, const B&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<bool&, bool>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, const bool>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, bool&>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, const bool&>::value, \"Error\");\n+\n+// bool is a fundamental type that does not allow assignment to an rvalue:\n+static_assert(!std::is_assignable<bool, bool>::value, \"Error\");\n+static_assert(!std::is_assignable<bool, const bool>::value, \"Error\");\n+static_assert(!std::is_assignable<bool, bool&>::value, \"Error\");\n+static_assert(!std::is_assignable<bool, const bool&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<std::nullptr_t&,\n+std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<std::nullptr_t&, const\n+std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<std::nullptr_t&,\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(std::is_assignable<std::nullptr_t&, const\n+std::nullptr_t&>::value, \"Error\");\n+\n+// std::nullptr_t is a fundamental type that does not allow\n+// assignment to an rvalue:\n+static_assert(!std::is_assignable<std::nullptr_t,\n+std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t, const\n+std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t,\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t, const\n+std::nullptr_t&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<E&, E>::value, \"Error\");\n+static_assert(std::is_assignable<E&, const E>::value, \"Error\");\n+static_assert(std::is_assignable<E&, E&>::value, \"Error\");\n+static_assert(std::is_assignable<E&, const E&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<int&, E>::value, \"Error\");\n+static_assert(std::is_assignable<int&, const E>::value, \"Error\");\n+static_assert(std::is_assignable<int&, E&>::value, \"Error\");\n+static_assert(std::is_assignable<int&, const E&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<E&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<E&, const int>::value, \"Error\");\n+static_assert(!std::is_assignable<E&, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<E&, const int&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<E&, E2>::value, \"Error\");\n+static_assert(!std::is_assignable<E&, const E2>::value, \"Error\");\n+static_assert(!std::is_assignable<E&, E2&>::value, \"Error\");\n+static_assert(!std::is_assignable<E&, const E2&>::value, \"Error\");\n+\n+// E is not a class type and thus does not allow assignment to an rvalue:\n+static_assert(!std::is_assignable<E, E>::value, \"Error\");\n+static_assert(!std::is_assignable<E, const E>::value, \"Error\");\n+static_assert(!std::is_assignable<E, E&>::value, \"Error\");\n+static_assert(!std::is_assignable<E, const E&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<SE&, SE>::value, \"Error\");\n+static_assert(std::is_assignable<SE&, const SE>::value, \"Error\");\n+static_assert(std::is_assignable<SE&, SE&>::value, \"Error\");\n+static_assert(std::is_assignable<SE&, const SE&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<int&, SE>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, const SE>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, SE&>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, const SE&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<SE&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<SE&, const int>::value, \"Error\");\n+static_assert(!std::is_assignable<SE&, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<SE&, const int&>::value, \"Error\");\n+\n+// SE is not a class type and thus does not allow assignment to an rvalue:\n+static_assert(!std::is_assignable<SE, SE>::value, \"Error\");\n+static_assert(!std::is_assignable<SE, const SE>::value, \"Error\");\n+static_assert(!std::is_assignable<SE, SE&>::value, \"Error\");\n+static_assert(!std::is_assignable<SE, const SE&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<AnyAssign&, int>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, E>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, SE>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, Empty>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, U>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, int&>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, std::nullptr_t&>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, E&>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, SE&>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, Empty&>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, U&>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, AnyAssign>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&,\n+std::initializer_list<int>>::value, \"Error\");\n+\n+static_assert(std::is_assignable<AnyAssign&, int[1]>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&,\n+std::nullptr_t[1]>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, E[1]>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, SE[1]>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, int(&)[1]>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&,\n+std::nullptr_t(&)[1]>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, E(&)[1]>::value, \"Error\");\n+static_assert(std::is_assignable<AnyAssign&, SE(&)[1]>::value, \"Error\");\n+\n+static_assert(std::is_assignable<int&, E>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, SE>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, E>::value, \"Error\");\n+static_assert(!std::is_assignable<bool&, SE>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, void*>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, int B::*>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, void*>::value, \"Error\");\n+static_assert(std::is_assignable<bool&, std::nullptr_t>::value, \"Error\");\n+\n+static_assert(std::is_assignable<std::nullptr_t&,\n+std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<void*&, std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<int*&, std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<int B::*&, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t&, bool>::value, \"Error\");\n+static_assert(!std::is_assignable<void*&, bool>::value, \"Error\");\n+static_assert(!std::is_assignable<E&, bool>::value, \"Error\");\n+static_assert(!std::is_assignable<SE&, bool>::value, \"Error\");\n+\n+static_assert(std::is_assignable<std::initializer_list<int>&,\n+std::initializer_list<int>>::value, \"Error\");\n+static_assert(std::is_assignable<std::initializer_list<int>&,\n+std::initializer_list<int>&&>::value, \"Error\");\n+static_assert(std::is_assignable<std::initializer_list<int>&, const\n+std::initializer_list<int>&&>::value, \"Error\");\n+static_assert(std::is_assignable<std::initializer_list<int>&,\n+std::initializer_list<int>&>::value, \"Error\");\n+static_assert(std::is_assignable<std::initializer_list<int>&, const\n+std::initializer_list<int>&>::value, \"Error\");\n+static_assert(!std::is_assignable<const std::initializer_list<int>&,\n+std::initializer_list<int>>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<const AnyAssign&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<AnyAssign&, void>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<void, int>::value, \"Error\");\n+static_assert(!std::is_assignable<const void, int>::value, \"Error\");\n+static_assert(!std::is_assignable<int, void>::value, \"Error\");\n+static_assert(!std::is_assignable<int, const void>::value, \"Error\");\n+static_assert(!std::is_assignable<const int, void>::value, \"Error\");\n+static_assert(!std::is_assignable<const int, const void>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, void>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, const void>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&, void>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&, const void>::value, \"Error\");\n+static_assert(!std::is_assignable<void, void>::value, \"Error\");\n+static_assert(!std::is_assignable<const void, void>::value, \"Error\");\n+static_assert(!std::is_assignable<const void, const void>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<int[1], int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[1], int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[1], int(&)[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int[2], int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[2], int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[2], int(&)[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int[1], void>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[1], void>::value, \"Error\");\n+static_assert(!std::is_assignable<void, int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<void, int(&)[1]>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<int[], int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[], int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[], int(&)[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int[1], int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[1], int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[1], int(&)[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int[], int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[], int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[], int(&)[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<int[], void>::value, \"Error\");\n+static_assert(!std::is_assignable<int(&)[], void>::value, \"Error\");\n+static_assert(!std::is_assignable<void, int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<void, int(&)[]>::value, \"Error\");\n+\n+static_assert(std::is_assignable<DelCopyAssign&,\n+DelCopyAssign>::value, \"Error\");\n+static_assert(!std::is_assignable<DelCopyAssign&, const\n+DelCopyAssign>::value, \"Error\");\n+static_assert(!std::is_assignable<DelCopyAssign&,\n+DelCopyAssign&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelCopyAssign&, const\n+DelCopyAssign&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelCopyAssign&, void>::value, \"Error\");\n+static_assert(!std::is_assignable<DelCopyAssign&, void()>::value, \"Error\");\n+static_assert(!std::is_assignable<DelCopyAssign&, void(&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<DelCopyAssign&, int>::value, \"Error\");\n+\n+static_assert(std::is_assignable<DelAnyAssign&,\n+DelAnyAssign&&>::value, \"Error\");\n+static_assert(std::is_assignable<DelAnyAssign&, const\n+DelAnyAssign&>::value, \"Error\");\n+static_assert(std::is_assignable<DelAnyAssign,\n+DelAnyAssign&&>::value, \"Error\");\n+static_assert(std::is_assignable<DelAnyAssign, const\n+DelAnyAssign&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<const DelAnyAssign&,\n+DelAnyAssign&&>::value, \"Error\");\n+static_assert(!std::is_assignable<const DelAnyAssign&, const\n+DelAnyAssign&>::value, \"Error\");\n+static_assert(!std::is_assignable<const DelAnyAssign,\n+DelAnyAssign&&>::value, \"Error\");\n+static_assert(!std::is_assignable<const DelAnyAssign, const\n+DelAnyAssign&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<DelAnyAssign&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, const int&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, void>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, void()>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, void()\n+const>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, void(&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, void(&&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&,\n+std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&,\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&,\n+std::initializer_list<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&,\n+std::initializer_list<int>&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, bool>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, bool&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, E>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, E&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, SE>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, SE&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, Empty>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, Empty&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, B>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, B&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, U>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, U&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, void*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, B*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, D*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int B::*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int D::*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int(&)[]>::value, \"Error\");\n+static_assert(!std::is_assignable<DelAnyAssign&, int(&)[1]>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<void(), void>::value, \"Error\");\n+static_assert(!std::is_assignable<void, void()>::value, \"Error\");\n+static_assert(!std::is_assignable<void(), void()>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<void(&)(), void>::value, \"Error\");\n+static_assert(!std::is_assignable<void, void(&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<void(&)(), void(&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<void(&)(), void()>::value, \"Error\");\n+static_assert(!std::is_assignable<void(), void(&)()>::value, \"Error\");\n+\n+static_assert(std::is_assignable<int&, ImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, ExplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<int, ImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<int, ExplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int, ImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int, ExplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&,\n+ImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&,\n+ExplicitTo<int>>::value, \"Error\");\n+\n+static_assert(std::is_assignable<DelImplicitTo<int>&,\n+DelImplicitTo<int>>::value, \"Error\");\n+static_assert(std::is_assignable<DelImplicitTo<int>,\n+DelImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, DelImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<int, DelImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&,\n+DelImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int,\n+DelImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<int&, DelExplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<int, DelExplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int&,\n+DelExplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<const int,\n+DelExplicitTo<int>>::value, \"Error\");\n+\n+static_assert(std::is_assignable<B&, B>::value, \"Error\");\n+static_assert(std::is_assignable<B&, D>::value, \"Error\");\n+static_assert(std::is_assignable<B&, B&>::value, \"Error\");\n+static_assert(std::is_assignable<B&, D&>::value, \"Error\");\n+static_assert(!std::is_assignable<const B&, B&>::value, \"Error\");\n+static_assert(!std::is_assignable<const B&, D&>::value, \"Error\");\n+static_assert(!std::is_assignable<D&, B>::value, \"Error\");\n+static_assert(!std::is_assignable<D&, B&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<B*&, B*>::value, \"Error\");\n+static_assert(std::is_assignable<B*&, D*>::value, \"Error\");\n+static_assert(std::is_assignable<const B*&, D*>::value, \"Error\");\n+static_assert(std::is_assignable<const B*&, const D*>::value, \"Error\");\n+static_assert(std::is_assignable<B*&, B*&>::value, \"Error\");\n+static_assert(std::is_assignable<B*&, D*&>::value, \"Error\");\n+static_assert(std::is_assignable<const B*&, B*&>::value, \"Error\");\n+static_assert(std::is_assignable<const B*&, D*&>::value, \"Error\");\n+static_assert(!std::is_assignable<B* const&, B*&>::value, \"Error\");\n+static_assert(!std::is_assignable<B* const&, D*&>::value, \"Error\");\n+static_assert(!std::is_assignable<D*&, B*>::value, \"Error\");\n+static_assert(!std::is_assignable<D*&, B*&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<MO&, MO>::value, \"Error\");\n+static_assert(std::is_assignable<MO&, MO&&>::value, \"Error\");\n+static_assert(std::is_assignable<MO, MO>::value, \"Error\");\n+static_assert(std::is_assignable<MO, MO&&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<const MO&, MO>::value, \"Error\");\n+static_assert(!std::is_assignable<const MO&, MO&&>::value, \"Error\");\n+static_assert(!std::is_assignable<MO&, const MO&&>::value, \"Error\");\n+static_assert(!std::is_assignable<MO&, MO&>::value, \"Error\");\n+static_assert(!std::is_assignable<MO&, const MO&>::value, \"Error\");\n+static_assert(!std::is_assignable<const MO, MO>::value, \"Error\");\n+static_assert(!std::is_assignable<const MO, MO&&>::value, \"Error\");\n+static_assert(!std::is_assignable<MO, const MO&&>::value, \"Error\");\n+static_assert(!std::is_assignable<MO, MO&>::value, \"Error\");\n+static_assert(!std::is_assignable<MO, const MO&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<NontrivialUnion&,\n+NontrivialUnion>::value, \"Error\");\n+static_assert(!std::is_assignable<NontrivialUnion&,\n+NontrivialUnion&&>::value, \"Error\");\n+static_assert(!std::is_assignable<NontrivialUnion&,\n+NontrivialUnion&>::value, \"Error\");\n+static_assert(!std::is_assignable<NontrivialUnion&, const\n+NontrivialUnion&>::value, \"Error\");\n+static_assert(!std::is_assignable<NontrivialUnion&, const\n+NontrivialUnion&&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<Abstract&, Abstract>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&, Abstract&&>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&, Abstract&>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&, const Abstract&>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&, const Abstract&&>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&&, Abstract>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&&, Abstract&&>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&&, Abstract&>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&&, const Abstract&>::value, \"Error\");\n+static_assert(std::is_assignable<Abstract&&, const\n+Abstract&&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<AbstractDelDtor&,\n+AbstractDelDtor>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&,\n+AbstractDelDtor&&>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&,\n+AbstractDelDtor&>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&, const\n+AbstractDelDtor&>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&, const\n+AbstractDelDtor&&>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&&,\n+AbstractDelDtor>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&&,\n+AbstractDelDtor&&>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&&,\n+AbstractDelDtor&>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&&, const\n+AbstractDelDtor&>::value, \"Error\");\n+static_assert(std::is_assignable<AbstractDelDtor&&, const\n+AbstractDelDtor&&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<DelDef&, DelDef>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&, DelDef&&>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&, DelDef&>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&, const DelDef&>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&, const DelDef&&>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&&, DelDef>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&&, DelDef&&>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&&, DelDef&>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&&, const DelDef&>::value, \"Error\");\n+static_assert(std::is_assignable<DelDef&&, const DelDef&&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<Ellipsis&, Ellipsis>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const Ellipsis>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, Ellipsis&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const Ellipsis&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis, Ellipsis>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis, const Ellipsis>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis, Ellipsis&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis, const Ellipsis&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<Ellipsis&, void>::value, \"Error\");\n+\n+static_assert(std::is_assignable<Ellipsis&, int>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const int>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, int&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const int&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, Empty>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const Empty>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, Empty&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const Empty&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, E>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const E>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, E&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const E&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, SE>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const SE>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, SE&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const SE&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, bool>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const bool>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, bool&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const bool&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const\n+std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, std::nullptr_t&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, void*>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const void*>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, void*&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, const void*&>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, void()>::value, \"Error\");\n+static_assert(std::is_assignable<Ellipsis&, void(&)()>::value, \"Error\");\n+\n+static_assert(std::is_assignable<DelEllipsis&, DelEllipsis>::value, \"Error\");\n+static_assert(std::is_assignable<DelEllipsis&, const\n+DelEllipsis>::value, \"Error\");\n+static_assert(std::is_assignable<DelEllipsis&, DelEllipsis&>::value, \"Error\");\n+static_assert(std::is_assignable<DelEllipsis&, const\n+DelEllipsis&>::value, \"Error\");\n+static_assert(std::is_assignable<DelEllipsis, DelEllipsis>::value, \"Error\");\n+static_assert(std::is_assignable<DelEllipsis, const\n+DelEllipsis>::value, \"Error\");\n+static_assert(std::is_assignable<DelEllipsis, DelEllipsis&>::value, \"Error\");\n+static_assert(std::is_assignable<DelEllipsis, const\n+DelEllipsis&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<DelEllipsis&, void>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const int>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const int&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, Empty>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const Empty>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, Empty&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const Empty&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, E>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const E>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, E&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const E&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, SE>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const SE>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, SE&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const SE&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, bool>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const bool>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, bool&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const bool&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&,\n+std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const\n+std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&,\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, void*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const void*>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, void*&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, const void*&>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, void()>::value, \"Error\");\n+static_assert(!std::is_assignable<DelEllipsis&, void(&)()>::value, \"Error\");\n+\n+static_assert(std::is_assignable<FromArgs<int>&, int>::value, \"Error\");\n+static_assert(std::is_assignable<FromArgs<int>&, const int>::value, \"Error\");\n+static_assert(!std::is_assignable<FromArgs<int>&,\n+ImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<FromArgs<int>&, ImplicitTo<const\n+int>>::value, \"Error\");\n+static_assert(!std::is_assignable<FromArgs<int>&,\n+ExplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_assignable<FromArgs<int>&, ExplicitTo<const\n+int>>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<DelFromArgs<int>&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<DelFromArgs<int>&, const\n+int>::value, \"Error\");\n+\n+static_assert(std::is_assignable<void(*&)(),\n+ImplicitTo<void(*)()>>::value, \"Error\");\n+static_assert(!std::is_assignable<void(*&)(),\n+ExplicitTo<void(*)()>>::value, \"Error\");\n+\n+static_assert(std::is_assignable<UAssignAll&, UAssignAll>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, const\n+UAssignAll>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, UAssignAll&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, const\n+UAssignAll&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<UAssignAll, UAssignAll>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll, const\n+UAssignAll>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll, UAssignAll&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll, const\n+UAssignAll&>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<UAssignAll&, void>::value, \"Error\");\n+static_assert(!std::is_assignable<const UAssignAll&, void>::value, \"Error\");\n+static_assert(!std::is_assignable<const UAssignAll&,\n+UAssignAll>::value, \"Error\");\n+static_assert(!std::is_assignable<const UAssignAll&, const\n+UAssignAll>::value, \"Error\");\n+static_assert(!std::is_assignable<const UAssignAll&,\n+UAssignAll&>::value, \"Error\");\n+static_assert(!std::is_assignable<const UAssignAll&, const\n+UAssignAll&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<UAssignAll&, int>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, int&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, E>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, E&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, SE>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, SE&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, double>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, double&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, Empty>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, Empty&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, B>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, B&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, U>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, U&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&,\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, void()>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, void(&)()>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, void() const>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, void(*)()>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, void(*&)()>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, int*>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, int*&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, void*>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, void*&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, const int*>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, const int*&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, const void*>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, const void*&>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, int[1]>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, int(&)[1]>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, int[]>::value, \"Error\");\n+static_assert(std::is_assignable<UAssignAll&, int(&)[]>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<UDelAssignAll&, int>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, int&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, E>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, E&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, SE>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, SE&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, double>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, double&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, Empty>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, Empty&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, B>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, B&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, U>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, U&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&,\n+std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&,\n+std::nullptr_t&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, void()>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, void(&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, void()\n+const>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, void(*)()>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, void(*&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, int*>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, int*&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, void*>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, void*&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, const int*>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, const\n+int*&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, const\n+void*>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, const\n+void*&>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, int(&)[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<UDelAssignAll&, int(&)[]>::value, \"Error\");\n+\n+static_assert(!std::is_assignable<void(&)(), std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t, void(&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<void(&)(), int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int[], void(&)()>::value, \"Error\");\n+static_assert(!std::is_assignable<int[], std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t, int[]>::value, \"Error\");\n+static_assert(!std::is_assignable<int[1], std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t, int[1]>::value, \"Error\");\n+static_assert(!std::is_assignable<void, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_assignable<std::nullptr_t, void>::value, \"Error\");\n+static_assert(!std::is_assignable<const D&, B&>::value, \"Error\");\n+static_assert(!std::is_assignable<const B&, B&>::value, \"Error\");\n+\n+static_assert(std::is_assignable<B&, const D&>::value, \"Error\");\n+static_assert(std::is_assignable<B&, const B&>::value, \"Error\");\n+static_assert(std::is_assignable<int&, const int&>::value, \"Error\");\n+static_assert(std::is_assignable<int&, const double&>::value, \"Error\");"}, {"sha": "7aaf37e8010990b0feab89b4e8d195c126e480ee", "filename": "libstdc++-v3/testsuite/20_util/is_copy_assignable/requirements/explicit_instantiation.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Frequirements%2Fexplicit_instantiation.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_copy_assignable<test_type>;\n+}"}, {"sha": "14366213afa00f4ea7fd39ea0ae1222a011a7bf8", "filename": "libstdc++-v3/testsuite/20_util/is_copy_assignable/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Frequirements%2Ftypedefs.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_copy_assignable<int>          test_type;\n+  typedef test_type::value_type                 value_type;\n+  typedef test_type::type                       type;\n+  typedef test_type::type::value_type           type_value_type;\n+  typedef test_type::type::type                 type_type;\n+}"}, {"sha": "662c834bd298cbbab39f3b19dd267055f595f73d", "filename": "libstdc++-v3/testsuite/20_util/is_copy_assignable/value.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_copy_assignable%2Fvalue.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_copy_assignable;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_property<is_copy_assignable, int>(true)) );\n+  VERIFY( (test_property<is_copy_assignable, float>(true)) );\n+  VERIFY( (test_property<is_copy_assignable, EnumType>(true)) );\n+  VERIFY( (test_property<is_copy_assignable, int*>(true)) );\n+  VERIFY( (test_property<is_copy_assignable, int(*)(int)>(true)) );\n+  VERIFY( (test_property<is_copy_assignable, int (ClassType::*)>(true)) );\n+  VERIFY( (test_property<is_copy_assignable,\n+\t   int (ClassType::*) (int)>(true)) );\n+\n+  VERIFY( (test_property<is_copy_assignable, NoexceptCopyAssignClass>(true)) );\n+  VERIFY( (test_property<is_copy_assignable, ExceptCopyAssignClass>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_property<is_copy_assignable, void>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, int[2]>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, float[][3]>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, EnumType[2][3][4]>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, int*[3]>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, int(*[][2])(int)>(false)) );\n+  VERIFY( (test_property<is_copy_assignable,\n+\t   int (ClassType::*[2][3])>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, \n+\t   int (ClassType::*[][2][3]) (int)>(false)) );\n+\n+  VERIFY( (test_property<is_copy_assignable, NoexceptMoveAssignClass>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, ExceptMoveAssignClass>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, DeletedCopyAssignClass>(false)) );\n+  VERIFY( (test_property<is_copy_assignable, DeletedMoveAssignClass>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "e85a7464300dcefdcf7a67d682fafd97e8536956", "filename": "libstdc++-v3/testsuite/20_util/is_move_assignable/requirements/explicit_instantiation.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Frequirements%2Fexplicit_instantiation.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_move_assignable<test_type>;\n+}"}, {"sha": "23b8aa816587cedb8c852cbbb362dc2629778f6e", "filename": "libstdc++-v3/testsuite/20_util/is_move_assignable/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Frequirements%2Ftypedefs.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_move_assignable<int>          test_type;\n+  typedef test_type::value_type                 value_type;\n+  typedef test_type::type                       type;\n+  typedef test_type::type::value_type           type_value_type;\n+  typedef test_type::type::type                 type_type;\n+}"}, {"sha": "a7dff82e0bd6db09e44333a5fab395c7c6834db9", "filename": "libstdc++-v3/testsuite/20_util/is_move_assignable/value.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_assignable%2Fvalue.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_move_assignable;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_property<is_move_assignable, int>(true)) );\n+  VERIFY( (test_property<is_move_assignable, float>(true)) );\n+  VERIFY( (test_property<is_move_assignable, EnumType>(true)) );\n+  VERIFY( (test_property<is_move_assignable, int*>(true)) );\n+  VERIFY( (test_property<is_move_assignable, int(*)(int)>(true)) );\n+  VERIFY( (test_property<is_move_assignable, int (ClassType::*)>(true)) );\n+  VERIFY( (test_property<is_move_assignable,\n+\t   int (ClassType::*) (int)>(true)) );\n+\n+  VERIFY( (test_property<is_move_assignable, NoexceptMoveAssignClass>(true)) );\n+  VERIFY( (test_property<is_move_assignable, ExceptMoveAssignClass>(true)) );\n+  VERIFY( (test_property<is_move_assignable, NoexceptCopyAssignClass>(true)) );\n+  VERIFY( (test_property<is_move_assignable, ExceptCopyAssignClass>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_property<is_move_assignable, void>(false)) );\n+  VERIFY( (test_property<is_move_assignable, int[2]>(false)) );\n+  VERIFY( (test_property<is_move_assignable, float[][3]>(false)) );\n+  VERIFY( (test_property<is_move_assignable, EnumType[2][3][4]>(false)) );\n+  VERIFY( (test_property<is_move_assignable, int*[3]>(false)) );\n+  VERIFY( (test_property<is_move_assignable, int(*[][2])(int)>(false)) );\n+  VERIFY( (test_property<is_move_assignable,\n+\t   int (ClassType::*[2][3])>(false)) );\n+  VERIFY( (test_property<is_move_assignable, \n+\t   int (ClassType::*[][2][3]) (int)>(false)) );\n+\n+  VERIFY( (test_property<is_move_assignable, DeletedCopyAssignClass>(false)) );\n+  VERIFY( (test_property<is_move_assignable, DeletedMoveAssignClass>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d3ebe8b1f7ae7c57d59427ef1430cc6415e6d83b", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_assignable/requirements/explicit_instantiation.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Frequirements%2Fexplicit_instantiation.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_nothrow_assignable<test_type, test_type>;\n+}"}, {"sha": "7baeb6f0aa5f896fc8178b6e860d19843450fb42", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_assignable/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Frequirements%2Ftypedefs.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_nothrow_assignable<int, int>  test_type;\n+  typedef test_type::value_type                 value_type;\n+  typedef test_type::type                       type;\n+  typedef test_type::type::value_type           type_value_type;\n+  typedef test_type::type::type                 type_type;\n+}"}, {"sha": "6414faf0e479071e15d240c4f85cee1534af2a85", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_assignable/value.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_assignable%2Fvalue.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_nothrow_assignable;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_relationship<is_nothrow_assignable, int&, int>(true)) );\n+  VERIFY( (test_relationship<is_nothrow_assignable, int&, const int>(true)) );\n+\n+  VERIFY( (test_relationship<is_nothrow_assignable,\n+\t   NoexceptCopyAssignClass&, const NoexceptCopyAssignClass&>(true)) );\n+  VERIFY( (test_relationship<is_nothrow_assignable,\n+\t   NoexceptMoveAssignClass&, NoexceptMoveAssignClass&&>(true)) );\n+  VERIFY( (test_relationship<is_nothrow_assignable,\n+\t   NoexceptCopyAssignClass&, NoexceptCopyAssignClass&&>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_relationship<is_nothrow_assignable, int, int>(false)) );\n+  VERIFY( (test_relationship<is_nothrow_assignable, int, const int>(false)) );\n+\n+  VERIFY( (test_relationship<is_nothrow_assignable,\n+\t   ExceptCopyAssignClass&, const ExceptCopyAssignClass&>(false)) );\n+  VERIFY( (test_relationship<is_nothrow_assignable,\n+\t   ExceptMoveAssignClass&, ExceptMoveAssignClass&&>(false)) );\n+  VERIFY( (test_relationship<is_nothrow_assignable,\n+\t   NoexceptMoveAssignClass&, const NoexceptMoveAssignClass&>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "406c60036f1788d5466904e51bdf0521359ada7d", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_copy_assignable/requirements/explicit_instantiation.cc", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Frequirements%2Fexplicit_instantiation.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -2,7 +2,7 @@\n // { dg-do compile }\n // 2010-06-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n-// Copyright (C) 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -26,5 +26,5 @@\n namespace std\n {\n   typedef short test_type;\n-  template struct has_nothrow_copy_assign<test_type>;\n+  template struct is_nothrow_copy_assignable<test_type>;\n }", "previous_filename": "libstdc++-v3/testsuite/20_util/has_nothrow_copy_assign/requirements/explicit_instantiation.cc"}, {"sha": "52876fe31a2f82dd0054f6a32d2a07e9f1bcaf01", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_copy_assignable/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Frequirements%2Ftypedefs.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2010-06-08  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_nothrow_copy_assignable<int>  test_type;\n+  typedef test_type::value_type                 value_type;\n+  typedef test_type::type                       type;\n+  typedef test_type::type::value_type           type_value_type;\n+  typedef test_type::type::type                 type_type;\n+}"}, {"sha": "f008bfca7c1a882b0944bcb77974db36035cee29", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_copy_assignable/value.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_copy_assignable%2Fvalue.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2010-06-08  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_nothrow_copy_assignable;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_property<is_nothrow_copy_assignable, int>(true)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, float>(true)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, EnumType>(true)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, int*>(true)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, int(*)(int)>(true)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   int (ClassType::*)>(true)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   int (ClassType::*) (int)>(true)) );\n+\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   NoexceptCopyAssignClass>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_property<is_nothrow_copy_assignable, void>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, int[2]>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, float[][3]>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   EnumType[2][3][4]>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, int*[3]>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   int(*[][2])(int)>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   int (ClassType::*[2][3])>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable, \n+\t   int (ClassType::*[][2][3]) (int)>(false)) );\n+\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   ExceptCopyAssignClass>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   NoexceptMoveAssignClass>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   ExceptMoveAssignClass>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   DeletedCopyAssignClass>(false)) );\n+  VERIFY( (test_property<is_nothrow_copy_assignable,\n+\t   DeletedMoveAssignClass>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c360102128e403bae6d6ea2b3bcf1bf86084ddbe", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_move_assignable/requirements/explicit_instantiation.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Frequirements%2Fexplicit_instantiation.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_nothrow_move_assignable<test_type>;\n+}"}, {"sha": "33e0cba43d771695f0a9c5dafb4756ee9594d039", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_move_assignable/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Frequirements%2Ftypedefs.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_nothrow_move_assignable<int>  test_type;\n+  typedef test_type::value_type                 value_type;\n+  typedef test_type::type                       type;\n+  typedef test_type::type::value_type           type_value_type;\n+  typedef test_type::type::type                 type_type;\n+}"}, {"sha": "3eec9b086d5d46ae5615fa3b93ad85d1a61fc243", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_move_assignable/value.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Fvalue.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2011-05-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_nothrow_move_assignable;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_property<is_nothrow_move_assignable, int>(true)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, float>(true)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, EnumType>(true)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, int*>(true)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, int(*)(int)>(true)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   int (ClassType::*)>(true)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   int (ClassType::*) (int)>(true)) );\n+\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   NoexceptMoveAssignClass>(true)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   NoexceptCopyAssignClass>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_property<is_nothrow_move_assignable, void>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, int[2]>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, float[][3]>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   EnumType[2][3][4]>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, int*[3]>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   int(*[][2])(int)>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   int (ClassType::*[2][3])>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable, \n+\t   int (ClassType::*[][2][3]) (int)>(false)) );\n+\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   ExceptMoveAssignClass>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   ExceptCopyAssignClass>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   DeletedMoveAssignClass>(false)) );\n+  VERIFY( (test_property<is_nothrow_move_assignable,\n+\t   DeletedCopyAssignClass>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c92df36b34815d0a7964d67ba8ec1c554cc06081", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1401 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1365 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1501 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1465 }"}, {"sha": "2bb62cba715adea0bebd9ccbdbe626328d156d60", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1325 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1289 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1425 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1389 }"}, {"sha": "03cc431c1cf3f45ceadf6df540dfc4665cd3ef83", "filename": "libstdc++-v3/testsuite/util/testsuite_tr1.h", "status": "modified", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f263981ac8f33dce2cfd904986ee596de5ddcdb1/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h?ref=f263981ac8f33dce2cfd904986ee596de5ddcdb1", "patch": "@@ -204,6 +204,42 @@ namespace __gnu_test\n   {\n     ExceptMoveConsClass(ExceptMoveConsClass&&) noexcept(false);\n   };\n+\n+  struct NoexceptCopyAssignClass\n+  {\n+    NoexceptCopyAssignClass&\n+    operator=(const NoexceptCopyAssignClass&) noexcept(true);\n+  };\n+\n+  struct ExceptCopyAssignClass\n+  {\n+    ExceptCopyAssignClass&\n+    operator=(const ExceptCopyAssignClass&) noexcept(false);\n+  };\n+\n+  struct NoexceptMoveAssignClass\n+  {\n+    NoexceptMoveAssignClass&\n+    operator=(NoexceptMoveAssignClass&&) noexcept(true);\n+  };\n+\n+  struct ExceptMoveAssignClass\n+  {\n+    ExceptMoveAssignClass&\n+    operator=(ExceptMoveAssignClass&&) noexcept(false);\n+  };\n+\n+  struct DeletedCopyAssignClass\n+  {\n+    DeletedCopyAssignClass&\n+    operator=(const DeletedCopyAssignClass&) = delete;\n+  };\n+\n+  struct DeletedMoveAssignClass\n+  {\n+    DeletedMoveAssignClass&\n+    operator=(DeletedMoveAssignClass&&) = delete;\n+  };\n #endif\n \n   struct NType   // neither trivial nor standard-layout\n@@ -450,6 +486,180 @@ namespace __gnu_test\n       UnusualCopy(UnusualCopy&);\n     };\n   }\n+\n+  namespace assign\n+  {\n+    struct Empty {};\n+\n+    struct B { int i; B(){} };\n+    struct D : B {};\n+\n+    enum E { ee1 };\n+    enum E2 { ee2 };\n+    enum class SE { e1 };\n+    enum class SE2 { e2 };\n+\n+    enum OpE : int;\n+    enum class OpSE : bool;\n+\n+    union U { int i; Empty b; };\n+\n+    union UAssignAll\n+    {\n+      bool b;\n+      char c;\n+      template<class T>\n+      void operator=(T&&);\n+    };\n+\n+    union UDelAssignAll\n+    {\n+      bool b;\n+      char c;\n+      template<class T>\n+      void operator=(T&&) = delete;\n+    };\n+\n+    struct Abstract\n+    {\n+      virtual ~Abstract() = 0;\n+    };\n+\n+    struct AbstractDelDtor\n+    {\n+      ~AbstractDelDtor() = delete;\n+      virtual void foo() = 0;\n+    };\n+\n+    struct Ukn;\n+\n+    template<class To>\n+      struct ImplicitTo\n+      {\n+\toperator To();\n+      };\n+\n+    template<class To>\n+      struct ExplicitTo\n+      {\n+\texplicit operator To();\n+      };\n+\n+    template<class To>\n+      struct DelImplicitTo\n+      {\n+\toperator To() = delete;\n+      };\n+\n+    template<class To>\n+      struct DelExplicitTo\n+      {\n+\texplicit operator To() = delete;\n+      };\n+\n+    struct Ellipsis\n+    {\n+      Ellipsis(...){}\n+    };\n+\n+    struct DelEllipsis\n+    {\n+      DelEllipsis(...) = delete;\n+    };\n+\n+    struct Any\n+    {\n+      template<class T>\n+        Any(T&&){}\n+    };\n+\n+    struct nAny\n+    {\n+      template<class... T>\n+        nAny(T&&...){}\n+    };\n+\n+    struct DelnAny\n+    {\n+      template<class... T>\n+        DelnAny(T&&...) = delete;\n+    };\n+\n+    template<class... Args>\n+      struct FromArgs\n+      {\n+\tFromArgs(Args...);\n+      };\n+\n+    template<class... Args>\n+      struct DelFromArgs\n+      {\n+\tDelFromArgs(Args...) = delete;\n+      };\n+\n+    struct DelDef\n+    {\n+      DelDef() = delete;\n+    };\n+\n+    struct DelCopy\n+    {\n+      DelCopy(const DelCopy&) = delete;\n+    };\n+\n+    struct DelDtor\n+    {\n+      DelDtor() = default;\n+      DelDtor(const DelDtor&) = default;\n+      DelDtor(DelDtor&&) = default;\n+      DelDtor(int);\n+      DelDtor(int, B, U);\n+      ~DelDtor() = delete;\n+    };\n+\n+    struct Nontrivial\n+    {\n+      Nontrivial();\n+      Nontrivial(const Nontrivial&);\n+      Nontrivial& operator=(const Nontrivial&);\n+      ~Nontrivial();\n+    };\n+\n+    union NontrivialUnion\n+    {\n+      int i;\n+      Nontrivial n;\n+    };\n+\n+    struct UnusualCopy\n+    {\n+      UnusualCopy(UnusualCopy&);\n+    };\n+\n+    struct AnyAssign\n+    {\n+      template<class T>\n+        void operator=(T&&);\n+    };\n+\n+    struct DelAnyAssign\n+    {\n+      template<class T>\n+        void operator=(T&&) = delete;\n+    };\n+\n+    struct DelCopyAssign\n+    {\n+      DelCopyAssign& operator=(const DelCopyAssign&) = delete;\n+      DelCopyAssign& operator=(DelCopyAssign&&) = default;\n+    };\n+\n+    struct MO\n+    {\n+      MO(MO&&) = default;\n+      MO& operator=(MO&&) = default;\n+    };\n+  }\n #endif\n \n } // namespace __gnu_test"}]}