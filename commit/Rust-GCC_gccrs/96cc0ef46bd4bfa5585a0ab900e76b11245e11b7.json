{"sha": "96cc0ef46bd4bfa5585a0ab900e76b11245e11b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZjYzBlZjQ2YmQ0YmZhNTU4NWEwYWI5MDBlNzZiMTEyNDVlMTFiNw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-04-29T08:43:18Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-04-29T08:43:18Z"}, "message": "Simplify SYSTEM_CLOCK implementation.\n\n2013-04-29  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        * intrinsics/system_clock (gf_gettime_mono): Use variable\n        resolution for fractional seconds argument.\n        (system_clock_4): Simplify, update for gf_gettime_mono change.\n        (system_clock_8): Likewise.\n\nFrom-SVN: r198391", "tree": {"sha": "dfe239cbe8e634690ce5be8c25c9af42fa5e15a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfe239cbe8e634690ce5be8c25c9af42fa5e15a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7/comments", "author": null, "committer": null, "parents": [{"sha": "c033f5ae3270e34c40c7ef9e7168b9884e39b75a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c033f5ae3270e34c40c7ef9e7168b9884e39b75a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c033f5ae3270e34c40c7ef9e7168b9884e39b75a"}], "stats": {"total": 98, "additions": 41, "deletions": 57}, "files": [{"sha": "334220de476a8a7d21b10a38ab5c60bd5331a093", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=96cc0ef46bd4bfa5585a0ab900e76b11245e11b7", "patch": "@@ -1,3 +1,10 @@\n+2013-04-29  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        * intrinsics/system_clock (gf_gettime_mono): Use variable\n+        resolution for fractional seconds argument.\n+        (system_clock_4): Simplify, update for gf_gettime_mono change.\n+        (system_clock_8): Likewise.\n+\n 2013-04-29  Janne Blomqvist  <jb@gcc.gnu.org>\n \n         PR fortran/56981"}, {"sha": "f588833e28b52d47364c8fef7aca077eebfbc136", "filename": "libgfortran/intrinsics/system_clock.c", "status": "modified", "additions": 34, "deletions": 57, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7/libgfortran%2Fintrinsics%2Fsystem_clock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cc0ef46bd4bfa5585a0ab900e76b11245e11b7/libgfortran%2Fintrinsics%2Fsystem_clock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsystem_clock.c?ref=96cc0ef46bd4bfa5585a0ab900e76b11245e11b7", "patch": "@@ -65,7 +65,7 @@ static int weak_gettime (clockid_t, struct timespec *)\n \n    Arguments:\n    secs     - OUTPUT, seconds\n-   nanosecs - OUTPUT, nanoseconds\n+   fracsecs - OUTPUT, fractional seconds, units given by tk argument\n    tk       - OUTPUT, clock resolution [counts/sec]\n \n    If the target supports a monotonic clock, the OUTPUT arguments\n@@ -79,15 +79,15 @@ static int weak_gettime (clockid_t, struct timespec *)\n    is set.\n */\n static int\n-gf_gettime_mono (time_t * secs, long * nanosecs, long * tck)\n+gf_gettime_mono (time_t * secs, long * fracsecs, long * tck)\n {\n   int err;\n #ifdef HAVE_CLOCK_GETTIME\n   struct timespec ts;\n   *tck = 1000000000;\n   err = clock_gettime (GF_CLOCK_MONOTONIC, &ts);\n   *secs = ts.tv_sec;\n-  *nanosecs = ts.tv_nsec;\n+  *fracsecs = ts.tv_nsec;\n   return err;\n #else\n #if defined(HAVE_CLOCK_GETTIME_LIBRT) && SUPPORTS_WEAK && GTHREAD_USE_WEAK\n@@ -97,13 +97,12 @@ gf_gettime_mono (time_t * secs, long * nanosecs, long * tck)\n       *tck = 1000000000;\n       err = weak_gettime (GF_CLOCK_MONOTONIC, &ts);\n       *secs = ts.tv_sec;\n-      *nanosecs = ts.tv_nsec;\n+      *fracsecs = ts.tv_nsec;\n       return err;\n     }\n #endif\n   *tck = 1000000;\n-  err = gf_gettime (secs, nanosecs);\n-  *nanosecs *= 1000;\n+  err = gf_gettime (secs, fracsecs);\n   return err;\n #endif\n }\n@@ -142,43 +141,33 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n   if (count_max)\n     *count_max = GFC_INTEGER_4_HUGE;\n #else\n-  GFC_INTEGER_4 cnt;\n-  GFC_INTEGER_4 mx;\n-\n   time_t secs;\n-  long nanosecs, tck;\n-\n-  if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n-    internal_error (NULL, \"secs too small\");\n+  long fracsecs, tck;\n \n-  if (gf_gettime_mono (&secs, &nanosecs, &tck) == 0)\n+  if (gf_gettime_mono (&secs, &fracsecs, &tck) == 0)\n     {\n-      tck = tck>1000 ? 1000 : tck;\n-      GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) secs * tck;\n-      ucnt += (nanosecs + 500000000 / tck) / (1000000000 / tck);\n+      long tck_out = tck > 1000 ? 1000 : tck;\n+      long tck_r = tck / tck_out;\n+      GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) secs * tck_out;\n+      ucnt += fracsecs / tck_r;\n       if (ucnt > GFC_INTEGER_4_HUGE)\n-\tcnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n-      else\n-\tcnt = ucnt;\n-      mx = GFC_INTEGER_4_HUGE;\n+\tucnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n+      if (count)\n+\t*count = ucnt;\n+      if (count_rate)\n+\t*count_rate = tck_out;\n+      if (count_max)\n+\t*count_max = GFC_INTEGER_4_HUGE;\n     }\n   else\n     {\n-      if (count != NULL)\n+      if (count)\n \t*count = - GFC_INTEGER_4_HUGE;\n-      if (count_rate != NULL)\n+      if (count_rate)\n \t*count_rate = 0;\n-      if (count_max != NULL)\n+      if (count_max)\n \t*count_max = 0;\n-      return;\n     }\n-\n-  if (count != NULL)\n-    *count = cnt;\n-  if (count_rate != NULL)\n-    *count_rate = tck;\n-  if (count_max != NULL)\n-    *count_max = mx;\n #endif\n }\n \n@@ -216,42 +205,30 @@ system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n \t*count_max = GFC_INTEGER_8_HUGE;\n     }\n #else\n-  GFC_INTEGER_8 cnt;\n-  GFC_INTEGER_8 mx;\n-\n   time_t secs;\n-  long nanosecs, tck;\n+  long fracsecs, tck;\n \n-  if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n-    internal_error (NULL, \"secs too small\");\n-\n-  if (gf_gettime_mono (&secs, &nanosecs, &tck) == 0)\n+  if (gf_gettime_mono (&secs, &fracsecs, &tck) == 0)\n     {\n       GFC_UINTEGER_8 ucnt = (GFC_UINTEGER_8) secs * tck;\n-      ucnt += (nanosecs + 500000000 / tck) / (1000000000 / tck);\n+      ucnt += fracsecs;\n       if (ucnt > GFC_INTEGER_8_HUGE)\n-\tcnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n-      else\n-\tcnt = ucnt;\n-      mx = GFC_INTEGER_8_HUGE;\n+\tucnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n+      if (count)\n+\t*count = ucnt;\n+      if (count_rate)\n+\t*count_rate = tck;\n+      if (count_max)\n+\t*count_max = GFC_INTEGER_8_HUGE;\n     }\n   else\n     {\n-      if (count != NULL)\n+      if (count)\n \t*count = - GFC_INTEGER_8_HUGE;\n-      if (count_rate != NULL)\n+      if (count_rate)\n \t*count_rate = 0;\n-      if (count_max != NULL)\n+      if (count_max)\n \t*count_max = 0;\n-\n-      return;\n     }\n-\n-  if (count != NULL)\n-    *count = cnt;\n-  if (count_rate != NULL)\n-    *count_rate = tck;\n-  if (count_max != NULL)\n-    *count_max = mx;\n #endif\n }"}]}