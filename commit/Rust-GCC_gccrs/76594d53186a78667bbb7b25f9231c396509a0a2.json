{"sha": "76594d53186a78667bbb7b25f9231c396509a0a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1OTRkNTMxODZhNzg2NjdiYmI3YjI1ZjkyMzFjMzk2NTA5YTBhMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2011-07-06T23:09:20Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2011-07-06T23:09:20Z"}, "message": "Add -mno-r11 support to PowerPC 64\n\nFrom-SVN: r175943", "tree": {"sha": "d89f83596c90ed466f39e10e56096ebc985f5b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d89f83596c90ed466f39e10e56096ebc985f5b27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76594d53186a78667bbb7b25f9231c396509a0a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76594d53186a78667bbb7b25f9231c396509a0a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76594d53186a78667bbb7b25f9231c396509a0a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76594d53186a78667bbb7b25f9231c396509a0a2/comments", "author": null, "committer": null, "parents": [{"sha": "04543ace474c672b9f95d52e985e41e4e7207200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04543ace474c672b9f95d52e985e41e4e7207200", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04543ace474c672b9f95d52e985e41e4e7207200"}], "stats": {"total": 710, "additions": 463, "deletions": 247}, "files": [{"sha": "c9bcc574ec8cd0b9cc278d56b660f05e217c0688", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -1,3 +1,69 @@\n+2011-07-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_call_indirect_aix): New\n+\tdeclaration.\n+\t(rs6000_save_toc_in_prologue_p): Ditto.\n+\n+\t* config/rs6000/rs6000.opt (-mr11): New switch to disable loading\n+\tup the static chain (r11) during indirect function calls.\n+\t(-msave-toc-indirect): New undocumented debug switch.\n+\n+\t* config/rs6000/rs6000.c (struct machine_function): Add\n+\tsave_toc_in_prologue field to note whether the prologue needs to\n+\tsave the TOC value in the reserved stack location.\n+\t(rs6000_emit_prologue): Use TOC_REGNUM instead of 2.  If we need\n+\tto save the TOC in the prologue, do so.\n+\t(rs6000_trampoline_init): Don't allow creating AIX style\n+\ttrampolines if -mno-r11 is in effect.\n+\t(rs6000_call_indirect_aix): New function to create AIX style\n+\tindirect calls, adding support for -mno-r11 to suppress loading\n+\tthe static chain, and saving the TOC in the prologue instead of\n+\tthe call body.\n+\t(rs6000_save_toc_in_prologue_p): Return true if we are saving the\n+\tTOC in the prologue.\n+\n+\t* config/rs6000/rs6000.md (STACK_POINTER_REGNUM): Add more fixed\n+\tregister numbers.\n+\t(TOC_REGNUM): Ditto.\n+\t(STATIC_CHAIN_REGNUM): Ditto.\n+\t(ARG_POINTER_REGNUM): Ditto.\n+\t(SFP_REGNO): Delete, unused.\n+\t(TOC_SAVE_OFFSET_32BIT): Add constants for AIX TOC save and\n+\tfunction descriptor offsets.\n+\t(TOC_SAVE_OFFSET_64BIT): Ditto.\n+\t(AIX_FUNC_DESC_TOC_32BIT): Ditto.\n+\t(AIX_FUNC_DESC_TOC_64BIT): Ditto.\n+\t(AIX_FUNC_DESC_SC_32BIT): Ditto.\n+\t(AIX_FUNC_DESC_SC_64BIT): Ditto.\n+\t(ptrload): New mode attribute for the appropriate load of a\n+\tpointer.\n+\t(call_indirect_aix32): Delete, rewrite AIX indirect function\n+\tcalls.\n+\t(call_indirect_aix64): Ditto.\n+\t(call_value_indirect_aix32): Ditto.\n+\t(call_value_indirect_aix64): Ditto.\n+\t(call_indirect_nonlocal_aix32_internal): Ditto.\n+\t(call_indirect_nonlocal_aix32): Ditto.\n+\t(call_indirect_nonlocal_aix64_internal): Ditto.\n+\t(call_indirect_nonlocal_aix64): Ditto.\n+\t(call): Rewrite AIX indirect function calls.  Add support for\n+\teliminating the static chain, and for moving the save of the TOC\n+\tto the function prologue.\n+\t(call_value): Ditto.\n+\t(call_indirect_aix<ptrsize>): Ditto.\n+\t(call_indirect_aix<ptrsize>_internal): Ditto.\n+\t(call_indirect_aix<ptrsize>_internal2): Ditto.\n+\t(call_indirect_aix<ptrsize>_nor11): Ditto.\n+\t(call_value_indirect_aix<ptrsize>): Ditto.\n+\t(call_value_indirect_aix<ptrsize>_internal): Ditto.\n+\t(call_value_indirect_aix<ptrsize>_internal2): Ditto.\n+\t(call_value_indirect_aix<ptrsize>_nor11): Ditto.\n+\t(call_nonlocal_aix32): Relocate in the rs6000.md file.\n+\t(call_nonlocal_aix64): Ditto.\n+\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Add -mr11 and\n+\t-mno-r11 documentation.\n+\n 2011-07-06  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR other/49658"}, {"sha": "357f7e720051cadc80102d5e8c10a68172c057b9", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -171,6 +171,8 @@ extern unsigned int rs6000_dbx_register_number (unsigned int);\n extern void rs6000_emit_epilogue (int);\n extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern const char * output_isel (rtx *);\n+extern void rs6000_call_indirect_aix (rtx, rtx, rtx);\n+extern bool rs6000_save_toc_in_prologue_p (void);\n \n extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n "}, {"sha": "65de2e3f2fd422c9cf0799c3200c64320ae1f4de", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 145, "deletions": 4, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -130,6 +130,9 @@ typedef struct GTY(()) machine_function\n   int ra_need_lr;\n   /* Cache lr_save_p after expansion of builtin_eh_return.  */\n   int lr_save_state;\n+  /* Whether we need to save the TOC to the reserved stack location in the\n+     function prologue.  */\n+  bool save_toc_in_prologue;\n   /* Offset from virtual_stack_vars_rtx to the start of the ABI_V4\n      varargs save area.  */\n   HOST_WIDE_INT varargs_save_offset;\n@@ -20325,7 +20328,7 @@ rs6000_emit_prologue (void)\n       JUMP_LABEL (jump) = toc_save_done;\n       LABEL_NUSES (toc_save_done) += 1;\n \n-      emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode, 2,\n+      emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode, TOC_REGNUM,\n \t\t       sp_offset + 5 * reg_size, info->total_size);\n       emit_label (toc_save_done);\n       if (using_static_chain_p)\n@@ -20516,6 +20519,11 @@ rs6000_emit_prologue (void)\n \temit_move_insn (lr, gen_rtx_REG (Pmode, 0));\n     }\n #endif\n+\n+  /* If we need to, save the TOC register after doing the stack setup.  */\n+  if (rs6000_save_toc_in_prologue_p ())\n+    emit_frame_save (sp_reg_rtx, sp_reg_rtx, reg_mode, TOC_REGNUM,\n+\t\t     5 * reg_size, info->total_size);\n }\n \n /* Write function prologue.  */\n@@ -24469,9 +24477,14 @@ rs6000_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n     /* Under AIX, just build the 3 word function descriptor */\n     case ABI_AIX:\n       {\n-\trtx fnmem = gen_const_mem (Pmode, force_reg (Pmode, fnaddr));\n-\trtx fn_reg = gen_reg_rtx (Pmode);\n-\trtx toc_reg = gen_reg_rtx (Pmode);\n+\trtx fnmem, fn_reg, toc_reg;\n+\n+\tif (!TARGET_R11)\n+\t  error (\"-mno-r11 must not be used if you have trampolines\");\n+\n+\tfnmem = gen_const_mem (Pmode, force_reg (Pmode, fnaddr));\n+\tfn_reg = gen_reg_rtx (Pmode);\n+\ttoc_reg = gen_reg_rtx (Pmode);\n \n   /* Macro to shorten the code expansions below.  */\n # define MEM_PLUS(MEM, OFFSET) adjust_address (MEM, Pmode, OFFSET)\n@@ -27760,4 +27773,132 @@ rs6000_legitimate_constant_p (enum machine_mode mode, rtx x)\n \t  || easy_vector_constant (x, mode));\n }\n \n+\f\n+/* A function pointer under AIX is a pointer to a data area whose first word\n+   contains the actual address of the function, whose second word contains a\n+   pointer to its TOC, and whose third word contains a value to place in the\n+   static chain register (r11).  Note that if we load the static chain, our\n+   \"trampoline\" need not have any executable code.  */\n+\n+void\n+rs6000_call_indirect_aix (rtx value, rtx func_desc, rtx flag)\n+{\n+  rtx func_addr;\n+  rtx toc_reg;\n+  rtx sc_reg;\n+  rtx stack_ptr;\n+  rtx stack_toc_offset;\n+  rtx stack_toc_mem;\n+  rtx func_toc_offset;\n+  rtx func_toc_mem;\n+  rtx func_sc_offset;\n+  rtx func_sc_mem;\n+  rtx insn;\n+  rtx (*call_func) (rtx, rtx, rtx, rtx);\n+  rtx (*call_value_func) (rtx, rtx, rtx, rtx, rtx);\n+\n+  stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+  toc_reg = gen_rtx_REG (Pmode, TOC_REGNUM);\n+\n+  /* Load up address of the actual function.  */\n+  func_desc = force_reg (Pmode, func_desc);\n+  func_addr = gen_reg_rtx (Pmode);\n+  emit_move_insn (func_addr, gen_rtx_MEM (Pmode, func_desc));\n+\n+  if (TARGET_32BIT)\n+    {\n+\n+      stack_toc_offset = GEN_INT (TOC_SAVE_OFFSET_32BIT);\n+      func_toc_offset = GEN_INT (AIX_FUNC_DESC_TOC_32BIT);\n+      func_sc_offset = GEN_INT (AIX_FUNC_DESC_SC_32BIT);\n+      if (TARGET_R11)\n+\t{\n+\t  call_func = gen_call_indirect_aix32bit;\n+\t  call_value_func = gen_call_value_indirect_aix32bit;\n+\t}\n+      else\n+\t{\n+\t  call_func = gen_call_indirect_aix32bit_nor11;\n+\t  call_value_func = gen_call_value_indirect_aix32bit_nor11;\n+\t}\n+    }\n+  else\n+    {\n+      stack_toc_offset = GEN_INT (TOC_SAVE_OFFSET_64BIT);\n+      func_toc_offset = GEN_INT (AIX_FUNC_DESC_TOC_64BIT);\n+      func_sc_offset = GEN_INT (AIX_FUNC_DESC_SC_64BIT);\n+      if (TARGET_R11)\n+\t{\n+\t  call_func = gen_call_indirect_aix64bit;\n+\t  call_value_func = gen_call_value_indirect_aix64bit;\n+\t}\n+      else\n+\t{\n+\t  call_func = gen_call_indirect_aix64bit_nor11;\n+\t  call_value_func = gen_call_value_indirect_aix64bit_nor11;\n+\t}\n+    }\n+\n+  /* Reserved spot to store the TOC.  */\n+  stack_toc_mem = gen_frame_mem (Pmode,\n+\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t       stack_ptr,\n+\t\t\t\t\t       stack_toc_offset));\n+\n+  gcc_assert (cfun);\n+  gcc_assert (cfun->machine);\n+\n+  /* Can we optimize saving the TOC in the prologue or do we need to do it at\n+     every call?  */\n+  if (TARGET_SAVE_TOC_INDIRECT && !cfun->calls_alloca\n+      && !cfun->calls_setjmp && !cfun->has_nonlocal_label\n+      && !cfun->can_throw_non_call_exceptions\n+      && ((flags_from_decl_or_type (cfun->decl) & ECF_NOTHROW) == ECF_NOTHROW))\n+    cfun->machine->save_toc_in_prologue = true;\n+\n+  else\n+    {\n+      MEM_VOLATILE_P (stack_toc_mem) = 1;\n+      emit_move_insn (stack_toc_mem, toc_reg);\n+    }\n+\n+  /* Calculate the address to load the TOC of the called function.  We don't\n+     actually load this until the split after reload.  */\n+  func_toc_mem = gen_rtx_MEM (Pmode,\n+\t\t\t      gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t    func_desc,\n+\t\t\t\t\t    func_toc_offset));\n+\n+  /* If we have a static chain, load it up.  */\n+  if (TARGET_R11)\n+    {\n+      func_sc_mem = gen_rtx_MEM (Pmode,\n+\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t       func_desc,\n+\t\t\t\t\t       func_sc_offset));\n+\n+      sc_reg = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+      emit_move_insn (sc_reg, func_sc_mem);\n+    }\n+\n+  /* Create the call.  */\n+  if (value)\n+    insn = call_value_func (value, func_addr, flag, func_toc_mem,\n+\t\t\t    stack_toc_mem);\n+  else\n+    insn = call_func (func_addr, flag, func_toc_mem, stack_toc_mem);\n+\n+  emit_call_insn (insn);\n+  return;\n+}\n+\n+/* Return whether we need to always update the saved TOC pointer when we update\n+   the stack pointer.  */\n+\n+bool\n+rs6000_save_toc_in_prologue_p (void)\n+{\n+  return (cfun && cfun->machine && cfun->machine->save_toc_in_prologue);\n+}\n+\n #include \"gt-rs6000.h\""}, {"sha": "8c0e299a2e76b3b49857a61940d677d5cee51bb5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 182, "deletions": 242, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -27,9 +27,14 @@\n ;;\n \n (define_constants\n-  [(MQ_REGNO\t\t\t64)\n+  [(STACK_POINTER_REGNUM\t1)\n+   (TOC_REGNUM\t\t\t2)\n+   (STATIC_CHAIN_REGNUM\t\t11)\n+   (HARD_FRAME_POINTER_REGNUM\t31)\n+   (MQ_REGNO\t\t\t64)\n    (LR_REGNO\t\t\t65)\n    (CTR_REGNO\t\t\t66)\n+   (ARG_POINTER_REGNUM\t\t67)\n    (CR0_REGNO\t\t\t68)\n    (CR1_REGNO\t\t\t69)\n    (CR2_REGNO\t\t\t70)\n@@ -46,7 +51,19 @@\n    (VSCR_REGNO\t\t\t110)\n    (SPE_ACC_REGNO\t\t111)\n    (SPEFSCR_REGNO\t\t112)\n-   (SFP_REGNO\t\t\t113)\n+   (FRAME_POINTER_REGNUM\t113)\n+\n+   ; ABI defined stack offsets for storing the TOC pointer with AIX calls.\n+   (TOC_SAVE_OFFSET_32BIT\t20)\n+   (TOC_SAVE_OFFSET_64BIT\t40)\n+\n+   ; Function TOC offset in the AIX function descriptor.\n+   (AIX_FUNC_DESC_TOC_32BIT\t4)\n+   (AIX_FUNC_DESC_TOC_64BIT\t8)\n+\n+   ; Static chain offset in the AIX function descriptor.\n+   (AIX_FUNC_DESC_SC_32BIT\t8)\n+   (AIX_FUNC_DESC_SC_64BIT\t16)\n   ])\n \n ;;\n@@ -267,6 +284,9 @@\n (define_mode_attr mptrsize [(SI \"si\")\n \t\t\t    (DI \"di\")])\n \n+(define_mode_attr ptrload [(SI \"{l|lwz}\")\n+\t\t\t   (DI \"ld\")])\n+\n (define_mode_attr rreg [(SF   \"f\")\n \t\t\t(DF   \"ws\")\n \t\t\t(V4SF \"wf\")\n@@ -12178,87 +12198,7 @@\n    \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n    \"{cal %0,%2@l(%1)|addi %0,%1,%2@l}\")\n \f\n-;; A function pointer under AIX is a pointer to a data area whose first word\n-;; contains the actual address of the function, whose second word contains a\n-;; pointer to its TOC, and whose third word contains a value to place in the\n-;; static chain register (r11).  Note that if we load the static chain, our\n-;; \"trampoline\" need not have any executable code.\n-\n-(define_expand \"call_indirect_aix32\"\n-  [(set (match_dup 2)\n-\t(mem:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")))\n-   (set (mem:SI (plus:SI (reg:SI 1) (const_int 20)))\n-\t(reg:SI 2))\n-   (set (reg:SI 11)\n-\t(mem:SI (plus:SI (match_dup 0)\n-\t\t\t (const_int 8))))\n-   (parallel [(call (mem:SI (match_dup 2))\n-\t\t    (match_operand 1 \"\" \"\"))\n-\t      (use (mem:SI (plus:SI (match_dup 0) (const_int 4))))\n-\t      (use (reg:SI 11))\n-\t      (use (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"TARGET_32BIT\"\n-  \"\n-{ operands[2] = gen_reg_rtx (SImode); }\")\n-\n-(define_expand \"call_indirect_aix64\"\n-  [(set (match_dup 2)\n-\t(mem:DI (match_operand:DI 0 \"gpc_reg_operand\" \"\")))\n-   (set (mem:DI (plus:DI (reg:DI 1) (const_int 40)))\n-\t(reg:DI 2))\n-   (set (reg:DI 11)\n-\t(mem:DI (plus:DI (match_dup 0)\n-\t\t\t (const_int 16))))\n-   (parallel [(call (mem:SI (match_dup 2))\n-\t\t    (match_operand 1 \"\" \"\"))\n-\t      (use (mem:DI (plus:DI (match_dup 0) (const_int 8))))\n-\t      (use (reg:DI 11))\n-\t      (use (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"TARGET_64BIT\"\n-  \"\n-{ operands[2] = gen_reg_rtx (DImode); }\")\n-\n-(define_expand \"call_value_indirect_aix32\"\n-  [(set (match_dup 3)\n-\t(mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n-   (set (mem:SI (plus:SI (reg:SI 1) (const_int 20)))\n-\t(reg:SI 2))\n-   (set (reg:SI 11)\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (const_int 8))))\n-   (parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (mem:SI (match_dup 3))\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t      (use (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-\t      (use (reg:SI 11))\n-\t      (use (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"TARGET_32BIT\"\n-  \"\n-{ operands[3] = gen_reg_rtx (SImode); }\")\n-\n-(define_expand \"call_value_indirect_aix64\"\n-  [(set (match_dup 3)\n-\t(mem:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n-   (set (mem:DI (plus:DI (reg:DI 1) (const_int 40)))\n-\t(reg:DI 2))\n-   (set (reg:DI 11)\n-\t(mem:DI (plus:DI (match_dup 1)\n-\t\t\t (const_int 16))))\n-   (parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (mem:SI (match_dup 3))\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t      (use (mem:DI (plus:DI (match_dup 1) (const_int 8))))\n-\t      (use (reg:DI 11))\n-\t      (use (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"TARGET_64BIT\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DImode); }\")\n-\n-;; Now the definitions for the call and call_value insns\n+;; Call and call_value insns\n (define_expand \"call\"\n   [(parallel [(call (mem:SI (match_operand 0 \"address_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n@@ -12294,13 +12234,7 @@\n \tcase ABI_AIX:\n \t  /* AIX function pointers are really pointers to a three word\n \t     area.  */\n-\t  emit_call_insn (TARGET_32BIT\n-\t\t\t  ? gen_call_indirect_aix32 (force_reg (SImode,\n-\t\t\t\t\t\t\t        operands[0]),\n-\t\t\t\t\t\t     operands[1])\n-\t\t\t  : gen_call_indirect_aix64 (force_reg (DImode,\n-\t\t\t\t\t\t\t        operands[0]),\n-\t\t\t\t\t\t     operands[1]));\n+\t  rs6000_call_indirect_aix (NULL_RTX, operands[0], operands[1]);\n \t  DONE;\n \n \tdefault:\n@@ -12345,15 +12279,7 @@\n \tcase ABI_AIX:\n \t  /* AIX function pointers are really pointers to a three word\n \t     area.  */\n-\t  emit_call_insn (TARGET_32BIT\n-\t\t\t  ? gen_call_value_indirect_aix32 (operands[0],\n-\t\t\t\t\t\t\t   force_reg (SImode,\n-\t\t\t\t\t\t\t\t      operands[1]),\n-\t\t\t\t\t\t\t   operands[2])\n-\t\t\t  : gen_call_value_indirect_aix64 (operands[0],\n-\t\t\t\t\t\t\t   force_reg (DImode,\n-\t\t\t\t\t\t\t\t      operands[1]),\n-\t\t\t\t\t\t\t   operands[2]));\n+\t  rs6000_call_indirect_aix (operands[0], operands[1], operands[2]);\n \t  DONE;\n \n \tdefault:\n@@ -12447,149 +12373,202 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n-;; Call to function which may be in another module.  Restore the TOC\n-;; pointer (r2) after the call unless this is System V.\n-;; Operand2 is nonzero if we are using the V.4 calling sequence and\n-;; either the function was not prototyped, or it was prototyped as a\n-;; variable argument function.  It is > 0 if FP registers were passed\n-;; and < 0 if they were not.\n+;; Call to indirect functions with the AIX abi using a 3 word descriptor.\n+;; Operand0 is the addresss of the function to call\n+;; Operand1 is the flag for System V.4 for unprototyped or FP registers\n+;; Operand2 is the location in the function descriptor to load r2 from\n+;; Operand3 is the stack location to hold the current TOC pointer\n \n-(define_insn_and_split \"*call_indirect_nonlocal_aix32_internal\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"c,*l\"))\n-\t\t (match_operand 1 \"\" \"g,g\"))\n-   (use (mem:SI (plus:SI (match_operand:SI 2 \"register_operand\" \"b,b\") (const_int 4))))\n-   (use (reg:SI 11))\n-   (use (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX\"\n+(define_insn_and_split \"call_indirect_aix<ptrsize>\"\n+  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n+\t (match_operand 1 \"\" \"g,g\"))\n+   (use (match_operand:P 2 \"memory_operand\" \"m,m\"))\n+   (use (match_operand:P 3 \"memory_operand\" \"m,m\"))\n+   (use (reg:P STATIC_CHAIN_REGNUM))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_R11\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (reg:SI 2)\n-\t(mem:SI (plus:SI (match_dup 2) (const_int 4))))\n+  [(set (reg:P TOC_REGNUM) (match_dup 2))\n    (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n-\t      (use (reg:SI 2))\n-\t      (use (reg:SI 11))\n-\t      (set (reg:SI 2)\n-\t\t   (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n+\t      (use (reg:P TOC_REGNUM))\n+\t      (use (reg:P STATIC_CHAIN_REGNUM))\n+\t      (use (match_dup 3))\n+\t      (set (reg:P TOC_REGNUM) (match_dup 3))\n+\t      (clobber (reg:P LR_REGNO))])]\n   \"\"\n   [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"12\")])\n \n-(define_insn \"*call_indirect_nonlocal_aix32\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"c,*l\"))\n+(define_insn \"*call_indirect_aix<ptrsize>_internal\"\n+  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n \t (match_operand 1 \"\" \"g,g\"))\n-   (use (reg:SI 2))\n-   (use (reg:SI 11))\n-   (set (reg:SI 2)\n-\t(mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX && reload_completed\"\n-  \"b%T0l\\;{l|lwz} 2,20(1)\"\n+   (use (reg:P TOC_REGNUM))\n+   (use (reg:P STATIC_CHAIN_REGNUM))\n+   (use (match_operand:P 2 \"memory_operand\" \"m,m\"))\n+   (set (reg:P TOC_REGNUM) (match_dup 2))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && reload_completed && TARGET_R11\"\n+  \"b%T0l\\;<ptrload> 2,%2\"\n   [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"*call_nonlocal_aix32\"\n-  [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"s\"))\n-\t (match_operand 1 \"\" \"g\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_32BIT\n-   && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"bl %z0\\;%.\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n-   \n-(define_insn_and_split \"*call_indirect_nonlocal_aix64_internal\"\n-  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"c,*l\"))\n-\t\t (match_operand 1 \"\" \"g,g\"))\n-   (use (mem:DI (plus:DI (match_operand:DI 2 \"register_operand\" \"b,b\")\n-\t\t\t (const_int 8))))\n-   (use (reg:DI 11))\n-   (use (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\"\n+;; Like call_indirect_aix<ptrsize>, except don't load the static chain\n+;; Operand0 is the addresss of the function to call\n+;; Operand1 is the flag for System V.4 for unprototyped or FP registers\n+;; Operand2 is the location in the function descriptor to load r2 from\n+;; Operand3 is the stack location to hold the current TOC pointer\n+\n+(define_insn_and_split \"call_indirect_aix<ptrsize>_nor11\"\n+  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n+\t (match_operand 1 \"\" \"g,g\"))\n+   (use (match_operand:P 2 \"memory_operand\" \"m,m\"))\n+   (use (match_operand:P 3 \"memory_operand\" \"m,m\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && !TARGET_R11\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (reg:DI 2)\n-\t(mem:DI (plus:DI (match_dup 2) (const_int 8))))\n+  [(set (reg:P TOC_REGNUM) (match_dup 2))\n    (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n-\t      (use (reg:DI 2))\n-\t      (use (reg:DI 11))\n-\t      (set (reg:DI 2)\n-\t\t   (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n+\t      (use (reg:P TOC_REGNUM))\n+\t      (use (match_dup 3))\n+\t      (set (reg:P TOC_REGNUM) (match_dup 3))\n+\t      (clobber (reg:P LR_REGNO))])]\n   \"\"\n   [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"12\")])\n \n-(define_insn \"*call_indirect_nonlocal_aix64\"\n-  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"c,*l\"))\n+(define_insn \"*call_indirect_aix<ptrsize>_internal2\"\n+  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n \t (match_operand 1 \"\" \"g,g\"))\n-   (use (reg:DI 2))\n-   (use (reg:DI 11))\n-   (set (reg:DI 2)\n-\t(mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX && reload_completed\"\n-  \"b%T0l\\;ld 2,40(1)\"\n+   (use (reg:P TOC_REGNUM))\n+   (use (match_operand:P 2 \"memory_operand\" \"m,m\"))\n+   (set (reg:P TOC_REGNUM) (match_dup 2))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && reload_completed && !TARGET_R11\"\n+  \"b%T0l\\;<ptrload> 2,%2\"\n   [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"*call_nonlocal_aix64\"\n-  [(call (mem:SI (match_operand:DI 0 \"symbol_ref_operand\" \"s\"))\n-\t (match_operand 1 \"\" \"g\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_64BIT\n-   && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"bl %z0\\;%.\"\n-  [(set_attr \"type\" \"branch\")\n+;; Operand0 is the return result of the function\n+;; Operand1 is the addresss of the function to call\n+;; Operand2 is the flag for System V.4 for unprototyped or FP registers\n+;; Operand3 is the location in the function descriptor to load r2 from\n+;; Operand4 is the stack location to hold the current TOC pointer\n+\n+(define_insn_and_split \"call_value_indirect_aix<ptrsize>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (use (match_operand:P 3 \"memory_operand\" \"m,m\"))\n+   (use (match_operand:P 4 \"memory_operand\" \"m,m\"))\n+   (use (reg:P STATIC_CHAIN_REGNUM))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_R11\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:P TOC_REGNUM) (match_dup 3))\n+   (parallel [(set (match_dup 0)\n+\t\t   (call (mem:SI (match_dup 1))\n+\t\t\t (match_dup 2)))\n+\t      (use (reg:P TOC_REGNUM))\n+\t      (use (reg:P STATIC_CHAIN_REGNUM))\n+\t      (use (match_dup 4))\n+\t      (set (reg:P TOC_REGNUM) (match_dup 4))\n+\t      (clobber (reg:P LR_REGNO))])]\n+  \"\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"12\")])\n+\n+(define_insn \"*call_value_indirect_aix<ptrsize>_internal\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (use (reg:P TOC_REGNUM))\n+   (use (reg:P STATIC_CHAIN_REGNUM))\n+   (use (match_operand:P 3 \"memory_operand\" \"m,m\"))\n+   (set (reg:P TOC_REGNUM) (match_dup 3))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && reload_completed && TARGET_R11\"\n+  \"b%T1l\\;<ptrload> 2,%3\"\n+  [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"*call_value_indirect_nonlocal_aix32_internal\"\n+;; Like call_value_indirect_aix<ptrsize>, but don't load the static chain\n+;; Operand0 is the return result of the function\n+;; Operand1 is the addresss of the function to call\n+;; Operand2 is the flag for System V.4 for unprototyped or FP registers\n+;; Operand3 is the location in the function descriptor to load r2 from\n+;; Operand4 is the stack location to hold the current TOC pointer\n+\n+(define_insn_and_split \"call_value_indirect_aix<ptrsize>_nor11\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"c,*l\"))\n-\t\t      (match_operand 2 \"\" \"g,g\")))\n-\t(use (mem:SI (plus:SI (match_operand:SI 3 \"register_operand\" \"b,b\")\n-\t\t\t      (const_int 4))))\n-\t(use (reg:SI 11))\n-\t(use (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-\t(clobber (reg:SI LR_REGNO))]\n-  \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX\"\n+\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (use (match_operand:P 3 \"memory_operand\" \"m,m\"))\n+   (use (match_operand:P 4 \"memory_operand\" \"m,m\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && !TARGET_R11\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (reg:SI 2)\n-\t(mem:SI (plus:SI (match_dup 3) (const_int 4))))\n-   (parallel [(set (match_dup 0) (call (mem:SI (match_dup 1))\n-\t\t\t\t       (match_dup 2)))\n-\t      (use (reg:SI 2))\n-\t      (use (reg:SI 11))\n-\t      (set (reg:SI 2)\n-\t\t   (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n+  [(set (reg:P TOC_REGNUM) (match_dup 3))\n+   (parallel [(set (match_dup 0)\n+\t\t   (call (mem:SI (match_dup 1))\n+\t\t\t (match_dup 2)))\n+\t      (use (reg:P TOC_REGNUM))\n+\t      (use (match_dup 4))\n+\t      (set (reg:P TOC_REGNUM) (match_dup 4))\n+\t      (clobber (reg:P LR_REGNO))])]\n   \"\"\n   [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"12\")])\n \n-(define_insn \"*call_value_indirect_nonlocal_aix32\"\n+(define_insn \"*call_value_indirect_aix<ptrsize>_internal2\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"c,*l\"))\n+\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n-   (use (reg:SI 2))\n-   (use (reg:SI 11))\n-   (set (reg:SI 2)\n-\t(mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX && reload_completed\"\n-  \"b%T1l\\;{l|lwz} 2,20(1)\"\n+   (use (reg:P TOC_REGNUM))\n+   (use (match_operand:P 3 \"memory_operand\" \"m,m\"))\n+   (set (reg:P TOC_REGNUM) (match_dup 3))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_AIX && reload_completed && !TARGET_R11\"\n+  \"b%T1l\\;<ptrload> 2,%3\"\n   [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"8\")])\n \n+;; Call to function which may be in another module.  Restore the TOC\n+;; pointer (r2) after the call unless this is System V.\n+;; Operand2 is nonzero if we are using the V.4 calling sequence and\n+;; either the function was not prototyped, or it was prototyped as a\n+;; variable argument function.  It is > 0 if FP registers were passed\n+;; and < 0 if they were not.\n+\n+(define_insn \"*call_nonlocal_aix32\"\n+  [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n+   (clobber (reg:SI LR_REGNO))]\n+  \"TARGET_32BIT\n+   && DEFAULT_ABI == ABI_AIX\n+   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n+  \"bl %z0\\;%.\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8\")])\n+   \n+(define_insn \"*call_nonlocal_aix64\"\n+  [(call (mem:SI (match_operand:DI 0 \"symbol_ref_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n+   (clobber (reg:SI LR_REGNO))]\n+  \"TARGET_64BIT\n+   && DEFAULT_ABI == ABI_AIX\n+   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n+  \"bl %z0\\;%.\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"*call_value_nonlocal_aix32\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"s\"))\n@@ -12603,45 +12582,6 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"*call_value_indirect_nonlocal_aix64_internal\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"c,*l\"))\n-\t\t      (match_operand 2 \"\" \"g,g\")))\n-\t(use (mem:DI (plus:DI (match_operand:DI 3 \"register_operand\" \"b,b\")\n-\t\t\t      (const_int 8))))\n-\t(use (reg:DI 11))\n-\t(use (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-\t(clobber (reg:SI LR_REGNO))]\n-  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (reg:DI 2)\n-\t(mem:DI (plus:DI (match_dup 3) (const_int 8))))\n-   (parallel [(set (match_dup 0) (call (mem:SI (match_dup 1))\n-\t\t\t\t       (match_dup 2)))\n-\t      (use (reg:DI 2))\n-\t      (use (reg:DI 11))\n-\t      (set (reg:DI 2)\n-\t\t   (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"*call_value_indirect_nonlocal_aix64\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"c,*l\"))\n-\t      (match_operand 2 \"\" \"g,g\")))\n-   (use (reg:DI 2))\n-   (use (reg:DI 11))\n-   (set (reg:DI 2)\n-\t(mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-   (clobber (reg:SI LR_REGNO))]\n-  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX && reload_completed\"\n-  \"b%T1l\\;ld 2,40(1)\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"*call_value_nonlocal_aix64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:DI 1 \"symbol_ref_operand\" \"s\"))"}, {"sha": "329104c441c1da90a05a5b5d564b6b24c56a1f28", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -521,4 +521,10 @@ mxilinx-fpu\n Target Var(rs6000_xilinx_fpu) Save\n Specify Xilinx FPU.\n \n+mr11\n+Target Report Var(TARGET_R11) Init(1) Save\n+Use/do not use r11 to hold the static link in calls.\n \n+msave-toc-indirect\n+Target Undocumented Var(TARGET_SAVE_TOC_INDIRECT) Save Init(1)\n+; Control whether we save the TOC in the prologue for indirect calls or generate the save inline"}, {"sha": "223a9d525ab087eb9bc80730f2a3109a5c2f2dcb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -807,7 +807,7 @@ See RS/6000 and PowerPC Options.\n -msdata=@var{opt}  -mvxworks  -G @var{num}  -pthread @gol\n -mrecip -mrecip=@var{opt} -mno-recip -mrecip-precision @gol\n -mno-recip-precision @gol\n--mveclibabi=@var{type} -mfriz -mno-friz}\n+-mveclibabi=@var{type} -mfriz -mno-friz -mr11 -mno-r11}\n \n @emph{RX Options}\n @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n@@ -16325,6 +16325,19 @@ Generate (do not generate) the @code{friz} instruction when the\n rounding a floating point value to 64-bit integer and back to floating\n point.  The @code{friz} instruction does not return the same value if\n the floating point number is too large to fit in an integer.\n+\n+@item -mr11\n+@itemx -mno-r11\n+@opindex mr11\n+Generate (do not generate) code to load up the static chain register\n+(@var{r11}) when calling through a pointer on AIX and 64-bit Linux\n+systems where a function pointer points to a 3 word descriptor giving\n+the function address, TOC value to be loaded in register @var{r2}, and\n+static chain value to be loaded in register @var{r11}.  The\n+@option{-mr11} is on by default.  You will not be able to call through\n+pointers to nested functions or pointers to functions compiled in\n+other languages that use the static chain if you use the\n+@option{-mno-r11}.\n @end table\n \n @node RX Options"}, {"sha": "f176a448cb50947ce19f36b54de8fd7b24ebe6c0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -1,3 +1,9 @@\n+2011-07-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/no-r11-1.c: New test for -mr11, -mno-r11.\n+\t* gcc.target/powerpc/no-r11-2.c: Ditto.\n+\t* gcc.target/powerpc/no-r11-3.c: Ditto.\n+\n 2011-07-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/stack-layout-2.c: Cleanup expand rtl dump."}, {"sha": "7e880e7d861a364fbfc58ccb2cde8f78fbb24852", "filename": "gcc/testsuite/gcc.target/powerpc/no-r11-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-1.c?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { *-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mno-r11\" } */\n+\n+int\n+call_ptr (int (func) (void))\n+{\n+  return func () + 1;\n+}\n+\n+/* { dg-final { scan-assembler-not \"ld 11,16(3)\" } } */"}, {"sha": "981bc0c954c07bbb447d17f4d8ba6c15ed777205", "filename": "gcc/testsuite/gcc.target/powerpc/no-r11-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-2.c?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { *-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mr11\" } */\n+\n+int\n+call_ptr (int (func) (void))\n+{\n+  return func () + 1;\n+}\n+\n+/* { dg-final { scan-assembler \"ld 11,16\" } } */"}, {"sha": "bc57385ca4efb2f26ff5795d55de35ebfceab430", "filename": "gcc/testsuite/gcc.target/powerpc/no-r11-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76594d53186a78667bbb7b25f9231c396509a0a2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-3.c?ref=76594d53186a78667bbb7b25f9231c396509a0a2", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { *-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mno-r11\" } */\n+\n+extern void ext_call (int (func) (void));\n+\n+int\n+outer_func (int init)\t/* { dg-error \"-mno-r11 must not be used if you have trampolines\" \"\" } */\n+{\n+  int value = init;\n+\n+  int inner (void)\n+  {\n+    return ++value;\n+  }\n+\n+  ext_call (inner);\n+  return value;\n+}\n+"}]}