{"sha": "63fc39600ce2640e9c4d07e00e162c2529b1820a", "node_id": "C_kwDOANBUbNoAKDYzZmMzOTYwMGNlMjY0MGU5YzRkMDdlMDBlMTYyYzI1MjliMTgyMGE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-17T21:22:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-17T21:22:20Z"}, "message": "Merge #805\n\n805: Remove Btype, Bexpression, etc. abstractions over gcc trees r=CohenArthur a=dafaust\n\nAs discussed in #412, the Rust front end inherits an abstraction over gcc from the initial bootstrap via GCCGO. \r\nThis is a cool idea, but adds overhead for the primary goal of gcc compiling Rust. It's not clear that the benefits of maintaining the abstraction are worth the potential extra headaches of maintaining it.\r\n\r\nI figured for the sake of discussion, I'd draft an initial step towards removing this abstraction. \r\n\r\nThe implementations of classes `Bytpe`, `Bexpression`, `Bstatement`, `Bfunction`, and `Bblock` are only wrappers around gcc's GENERIC `tree` structure, with no added functionality. This PR removes them, and changes all the functions for creating and manipulating these abstract types to just use/return `tree` instead. I also deleted a few functions that are vestiges from GCCGO port and aren't used.\r\n\r\nPersonally, I think the abstraction should be removed in favor of using `tree`s. This is more in line with the other gcc front ends and makes the interface between the frontend and the rest of gcc simpler.\r\n\r\nI'm curious to hear other opinions on the matter :)\r\n\r\nAddresses: #412 \r\n\r\n\n\nCo-authored-by: David Faust <david.faust@oracle.com>", "tree": {"sha": "7bd431f6cd496e67e3ac8947f975a636093a1485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bd431f6cd496e67e3ac8947f975a636093a1485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63fc39600ce2640e9c4d07e00e162c2529b1820a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhlXKMCRBK7hj4Ov3rIwAA7zcIAAIEhWUIbLa38eN6LqQDTJ1i\nd80d7rUdHQHqM9r3h2W3KziMALnpJe2JRP8xKS0GKGoUum6sKx3qlyadNLTFurjx\nt4q5Er2luVUPM1PjH3vth56/IcP/QwLMJCx7rGqI4IJ0aRLB1VP2CmN1ic+4/T9T\n5EhflgvdwYlNpFYsp7pvmUyaVeg4ARJaEumbnP8Mo9dqWKNPm7xhrXPqxQKlcb6y\nCjDdq2m7O/1gBipIHMbgjbK7xAGH42IdyuDME1serX2zKymRV8QRBMV2O/5n9oaR\nxNl9uqCPx+McuNFCldpapQIGw1xKs/UgZ14fhgMB7SZrv8Y92rzD4ZKJtpiTYuw=\n=mYaZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 7bd431f6cd496e67e3ac8947f975a636093a1485\nparent 5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3\nparent 5c87e61f96e0b394ce406bf9967c92708a16becc\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637184140 +0000\ncommitter GitHub <noreply@github.com> 1637184140 +0000\n\nMerge #805\n\n805: Remove Btype, Bexpression, etc. abstractions over gcc trees r=CohenArthur a=dafaust\n\nAs discussed in #412, the Rust front end inherits an abstraction over gcc from the initial bootstrap via GCCGO. \r\nThis is a cool idea, but adds overhead for the primary goal of gcc compiling Rust. It's not clear that the benefits of maintaining the abstraction are worth the potential extra headaches of maintaining it.\r\n\r\nI figured for the sake of discussion, I'd draft an initial step towards removing this abstraction. \r\n\r\nThe implementations of classes `Bytpe`, `Bexpression`, `Bstatement`, `Bfunction`, and `Bblock` are only wrappers around gcc's GENERIC `tree` structure, with no added functionality. This PR removes them, and changes all the functions for creating and manipulating these abstract types to just use/return `tree` instead. I also deleted a few functions that are vestiges from GCCGO port and aren't used.\r\n\r\nPersonally, I think the abstraction should be removed in favor of using `tree`s. This is more in line with the other gcc front ends and makes the interface between the frontend and the rest of gcc simpler.\r\n\r\nI'm curious to hear other opinions on the matter :)\r\n\r\nAddresses: #412 \r\n\r\n\n\nCo-authored-by: David Faust <david.faust@oracle.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fc39600ce2640e9c4d07e00e162c2529b1820a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63fc39600ce2640e9c4d07e00e162c2529b1820a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fc39600ce2640e9c4d07e00e162c2529b1820a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3"}, {"sha": "5c87e61f96e0b394ce406bf9967c92708a16becc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c87e61f96e0b394ce406bf9967c92708a16becc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c87e61f96e0b394ce406bf9967c92708a16becc"}], "stats": {"total": 2752, "additions": 1088, "deletions": 1664}, "files": [{"sha": "af0ea408ccdf0cd69ceb059405d6f06ac8449222", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -193,23 +193,21 @@ class HIRCompileBase : public HIR::HIRVisitor\n \n   Context *get_context () { return ctx; }\n \n-  void compile_function_body (Bfunction *fndecl,\n+  void compile_function_body (tree fndecl,\n \t\t\t      std::unique_ptr<HIR::BlockExpr> &function_body,\n \t\t\t      bool has_return_type);\n \n-  bool compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+  bool compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n \t\t\t\t std::vector<Bvariable *> &locals);\n \n-  Bexpression *coercion_site (Bexpression *compiled_ref, TyTy::BaseType *actual,\n-\t\t\t      TyTy::BaseType *expected, Location locus);\n+  tree coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n+\t\t      TyTy::BaseType *expected, Location locus);\n \n-  Bexpression *coerce_to_dyn_object (Bexpression *compiled_ref,\n-\t\t\t\t     const TyTy::BaseType *actual,\n-\t\t\t\t     const TyTy::BaseType *expected,\n-\t\t\t\t     const TyTy::DynamicObjectType *ty,\n-\t\t\t\t     Location locus);\n+  tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,\n+\t\t\t     const TyTy::BaseType *expected,\n+\t\t\t     const TyTy::DynamicObjectType *ty, Location locus);\n \n-  Bexpression *compute_address_for_trait_item (\n+  tree compute_address_for_trait_item (\n     const Resolver::TraitItemReference *ref,\n     const TyTy::TypeBoundPredicate *predicate,\n     std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>"}, {"sha": "af90671da01dc2d17cab77369e9eec52b80cc108", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -30,7 +30,7 @@ class CompileBlock : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bblock *compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n+  static tree compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n   {\n     CompileBlock compiler (ctx, result);\n     expr->accept_vis (compiler);\n@@ -44,7 +44,7 @@ class CompileBlock : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bblock *translated;\n+  tree translated;\n   Bvariable *result;\n };\n \n@@ -53,8 +53,7 @@ class CompileConditionalBlocks : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx,\n-\t\t\t      Bvariable *result)\n+  static tree compile (HIR::IfExpr *expr, Context *ctx, Bvariable *result)\n   {\n     CompileConditionalBlocks resolver (ctx, result);\n     expr->accept_vis (resolver);\n@@ -72,7 +71,7 @@ class CompileConditionalBlocks : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bstatement *translated;\n+  tree translated;\n   Bvariable *result;\n };\n \n@@ -81,8 +80,8 @@ class CompileExprWithBlock : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx,\n-\t\t\t      Bvariable *result)\n+  static tree compile (HIR::ExprWithBlock *expr, Context *ctx,\n+\t\t       Bvariable *result)\n   {\n     CompileExprWithBlock resolver (ctx, result);\n     expr->accept_vis (resolver);\n@@ -109,7 +108,7 @@ class CompileExprWithBlock : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bstatement *translated;\n+  tree translated;\n   Bvariable *result;\n };\n "}, {"sha": "668e8ba8f52c14275887dd224905c8d193c11d7e", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 92, "deletions": 99, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -35,7 +35,7 @@ namespace Compile {\n \n struct fncontext\n {\n-  ::Bfunction *fndecl;\n+  tree fndecl;\n   ::Bvariable *ret_addr;\n };\n \n@@ -60,20 +60,20 @@ class Context\n \tok = tyctx->lookup_type (ref, &lookup);\n \trust_assert (ok);\n \n-\tBtype *compiled = TyTyCompile::compile (backend, lookup);\n-\tcompiled_type_map.insert (std::pair<HirId, Btype *> (ref, compiled));\n+\ttree compiled = TyTyCompile::compile (backend, lookup);\n+\tcompiled_type_map.insert (std::pair<HirId, tree> (ref, compiled));\n \tbuiltin_range.insert (ref);\n       }\n   }\n \n-  bool lookup_compiled_types (HirId id, ::Btype **type,\n+  bool lookup_compiled_types (HirId id, tree *type,\n \t\t\t      const TyTy::BaseType *ref = nullptr)\n   {\n     if (ref != nullptr)\n       {\n \tfor (auto it = mono.begin (); it != mono.end (); it++)\n \t  {\n-\t    std::pair<HirId, ::Btype *> &val = it->second;\n+\t    std::pair<HirId, tree> &val = it->second;\n \t    const TyTy::BaseType *r = it->first;\n \n \t    if (ref->is_equal (*r))\n@@ -94,14 +94,14 @@ class Context\n     return true;\n   }\n \n-  void insert_compiled_type (HirId id, ::Btype *type,\n+  void insert_compiled_type (HirId id, tree type,\n \t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     rust_assert (builtin_range.find (id) == builtin_range.end ());\n-    compiled_type_map.insert (std::pair<HirId, Btype *> (id, type));\n+    compiled_type_map.insert (std::pair<HirId, tree> (id, type));\n     if (ref != nullptr)\n       {\n-\tstd::pair<HirId, ::Btype *> elem (id, type);\n+\tstd::pair<HirId, tree> elem (id, type);\n \tmono[ref] = std::move (elem);\n       }\n   }\n@@ -112,13 +112,13 @@ class Context\n   Analysis::Mappings *get_mappings () { return mappings; }\n   ConstFold::Context *get_const_ctx () { return const_ctx; }\n \n-  void push_block (Bblock *scope)\n+  void push_block (tree scope)\n   {\n     scope_stack.push_back (scope);\n     statements.push_back ({});\n   }\n \n-  Bblock *pop_block ()\n+  tree pop_block ()\n   {\n     auto block = scope_stack.back ();\n     scope_stack.pop_back ();\n@@ -131,20 +131,20 @@ class Context\n     return block;\n   }\n \n-  Bblock *peek_enclosing_scope ()\n+  tree peek_enclosing_scope ()\n   {\n     if (scope_stack.size () == 0)\n       return nullptr;\n \n     return scope_stack.back ();\n   }\n \n-  void add_statement_to_enclosing_scope (Bstatement *stmt)\n+  void add_statement_to_enclosing_scope (tree stmt)\n   {\n     statements.at (statements.size () - 2).push_back (stmt);\n   }\n \n-  void add_statement (Bstatement *stmt) { statements.back ().push_back (stmt); }\n+  void add_statement (tree stmt) { statements.back ().push_back (stmt); }\n \n   void insert_var_decl (HirId id, ::Bvariable *decl)\n   {\n@@ -161,7 +161,7 @@ class Context\n     return true;\n   }\n \n-  void insert_function_decl (const TyTy::FnType *ref, ::Bfunction *fn)\n+  void insert_function_decl (const TyTy::FnType *ref, tree fn)\n   {\n     auto id = ref->get_ty_ref ();\n     auto dId = ref->get_id ();\n@@ -176,8 +176,7 @@ class Context\n     mono_fns[dId].push_back ({ref, fn});\n   }\n \n-  bool lookup_function_decl (HirId id, ::Bfunction **fn,\n-\t\t\t     DefId dId = UNKNOWN_DEFID,\n+  bool lookup_function_decl (HirId id, tree *fn, DefId dId = UNKNOWN_DEFID,\n \t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     // for for any monomorphized fns\n@@ -192,7 +191,7 @@ class Context\n \tfor (auto &e : mono_fns[dId])\n \t  {\n \t    const TyTy::BaseType *r = e.first;\n-\t    ::Bfunction *f = e.second;\n+\t    tree f = e.second;\n \t    if (ref->is_equal (*r))\n \t      {\n \t\t*fn = f;\n@@ -210,12 +209,9 @@ class Context\n     return true;\n   }\n \n-  void insert_const_decl (HirId id, ::Bexpression *expr)\n-  {\n-    compiled_consts[id] = expr;\n-  }\n+  void insert_const_decl (HirId id, tree expr) { compiled_consts[id] = expr; }\n \n-  bool lookup_const_decl (HirId id, ::Bexpression **expr)\n+  bool lookup_const_decl (HirId id, tree *expr)\n   {\n     auto it = compiled_consts.find (id);\n     if (it == compiled_consts.end ())\n@@ -225,12 +221,9 @@ class Context\n     return true;\n   }\n \n-  void insert_label_decl (HirId id, ::Blabel *label)\n-  {\n-    compiled_labels[id] = label;\n-  }\n+  void insert_label_decl (HirId id, tree label) { compiled_labels[id] = label; }\n \n-  bool lookup_label_decl (HirId id, ::Blabel **label)\n+  bool lookup_label_decl (HirId id, tree *label)\n   {\n     auto it = compiled_labels.find (id);\n     if (it == compiled_labels.end ())\n@@ -240,29 +233,29 @@ class Context\n     return true;\n   }\n \n-  void push_fn (::Bfunction *fn, ::Bvariable *ret_addr)\n+  void push_fn (tree fn, ::Bvariable *ret_addr)\n   {\n     fn_stack.push_back (fncontext{fn, ret_addr});\n   }\n   void pop_fn () { fn_stack.pop_back (); }\n   fncontext peek_fn () { return fn_stack.back (); }\n \n-  void push_type (::Btype *t) { type_decls.push_back (t); }\n+  void push_type (tree t) { type_decls.push_back (t); }\n   void push_var (::Bvariable *v) { var_decls.push_back (v); }\n-  void push_const (::Bexpression *c) { const_decls.push_back (c); }\n-  void push_function (::Bfunction *f) { func_decls.push_back (f); }\n+  void push_const (tree c) { const_decls.push_back (c); }\n+  void push_function (tree f) { func_decls.push_back (f); }\n \n   void write_to_backend ()\n   {\n     backend->write_global_definitions (type_decls, const_decls, func_decls,\n \t\t\t\t       var_decls);\n   }\n \n-  bool function_completed (Bfunction *fn)\n+  bool function_completed (tree fn)\n   {\n     for (auto it = func_decls.begin (); it != func_decls.end (); it++)\n       {\n-\tBfunction *i = (*it);\n+\ttree i = (*it);\n \tif (i == fn)\n \t  {\n \t    return true;\n@@ -282,16 +275,16 @@ class Context\n     return back;\n   }\n \n-  void push_loop_begin_label (Blabel *label)\n+  void push_loop_begin_label (tree label)\n   {\n     loop_begin_labels.push_back (label);\n   }\n \n-  Blabel *peek_loop_begin_label () { return loop_begin_labels.back (); }\n+  tree peek_loop_begin_label () { return loop_begin_labels.back (); }\n \n-  Blabel *pop_loop_begin_label ()\n+  tree pop_loop_begin_label ()\n   {\n-    Blabel *pop = loop_begin_labels.back ();\n+    tree pop = loop_begin_labels.back ();\n     loop_begin_labels.pop_back ();\n     return pop;\n   }\n@@ -322,30 +315,30 @@ class Context\n   // state\n   std::vector<fncontext> fn_stack;\n   std::map<HirId, ::Bvariable *> compiled_var_decls;\n-  std::map<HirId, ::Btype *> compiled_type_map;\n-  std::map<HirId, ::Bfunction *> compiled_fn_map;\n-  std::map<HirId, ::Bexpression *> compiled_consts;\n-  std::map<HirId, ::Blabel *> compiled_labels;\n-  std::vector<::std::vector<Bstatement *>> statements;\n-  std::vector<::Bblock *> scope_stack;\n+  std::map<HirId, tree> compiled_type_map;\n+  std::map<HirId, tree> compiled_fn_map;\n+  std::map<HirId, tree> compiled_consts;\n+  std::map<HirId, tree> compiled_labels;\n+  std::vector<::std::vector<tree>> statements;\n+  std::vector<tree> scope_stack;\n   std::vector<::Bvariable *> loop_value_stack;\n-  std::vector<::Blabel *> loop_begin_labels;\n-  std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *>> mono;\n-  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, ::Bfunction *>>>\n+  std::vector<tree> loop_begin_labels;\n+  std::map<const TyTy::BaseType *, std::pair<HirId, tree>> mono;\n+  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n \n   // To GCC middle-end\n-  std::vector<::Btype *> type_decls;\n+  std::vector<tree> type_decls;\n   std::vector<::Bvariable *> var_decls;\n-  std::vector<::Bexpression *> const_decls;\n-  std::vector<::Bfunction *> func_decls;\n+  std::vector<tree> const_decls;\n+  std::vector<tree> func_decls;\n };\n \n class TyTyResolveCompile : public TyTy::TyConstVisitor\n {\n public:\n-  static ::Btype *compile (Context *ctx, const TyTy::BaseType *ty,\n-\t\t\t   bool trait_object_mode = false)\n+  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n+\t\t       bool trait_object_mode = false)\n   {\n     TyTyResolveCompile compiler (ctx, trait_object_mode);\n     ty->accept_vis (compiler);\n@@ -375,16 +368,16 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::FnType &type) override\n   {\n-    Backend::Btyped_identifier receiver;\n-    std::vector<Backend::Btyped_identifier> parameters;\n-    std::vector<Backend::Btyped_identifier> results;\n+    Backend::typed_identifier receiver;\n+    std::vector<Backend::typed_identifier> parameters;\n+    std::vector<Backend::typed_identifier> results;\n \n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n \tauto ret\n \t  = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n-\tresults.push_back (Backend::Btyped_identifier (\n+\tresults.push_back (Backend::typed_identifier (\n \t  \"_\", ret,\n \t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n       }\n@@ -395,7 +388,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \tauto compiled_param_type\n \t  = TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n \n-\tauto compiled_param = Backend::Btyped_identifier (\n+\tauto compiled_param = Backend::typed_identifier (\n \t  param_pair.first->as_string (), compiled_param_type,\n \t  ctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n \n@@ -414,12 +407,12 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::FnPtr &type) override\n   {\n-    Btype *result_type\n+    tree result_type\n       = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n \n-    std::vector<Btype *> parameters;\n+    std::vector<tree> parameters;\n     type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n-      Btype *pty = TyTyResolveCompile::compile (ctx, p);\n+      tree pty = TyTyResolveCompile::compile (ctx, p);\n       parameters.push_back (pty);\n       return true;\n     });\n@@ -439,25 +432,25 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n     rust_assert (type.number_of_variants () == 1);\n \n     TyTy::VariantDef &variant = *type.get_variants ().at (0);\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n     for (size_t i = 0; i < variant.num_fields (); i++)\n       {\n \tconst TyTy::StructFieldType *field = variant.get_field_at_index (i);\n-\tBtype *compiled_field_ty\n+\ttree compiled_field_ty\n \t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n \n-\tBackend::Btyped_identifier f (field->get_name (), compiled_field_ty,\n-\t\t\t\t      ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\ttype.get_ty_ref ()));\n+\tBackend::typed_identifier f (field->get_name (), compiled_field_ty,\n+\t\t\t\t     ctx->get_mappings ()->lookup_location (\n+\t\t\t\t       type.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *type_record;\n+    tree type_record;\n     if (type.is_union ())\n       type_record = ctx->get_backend ()->union_type (fields);\n     else\n       type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -482,27 +475,27 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n       return;\n \n     // create implicit struct\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n     for (size_t i = 0; i < type.num_fields (); i++)\n       {\n \tTyTy::BaseType *field = type.get_field (i);\n-\tBtype *compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n+\ttree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n \n \t// rustc uses the convention __N, where N is an integer, to\n \t// name the fields of a tuple.  We follow this as well,\n \t// because this is used by GDB.  One further reason to prefer\n \t// this, rather than simply emitting the integer, is that this\n \t// approach makes it simpler to use a C-only debugger, or\n \t// GDB's C mode, when debugging Rust.\n-\tBackend::Btyped_identifier f (\"__\" + std::to_string (i),\n-\t\t\t\t      compiled_field_ty,\n-\t\t\t\t      ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\ttype.get_ty_ref ()));\n+\tBackend::typed_identifier f (\"__\" + std::to_string (i),\n+\t\t\t\t     compiled_field_ty,\n+\t\t\t\t     ctx->get_mappings ()->lookup_location (\n+\t\t\t\t       type.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -514,71 +507,71 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::ArrayType &type) override\n   {\n-    Btype *element_type\n+    tree element_type\n       = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n     translated\n       = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n   }\n \n   void visit (const TyTy::BoolType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::IntType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::UintType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::FloatType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::USizeType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::ISizeType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::CharType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::ReferenceType &type) override\n   {\n-    Btype *base_compiled_type\n+    tree base_compiled_type\n       = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n@@ -593,7 +586,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::PointerType &type) override\n   {\n-    Btype *base_compiled_type\n+    tree base_compiled_type\n       = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n@@ -608,7 +601,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::StrType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n@@ -633,32 +626,32 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n     // create implicit struct\n     auto items = type.get_object_items ();\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n \n-    Btype *uint = ctx->get_backend ()->integer_type (\n+    tree uint = ctx->get_backend ()->integer_type (\n       true, ctx->get_backend ()->get_pointer_size ());\n-    Btype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+    tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n \n-    Backend::Btyped_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n-\t\t\t\t  ctx->get_mappings ()->lookup_location (\n-\t\t\t\t    type.get_ty_ref ()));\n+    Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t   type.get_ty_ref ()));\n     fields.push_back (std::move (f));\n \n     for (size_t i = 0; i < items.size (); i++)\n       {\n \t// mrustc seems to make a vtable consisting of uintptr's\n-\tBtype *uint = ctx->get_backend ()->integer_type (\n+\ttree uint = ctx->get_backend ()->integer_type (\n \t  true, ctx->get_backend ()->get_pointer_size ());\n-\tBtype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\ttree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n \n-\tBackend::Btyped_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n-\t\t\t\t      ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\ttype.get_ty_ref ()));\n+\tBackend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n+\t\t\t\t     ctx->get_mappings ()->lookup_location (\n+\t\t\t\t       type.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree type_record = ctx->get_backend ()->struct_type (fields);\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -679,7 +672,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   Context *ctx;\n   bool trait_object_mode;\n-  ::Btype *translated;\n+  tree translated;\n   size_t recursion_count;\n \n   static const size_t kDefaultRecusionLimit = 5;"}, {"sha": "fb01d8d41225a0fde71d791daae92710e84a49fc", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -86,7 +86,7 @@ CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n   auto operator_expr\n     = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n \t\t\t\t\t\t\t     expr.get_locus ());\n-  Bstatement *assignment\n+  tree assignment\n     = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, operator_expr,\n \t\t\t\t\t\t expr.get_locus ());\n   ctx->add_statement (assignment);\n@@ -117,11 +117,10 @@ CompileExpr::visit (HIR::NegationExpr &expr)\n     = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n }\n \n-Bexpression *\n+tree\n CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\tTyTy::BaseType *receiver,\n-\t\t\t\t\tTyTy::FnType *fntype,\n-\t\t\t\t\tBexpression *receiver_ref,\n+\t\t\t\t\tTyTy::FnType *fntype, tree receiver_ref,\n \t\t\t\t\tstd::vector<HIR::Expr *> &arguments,\n \t\t\t\t\tLocation expr_locus)\n {\n@@ -150,67 +149,67 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n     {\n       TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n       auto indirect_ty = r->get_base ();\n-      Btype *indrect_compiled_tyty\n+      tree indrect_compiled_tyty\n \t= TyTyResolveCompile::compile (ctx, indirect_ty);\n \n-      Bexpression *indirect\n+      tree indirect\n \t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n \t\t\t\t\t\t    receiver_ref, true,\n \t\t\t\t\t\t    expr_locus);\n       receiver_ref = indirect;\n     }\n \n   // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n-  Bexpression *self_argument\n+  tree self_argument\n     = ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n \t\t\t\t\t\t    expr_locus);\n \n   // access the vtable for the fn\n-  Bexpression *fn_vtable_access\n+  tree fn_vtable_access\n     = ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n \t\t\t\t\t\t    expr_locus);\n \n   // cast it to the correct fntype\n-  Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n-  Bexpression *fn_convert_expr\n+  tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+  tree fn_convert_expr\n     = ctx->get_backend ()->convert_expression (expected_fntype,\n \t\t\t\t\t       fn_vtable_access, expr_locus);\n \n   fncontext fnctx = ctx->peek_fn ();\n-  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n   bool is_address_taken = false;\n-  Bstatement *ret_var_stmt = nullptr;\n+  tree ret_var_stmt = NULL_TREE;\n   Bvariable *fn_convert_expr_tmp\n     = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n \t\t\t\t\t       expected_fntype, fn_convert_expr,\n \t\t\t\t\t       is_address_taken, expr_locus,\n \t\t\t\t\t       &ret_var_stmt);\n   ctx->add_statement (ret_var_stmt);\n \n-  std::vector<Bexpression *> args;\n+  std::vector<tree> args;\n   args.push_back (self_argument);\n   for (auto &argument : arguments)\n     {\n-      Bexpression *compiled_expr = CompileExpr::Compile (argument, ctx);\n+      tree compiled_expr = CompileExpr::Compile (argument, ctx);\n       args.push_back (compiled_expr);\n     }\n \n-  Bexpression *fn_expr\n+  tree fn_expr\n     = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n \n   return ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n \t\t\t\t\t       nullptr, expr_locus);\n }\n \n-Bexpression *\n+tree\n CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \t\t\t\t     TyTy::BaseType *receiver,\n \t\t\t\t     HIR::PathIdentSegment &segment,\n \t\t\t\t     Analysis::NodeMapping expr_mappings,\n \t\t\t\t     Location expr_locus)\n {\n   // lookup compiled functions since it may have already been compiled\n-  Bfunction *fn = nullptr;\n+  tree fn = NULL_TREE;\n   if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n       return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n@@ -294,10 +293,10 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n     }\n }\n \n-Bexpression *\n+tree\n CompileExpr::resolve_operator_overload (\n   Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExpr &expr,\n-  Bexpression *lhs, Bexpression *rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n+  tree lhs, tree rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n {\n   TyTy::FnType *fntype;\n   bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n@@ -346,7 +345,7 @@ CompileExpr::resolve_operator_overload (\n   // lookup compiled functions since it may have already been compiled\n   HIR::PathIdentSegment segment_name (\n     Analysis::RustLangItem::ToString (lang_item_type));\n-  Bexpression *fn_expr\n+  tree fn_expr\n     = resolve_method_address (fntype, ref, receiver, segment_name,\n \t\t\t      expr.get_mappings (), expr.get_locus ());\n \n@@ -357,7 +356,7 @@ CompileExpr::resolve_operator_overload (\n   rust_assert (ok);\n \n   // FIXME refactor this out\n-  Bexpression *self = lhs;\n+  tree self = lhs;\n   for (auto &adjustment : *adjustments)\n     {\n       switch (adjustment.get_type ())\n@@ -370,7 +369,7 @@ CompileExpr::resolve_operator_overload (\n \t  break;\n \n \tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  Btype *expected_type\n+\t  tree expected_type\n \t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \t  self\n \t    = ctx->get_backend ()->indirect_expression (expected_type, self,\n@@ -380,7 +379,7 @@ CompileExpr::resolve_operator_overload (\n \t}\n     }\n \n-  std::vector<Bexpression *> args;\n+  std::vector<tree> args;\n   args.push_back (self); // adjusted self\n   if (rhs != nullptr)\t // can be null for negation_expr (unary ones)\n     args.push_back (rhs);"}, {"sha": "2bf969beef988015cf5e18a3406caa848e11f3ab", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 90, "deletions": 97, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -33,7 +33,7 @@ class CompileExpr : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  static tree Compile (HIR::Expr *expr, Context *ctx)\n   {\n     CompileExpr compiler (ctx);\n     expr->accept_vis (compiler);\n@@ -45,7 +45,7 @@ class CompileExpr : public HIRCompileBase\n     HIR::Expr *tuple_expr = expr.get_tuple_expr ().get ();\n     TupleIndex index = expr.get_tuple_index ();\n \n-    Bexpression *receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n+    tree receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n \n     TyTy::BaseType *tuple_expr_ty = nullptr;\n     bool ok = ctx->get_tyctx ()->lookup_type (\n@@ -58,9 +58,9 @@ class CompileExpr : public HIRCompileBase\n \tTyTy::ReferenceType *r\n \t  = static_cast<TyTy::ReferenceType *> (tuple_expr_ty);\n \tTyTy::BaseType *tuple_type = r->get_base ();\n-\tBtype *tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n+\ttree tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n \n-\tBexpression *indirect\n+\ttree indirect\n \t  = ctx->get_backend ()->indirect_expression (tuple_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());\n \treceiver_ref = indirect;\n@@ -88,11 +88,11 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n     rust_assert (tuple_type != nullptr);\n \n     // this assumes all fields are in order from type resolution\n-    std::vector<Bexpression *> vals;\n+    std::vector<tree> vals;\n     for (auto &elem : expr.get_tuple_elems ())\n       {\n \tauto e = CompileExpr::Compile (elem.get (), ctx);\n@@ -108,10 +108,10 @@ class CompileExpr : public HIRCompileBase\n   {\n     auto fncontext = ctx->peek_fn ();\n \n-    std::vector<Bexpression *> retstmts;\n+    std::vector<tree> retstmts;\n     if (expr.has_return_expr ())\n       {\n-\tBexpression *compiled_expr\n+\ttree compiled_expr\n \t  = CompileExpr::Compile (expr.return_expr.get (), ctx);\n \trust_assert (compiled_expr != nullptr);\n \n@@ -204,7 +204,7 @@ class CompileExpr : public HIRCompileBase\n \tgcc_unreachable ();\n       }\n \n-    Bfunction *fn = nullptr;\n+    tree fn = NULL_TREE;\n     Bvariable *var = nullptr;\n     if (ctx->lookup_const_decl (ref, &translated))\n       {\n@@ -259,7 +259,7 @@ class CompileExpr : public HIRCompileBase\n \t      return;\n \t    }\n \n-\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n \t  translated\n \t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n \t}\n@@ -285,7 +285,7 @@ class CompileExpr : public HIRCompileBase\n \t      return;\n \t    }\n \n-\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n \t  translated\n \t    = ctx->get_backend ()->float_constant_expression (type, fval);\n \t}\n@@ -330,21 +330,19 @@ class CompileExpr : public HIRCompileBase\n \t  auto array_tyty = static_cast<TyTy::ArrayType *> (base_tyty);\n \n \t  std::string value_str = expr.get_literal ()->as_string ();\n-\t  std::vector<Bexpression *> vals;\n+\t  std::vector<tree> vals;\n \t  std::vector<unsigned long> indexes;\n \t  for (size_t i = 0; i < value_str.size (); i++)\n \t    {\n \t      char b = value_str.at (i);\n-\t      Bexpression *bb\n-\t\t= ctx->get_backend ()->char_constant_expression (b);\n+\t      tree bb = ctx->get_backend ()->char_constant_expression (b);\n \t      vals.push_back (bb);\n \t      indexes.push_back (i);\n \t    }\n \n-\t  Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n-\t  Bexpression *constructed\n-\t    = ctx->get_backend ()->array_constructor_expression (\n-\t      array_type, indexes, vals, expr.get_locus ());\n+\t  tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+\t  tree constructed = ctx->get_backend ()->array_constructor_expression (\n+\t    array_type, indexes, vals, expr.get_locus ());\n \n \t  translated\n \t    = ctx->get_backend ()->address_expression (constructed,\n@@ -381,7 +379,7 @@ class CompileExpr : public HIRCompileBase\n \n     rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n \n-    Bstatement *assignment\n+    tree assignment\n       = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue, rvalue,\n \t\t\t\t\t\t   expr.get_locus ());\n \n@@ -392,8 +390,8 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::ArrayIndexExpr &expr) override\n   {\n-    Bexpression *array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n-    Bexpression *index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n+    tree array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n+    tree index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n     translated\n       = ctx->get_backend ()->array_index_expression (array, index,\n \t\t\t\t\t\t     expr.get_locus ());\n@@ -414,7 +412,7 @@ class CompileExpr : public HIRCompileBase\n     TyTy::ArrayType *array_tyty = static_cast<TyTy::ArrayType *> (tyty);\n     capacity_expr = array_tyty->get_capacity ();\n \n-    Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+    tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n     rust_assert (array_type != nullptr);\n \n     expr.get_internal_elements ()->accept_vis (*this);\n@@ -432,14 +430,14 @@ class CompileExpr : public HIRCompileBase\n   {\n     for (auto &elem : elems.get_values ())\n       {\n-\tBexpression *translated_expr = CompileExpr::Compile (elem.get (), ctx);\n+\ttree translated_expr = CompileExpr::Compile (elem.get (), ctx);\n \tconstructor.push_back (translated_expr);\n       }\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems) override\n   {\n-    Bexpression *translated_expr\n+    tree translated_expr\n       = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n \n     size_t capacity;\n@@ -516,11 +514,11 @@ class CompileExpr : public HIRCompileBase\n     if (needs_temp)\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -553,11 +551,11 @@ class CompileExpr : public HIRCompileBase\n     if (needs_temp)\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -589,11 +587,11 @@ class CompileExpr : public HIRCompileBase\n     if (needs_temp)\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -640,15 +638,15 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree type = TyTyResolveCompile::compile (ctx, tyty);\n     rust_assert (type != nullptr);\n \n     // this assumes all fields are in order from type resolution and if a base\n     // struct was specified those fields are filed via accesors\n-    std::vector<Bexpression *> vals;\n+    std::vector<tree> vals;\n     for (auto &field : struct_expr.get_fields ())\n       {\n-\tBexpression *expr = CompileStructExprField::Compile (field.get (), ctx);\n+\ttree expr = CompileStructExprField::Compile (field.get (), ctx);\n \tvals.push_back (expr);\n       }\n \n@@ -665,7 +663,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::FieldAccessExpr &expr) override\n   {\n-    Bexpression *receiver_ref\n+    tree receiver_ref\n       = CompileExpr::Compile (expr.get_receiver_expr ().get (), ctx);\n \n     // resolve the receiver back to ADT type\n@@ -705,8 +703,8 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t &field_index);\n \trust_assert (ok);\n \n-\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n-\tBexpression *indirect\n+\ttree adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n+\ttree indirect\n \t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());\n \treceiver_ref = indirect;\n@@ -742,11 +740,11 @@ class CompileExpr : public HIRCompileBase\n     bool needs_temp = !block_tyty->is_unit ();\n     if (needs_temp)\n       {\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -757,29 +755,29 @@ class CompileExpr : public HIRCompileBase\n     if (expr.has_loop_label ())\n       {\n \tHIR::LoopLabel &loop_label = expr.get_loop_label ();\n-\tBlabel *label\n+\ttree label\n \t  = ctx->get_backend ()->label (fnctx.fndecl,\n \t\t\t\t\tloop_label.get_lifetime ().get_name (),\n \t\t\t\t\tloop_label.get_locus ());\n-\tBstatement *label_decl\n+\ttree label_decl\n \t  = ctx->get_backend ()->label_definition_statement (label);\n \tctx->add_statement (label_decl);\n \tctx->insert_label_decl (\n \t  loop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n       }\n \n-    Blabel *loop_begin_label\n+    tree loop_begin_label\n       = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    Bstatement *loop_begin_label_decl\n+    tree loop_begin_label_decl\n       = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n     ctx->add_statement (loop_begin_label_decl);\n     ctx->push_loop_begin_label (loop_begin_label);\n \n-    Bblock *code_block\n+    tree code_block\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    Bexpression *loop_expr\n+    tree loop_expr\n       = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n-    Bstatement *loop_stmt\n+    tree loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n     ctx->add_statement (loop_stmt);\n \n@@ -798,11 +796,11 @@ class CompileExpr : public HIRCompileBase\n     if (expr.has_loop_label ())\n       {\n \tHIR::LoopLabel &loop_label = expr.get_loop_label ();\n-\tBlabel *label\n+\ttree label\n \t  = ctx->get_backend ()->label (fnctx.fndecl,\n \t\t\t\t\tloop_label.get_lifetime ().get_name (),\n \t\t\t\t\tloop_label.get_locus ());\n-\tBstatement *label_decl\n+\ttree label_decl\n \t  = ctx->get_backend ()->label_definition_statement (label);\n \tctx->add_statement (label_decl);\n \tctx->insert_label_decl (\n@@ -813,39 +811,38 @@ class CompileExpr : public HIRCompileBase\n     Location start_location = expr.get_loop_block ()->get_locus ();\n     Location end_location = expr.get_loop_block ()->get_locus (); // FIXME\n \n-    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-    Bblock *loop_block\n+    tree enclosing_scope = ctx->peek_enclosing_scope ();\n+    tree loop_block\n       = ctx->get_backend ()->block (fnctx.fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (loop_block);\n \n-    Blabel *loop_begin_label\n+    tree loop_begin_label\n       = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    Bstatement *loop_begin_label_decl\n+    tree loop_begin_label_decl\n       = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n     ctx->add_statement (loop_begin_label_decl);\n     ctx->push_loop_begin_label (loop_begin_label);\n \n-    Bexpression *condition\n+    tree condition\n       = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n-    Bexpression *exit_expr\n+    tree exit_expr\n       = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n-    Bstatement *break_stmt\n+    tree break_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n     ctx->add_statement (break_stmt);\n \n-    Bblock *code_block\n+    tree code_block\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    Bstatement *code_block_stmt\n-      = ctx->get_backend ()->block_statement (code_block);\n+    tree code_block_stmt = ctx->get_backend ()->block_statement (code_block);\n     ctx->add_statement (code_block_stmt);\n \n     ctx->pop_loop_begin_label ();\n     ctx->pop_block ();\n \n-    Bexpression *loop_expr\n+    tree loop_expr\n       = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n-    Bstatement *loop_stmt\n+    tree loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n     ctx->add_statement (loop_stmt);\n   }\n@@ -855,14 +852,14 @@ class CompileExpr : public HIRCompileBase\n     fncontext fnctx = ctx->peek_fn ();\n     if (expr.has_break_expr ())\n       {\n-\tBexpression *compiled_expr\n+\ttree compiled_expr\n \t  = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n \tBvariable *loop_result_holder = ctx->peek_loop_context ();\n-\tBexpression *result_reference = ctx->get_backend ()->var_expression (\n+\ttree result_reference = ctx->get_backend ()->var_expression (\n \t  loop_result_holder, expr.get_expr ()->get_locus ());\n \n-\tBstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\ttree assignment = ctx->get_backend ()->assignment_statement (\n \t  fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n \tctx->add_statement (assignment);\n       }\n@@ -890,32 +887,32 @@ class CompileExpr : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBlabel *label = nullptr;\n+\ttree label = NULL_TREE;\n \tif (!ctx->lookup_label_decl (ref, &label))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to lookup compiled label\");\n \t    return;\n \t  }\n \n-\tBstatement *goto_label\n+\ttree goto_label\n \t  = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n \tctx->add_statement (goto_label);\n       }\n     else\n       {\n-\tBexpression *exit_expr = ctx->get_backend ()->exit_expression (\n+\ttree exit_expr = ctx->get_backend ()->exit_expression (\n \t  ctx->get_backend ()->boolean_constant_expression (true),\n \t  expr.get_locus ());\n-\tBstatement *break_stmt\n+\ttree break_stmt\n \t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n \tctx->add_statement (break_stmt);\n       }\n   }\n \n   void visit (HIR::ContinueExpr &expr) override\n   {\n-    Blabel *label = ctx->peek_loop_begin_label ();\n+    tree label = ctx->peek_loop_begin_label ();\n     if (expr.has_label ())\n       {\n \tNodeId resolved_node_id = UNKNOWN_NODEID;\n@@ -947,24 +944,22 @@ class CompileExpr : public HIRCompileBase\n \t  }\n       }\n \n-    Bstatement *goto_label\n+    tree goto_label\n       = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n     ctx->add_statement (goto_label);\n   }\n \n   void visit (HIR::BorrowExpr &expr) override\n   {\n-    Bexpression *main_expr\n-      = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n     translated\n       = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override\n   {\n-    Bexpression *main_expr\n-      = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n     TyTy::BaseType *tyty = nullptr;\n     if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n@@ -975,7 +970,7 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *expected_type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n     bool known_valid = true;\n     translated\n       = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n@@ -984,33 +979,31 @@ class CompileExpr : public HIRCompileBase\n   }\n \n protected:\n-  Bexpression *compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n-\t\t\t\t\t  TyTy::BaseType *receiver,\n-\t\t\t\t\t  TyTy::FnType *fntype,\n-\t\t\t\t\t  Bexpression *receiver_ref,\n-\t\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n-\t\t\t\t\t  Location expr_locus);\n-\n-  Bexpression *resolve_method_address (TyTy::FnType *fntype, HirId ref,\n-\t\t\t\t       TyTy::BaseType *receiver,\n-\t\t\t\t       HIR::PathIdentSegment &segment,\n-\t\t\t\t       Analysis::NodeMapping expr_mappings,\n-\t\t\t\t       Location expr_locus);\n-\n-  Bexpression *\n+  tree compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t  TyTy::BaseType *receiver,\n+\t\t\t\t  TyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n+\t\t\t\t  Location expr_locus);\n+\n+  tree resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t       TyTy::BaseType *receiver,\n+\t\t\t       HIR::PathIdentSegment &segment,\n+\t\t\t       Analysis::NodeMapping expr_mappings,\n+\t\t\t       Location expr_locus);\n+\n+  tree\n   resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n-\t\t\t     HIR::OperatorExpr &expr, Bexpression *lhs,\n-\t\t\t     Bexpression *rhs, HIR::Expr *lhs_expr,\n-\t\t\t     HIR::Expr *rhs_expr);\n+\t\t\t     HIR::OperatorExpr &expr, tree lhs, tree rhs,\n+\t\t\t     HIR::Expr *lhs_expr, HIR::Expr *rhs_expr);\n \n private:\n   CompileExpr (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)\n   {}\n \n-  Bexpression *translated;\n-  Bexpression *capacity_expr;\n-  std::vector<Bexpression *> constructor;\n+  tree translated;\n+  tree capacity_expr;\n+  std::vector<tree> constructor;\n };\n \n } // namespace Compile"}, {"sha": "aa73509f634a02ada963ade4267eeeb91c8b4711", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -55,7 +55,7 @@ class CompileExternItem : public HIRCompileBase\n     // FIXME this is assuming C ABI\n     std::string asm_name = name;\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     bool is_external = true;\n     bool is_hidden = false;\n     bool in_unique_section = false;\n@@ -99,14 +99,14 @@ class CompileExternItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      ctx->insert_function_decl (fntype, lookup);\n \n@@ -123,12 +123,12 @@ class CompileExternItem : public HIRCompileBase\n     if (fntype->get_abi () == ABI::INTRINSIC)\n       {\n \tIntrinsics compile (ctx);\n-\tBfunction *fndecl = compile.compile (fntype);\n+\ttree fndecl = compile.compile (fntype);\n \tctx->insert_function_decl (fntype, fndecl);\n \treturn;\n       }\n \n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n     compiled_fn_type\n       = ctx->get_backend ()->specify_abi_attribute (compiled_fn_type,\n \t\t\t\t\t\t    fntype->get_abi ());\n@@ -139,7 +139,7 @@ class CompileExternItem : public HIRCompileBase\n     std::string ir_symbol_name = function.get_item_name ();\n     std::string asm_name = function.get_item_name ();\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);"}, {"sha": "629f0f5a873db43244949c83254a8ed4796af0aa", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -29,8 +29,8 @@ class CompileFnParam : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n-\t\t\t     HIR::FunctionParam *param, Btype *decl_type,\n+  static Bvariable *compile (Context *ctx, tree fndecl,\n+\t\t\t     HIR::FunctionParam *param, tree decl_type,\n \t\t\t     Location locus)\n   {\n     CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n@@ -51,24 +51,22 @@ class CompileFnParam : public HIRCompileBase\n   }\n \n private:\n-  CompileFnParam (Context *ctx, ::Bfunction *fndecl, ::Btype *decl_type,\n-\t\t  Location locus)\n+  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus)\n     : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n       locus (locus), translated (nullptr)\n   {}\n \n-  ::Bfunction *fndecl;\n-  ::Btype *decl_type;\n+  tree fndecl;\n+  tree decl_type;\n   Location locus;\n   ::Bvariable *translated;\n };\n \n class CompileSelfParam : public HIRCompileBase\n {\n public:\n-  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n-\t\t\t     HIR::SelfParam &self, Btype *decl_type,\n-\t\t\t     Location locus)\n+  static Bvariable *compile (Context *ctx, tree fndecl, HIR::SelfParam &self,\n+\t\t\t     tree decl_type, Location locus)\n   {\n     bool is_immutable\n       = self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM"}, {"sha": "7b412266a0a9fddbbcb7b7975bd7962b18b3fd7f", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -34,11 +34,11 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (const TyTy::BaseType *self, HIR::ImplItem *item,\n-\t\t\t       Context *ctx, bool compile_fns,\n-\t\t\t       TyTy::BaseType *concrete = nullptr,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree Compile (const TyTy::BaseType *self, HIR::ImplItem *item,\n+\t\t       Context *ctx, bool compile_fns,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileInherentImplItem compiler (self, ctx, compile_fns, concrete,\n \t\t\t\t      ref_locus);\n@@ -60,8 +60,8 @@ class CompileInherentImplItem : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -70,7 +70,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+    tree const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_identifier (), value, constant.get_locus ());\n \n     ctx->push_const (const_expr);\n@@ -110,14 +110,14 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -136,7 +136,7 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n \n@@ -156,7 +156,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     std::string asm_name\n       = ctx->mangle_impl_item (self, fntype, function.get_function_name ());\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);\n@@ -178,7 +178,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n \tif (self_type == nullptr)\n \t  {\n \t    rust_error_at (function.get_self_param ().get_locus (),\n@@ -262,23 +262,23 @@ class CompileInherentImplItem : public HIRCompileBase\n     ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n-    Bblock *enclosing_scope = NULL;\n+    tree enclosing_scope = NULL_TREE;\n     HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n-    Bblock *code_block\n+    tree code_block\n       = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n     if (function.has_function_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n@@ -319,7 +319,7 @@ class CompileInherentImplItem : public HIRCompileBase\n   const TyTy::BaseType *self;\n   bool compile_fns;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n \n@@ -328,10 +328,10 @@ class CompileTraitItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n-\t\t\t       Context *ctx, TyTy::BaseType *concrete,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n+\t\t       Context *ctx, TyTy::BaseType *concrete,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileTraitItem compiler (self, ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n@@ -349,9 +349,8 @@ class CompileTraitItem : public HIRCompileBase\n     rust_assert (concrete != nullptr);\n     TyTy::BaseType *resolved_type = concrete;\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value\n-      = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     bool ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -360,7 +359,7 @@ class CompileTraitItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+    tree const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_name (), value, constant.get_locus ());\n \n     ctx->push_const (const_expr);\n@@ -378,14 +377,14 @@ class CompileTraitItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -404,7 +403,7 @@ class CompileTraitItem : public HIRCompileBase\n       }\n \n     // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     HIR::TraitFunctionDecl &function = func.get_decl ();\n     unsigned int flags = 0;\n@@ -418,7 +417,7 @@ class CompileTraitItem : public HIRCompileBase\n     std::string fn_identifier = canonical_path->get ();\n     std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, func.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);\n@@ -440,7 +439,7 @@ class CompileTraitItem : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n \tif (self_type == nullptr)\n \t  {\n \t    rust_error_at (function.get_self ().get_locus (),\n@@ -523,23 +522,23 @@ class CompileTraitItem : public HIRCompileBase\n     ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n-    Bblock *enclosing_scope = NULL;\n+    tree enclosing_scope = NULL_TREE;\n     HIR::BlockExpr *function_body = func.get_block_expr ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n-    Bblock *code_block\n+    tree code_block\n       = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n     if (function.has_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n@@ -578,7 +577,7 @@ class CompileTraitItem : public HIRCompileBase\n \n   const TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n "}, {"sha": "69626a930e955753529624771b865b1681a76755", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -21,7 +21,7 @@ namespace Compile {\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n \n-Bfunction *\n+tree\n Intrinsics::compile (TyTy::FnType *fntype)\n {\n   rust_assert (fntype->get_abi () == ABI::INTRINSIC);\n@@ -77,7 +77,7 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   // };\n   // Some(cx.get_intrinsic(&llvm_name))\n \n-  Bfunction *builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n+  tree builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n     fntype->get_identifier ());\n   if (builtin != nullptr)\n     return builtin;"}, {"sha": "2d44baa037cf78b3eae22b12b5ec9c46b69d393e", "filename": "gcc/rust/backend/rust-compile-intrinsic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -27,7 +27,7 @@ class Intrinsics\n public:\n   Intrinsics (Context *ctx);\n \n-  Bfunction *compile (TyTy::FnType *fntype);\n+  tree compile (TyTy::FnType *fntype);\n \n private:\n   Context *ctx;"}, {"sha": "5af9ab31847491da383ac5546e4c85ce327f6cc2", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -37,11 +37,10 @@ class CompileItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *compile (HIR::Item *item, Context *ctx,\n-\t\t\t       bool compile_fns = true,\n-\t\t\t       TyTy::BaseType *concrete = nullptr,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree compile (HIR::Item *item, Context *ctx, bool compile_fns = true,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileItem compiler (ctx, compile_fns, concrete, ref_locus);\n     item->accept_vis (compiler);\n@@ -61,8 +60,8 @@ class CompileItem : public HIRCompileBase\n \t\t\t\t\t      &resolved_type);\n     rust_assert (ok);\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (var.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (var.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -97,8 +96,8 @@ class CompileItem : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -107,7 +106,7 @@ class CompileItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr\n+    tree const_expr\n       = ctx->get_backend ()->named_constant_expression (type, ident, value,\n \t\t\t\t\t\t\tconstant.get_locus ());\n \n@@ -148,14 +147,14 @@ class CompileItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -174,7 +173,7 @@ class CompileItem : public HIRCompileBase\n \tfntype->override_context ();\n       }\n \n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n     bool is_main_fn = function.get_function_name ().compare (\"main\") == 0;\n@@ -202,7 +201,7 @@ class CompileItem : public HIRCompileBase\n \tasm_name = ctx->mangle_item (fntype, *canonical_path);\n       }\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);\n@@ -262,23 +261,23 @@ class CompileItem : public HIRCompileBase\n     ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n-    Bblock *enclosing_scope = NULL;\n+    tree enclosing_scope = NULL_TREE;\n     HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n-    Bblock *code_block\n+    tree code_block\n       = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n     if (function.has_function_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n@@ -347,7 +346,7 @@ class CompileItem : public HIRCompileBase\n \n   bool compile_fns;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n "}, {"sha": "cb3f0df8db03d2e89e19d77ec64dc39ea0c51c11", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -40,7 +40,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t      expr.get_mappings (), expr.get_locus (), false);\n }\n \n-Bexpression *\n+tree\n ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t const Analysis::NodeMapping &mappings,\n \t\t\t Location expr_locus, bool is_qualified_path)\n@@ -76,7 +76,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n     }\n \n   // might be a constant\n-  Bexpression *constant_expr;\n+  tree constant_expr;\n   if (ctx->lookup_const_decl (ref, &constant_expr))\n     return constant_expr;\n \n@@ -92,7 +92,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n   if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-      Bfunction *fn = nullptr;\n+      tree fn = NULL_TREE;\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n \t  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n@@ -104,7 +104,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\tis_qualified_path);\n }\n \n-Bexpression *\n+tree\n ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t\t\t       const HIR::PathIdentSegment &final_segment,\n \t\t\t       const Analysis::NodeMapping &mappings,"}, {"sha": "56f82d1e6bca9a81aa43b2fec678f07ceab09b31", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -30,15 +30,14 @@ class ResolvePathRef : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::QualifiedPathInExpression &expr,\n-\t\t\t       Context *ctx)\n+  static tree Compile (HIR::QualifiedPathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n     expr.accept_vis (resolver);\n     return resolver.resolved;\n   }\n \n-  static Bexpression *Compile (HIR::PathInExpression &expr, Context *ctx)\n+  static tree Compile (HIR::PathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n     expr.accept_vis (resolver);\n@@ -54,16 +53,16 @@ class ResolvePathRef : public HIRCompileBase\n     : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *resolve (const HIR::PathIdentSegment &final_segment,\n-\t\t\tconst Analysis::NodeMapping &mappings, Location locus,\n-\t\t\tbool is_qualified_path);\n+  tree resolve (const HIR::PathIdentSegment &final_segment,\n+\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\tbool is_qualified_path);\n \n-  Bexpression *query_compile (HirId ref, TyTy::BaseType *lookup,\n-\t\t\t      const HIR::PathIdentSegment &final_segment,\n-\t\t\t      const Analysis::NodeMapping &mappings,\n-\t\t\t      Location expr_locus, bool is_qualified_path);\n+  tree query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t      const HIR::PathIdentSegment &final_segment,\n+\t\t      const Analysis::NodeMapping &mappings,\n+\t\t      Location expr_locus, bool is_qualified_path);\n \n-  Bexpression *resolved;\n+  tree resolved;\n };\n \n } // namespace Compile"}, {"sha": "f3ee69d984837b0d9f2fc2f807e7a705c4b6a8dc", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -31,7 +31,7 @@ class CompileStmt : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::Stmt *stmt, Context *ctx)\n+  static tree Compile (HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileStmt compiler (ctx);\n     stmt->accept_vis (compiler);\n@@ -56,8 +56,8 @@ class CompileStmt : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -66,7 +66,7 @@ class CompileStmt : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr\n+    tree const_expr\n       = ctx->get_backend ()->named_constant_expression (type, ident, value,\n \t\t\t\t\t\t\tconstant.get_locus ());\n \n@@ -101,7 +101,7 @@ class CompileStmt : public HIRCompileBase\n \treturn;\n       }\n \n-    Bexpression *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    tree init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n     // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n     // on failure and make this an assertion\n     if (init == nullptr)\n@@ -118,7 +118,7 @@ class CompileStmt : public HIRCompileBase\n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())\n       {\n-\tBstatement *expr_stmt\n+\ttree expr_stmt\n \t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, init);\n \tctx->add_statement (expr_stmt);\n       }\n@@ -132,7 +132,7 @@ class CompileStmt : public HIRCompileBase\n private:\n   CompileStmt (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n \n-  Bexpression *translated;\n+  tree translated;\n };\n \n } // namespace Compile"}, {"sha": "6754e8c4242504b2763eda2b7b9c3e1722d52db1", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -30,7 +30,7 @@ class CompileStructExprField : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::StructExprField *field, Context *ctx)\n+  static tree Compile (HIR::StructExprField *field, Context *ctx)\n   {\n     CompileStructExprField compiler (ctx);\n     field->accept_vis (compiler);\n@@ -49,7 +49,7 @@ class CompileStructExprField : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr)\n   {}\n \n-  Bexpression *translated;\n+  tree translated;\n };\n \n } // namespace Compile"}, {"sha": "04a3ecd222ea0c4db1134ed876a1c64de09e16ec", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -34,7 +34,7 @@ namespace Compile {\n class TyTyCompile : public TyTy::TyVisitor\n {\n public:\n-  static ::Btype *compile (::Backend *backend, TyTy::BaseType *ty)\n+  static tree compile (::Backend *backend, TyTy::BaseType *ty)\n   {\n     TyTyCompile compiler (backend);\n     ty->accept_vis (compiler);\n@@ -72,15 +72,15 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::FnType &type) override\n   {\n-    Backend::Btyped_identifier receiver;\n-    std::vector<Backend::Btyped_identifier> parameters;\n-    std::vector<Backend::Btyped_identifier> results;\n+    Backend::typed_identifier receiver;\n+    std::vector<Backend::typed_identifier> parameters;\n+    std::vector<Backend::typed_identifier> results;\n \n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n \tauto ret = TyTyCompile::compile (backend, hir_type);\n-\tresults.push_back (Backend::Btyped_identifier (\n+\tresults.push_back (Backend::typed_identifier (\n \t  \"_\", ret, mappings->lookup_location (hir_type->get_ref ())));\n       }\n \n@@ -90,7 +90,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \tauto param_tyty = params.second;\n \tauto compiled_param_type = TyTyCompile::compile (backend, param_tyty);\n \n-\tauto compiled_param = Backend::Btyped_identifier (\n+\tauto compiled_param = Backend::typed_identifier (\n \t  param_pattern->as_string (), compiled_param_type,\n \t  mappings->lookup_location (param_tyty->get_ref ()));\n \n@@ -227,7 +227,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::StrType &) override\n   {\n-    Btype *raw_str = backend->raw_str_type ();\n+    tree raw_str = backend->raw_str_type ();\n     translated\n       = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n   }\n@@ -248,7 +248,7 @@ class TyTyCompile : public TyTy::TyVisitor\n   {}\n \n   ::Backend *backend;\n-  ::Btype *translated;\n+  tree translated;\n   Analysis::Mappings *mappings;\n };\n "}, {"sha": "a964fa2206bfa015b3b74983a94530aa9ea4d1a6", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -29,8 +29,7 @@ class CompileVarDecl : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static ::Bvariable *compile (::Bfunction *fndecl, HIR::Stmt *stmt,\n-\t\t\t       Context *ctx)\n+  static ::Bvariable *compile (tree fndecl, HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileVarDecl compiler (ctx, fndecl);\n     stmt->accept_vis (compiler);\n@@ -64,13 +63,13 @@ class CompileVarDecl : public HIRCompileBase\n   }\n \n private:\n-  CompileVarDecl (Context *ctx, ::Bfunction *fndecl)\n+  CompileVarDecl (Context *ctx, tree fndecl)\n     : HIRCompileBase (ctx), fndecl (fndecl), translated_type (nullptr),\n       translated (nullptr)\n   {}\n \n-  ::Bfunction *fndecl;\n-  ::Btype *translated_type;\n+  tree fndecl;\n+  tree translated_type;\n   Location locus;\n   ::Bvariable *translated;\n };"}, {"sha": "579b323ab8bb2c2af414721e85e05936f982dcc9", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -72,15 +72,15 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     {\n       rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n-      Btype *compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n       rust_assert (!adt->is_enum ());\n       rust_assert (adt->number_of_variants () == 1);\n       auto variant = adt->get_variants ().at (0);\n \n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n-      std::vector<Bexpression *> vals;\n+      std::vector<tree> vals;\n       for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n \t  auto &argument = expr.get_arguments ().at (i);\n@@ -150,7 +150,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t  required_num_args = fn->num_params ();\n \t}\n \n-      std::vector<Bexpression *> args;\n+      std::vector<tree> args;\n       for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n \t  auto &argument = expr.get_arguments ().at (i);\n@@ -195,7 +195,7 @@ void\n CompileExpr::visit (HIR::MethodCallExpr &expr)\n {\n   // method receiver\n-  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n \n   // lookup the resolved name\n   NodeId resolved_node_id = UNKNOWN_NODEID;\n@@ -254,7 +254,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n   // lookup compiled functions since it may have already been compiled\n   HIR::PathExprSegment method_name = expr.get_method_name ();\n   HIR::PathIdentSegment segment_name = method_name.get_segment ();\n-  Bexpression *fn_expr\n+  tree fn_expr\n     = resolve_method_address (fntype, ref, receiver, segment_name,\n \t\t\t      expr.get_mappings (), expr.get_locus ());\n \n@@ -275,7 +275,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t  break;\n \n \tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  Btype *expected_type\n+\t  tree expected_type\n \t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \t  self = ctx->get_backend ()->indirect_expression (\n \t    expected_type, self, true, /* known_valid*/\n@@ -284,7 +284,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t}\n     }\n \n-  std::vector<Bexpression *> args;\n+  std::vector<tree> args;\n   args.push_back (self); // adjusted self\n \n   // normal args\n@@ -322,7 +322,7 @@ void\n CompileBlock::visit (HIR::BlockExpr &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n+  tree fndecl = fnctx.fndecl;\n   Location start_location = expr.get_locus ();\n   Location end_location = expr.get_closing_locus ();\n   auto body_mappings = expr.get_mappings ();\n@@ -338,18 +338,17 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n   bool ok = compile_locals_for_block (*rib, fndecl, locals);\n   rust_assert (ok);\n \n-  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-  Bblock *new_block\n-    = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t  start_location, end_location);\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree new_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t       start_location, end_location);\n   ctx->push_block (new_block);\n \n   for (auto &s : expr.get_statements ())\n     {\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  Bstatement *compiled_stmt\n+\t  tree compiled_stmt\n \t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t compiled_expr);\n \t  ctx->add_statement (compiled_stmt);\n@@ -360,23 +359,22 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n     {\n       // the previous passes will ensure this is a valid return or\n       // a valid trailing expression\n-      Bexpression *compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n+      tree compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n \t  if (result == nullptr)\n \t    {\n-\t      Bstatement *final_stmt\n+\t      tree final_stmt\n \t\t= ctx->get_backend ()->expression_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t     compiled_expr);\n \t      ctx->add_statement (final_stmt);\n \t    }\n \t  else\n \t    {\n-\t      Bexpression *result_reference\n-\t\t= ctx->get_backend ()->var_expression (\n-\t\t  result, expr.get_final_expr ()->get_locus ());\n+\t      tree result_reference = ctx->get_backend ()->var_expression (\n+\t\tresult, expr.get_final_expr ()->get_locus ());\n \n-\t      Bstatement *assignment\n+\t      tree assignment\n \t\t= ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t     result_reference,\n \t\t\t\t\t\t\t     compiled_expr,\n@@ -394,11 +392,9 @@ void\n CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block\n-    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -409,13 +405,10 @@ void\n CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block\n-    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n-  Bblock *else_block\n-    = CompileBlock::compile (expr.get_else_block (), ctx, result);\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree else_block = CompileBlock::compile (expr.get_else_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -426,23 +419,20 @@ void\n CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block\n-    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   // else block\n   std::vector<Bvariable *> locals;\n   Location start_location = expr.get_conseq_if_expr ()->get_locus ();\n   Location end_location = expr.get_conseq_if_expr ()->get_locus (); // FIXME\n-  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-  Bblock *else_block\n-    = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t  start_location, end_location);\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree else_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n   ctx->push_block (else_block);\n \n-  Bstatement *else_stmt_decl\n+  tree else_stmt_decl\n     = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n \t\t\t\t\t result);\n   ctx->add_statement (else_stmt_decl);\n@@ -482,15 +472,15 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n \n void\n HIRCompileBase::compile_function_body (\n-  Bfunction *fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n+  tree fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n   bool has_return_type)\n {\n   for (auto &s : function_body->get_statements ())\n     {\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  Bstatement *compiled_stmt\n+\t  tree compiled_stmt\n \t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n \t  ctx->add_statement (compiled_stmt);\n \t}\n@@ -500,14 +490,14 @@ HIRCompileBase::compile_function_body (\n     {\n       // the previous passes will ensure this is a valid return\n       // or a valid trailing expression\n-      Bexpression *compiled_expr\n+      tree compiled_expr\n \t= CompileExpr::Compile (function_body->expr.get (), ctx);\n \n       if (compiled_expr != nullptr)\n \t{\n \t  if (has_return_type)\n \t    {\n-\t      std::vector<Bexpression *> retstmts;\n+\t      std::vector<tree> retstmts;\n \t      retstmts.push_back (compiled_expr);\n \n \t      auto ret = ctx->get_backend ()->return_statement (\n@@ -517,7 +507,7 @@ HIRCompileBase::compile_function_body (\n \t    }\n \t  else\n \t    {\n-\t      Bstatement *final_stmt\n+\t      tree final_stmt\n \t\t= ctx->get_backend ()->expression_statement (fndecl,\n \t\t\t\t\t\t\t     compiled_expr);\n \t      ctx->add_statement (final_stmt);\n@@ -527,7 +517,7 @@ HIRCompileBase::compile_function_body (\n }\n \n bool\n-HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n \t\t\t\t\t  std::vector<Bvariable *> &locals)\n {\n   rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n@@ -561,10 +551,9 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n   return true;\n }\n \n-Bexpression *\n-HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n-\t\t\t       TyTy::BaseType *actual, TyTy::BaseType *expected,\n-\t\t\t       Location locus)\n+tree\n+HIRCompileBase::coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n+\t\t\t       TyTy::BaseType *expected, Location locus)\n {\n   auto root_actual_kind = actual->get_root ()->get_kind ();\n   auto root_expected_kind = expected->get_root ()->get_kind ();\n@@ -580,14 +569,14 @@ HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n   return compiled_ref;\n }\n \n-Bexpression *\n-HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n+tree\n+HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \t\t\t\t      const TyTy::BaseType *actual,\n \t\t\t\t      const TyTy::BaseType *expected,\n \t\t\t\t      const TyTy::DynamicObjectType *ty,\n \t\t\t\t      Location locus)\n {\n-  Btype *dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+  tree dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n \n   //' this assumes ordering and current the structure is\n   // __trait_object_ptr\n@@ -597,7 +586,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n     probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (root);\n \n-  std::vector<Bexpression *> vals;\n+  std::vector<tree> vals;\n   vals.push_back (compiled_ref);\n   for (auto &bound : ty->get_object_items ())\n     {\n@@ -610,14 +599,14 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n       vals.push_back (address);\n     }\n \n-  Bexpression *constructed_trait_object\n+  tree constructed_trait_object\n     = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n \t\t\t\t\t\t   locus);\n \n   fncontext fnctx = ctx->peek_fn ();\n-  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n   bool is_address_taken = false;\n-  Bstatement *ret_var_stmt = nullptr;\n+  tree ret_var_stmt = NULL_TREE;\n \n   Bvariable *dyn_tmp = ctx->get_backend ()->temporary_variable (\n     fnctx.fndecl, enclosing_scope, dynamic_object, constructed_trait_object,\n@@ -659,7 +648,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   return resulting_dyn_object_ref;\n }\n \n-Bexpression *\n+tree\n HIRCompileBase::compute_address_for_trait_item (\n   const Resolver::TraitItemReference *ref,\n   const TyTy::TypeBoundPredicate *predicate,"}, {"sha": "64144bcaf805ea15a7fbb8ea20c69d968b6f93d1", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 157, "deletions": 297, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -29,6 +29,8 @@\n #include \"operator.h\"\n #include \"rust-abi.h\"\n \n+#include \"tree.h\"\n+\n extern bool\n saw_errors (void);\n \n@@ -39,27 +41,9 @@ saw_errors (void);\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n \n-// The backend representation of a type.\n-class Btype;\n-\n-// The backend represention of an expression.\n-class Bexpression;\n-\n-// The backend representation of a statement.\n-class Bstatement;\n-\n-// The backend representation of a function definition or declaration.\n-class Bfunction;\n-\n-// The backend representation of a block.\n-class Bblock;\n-\n // The backend representation of a variable.\n class Bvariable;\n \n-// The backend representation of a label.\n-class Blabel;\n-\n // The backend interface.  This is a pure abstract class that a\n // specific backend will implement.\n \n@@ -70,35 +54,30 @@ class Backend\n \n   // Name/type/location.  Used for function parameters, struct fields,\n   // interface methods.\n-  struct Btyped_identifier\n+  struct typed_identifier\n   {\n     std::string name;\n-    Btype *btype;\n+    tree type;\n     Location location;\n \n-    Btyped_identifier ()\n-      : name (), btype (NULL), location (Linemap::unknown_location ())\n+    typed_identifier ()\n+      : name (), type (NULL_TREE), location (Linemap::unknown_location ())\n     {}\n \n-    Btyped_identifier (const std::string &a_name, Btype *a_btype,\n-\t\t       Location a_location)\n-      : name (a_name), btype (a_btype), location (a_location)\n+    typed_identifier (const std::string &a_name, tree a_type,\n+\t\t      Location a_location)\n+      : name (a_name), type (a_type), location (a_location)\n     {}\n   };\n \n   // debug\n-  virtual void debug (Btype *) = 0;\n-  virtual void debug (Bexpression *) = 0;\n-  virtual void debug (Bstatement *) = 0;\n-  virtual void debug (Bfunction *) = 0;\n-  virtual void debug (Bblock *) = 0;\n+  virtual void debug (tree) = 0;\n   virtual void debug (Bvariable *) = 0;\n-  virtual void debug (Blabel *) = 0;\n \n   // const folder helpers\n-  virtual bool const_size_cast (Bexpression *, size_t *) = 0;\n-  virtual std::string const_size_val_to_string (Bexpression *) = 0;\n-  virtual bool const_values_equal (Bexpression *, Bexpression *) = 0;\n+  virtual bool const_size_cast (tree, size_t *) = 0;\n+  virtual std::string const_size_val_to_string (tree) = 0;\n+  virtual bool const_values_equal (tree, tree) = 0;\n \n   static Rust::ABI get_abi_from_string (const std::string &abi, Location locus)\n   {\n@@ -147,50 +126,50 @@ class Backend\n \n   // Produce an error type.  Actually the backend could probably just\n   // crash if this is called.\n-  virtual Btype *error_type () = 0;\n+  virtual tree error_type () = 0;\n \n   // Get a void type.  This is used in (at least) two ways: 1) as the\n   // return type of a function with no result parameters; 2)\n   // unsafe.Pointer is represented as *void.\n-  virtual Btype *void_type () = 0;\n+  virtual tree void_type () = 0;\n \n   // get unit-type\n-  virtual Btype *unit_type () = 0;\n+  virtual tree unit_type () = 0;\n \n   // Get the unnamed boolean type.\n-  virtual Btype *bool_type () = 0;\n+  virtual tree bool_type () = 0;\n \n   // Get the char type\n-  virtual Btype *char_type () = 0;\n+  virtual tree char_type () = 0;\n \n   // Get the wchar type\n-  virtual Btype *wchar_type () = 0;\n+  virtual tree wchar_type () = 0;\n \n   // Get the Host pointer size in bits\n   virtual int get_pointer_size () = 0;\n \n   // Get the raw str type const char*\n-  virtual Btype *raw_str_type () = 0;\n+  virtual tree raw_str_type () = 0;\n \n   // Get an unnamed integer type with the given signedness and number\n   // of bits.\n-  virtual Btype *integer_type (bool is_unsigned, int bits) = 0;\n+  virtual tree integer_type (bool is_unsigned, int bits) = 0;\n \n   // Get an unnamed floating point type with the given number of bits\n   // (32 or 64).\n-  virtual Btype *float_type (int bits) = 0;\n+  virtual tree float_type (int bits) = 0;\n \n   // Get an unnamed complex type with the given number of bits (64 or 128).\n-  virtual Btype *complex_type (int bits) = 0;\n+  virtual tree complex_type (int bits) = 0;\n \n   // Get a pointer type.\n-  virtual Btype *pointer_type (Btype *to_type) = 0;\n+  virtual tree pointer_type (tree to_type) = 0;\n \n   // Get a reference type.\n-  virtual Btype *reference_type (Btype *to_type) = 0;\n+  virtual tree reference_type (tree to_type) = 0;\n \n   // make type immutable\n-  virtual Btype *immutable_type (Btype *base) = 0;\n+  virtual tree immutable_type (tree base) = 0;\n \n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n@@ -201,346 +180,235 @@ class Backend\n   // one result, RESULT_STRUCT is a struct type to hold the results,\n   // and RESULTS may be ignored; if there are zero or one results,\n   // RESULT_STRUCT is NULL.\n-  virtual Btype *\n-  function_type (const Btyped_identifier &receiver,\n-\t\t const std::vector<Btyped_identifier> &parameters,\n-\t\t const std::vector<Btyped_identifier> &results,\n-\t\t Btype *result_struct, Location location)\n+  virtual tree function_type (const typed_identifier &receiver,\n+\t\t\t      const std::vector<typed_identifier> &parameters,\n+\t\t\t      const std::vector<typed_identifier> &results,\n+\t\t\t      tree result_struct, Location location)\n     = 0;\n \n-  virtual Btype *\n-  function_type_varadic (const Btyped_identifier &receiver,\n-\t\t\t const std::vector<Btyped_identifier> &parameters,\n-\t\t\t const std::vector<Btyped_identifier> &results,\n-\t\t\t Btype *result_struct, Location location)\n+  virtual tree\n+  function_type_varadic (const typed_identifier &receiver,\n+\t\t\t const std::vector<typed_identifier> &parameters,\n+\t\t\t const std::vector<typed_identifier> &results,\n+\t\t\t tree result_struct, Location location)\n     = 0;\n \n-  virtual Btype *function_ptr_type (Btype *result,\n-\t\t\t\t    const std::vector<Btype *> &praameters,\n-\t\t\t\t    Location location)\n+  virtual tree function_ptr_type (tree result,\n+\t\t\t\t  const std::vector<tree> &praameters,\n+\t\t\t\t  Location location)\n     = 0;\n \n   // Get a struct type.\n-  virtual Btype *struct_type (const std::vector<Btyped_identifier> &fields) = 0;\n+  virtual tree struct_type (const std::vector<typed_identifier> &fields) = 0;\n \n   // Get a union type.\n-  virtual Btype *union_type (const std::vector<Btyped_identifier> &fields) = 0;\n+  virtual tree union_type (const std::vector<typed_identifier> &fields) = 0;\n \n   // Get an array type.\n-  virtual Btype *array_type (Btype *element_type, Bexpression *length) = 0;\n-\n-  // Create a placeholder pointer type.  This is used for a named\n-  // pointer type, since in Go a pointer type may refer to itself.\n-  // NAME is the name of the type, and the location is where the named\n-  // type is defined.  This function is also used for unnamed function\n-  // types with multiple results, in which case the type has no name\n-  // and NAME will be empty.  FOR_FUNCTION is true if this is for a C\n-  // pointer to function type.  A Go func type is represented as a\n-  // pointer to a struct, and the first field of the struct is a C\n-  // pointer to function.  The return value will later be passed as\n-  // the first parameter to set_placeholder_pointer_type or\n-  // set_placeholder_function_type.\n-  virtual Btype *placeholder_pointer_type (const std::string &name, Location,\n-\t\t\t\t\t   bool for_function)\n-    = 0;\n-\n-  // Fill in a placeholder pointer type as a pointer.  This takes a\n-  // type returned by placeholder_pointer_type and arranges for it to\n-  // point to the type that TO_TYPE points to (that is, PLACEHOLDER\n-  // becomes the same type as TO_TYPE).  Returns true on success,\n-  // false on failure.\n-  virtual bool set_placeholder_pointer_type (Btype *placeholder, Btype *to_type)\n-    = 0;\n-\n-  // Fill in a placeholder pointer type as a function.  This takes a\n-  // type returned by placeholder_pointer_type and arranges for it to\n-  // become a real Go function type (which corresponds to a C/C++\n-  // pointer to function type).  FT will be something returned by the\n-  // function_type method.  Returns true on success, false on failure.\n-  virtual bool set_placeholder_function_type (Btype *placeholder, Btype *ft)\n-    = 0;\n-\n-  // Create a placeholder struct type.  This is used for a named\n-  // struct type, as with placeholder_pointer_type.  It is also used\n-  // for interface types, in which case NAME will be the empty string.\n-  virtual Btype *placeholder_struct_type (const std::string &name, Location)\n-    = 0;\n-\n-  // Fill in a placeholder struct type.  This takes a type returned by\n-  // placeholder_struct_type and arranges for it to become a real\n-  // struct type.  The parameter is as for struct_type.  Returns true\n-  // on success, false on failure.\n-  virtual bool\n-  set_placeholder_struct_type (Btype *placeholder,\n-\t\t\t       const std::vector<Btyped_identifier> &fields)\n-    = 0;\n-\n-  // Create a placeholder array type.  This is used for a named array\n-  // type, as with placeholder_pointer_type, to handle cases like\n-  // type A []*A.\n-  virtual Btype *placeholder_array_type (const std::string &name, Location) = 0;\n-\n-  // Fill in a placeholder array type.  This takes a type returned by\n-  // placeholder_array_type and arranges for it to become a real array\n-  // type.  The parameters are as for array_type.  Returns true on\n-  // success, false on failure.\n-  virtual bool set_placeholder_array_type (Btype *placeholder,\n-\t\t\t\t\t   Btype *element_type,\n-\t\t\t\t\t   Bexpression *length)\n-    = 0;\n+  virtual tree array_type (tree element_type, tree length) = 0;\n \n   // Return a named version of a type.  The location is the location\n   // of the type definition.  This will not be called for a type\n   // created via placeholder_pointer_type, placeholder_struct_type, or\n   // placeholder_array_type..  (It may be called for a pointer,\n   // struct, or array type in a case like \"type P *byte; type Q P\".)\n-  virtual Btype *named_type (const std::string &name, Btype *, Location) = 0;\n-\n-  // Create a marker for a circular pointer type.  Go pointer and\n-  // function types can refer to themselves in ways that are not\n-  // permitted in C/C++.  When a circular type is found, this function\n-  // is called for the circular reference.  This permits the backend\n-  // to decide how to handle such a type.  PLACEHOLDER is the\n-  // placeholder type which has already been created; if the backend\n-  // is prepared to handle a circular pointer type, it may simply\n-  // return PLACEHOLDER.  FOR_FUNCTION is true if this is for a\n-  // function type.\n-  //\n-  // For \"type P *P\" the sequence of calls will be\n-  //   bt1 = placeholder_pointer_type();\n-  //   bt2 = circular_pointer_type(bt1, false);\n-  //   set_placeholder_pointer_type(bt1, bt2);\n-  virtual Btype *circular_pointer_type (Btype *placeholder, bool for_function)\n-    = 0;\n-\n-  // Return whether the argument could be a special type created by\n-  // circular_pointer_type.  This is used to introduce explicit type\n-  // conversions where needed.  If circular_pointer_type returns its\n-  // PLACEHOLDER parameter, this may safely always return false.\n-  virtual bool is_circular_pointer_type (Btype *) = 0;\n+  virtual tree named_type (const std::string &name, tree, Location) = 0;\n \n   // Return the size of a type.\n-  virtual int64_t type_size (Btype *) = 0;\n+  virtual int64_t type_size (tree) = 0;\n \n   // Return the alignment of a type.\n-  virtual int64_t type_alignment (Btype *) = 0;\n+  virtual int64_t type_alignment (tree) = 0;\n \n   // Return the alignment of a struct field of this type.  This is\n   // normally the same as type_alignment, but not always.\n-  virtual int64_t type_field_alignment (Btype *) = 0;\n+  virtual int64_t type_field_alignment (tree) = 0;\n \n   // Return the offset of field INDEX in a struct type.  INDEX is the\n   // entry in the FIELDS std::vector parameter of struct_type or\n   // set_placeholder_struct_type.\n-  virtual int64_t type_field_offset (Btype *, size_t index) = 0;\n+  virtual int64_t type_field_offset (tree, size_t index) = 0;\n \n   // Expressions.\n \n   // Return an expression for a zero value of the given type.  This is\n   // used for cases such as local variable initialization and\n   // converting nil to other types.\n-  virtual Bexpression *zero_expression (Btype *) = 0;\n+  virtual tree zero_expression (tree) = 0;\n \n   // Create an error expression. This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bexpression *error_expression () = 0;\n+  virtual tree error_expression () = 0;\n \n   // return whether this is error_mark_node\n-  virtual bool is_error_expression (Bexpression *) = 0;\n+  virtual bool is_error_expression (tree) = 0;\n \n   // Create a nil pointer expression.\n-  virtual Bexpression *nil_pointer_expression () = 0;\n+  virtual tree nil_pointer_expression () = 0;\n \n-  virtual Bexpression *unit_expression () = 0;\n+  virtual tree unit_expression () = 0;\n \n   // Create a reference to a variable.\n-  virtual Bexpression *var_expression (Bvariable *var, Location) = 0;\n+  virtual tree var_expression (Bvariable *var, Location) = 0;\n \n   // Create an expression that indirects through the pointer expression EXPR\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n   // is known to point to a valid memory location.  BTYPE is the expected type\n   // of the indirected EXPR.\n-  virtual Bexpression *indirect_expression (Btype *btype, Bexpression *expr,\n-\t\t\t\t\t    bool known_valid, Location)\n+  virtual tree indirect_expression (tree btype, tree expr, bool known_valid,\n+\t\t\t\t    Location)\n     = 0;\n \n   // Return an expression that declares a constant named NAME with the\n   // constant value VAL in BTYPE.\n-  virtual Bexpression *named_constant_expression (Btype *btype,\n-\t\t\t\t\t\t  const std::string &name,\n-\t\t\t\t\t\t  Bexpression *val, Location)\n+  virtual tree named_constant_expression (tree btype, const std::string &name,\n+\t\t\t\t\t  tree val, Location)\n     = 0;\n \n   // Return an expression for the multi-precision integer VAL in BTYPE.\n-  virtual Bexpression *integer_constant_expression (Btype *btype, mpz_t val)\n-    = 0;\n+  virtual tree integer_constant_expression (tree btype, mpz_t val) = 0;\n \n   // Return an expression for the floating point value VAL in BTYPE.\n-  virtual Bexpression *float_constant_expression (Btype *btype, mpfr_t val) = 0;\n+  virtual tree float_constant_expression (tree btype, mpfr_t val) = 0;\n \n   // Return an expression for the complex value VAL in BTYPE.\n-  virtual Bexpression *complex_constant_expression (Btype *btype, mpc_t val)\n-    = 0;\n+  virtual tree complex_constant_expression (tree btype, mpc_t val) = 0;\n \n   // Return an expression for the string value VAL.\n-  virtual Bexpression *string_constant_expression (const std::string &val) = 0;\n+  virtual tree string_constant_expression (const std::string &val) = 0;\n \n   // Get a char literal\n-  virtual Bexpression *char_constant_expression (char c) = 0;\n+  virtual tree char_constant_expression (char c) = 0;\n \n   // Get a char literal\n-  virtual Bexpression *wchar_constant_expression (wchar_t c) = 0;\n+  virtual tree wchar_constant_expression (wchar_t c) = 0;\n \n   // Return an expression for the boolean value VAL.\n-  virtual Bexpression *boolean_constant_expression (bool val) = 0;\n+  virtual tree boolean_constant_expression (bool val) = 0;\n \n   // Return an expression for the real part of BCOMPLEX.\n-  virtual Bexpression *real_part_expression (Bexpression *bcomplex, Location)\n-    = 0;\n+  virtual tree real_part_expression (tree bcomplex, Location) = 0;\n \n   // Return an expression for the imaginary part of BCOMPLEX.\n-  virtual Bexpression *imag_part_expression (Bexpression *bcomplex, Location)\n-    = 0;\n+  virtual tree imag_part_expression (tree bcomplex, Location) = 0;\n \n   // Return an expression for the complex number (BREAL, BIMAG).\n-  virtual Bexpression *complex_expression (Bexpression *breal,\n-\t\t\t\t\t   Bexpression *bimag, Location)\n-    = 0;\n+  virtual tree complex_expression (tree breal, tree bimag, Location) = 0;\n \n   // Return an expression that converts EXPR to TYPE.\n-  virtual Bexpression *convert_expression (Btype *type, Bexpression *expr,\n-\t\t\t\t\t   Location)\n-    = 0;\n+  virtual tree convert_expression (tree type, tree expr, Location) = 0;\n \n   // Create an expression for the address of a function.  This is used to\n   // get the address of the code for a function.\n-  virtual Bexpression *function_code_expression (Bfunction *, Location) = 0;\n+  virtual tree function_code_expression (tree, Location) = 0;\n \n   // Create an expression that takes the address of an expression.\n-  virtual Bexpression *address_expression (Bexpression *, Location) = 0;\n+  virtual tree address_expression (tree, Location) = 0;\n \n   // Return an expression for the field at INDEX in BSTRUCT.\n-  virtual Bexpression *struct_field_expression (Bexpression *bstruct,\n-\t\t\t\t\t\tsize_t index, Location)\n+  virtual tree struct_field_expression (tree bstruct, size_t index, Location)\n     = 0;\n \n   // Create an expression that executes BSTAT before BEXPR.\n-  virtual Bexpression *compound_expression (Bstatement *bstat,\n-\t\t\t\t\t    Bexpression *bexpr, Location)\n-    = 0;\n+  virtual tree compound_expression (tree bstat, tree bexpr, Location) = 0;\n \n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n   // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n-  virtual Bexpression *\n-  conditional_expression (Bfunction *function, Btype *btype,\n-\t\t\t  Bexpression *condition, Bexpression *then_expr,\n-\t\t\t  Bexpression *else_expr, Location)\n+  virtual tree conditional_expression (tree function, tree btype,\n+\t\t\t\t       tree condition, tree then_expr,\n+\t\t\t\t       tree else_expr, Location)\n     = 0;\n \n   // Return an expression for the negation operation OP EXPR.\n   // Supported values of OP are enumerated in NegationOperator.\n-  virtual Bexpression *negation_expression (NegationOperator op,\n-\t\t\t\t\t    Bexpression *expr, Location)\n+  virtual tree negation_expression (NegationOperator op, tree expr, Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n-  virtual Bexpression *\n-  arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t    Bexpression *left, Bexpression *right,\n-\t\t\t\t    Location)\n+  virtual tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t\t tree left, tree right,\n+\t\t\t\t\t\t Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ComparisonOperator.\n-  virtual Bexpression *comparison_expression (ComparisonOperator op,\n-\t\t\t\t\t      Bexpression *left,\n-\t\t\t\t\t      Bexpression *right, Location)\n+  virtual tree comparison_expression (ComparisonOperator op, tree left,\n+\t\t\t\t      tree right, Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in LazyBooleanOperator.\n-  virtual Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n-\t\t\t\t\t\tBexpression *left,\n-\t\t\t\t\t\tBexpression *right, Location)\n+  virtual tree lazy_boolean_expression (LazyBooleanOperator op, tree left,\n+\t\t\t\t\ttree right, Location)\n     = 0;\n \n   // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n   // backend representation a of struct.  VALS must be in the same order as the\n   // corresponding fields in BTYPE.\n-  virtual Bexpression *\n-  constructor_expression (Btype *btype, const std::vector<Bexpression *> &vals,\n-\t\t\t  int, Location)\n+  virtual tree constructor_expression (tree btype,\n+\t\t\t\t       const std::vector<tree> &vals, int,\n+\t\t\t\t       Location)\n     = 0;\n \n   // Return an expression that constructs an array of BTYPE with INDEXES and\n   // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n   // in INDEXES must be in the same order as the corresponding value in VALS.\n-  virtual Bexpression *array_constructor_expression (\n-    Btype *btype, const std::vector<unsigned long> &indexes,\n-    const std::vector<Bexpression *> &vals, Location)\n+  virtual tree\n+  array_constructor_expression (tree btype,\n+\t\t\t\tconst std::vector<unsigned long> &indexes,\n+\t\t\t\tconst std::vector<tree> &vals, Location)\n     = 0;\n \n   // Return an expression for the address of BASE[INDEX].\n   // BASE has a pointer type.  This is used for slice indexing.\n-  virtual Bexpression *pointer_offset_expression (Bexpression *base,\n-\t\t\t\t\t\t  Bexpression *index, Location)\n-    = 0;\n+  virtual tree pointer_offset_expression (tree base, tree index, Location) = 0;\n \n   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n   // fixed-length array, not a slice.\n-  virtual Bexpression *array_index_expression (Bexpression *array,\n-\t\t\t\t\t       Bexpression *index, Location)\n-    = 0;\n+  virtual tree array_index_expression (tree array, tree index, Location) = 0;\n \n   // Create an expression for a call to FN with ARGS, taking place within\n   // caller CALLER.\n-  virtual Bexpression *call_expression (Bfunction *caller, Bexpression *fn,\n-\t\t\t\t\tconst std::vector<Bexpression *> &args,\n-\t\t\t\t\tBexpression *static_chain, Location)\n+  virtual tree call_expression (tree caller, tree fn,\n+\t\t\t\tconst std::vector<tree> &args,\n+\t\t\t\ttree static_chain, Location)\n     = 0;\n \n   // Statements.\n \n   // Create an error statement.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bstatement *error_statement () = 0;\n+  virtual tree error_statement () = 0;\n \n   // Create an expression statement within the specified function.\n-  virtual Bstatement *expression_statement (Bfunction *, Bexpression *) = 0;\n+  virtual tree expression_statement (tree, tree) = 0;\n \n   // Create a variable initialization statement in the specified\n   // function.  This initializes a local variable at the point in the\n   // program flow where it is declared.\n-  virtual Bstatement *init_statement (Bfunction *, Bvariable *var,\n-\t\t\t\t      Bexpression *init)\n-    = 0;\n+  virtual tree init_statement (tree, Bvariable *var, tree init) = 0;\n \n   // Create an assignment statement within the specified function.\n-  virtual Bstatement *assignment_statement (Bfunction *, Bexpression *lhs,\n-\t\t\t\t\t    Bexpression *rhs, Location)\n-    = 0;\n+  virtual tree assignment_statement (tree, tree lhs, tree rhs, Location) = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return.\n-  virtual Bstatement *\n-  return_statement (Bfunction *, const std::vector<Bexpression *> &, Location)\n-    = 0;\n+  virtual tree return_statement (tree, const std::vector<tree> &, Location) = 0;\n \n   // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n-  virtual Bstatement *if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t\t    Bblock *then_block, Bblock *else_block,\n-\t\t\t\t    Location)\n+  virtual tree if_statement (tree, tree condition, tree then_block,\n+\t\t\t     tree else_block, Location)\n     = 0;\n \n   // infinite loop expressions\n-  virtual Bexpression *loop_expression (Bblock *body, Location) = 0;\n+  virtual tree loop_expression (tree body, Location) = 0;\n \n   // exit expressions\n-  virtual Bexpression *exit_expression (Bexpression *condition, Location) = 0;\n+  virtual tree exit_expression (tree condition, Location) = 0;\n \n   // Create a switch statement where the case values are constants.\n   // CASES and STATEMENTS must have the same number of entries.  If\n@@ -549,26 +417,24 @@ class Backend\n   // either end with a goto statement or will fall through into\n   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n   // which need not be last.  FUNCTION is the current function.\n-  virtual Bstatement *\n-  switch_statement (Bfunction *function, Bexpression *value,\n-\t\t    const std::vector<std::vector<Bexpression *> > &cases,\n-\t\t    const std::vector<Bstatement *> &statements, Location)\n+  virtual tree switch_statement (tree function, tree value,\n+\t\t\t\t const std::vector<std::vector<tree> > &cases,\n+\t\t\t\t const std::vector<tree> &statements, Location)\n     = 0;\n \n   // Create a single statement from two statements.\n-  virtual Bstatement *compound_statement (Bstatement *, Bstatement *) = 0;\n+  virtual tree compound_statement (tree, tree) = 0;\n \n   // Create a single statement from a list of statements.\n-  virtual Bstatement *statement_list (const std::vector<Bstatement *> &) = 0;\n+  virtual tree statement_list (const std::vector<tree> &) = 0;\n \n   // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n   // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n   // if not NULL, it will always be executed.  This is used for handling defers\n   // in Go functions.  In C++, the resulting code is of this form:\n   //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n-  virtual Bstatement *\n-  exception_handler_statement (Bstatement *bstat, Bstatement *except_stmt,\n-\t\t\t       Bstatement *finally_stmt, Location)\n+  virtual tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t\t    tree finally_stmt, Location)\n     = 0;\n \n   // Blocks.\n@@ -583,22 +449,20 @@ class Backend\n   // the initial curly brace.  END_LOCATION is the location of the end\n   // of the block, more or less the location of the final curly brace.\n   // The statements will be added after the block is created.\n-  virtual Bblock *block (Bfunction *function, Bblock *enclosing,\n-\t\t\t const std::vector<Bvariable *> &vars,\n-\t\t\t Location start_location, Location end_location)\n+  virtual tree block (tree function, tree enclosing,\n+\t\t      const std::vector<Bvariable *> &vars,\n+\t\t      Location start_location, Location end_location)\n     = 0;\n \n   // Add the statements to a block.  The block is created first.  Then\n   // the statements are created.  Then the statements are added to the\n   // block.  This will called exactly once per block.  The vector may\n   // be empty if there are no statements.\n-  virtual void block_add_statements (Bblock *,\n-\t\t\t\t     const std::vector<Bstatement *> &)\n-    = 0;\n+  virtual void block_add_statements (tree, const std::vector<tree> &) = 0;\n \n   // Return the block as a statement.  This is used to include a block\n   // in a list of statements.\n-  virtual Bstatement *block_statement (Bblock *) = 0;\n+  virtual tree block_statement (tree) = 0;\n \n   // Variables.\n \n@@ -618,7 +482,7 @@ class Backend\n   // permit the linker to garbage collect the variable if it is not\n   // referenced.  LOCATION is where the variable was defined.\n   virtual Bvariable *global_variable (const std::string &name,\n-\t\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t\t      const std::string &asm_name, tree btype,\n \t\t\t\t      bool is_external, bool is_hidden,\n \t\t\t\t      bool in_unique_section, Location location)\n     = 0;\n@@ -629,7 +493,7 @@ class Backend\n   // global_variable_set_init to set the initial value.  If this is\n   // not called, the backend should initialize a global variable to 0.\n   // The init function may then assign a value to it.\n-  virtual void global_variable_set_init (Bvariable *, Bexpression *) = 0;\n+  virtual void global_variable_set_init (Bvariable *, tree) = 0;\n \n   // Create a local variable.  The frontend will create the local\n   // variables first, and then create the block which contains them.\n@@ -643,23 +507,23 @@ class Backend\n   // the function, as otherwise the variable would be on the heap).\n   // LOCATION is where the variable is defined.  For each local variable\n   // the frontend will call init_statement to set the initial value.\n-  virtual Bvariable *\n-  local_variable (Bfunction *function, const std::string &name, Btype *type,\n-\t\t  Bvariable *decl_var, bool is_address_taken, Location location)\n+  virtual Bvariable *local_variable (tree function, const std::string &name,\n+\t\t\t\t     tree type, Bvariable *decl_var,\n+\t\t\t\t     bool is_address_taken, Location location)\n     = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n-  virtual Bvariable *\n-  parameter_variable (Bfunction *function, const std::string &name, Btype *type,\n-\t\t      bool is_address_taken, Location location)\n+  virtual Bvariable *parameter_variable (tree function, const std::string &name,\n+\t\t\t\t\t tree type, bool is_address_taken,\n+\t\t\t\t\t Location location)\n     = 0;\n \n   // Create a static chain parameter.  This is the closure parameter.\n-  virtual Bvariable *static_chain_variable (Bfunction *function,\n-\t\t\t\t\t    const std::string &name,\n-\t\t\t\t\t    Btype *type, Location location)\n+  virtual Bvariable *static_chain_variable (tree function,\n+\t\t\t\t\t    const std::string &name, tree type,\n+\t\t\t\t\t    Location location)\n     = 0;\n \n   // Create a temporary variable.  A temporary variable has no name,\n@@ -673,10 +537,9 @@ class Backend\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n-  virtual Bvariable *\n-  temporary_variable (Bfunction *, Bblock *, Btype *, Bexpression *init,\n-\t\t      bool address_is_taken, Location location,\n-\t\t      Bstatement **pstatement)\n+  virtual Bvariable *temporary_variable (tree, tree, tree, tree init,\n+\t\t\t\t\t bool address_is_taken,\n+\t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n \n   // Create an implicit variable that is compiler-defined.  This is\n@@ -705,10 +568,10 @@ class Backend\n   // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n   //\n   // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n-  virtual Bvariable *\n-  implicit_variable (const std::string &name, const std::string &asm_name,\n-\t\t     Btype *type, bool is_hidden, bool is_constant,\n-\t\t     bool is_common, int64_t alignment)\n+  virtual Bvariable *implicit_variable (const std::string &name,\n+\t\t\t\t\tconst std::string &asm_name, tree type,\n+\t\t\t\t\tbool is_hidden, bool is_constant,\n+\t\t\t\t\tbool is_common, int64_t alignment)\n     = 0;\n \n   // Set the initial value of a variable created by implicit_variable.\n@@ -722,9 +585,9 @@ class Backend\n   // If IS_COMMON is true, INIT will be NULL, and the\n   // variable should be initialized to all zeros.\n   virtual void implicit_variable_set_init (Bvariable *, const std::string &name,\n-\t\t\t\t\t   Btype *type, bool is_hidden,\n+\t\t\t\t\t   tree type, bool is_hidden,\n \t\t\t\t\t   bool is_constant, bool is_common,\n-\t\t\t\t\t   Bexpression *init)\n+\t\t\t\t\t   tree init)\n     = 0;\n \n   // Create a reference to a named implicit variable defined in some\n@@ -734,7 +597,7 @@ class Backend\n   // variable in C.\n   virtual Bvariable *implicit_variable_reference (const std::string &name,\n \t\t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t\t  Btype *type)\n+\t\t\t\t\t\t  tree type)\n     = 0;\n \n   // Create a named immutable initialized data structure.  This is\n@@ -767,7 +630,7 @@ class Backend\n   // immutable_struct_set_init.\n   virtual Bvariable *\n   immutable_struct (const std::string &name, const std::string &asm_name,\n-\t\t    bool is_hidden, bool is_common, Btype *type, Location)\n+\t\t    bool is_hidden, bool is_common, tree type, Location)\n     = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n@@ -779,8 +642,7 @@ class Backend\n   // immutable_struct.\n   virtual void immutable_struct_set_init (Bvariable *, const std::string &name,\n \t\t\t\t\t  bool is_hidden, bool is_common,\n-\t\t\t\t\t  Btype *type, Location,\n-\t\t\t\t\t  Bexpression *initializer)\n+\t\t\t\t\t  tree type, Location, tree initializer)\n     = 0;\n \n   // Create a reference to a named immutable initialized data\n@@ -790,35 +652,35 @@ class Backend\n   // corresponds to an extern const global variable in C.\n   virtual Bvariable *immutable_struct_reference (const std::string &name,\n \t\t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t\t Btype *type, Location)\n+\t\t\t\t\t\t tree type, Location)\n     = 0;\n \n   // Labels.\n \n   // Create a new label.  NAME will be empty if this is a label\n   // created by the frontend for a loop construct.  The location is\n   // where the label is defined.\n-  virtual Blabel *label (Bfunction *, const std::string &name, Location) = 0;\n+  virtual tree label (tree, const std::string &name, Location) = 0;\n \n   // Create a statement which defines a label.  This statement will be\n   // put into the codestream at the point where the label should be\n   // defined.\n-  virtual Bstatement *label_definition_statement (Blabel *) = 0;\n+  virtual tree label_definition_statement (tree) = 0;\n \n   // Create a goto statement to a label.\n-  virtual Bstatement *goto_statement (Blabel *, Location) = 0;\n+  virtual tree goto_statement (tree, Location) = 0;\n \n   // Create an expression for the address of a label.  This is used to\n   // get the return address of a deferred function which may call\n   // recover.\n-  virtual Bexpression *label_address (Blabel *, Location) = 0;\n+  virtual tree label_address (tree, Location) = 0;\n \n   // Functions.\n \n   // Create an error function.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bfunction *error_function () = 0;\n+  virtual tree error_function () = 0;\n \n   // Bit flags to pass to the function method.\n \n@@ -857,49 +719,47 @@ class Backend\n   // string, is the name that should be used in the symbol table; this\n   // will be non-empty if a magic extern comment is used.  FLAGS is\n   // bit flags described above.\n-  virtual Bfunction *function (Btype *fntype, const std::string &name,\n-\t\t\t       const std::string &asm_name, unsigned int flags,\n-\t\t\t       Location)\n+  virtual tree function (tree fntype, const std::string &name,\n+\t\t\t const std::string &asm_name, unsigned int flags,\n+\t\t\t Location)\n     = 0;\n \n-  virtual Btype *specify_abi_attribute (Btype *type, Rust::ABI abi) = 0;\n+  virtual tree specify_abi_attribute (tree type, Rust::ABI abi) = 0;\n \n   // Create a statement that runs all deferred calls for FUNCTION.  This should\n   // be a statement that looks like this in C++:\n   //   finish:\n   //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n-  virtual Bstatement *\n-  function_defer_statement (Bfunction *function, Bexpression *undefer,\n-\t\t\t    Bexpression *check_defer, Location)\n+  virtual tree function_defer_statement (tree function, tree undefer,\n+\t\t\t\t\t tree check_defer, Location)\n     = 0;\n \n   // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n   // This will only be called for a function definition.  Returns true on\n   // success, false on failure.\n   virtual bool\n-  function_set_parameters (Bfunction *function,\n+  function_set_parameters (tree function,\n \t\t\t   const std::vector<Bvariable *> &param_vars)\n     = 0;\n \n   // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n   // true on success, false on failure.\n-  virtual bool function_set_body (Bfunction *function, Bstatement *code_stmt)\n-    = 0;\n+  virtual bool function_set_body (tree function, tree code_stmt) = 0;\n \n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n-  virtual Bfunction *lookup_gcc_builtin (const std::string &) = 0;\n+  virtual tree lookup_gcc_builtin (const std::string &) = 0;\n \n-  virtual Bfunction *lookup_builtin_by_rust_name (const std::string &) = 0;\n+  virtual tree lookup_builtin_by_rust_name (const std::string &) = 0;\n \n   // Utility.\n \n   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n   // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n   virtual void\n-  write_global_definitions (const std::vector<Btype *> &type_decls,\n-\t\t\t    const std::vector<Bexpression *> &constant_decls,\n-\t\t\t    const std::vector<Bfunction *> &function_decls,\n+  write_global_definitions (const std::vector<tree> &type_decls,\n+\t\t\t    const std::vector<tree> &constant_decls,\n+\t\t\t    const std::vector<tree> &function_decls,\n \t\t\t    const std::vector<Bvariable *> &variable_decls)\n     = 0;\n "}, {"sha": "12df7699879f9ba4bac1cb2ae70773d2da7a3719", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 521, "deletions": 921, "changes": 1442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -53,58 +53,6 @@\n \n // TODO: this will have to be significantly modified to work with Rust\n \n-// A class wrapping a tree.\n-\n-class Gcc_tree\n-{\n-public:\n-  Gcc_tree (tree t) : t_ (t) {}\n-\n-  tree get_tree () const { return this->t_; }\n-\n-  void set_tree (tree t) { this->t_ = t; }\n-\n-private:\n-  tree t_;\n-};\n-\n-// In gcc, types, expressions, and statements are all trees.\n-class Btype : public Gcc_tree\n-{\n-public:\n-  Btype (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bexpression : public Gcc_tree\n-{\n-public:\n-  Bexpression (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bstatement : public Gcc_tree\n-{\n-public:\n-  Bstatement (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bfunction : public Gcc_tree\n-{\n-public:\n-  Bfunction (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bblock : public Gcc_tree\n-{\n-public:\n-  Bblock (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Blabel : public Gcc_tree\n-{\n-public:\n-  Blabel (tree t) : Gcc_tree (t) {}\n-};\n-\n // Bvariable is a bit more complicated, because of zero-sized types.\n // The GNU linker does not permit dynamic variables with zero size.\n // When we see such a variable, we generate a version of the type with\n@@ -159,22 +107,17 @@ class Gcc_backend : public Backend\n public:\n   Gcc_backend ();\n \n-  void debug (Btype *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bexpression *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bstatement *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bfunction *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bblock *t) { debug_tree (t->get_tree ()); };\n+  void debug (tree t) { debug_tree (t); };\n   void debug (Bvariable *t) { debug_tree (t->get_decl ()); };\n-  void debug (Blabel *t) { debug_tree (t->get_tree ()); };\n \n   // Types.\n-  Btype *error_type () { return this->make_type (error_mark_node); }\n+  tree error_type () { return error_mark_node; }\n \n-  Btype *void_type () { return this->make_type (void_type_node); }\n+  tree void_type () { return void_type_node; }\n \n-  Btype *unit_type ()\n+  tree unit_type ()\n   {\n-    static Btype *unit_type;\n+    static tree unit_type;\n     if (unit_type == nullptr)\n       {\n \tauto unit_type_node = integer_type (true, 0);\n@@ -185,18 +128,18 @@ class Gcc_backend : public Backend\n     return unit_type;\n   }\n \n-  Btype *bool_type () { return this->make_type (boolean_type_node); }\n+  tree bool_type () { return boolean_type_node; }\n \n-  Btype *char_type () { return this->make_type (char_type_node); }\n+  tree char_type () { return char_type_node; }\n \n-  bool const_size_cast (Bexpression *expr, size_t *result)\n+  bool const_size_cast (tree expr, size_t *result)\n   {\n-    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+    rust_assert (TREE_CONSTANT (expr));\n \n     unsigned char buf[sizeof (size_t) + 1];\n     memset (buf, 0, sizeof (buf));\n \n-    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n     if (ret <= 0)\n       return false;\n \n@@ -205,344 +148,276 @@ class Gcc_backend : public Backend\n     return true;\n   }\n \n-  std::string const_size_val_to_string (Bexpression *expr)\n+  std::string const_size_val_to_string (tree expr)\n   {\n-    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+    rust_assert (TREE_CONSTANT (expr));\n \n     unsigned char buf[sizeof (size_t) + 1];\n     memset (buf, 0, sizeof (buf));\n \n-    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n     rust_assert (ret > 0);\n \n     size_t *ptr = (size_t *) buf;\n     return std::to_string (*ptr);\n   }\n \n-  bool const_values_equal (Bexpression *a, Bexpression *b)\n+  bool const_values_equal (tree a, tree b)\n   {\n-    return operand_equal_p (a->get_tree (), b->get_tree (),\n-\t\t\t    OEP_ONLY_CONST | OEP_PURE_SAME);\n+    return operand_equal_p (a, b, OEP_ONLY_CONST | OEP_PURE_SAME);\n     // printf (\"comparing!\\n\");\n     // debug_tree (a->get_tree ());\n     // debug_tree (b->get_tree ());\n     // printf (\"ok = %s\\n\", ok ? \"true\" : \"false\");\n   }\n \n-  Btype *wchar_type ()\n+  tree wchar_type ()\n   {\n     tree wchar = make_unsigned_type (32);\n     TYPE_STRING_FLAG (wchar) = 1;\n-    return this->make_type (wchar);\n+    return wchar;\n   }\n \n   int get_pointer_size ();\n \n-  Btype *raw_str_type ();\n-\n-  Btype *integer_type (bool, int);\n-\n-  Btype *float_type (int);\n-\n-  Btype *complex_type (int);\n-\n-  Btype *pointer_type (Btype *);\n-\n-  Btype *reference_type (Btype *);\n-\n-  Btype *immutable_type (Btype *);\n-\n-  Btype *specify_abi_attribute (Btype *, Rust::ABI);\n-\n-  Btype *insert_type_attribute (Btype *, const std::string &);\n-\n-  Btype *function_type (const Btyped_identifier &,\n-\t\t\tconst std::vector<Btyped_identifier> &,\n-\t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n-\t\t\tconst Location);\n+  tree raw_str_type ();\n \n-  Btype *function_type_varadic (const Btyped_identifier &,\n-\t\t\t\tconst std::vector<Btyped_identifier> &,\n-\t\t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n-\t\t\t\tconst Location);\n+  tree integer_type (bool, int);\n \n-  Btype *function_ptr_type (Btype *, const std::vector<Btype *> &, Location);\n+  tree float_type (int);\n \n-  Btype *struct_type (const std::vector<Btyped_identifier> &);\n+  tree complex_type (int);\n \n-  Btype *union_type (const std::vector<Btyped_identifier> &);\n+  tree pointer_type (tree);\n \n-  Btype *array_type (Btype *, Bexpression *);\n+  tree reference_type (tree);\n \n-  Btype *placeholder_pointer_type (const std::string &, Location, bool);\n+  tree immutable_type (tree);\n \n-  bool set_placeholder_pointer_type (Btype *, Btype *);\n+  tree specify_abi_attribute (tree, Rust::ABI);\n \n-  bool set_placeholder_function_type (Btype *, Btype *);\n+  tree insert_type_attribute (tree, const std::string &);\n \n-  Btype *placeholder_struct_type (const std::string &, Location);\n+  tree function_type (const typed_identifier &,\n+\t\t      const std::vector<typed_identifier> &,\n+\t\t      const std::vector<typed_identifier> &, tree,\n+\t\t      const Location);\n \n-  bool set_placeholder_struct_type (Btype *placeholder,\n-\t\t\t\t    const std::vector<Btyped_identifier> &);\n+  tree function_type_varadic (const typed_identifier &,\n+\t\t\t      const std::vector<typed_identifier> &,\n+\t\t\t      const std::vector<typed_identifier> &, tree,\n+\t\t\t      const Location);\n \n-  Btype *placeholder_array_type (const std::string &, Location);\n+  tree function_ptr_type (tree, const std::vector<tree> &, Location);\n \n-  bool set_placeholder_array_type (Btype *, Btype *, Bexpression *);\n+  tree struct_type (const std::vector<typed_identifier> &);\n \n-  Btype *named_type (const std::string &, Btype *, Location);\n+  tree union_type (const std::vector<typed_identifier> &);\n \n-  Btype *circular_pointer_type (Btype *, bool);\n+  tree array_type (tree, tree);\n \n-  bool is_circular_pointer_type (Btype *);\n+  tree named_type (const std::string &, tree, Location);\n \n-  int64_t type_size (Btype *);\n+  int64_t type_size (tree);\n \n-  int64_t type_alignment (Btype *);\n+  int64_t type_alignment (tree);\n \n-  int64_t type_field_alignment (Btype *);\n+  int64_t type_field_alignment (tree);\n \n-  int64_t type_field_offset (Btype *, size_t index);\n+  int64_t type_field_offset (tree, size_t index);\n \n   // Expressions.\n \n-  Bexpression *zero_expression (Btype *);\n+  tree zero_expression (tree);\n \n-  Bexpression *error_expression ()\n-  {\n-    return this->make_expression (error_mark_node);\n-  }\n+  tree error_expression () { return error_mark_node; }\n \n-  bool is_error_expression (Bexpression *expr)\n-  {\n-    return expr->get_tree () == error_mark_node;\n-  }\n+  bool is_error_expression (tree expr) { return expr == error_mark_node; }\n \n-  Bexpression *nil_pointer_expression ()\n-  {\n-    return this->make_expression (null_pointer_node);\n-  }\n+  tree nil_pointer_expression () { return null_pointer_node; }\n \n-  Bexpression *unit_expression ()\n-  {\n-    return this->make_expression (integer_zero_node);\n-  }\n+  tree unit_expression () { return integer_zero_node; }\n \n-  Bexpression *var_expression (Bvariable *var, Location);\n+  tree var_expression (Bvariable *var, Location);\n \n-  Bexpression *indirect_expression (Btype *, Bexpression *expr,\n-\t\t\t\t    bool known_valid, Location);\n+  tree indirect_expression (tree, tree expr, bool known_valid, Location);\n \n-  Bexpression *named_constant_expression (Btype *btype, const std::string &name,\n-\t\t\t\t\t  Bexpression *val, Location);\n+  tree named_constant_expression (tree type, const std::string &name, tree val,\n+\t\t\t\t  Location);\n \n-  Bexpression *integer_constant_expression (Btype *btype, mpz_t val);\n+  tree integer_constant_expression (tree type, mpz_t val);\n \n-  Bexpression *float_constant_expression (Btype *btype, mpfr_t val);\n+  tree float_constant_expression (tree type, mpfr_t val);\n \n-  Bexpression *complex_constant_expression (Btype *btype, mpc_t val);\n+  tree complex_constant_expression (tree type, mpc_t val);\n \n-  Bexpression *string_constant_expression (const std::string &val);\n+  tree string_constant_expression (const std::string &val);\n \n-  Bexpression *wchar_constant_expression (wchar_t c);\n+  tree wchar_constant_expression (wchar_t c);\n \n-  Bexpression *char_constant_expression (char c);\n+  tree char_constant_expression (char c);\n \n-  Bexpression *boolean_constant_expression (bool val);\n+  tree boolean_constant_expression (bool val);\n \n-  Bexpression *real_part_expression (Bexpression *bcomplex, Location);\n+  tree real_part_expression (tree bcomplex, Location);\n \n-  Bexpression *imag_part_expression (Bexpression *bcomplex, Location);\n+  tree imag_part_expression (tree bcomplex, Location);\n \n-  Bexpression *complex_expression (Bexpression *breal, Bexpression *bimag,\n-\t\t\t\t   Location);\n+  tree complex_expression (tree breal, tree bimag, Location);\n \n-  Bexpression *convert_expression (Btype *type, Bexpression *expr, Location);\n+  tree convert_expression (tree type, tree expr, Location);\n \n-  Bexpression *function_code_expression (Bfunction *, Location);\n+  tree function_code_expression (tree, Location);\n \n-  Bexpression *address_expression (Bexpression *, Location);\n+  tree address_expression (tree, Location);\n \n-  Bexpression *struct_field_expression (Bexpression *, size_t, Location);\n+  tree struct_field_expression (tree, size_t, Location);\n \n-  Bexpression *compound_expression (Bstatement *, Bexpression *, Location);\n+  tree compound_expression (tree, tree, Location);\n \n-  Bexpression *conditional_expression (Bfunction *, Btype *, Bexpression *,\n-\t\t\t\t       Bexpression *, Bexpression *, Location);\n+  tree conditional_expression (tree, tree, tree, tree, tree, Location);\n \n-  Bexpression *negation_expression (NegationOperator op, Bexpression *expr,\n-\t\t\t\t    Location);\n+  tree negation_expression (NegationOperator op, tree expr, Location);\n \n-  Bexpression *arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t\t Bexpression *left,\n-\t\t\t\t\t\t Bexpression *right, Location);\n+  tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t tree left, tree right, Location);\n \n-  Bexpression *comparison_expression (ComparisonOperator op, Bexpression *left,\n-\t\t\t\t      Bexpression *right, Location);\n+  tree comparison_expression (ComparisonOperator op, tree left, tree right,\n+\t\t\t      Location);\n \n-  Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n-\t\t\t\t\tBexpression *left, Bexpression *right,\n-\t\t\t\t\tLocation);\n+  tree lazy_boolean_expression (LazyBooleanOperator op, tree left, tree right,\n+\t\t\t\tLocation);\n \n-  Bexpression *constructor_expression (Btype *,\n-\t\t\t\t       const std::vector<Bexpression *> &, int,\n-\t\t\t\t       Location);\n+  tree constructor_expression (tree, const std::vector<tree> &, int, Location);\n \n-  Bexpression *array_constructor_expression (Btype *,\n-\t\t\t\t\t     const std::vector<unsigned long> &,\n-\t\t\t\t\t     const std::vector<Bexpression *> &,\n-\t\t\t\t\t     Location);\n+  tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n+\t\t\t\t     const std::vector<tree> &, Location);\n \n-  Bexpression *pointer_offset_expression (Bexpression *base,\n-\t\t\t\t\t  Bexpression *offset, Location);\n+  tree pointer_offset_expression (tree base, tree offset, Location);\n \n-  Bexpression *array_index_expression (Bexpression *array, Bexpression *index,\n-\t\t\t\t       Location);\n+  tree array_index_expression (tree array, tree index, Location);\n \n-  Bexpression *call_expression (Bfunction *caller, Bexpression *fn,\n-\t\t\t\tconst std::vector<Bexpression *> &args,\n-\t\t\t\tBexpression *static_chain, Location);\n+  tree call_expression (tree caller, tree fn, const std::vector<tree> &args,\n+\t\t\ttree static_chain, Location);\n \n   // Statements.\n \n-  Bstatement *error_statement ()\n-  {\n-    return this->make_statement (error_mark_node);\n-  }\n+  tree error_statement () { return error_mark_node; }\n \n-  Bstatement *expression_statement (Bfunction *, Bexpression *);\n+  tree expression_statement (tree, tree);\n \n-  Bstatement *init_statement (Bfunction *, Bvariable *var, Bexpression *init);\n+  tree init_statement (tree, Bvariable *var, tree init);\n \n-  Bstatement *assignment_statement (Bfunction *, Bexpression *lhs,\n-\t\t\t\t    Bexpression *rhs, Location);\n+  tree assignment_statement (tree, tree lhs, tree rhs, Location);\n \n-  Bstatement *return_statement (Bfunction *, const std::vector<Bexpression *> &,\n-\t\t\t\tLocation);\n+  tree return_statement (tree, const std::vector<tree> &, Location);\n \n-  Bstatement *if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t    Bblock *then_block, Bblock *else_block, Location);\n+  tree if_statement (tree, tree condition, tree then_block, tree else_block,\n+\t\t     Location);\n \n-  Bstatement *\n-  switch_statement (Bfunction *function, Bexpression *value,\n-\t\t    const std::vector<std::vector<Bexpression *> > &cases,\n-\t\t    const std::vector<Bstatement *> &statements, Location);\n+  tree switch_statement (tree function, tree value,\n+\t\t\t const std::vector<std::vector<tree>> &cases,\n+\t\t\t const std::vector<tree> &statements, Location);\n \n-  Bstatement *compound_statement (Bstatement *, Bstatement *);\n+  tree compound_statement (tree, tree);\n \n-  Bstatement *statement_list (const std::vector<Bstatement *> &);\n+  tree statement_list (const std::vector<tree> &);\n \n-  Bstatement *exception_handler_statement (Bstatement *bstat,\n-\t\t\t\t\t   Bstatement *except_stmt,\n-\t\t\t\t\t   Bstatement *finally_stmt, Location);\n+  tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t    tree finally_stmt, Location);\n \n-  Bexpression *loop_expression (Bblock *body, Location);\n+  tree loop_expression (tree body, Location);\n \n-  Bexpression *exit_expression (Bexpression *condition, Location);\n+  tree exit_expression (tree condition, Location);\n \n   // Blocks.\n \n-  Bblock *block (Bfunction *, Bblock *, const std::vector<Bvariable *> &,\n-\t\t Location, Location);\n+  tree block (tree, tree, const std::vector<Bvariable *> &, Location, Location);\n \n-  void block_add_statements (Bblock *, const std::vector<Bstatement *> &);\n+  void block_add_statements (tree, const std::vector<tree> &);\n \n-  Bstatement *block_statement (Bblock *);\n+  tree block_statement (tree);\n \n   // Variables.\n \n   Bvariable *error_variable () { return new Bvariable (error_mark_node); }\n \n   Bvariable *global_variable (const std::string &var_name,\n-\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t      const std::string &asm_name, tree type,\n \t\t\t      bool is_external, bool is_hidden,\n \t\t\t      bool in_unique_section, Location location);\n \n-  void global_variable_set_init (Bvariable *, Bexpression *);\n+  void global_variable_set_init (Bvariable *, tree);\n \n-  Bvariable *local_variable (Bfunction *, const std::string &, Btype *,\n-\t\t\t     Bvariable *, bool, Location);\n+  Bvariable *local_variable (tree, const std::string &, tree, Bvariable *, bool,\n+\t\t\t     Location);\n \n-  Bvariable *parameter_variable (Bfunction *, const std::string &, Btype *,\n-\t\t\t\t bool, Location);\n+  Bvariable *parameter_variable (tree, const std::string &, tree, bool,\n+\t\t\t\t Location);\n \n-  Bvariable *static_chain_variable (Bfunction *, const std::string &, Btype *,\n-\t\t\t\t    Location);\n+  Bvariable *static_chain_variable (tree, const std::string &, tree, Location);\n \n-  Bvariable *temporary_variable (Bfunction *, Bblock *, Btype *, Bexpression *,\n-\t\t\t\t bool, Location, Bstatement **);\n+  Bvariable *temporary_variable (tree, tree, tree, tree, bool, Location,\n+\t\t\t\t tree *);\n \n-  Bvariable *implicit_variable (const std::string &, const std::string &,\n-\t\t\t\tBtype *, bool, bool, bool, int64_t);\n+  Bvariable *implicit_variable (const std::string &, const std::string &, tree,\n+\t\t\t\tbool, bool, bool, int64_t);\n \n-  void implicit_variable_set_init (Bvariable *, const std::string &, Btype *,\n-\t\t\t\t   bool, bool, bool, Bexpression *);\n+  void implicit_variable_set_init (Bvariable *, const std::string &, tree, bool,\n+\t\t\t\t   bool, bool, tree);\n \n   Bvariable *implicit_variable_reference (const std::string &,\n-\t\t\t\t\t  const std::string &, Btype *);\n+\t\t\t\t\t  const std::string &, tree);\n \n   Bvariable *immutable_struct (const std::string &, const std::string &, bool,\n-\t\t\t       bool, Btype *, Location);\n+\t\t\t       bool, tree, Location);\n \n   void immutable_struct_set_init (Bvariable *, const std::string &, bool, bool,\n-\t\t\t\t  Btype *, Location, Bexpression *);\n+\t\t\t\t  tree, Location, tree);\n \n   Bvariable *immutable_struct_reference (const std::string &,\n-\t\t\t\t\t const std::string &, Btype *,\n-\t\t\t\t\t Location);\n+\t\t\t\t\t const std::string &, tree, Location);\n \n   // Labels.\n \n-  Blabel *label (Bfunction *, const std::string &name, Location);\n+  tree label (tree, const std::string &name, Location);\n \n-  Bstatement *label_definition_statement (Blabel *);\n+  tree label_definition_statement (tree);\n \n-  Bstatement *goto_statement (Blabel *, Location);\n+  tree goto_statement (tree, Location);\n \n-  Bexpression *label_address (Blabel *, Location);\n+  tree label_address (tree, Location);\n \n   // Functions.\n \n-  Bfunction *error_function () { return this->make_function (error_mark_node); }\n+  tree error_function () { return error_mark_node; }\n \n-  Bfunction *function (Btype *fntype, const std::string &name,\n-\t\t       const std::string &asm_name, unsigned int flags,\n-\t\t       Location);\n+  tree function (tree fntype, const std::string &name,\n+\t\t const std::string &asm_name, unsigned int flags, Location);\n \n-  Bstatement *function_defer_statement (Bfunction *function,\n-\t\t\t\t\tBexpression *undefer,\n-\t\t\t\t\tBexpression *defer, Location);\n+  tree function_defer_statement (tree function, tree undefer, tree defer,\n+\t\t\t\t Location);\n \n-  bool function_set_parameters (Bfunction *function,\n+  bool function_set_parameters (tree function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n \n-  bool function_set_body (Bfunction *function, Bstatement *code_stmt);\n+  bool function_set_body (tree function, tree code_stmt);\n \n-  Bfunction *lookup_gcc_builtin (const std::string &);\n+  tree lookup_gcc_builtin (const std::string &);\n \n-  Bfunction *lookup_builtin_by_rust_name (const std::string &);\n+  tree lookup_builtin_by_rust_name (const std::string &);\n \n-  void write_global_definitions (const std::vector<Btype *> &,\n-\t\t\t\t const std::vector<Bexpression *> &,\n-\t\t\t\t const std::vector<Bfunction *> &,\n+  void write_global_definitions (const std::vector<tree> &,\n+\t\t\t\t const std::vector<tree> &,\n+\t\t\t\t const std::vector<tree> &,\n \t\t\t\t const std::vector<Bvariable *> &);\n \n   void write_export_data (const char *bytes, unsigned int size);\n \n private:\n-  // Make a Bexpression from a tree.\n-  Bexpression *make_expression (tree t) { return new Bexpression (t); }\n-\n-  // Make a Bstatement from a tree.\n-  Bstatement *make_statement (tree t) { return new Bstatement (t); }\n+  tree fill_in_fields (tree, const std::vector<typed_identifier> &);\n \n-  // Make a Btype from a tree.\n-  Btype *make_type (tree t) { return new Btype (t); }\n-\n-  Bfunction *make_function (tree t) { return new Bfunction (t); }\n-\n-  Btype *fill_in_fields (Btype *, const std::vector<Btyped_identifier> &);\n-\n-  Btype *fill_in_array (Btype *, Btype *, Bexpression *);\n+  tree fill_in_array (tree, tree, tree);\n \n   tree non_zero_size_type (tree);\n \n@@ -558,7 +433,7 @@ class Gcc_backend : public Backend\n \t\t       int flags);\n \n   // A mapping of the GCC built-ins exposed to GCCRust.\n-  std::map<std::string, Bfunction *> builtin_functions_;\n+  std::map<std::string, tree> builtin_functions_;\n   std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n \n@@ -810,15 +685,15 @@ Gcc_backend::get_pointer_size ()\n   return POINTER_SIZE;\n }\n \n-Btype *\n+tree\n Gcc_backend::raw_str_type ()\n {\n   tree char_ptr = build_pointer_type (char_type_node);\n   tree const_char_type = build_qualified_type (char_ptr, TYPE_QUAL_CONST);\n-  return this->make_type (const_char_type);\n+  return const_char_type;\n }\n \n-Btype *\n+tree\n Gcc_backend::integer_type (bool is_unsigned, int bits)\n {\n   tree type;\n@@ -848,12 +723,12 @@ Gcc_backend::integer_type (bool is_unsigned, int bits)\n       else\n \ttype = make_signed_type (bits);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get an unnamed float type.\n \n-Btype *\n+tree\n Gcc_backend::float_type (int bits)\n {\n   tree type;\n@@ -869,12 +744,12 @@ Gcc_backend::float_type (int bits)\n       TYPE_PRECISION (type) = bits;\n       layout_type (type);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get an unnamed complex type.\n \n-Btype *\n+tree\n Gcc_backend::complex_type (int bits)\n {\n   tree type;\n@@ -891,49 +766,46 @@ Gcc_backend::complex_type (int bits)\n       layout_type (type);\n       type = build_complex_type (type);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get a pointer type.\n \n-Btype *\n-Gcc_backend::pointer_type (Btype *to_type)\n+tree\n+Gcc_backend::pointer_type (tree to_type)\n {\n-  tree to_type_tree = to_type->get_tree ();\n-  if (to_type_tree == error_mark_node)\n+  if (to_type == error_mark_node)\n     return this->error_type ();\n-  tree type = build_pointer_type (to_type_tree);\n-  return this->make_type (type);\n+  tree type = build_pointer_type (to_type);\n+  return type;\n }\n \n // Get a reference type.\n \n-Btype *\n-Gcc_backend::reference_type (Btype *to_type)\n+tree\n+Gcc_backend::reference_type (tree to_type)\n {\n-  tree to_type_tree = to_type->get_tree ();\n-  if (to_type_tree == error_mark_node)\n+  if (to_type == error_mark_node)\n     return this->error_type ();\n-  tree type = build_reference_type (to_type_tree);\n-  return this->make_type (type);\n+  tree type = build_reference_type (to_type);\n+  return type;\n }\n \n // Get immutable type\n \n-Btype *\n-Gcc_backend::immutable_type (Btype *base)\n+tree\n+Gcc_backend::immutable_type (tree base)\n {\n-  tree type_tree = base->get_tree ();\n-  if (type_tree == error_mark_node)\n+  if (base == error_mark_node)\n     return this->error_type ();\n-  tree constified = build_qualified_type (type_tree, TYPE_QUAL_CONST);\n-  return this->make_type (constified);\n+  tree constified = build_qualified_type (base, TYPE_QUAL_CONST);\n+  return constified;\n }\n \n // ABI\n \n-Btype *\n-Gcc_backend::specify_abi_attribute (Btype *type, Rust::ABI abi)\n+tree\n+Gcc_backend::specify_abi_attribute (tree type, Rust::ABI abi)\n {\n   std::string abi_string;\n   switch (abi)\n@@ -959,46 +831,46 @@ Gcc_backend::specify_abi_attribute (Btype *type, Rust::ABI abi)\n   return insert_type_attribute (type, abi_string);\n }\n \n-Btype *\n-Gcc_backend::insert_type_attribute (Btype *type, const std::string &attrname)\n+tree\n+Gcc_backend::insert_type_attribute (tree type, const std::string &attrname)\n {\n   tree ident = get_identifier (attrname.c_str ());\n \n   tree attribs = NULL_TREE;\n-  tree old_attrs = TYPE_ATTRIBUTES (type->get_tree ());\n+  tree old_attrs = TYPE_ATTRIBUTES (type);\n   if (old_attrs)\n     attribs = merge_type_attributes (old_attrs,\n \t\t\t\t     tree_cons (ident, NULL_TREE, NULL_TREE));\n   else\n     attribs = tree_cons (ident, NULL_TREE, NULL_TREE);\n \n-  tree res = build_type_attribute_variant (type->get_tree (), attribs);\n-  return this->make_type (res);\n+  tree res = build_type_attribute_variant (type, attribs);\n+  return res;\n }\n \n // Make a function type.\n \n-Btype *\n-Gcc_backend::function_type (const Btyped_identifier &receiver,\n-\t\t\t    const std::vector<Btyped_identifier> &parameters,\n-\t\t\t    const std::vector<Btyped_identifier> &results,\n-\t\t\t    Btype *result_struct, Location)\n+tree\n+Gcc_backend::function_type (const typed_identifier &receiver,\n+\t\t\t    const std::vector<typed_identifier> &parameters,\n+\t\t\t    const std::vector<typed_identifier> &results,\n+\t\t\t    tree result_struct, Location)\n {\n   tree args = NULL_TREE;\n   tree *pp = &args;\n-  if (receiver.btype != NULL)\n+  if (receiver.type != NULL_TREE)\n     {\n-      tree t = receiver.btype->get_tree ();\n+      tree t = receiver.type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n \n-  for (std::vector<Btyped_identifier>::const_iterator p = parameters.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n        p != parameters.end (); ++p)\n     {\n-      tree t = p->btype->get_tree ();\n+      tree t = p->type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n@@ -1013,11 +885,11 @@ Gcc_backend::function_type (const Btyped_identifier &receiver,\n   if (results.empty ())\n     result = void_type_node;\n   else if (results.size () == 1)\n-    result = results.front ().btype->get_tree ();\n+    result = results.front ().type;\n   else\n     {\n       gcc_assert (result_struct != NULL);\n-      result = result_struct->get_tree ();\n+      result = result_struct;\n     }\n   if (result == error_mark_node)\n     return this->error_type ();\n@@ -1034,32 +906,32 @@ Gcc_backend::function_type (const Btyped_identifier &receiver,\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n-Btype *\n+tree\n Gcc_backend::function_type_varadic (\n-  const Btyped_identifier &receiver,\n-  const std::vector<Btyped_identifier> &parameters,\n-  const std::vector<Btyped_identifier> &results, Btype *result_struct, Location)\n+  const typed_identifier &receiver,\n+  const std::vector<typed_identifier> &parameters,\n+  const std::vector<typed_identifier> &results, tree result_struct, Location)\n {\n-  size_t n = parameters.size () + (receiver.btype != NULL ? 1 : 0);\n+  size_t n = parameters.size () + (receiver.type != NULL_TREE ? 1 : 0);\n   tree *args = XALLOCAVEC (tree, n);\n   size_t offs = 0;\n \n-  if (receiver.btype != NULL)\n+  if (receiver.type != NULL_TREE)\n     {\n-      tree t = receiver.btype->get_tree ();\n+      tree t = receiver.type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n \n       args[offs++] = t;\n     }\n \n-  for (std::vector<Btyped_identifier>::const_iterator p = parameters.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n        p != parameters.end (); ++p)\n     {\n-      tree t = p->btype->get_tree ();\n+      tree t = p->type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       args[offs++] = t;\n@@ -1069,11 +941,11 @@ Gcc_backend::function_type_varadic (\n   if (results.empty ())\n     result = void_type_node;\n   else if (results.size () == 1)\n-    result = results.front ().btype->get_tree ();\n+    result = results.front ().type;\n   else\n     {\n-      gcc_assert (result_struct != NULL);\n-      result = result_struct->get_tree ();\n+      gcc_assert (result_struct != NULL_TREE);\n+      result = result_struct;\n     }\n   if (result == error_mark_node)\n     return this->error_type ();\n@@ -1090,113 +962,105 @@ Gcc_backend::function_type_varadic (\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n-Btype *\n-Gcc_backend::function_ptr_type (Btype *result_type,\n-\t\t\t\tconst std::vector<Btype *> &parameters,\n+tree\n+Gcc_backend::function_ptr_type (tree result_type,\n+\t\t\t\tconst std::vector<tree> &parameters,\n \t\t\t\tLocation /* locus */)\n {\n   tree args = NULL_TREE;\n   tree *pp = &args;\n \n   for (auto &param : parameters)\n     {\n-      tree t = param->get_tree ();\n-      if (t == error_mark_node)\n+      if (param == error_mark_node)\n \treturn this->error_type ();\n \n-      *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n+      *pp = tree_cons (NULL_TREE, param, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n \n   *pp = void_list_node;\n \n-  tree result = result_type->get_tree ();\n+  tree result = result_type;\n   if (result != void_type_node && int_size_in_bytes (result) == 0)\n     result = void_type_node;\n \n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n // Make a struct type.\n \n-Btype *\n-Gcc_backend::struct_type (const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::struct_type (const std::vector<typed_identifier> &fields)\n {\n-  return this->fill_in_fields (this->make_type (make_node (RECORD_TYPE)),\n-\t\t\t       fields);\n+  return this->fill_in_fields (make_node (RECORD_TYPE), fields);\n }\n \n // Make a union type.\n \n-Btype *\n-Gcc_backend::union_type (const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::union_type (const std::vector<typed_identifier> &fields)\n {\n-  return this->fill_in_fields (this->make_type (make_node (UNION_TYPE)),\n-\t\t\t       fields);\n+  return this->fill_in_fields (make_node (UNION_TYPE), fields);\n }\n \n // Fill in the fields of a struct or union type.\n \n-Btype *\n-Gcc_backend::fill_in_fields (Btype *fill,\n-\t\t\t     const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::fill_in_fields (tree fill,\n+\t\t\t     const std::vector<typed_identifier> &fields)\n {\n-  tree fill_tree = fill->get_tree ();\n   tree field_trees = NULL_TREE;\n   tree *pp = &field_trees;\n-  for (std::vector<Btyped_identifier>::const_iterator p = fields.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = fields.begin ();\n        p != fields.end (); ++p)\n     {\n       tree name_tree = get_identifier_from_string (p->name);\n-      tree type_tree = p->btype->get_tree ();\n+      tree type_tree = p->type;\n       if (type_tree == error_mark_node)\n \treturn this->error_type ();\n       tree field = build_decl (p->location.gcc_location (), FIELD_DECL,\n \t\t\t       name_tree, type_tree);\n-      DECL_CONTEXT (field) = fill_tree;\n+      DECL_CONTEXT (field) = fill;\n       *pp = field;\n       pp = &DECL_CHAIN (field);\n     }\n-  TYPE_FIELDS (fill_tree) = field_trees;\n-  layout_type (fill_tree);\n+  TYPE_FIELDS (fill) = field_trees;\n+  layout_type (fill);\n \n   // Because Rust permits converting between named struct types and\n   // equivalent struct types, for which we use VIEW_CONVERT_EXPR, and\n   // because we don't try to maintain TYPE_CANONICAL for struct types,\n   // we need to tell the middle-end to use structural equality.\n-  SET_TYPE_STRUCTURAL_EQUALITY (fill_tree);\n+  SET_TYPE_STRUCTURAL_EQUALITY (fill);\n \n   return fill;\n }\n \n // Make an array type.\n \n-Btype *\n-Gcc_backend::array_type (Btype *element_btype, Bexpression *length)\n+tree\n+Gcc_backend::array_type (tree element_type, tree length)\n {\n-  return this->fill_in_array (this->make_type (make_node (ARRAY_TYPE)),\n-\t\t\t      element_btype, length);\n+  return this->fill_in_array (make_node (ARRAY_TYPE), element_type, length);\n }\n \n // Fill in an array type.\n \n-Btype *\n-Gcc_backend::fill_in_array (Btype *fill, Btype *element_type,\n-\t\t\t    Bexpression *length)\n+tree\n+Gcc_backend::fill_in_array (tree fill, tree element_type, tree length_tree)\n {\n-  tree element_type_tree = element_type->get_tree ();\n-  tree length_tree = length->get_tree ();\n-  if (element_type_tree == error_mark_node || length_tree == error_mark_node)\n+  if (element_type == error_mark_node || length_tree == error_mark_node)\n     return this->error_type ();\n \n-  gcc_assert (TYPE_SIZE (element_type_tree) != NULL_TREE);\n+  gcc_assert (TYPE_SIZE (element_type) != NULL_TREE);\n \n   length_tree = fold_convert (sizetype, length_tree);\n \n@@ -1205,160 +1069,26 @@ Gcc_backend::fill_in_array (Btype *fill, Btype *element_type,\n   tree index_type_tree = build_index_type (\n     fold_build2 (MINUS_EXPR, sizetype, length_tree, size_one_node));\n \n-  tree fill_tree = fill->get_tree ();\n-  TREE_TYPE (fill_tree) = element_type_tree;\n-  TYPE_DOMAIN (fill_tree) = index_type_tree;\n-  TYPE_ADDR_SPACE (fill_tree) = TYPE_ADDR_SPACE (element_type_tree);\n-  layout_type (fill_tree);\n+  TREE_TYPE (fill) = element_type;\n+  TYPE_DOMAIN (fill) = index_type_tree;\n+  TYPE_ADDR_SPACE (fill) = TYPE_ADDR_SPACE (element_type);\n+  layout_type (fill);\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P (element_type_tree))\n-    SET_TYPE_STRUCTURAL_EQUALITY (fill_tree);\n-  else if (TYPE_CANONICAL (element_type_tree) != element_type_tree\n+  if (TYPE_STRUCTURAL_EQUALITY_P (element_type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (fill);\n+  else if (TYPE_CANONICAL (element_type) != element_type\n \t   || TYPE_CANONICAL (index_type_tree) != index_type_tree)\n-    TYPE_CANONICAL (fill_tree)\n-      = build_array_type (TYPE_CANONICAL (element_type_tree),\n-\t\t\t  TYPE_CANONICAL (index_type_tree));\n+    TYPE_CANONICAL (fill) = build_array_type (TYPE_CANONICAL (element_type),\n+\t\t\t\t\t      TYPE_CANONICAL (index_type_tree));\n \n   return fill;\n }\n \n-// Create a placeholder for a pointer type.\n-\n-Btype *\n-Gcc_backend::placeholder_pointer_type (const std::string &name,\n-\t\t\t\t       Location location, bool)\n-{\n-  tree ret = build_distinct_type_copy (ptr_type_node);\n-  if (!name.empty ())\n-    {\n-      tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t      get_identifier_from_string (name), ret);\n-      TYPE_NAME (ret) = decl;\n-    }\n-  return this->make_type (ret);\n-}\n-\n-// Set the real target type for a placeholder pointer type.\n-\n-bool\n-Gcc_backend::set_placeholder_pointer_type (Btype *placeholder, Btype *to_type)\n-{\n-  tree pt = placeholder->get_tree ();\n-  if (pt == error_mark_node)\n-    return false;\n-  gcc_assert (TREE_CODE (pt) == POINTER_TYPE);\n-  tree tt = to_type->get_tree ();\n-  if (tt == error_mark_node)\n-    {\n-      placeholder->set_tree (error_mark_node);\n-      return false;\n-    }\n-  gcc_assert (TREE_CODE (tt) == POINTER_TYPE);\n-  TREE_TYPE (pt) = TREE_TYPE (tt);\n-  TYPE_CANONICAL (pt) = TYPE_CANONICAL (tt);\n-  if (TYPE_NAME (pt) != NULL_TREE)\n-    {\n-      // Build the data structure gcc wants to see for a typedef.\n-      tree copy = build_variant_type_copy (pt);\n-      TYPE_NAME (copy) = NULL_TREE;\n-      DECL_ORIGINAL_TYPE (TYPE_NAME (pt)) = copy;\n-    }\n-  return true;\n-}\n-\n-// Set the real values for a placeholder function type.\n-\n-bool\n-Gcc_backend::set_placeholder_function_type (Btype *placeholder, Btype *ft)\n-{\n-  return this->set_placeholder_pointer_type (placeholder, ft);\n-}\n-\n-// Create a placeholder for a struct type.\n-\n-Btype *\n-Gcc_backend::placeholder_struct_type (const std::string &name,\n-\t\t\t\t      Location location)\n-{\n-  tree ret = make_node (RECORD_TYPE);\n-  if (!name.empty ())\n-    {\n-      tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t      get_identifier_from_string (name), ret);\n-      TYPE_NAME (ret) = decl;\n-\n-      // The struct type that eventually replaces this placeholder will require\n-      // structural equality. The placeholder must too, so that the requirement\n-      // for structural equality propagates to references that are constructed\n-      // before the replacement occurs.\n-      SET_TYPE_STRUCTURAL_EQUALITY (ret);\n-    }\n-  return this->make_type (ret);\n-}\n-\n-// Fill in the fields of a placeholder struct type.\n-\n-bool\n-Gcc_backend::set_placeholder_struct_type (\n-  Btype *placeholder, const std::vector<Btyped_identifier> &fields)\n-{\n-  tree t = placeholder->get_tree ();\n-  gcc_assert (TREE_CODE (t) == RECORD_TYPE && TYPE_FIELDS (t) == NULL_TREE);\n-  Btype *r = this->fill_in_fields (placeholder, fields);\n-\n-  if (TYPE_NAME (t) != NULL_TREE)\n-    {\n-      // Build the data structure gcc wants to see for a typedef.\n-      tree copy = build_distinct_type_copy (t);\n-      TYPE_NAME (copy) = NULL_TREE;\n-      DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = copy;\n-      TYPE_SIZE (copy) = NULL_TREE;\n-      Btype *bc = this->make_type (copy);\n-      this->fill_in_fields (bc, fields);\n-      delete bc;\n-    }\n-\n-  return r->get_tree () != error_mark_node;\n-}\n-\n-// Create a placeholder for an array type.\n-\n-Btype *\n-Gcc_backend::placeholder_array_type (const std::string &name, Location location)\n-{\n-  tree ret = make_node (ARRAY_TYPE);\n-  tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t  get_identifier_from_string (name), ret);\n-  TYPE_NAME (ret) = decl;\n-  return this->make_type (ret);\n-}\n-\n-// Fill in the fields of a placeholder array type.\n-\n-bool\n-Gcc_backend::set_placeholder_array_type (Btype *placeholder,\n-\t\t\t\t\t Btype *element_btype,\n-\t\t\t\t\t Bexpression *length)\n-{\n-  tree t = placeholder->get_tree ();\n-  gcc_assert (TREE_CODE (t) == ARRAY_TYPE && TREE_TYPE (t) == NULL_TREE);\n-  Btype *r = this->fill_in_array (placeholder, element_btype, length);\n-\n-  // Build the data structure gcc wants to see for a typedef.\n-  tree copy = build_distinct_type_copy (t);\n-  TYPE_NAME (copy) = NULL_TREE;\n-  DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = copy;\n-\n-  return r->get_tree () != error_mark_node;\n-}\n-\n // Return a named version of a type.\n \n-Btype *\n-Gcc_backend::named_type (const std::string &name, Btype *btype,\n-\t\t\t Location location)\n+tree\n+Gcc_backend::named_type (const std::string &name, tree type, Location location)\n {\n-  tree type = btype->get_tree ();\n   if (type == error_mark_node)\n     return this->error_type ();\n \n@@ -1374,39 +1104,22 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n       tree decl = build_decl (BUILTINS_LOCATION, TYPE_DECL,\n \t\t\t      get_identifier_from_string (name), type);\n       TYPE_NAME (type) = decl;\n-      return this->make_type (type);\n+      return type;\n     }\n \n   tree copy = build_variant_type_copy (type);\n   tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n \t\t\t  get_identifier_from_string (name), copy);\n   DECL_ORIGINAL_TYPE (decl) = type;\n   TYPE_NAME (copy) = decl;\n-  return this->make_type (copy);\n-}\n-\n-// Return a pointer type used as a marker for a circular type.\n-\n-Btype *\n-Gcc_backend::circular_pointer_type (Btype *, bool)\n-{\n-  return this->make_type (ptr_type_node);\n-}\n-\n-// Return whether we might be looking at a circular type.\n-\n-bool\n-Gcc_backend::is_circular_pointer_type (Btype *btype)\n-{\n-  return btype->get_tree () == ptr_type_node;\n+  return copy;\n }\n \n // Return the size of a type.\n \n int64_t\n-Gcc_backend::type_size (Btype *btype)\n+Gcc_backend::type_size (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   if (t == void_type_node)\n@@ -1423,9 +1136,8 @@ Gcc_backend::type_size (Btype *btype)\n // Return the alignment of a type.\n \n int64_t\n-Gcc_backend::type_alignment (Btype *btype)\n+Gcc_backend::type_alignment (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   return TYPE_ALIGN_UNIT (t);\n@@ -1434,9 +1146,8 @@ Gcc_backend::type_alignment (Btype *btype)\n // Return the alignment of a struct field of type BTYPE.\n \n int64_t\n-Gcc_backend::type_field_alignment (Btype *btype)\n+Gcc_backend::type_field_alignment (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   return rust_field_alignment (t);\n@@ -1445,9 +1156,8 @@ Gcc_backend::type_field_alignment (Btype *btype)\n // Return the offset of a field in a struct.\n \n int64_t\n-Gcc_backend::type_field_offset (Btype *btype, size_t index)\n+Gcc_backend::type_field_offset (tree struct_tree, size_t index)\n {\n-  tree struct_tree = btype->get_tree ();\n   if (struct_tree == error_mark_node)\n     return 0;\n   gcc_assert (TREE_CODE (struct_tree) == RECORD_TYPE);\n@@ -1465,37 +1175,34 @@ Gcc_backend::type_field_offset (Btype *btype, size_t index)\n \n // Return the zero value for a type.\n \n-Bexpression *\n-Gcc_backend::zero_expression (Btype *btype)\n+tree\n+Gcc_backend::zero_expression (tree t)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     ret = error_mark_node;\n   else\n     ret = build_zero_cst (t);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that references a variable.\n \n-Bexpression *\n+tree\n Gcc_backend::var_expression (Bvariable *var, Location location)\n {\n   tree ret = var->get_tree (location);\n   if (ret == error_mark_node)\n     return this->error_expression ();\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that indirectly references an expression.\n \n-Bexpression *\n-Gcc_backend::indirect_expression (Btype *btype, Bexpression *expr,\n+tree\n+Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n \t\t\t\t  bool known_valid, Location location)\n {\n-  tree expr_tree = expr->get_tree ();\n-  tree type_tree = btype->get_tree ();\n   if (expr_tree == error_mark_node || type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1509,18 +1216,16 @@ Gcc_backend::indirect_expression (Btype *btype, Bexpression *expr,\n   tree ret = build_fold_indirect_ref_loc (location.gcc_location (), expr_tree);\n   if (known_valid)\n     TREE_THIS_NOTRAP (ret) = 1;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that declares a constant named NAME with the\n // constant value VAL in BTYPE.\n \n-Bexpression *\n-Gcc_backend::named_constant_expression (Btype *btype, const std::string &name,\n-\t\t\t\t\tBexpression *val, Location location)\n+tree\n+Gcc_backend::named_constant_expression (tree type_tree, const std::string &name,\n+\t\t\t\t\ttree const_val, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n-  tree const_val = val->get_tree ();\n   if (type_tree == error_mark_node || const_val == error_mark_node)\n     return this->error_expression ();\n \n@@ -1532,28 +1237,26 @@ Gcc_backend::named_constant_expression (Btype *btype, const std::string &name,\n   TREE_READONLY (decl) = 1;\n \n   rust_preserve_from_gc (decl);\n-  return this->make_expression (decl);\n+  return decl;\n }\n \n // Return a typed value as a constant integer.\n \n-Bexpression *\n-Gcc_backend::integer_constant_expression (Btype *btype, mpz_t val)\n+tree\n+Gcc_backend::integer_constant_expression (tree t, mpz_t val)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return this->error_expression ();\n \n   tree ret = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return a typed value as a constant floating-point number.\n \n-Bexpression *\n-Gcc_backend::float_constant_expression (Btype *btype, mpfr_t val)\n+tree\n+Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     return this->error_expression ();\n@@ -1563,15 +1266,14 @@ Gcc_backend::float_constant_expression (Btype *btype, mpfr_t val)\n   REAL_VALUE_TYPE r2;\n   real_convert (&r2, TYPE_MODE (t), &r1);\n   ret = build_real (t, r2);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return a typed real and imaginary value as a constant complex number.\n \n-Bexpression *\n-Gcc_backend::complex_constant_expression (Btype *btype, mpc_t val)\n+tree\n+Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     return this->error_expression ();\n@@ -1588,12 +1290,12 @@ Gcc_backend::complex_constant_expression (Btype *btype, mpc_t val)\n \n   ret = build_complex (t, build_real (TREE_TYPE (t), r2),\n \t\t       build_real (TREE_TYPE (t), r4));\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Make a constant string expression.\n \n-Bexpression *\n+tree\n Gcc_backend::string_constant_expression (const std::string &val)\n {\n   tree index_type = build_index_type (size_int (val.length ()));\n@@ -1603,70 +1305,63 @@ Gcc_backend::string_constant_expression (const std::string &val)\n   tree string_val = build_string (val.length (), val.data ());\n   TREE_TYPE (string_val) = string_type;\n \n-  return this->make_expression (string_val);\n+  return string_val;\n }\n \n-Bexpression *\n+tree\n Gcc_backend::wchar_constant_expression (wchar_t c)\n {\n-  tree ret = build_int_cst (this->wchar_type ()->get_tree (), c);\n-  return this->make_expression (ret);\n+  return build_int_cst (this->wchar_type (), c);\n }\n \n-Bexpression *\n+tree\n Gcc_backend::char_constant_expression (char c)\n {\n-  tree ret = build_int_cst (this->char_type ()->get_tree (), c);\n-  return this->make_expression (ret);\n+  return build_int_cst (this->char_type (), c);\n }\n \n // Make a constant boolean expression.\n \n-Bexpression *\n+tree\n Gcc_backend::boolean_constant_expression (bool val)\n {\n-  tree bool_cst = val ? boolean_true_node : boolean_false_node;\n-  return this->make_expression (bool_cst);\n+  return val ? boolean_true_node : boolean_false_node;\n }\n \n // Return the real part of a complex expression.\n \n-Bexpression *\n-Gcc_backend::real_part_expression (Bexpression *bcomplex, Location location)\n+tree\n+Gcc_backend::real_part_expression (tree complex_tree, Location location)\n {\n-  tree complex_tree = bcomplex->get_tree ();\n   if (complex_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), REALPART_EXPR,\n \t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return the imaginary part of a complex expression.\n \n-Bexpression *\n-Gcc_backend::imag_part_expression (Bexpression *bcomplex, Location location)\n+tree\n+Gcc_backend::imag_part_expression (tree complex_tree, Location location)\n {\n-  tree complex_tree = bcomplex->get_tree ();\n   if (complex_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), IMAGPART_EXPR,\n \t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Make a complex expression given its real and imaginary parts.\n \n-Bexpression *\n-Gcc_backend::complex_expression (Bexpression *breal, Bexpression *bimag,\n+tree\n+Gcc_backend::complex_expression (tree real_tree, tree imag_tree,\n \t\t\t\t Location location)\n {\n-  tree real_tree = breal->get_tree ();\n-  tree imag_tree = bimag->get_tree ();\n   if (real_tree == error_mark_node || imag_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (real_tree))\n@@ -1675,23 +1370,22 @@ Gcc_backend::complex_expression (Bexpression *breal, Bexpression *bimag,\n   tree ret = fold_build2_loc (location.gcc_location (), COMPLEX_EXPR,\n \t\t\t      build_complex_type (TREE_TYPE (real_tree)),\n \t\t\t      real_tree, imag_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that converts an expression to a different type.\n \n-Bexpression *\n-Gcc_backend::convert_expression (Btype *type, Bexpression *expr,\n+tree\n+Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n \t\t\t\t Location location)\n {\n-  tree type_tree = type->get_tree ();\n-  tree expr_tree = expr->get_tree ();\n   if (type_tree == error_mark_node || expr_tree == error_mark_node\n       || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n \n   tree ret;\n-  if (this->type_size (type) == 0 || TREE_TYPE (expr_tree) == void_type_node)\n+  if (this->type_size (type_tree) == 0\n+      || TREE_TYPE (expr_tree) == void_type_node)\n     {\n       // Do not convert zero-sized types.\n       ret = expr_tree;\n@@ -1712,42 +1406,38 @@ Gcc_backend::convert_expression (Btype *type, Bexpression *expr,\n   else\n     ret = fold_convert_loc (location.gcc_location (), type_tree, expr_tree);\n \n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Get the address of a function.\n \n-Bexpression *\n-Gcc_backend::function_code_expression (Bfunction *bfunc, Location location)\n+tree\n+Gcc_backend::function_code_expression (tree func, Location location)\n {\n-  tree func = bfunc->get_tree ();\n   if (func == error_mark_node)\n     return this->error_expression ();\n \n   tree ret = build_fold_addr_expr_loc (location.gcc_location (), func);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Get the address of an expression.\n \n-Bexpression *\n-Gcc_backend::address_expression (Bexpression *bexpr, Location location)\n+tree\n+Gcc_backend::address_expression (tree expr, Location location)\n {\n-  tree expr = bexpr->get_tree ();\n   if (expr == error_mark_node)\n     return this->error_expression ();\n \n-  tree ret = build_fold_addr_expr_loc (location.gcc_location (), expr);\n-  return this->make_expression (ret);\n+  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n }\n \n // Return an expression for the field at INDEX in BSTRUCT.\n \n-Bexpression *\n-Gcc_backend::struct_field_expression (Bexpression *bstruct, size_t index,\n+tree\n+Gcc_backend::struct_field_expression (tree struct_tree, size_t index,\n \t\t\t\t      Location location)\n {\n-  tree struct_tree = bstruct->get_tree ();\n   if (struct_tree == error_mark_node\n       || TREE_TYPE (struct_tree) == error_mark_node)\n     return this->error_expression ();\n@@ -1771,43 +1461,35 @@ Gcc_backend::struct_field_expression (Bexpression *bstruct, size_t index,\n \t\t\t      TREE_TYPE (field), struct_tree, field, NULL_TREE);\n   if (TREE_CONSTANT (struct_tree))\n     TREE_CONSTANT (ret) = 1;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that executes BSTAT before BEXPR.\n \n-Bexpression *\n-Gcc_backend::compound_expression (Bstatement *bstat, Bexpression *bexpr,\n-\t\t\t\t  Location location)\n+tree\n+Gcc_backend::compound_expression (tree stat, tree expr, Location location)\n {\n-  tree stat = bstat->get_tree ();\n-  tree expr = bexpr->get_tree ();\n   if (stat == error_mark_node || expr == error_mark_node)\n     return this->error_expression ();\n   tree ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t      TREE_TYPE (expr), stat, expr);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that executes THEN_EXPR if CONDITION is true, or\n // ELSE_EXPR otherwise.\n \n-Bexpression *\n-Gcc_backend::conditional_expression (Bfunction *, Btype *btype,\n-\t\t\t\t     Bexpression *condition,\n-\t\t\t\t     Bexpression *then_expr,\n-\t\t\t\t     Bexpression *else_expr, Location location)\n-{\n-  tree type_tree = btype == NULL ? void_type_node : btype->get_tree ();\n-  tree cond_tree = condition->get_tree ();\n-  tree then_tree = then_expr->get_tree ();\n-  tree else_tree = else_expr == NULL ? NULL_TREE : else_expr->get_tree ();\n-  if (type_tree == error_mark_node || cond_tree == error_mark_node\n-      || then_tree == error_mark_node || else_tree == error_mark_node)\n+tree\n+Gcc_backend::conditional_expression (tree, tree type_tree, tree cond_expr,\n+\t\t\t\t     tree then_expr, tree else_expr,\n+\t\t\t\t     Location location)\n+{\n+  if (type_tree == error_mark_node || cond_expr == error_mark_node\n+      || then_expr == error_mark_node || else_expr == error_mark_node)\n     return this->error_expression ();\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, type_tree,\n-\t\t\t cond_tree, then_tree, else_tree);\n-  return this->make_expression (ret);\n+\t\t\t cond_expr, then_expr, else_expr);\n+  return ret;\n }\n \n /* Helper function that converts rust operators to equivalent GCC tree_code.\n@@ -1909,13 +1591,12 @@ is_floating_point (tree t)\n }\n \n // Return an expression for the negation operation OP EXPR.\n-Bexpression *\n-Gcc_backend::negation_expression (NegationOperator op, Bexpression *expr,\n+tree\n+Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n \t\t\t\t  Location location)\n {\n   /* Check if the expression is an error, in which case we return an error\n      expression. */\n-  auto expr_tree = expr->get_tree ();\n   if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n \n@@ -1944,20 +1625,17 @@ Gcc_backend::negation_expression (NegationOperator op, Bexpression *expr,\n \t\t\t\t   tree_type, expr_tree);\n   if (floating_point && extended_type != NULL_TREE)\n     new_tree = convert (original_type, expr_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the arithmetic or logical operation LEFT OP RIGHT.\n-Bexpression *\n+tree\n Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t       Bexpression *left,\n-\t\t\t\t\t       Bexpression *right,\n+\t\t\t\t\t       tree left_tree, tree right_tree,\n \t\t\t\t\t       Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1990,18 +1668,16 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n \t\t\t\t   tree_type, left_tree, right_tree);\n   if (floating_point && extended_type != NULL_TREE)\n     new_tree = convert (original_type, new_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the comparison operation LEFT OP RIGHT.\n-Bexpression *\n-Gcc_backend::comparison_expression (ComparisonOperator op, Bexpression *left,\n-\t\t\t\t    Bexpression *right, Location location)\n+tree\n+Gcc_backend::comparison_expression (ComparisonOperator op, tree left_tree,\n+\t\t\t\t    tree right_tree, Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2012,18 +1688,16 @@ Gcc_backend::comparison_expression (ComparisonOperator op, Bexpression *left,\n   /* Construct a new tree and build an expression from it. */\n   auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n \t\t\t\t   tree_type, left_tree, right_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the lazy boolean operation LEFT OP RIGHT.\n-Bexpression *\n-Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n-\t\t\t\t      Bexpression *right, Location location)\n+tree\n+Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, tree left_tree,\n+\t\t\t\t      tree right_tree, Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2035,17 +1709,16 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n   /* Construct a new tree and build an expression from it. */\n   auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n \t\t\t\t   tree_type, left_tree, right_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression that constructs BTYPE with VALS.\n \n-Bexpression *\n-Gcc_backend::constructor_expression (Btype *btype,\n-\t\t\t\t     const std::vector<Bexpression *> &vals,\n+tree\n+Gcc_backend::constructor_expression (tree type_tree,\n+\t\t\t\t     const std::vector<tree> &vals,\n \t\t\t\t     int union_index, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2058,7 +1731,7 @@ Gcc_backend::constructor_expression (Btype *btype,\n   if (union_index != -1)\n     {\n       gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n-      tree val = vals.front ()->get_tree ();\n+      tree val = vals.front ();\n       for (int i = 0; i < union_index; i++)\n \t{\n \t  gcc_assert (field != NULL_TREE);\n@@ -2090,11 +1763,11 @@ Gcc_backend::constructor_expression (Btype *btype,\n   else\n     {\n       gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); ++p, field = DECL_CHAIN (field))\n \t{\n \t  gcc_assert (field != NULL_TREE);\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t      || TREE_TYPE (val) == error_mark_node)\n \t    return this->error_expression ();\n@@ -2125,15 +1798,14 @@ Gcc_backend::constructor_expression (Btype *btype,\n   if (sink != NULL_TREE)\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n \t\t\t   sink, ret);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n-Bexpression *\n+tree\n Gcc_backend::array_constructor_expression (\n-  Btype *array_btype, const std::vector<unsigned long> &indexes,\n-  const std::vector<Bexpression *> &vals, Location location)\n+  tree type_tree, const std::vector<unsigned long> &indexes,\n+  const std::vector<tree> &vals, Location location)\n {\n-  tree type_tree = array_btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2149,7 +1821,7 @@ Gcc_backend::array_constructor_expression (\n   for (size_t i = 0; i < vals.size (); ++i)\n     {\n       tree index = size_int (indexes[i]);\n-      tree val = (vals[i])->get_tree ();\n+      tree val = vals[i];\n \n       if (index == error_mark_node || val == error_mark_node)\n \treturn this->error_expression ();\n@@ -2179,17 +1851,15 @@ Gcc_backend::array_constructor_expression (\n   if (sink != NULL_TREE)\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n \t\t\t   sink, ret);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression for the address of BASE[INDEX].\n \n-Bexpression *\n-Gcc_backend::pointer_offset_expression (Bexpression *base, Bexpression *index,\n+tree\n+Gcc_backend::pointer_offset_expression (tree base_tree, tree index_tree,\n \t\t\t\t\tLocation location)\n {\n-  tree base_tree = base->get_tree ();\n-  tree index_tree = index->get_tree ();\n   tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n   if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n       || index_tree == error_mark_node || element_type_tree == error_mark_node)\n@@ -2202,17 +1872,15 @@ Gcc_backend::pointer_offset_expression (Bexpression *base, Bexpression *index,\n \t\t\t\t index_tree, element_size);\n   tree ptr = fold_build2_loc (location.gcc_location (), POINTER_PLUS_EXPR,\n \t\t\t      TREE_TYPE (base_tree), base_tree, offset);\n-  return this->make_expression (ptr);\n+  return ptr;\n }\n \n // Return an expression representing ARRAY[INDEX]\n \n-Bexpression *\n-Gcc_backend::array_index_expression (Bexpression *array, Bexpression *index,\n+tree\n+Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n \t\t\t\t     Location location)\n {\n-  tree array_tree = array->get_tree ();\n-  tree index_tree = index->get_tree ();\n   if (array_tree == error_mark_node || TREE_TYPE (array_tree) == error_mark_node\n       || index_tree == error_mark_node)\n     return this->error_expression ();\n@@ -2229,17 +1897,15 @@ Gcc_backend::array_index_expression (Bexpression *array, Bexpression *index,\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t   void_type_node, array_tree, index_tree);\n \n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Create an expression for a call to FN_EXPR with FN_ARGS.\n-Bexpression *\n-Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n-\t\t\t      Bexpression *fn_expr,\n-\t\t\t      const std::vector<Bexpression *> &fn_args,\n-\t\t\t      Bexpression *chain_expr, Location location)\n+tree\n+Gcc_backend::call_expression (tree, // containing fcn for call\n+\t\t\t      tree fn, const std::vector<tree> &fn_args,\n+\t\t\t      tree chain_expr, Location location)\n {\n-  tree fn = fn_expr->get_tree ();\n   if (fn == error_mark_node || TREE_TYPE (fn) == error_mark_node)\n     return this->error_expression ();\n \n@@ -2250,7 +1916,7 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n   tree *args = nargs == 0 ? NULL : new tree[nargs];\n   for (size_t i = 0; i < nargs; ++i)\n     {\n-      args[i] = fn_args.at (i)->get_tree ();\n+      args[i] = fn_args.at (i);\n       if (args[i] == error_mark_node)\n \treturn this->error_expression ();\n     }\n@@ -2296,7 +1962,7 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n \t\t\t    fn, nargs, args);\n \n   if (chain_expr)\n-    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr->get_tree ();\n+    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr;\n \n   if (excess_type != NULL_TREE)\n     {\n@@ -2306,24 +1972,23 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n     }\n \n   delete[] args;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression as a statement.\n \n-Bstatement *\n-Gcc_backend::expression_statement (Bfunction *, Bexpression *expr)\n+tree\n+Gcc_backend::expression_statement (tree, tree expr)\n {\n-  return this->make_statement (expr->get_tree ());\n+  return expr;\n }\n \n // Variable initialization.\n \n-Bstatement *\n-Gcc_backend::init_statement (Bfunction *, Bvariable *var, Bexpression *init)\n+tree\n+Gcc_backend::init_statement (tree, Bvariable *var, tree init_tree)\n {\n   tree var_tree = var->get_decl ();\n-  tree init_tree = init->get_tree ();\n   if (var_tree == error_mark_node || init_tree == error_mark_node)\n     return this->error_statement ();\n   gcc_assert (TREE_CODE (var_tree) == VAR_DECL);\n@@ -2347,18 +2012,16 @@ Gcc_backend::init_statement (Bfunction *, Bvariable *var, Bexpression *init)\n     ret = build2_loc (DECL_SOURCE_LOCATION (var_tree), COMPOUND_EXPR,\n \t\t      void_type_node, init_tree, ret);\n \n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Assignment.\n \n-Bstatement *\n-Gcc_backend::assignment_statement (Bfunction *bfn, Bexpression *lhs,\n-\t\t\t\t   Bexpression *rhs, Location location)\n+tree\n+Gcc_backend::assignment_statement (tree bfn, tree lhs, tree rhs,\n+\t\t\t\t   Location location)\n {\n-  tree lhs_tree = lhs->get_tree ();\n-  tree rhs_tree = rhs->get_tree ();\n-  if (lhs_tree == error_mark_node || rhs_tree == error_mark_node)\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n     return this->error_statement ();\n \n   // To avoid problems with GNU ld, we don't make zero-sized\n@@ -2367,28 +2030,25 @@ Gcc_backend::assignment_statement (Bfunction *bfn, Bexpression *lhs,\n   // expression; avoid crashes here by avoiding assignments of\n   // zero-sized expressions.  Such assignments don't really mean\n   // anything anyhow.\n-  if (TREE_TYPE (lhs_tree) == void_type_node\n-      || int_size_in_bytes (TREE_TYPE (lhs_tree)) == 0\n-      || TREE_TYPE (rhs_tree) == void_type_node\n-      || int_size_in_bytes (TREE_TYPE (rhs_tree)) == 0)\n+  if (TREE_TYPE (lhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (lhs)) == 0\n+      || TREE_TYPE (rhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (rhs)) == 0)\n     return this->compound_statement (this->expression_statement (bfn, lhs),\n \t\t\t\t     this->expression_statement (bfn, rhs));\n \n-  rhs_tree = this->convert_tree (TREE_TYPE (lhs_tree), rhs_tree, location);\n+  rhs = this->convert_tree (TREE_TYPE (lhs), rhs, location);\n \n-  return this->make_statement (fold_build2_loc (location.gcc_location (),\n-\t\t\t\t\t\tMODIFY_EXPR, void_type_node,\n-\t\t\t\t\t\tlhs_tree, rhs_tree));\n+  return fold_build2_loc (location.gcc_location (), MODIFY_EXPR, void_type_node,\n+\t\t\t  lhs, rhs);\n }\n \n // Return.\n \n-Bstatement *\n-Gcc_backend::return_statement (Bfunction *bfunction,\n-\t\t\t       const std::vector<Bexpression *> &vals,\n+tree\n+Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t\t\t       Location location)\n {\n-  tree fntree = bfunction->get_tree ();\n   if (fntree == error_mark_node)\n     return this->error_statement ();\n   tree result = DECL_RESULT (fntree);\n@@ -2402,18 +2062,18 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n   if (res_type == void_type_node || int_size_in_bytes (res_type) == 0)\n     {\n       tree stmt_list = NULL_TREE;\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); p++)\n \t{\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (val == error_mark_node)\n \t    return this->error_statement ();\n \t  append_to_statement_list (val, &stmt_list);\n \t}\n       tree ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n \t\t\t\t  void_type_node, NULL_TREE);\n       append_to_statement_list (ret, &stmt_list);\n-      return this->make_statement (stmt_list);\n+      return stmt_list;\n     }\n \n   tree ret;\n@@ -2422,12 +2082,11 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n \t\t\t   void_type_node, NULL_TREE);\n   else if (vals.size () == 1)\n     {\n-      tree val = vals.front ()->get_tree ();\n+      tree val = vals.front ();\n       if (val == error_mark_node)\n \treturn this->error_statement ();\n-      tree set\n-\t= fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t   void_type_node, result, vals.front ()->get_tree ());\n+      tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n+\t\t\t\t  void_type_node, result, vals.front ());\n       ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n \t\t\t     void_type_node, set);\n     }\n@@ -2448,18 +2107,18 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n       pop_cfun ();\n \n       tree field = TYPE_FIELDS (rettype);\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); p++, field = DECL_CHAIN (field))\n \t{\n \t  gcc_assert (field != NULL_TREE);\n \t  tree ref\n \t    = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n \t\t\t       TREE_TYPE (field), rettmp, field, NULL_TREE);\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (val == error_mark_node)\n \t    return this->error_statement ();\n \t  tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t\t      void_type_node, ref, (*p)->get_tree ());\n+\t\t\t\t      void_type_node, ref, (*p));\n \t  append_to_statement_list (set, &stmt_list);\n \t}\n       gcc_assert (field == NULL_TREE);\n@@ -2470,7 +2129,7 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n       append_to_statement_list (ret_expr, &stmt_list);\n       ret = stmt_list;\n     }\n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if an\n@@ -2479,142 +2138,127 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n // functions.  In C++, the resulting code is of this form:\n //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n \n-Bstatement *\n-Gcc_backend::exception_handler_statement (Bstatement *bstat,\n-\t\t\t\t\t  Bstatement *except_stmt,\n-\t\t\t\t\t  Bstatement *finally_stmt,\n-\t\t\t\t\t  Location location)\n+tree\n+Gcc_backend::exception_handler_statement (tree try_stmt, tree except_stmt,\n+\t\t\t\t\t  tree finally_stmt, Location location)\n {\n-  tree stat_tree = bstat->get_tree ();\n-  tree except_tree = except_stmt == NULL ? NULL_TREE : except_stmt->get_tree ();\n-  tree finally_tree\n-    = finally_stmt == NULL ? NULL_TREE : finally_stmt->get_tree ();\n-\n-  if (stat_tree == error_mark_node || except_tree == error_mark_node\n-      || finally_tree == error_mark_node)\n+  if (try_stmt == error_mark_node || except_stmt == error_mark_node\n+      || finally_stmt == error_mark_node)\n     return this->error_statement ();\n \n-  if (except_tree != NULL_TREE)\n-    stat_tree = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n-\t\t\t    void_type_node, stat_tree,\n-\t\t\t    build2_loc (location.gcc_location (), CATCH_EXPR,\n-\t\t\t\t\tvoid_type_node, NULL, except_tree));\n-  if (finally_tree != NULL_TREE)\n-    stat_tree = build2_loc (location.gcc_location (), TRY_FINALLY_EXPR,\n-\t\t\t    void_type_node, stat_tree, finally_tree);\n-  return this->make_statement (stat_tree);\n+  if (except_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n+\t\t\t   void_type_node, try_stmt,\n+\t\t\t   build2_loc (location.gcc_location (), CATCH_EXPR,\n+\t\t\t\t       void_type_node, NULL, except_stmt));\n+  if (finally_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_FINALLY_EXPR,\n+\t\t\t   void_type_node, try_stmt, finally_stmt);\n+  return try_stmt;\n }\n \n // If.\n \n-Bstatement *\n-Gcc_backend::if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t   Bblock *then_block, Bblock *else_block,\n+tree\n+Gcc_backend::if_statement (tree, tree cond_tree, tree then_tree, tree else_tree,\n \t\t\t   Location location)\n {\n-  tree cond_tree = condition->get_tree ();\n-  tree then_tree = then_block->get_tree ();\n-  tree else_tree = else_block == NULL ? NULL_TREE : else_block->get_tree ();\n   if (cond_tree == error_mark_node || then_tree == error_mark_node\n       || else_tree == error_mark_node)\n     return this->error_statement ();\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, void_type_node,\n \t\t\t cond_tree, then_tree, else_tree);\n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Loops\n \n-Bexpression *\n-Gcc_backend::loop_expression (Bblock *body, Location locus)\n+tree\n+Gcc_backend::loop_expression (tree body, Location locus)\n {\n-  tree loop_expr_tree = fold_build1_loc (locus.gcc_location (), LOOP_EXPR,\n-\t\t\t\t\t void_type_node, body->get_tree ());\n-  return this->make_expression (loop_expr_tree);\n+  return fold_build1_loc (locus.gcc_location (), LOOP_EXPR, void_type_node,\n+\t\t\t  body);\n }\n \n-Bexpression *\n-Gcc_backend::exit_expression (Bexpression *condition, Location locus)\n+tree\n+Gcc_backend::exit_expression (tree cond_tree, Location locus)\n {\n-  tree cond_tree = condition->get_tree ();\n-  tree exit_expr_tree = fold_build1_loc (locus.gcc_location (), EXIT_EXPR,\n-\t\t\t\t\t void_type_node, cond_tree);\n-  return this->make_expression (exit_expr_tree);\n+  return fold_build1_loc (locus.gcc_location (), EXIT_EXPR, void_type_node,\n+\t\t\t  cond_tree);\n }\n \n // Switch.\n \n-Bstatement *\n-Gcc_backend::switch_statement (\n-  Bfunction *function, Bexpression *value,\n-  const std::vector<std::vector<Bexpression *> > &cases,\n-  const std::vector<Bstatement *> &statements, Location switch_location)\n+tree\n+Gcc_backend::switch_statement (tree decl, tree value,\n+\t\t\t       const std::vector<std::vector<tree>> &cases,\n+\t\t\t       const std::vector<tree> &statements,\n+\t\t\t       Location switch_location)\n {\n   gcc_assert (cases.size () == statements.size ());\n \n-  tree decl = function->get_tree ();\n   if (DECL_STRUCT_FUNCTION (decl) == NULL)\n     push_struct_function (decl);\n   else\n     push_cfun (DECL_STRUCT_FUNCTION (decl));\n \n   tree stmt_list = NULL_TREE;\n-  std::vector<std::vector<Bexpression *> >::const_iterator pc = cases.begin ();\n-  for (std::vector<Bstatement *>::const_iterator ps = statements.begin ();\n+  std::vector<std::vector<tree>>::const_iterator pc = cases.begin ();\n+  for (std::vector<tree>::const_iterator ps = statements.begin ();\n        ps != statements.end (); ++ps, ++pc)\n     {\n       if (pc->empty ())\n \t{\n-\t  location_t loc = (*ps != NULL ? EXPR_LOCATION ((*ps)->get_tree ())\n-\t\t\t\t\t: UNKNOWN_LOCATION);\n+\t  location_t loc\n+\t    = (*ps != NULL ? EXPR_LOCATION (*ps) : UNKNOWN_LOCATION);\n \t  tree label = create_artificial_label (loc);\n \t  tree c = build_case_label (NULL_TREE, NULL_TREE, label);\n \t  append_to_statement_list (c, &stmt_list);\n \t}\n       else\n \t{\n-\t  for (std::vector<Bexpression *>::const_iterator pcv = pc->begin ();\n+\t  for (std::vector<tree>::const_iterator pcv = pc->begin ();\n \t       pcv != pc->end (); ++pcv)\n \t    {\n-\t      tree t = (*pcv)->get_tree ();\n+\t      tree t = (*pcv);\n \t      if (t == error_mark_node)\n \t\treturn this->error_statement ();\n \t      location_t loc = EXPR_LOCATION (t);\n \t      tree label = create_artificial_label (loc);\n-\t      tree c = build_case_label ((*pcv)->get_tree (), NULL_TREE, label);\n+\t      tree c = build_case_label ((*pcv), NULL_TREE, label);\n \t      append_to_statement_list (c, &stmt_list);\n \t    }\n \t}\n \n       if (*ps != NULL)\n \t{\n-\t  tree t = (*ps)->get_tree ();\n+\t  tree t = (*ps);\n \t  if (t == error_mark_node)\n \t    return this->error_statement ();\n \t  append_to_statement_list (t, &stmt_list);\n \t}\n     }\n   pop_cfun ();\n \n-  tree tv = value->get_tree ();\n+  tree tv = value;\n   if (tv == error_mark_node)\n     return this->error_statement ();\n   tree t = build2_loc (switch_location.gcc_location (), SWITCH_EXPR, NULL_TREE,\n \t\t       tv, stmt_list);\n-  return this->make_statement (t);\n+  return t;\n }\n \n // Pair of statements.\n \n-Bstatement *\n-Gcc_backend::compound_statement (Bstatement *s1, Bstatement *s2)\n+tree\n+Gcc_backend::compound_statement (tree s1, tree s2)\n {\n   tree stmt_list = NULL_TREE;\n-  tree t = s1->get_tree ();\n+  tree t = s1;\n   if (t == error_mark_node)\n     return this->error_statement ();\n   append_to_statement_list (t, &stmt_list);\n-  t = s2->get_tree ();\n+  t = s2;\n   if (t == error_mark_node)\n     return this->error_statement ();\n   append_to_statement_list (t, &stmt_list);\n@@ -2624,40 +2268,39 @@ Gcc_backend::compound_statement (Bstatement *s1, Bstatement *s2)\n   if (stmt_list == NULL_TREE)\n     stmt_list = integer_zero_node;\n \n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // List of statements.\n \n-Bstatement *\n-Gcc_backend::statement_list (const std::vector<Bstatement *> &statements)\n+tree\n+Gcc_backend::statement_list (const std::vector<tree> &statements)\n {\n   tree stmt_list = NULL_TREE;\n-  for (std::vector<Bstatement *>::const_iterator p = statements.begin ();\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n        p != statements.end (); ++p)\n     {\n-      tree t = (*p)->get_tree ();\n+      tree t = (*p);\n       if (t == error_mark_node)\n \treturn this->error_statement ();\n       append_to_statement_list (t, &stmt_list);\n     }\n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // Make a block.  For some reason gcc uses a dual structure for\n // blocks: BLOCK tree nodes and BIND_EXPR tree nodes.  Since the\n // BIND_EXPR node points to the BLOCK node, we store the BIND_EXPR in\n // the Bblock.\n \n-Bblock *\n-Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n+tree\n+Gcc_backend::block (tree fndecl, tree enclosing,\n \t\t    const std::vector<Bvariable *> &vars,\n \t\t    Location start_location, Location)\n {\n   tree block_tree = make_node (BLOCK);\n   if (enclosing == NULL)\n     {\n-      tree fndecl = function->get_tree ();\n       gcc_assert (fndecl != NULL_TREE);\n \n       // We may have already created a block for local variables when\n@@ -2680,8 +2323,7 @@ Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n     }\n   else\n     {\n-      tree superbind_tree = enclosing->get_tree ();\n-      tree superblock_tree = BIND_EXPR_BLOCK (superbind_tree);\n+      tree superblock_tree = BIND_EXPR_BLOCK (enclosing);\n       gcc_assert (TREE_CODE (superblock_tree) == BLOCK);\n \n       BLOCK_SUPERCONTEXT (block_tree) = superblock_tree;\n@@ -2708,37 +2350,35 @@ Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n     = build3_loc (start_location.gcc_location (), BIND_EXPR, void_type_node,\n \t\t  BLOCK_VARS (block_tree), NULL_TREE, block_tree);\n   TREE_SIDE_EFFECTS (bind_tree) = 1;\n-  return new Bblock (bind_tree);\n+  return bind_tree;\n }\n \n // Add statements to a block.\n \n void\n-Gcc_backend::block_add_statements (Bblock *bblock,\n-\t\t\t\t   const std::vector<Bstatement *> &statements)\n+Gcc_backend::block_add_statements (tree bind_tree,\n+\t\t\t\t   const std::vector<tree> &statements)\n {\n   tree stmt_list = NULL_TREE;\n-  for (std::vector<Bstatement *>::const_iterator p = statements.begin ();\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n        p != statements.end (); ++p)\n     {\n-      tree s = (*p)->get_tree ();\n+      tree s = (*p);\n       if (s != error_mark_node)\n \tappend_to_statement_list (s, &stmt_list);\n     }\n \n-  tree bind_tree = bblock->get_tree ();\n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n   BIND_EXPR_BODY (bind_tree) = stmt_list;\n }\n \n // Return a block as a statement.\n \n-Bstatement *\n-Gcc_backend::block_statement (Bblock *bblock)\n+tree\n+Gcc_backend::block_statement (tree bind_tree)\n {\n-  tree bind_tree = bblock->get_tree ();\n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  return this->make_statement (bind_tree);\n+  return bind_tree;\n }\n \n // This is not static because we declare it with GTY(()) in rust-c.h.\n@@ -2839,11 +2479,10 @@ Gcc_backend::convert_tree (tree type_tree, tree expr_tree, Location location)\n \n Bvariable *\n Gcc_backend::global_variable (const std::string &var_name,\n-\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t      const std::string &asm_name, tree type_tree,\n \t\t\t      bool is_external, bool is_hidden,\n \t\t\t      bool in_unique_section, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -2881,9 +2520,8 @@ Gcc_backend::global_variable (const std::string &var_name,\n // Set the initial value of a global variable.\n \n void\n-Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n+Gcc_backend::global_variable_set_init (Bvariable *var, tree expr_tree)\n {\n-  tree expr_tree = expr->get_tree ();\n   if (expr_tree == error_mark_node)\n     return;\n   gcc_assert (TREE_CONSTANT (expr_tree));\n@@ -2906,16 +2544,15 @@ Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n // Make a local variable.\n \n Bvariable *\n-Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n-\t\t\t     Btype *btype, Bvariable *decl_var,\n+Gcc_backend::local_variable (tree function, const std::string &name,\n+\t\t\t     tree type_tree, Bvariable *decl_var,\n \t\t\t     bool is_address_taken, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), VAR_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_CONTEXT (decl) = function->get_tree ();\n+  DECL_CONTEXT (decl) = function;\n   TREE_USED (decl) = 1;\n   if (is_address_taken)\n     TREE_ADDRESSABLE (decl) = 1;\n@@ -2931,16 +2568,15 @@ Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n // Make a function parameter variable.\n \n Bvariable *\n-Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n-\t\t\t\t Btype *btype, bool is_address_taken,\n+Gcc_backend::parameter_variable (tree function, const std::string &name,\n+\t\t\t\t tree type_tree, bool is_address_taken,\n \t\t\t\t Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_CONTEXT (decl) = function->get_tree ();\n+  DECL_CONTEXT (decl) = function;\n   DECL_ARG_TYPE (decl) = type_tree;\n   TREE_USED (decl) = 1;\n   if (is_address_taken)\n@@ -2952,16 +2588,13 @@ Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n // Make a static chain variable.\n \n Bvariable *\n-Gcc_backend::static_chain_variable (Bfunction *function,\n-\t\t\t\t    const std::string &name, Btype *btype,\n-\t\t\t\t    Location location)\n+Gcc_backend::static_chain_variable (tree fndecl, const std::string &name,\n+\t\t\t\t    tree type_tree, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  tree fndecl = function->get_tree ();\n   DECL_CONTEXT (decl) = fndecl;\n   DECL_ARG_TYPE (decl) = type_tree;\n   TREE_USED (decl) = 1;\n@@ -2987,17 +2620,13 @@ Gcc_backend::static_chain_variable (Bfunction *function,\n // Make a temporary variable.\n \n Bvariable *\n-Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n-\t\t\t\t Btype *btype, Bexpression *binit,\n-\t\t\t\t bool is_address_taken, Location location,\n-\t\t\t\t Bstatement **pstatement)\n-{\n-  gcc_assert (function != NULL);\n-  tree decl = function->get_tree ();\n-  tree type_tree = btype->get_tree ();\n-  tree init_tree = binit == NULL ? NULL_TREE : binit->get_tree ();\n+Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n+\t\t\t\t tree init_tree, bool is_address_taken,\n+\t\t\t\t Location location, tree *pstatement)\n+{\n+  gcc_assert (fndecl != NULL_TREE);\n   if (type_tree == error_mark_node || init_tree == error_mark_node\n-      || decl == error_mark_node)\n+      || fndecl == error_mark_node)\n     {\n       *pstatement = this->error_statement ();\n       return this->error_variable ();\n@@ -3007,26 +2636,25 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n   // We can only use create_tmp_var if the type is not addressable.\n   if (!TREE_ADDRESSABLE (type_tree))\n     {\n-      if (DECL_STRUCT_FUNCTION (decl) == NULL)\n-\tpush_struct_function (decl);\n+      if (DECL_STRUCT_FUNCTION (fndecl) == NULL)\n+\tpush_struct_function (fndecl);\n       else\n-\tpush_cfun (DECL_STRUCT_FUNCTION (decl));\n+\tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \n       var = create_tmp_var (type_tree, \"RUSTTMP\");\n       pop_cfun ();\n     }\n   else\n     {\n-      gcc_assert (bblock != NULL);\n+      gcc_assert (bind_tree != NULL_TREE);\n       var = build_decl (location.gcc_location (), VAR_DECL,\n \t\t\tcreate_tmp_var_name (\"RUSTTMP\"), type_tree);\n       DECL_ARTIFICIAL (var) = 1;\n       DECL_IGNORED_P (var) = 1;\n       TREE_USED (var) = 1;\n-      DECL_CONTEXT (var) = decl;\n+      DECL_CONTEXT (var) = fndecl;\n \n       // We have to add this variable to the BLOCK and the BIND_EXPR.\n-      tree bind_tree = bblock->get_tree ();\n       gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n       tree block_tree = BIND_EXPR_BLOCK (bind_tree);\n       gcc_assert (TREE_CODE (block_tree) == BLOCK);\n@@ -3035,24 +2663,23 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n       BIND_EXPR_VARS (bind_tree) = BLOCK_VARS (block_tree);\n     }\n \n-  if (this->type_size (btype) != 0 && init_tree != NULL_TREE\n+  if (this->type_size (type_tree) != 0 && init_tree != NULL_TREE\n       && TREE_TYPE (init_tree) != void_type_node)\n     DECL_INITIAL (var) = this->convert_tree (type_tree, init_tree, location);\n \n   if (is_address_taken)\n     TREE_ADDRESSABLE (var) = 1;\n \n-  *pstatement = this->make_statement (\n-    build1_loc (location.gcc_location (), DECL_EXPR, void_type_node, var));\n+  *pstatement\n+    = build1_loc (location.gcc_location (), DECL_EXPR, void_type_node, var);\n \n   // For a zero sized type, don't initialize VAR with BINIT, but still\n   // evaluate BINIT for its side effects.\n   if (init_tree != NULL_TREE\n-      && (this->type_size (btype) == 0\n+      && (this->type_size (type_tree) == 0\n \t  || TREE_TYPE (init_tree) == void_type_node))\n-    *pstatement\n-      = this->compound_statement (this->expression_statement (function, binit),\n-\t\t\t\t  *pstatement);\n+    *pstatement = this->compound_statement (\n+      this->expression_statement (fndecl, init_tree), *pstatement);\n \n   return new Bvariable (var);\n }\n@@ -3062,11 +2689,10 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n \n Bvariable *\n Gcc_backend::implicit_variable (const std::string &name,\n-\t\t\t\tconst std::string &asm_name, Btype *type,\n+\t\t\t\tconst std::string &asm_name, tree type_tree,\n \t\t\t\tbool is_hidden, bool is_constant,\n \t\t\t\tbool is_common, int64_t alignment)\n {\n-  tree type_tree = type->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -3117,15 +2743,10 @@ Gcc_backend::implicit_variable (const std::string &name,\n \n void\n Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\t Btype *, bool, bool, bool is_common,\n-\t\t\t\t\t Bexpression *init)\n+\t\t\t\t\t tree, bool, bool, bool is_common,\n+\t\t\t\t\t tree init_tree)\n {\n   tree decl = var->get_decl ();\n-  tree init_tree;\n-  if (init == NULL)\n-    init_tree = NULL_TREE;\n-  else\n-    init_tree = init->get_tree ();\n   if (decl == error_mark_node || init_tree == error_mark_node)\n     return;\n \n@@ -3149,9 +2770,8 @@ Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n Bvariable *\n Gcc_backend::implicit_variable_reference (const std::string &name,\n \t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t  Btype *btype)\n+\t\t\t\t\t  tree type_tree)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -3172,9 +2792,9 @@ Gcc_backend::implicit_variable_reference (const std::string &name,\n Bvariable *\n Gcc_backend::immutable_struct (const std::string &name,\n \t\t\t       const std::string &asm_name, bool is_hidden,\n-\t\t\t       bool is_common, Btype *btype, Location location)\n+\t\t\t       bool is_common, tree type_tree,\n+\t\t\t       Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n@@ -3218,11 +2838,10 @@ Gcc_backend::immutable_struct (const std::string &name,\n \n void\n Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\tbool, bool is_common, Btype *, Location,\n-\t\t\t\t\tBexpression *initializer)\n+\t\t\t\t\tbool, bool is_common, tree, Location,\n+\t\t\t\t\ttree init_tree)\n {\n   tree decl = var->get_decl ();\n-  tree init_tree = initializer->get_tree ();\n   if (decl == error_mark_node || init_tree == error_mark_node)\n     return;\n \n@@ -3249,9 +2868,8 @@ Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n Bvariable *\n Gcc_backend::immutable_struct_reference (const std::string &name,\n \t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t Btype *btype, Location location)\n+\t\t\t\t\t tree type_tree, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n@@ -3271,14 +2889,12 @@ Gcc_backend::immutable_struct_reference (const std::string &name,\n \n // Make a label.\n \n-Blabel *\n-Gcc_backend::label (Bfunction *function, const std::string &name,\n-\t\t    Location location)\n+tree\n+Gcc_backend::label (tree func_tree, const std::string &name, Location location)\n {\n   tree decl;\n   if (name.empty ())\n     {\n-      tree func_tree = function->get_tree ();\n       if (DECL_STRUCT_FUNCTION (func_tree) == NULL)\n \tpush_struct_function (func_tree);\n       else\n@@ -3293,56 +2909,50 @@ Gcc_backend::label (Bfunction *function, const std::string &name,\n       tree id = get_identifier_from_string (name);\n       decl\n \t= build_decl (location.gcc_location (), LABEL_DECL, id, void_type_node);\n-      DECL_CONTEXT (decl) = function->get_tree ();\n+      DECL_CONTEXT (decl) = func_tree;\n     }\n-  return new Blabel (decl);\n+  return decl;\n }\n \n // Make a statement which defines a label.\n \n-Bstatement *\n-Gcc_backend::label_definition_statement (Blabel *label)\n+tree\n+Gcc_backend::label_definition_statement (tree label)\n {\n-  tree lab = label->get_tree ();\n-  tree ret = fold_build1_loc (DECL_SOURCE_LOCATION (lab), LABEL_EXPR,\n-\t\t\t      void_type_node, lab);\n-  return this->make_statement (ret);\n+  return fold_build1_loc (DECL_SOURCE_LOCATION (label), LABEL_EXPR,\n+\t\t\t  void_type_node, label);\n }\n \n // Make a goto statement.\n \n-Bstatement *\n-Gcc_backend::goto_statement (Blabel *label, Location location)\n+tree\n+Gcc_backend::goto_statement (tree label, Location location)\n {\n-  tree lab = label->get_tree ();\n-  tree ret = fold_build1_loc (location.gcc_location (), GOTO_EXPR,\n-\t\t\t      void_type_node, lab);\n-  return this->make_statement (ret);\n+  return fold_build1_loc (location.gcc_location (), GOTO_EXPR, void_type_node,\n+\t\t\t  label);\n }\n \n // Get the address of a label.\n \n-Bexpression *\n-Gcc_backend::label_address (Blabel *label, Location location)\n+tree\n+Gcc_backend::label_address (tree label, Location location)\n {\n-  tree lab = label->get_tree ();\n-  TREE_USED (lab) = 1;\n-  TREE_ADDRESSABLE (lab) = 1;\n+  TREE_USED (label) = 1;\n+  TREE_ADDRESSABLE (label) = 1;\n   tree ret\n     = fold_convert_loc (location.gcc_location (), ptr_type_node,\n \t\t\tbuild_fold_addr_expr_loc (location.gcc_location (),\n-\t\t\t\t\t\t  lab));\n-  return this->make_expression (ret);\n+\t\t\t\t\t\t  label));\n+  return ret;\n }\n \n // Declare or define a new function.\n \n-Bfunction *\n-Gcc_backend::function (Btype *fntype, const std::string &name,\n+tree\n+Gcc_backend::function (tree functype, const std::string &name,\n \t\t       const std::string &asm_name, unsigned int flags,\n \t\t       Location location)\n {\n-  tree functype = fntype->get_tree ();\n   if (functype != error_mark_node)\n     {\n       gcc_assert (FUNCTION_POINTER_TYPE_P (functype));\n@@ -3386,58 +2996,52 @@ Gcc_backend::function (Btype *fntype, const std::string &name,\n     TREE_READONLY (decl) = 1;\n \n   rust_preserve_from_gc (decl);\n-  return new Bfunction (decl);\n+  return decl;\n }\n \n // Create a statement that runs all deferred calls for FUNCTION.  This should\n // be a statement that looks like this in C++:\n //   finish:\n //     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n \n-Bstatement *\n-Gcc_backend::function_defer_statement (Bfunction *function,\n-\t\t\t\t       Bexpression *undefer, Bexpression *defer,\n-\t\t\t\t       Location location)\n+tree\n+Gcc_backend::function_defer_statement (tree function, tree undefer_tree,\n+\t\t\t\t       tree defer_tree, Location location)\n {\n-  tree undefer_tree = undefer->get_tree ();\n-  tree defer_tree = defer->get_tree ();\n-  tree fntree = function->get_tree ();\n-\n   if (undefer_tree == error_mark_node || defer_tree == error_mark_node\n-      || fntree == error_mark_node)\n+      || function == error_mark_node)\n     return this->error_statement ();\n \n-  if (DECL_STRUCT_FUNCTION (fntree) == NULL)\n-    push_struct_function (fntree);\n+  if (DECL_STRUCT_FUNCTION (function) == NULL)\n+    push_struct_function (function);\n   else\n-    push_cfun (DECL_STRUCT_FUNCTION (fntree));\n+    push_cfun (DECL_STRUCT_FUNCTION (function));\n \n   tree stmt_list = NULL;\n-  Blabel *blabel = this->label (function, \"\", location);\n-  Bstatement *label_def = this->label_definition_statement (blabel);\n-  append_to_statement_list (label_def->get_tree (), &stmt_list);\n+  tree label = this->label (function, \"\", location);\n+  tree label_def = this->label_definition_statement (label);\n+  append_to_statement_list (label_def, &stmt_list);\n \n-  Bstatement *jump_stmt = this->goto_statement (blabel, location);\n-  tree jump = jump_stmt->get_tree ();\n-  tree catch_body = build2 (COMPOUND_EXPR, void_type_node, defer_tree, jump);\n+  tree jump_stmt = this->goto_statement (label, location);\n+  tree catch_body\n+    = build2 (COMPOUND_EXPR, void_type_node, defer_tree, jump_stmt);\n   catch_body = build2 (CATCH_EXPR, void_type_node, NULL, catch_body);\n   tree try_catch\n     = build2 (TRY_CATCH_EXPR, void_type_node, undefer_tree, catch_body);\n   append_to_statement_list (try_catch, &stmt_list);\n   pop_cfun ();\n \n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n // This will only be called for a function definition.\n \n bool\n Gcc_backend::function_set_parameters (\n-  Bfunction *function, const std::vector<Bvariable *> &param_vars)\n+  tree function, const std::vector<Bvariable *> &param_vars)\n {\n-  tree func_tree = function->get_tree ();\n-  if (func_tree == error_mark_node)\n+  if (function == error_mark_node)\n     return false;\n \n   tree params = NULL_TREE;\n@@ -3450,36 +3054,33 @@ Gcc_backend::function_set_parameters (\n       pp = &DECL_CHAIN (*pp);\n     }\n   *pp = NULL_TREE;\n-  DECL_ARGUMENTS (func_tree) = params;\n+  DECL_ARGUMENTS (function) = params;\n   return true;\n }\n \n // Set the function body for FUNCTION using the code in CODE_BLOCK.\n \n bool\n-Gcc_backend::function_set_body (Bfunction *function, Bstatement *code_stmt)\n+Gcc_backend::function_set_body (tree function, tree code_stmt)\n {\n-  tree func_tree = function->get_tree ();\n-  tree code = code_stmt->get_tree ();\n-\n-  if (func_tree == error_mark_node || code == error_mark_node)\n+  if (function == error_mark_node || code_stmt == error_mark_node)\n     return false;\n-  DECL_SAVED_TREE (func_tree) = code;\n+  DECL_SAVED_TREE (function) = code_stmt;\n   return true;\n }\n \n // Look up a named built-in function in the current backend implementation.\n // Returns NULL if no built-in function by that name exists.\n \n-Bfunction *\n+tree\n Gcc_backend::lookup_gcc_builtin (const std::string &name)\n {\n   if (this->builtin_functions_.count (name) != 0)\n     return this->builtin_functions_[name];\n   return NULL;\n }\n \n-Bfunction *\n+tree\n Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n {\n   auto it = rust_intrinsic_to_gcc_builtin.find (name);\n@@ -3495,9 +3096,8 @@ Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n \n void\n Gcc_backend::write_global_definitions (\n-  const std::vector<Btype *> &type_decls,\n-  const std::vector<Bexpression *> &constant_decls,\n-  const std::vector<Bfunction *> &function_decls,\n+  const std::vector<tree> &type_decls, const std::vector<tree> &constant_decls,\n+  const std::vector<tree> &function_decls,\n   const std::vector<Bvariable *> &variable_decls)\n {\n   size_t count_definitions = type_decls.size () + constant_decls.size ()\n@@ -3519,10 +3119,10 @@ Gcc_backend::write_global_definitions (\n \t}\n     }\n \n-  for (std::vector<Btype *>::const_iterator p = type_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = type_decls.begin ();\n        p != type_decls.end (); ++p)\n     {\n-      tree type_tree = (*p)->get_tree ();\n+      tree type_tree = (*p);\n       if (type_tree != error_mark_node && IS_TYPE_OR_DECL_P (type_tree))\n \t{\n \t  defs[i] = TYPE_NAME (type_tree);\n@@ -3531,20 +3131,20 @@ Gcc_backend::write_global_definitions (\n \t  ++i;\n \t}\n     }\n-  for (std::vector<Bexpression *>::const_iterator p = constant_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = constant_decls.begin ();\n        p != constant_decls.end (); ++p)\n     {\n-      if ((*p)->get_tree () != error_mark_node)\n+      if ((*p) != error_mark_node)\n \t{\n-\t  defs[i] = (*p)->get_tree ();\n+\t  defs[i] = (*p);\n \t  rust_preserve_from_gc (defs[i]);\n \t  ++i;\n \t}\n     }\n-  for (std::vector<Bfunction *>::const_iterator p = function_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = function_decls.begin ();\n        p != function_decls.end (); ++p)\n     {\n-      tree decl = (*p)->get_tree ();\n+      tree decl = (*p);\n       if (decl != error_mark_node)\n \t{\n \t  rust_preserve_from_gc (decl);\n@@ -3592,7 +3192,7 @@ Gcc_backend::define_builtin (const std::string rust_name,\n   if ((flags & builtin_novops) != 0)\n     DECL_IS_NOVOPS (decl) = 1;\n   set_builtin_decl (bcode, decl, true);\n-  this->builtin_functions_[name] = this->make_function (decl);\n+  this->builtin_functions_[name] = decl;\n   if (libname != NULL)\n     {\n       decl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n@@ -3603,7 +3203,7 @@ Gcc_backend::define_builtin (const std::string rust_name,\n \tTREE_THIS_VOLATILE (decl) = 1;\n       if ((flags & builtin_novops) != 0)\n \tDECL_IS_NOVOPS (decl) = 1;\n-      this->builtin_functions_[libname] = this->make_function (decl);\n+      this->builtin_functions_[libname] = decl;\n     }\n \n   rust_intrinsic_to_gcc_builtin[rust_name] = name;"}, {"sha": "a3f5a16118ef870796afdea1c4c0a8227f100f23", "filename": "gcc/rust/typecheck/rust-hir-const-fold-ctx.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -36,15 +36,15 @@ class Context\n \n   ::Backend *get_backend () { return backend; }\n \n-  bool lookup_const (HirId id, Bexpression **expr);\n+  bool lookup_const (HirId id, tree *expr);\n \n-  void insert_const (HirId, Bexpression *expr);\n+  void insert_const (HirId, tree expr);\n \n private:\n   Context (::Backend *backend);\n \n   ::Backend *backend;\n-  std::map<HirId, Bexpression *> ctx;\n+  std::map<HirId, tree> ctx;\n };\n \n } // namespace ConstFold"}, {"sha": "6acedd19b0fc015f13590094af7d7b6ba23eb258", "filename": "gcc/rust/typecheck/rust-hir-const-fold.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -41,7 +41,7 @@ Context::get ()\n }\n \n bool\n-Context::lookup_const (HirId id, Bexpression **expr)\n+Context::lookup_const (HirId id, tree *expr)\n {\n   auto it = ctx.find (id);\n   if (it == ctx.end ())\n@@ -52,7 +52,7 @@ Context::lookup_const (HirId id, Bexpression **expr)\n }\n \n void\n-Context::insert_const (HirId id, Bexpression *expr)\n+Context::insert_const (HirId id, tree expr)\n {\n   rust_assert (ctx.find (id) == ctx.end ());\n   ctx[id] = expr;\n@@ -75,7 +75,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n {\n   unsigned long index = 0;\n   std::vector<unsigned long> indices;\n-  std::vector<Bexpression *> values;\n+  std::vector<tree> values;\n \n   TyTy::BaseType *tyty = nullptr;\n   if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -85,7 +85,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n       return;\n     }\n \n-  Btype *btype = ConstFoldType::fold (tyty, ctx->get_backend ());\n+  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \n   for (auto &value : elems.get_values ())\n     {\n@@ -94,15 +94,15 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n     }\n \n   folded\n-    = ctx->get_backend ()->array_constructor_expression (btype, indices, values,\n+    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n \t\t\t\t\t\t\t expr.get_locus ());\n }\n \n void\n ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n {\n   std::vector<unsigned long> indices;\n-  std::vector<Bexpression *> values;\n+  std::vector<tree> values;\n \n   TyTy::BaseType *tyty = nullptr;\n   if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -112,12 +112,12 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n       return;\n     }\n \n-  Btype *btype = ConstFoldType::fold (tyty, ctx->get_backend ());\n-  Bexpression *elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n+  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+  tree elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n \n   // num copies expr was already folded in rust-hir-type-check-expr; lookup the\n   // earlier result\n-  Bexpression *num_copies_expr = ctx->get_backend ()->error_expression ();\n+  tree num_copies_expr = ctx->get_backend ()->error_expression ();\n   ctx->lookup_const (elems.get_num_copies_expr ()->get_mappings ().get_hirid (),\n \t\t     &num_copies_expr);\n \n@@ -132,7 +132,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n     }\n \n   folded\n-    = ctx->get_backend ()->array_constructor_expression (btype, indices, values,\n+    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n \t\t\t\t\t\t\t expr.get_locus ());\n }\n "}, {"sha": "c965e25017c183ff334b08b3e08a74f706fe92b7", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -28,7 +28,7 @@ namespace ConstFold {\n class ConstFoldType : public TyTy::TyVisitor\n {\n public:\n-  static Btype *fold (TyTy::BaseType *type, ::Backend *backend)\n+  static tree fold (TyTy::BaseType *type, ::Backend *backend)\n   {\n     ConstFoldType folder (backend);\n     type->accept_vis (folder);\n@@ -43,13 +43,13 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::ArrayType &type) override\n   {\n-    Btype *element_ty = ConstFoldType::fold (type.get_element_type (), backend);\n+    tree element_ty = ConstFoldType::fold (type.get_element_type (), backend);\n     translated = backend->array_type (element_ty, type.get_capacity ());\n   }\n \n   void visit (TyTy::ReferenceType &type) override\n   {\n-    Btype *base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n+    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n     if (type.is_mutable ())\n       {\n \ttranslated = backend->reference_type (base_compiled_type);\n@@ -63,7 +63,7 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::PointerType &type) override\n   {\n-    Btype *base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n+    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n     if (type.is_mutable ())\n       {\n \ttranslated = backend->pointer_type (base_compiled_type);\n@@ -212,7 +212,7 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::StrType &) override\n   {\n-    Btype *raw_str = backend->raw_str_type ();\n+    tree raw_str = backend->raw_str_type ();\n     translated\n       = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n   }\n@@ -229,15 +229,15 @@ class ConstFoldType : public TyTy::TyVisitor\n   {}\n \n   ::Backend *backend;\n-  ::Btype *translated;\n+  ::tree translated;\n };\n \n class ConstFoldItem : public ConstFoldBase\n {\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::Item &item)\n+  static tree fold (HIR::Item &item)\n   {\n     ConstFoldItem folder;\n     item.accept_vis (folder);\n@@ -258,15 +258,15 @@ class ConstFoldItem : public ConstFoldBase\n     : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n };\n \n class ConstFoldArrayElems : public ConstFoldBase\n {\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::ArrayExpr &expr)\n+  static tree fold (HIR::ArrayExpr &expr)\n   {\n     ConstFoldArrayElems folder (expr);\n     HIR::ArrayElems *elems = expr.get_internal_elements ();\n@@ -283,7 +283,7 @@ class ConstFoldArrayElems : public ConstFoldBase\n       expr (expr)\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n   HIR::ArrayExpr &expr;\n };\n \n@@ -292,7 +292,7 @@ class ConstFoldExpr : public ConstFoldBase\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::Expr *expr)\n+  static tree fold (HIR::Expr *expr)\n   {\n     ConstFoldExpr folder;\n     expr->accept_vis (folder);\n@@ -369,7 +369,7 @@ class ConstFoldExpr : public ConstFoldBase\n \t      return;\n \t    }\n \n-\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \t  folded\n \t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n \t}\n@@ -400,7 +400,7 @@ class ConstFoldExpr : public ConstFoldBase\n \t      return;\n \t    }\n \n-\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \t  folded = ctx->get_backend ()->float_constant_expression (type, fval);\n \t}\n \treturn;\n@@ -453,24 +453,24 @@ class ConstFoldExpr : public ConstFoldBase\n \n   void visit (HIR::ArrayIndexExpr &expr) override\n   {\n-    Bexpression *array = ConstFoldExpr::fold (expr.get_array_expr ());\n-    Bexpression *index = ConstFoldExpr::fold (expr.get_index_expr ());\n+    tree array = ConstFoldExpr::fold (expr.get_array_expr ());\n+    tree index = ConstFoldExpr::fold (expr.get_index_expr ());\n \n     folded = ctx->get_backend ()->array_index_expression (array, index,\n \t\t\t\t\t\t\t  expr.get_locus ());\n   }\n \n   void visit (HIR::BorrowExpr &expr) override\n   {\n-    Bexpression *main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n+    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n \n     folded\n       = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override\n   {\n-    Bexpression *main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n+    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n \n     TyTy::BaseType *tyty = nullptr;\n     if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -480,7 +480,7 @@ class ConstFoldExpr : public ConstFoldBase\n \treturn;\n       }\n \n-    Btype *expected_type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+    tree expected_type = ConstFoldType::fold (tyty, ctx->get_backend ());\n     bool known_valid = true;\n     folded = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n \t\t\t\t\t\t       known_valid,\n@@ -497,7 +497,7 @@ class ConstFoldExpr : public ConstFoldBase\n     : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n };\n \n } // namespace ConstFold"}, {"sha": "daef15ba8ed7f5858fd79aca3ee2416b3182e7b0", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -687,7 +687,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t\t\t\t  UNKNOWN_LOCAL_DEFID);\n \n \t  /* Capacity is the size of the string (number of chars).\n-\t     It is a constant, but for fold it to get a Bexpression.  */\n+\t     It is a constant, but for fold it to get a tree.  */\n \t  std::string capacity_str\n \t    = std::to_string (expr.get_literal ()->as_string ().size ());\n \t  HIR::LiteralExpr literal_capacity (capacity_mapping, capacity_str,\n@@ -700,8 +700,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t\tnew TyTy::USizeType (\n \t\t\t\t  capacity_mapping.get_hirid ()));\n \n-\t  Bexpression *capacity\n-\t    = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n+\t  tree capacity = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n \n \t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n \t\t\t\t\t       mappings->get_next_hir_id (\n@@ -1491,7 +1490,7 @@ class TypeCheckExpr : public TypeCheckBase\n   /* The return value of visit(ArrayElemsValues&) and visit(ArrayElemsCopied&)\n      Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n-  Bexpression *folded_array_capacity;\n+  tree folded_array_capacity;\n   Location root_array_expr_locus;\n \n   bool inside_loop;"}, {"sha": "915aad9909bc702ce41e8ebb3ad62b90041ec971", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fc39600ce2640e9c4d07e00e162c2529b1820a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=63fc39600ce2640e9c4d07e00e162c2529b1820a", "patch": "@@ -1588,13 +1588,13 @@ class ClosureType : public BaseType, public SubstitutionRef\n class ArrayType : public BaseType\n {\n public:\n-  ArrayType (HirId ref, Bexpression *capacity, TyVar base,\n+  ArrayType (HirId ref, tree capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, Bexpression *capacity, TyVar base,\n+  ArrayType (HirId ref, HirId ty_ref, tree capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n@@ -1615,7 +1615,7 @@ class ArrayType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  Bexpression *get_capacity () const { return capacity; }\n+  tree get_capacity () const { return capacity; }\n   std::string capacity_string () const;\n \n   BaseType *get_element_type () const;\n@@ -1628,7 +1628,7 @@ class ArrayType : public BaseType\n   }\n \n private:\n-  Bexpression *capacity;\n+  tree capacity;\n   TyVar element_type;\n };\n "}]}