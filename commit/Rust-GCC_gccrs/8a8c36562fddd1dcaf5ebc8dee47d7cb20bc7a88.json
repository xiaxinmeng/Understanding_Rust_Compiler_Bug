{"sha": "8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE4YzM2NTYyZmRkZDFkY2FmNWViYzhkZWU0N2Q3Y2IyMGJjN2E4OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-06-03T02:31:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-06-03T02:31:22Z"}, "message": "dwarf2out.c (add_incomplete_type): New fn.\n\n\t* dwarf2out.c (add_incomplete_type): New fn.\n\t(gen_struct_or_union_type_die): Call it.\n\t(retry_incomplete_types): New fn.\n\t(dwarf2out_finish): Call it.\n\nFrom-SVN: r27325", "tree": {"sha": "686d716a425f3c3ba8a4f21bec3493ff9dda1c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/686d716a425f3c3ba8a4f21bec3493ff9dda1c1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88/comments", "author": null, "committer": null, "parents": [{"sha": "ec1f6a38efe6ad810d21c5f1dc2dbb2093c8277d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1f6a38efe6ad810d21c5f1dc2dbb2093c8277d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec1f6a38efe6ad810d21c5f1dc2dbb2093c8277d"}], "stats": {"total": 65, "additions": 64, "deletions": 1}, "files": [{"sha": "935980a89e493e1aa1dd6a0466489b040bd82047", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88", "patch": "@@ -1,3 +1,10 @@\n+Thu Jun  3 02:15:07 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* dwarf2out.c (add_incomplete_type): New fn.\n+\t(gen_struct_or_union_type_die): Call it.\n+\t(retry_incomplete_types): New fn.\n+\t(dwarf2out_finish): Call it.\n+\n Thu Jun  3 01:19:03 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* gcse.c (insert_insn_end_bb): Correct placement of insns when the"}, {"sha": "f75d2c1e4b72dc00920b9a8bcf4ecdc2ae07cf5d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8a8c36562fddd1dcaf5ebc8dee47d7cb20bc7a88", "patch": "@@ -2426,6 +2426,22 @@ static unsigned pending_types;\n    be enough for most typical programs.\t */\n #define PENDING_TYPES_INCREMENT 64\n \n+/* A pointer to the base of a list of incomplete types which might be\n+   completed at some later time.  */\n+\n+static tree *incomplete_types_list;\n+\n+/* Number of elements currently allocated for the incomplete_types_list.  */\n+static unsigned incomplete_types_allocated;\n+\n+/* Number of elements of incomplete_types_list currently in use.  */\n+static unsigned incomplete_types;\n+\n+/* Size (in elements) of increments by which we may expand the incomplete\n+   types list.  Actually, a single hunk of space of this size should\n+   be enough for most typical programs.\t */\n+#define INCOMPLETE_TYPES_INCREMENT 64\n+\n /* Record whether the function being analyzed contains inlined functions.  */\n static int current_function_has_inlines;\n #if 0 && defined (MIPS_DEBUGGING_INFO)\n@@ -8035,6 +8051,39 @@ output_pending_types_for_scope (context_die)\n     }\n }\n \n+/* Remember a type in the incomplete_types_list.  */\n+\n+static void\n+add_incomplete_type (type)\n+     tree type;\n+{\n+  if (incomplete_types == incomplete_types_allocated)\n+    {\n+      incomplete_types_allocated += INCOMPLETE_TYPES_INCREMENT;\n+      incomplete_types_list\n+\t= (tree *) xrealloc (incomplete_types_list,\n+\t\t\t     sizeof (tree) * incomplete_types_allocated);\n+    }\n+\n+  incomplete_types_list[incomplete_types++] = type;\n+}\n+\n+/* Walk through the list of incomplete types again, trying once more to\n+   emit full debugging info for them.  */\n+\n+static void\n+retry_incomplete_types ()\n+{\n+  register tree type;\n+\n+  while (incomplete_types)\n+    {\n+      --incomplete_types;\n+      type = incomplete_types_list[incomplete_types];\n+      gen_type_die (type, comp_unit_die);\n+    }\n+}\n+\n /* Generate a DIE to represent an inlined instance of an enumeration type.  */\n \n static void\n@@ -9026,7 +9075,10 @@ gen_struct_or_union_type_die (type, context_die)\n \t}\n     }\n   else\n-    add_AT_flag (type_die, DW_AT_declaration, 1);\n+    {\n+      add_AT_flag (type_die, DW_AT_declaration, 1);\n+      add_incomplete_type (type);\n+    }\n }\n \n /* Generate a DIE for a subroutine _type_.  */\n@@ -9995,6 +10047,10 @@ dwarf2out_finish ()\n       free (node);\n     }\n \n+  /* Walk through the list of incomplete types again, trying once more to\n+     emit full debugging info for them.  */\n+  retry_incomplete_types ();\n+\n   /* Traverse the DIE tree and add sibling attributes to those DIE's\n      that have children.  */\n   add_sibling_attributes (comp_unit_die);"}]}