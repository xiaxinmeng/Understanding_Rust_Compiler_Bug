{"sha": "f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4ZWNiYTBiYzhkY2ExYWY5NWJhNmZmMjlkZTZjMmMyNjNjNWI3Ng==", "commit": {"author": {"name": "Pascal Obry", "email": "obry@adacore.com", "date": "2008-03-26T07:40:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:40:18Z"}, "message": "Makefile.in: Add proper GNAT.Serial_Communications implementation on supported platforms.\n\n2008-03-26  Pascal Obry  <obry@adacore.com>\n\n\t* Makefile.in: Add proper GNAT.Serial_Communications implementation on\n\tsupported platforms.\n\t\n\t* Makefile.rtl: Add g-sercom.o.\n\t\n\t* impunit.adb: Add g-sercom.adb.\n\t\n\t* s-crtl.ads (open): New routine.\n\t(close): Likewise.\n\t(write): Likewise.\n\t\n\t* s-osinte-mingw.ads (BYTE): New type.\n\t(CHAR): Likewise.\n\t(OVERLAPPED): Likewise.\n\t(GENERIC_READ): New constant.\n\t(GENERIC_WRITE): Likewise.\n\t(OPEN_EXISTING): Likewise.\n\t(PSECURITY_ATTRIBUTES): Removed this type, use anonymous access\n\ttype instead.\n\t(CreateFile): New routine.\n\t(WriteFile): Likewise.\n\t(ReadFile): Likewise.\n\t(CloseHandle): Move next to the other file oriented routines.\n\n\t* g-sercom.ads: New unit.\n\n\t* g-sercom.adb: Default implementation, calls to this unit will raise\n\ta program error exception.\n\t\n\t* g-sercom-mingw.adb, g-sercom-linux.adb: Windows and\n\tGNU/Linux implementations.\n\nFrom-SVN: r133569", "tree": {"sha": "28343910375ab6a065b5ea0288fb08858441c855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28343910375ab6a065b5ea0288fb08858441c855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/comments", "author": {"login": "TurboGit", "id": 467069, "node_id": "MDQ6VXNlcjQ2NzA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/467069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TurboGit", "html_url": "https://github.com/TurboGit", "followers_url": "https://api.github.com/users/TurboGit/followers", "following_url": "https://api.github.com/users/TurboGit/following{/other_user}", "gists_url": "https://api.github.com/users/TurboGit/gists{/gist_id}", "starred_url": "https://api.github.com/users/TurboGit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TurboGit/subscriptions", "organizations_url": "https://api.github.com/users/TurboGit/orgs", "repos_url": "https://api.github.com/users/TurboGit/repos", "events_url": "https://api.github.com/users/TurboGit/events{/privacy}", "received_events_url": "https://api.github.com/users/TurboGit/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e9f48a126a0812b87a7dba7dfcd11d441c48e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9f48a126a0812b87a7dba7dfcd11d441c48e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9f48a126a0812b87a7dba7dfcd11d441c48e80"}], "stats": {"total": 991, "additions": 971, "deletions": 20}, "files": [{"sha": "c27e7e216a1026bb671940cb48423ef32003a1ac", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -837,6 +837,7 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   s-osprim.adb<s-osprim-posix.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n   system.ads<system-linux-x86.ads\n \n   ifeq ($(strip $(filter-out marte,$(THREAD_KIND))),)\n@@ -1247,7 +1248,6 @@ endif\n   i-cpoint.ads<i-cpoint-vms_64.ads \\\n   i-cpoint.adb<i-cpoint-vms_64.adb \\\n   i-cstrea.adb<i-cstrea-vms.adb \\\n-  i-forbla.ads<i-forbla-unimplemented.ads \\\n   s-inmaop.adb<s-inmaop-vms.adb \\\n   s-interr.adb<s-interr-vms.adb \\\n   s-intman.adb<s-intman-vms.adb \\\n@@ -1315,7 +1315,8 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   g-socthi.adb<g-socthi-mingw.adb \\\n   g-stsifd.adb<g-stsifd-sockets.adb \\\n   g-soccon.ads<g-soccon-mingw.ads \\\n-  g-soliop.ads<g-soliop-mingw.ads\n+  g-soliop.ads<g-soliop-mingw.ads \\\n+  g-sercom.adb<g-sercom-mingw.adb\n \n   ifeq ($(strip $(filter-out rtx_w32 rtx_rtss,$(THREAD_KIND))),)\n     LIBGNAT_TARGET_PAIRS += \\\n@@ -1376,6 +1377,7 @@ ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n   s-tasinf.adb<s-tasinf-linux.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n   system.ads<system-linux-ppc.ads\n \n   TOOLS_TARGET_PAIRS =  \\\n@@ -1487,6 +1489,7 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   s-tasinf.adb<s-tasinf-linux.adb \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n   system.ads<system-linux-ia64.ads\n \n   TOOLS_TARGET_PAIRS =  \\\n@@ -1545,6 +1548,7 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   s-tasinf.adb<s-tasinf-linux.adb \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n   system.ads<system-linux-x86_64.ads\n \n   TOOLS_TARGET_PAIRS =  \\"}, {"sha": "9eaa7070d1bc8dc648d7c153746e3059b5988db9", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -360,6 +360,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-rannum$(objext) \\\n   g-regexp$(objext) \\\n   g-regpat$(objext) \\\n+  g-sercom$(objext) \\\n   g-sestin$(objext) \\\n   g-sha1$(objext) \\\n   g-soccon$(objext) \\"}, {"sha": "bcb5952f52975e0055991784530aa1a125d0a7eb", "filename": "gcc/ada/g-sercom-linux.adb", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sercom-linux.adb?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -0,0 +1,289 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           G N A T . S E R I A L _ C O M M U N I C A T I O N S            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                    Copyright (C) 2007-2008, AdaCore                      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the GNU/Linux implementation of this package\n+\n+with Ada.Streams;                use Ada.Streams;\n+with Ada;                        use Ada;\n+with Ada.Unchecked_Deallocation;\n+\n+with System.CRTL; use System, System.CRTL;\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+package body GNAT.Serial_Communications is\n+\n+   type Port_Data is new int;\n+\n+   subtype unsigned is Interfaces.C.unsigned;\n+   subtype char is Interfaces.C.char;\n+   subtype unsigned_char is Interfaces.C.unsigned_char;\n+\n+   function fcntl (fd : int; cmd : int; value : int) return int;\n+   pragma Import (C, fcntl, \"fcntl\");\n+\n+   O_RDWR   : constant := 8#02#;\n+   O_NOCTTY : constant := 8#0400#;\n+   O_NDELAY : constant := 8#04000#;\n+   FNDELAY  : constant := O_NDELAY;\n+   F_SETFL  : constant := 4;\n+   TCSANOW  : constant := 0;\n+   TCIFLUSH : constant := 0;\n+   CLOCAL   : constant := 8#04000#;\n+   CREAD    : constant := 8#0200#;\n+   CSTOPB   : constant := 8#0100#;\n+   CRTSCTS  : constant := 8#020000000000#;\n+\n+   --  c_cc indexes\n+\n+   VTIME : constant := 5;\n+   VMIN  : constant := 6;\n+\n+   C_Data_Rate : constant array (Data_Rate) of unsigned :=\n+                   (B1200  => 8#000011#,\n+                    B2400  => 8#000013#,\n+                    B4800  => 8#000014#,\n+                    B9600  => 8#000015#,\n+                    B19200 => 8#000016#,\n+                    B38400 => 8#000017#,\n+                    B57600 => 8#010001#);\n+\n+   C_Bits : constant array (Data_Bits) of unsigned :=\n+              (B7 => 8#040#, B8 => 8#060#);\n+\n+   procedure Raise_Error (Message : String; Error : Integer := Errno);\n+   pragma No_Return (Raise_Error);\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (Number : Positive) return Port_Name is\n+      N     : constant Natural := Number - 1;\n+      N_Img : constant String  := Natural'Image (N);\n+   begin\n+      return Port_Name (\"/dev/ttyS\" & N_Img (N_Img'First + 1 .. N_Img'Last));\n+   end Name;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (Port : out Serial_Port;\n+      Name : Port_Name)\n+   is\n+      C_Name : constant String := String (Name) & ASCII.NUL;\n+      Res    : int;\n+\n+   begin\n+      if Port.H = null then\n+         Port.H := new Port_Data;\n+      end if;\n+\n+      Port.H.all := Port_Data (open\n+         (C_Name (C_Name'First)'Address, int (O_RDWR + O_NOCTTY + O_NDELAY)));\n+\n+      if Port.H.all = -1 then\n+         Raise_Error (\"open: open failed\");\n+      end if;\n+\n+      --  By default we are in blocking mode\n+\n+      Res := fcntl (int (Port.H.all), F_SETFL, 0);\n+\n+      if Res = -1 then\n+         Raise_Error (\"open: fcntl failed\");\n+      end if;\n+   end Open;\n+\n+   -----------------\n+   -- Raise_Error --\n+   -----------------\n+\n+   procedure Raise_Error (Message : String; Error : Integer := Errno) is\n+   begin\n+      raise Serial_Error with Message & \" (\" & Integer'Image (Error) & ')';\n+   end Raise_Error;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   overriding procedure Read\n+     (Port   : in out Serial_Port;\n+      Buffer : out Stream_Element_Array;\n+      Last   : out Stream_Element_Offset)\n+   is\n+      Len : constant int := Buffer'Length;\n+      Res : int;\n+\n+   begin\n+      if Port.H = null then\n+         Raise_Error (\"read: port not opened\", 0);\n+      end if;\n+\n+      Res := read (Integer (Port.H.all), Buffer'Address, Len);\n+\n+      if Res = -1 then\n+         Last := 0;\n+         Raise_Error (\"read failed\");\n+      else\n+         Last := Buffer'First + Stream_Element_Offset (Res) - 1;\n+      end if;\n+   end Read;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set\n+     (Port    : Serial_Port;\n+      Rate    : Data_Rate := B9600;\n+      Bits    : Data_Bits := B8;\n+      Block   : Boolean   := True;\n+      Timeout : Integer   := 10)\n+   is\n+      use type unsigned;\n+\n+      type termios is record\n+         c_iflag  : unsigned;\n+         c_oflag  : unsigned;\n+         c_cflag  : unsigned;\n+         c_lflag  : unsigned;\n+         c_line   : unsigned_char;\n+         c_cc     : Interfaces.C.char_array (0 .. 31);\n+         c_ispeed : unsigned;\n+         c_ospeed : unsigned;\n+      end record;\n+      pragma Convention (C, termios);\n+\n+      function tcgetattr (fd : int; termios_p : Address) return int;\n+      pragma Import (C, tcgetattr, \"tcgetattr\");\n+\n+      function tcsetattr\n+        (fd : int; action : int; termios_p : Address) return int;\n+      pragma Import (C, tcsetattr, \"tcsetattr\");\n+\n+      function tcflush (fd : int; queue_selector : int) return int;\n+      pragma Import (C, tcflush, \"tcflush\");\n+\n+      Current : termios;\n+      Res     : int;\n+\n+   begin\n+      if Port.H = null then\n+         Raise_Error (\"set: port not opened\", 0);\n+      end if;\n+\n+      --  Get current port settings\n+\n+      Res := tcgetattr (int (Port.H.all), Current'Address);\n+\n+      --  Change settings now\n+\n+      Current.c_cflag      := C_Data_Rate (Rate)\n+                                or C_Bits (Bits)\n+                                or CLOCAL\n+                                or CREAD\n+                                or CSTOPB\n+                                or CRTSCTS;\n+      Current.c_lflag      := 0;\n+      Current.c_iflag      := 0;\n+      Current.c_oflag      := 0;\n+      Current.c_ispeed     := Data_Rate_Value (Rate);\n+      Current.c_ospeed     := Data_Rate_Value (Rate);\n+      Current.c_cc (VMIN)  := char'Val (0);\n+      Current.c_cc (VTIME) := char'Val (Timeout);\n+\n+      --  Set port settings\n+\n+      Res := tcflush (int (Port.H.all), TCIFLUSH);\n+      Res := tcsetattr (int (Port.H.all), TCSANOW, Current'Address);\n+\n+      --  Block\n+\n+      if Block then\n+         Res := fcntl (int (Port.H.all), F_SETFL, 0);\n+      else\n+         Res := fcntl (int (Port.H.all), F_SETFL, FNDELAY);\n+      end if;\n+\n+      if Res = -1 then\n+         Raise_Error (\"set: fcntl failed\");\n+      end if;\n+   end Set;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   overriding procedure Write\n+     (Port   : in out Serial_Port;\n+      Buffer : Stream_Element_Array)\n+   is\n+      Len : constant int := Buffer'Length;\n+      Res : int;\n+\n+   begin\n+      if Port.H = null then\n+         Raise_Error (\"write: port not opened\", 0);\n+      end if;\n+\n+      Res := write (int (Port.H.all), Buffer'Address, Len);\n+      pragma Assert (Res = Len);\n+\n+      if Res = -1 then\n+         Raise_Error (\"write failed\");\n+      end if;\n+   end Write;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Port : in out Serial_Port) is\n+      procedure Unchecked_Free is\n+        new Unchecked_Deallocation (Port_Data, Port_Data_Access);\n+\n+      Res : int;\n+      pragma Unreferenced (Res);\n+\n+   begin\n+      if Port.H /= null then\n+         Res := close (int (Port.H.all));\n+         Unchecked_Free (Port.H);\n+      end if;\n+   end Close;\n+\n+end GNAT.Serial_Communications;"}, {"sha": "5cb6e455cfcdc694bd071d400aa4136203642f1d", "filename": "gcc/ada/g-sercom-mingw.adb", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sercom-mingw.adb?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -0,0 +1,413 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           G N A T . S E R I A L _ C O M M U N I C A T I O N S            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                    Copyright (C) 2007-2008, AdaCore                      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Windows implementation of this package\n+\n+with Ada.Unchecked_Deallocation; use Ada;\n+with Ada.Streams;                use Ada.Streams;\n+with System;                     use System;\n+\n+package body GNAT.Serial_Communications is\n+\n+   --  Common types\n+\n+   type HANDLE is new Interfaces.C.long;\n+   type DWORD is new Interfaces.C.unsigned_long;\n+   type WORD  is new Interfaces.C.unsigned_short;\n+   subtype PVOID is System.Address;\n+   type BOOL is new Boolean;\n+   for BOOL'Size use Interfaces.C.unsigned_long'Size;\n+   type BYTE is new Interfaces.C.unsigned_char;\n+   subtype CHAR is Interfaces.C.char;\n+\n+   type Port_Data is new HANDLE;\n+\n+   type Bits1  is range 0 .. 2 ** 1 - 1;\n+   type Bits2  is range 0 .. 2 ** 2 - 1;\n+   type Bits17 is range 0 .. 2 ** 17 - 1;\n+   for Bits1'Size  use 1;\n+   for Bits2'Size  use 2;\n+   for Bits17'Size use 17;\n+\n+   -----------\n+   -- Files --\n+   -----------\n+\n+   function GetLastError return DWORD;\n+   pragma Import (Stdcall, GetLastError, \"GetLastError\");\n+\n+   GENERIC_READ  : constant := 16#80000000#;\n+   GENERIC_WRITE : constant := 16#40000000#;\n+   OPEN_EXISTING : constant := 3;\n+\n+   type OVERLAPPED is record\n+      Internal     : DWORD;\n+      InternalHigh : DWORD;\n+      Offset       : DWORD;\n+      OffsetHigh   : DWORD;\n+      hEvent       : HANDLE;\n+   end record;\n+\n+   type SECURITY_ATTRIBUTES is record\n+      nLength             : DWORD;\n+      pSecurityDescriptor : PVOID;\n+      bInheritHandle      : BOOL;\n+   end record;\n+\n+   function CreateFile\n+     (lpFileName            : Address;\n+      dwDesiredAccess       : DWORD;\n+      dwShareMode           : DWORD;\n+      lpSecurityAttributes  : access SECURITY_ATTRIBUTES;\n+      dwCreationDisposition : DWORD;\n+      dwFlagsAndAttributes  : DWORD;\n+      hTemplateFile         : HANDLE) return HANDLE;\n+   pragma Import (Stdcall, CreateFile, \"CreateFileA\");\n+\n+   function WriteFile\n+     (hFile                  : HANDLE;\n+      lpBuffer               : Address;\n+      nNumberOfBytesToWrite  : DWORD;\n+      lpNumberOfBytesWritten : access DWORD;\n+      lpOverlapped           : access OVERLAPPED) return BOOL;\n+   pragma Import (Stdcall, WriteFile, \"WriteFile\");\n+\n+   function ReadFile\n+     (hFile                : HANDLE;\n+      lpBuffer             : Address;\n+      nNumberOfBytesToRead : DWORD;\n+      lpNumberOfBytesRead  : access DWORD;\n+      lpOverlapped         : access OVERLAPPED) return BOOL;\n+   pragma Import (Stdcall, ReadFile, \"ReadFile\");\n+\n+   function CloseHandle (hObject : HANDLE) return BOOL;\n+   pragma Import (Stdcall, CloseHandle, \"CloseHandle\");\n+\n+   DTR_CONTROL_DISABLE : constant := 16#0#;\n+   RTS_CONTROL_DISABLE : constant := 16#0#;\n+   ODDPARITY           : constant := 1;\n+   ONESTOPBIT          : constant := 0;\n+\n+   type DCB is record\n+      DCBLENGTH         : DWORD;\n+      BaudRate          : DWORD;\n+      fBinary           : Bits1;\n+      fParity           : Bits1;\n+      fOutxCtsFlow      : Bits1;\n+      fOutxDsrFlow      : Bits1;\n+      fDtrControl       : Bits2;\n+      fDsrSensitivity   : Bits1;\n+      fTXContinueOnXoff : Bits1;\n+      fOutX             : Bits1;\n+      fInX              : Bits1;\n+      fErrorChar        : Bits1;\n+      fNull             : Bits1;\n+      fRtsControl       : Bits2;\n+      fAbortOnError     : Bits1;\n+      fDummy2           : Bits17;\n+      wReserved         : WORD;\n+      XonLim            : WORD;\n+      XoffLim           : WORD;\n+      ByteSize          : BYTE;\n+      Parity            : BYTE;\n+      StopBits          : BYTE;\n+      XonChar           : CHAR;\n+      XoffChar          : CHAR;\n+      ErrorChar         : CHAR;\n+      EofChar           : CHAR;\n+      EvtChar           : CHAR;\n+      wReserved1        : WORD;\n+   end record;\n+   pragma Convention (C, DCB);\n+\n+   for DCB use record\n+      DCBLENGTH         at  0 range 0 .. 31;\n+      BaudRate          at  4 range 0 .. 31;\n+      fBinary           at  8 range 0 .. 0;\n+      fParity           at  8 range 1 .. 1;\n+      fOutxCtsFlow      at  8 range 2 .. 2;\n+      fOutxDsrFlow      at  8 range 3 .. 3;\n+      fDtrControl       at  8 range 4 .. 5;\n+      fDsrSensitivity   at  8 range 6 .. 6;\n+      fTXContinueOnXoff at  8 range 7 .. 7;\n+      fOutX             at  9 range 0 .. 0;\n+      fInX              at  9 range 1 .. 1;\n+      fErrorChar        at  9 range 2 .. 2;\n+      fNull             at  9 range 3 .. 3;\n+      fRtsControl       at  9 range 4 .. 5;\n+      fAbortOnError     at  9 range 6 .. 6;\n+      fDummy2           at  9 range 7 .. 23;\n+      wReserved         at 12 range 0 .. 15;\n+      XonLim            at 14 range 0 .. 15;\n+      XoffLim           at 16 range 0 .. 15;\n+      ByteSize          at 18 range 0 .. 7;\n+      Parity            at 19 range 0 .. 7;\n+      StopBits          at 20 range 0 .. 7;\n+      XonChar           at 21 range 0 .. 7;\n+      XoffChar          at 22 range 0 .. 7;\n+      ErrorChar         at 23 range 0 .. 7;\n+      EofChar           at 24 range 0 .. 7;\n+      EvtChar           at 25 range 0 .. 7;\n+      wReserved1        at 26 range 0 .. 15;\n+   end record;\n+\n+   type COMMTIMEOUTS is record\n+      ReadIntervalTimeout         : DWORD;\n+      ReadTotalTimeoutMultiplier  : DWORD;\n+      ReadTotalTimeoutConstant    : DWORD;\n+      WriteTotalTimeoutMultiplier : DWORD;\n+      WriteTotalTimeoutConstant   : DWORD;\n+   end record;\n+   pragma Convention (C, COMMTIMEOUTS);\n+\n+   function GetCommState\n+     (hFile : HANDLE;\n+      lpDCB : access DCB) return BOOL;\n+   pragma Import (Stdcall, GetCommState, \"GetCommState\");\n+\n+   function SetCommState\n+     (hFile : HANDLE;\n+      lpDCB : access DCB) return BOOL;\n+   pragma Import (Stdcall, SetCommState, \"SetCommState\");\n+\n+   function SetCommTimeouts\n+     (hFile          : HANDLE;\n+      lpCommTimeouts : access COMMTIMEOUTS) return BOOL;\n+   pragma Import (Stdcall, SetCommTimeouts, \"SetCommTimeouts\");\n+\n+   procedure Raise_Error (Message : String; Error : DWORD := GetLastError);\n+   pragma No_Return (Raise_Error);\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Port : in out Serial_Port) is\n+      procedure Unchecked_Free is\n+        new Unchecked_Deallocation (Port_Data, Port_Data_Access);\n+\n+      Success : BOOL;\n+\n+   begin\n+      if Port.H /= null then\n+         Success := CloseHandle (HANDLE (Port.H.all));\n+         Unchecked_Free (Port.H);\n+         if not Success then\n+            Raise_Error (\"error closing the port\");\n+         end if;\n+      end if;\n+   end Close;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (Number : Positive) return Port_Name is\n+      N_Img : constant String := Positive'Image (Number);\n+   begin\n+      return Port_Name (\"COM\" & N_Img (N_Img'First + 1 .. N_Img'Last) & ':');\n+   end Name;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (Port : out Serial_Port;\n+      Name : Port_Name)\n+   is\n+      C_Name  : constant String := String (Name) & ASCII.NUL;\n+      Success : BOOL;\n+      pragma Unreferenced (Success);\n+\n+   begin\n+      if Port.H = null then\n+         Port.H := new Port_Data;\n+      else\n+         Success := CloseHandle (HANDLE (Port.H.all));\n+      end if;\n+\n+      Port.H.all := Port_Data (CreateFile\n+        (lpFileName            => C_Name (C_Name'First)'Address,\n+         dwDesiredAccess       => GENERIC_READ or GENERIC_WRITE,\n+         dwShareMode           => 0,\n+         lpSecurityAttributes  => null,\n+         DwCreationDisposition => OPEN_EXISTING,\n+         dwFlagsAndAttributes  => 0,\n+         HTemplateFile         => 0));\n+\n+      if Port.H.all = 0 then\n+         Raise_Error (\"cannot open com port\");\n+      end if;\n+   end Open;\n+\n+   -----------------\n+   -- Raise_Error --\n+   -----------------\n+\n+   procedure Raise_Error (Message : String; Error : DWORD := GetLastError) is\n+   begin\n+      raise Serial_Error with Message & \" (\" & DWORD'Image (Error) & ')';\n+   end Raise_Error;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   overriding procedure Read\n+     (Port   : in out Serial_Port;\n+      Buffer : out Stream_Element_Array;\n+      Last   : out Stream_Element_Offset)\n+   is\n+      Success   : BOOL;\n+      Read_Last : aliased DWORD;\n+\n+   begin\n+      if Port.H = null then\n+         Raise_Error (\"read: port not opened\", 0);\n+      end if;\n+\n+      Success := ReadFile\n+        (hFile                => HANDLE (Port.H.all),\n+         lpBuffer             => Buffer (Buffer'First)'Address,\n+         nNumberOfBytesToRead => DWORD (Buffer'Length),\n+         lpNumberOfBytesRead  => Read_Last'Access,\n+         lpOverlapped         => null);\n+\n+      if not Success then\n+         Raise_Error (\"read error\");\n+      end if;\n+\n+      Last := Buffer'First - 1 + Stream_Element_Offset (Read_Last);\n+   end Read;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set\n+     (Port    : Serial_Port;\n+      Rate    : Data_Rate := B9600;\n+      Bits    : Data_Bits := B8;\n+      Block   : Boolean   := True;\n+      Timeout : Integer   := 10)\n+   is\n+      Success      : BOOL;\n+      Com_Time_Out : aliased COMMTIMEOUTS;\n+      Com_Settings : aliased DCB;\n+\n+   begin\n+      if Port.H = null then\n+         Raise_Error (\"set: port not opened\", 0);\n+      end if;\n+\n+      Success := GetCommState (HANDLE (Port.H.all), Com_Settings'Access);\n+\n+      if not Success then\n+         Success := CloseHandle (HANDLE (Port.H.all));\n+         Port.H.all := 0;\n+         Raise_Error (\"set: cannot get comm state\");\n+      end if;\n+\n+      Com_Settings.BaudRate        := DWORD (Data_Rate_Value (Rate));\n+      Com_Settings.fParity         := 1;\n+      Com_Settings.fOutxCtsFlow    := 0;\n+      Com_Settings.fOutxDsrFlow    := 0;\n+      Com_Settings.fDsrSensitivity := 0;\n+      Com_Settings.fDtrControl     := DTR_CONTROL_DISABLE;\n+      Com_Settings.fOutX           := 0;\n+      Com_Settings.fInX            := 0;\n+      Com_Settings.fRtsControl     := RTS_CONTROL_DISABLE;\n+      Com_Settings.fAbortOnError   := 0;\n+      Com_Settings.ByteSize        := BYTE (Bit_Value (Bits));\n+      Com_Settings.Parity          := ODDPARITY;\n+      Com_Settings.StopBits        := ONESTOPBIT;\n+\n+      Success := SetCommState (HANDLE (Port.H.all), Com_Settings'Access);\n+\n+      if not Success then\n+         Success := CloseHandle (HANDLE (Port.H.all));\n+         Port.H.all := 0;\n+         Raise_Error (\"cannot set comm state\");\n+      end if;\n+\n+      --  Set the timeout status\n+\n+      if Block then\n+         Com_Time_Out := (others => 0);\n+      else\n+         Com_Time_Out :=\n+           (ReadTotalTimeoutConstant => DWORD (1000 * Timeout),\n+            others                   => 0);\n+      end if;\n+\n+      Success := SetCommTimeouts\n+         (hFile          => HANDLE (Port.H.all),\n+          lpCommTimeouts => Com_Time_Out'Access);\n+\n+      if not Success then\n+         Raise_Error (\"cannot set the timeout\");\n+      end if;\n+   end Set;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   overriding procedure Write\n+     (Port   : in out Serial_Port;\n+      Buffer : Stream_Element_Array)\n+   is\n+      Success   : BOOL;\n+      Temp_Last : aliased DWORD;\n+\n+   begin\n+      if Port.H = null then\n+         Raise_Error (\"write: port not opened\", 0);\n+      end if;\n+\n+      Success := WriteFile\n+         (hFile                  => HANDLE (Port.H.all),\n+          lpBuffer               => Buffer'Address,\n+          nNumberOfBytesToWrite  => DWORD (Buffer'Length),\n+          lpNumberOfBytesWritten => Temp_Last'Access,\n+          lpOverlapped           => null);\n+\n+      if not Boolean (Success)\n+        or else Stream_Element_Offset (Temp_Last) /= Buffer'Length\n+      then\n+         Raise_Error (\"failed to write data\");\n+      end if;\n+   end Write;\n+\n+end GNAT.Serial_Communications;"}, {"sha": "920557b2643d1aab83655fe28c18dd096b4b60cd", "filename": "gcc/ada/g-sercom.adb", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sercom.adb?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -0,0 +1,131 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           G N A T . S E R I A L _ C O M M U N I C A T I O N S            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Default version of this package\n+\n+with Ada.Streams; use Ada.Streams;\n+\n+package body GNAT.Serial_Communications is\n+\n+   pragma Warnings (Off);\n+   --  Kill warnings on unreferenced formals\n+\n+   type Port_Data is new Integer;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Unimplemented;\n+   pragma No_Return (Unimplemented);\n+   --  This procedure raises a Program_Error with an appropriate message\n+   --  indicating that an unimplemented feature has been used.\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name (Number : Positive) return Port_Name is\n+   begin\n+      Unimplemented;\n+      return \"\";\n+   end Name;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (Port : out Serial_Port;\n+      Name : Port_Name) is\n+   begin\n+      Unimplemented;\n+   end Open;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set\n+     (Port    : Serial_Port;\n+      Rate    : Data_Rate := B9600;\n+      Bits    : Data_Bits := B8;\n+      Block   : Boolean   := True;\n+      Timeout : Integer   := 10) is\n+   begin\n+      Unimplemented;\n+   end Set;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   overriding procedure Read\n+     (Port   : in out Serial_Port;\n+      Buffer : out Stream_Element_Array;\n+      Last   : out Stream_Element_Offset) is\n+   begin\n+      Unimplemented;\n+   end Read;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   overriding procedure Write\n+     (Port   : in out Serial_Port;\n+      Buffer : Stream_Element_Array) is\n+   begin\n+      Unimplemented;\n+   end Write;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Port : in out Serial_Port) is\n+   begin\n+      Unimplemented;\n+   end Close;\n+\n+   -------------------\n+   -- Unimplemented; --\n+   -------------------\n+\n+   procedure Unimplemented is\n+   begin\n+      raise Program_Error\n+        with \"Serial_Communications not implemented\";\n+   end Unimplemented;\n+\n+end GNAT.Serial_Communications;"}, {"sha": "bbd8f91e3316893f789ab720e26e6b6f408952ab", "filename": "gcc/ada/g-sercom.ads", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fg-sercom.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sercom.ads?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -0,0 +1,109 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           G N A T . S E R I A L _ C O M M U N I C A T I O N S            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Serial communications package, implemented on Windows and GNU/Linux\n+\n+with Ada.Streams;\n+with Interfaces.C;\n+\n+package GNAT.Serial_Communications is\n+\n+   Serial_Error : exception;\n+   --  Raised when a communication problem occurs\n+\n+   type Port_Name is new String;\n+   --  A serial com port name\n+\n+   function Name (Number : Positive) return Port_Name;\n+   --  Returns the port name for the given port number\n+\n+   type Data_Rate is (B1200, B2400, B4800, B9600, B19200, B38400, B57600);\n+   --  Speed of the communication\n+\n+   type Data_Bits is (B8, B7);\n+   --  Communication bits\n+\n+   type Serial_Port is new Ada.Streams.Root_Stream_Type with private;\n+\n+   procedure Open\n+     (Port : out Serial_Port;\n+      Name : Port_Name);\n+   --  Open the given port name. Raises Serial_Error if the port cannot be\n+   --  opened.\n+\n+   procedure Set\n+     (Port    : Serial_Port;\n+      Rate    : Data_Rate := B9600;\n+      Bits    : Data_Bits := B8;\n+      Block   : Boolean   := True;\n+      Timeout : Integer   := 10);\n+   --  The communication port settings. If Block is set then a read call\n+   --  will wait for the whole buffer to be filed. If Block is not set then\n+   --  the given Timeout (in seconds) is used.\n+\n+   overriding procedure Read\n+     (Port   : in out Serial_Port;\n+      Buffer : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset);\n+   --  Read a set of bytes, put result into Buffer and set Last accordingly.\n+   --  Last is set to 0 if no byte has been read.\n+\n+   overriding procedure Write\n+     (Port   : in out Serial_Port;\n+      Buffer : Ada.Streams.Stream_Element_Array);\n+   --  Write buffer into the port\n+\n+   procedure Close (Port : in out Serial_Port);\n+   --  Close port\n+\n+private\n+\n+   type Port_Data;\n+   type Port_Data_Access is access Port_Data;\n+\n+   type Serial_Port is new Ada.Streams.Root_Stream_Type with record\n+      H : Port_Data_Access;\n+   end record;\n+\n+   Data_Rate_Value : constant array (Data_Rate) of Interfaces.C.unsigned :=\n+                       (B1200  => 1_200,\n+                        B2400  => 2_400,\n+                        B4800  => 4_800,\n+                        B9600  => 9_600,\n+                        B19200 => 19_200,\n+                        B38400 => 38_400,\n+                        B57600 => 57_600);\n+\n+   Bit_Value : constant array (Data_Bits) of Interfaces.C.unsigned := (8, 7);\n+\n+end GNAT.Serial_Communications;"}, {"sha": "bf85defa17a45620e52fda70291f43e0e80bec0f", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -42,13 +42,14 @@ package body Impunit is\n    -- Ada 95 Units --\n    ------------------\n \n-   --  The following is a giant string list containing the names of all\n-   --  non-implementation internal files, i.e. the complete list of files for\n+   --  The following is a giant string list containing the names of all non-\n+   --  implementation internal files, i.e. the complete list of files for\n    --  internal units which a program may legitimately WITH when operating in\n    --  either Ada 95 or Ada 05 mode.\n \n    --  Note that this list should match the list of units documented in the\n-   --  \"GNAT Library\" section of the GNAT Reference Manual.\n+   --  \"GNAT Library\" section of the GNAT Reference Manual. A unit listed here\n+   --  must either be documented in that section or described in the Ada RM.\n \n    Non_Imp_File_Names_95 : constant File_List := (\n \n@@ -160,7 +161,6 @@ package body Impunit is\n      \"a-ssicst\",    -- Ada.Streams.Stream_IO.C_Streams\n      \"a-suteio\",    -- Ada.Strings.Unbounded.Text_IO\n      \"a-swuwti\",    -- Ada.Strings.Wide_Unbounded.Wide_Text_IO\n-     \"a-taidim\",    -- Ada.Task_Identification.Image\n      \"a-tiocst\",    -- Ada.Text_IO.C_Streams\n      \"a-wtcstr\",    -- Ada.Wide_Text_IO.C_Streams\n \n@@ -175,14 +175,13 @@ package body Impunit is\n    -- GNAT Special IO Units --\n    ---------------------------\n \n-   --  As further explained elsewhere (see Sem_Ch10), the internal\n-   --  packages of Text_IO and Wide_Text_IO are actually implemented\n-   --  as separate children, but this fact is intended to be hidden\n-   --  from the user completely. Any attempt to WITH one of these\n-   --  units will be diagnosed as an error later on, but for now we\n-   --  do not consider these internal implementation units (if we did,\n-   --  then we would get a junk warning which would be confusing and\n-   --  unecessary, given that we generate a clear error message).\n+   --  As further explained elsewhere (see Sem_Ch10), the internal packages of\n+   --  Text_IO and Wide_Text_IO are actually implemented as separate children,\n+   --  but this fact is intended to be hidden from the user completely. Any\n+   --  attempt to WITH one of these units will be diagnosed as an error later\n+   --  on, but for now we do not consider these internal implementation units\n+   --  (if we did, then we would get a junk warning which would be confusing\n+   --  and unecessary, given that we generate a clear error message).\n \n      \"a-tideio\",    -- Ada.Text_IO.Decimal_IO\n      \"a-tienio\",    -- Ada.Text_IO.Enumeration_IO\n@@ -259,6 +258,7 @@ package body Impunit is\n      \"g-regist\",    -- GNAT.Registry\n      \"g-regpat\",    -- GNAT.Regpat\n      \"g-semaph\",    -- GNAT.Semaphores\n+     \"g-sercom\",    -- GNAT.Serial_Communications\n      \"g-sestin\",    -- GNAT.Secondary_Stack_Info\n      \"g-sha1  \",    -- GNAT.SHA1\n      \"g-signal\",    -- GNAT.Signals\n@@ -282,8 +282,6 @@ package body Impunit is\n      \"g-u3spch\",    -- GNAT.UTF_32_Spelling_Checker\n      \"g-wispch\",    -- GNAT.Wide_Spelling_Checker\n      \"g-wistsp\",    -- GNAT.Wide_String_Split\n-     \"g-zspche\",    -- GNAT.Wide_Wide_Spelling_Checker\n-     \"g-zstspl\",    -- GNAT.Wide_Wide_String_Split\n \n    -----------------------------------------------------\n    -- Interface Hierarchy Units from Reference Manual --"}, {"sha": "4ab0e7d606db75cae739683987270cb103d71f5f", "filename": "gcc/ada/s-crtl.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fs-crtl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76/gcc%2Fada%2Fs-crtl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crtl.ads?ref=f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -148,9 +148,6 @@ package System.CRTL is\n    function popen (command, mode : System.Address) return System.Address;\n    pragma Import (C, popen, \"popen\");\n \n-   function read (fd : int; buffer : chars; nbytes : int) return int;\n-   pragma Import (C, read, \"read\");\n-\n    function realloc\n      (Ptr : System.Address; Size : size_t) return System.Address;\n    pragma Import (C, realloc, \"realloc\");\n@@ -181,6 +178,15 @@ package System.CRTL is\n    function unlink (filename : chars) return int;\n    pragma Import (C, unlink, \"unlink\");\n \n+   function open (filename : chars; oflag : int) return int;\n+   pragma Import (C, open, \"open\");\n+\n+   function close (fd : int) return int;\n+   pragma Import (C, close, \"close\");\n+\n+   function read (fd : int; buffer : chars; nbytes : int) return int;\n+   pragma Import (C, read, \"read\");\n+\n    function write (fd : int; buffer : chars; nbytes : int) return int;\n    pragma Import (C, write, \"write\");\n "}]}