{"sha": "02ae0e08a93f41022d1584054cf6111548c0d954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJhZTBlMDhhOTNmNDEwMjJkMTU4NDA1NGNmNjExMTU0OGMwZDk1NA==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@gmail.com", "date": "2020-03-03T08:34:50Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gmail.com", "date": "2020-03-03T08:34:50Z"}, "message": "arc: Update legitimate small data address.\n\nAll ARC's small data adressing is using address scaling feature of the\nload/store instructions (i.e., the address is made of a general\npointer plus a shifted offset. The shift amount depends on the\naddressing mode).  This patch is checking the offset of an address if\nit fits the scalled constraint.  If so, a small data access is\ngenerated.  This patch fixes execute' pr93249 failure.\n\ngcc/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.c (leigitimate_small_data_address_p): Check if an\n\taddress has an offset which fits the scalling constraint for a\n\tload/store operation.\n\t(legitimate_scaled_address_p): Update use\n\tleigitimate_small_data_address_p.\n\t(arc_print_operand): Likewise.\n\t(arc_legitimate_address_p): Likewise.\n\t(legitimate_small_data_address_p): Likewise.\n\nSigned-off-by: Claudiu Zissulescu <claziss@gmail.com>", "tree": {"sha": "8da1ac71aaa4a037a8a6ff0d1b7fe6d05c3a0115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8da1ac71aaa4a037a8a6ff0d1b7fe6d05c3a0115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02ae0e08a93f41022d1584054cf6111548c0d954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ae0e08a93f41022d1584054cf6111548c0d954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ae0e08a93f41022d1584054cf6111548c0d954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ae0e08a93f41022d1584054cf6111548c0d954/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c3044a210d69d475f76e4e269752e21ca4d3ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c3044a210d69d475f76e4e269752e21ca4d3ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c3044a210d69d475f76e4e269752e21ca4d3ac0"}], "stats": {"total": 47, "additions": 37, "deletions": 10}, "files": [{"sha": "ef5c7a170b4786b4e44c035a5ae5072272d40ea5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ae0e08a93f41022d1584054cf6111548c0d954/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ae0e08a93f41022d1584054cf6111548c0d954/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02ae0e08a93f41022d1584054cf6111548c0d954", "patch": "@@ -1,3 +1,14 @@\n+2020-03-03  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.c (leigitimate_small_data_address_p): Check if an\n+\taddress has an offset which fits the scalling constraint for a\n+\tload/store operation.\n+\t(legitimate_scaled_address_p): Update use\n+\tleigitimate_small_data_address_p.\n+\t(arc_print_operand): Likewise.\n+\t(arc_legitimate_address_p): Likewise.\n+\t(legitimate_small_data_address_p): Likewise.\n+\n 2020-03-03  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.md (fmasf4_fpu): Use accl_operand predicate."}, {"sha": "c98bd6cc05bb740edf1ff6d75f993335d63570e8", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ae0e08a93f41022d1584054cf6111548c0d954/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ae0e08a93f41022d1584054cf6111548c0d954/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=02ae0e08a93f41022d1584054cf6111548c0d954", "patch": "@@ -463,21 +463,37 @@ get_symbol_alignment (rtx x)\n /* Return true if x is ok to be used as a small data address.  */\n \n static bool\n-legitimate_small_data_address_p (rtx x)\n+legitimate_small_data_address_p (rtx x, machine_mode mode)\n {\n   switch (GET_CODE (x))\n     {\n     case CONST:\n-      return legitimate_small_data_address_p (XEXP (x, 0));\n+      return legitimate_small_data_address_p (XEXP (x, 0), mode);\n     case SYMBOL_REF:\n       return SYMBOL_REF_SMALL_P (x);\n     case PLUS:\n       {\n \tbool p0 = (GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t  && SYMBOL_REF_SMALL_P (XEXP (x, 0));\n-\tbool p1 = CONST_INT_P (XEXP (x, 1))\n-\t  && (INTVAL (XEXP (x, 1)) <= g_switch_value);\n-\treturn p0 && p1;\n+\n+\t/* If no constant then we cannot do small data.  */\n+\tif (!CONST_INT_P (XEXP (x, 1)))\n+\t  return false;\n+\n+\t/* Small data relocs works with scalled addresses, check if\n+\t   the immediate fits the requirements.  */\n+\tswitch (GET_MODE_SIZE (mode))\n+\t  {\n+\t  case 1:\n+\t    return p0;\n+\t  case 2:\n+\t    return p0 && ((INTVAL (XEXP (x, 1)) & 0x1) == 0);\n+\t  case 4:\n+\t  case 8:\n+\t    return p0 && ((INTVAL (XEXP (x, 1)) & 0x3) == 0);\n+\t  default:\n+\t    return false;\n+\t  }\n       }\n     default:\n       return false;\n@@ -531,7 +547,7 @@ legitimate_scaled_address_p (machine_mode mode, rtx op, bool strict)\n     }\n \n   /* Scalled addresses for sdata is done other places.  */\n-  if (legitimate_small_data_address_p (op))\n+  if (legitimate_small_data_address_p (op, mode))\n     return false;\n \n   if (CONSTANT_P (XEXP (op, 1)))\n@@ -4810,7 +4826,7 @@ arc_print_operand (FILE *file, rtx x, int code)\n \t      break;\n \t    case SYMBOL_REF:\n \t    case CONST:\n-\t      if (legitimate_small_data_address_p (addr)\n+\t      if (legitimate_small_data_address_p (addr, GET_MODE (x))\n \t\t  && GET_MODE_SIZE (GET_MODE (x)) > 1)\n \t\t{\n \t\t  int align = get_symbol_alignment (addr);\n@@ -4943,7 +4959,7 @@ arc_print_operand (FILE *file, rtx x, int code)\n \trtx addr = XEXP (x, 0);\n \tint size = GET_MODE_SIZE (GET_MODE (x));\n \n-\tif (legitimate_small_data_address_p (addr))\n+\tif (legitimate_small_data_address_p (addr, GET_MODE (x)))\n \t  output_sdata = 1;\n \n \tfputc ('[', file);\n@@ -6701,7 +6717,7 @@ arc_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n      return true;\n   if (legitimate_scaled_address_p (mode, x, strict))\n     return true;\n-  if (legitimate_small_data_address_p (x))\n+  if (legitimate_small_data_address_p (x, mode))\n      return true;\n   if (GET_CODE (x) == CONST_INT && LARGE_INT (INTVAL (x)))\n      return true;\n@@ -8748,7 +8764,7 @@ compact_sda_memory_operand (rtx op, machine_mode mode, bool short_p)\n   /* Decode the address now.  */\n   addr = XEXP (op, 0);\n \n-  if (!legitimate_small_data_address_p (addr))\n+  if (!legitimate_small_data_address_p (addr, mode))\n     return false;\n \n   if (!short_p || size == 1)"}]}