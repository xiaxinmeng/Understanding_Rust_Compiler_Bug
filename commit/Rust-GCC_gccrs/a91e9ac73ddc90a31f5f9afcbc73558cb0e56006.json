{"sha": "a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkxZTlhYzczZGRjOTBhMzFmNWY5YWZjYmM3MzU1OGNiMGU1NjAwNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T13:18:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T13:18:22Z"}, "message": "[multiple changes]\n\n2012-10-01  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Divide_Checks): New name for\n\tApply_Divide_Check (Minimize_Eliminate_Overflow_Checks):\n\tAdd code to handle division (and rem and mod) properly.\n\t(Apply_Division_Check): New procedure (Apply_Divide_Checks):\n\tUse Apply_Division_Check (Apply_Divide_Checks): Use\n\tApply_Arithmetic_Overflow_Minimized_Eliminated.\n\t* checks.ads (Apply_Divide_Checks): New name for\n\tApply_Divide_Check, also add clearer documentation for this\n\troutine and put in alfa order.\n\t* exp_ch4.adb (Apply_Divide_Checks): New name for\n\tApply_Divide_Check.\n\t* s-bignum.adb (To_Bignum): Handle largest negative integer\n\tproperly.\n\t* sem.adb (Analyze): Handle overflow suppression correctly\n\t(Analyze_List): Handle overflow suppression correctly\n\t* sem_res.adb (Analyze_And_Resolve): Handle overflow suppression\n\tcorrectly.\n\n2012-10-01  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* s-oscons-tmplt.c, g-socket.ads: Revert previous change, breaks VMS.\n\nFrom-SVN: r191920", "tree": {"sha": "1e9890433ea1e4a8576e1dd8596d25f5c826961f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e9890433ea1e4a8576e1dd8596d25f5c826961f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/comments", "author": null, "committer": null, "parents": [{"sha": "6cb3037c69f90344dd3c5f9504b0a79422932b12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb3037c69f90344dd3c5f9504b0a79422932b12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb3037c69f90344dd3c5f9504b0a79422932b12"}], "stats": {"total": 500, "additions": 437, "deletions": 63}, "files": [{"sha": "56d54d578cb0391efe3da97ab4c6fa1d2e67db9d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -1,3 +1,27 @@\n+2012-10-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Apply_Divide_Checks): New name for\n+\tApply_Divide_Check (Minimize_Eliminate_Overflow_Checks):\n+\tAdd code to handle division (and rem and mod) properly.\n+\t(Apply_Division_Check): New procedure (Apply_Divide_Checks):\n+\tUse Apply_Division_Check (Apply_Divide_Checks): Use\n+\tApply_Arithmetic_Overflow_Minimized_Eliminated.\n+\t* checks.ads (Apply_Divide_Checks): New name for\n+\tApply_Divide_Check, also add clearer documentation for this\n+\troutine and put in alfa order.\n+\t* exp_ch4.adb (Apply_Divide_Checks): New name for\n+\tApply_Divide_Check.\n+\t* s-bignum.adb (To_Bignum): Handle largest negative integer\n+\tproperly.\n+\t* sem.adb (Analyze): Handle overflow suppression correctly\n+\t(Analyze_List): Handle overflow suppression correctly\n+\t* sem_res.adb (Analyze_And_Resolve): Handle overflow suppression\n+\tcorrectly.\n+\n+2012-10-01  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* s-oscons-tmplt.c, g-socket.ads: Revert previous change, breaks VMS.\n+\n 2012-10-01  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.adb (Minimize_Eliminate_Overflow_Checks): Changes"}, {"sha": "3cbec969d3b65446e07cfcadf74f9981f727dc01", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 329, "deletions": 47, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -193,14 +193,6 @@ package body Checks is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Apply_Float_Conversion_Check\n-     (Ck_Node    : Node_Id;\n-      Target_Typ : Entity_Id);\n-   --  The checks on a conversion from a floating-point type to an integer\n-   --  type are delicate. They have to be performed before conversion, they\n-   --  have to raise an exception when the operand is a NaN, and rounding must\n-   --  be taken into account to determine the safe bounds of the operand.\n-\n    procedure Apply_Arithmetic_Overflow_Normal (N : Node_Id);\n    --  Used to apply arithmetic overflow checks for all cases except operators\n    --  on signed arithmetic types in Minimized/Eliminate case (for which we\n@@ -211,6 +203,24 @@ package body Checks is\n    --  checking mode is Minimized or Eliminated (and the Do_Overflow_Check flag\n    --  is known to be set) and we have an signed integer arithmetic op.\n \n+   procedure Apply_Division_Check\n+     (N   : Node_Id;\n+      Rlo : Uint;\n+      Rhi : Uint;\n+      ROK : Boolean);\n+   --  N is an N_Op_Div, N_Op_Rem, or N_Op_Mod node. This routine applies\n+   --  division checks as required if the Do_Division_Check flag is set.\n+   --  Rlo and Rhi give the possible range of the right operand, these values\n+   --  can be referenced and trusted only if ROK is set True.\n+\n+   procedure Apply_Float_Conversion_Check\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id);\n+   --  The checks on a conversion from a floating-point type to an integer\n+   --  type are delicate. They have to be performed before conversion, they\n+   --  have to raise an exception when the operand is a NaN, and rounding must\n+   --  be taken into account to determine the safe bounds of the operand.\n+\n    procedure Apply_Selected_Length_Checks\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id;\n@@ -1641,83 +1651,138 @@ package body Checks is\n           Reason    => CE_Discriminant_Check_Failed));\n    end Apply_Discriminant_Check;\n \n-   ------------------------\n-   -- Apply_Divide_Check --\n-   ------------------------\n+   -------------------------\n+   -- Apply_Divide_Checks --\n+   -------------------------\n \n-   procedure Apply_Divide_Check (N : Node_Id) is\n+   procedure Apply_Divide_Checks (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Typ   : constant Entity_Id  := Etype (N);\n       Left  : constant Node_Id    := Left_Opnd (N);\n       Right : constant Node_Id    := Right_Opnd (N);\n \n+      Mode : constant Overflow_Check_Type := Overflow_Check_Mode (Typ);\n+      --  Current overflow checking mode\n+\n       LLB : Uint;\n       Llo : Uint;\n       Lhi : Uint;\n       LOK : Boolean;\n       Rlo : Uint;\n       Rhi : Uint;\n-      ROK   : Boolean;\n+      ROK : Boolean;\n \n       pragma Warnings (Off, Lhi);\n       --  Don't actually use this value\n \n    begin\n+      --  If we are operating in MINIMIZED or ELIMINATED mode, and the\n+      --  Do_Overflow_Check flag is set and we are operating on signed\n+      --  integer types, then the only thing this routine does is to call\n+      --  Apply_Arithmetic_Overflow_Minimized_Eliminated. That procedure will\n+      --  (possibly later on during recursive downward calls), make sure that\n+      --  any needed overflow and division checks are properly applied.\n+\n+      if Mode in Minimized_Or_Eliminated\n+        and then Do_Overflow_Check (N)\n+        and then Is_Signed_Integer_Type (Typ)\n+      then\n+         Apply_Arithmetic_Overflow_Minimized_Eliminated (N);\n+         return;\n+      end if;\n+\n+      --  Proceed here in SUPPRESSED or CHECKED modes\n+\n       if Full_Expander_Active\n         and then not Backend_Divide_Checks_On_Target\n         and then Check_Needed (Right, Division_Check)\n       then\n          Determine_Range (Right, ROK, Rlo, Rhi, Assume_Valid => True);\n \n-         --  See if division by zero possible, and if so generate test. This\n-         --  part of the test is not controlled by the -gnato switch.\n+         --  Deal with division check\n \n-         if Do_Division_Check (N) then\n-            if (not ROK) or else (Rlo <= 0 and then 0 <= Rhi) then\n-               Insert_Action (N,\n-                 Make_Raise_Constraint_Error (Loc,\n-                   Condition =>\n-                     Make_Op_Eq (Loc,\n-                       Left_Opnd  => Duplicate_Subexpr_Move_Checks (Right),\n-                       Right_Opnd => Make_Integer_Literal (Loc, 0)),\n-                   Reason => CE_Divide_By_Zero));\n-            end if;\n+         if Do_Division_Check (N)\n+           and then not Division_Checks_Suppressed (Typ)\n+         then\n+            Apply_Division_Check (N, Rlo, Rhi, ROK);\n          end if;\n \n-         --  Test for extremely annoying case of xxx'First divided by -1\n+         --  Deal with overflow check\n+\n+         if Do_Overflow_Check (N) and then Mode /= Suppressed then\n+\n+            --  Test for extremely annoying case of xxx'First divided by -1\n+            --  for division of signed integer types (only overflow case).\n \n-         if Do_Overflow_Check (N) then\n             if Nkind (N) = N_Op_Divide\n               and then Is_Signed_Integer_Type (Typ)\n             then\n                Determine_Range (Left, LOK, Llo, Lhi, Assume_Valid => True);\n                LLB := Expr_Value (Type_Low_Bound (Base_Type (Typ)));\n \n                if ((not ROK) or else (Rlo <= (-1) and then (-1) <= Rhi))\n-                 and then\n-                 ((not LOK) or else (Llo = LLB))\n+                     and then\n+                  ((not LOK) or else (Llo = LLB))\n                then\n                   Insert_Action (N,\n                     Make_Raise_Constraint_Error (Loc,\n                       Condition =>\n                         Make_And_Then (Loc,\n+                          Left_Opnd  =>\n+                            Make_Op_Eq (Loc,\n+                              Left_Opnd  =>\n+                                Duplicate_Subexpr_Move_Checks (Left),\n+                              Right_Opnd => Make_Integer_Literal (Loc, LLB)),\n \n-                           Make_Op_Eq (Loc,\n-                             Left_Opnd  =>\n-                               Duplicate_Subexpr_Move_Checks (Left),\n-                             Right_Opnd => Make_Integer_Literal (Loc, LLB)),\n+                          Right_Opnd =>\n+                            Make_Op_Eq (Loc,\n+                              Left_Opnd  => Duplicate_Subexpr (Right),\n+                              Right_Opnd => Make_Integer_Literal (Loc, -1))),\n \n-                           Make_Op_Eq (Loc,\n-                             Left_Opnd =>\n-                               Duplicate_Subexpr (Right),\n-                             Right_Opnd =>\n-                               Make_Integer_Literal (Loc, -1))),\n                       Reason => CE_Overflow_Check_Failed));\n                end if;\n             end if;\n          end if;\n       end if;\n-   end Apply_Divide_Check;\n+   end Apply_Divide_Checks;\n+\n+   --------------------------\n+   -- Apply_Division_Check --\n+   --------------------------\n+\n+   procedure Apply_Division_Check\n+     (N   : Node_Id;\n+      Rlo : Uint;\n+      Rhi : Uint;\n+      ROK : Boolean)\n+   is\n+      pragma Assert (Do_Division_Check (N));\n+\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Right : constant Node_Id    := Right_Opnd (N);\n+\n+   begin\n+      if Full_Expander_Active\n+        and then not Backend_Divide_Checks_On_Target\n+        and then Check_Needed (Right, Division_Check)\n+      then\n+         --  See if division by zero possible, and if so generate test. This\n+         --  part of the test is not controlled by the -gnato switch, since\n+         --  it is a Division_Check and not an Overflow_Check.\n+\n+         if Do_Division_Check (N) then\n+            if (not ROK) or else (Rlo <= 0 and then 0 <= Rhi) then\n+               Insert_Action (N,\n+                 Make_Raise_Constraint_Error (Loc,\n+                   Condition =>\n+                     Make_Op_Eq (Loc,\n+                       Left_Opnd  => Duplicate_Subexpr_Move_Checks (Right),\n+                       Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+                   Reason => CE_Divide_By_Zero));\n+            end if;\n+         end if;\n+      end if;\n+   end Apply_Division_Check;\n \n    ----------------------------------\n    -- Apply_Float_Conversion_Check --\n@@ -6496,6 +6561,36 @@ package body Checks is\n       OK : Boolean;\n       --  Used in call to Determine_Range\n \n+      procedure Max (A : in out Uint; B : Uint);\n+      --  If A is No_Uint, sets A to B, else to UI_Max (A, B);\n+\n+      procedure Min (A : in out Uint; B : Uint);\n+      --  If A is No_Uint, sets A to B, else to UI_Min (A, B);\n+\n+      ---------\n+      -- Max --\n+      ---------\n+\n+      procedure Max (A : in out Uint; B : Uint) is\n+      begin\n+         if A = No_Uint or else B > A then\n+            A := B;\n+         end if;\n+      end Max;\n+\n+      ---------\n+      -- Min --\n+      ---------\n+\n+      procedure Min (A : in out Uint; B : Uint) is\n+      begin\n+         if A = No_Uint or else B < A then\n+            A := B;\n+         end if;\n+      end Min;\n+\n+   --  Start of processing for Minimize_Eliminate_Overflow_Checks\n+\n    begin\n       --  Case where we do not have an arithmetic operator.\n \n@@ -6559,7 +6654,148 @@ package body Checks is\n             --  Division\n \n             when N_Op_Divide =>\n-               raise Program_Error;\n+\n+               --  Following seems awfully complex, can it be simplified ???\n+\n+               Hi := No_Uint;\n+               Lo := No_Uint;\n+\n+               declare\n+                  S : Uint;\n+\n+               begin\n+                  --  First work on finding big absolute result values. These\n+                  --  come from dividing large numbers (which we have in Llo\n+                  --  and Lhi) by small values, which we need to figure out.\n+\n+                  --  Case where right operand can be positive\n+\n+                  if Rhi > 0 then\n+\n+                     --  Find smallest positive divisor\n+\n+                     if Rlo > 0 then\n+                        S := Rlo;\n+                     else\n+                        S := Uint_1;\n+                     end if;\n+\n+                     --  Big negative value divided by small positive value\n+                     --  generates a candidate for lowest possible result.\n+\n+                     if Llo < 0 then\n+                        Min (Lo, Llo / S);\n+                     end if;\n+\n+                     --  Big positive value divided by small positive value\n+                     --  generates a candidate for highest possible result.\n+\n+                     if Lhi > 0 then\n+                        Max (Hi, Lhi / S);\n+                     end if;\n+                  end if;\n+\n+                  --  Case where right operand can be negative\n+\n+                  if Rlo < 0 then\n+\n+                     --  Find smallest absolute value negative divisor\n+\n+                     if Rhi < 0 then\n+                        S := Rhi;\n+                     else\n+                        S := -Uint_1;\n+                     end if;\n+\n+                     --  Big negative value divided by small negative value\n+                     --  generates a candidate for largest possible result.\n+\n+                     if Llo < 0 then\n+                        Max (Hi, Llo / S);\n+                     end if;\n+\n+                     --  Big positive value divided by small negative value\n+                     --  generates a candidate for lowest possible result.\n+\n+                     if Lhi > 0 then\n+                        Min (Lo, Lhi / S);\n+                     end if;\n+                  end if;\n+\n+                  --  Now work on finding small absolute result values. These\n+                  --  come from dividing small numbers, which we need to figure\n+                  --  out, by large values (which we have in Rlo, Rhi).\n+\n+                  --  Case where left operand can be positive\n+\n+                  if Lhi > 0 then\n+\n+                     --  Find smallest positive dividend\n+\n+                     if Llo > 0 then\n+                        S := Llo;\n+                     else\n+                        S := Uint_1;\n+                     end if;\n+\n+                     --  Small positive values divided by large negative values\n+                     --  generate candidates for low results.\n+\n+                     if Rlo < 0 then\n+                        Min (Lo, S / Rlo);\n+                     end if;\n+\n+                     --  Small positive values divided by large positive values\n+                     --  generate candidates for high results.\n+\n+                     if Rhi > 0 then\n+                        Max (Hi, S / Rhi);\n+                     end if;\n+                  end if;\n+\n+                  --  Case where left operand can be negative\n+\n+                  if Llo < 0 then\n+\n+                     --  Find smallest absolute value negative dividend\n+\n+                     if Lhi < 0 then\n+                        S := Lhi;\n+                     else\n+                        S := -Uint_1;\n+                     end if;\n+\n+                     --  Small negative value divided by large negative value\n+                     --  generates a candidate for highest possible result.\n+\n+                     if Rlo < 0 then\n+                        Max (Hi, Rlo / S);\n+                     end if;\n+\n+                     --  Small negative value divided by large positive value\n+                     --  generates a candidate for lowest possible result.\n+\n+                     if Rhi > 0 then\n+                        Min (Lo, Rhi / S);\n+                     end if;\n+                  end if;\n+\n+                  --  Finally, if neither Lo or Hi set (happens if the right\n+                  --  operand is always zero for example), then set 0 .. 0.\n+\n+                  if Lo = No_Uint and then Hi = No_Uint then\n+                     Lo := Uint_0;\n+                     Hi := Uint_0;\n+\n+                  --  If one bound set and not the other copy\n+\n+                  elsif Lo = No_Uint then\n+                     Lo := Hi;\n+\n+                  elsif Hi = No_Uint then\n+                     Hi := Lo;\n+                  end if;\n+               end;\n \n             --  Exponentiation\n \n@@ -6647,7 +6883,26 @@ package body Checks is\n             --  Mod\n \n             when N_Op_Mod =>\n-               raise Program_Error;\n+               declare\n+                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi);\n+                  --  This is the maximum absolute value of the result\n+\n+               begin\n+                  Lo := Uint_0;\n+                  Hi := Uint_0;\n+\n+                  --  The result depends only on the sign and magnitude of\n+                  --  the right operand, it does not depend on the sign or\n+                  --  magnitude of the left operand.\n+\n+                  if Rlo < 0 then\n+                     Lo := -Maxabs;\n+                  end if;\n+\n+                  if Rhi > 0 then\n+                     Hi := Maxabs;\n+                  end if;\n+               end;\n \n             --  Multiplication\n \n@@ -6683,7 +6938,29 @@ package body Checks is\n             --  Remainder\n \n             when N_Op_Rem =>\n-               raise Program_Error;\n+               declare\n+                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi);\n+                  --  This is the maximum absolute value of the result. Note\n+                  --  that the result range does not depend on the sign of B.\n+\n+               begin\n+                  Lo := Uint_0;\n+                  Hi := Uint_0;\n+\n+                  --  Case of left operand negative, which results in a range\n+                  --  of -Maxabs .. 0 for those negative values. If there are\n+                  --  no negative values then Lo value of result is always 0.\n+\n+                  if Llo < 0 then\n+                     Lo := -Maxabs;\n+                  end if;\n+\n+                  --  Case of left operand positive\n+\n+                  if Lhi > 0 then\n+                     Hi := Maxabs;\n+                  end if;\n+               end;\n \n             --  Subtract\n \n@@ -6819,16 +7096,21 @@ package body Checks is\n       Set_Etype (N, Empty);\n       Set_Entity (N, Empty);\n \n-      --  Now analyze this new node\n+      --  Now analyze this new node. This reanalysis will complete processing\n+      --  for the node. In particular we will complete the expansion of an\n+      --  exponentiation operator (e.g. changing A ** 2 to A * A), and also\n+      --  we will complete any division checks (since we have not changed the\n+      --  setting of the Do_Division_Check flag).\n \n-      --  If no overflow check, suppress all checks\n+      --  If no overflow check, suppress overflow check to avoid an infinite\n+      --  recursion into this procedure.\n \n       if not Do_Overflow_Check (N) then\n-         Analyze_And_Resolve (N, LLIB, Suppress => All_Checks);\n+         Analyze_And_Resolve (N, LLIB, Suppress => Overflow_Check);\n \n       --  If an overflow check is required, do it in normal CHECKED mode.\n-      --  That avoids an infinite recursion, makes sure we get a normal\n-      --  overflow check, and also completes expansion of Exponentiation.\n+      --  That avoids an infinite recursion, making sure we get a normal\n+      --  overflow check.\n \n       else\n          declare"}, {"sha": "9fd8034b777b74fb5a53ed3d32d9e849335433db", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -166,6 +166,13 @@ package Checks is\n    --  formals, the check is performed only if the corresponding actual is\n    --  constrained, i.e., whether Lhs'Constrained is True.\n \n+   procedure Apply_Divide_Checks (N : Node_Id);\n+   --  The node kind is N_Op_Divide, N_Op_Mod, or N_Op_Rem if either of the\n+   --  flags Do_Division_Check or Do_Overflow_Check is set, then this routine\n+   --  ensures that the appropriate checks are made. Note that overflow can\n+   --  occur in the signed case for the case of the largest negative number\n+   --  divided by minus one.\n+\n    procedure Apply_Parameter_Aliasing_And_Validity_Checks (Subp : Entity_Id);\n    --  Given a subprogram Subp, add both a pre and post condition pragmas that\n    --  detect aliased objects and verify the proper initialization of scalars\n@@ -176,12 +183,6 @@ package Checks is\n    --  for Typ, if Typ has a predicate function. The check is applied only\n    --  if the type of N does not match Typ.\n \n-   procedure Apply_Divide_Check (N : Node_Id);\n-   --  The node kind is N_Op_Divide, N_Op_Mod, or N_Op_Rem. An appropriate\n-   --  check is generated to ensure that the right operand is non-zero. In\n-   --  the divide case, we also check that we do not have the annoying case\n-   --  of the largest negative number divided by minus one.\n-\n    procedure Apply_Type_Conversion_Checks (N : Node_Id);\n    --  N is an N_Type_Conversion node. A type conversion actually involves\n    --  two sorts of checks. The first check is the checks that ensures that"}, {"sha": "dcf33824cfa847e46d0c210237c8e0503969f663", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -6584,7 +6584,7 @@ package body Exp_Ch4 is\n       --  Non-fixed point cases, do integer zero divide and overflow checks\n \n       elsif Is_Integer_Type (Typ) then\n-         Apply_Divide_Check (N);\n+         Apply_Divide_Checks (N);\n \n       --  Deal with Vax_Float\n \n@@ -7836,7 +7836,7 @@ package body Exp_Ch4 is\n \n       else\n          if Is_Integer_Type (Etype (N)) then\n-            Apply_Divide_Check (N);\n+            Apply_Divide_Checks (N);\n          end if;\n \n          --  Apply optimization x mod 1 = 0. We don't really need that with\n@@ -8469,7 +8469,7 @@ package body Exp_Ch4 is\n       Binary_Op_Validity_Checks (N);\n \n       if Is_Integer_Type (Etype (N)) then\n-         Apply_Divide_Check (N);\n+         Apply_Divide_Checks (N);\n       end if;\n \n       --  Apply optimization x rem 1 = 0. We don't really need that with gcc,"}, {"sha": "462556265a6880fbbfde21e98e750c962246fc77", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2012, AdaCore                     --\n+--                     Copyright (C) 2001-2011, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1155,7 +1155,10 @@ private\n \n    type Fd_Set is\n      new System.Storage_Elements.Storage_Array (1 .. SOSC.SIZEOF_fd_set);\n-   for Fd_Set'Alignment use SOSC.ALIGNOF_fd_set;\n+   for Fd_Set'Alignment use Interfaces.C.long'Alignment;\n+   --  Set conservative alignment so that our Fd_Sets are always adequately\n+   --  aligned for the underlying data type (which is implementation defined\n+   --  and may be an array of C long integers).\n \n    type Fd_Set_Access is access all Fd_Set;\n    pragma Convention (C, Fd_Set_Access);"}, {"sha": "bf8efcf72fdb58c3ed16bc12993dfb9833877438", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -1024,10 +1024,21 @@ package body System.Bignums is\n       if X = 0 then\n          R := Allocate_Bignum (0);\n \n+      --  One word result\n+\n       elsif X in -(2 ** 32 - 1) .. +(2 ** 32 - 1) then\n          R := Allocate_Bignum (1);\n          R.D (1) := SD (abs (X));\n \n+      --  Largest negative number annoyance\n+\n+      elsif X = Long_Long_Integer'First then\n+         R := Allocate_Bignum (2);\n+         R.D (1) := 2 ** 31;\n+         R.D (2) := 0;\n+\n+      --  Normal two word case\n+\n       else\n          R := Allocate_Bignum (2);\n          R.D (2) := SD (abs (X) mod Base);"}, {"sha": "50a55e43d231f493c0efc070b5853896a5975f37", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -1292,7 +1292,7 @@ CNS(MAX_tv_sec, \"\")\n }\n /*\n \n-   --  Sizes and alignments of various data types\n+   --  Sizes of various data types\n */\n \n #define SIZEOF_sockaddr_in (sizeof (struct sockaddr_in))\n@@ -1306,9 +1306,6 @@ CND(SIZEOF_sockaddr_in6, \"struct sockaddr_in6\")\n \n #define SIZEOF_fd_set (sizeof (fd_set))\n CND(SIZEOF_fd_set, \"fd_set\");\n-#define ALIGNOF_fd_set (__alignof__ (fd_set))\n-CND(ALIGNOF_fd_set, \"\");\n-\n CND(FD_SETSIZE, \"Max fd value\");\n \n #define SIZEOF_struct_hostent (sizeof (struct hostent))"}, {"sha": "bbd642536479b3ef31384b600e33456817cad960", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -730,6 +730,20 @@ package body Sem is\n             Scope_Suppress := Svg;\n          end;\n \n+      elsif Suppress = Overflow_Check then\n+         declare\n+            Svg : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_General;\n+            Sva : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_Assertions;\n+         begin\n+            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n+            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n+            Analyze (N);\n+            Scope_Suppress.Overflow_Checks_General    := Svg;\n+            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+         end;\n+\n       else\n          declare\n             Svg : constant Boolean := Scope_Suppress.Suppress (Suppress);\n@@ -769,6 +783,20 @@ package body Sem is\n             Scope_Suppress := Svg;\n          end;\n \n+      elsif Suppress = Overflow_Check then\n+         declare\n+            Svg : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_General;\n+            Sva : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_Assertions;\n+         begin\n+            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n+            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n+            Analyze_List (L);\n+            Scope_Suppress.Overflow_Checks_General    := Svg;\n+            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+         end;\n+\n       else\n          declare\n             Svg : constant Boolean := Scope_Suppress.Suppress (Suppress);"}, {"sha": "ee25ef15ee2e635f76cb609069c408b3197e90c2", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91e9ac73ddc90a31f5f9afcbc73558cb0e56006/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a91e9ac73ddc90a31f5f9afcbc73558cb0e56006", "patch": "@@ -322,7 +322,7 @@ package body Sem_Res is\n       Resolve (N, Typ);\n    end Analyze_And_Resolve;\n \n-   --  Version withs check(s) suppressed\n+   --  Versions with check(s) suppressed\n \n    procedure Analyze_And_Resolve\n      (N        : Node_Id;\n@@ -341,6 +341,20 @@ package body Sem_Res is\n             Scope_Suppress := Svg;\n          end;\n \n+      elsif Suppress = Overflow_Check then\n+         declare\n+            Svg : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_General;\n+            Sva : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_Assertions;\n+         begin\n+            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n+            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n+            Analyze_And_Resolve (N, Typ);\n+            Scope_Suppress.Overflow_Checks_General    := Svg;\n+            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+         end;\n+\n       else\n          declare\n             Svg : constant Boolean := Scope_Suppress.Suppress (Suppress);\n@@ -381,6 +395,20 @@ package body Sem_Res is\n             Scope_Suppress := Svg;\n          end;\n \n+      elsif Suppress = Overflow_Check then\n+         declare\n+            Svg : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_General;\n+            Sva : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_Assertions;\n+         begin\n+            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n+            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n+            Analyze_And_Resolve (N);\n+            Scope_Suppress.Overflow_Checks_General    := Svg;\n+            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+         end;\n+\n       else\n          declare\n             Svg : constant Boolean := Scope_Suppress.Suppress (Suppress);"}]}