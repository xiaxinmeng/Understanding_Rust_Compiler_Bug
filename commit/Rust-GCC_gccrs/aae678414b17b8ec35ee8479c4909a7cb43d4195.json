{"sha": "aae678414b17b8ec35ee8479c4909a7cb43d4195", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFlNjc4NDE0YjE3YjhlYzM1ZWU4NDc5YzQ5MDlhN2NiNDNkNDE5NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-08T10:46:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-08T10:46:16Z"}, "message": "(fold, case *_{DIV,MOD}_EXPR): When using distributive law, take care\nwhen C2 is negative.\n\nFrom-SVN: r6194", "tree": {"sha": "ba89090bcb9c210bd0f6fdde273dcad88d9409d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba89090bcb9c210bd0f6fdde273dcad88d9409d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aae678414b17b8ec35ee8479c4909a7cb43d4195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aae678414b17b8ec35ee8479c4909a7cb43d4195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aae678414b17b8ec35ee8479c4909a7cb43d4195", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aae678414b17b8ec35ee8479c4909a7cb43d4195/comments", "author": null, "committer": null, "parents": [{"sha": "a03f67cb3ca5a46627fd3af24a3f3cc33c8557ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03f67cb3ca5a46627fd3af24a3f3cc33c8557ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a03f67cb3ca5a46627fd3af24a3f3cc33c8557ba"}], "stats": {"total": 18, "additions": 13, "deletions": 5}, "files": [{"sha": "6821c0635b97a737c8965d16df91a7f6dd7acb7d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aae678414b17b8ec35ee8479c4909a7cb43d4195/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aae678414b17b8ec35ee8479c4909a7cb43d4195/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=aae678414b17b8ec35ee8479c4909a7cb43d4195", "patch": "@@ -3922,7 +3922,7 @@ fold (expr)\n \t where C1 % C3 == 0 or C3 % C1 == 0.  We can simplify these\n \t expressions, which often appear in the offsets or sizes of\n \t objects with a varying size.  Only deal with positive divisors\n-\t and multiplicands. \n+\t and multiplicands.   If C2 is negative, we must have C2 % C3 == 0.\n \n \t Look for NOPs and SAVE_EXPRs inside.  */\n \n@@ -3942,7 +3942,10 @@ fold (expr)\n \t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n \t    c2 = TREE_OPERAND (xarg0, 1), xarg0 = TREE_OPERAND (xarg0, 0);\n \t  else if (TREE_CODE (xarg0) == MINUS_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n+\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n+\t\t   /* If we are doing this computation unsigned, the negate\n+\t\t      is incorrect.  */\n+\t\t   && ! TREE_UNSIGNED (type))\n \t    {\n \t      c2 = fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (xarg0, 1)));\n \t      xarg0 = TREE_OPERAND (xarg0, 0);\n@@ -3959,7 +3962,10 @@ fold (expr)\n \t      && (integer_zerop (const_binop (TRUNC_MOD_EXPR,\n \t\t\t\t\t      TREE_OPERAND (xarg0, 1), arg1, 1))\n \t\t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, arg1,\n-\t\t\t\t\t\t TREE_OPERAND (xarg0, 1), 1))))\n+\t\t\t\t\t\t TREE_OPERAND (xarg0, 1), 1)))\n+\t      && (tree_int_cst_lt (integer_zero_node, c2)\n+\t\t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, c2,\n+\t\t\t\t\t\t arg1, 1))))\n \t    {\n \t      tree outer_div = integer_one_node;\n \t      tree c1 = TREE_OPERAND (xarg0, 1);\n@@ -4020,7 +4026,8 @@ fold (expr)\n \t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n \t    c2 = TREE_OPERAND (xarg0, 1), xarg0 = TREE_OPERAND (xarg0, 0);\n \t  else if (TREE_CODE (xarg0) == MINUS_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n+\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n+\t\t   && ! TREE_UNSIGNED (type))\n \t    {\n \t      c2 = fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (xarg0, 1)));\n \t      xarg0 = TREE_OPERAND (xarg0, 0);\n@@ -4032,7 +4039,8 @@ fold (expr)\n \t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n \t      && integer_zerop (const_binop (TRUNC_MOD_EXPR,\n \t\t\t\t\t     TREE_OPERAND (xarg0, 1),\n-\t\t\t\t\t     arg1, 1)))\n+\t\t\t\t\t     arg1, 1))\n+\t      && tree_int_cst_lt (integer_zero_node, c2))\n \t    /* The result is (C2%C3).  */\n \t    return omit_one_operand (type, const_binop (code, c2, arg1, 1),\n \t\t\t\t     TREE_OPERAND (xarg0, 0));"}]}