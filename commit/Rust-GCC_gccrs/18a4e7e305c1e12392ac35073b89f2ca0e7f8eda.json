{"sha": "18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhNGU3ZTMwNWMxZTEyMzkyYWMzNTA3M2I4OWYyY2EwZTdmOGVkYQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-12T18:06:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-12T18:06:52Z"}, "message": "re PR fortran/82173 ([meta-bug] Parameterized derived type errors)\n\n2017-09-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/82173\n\tPR fortran/82168\n\t* decl.c (variable_decl): Check pdt template components for\n\tappearance of KIND/LEN components in the type parameter name\n\tlist, that components corresponding to type parameters have\n\teither KIND or LEN attributes and that KIND or LEN components\n\tare scalar. Copy the initializer to the parameter value.\n\t(gfc_get_pdt_instance): Add a label 'error_return' and follow\n\tit with repeated code, while replacing this code with a jump.\n\tCheck if a parameter appears as a component in the template.\n\tMake sure that the parameter expressions are integer. Validate\n\tKIND expressions.\n\t(gfc_match_decl_type_spec): Search for pdt_types in the parent\n\tnamespace since they are instantiated in the template ns.\n\t* expr.c (gfc_extract_int): Use a KIND parameter if it\n\tappears as a component expression.\n\t(gfc_check_init_expr): Allow expressions with the pdt_kind\n\tattribute.\n\t*primary.c (gfc_match_actual_arglist): Make sure that the first\n\tkeyword argument is recognised when 'pdt' is set.\n\n\n2017-09-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/82173\n\t* gfortran.dg/pdt_4.f03 : Remove the 'is being used before it\n\tis defined' error.\n\t* gfortran.dg/pdt_6.f03 : New test.\n\t* gfortran.dg/pdt_7.f03 : New test.\n\t* gfortran.dg/pdt_8.f03 : New test.\n\n\tPR fortran/82168\n\t* gfortran.dg/pdt_9.f03 : New test.\n\nFrom-SVN: r252039", "tree": {"sha": "35868a7bbccbfde8c2a0a0a67d0e69c9c17b1d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35868a7bbccbfde8c2a0a0a67d0e69c9c17b1d6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/comments", "author": null, "committer": null, "parents": [{"sha": "29788f907095044876531d7b4df154ad8398f854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29788f907095044876531d7b4df154ad8398f854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29788f907095044876531d7b4df154ad8398f854"}], "stats": {"total": 373, "additions": 303, "deletions": 70}, "files": [{"sha": "4db5051e0edf9a48e71a6c125cdc7e8431b1dc4d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -1,3 +1,26 @@\n+2017-09-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/82173\n+\tPR fortran/82168\n+\t* decl.c (variable_decl): Check pdt template components for\n+\tappearance of KIND/LEN components in the type parameter name\n+\tlist, that components corresponding to type parameters have\n+\teither KIND or LEN attributes and that KIND or LEN components\n+\tare scalar. Copy the initializer to the parameter value.\n+\t(gfc_get_pdt_instance): Add a label 'error_return' and follow\n+\tit with repeated code, while replacing this code with a jump.\n+\tCheck if a parameter appears as a component in the template.\n+\tMake sure that the parameter expressions are integer. Validate\n+\tKIND expressions.\n+\t(gfc_match_decl_type_spec): Search for pdt_types in the parent\n+\tnamespace since they are instantiated in the template ns.\n+\t* expr.c (gfc_extract_int): Use a KIND parameter if it\n+\tappears as a component expression.\n+\t(gfc_check_init_expr): Allow expressions with the pdt_kind\n+\tattribute.\n+\t*primary.c (gfc_match_actual_arglist): Make sure that the first\n+\tkeyword argument is recognised when 'pdt' is set.\n+\n 2017-09-10  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/34640"}, {"sha": "6e78d0d0e495ac65b5402a004c217b9022837f1f", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 107, "deletions": 19, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -2537,6 +2537,39 @@ variable_decl (int elem)\n       goto cleanup;\n     }\n \n+  if (gfc_current_state () == COMP_DERIVED\n+      && gfc_current_block ()->attr.pdt_template)\n+    {\n+      gfc_symbol *param;\n+      gfc_find_symbol (name, gfc_current_block ()->f2k_derived,\n+\t\t       0, &param);\n+      if (!param && (current_attr.pdt_kind || current_attr.pdt_len))\n+\t{\n+\t  gfc_error (\"The component with KIND or LEN attribute at %C does not \"\n+\t\t     \"not appear in the type parameter list at %L\",\n+\t\t     &gfc_current_block ()->declared_at);\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+      else if (param && !(current_attr.pdt_kind || current_attr.pdt_len))\n+\t{\n+\t  gfc_error (\"The component at %C that appears in the type parameter \"\n+\t\t     \"list at %L has neither the KIND nor LEN attribute\",\n+\t\t     &gfc_current_block ()->declared_at);\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+      else if (as && (current_attr.pdt_kind || current_attr.pdt_len))\n+\t{\n+\t  gfc_error (\"The component at %C which is a type parameter must be \"\n+\t\t     \"a scalar\");\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+      else if (param && initializer)\n+\tparam->value = gfc_copy_expr (initializer);\n+    }\n+\n   /* Add the initializer.  Note that it is fine if initializer is\n      NULL here, because we sometimes also need to check if a\n      declaration *must* have an initialization expression.  */\n@@ -3193,19 +3226,35 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \t    {\n \t      gfc_error (\"The type parameter spec list at %C cannot contain \"\n \t\t\t \"both ASSUMED and DEFERRED parameters\");\n-\t      gfc_free_actual_arglist (type_param_spec_list);\n-\t      return MATCH_ERROR;\n+\t      goto error_return;\n \t    }\n \t}\n \n       if (actual_param && actual_param->name)\n \tname_seen = true;\n       param = type_param_name_list->sym;\n \n+      c1 = gfc_find_component (pdt, param->name, false, true, NULL);\n+      if (!pdt->attr.use_assoc && !c1)\n+\t{\n+\t  gfc_error (\"The type parameter name list at %L contains a parameter \"\n+\t\t     \"'%qs' , which is not declared as a component of the type\",\n+\t\t     &pdt->declared_at, param->name);\n+\t  goto error_return;\n+\t}\n+\n       kind_expr = NULL;\n       if (!name_seen)\n \t{\n-\t  if (actual_param && actual_param->spec_type == SPEC_EXPLICIT)\n+\t  if (!actual_param && !(c1 && c1->initializer))\n+\t    {\n+\t      gfc_error (\"The type parameter spec list at %C does not contain \"\n+\t\t\t \"enough parameter expressions\");\n+\t      goto error_return;\n+\t    }\n+\t  else if (!actual_param && c1 && c1->initializer)\n+\t    kind_expr = gfc_copy_expr (c1->initializer);\n+\t  else if (actual_param && actual_param->spec_type == SPEC_EXPLICIT)\n \t    kind_expr = gfc_copy_expr (actual_param->expr);\n \t}\n       else\n@@ -3225,7 +3274,7 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \t\t{\n \t\t  gfc_error (\"The derived parameter '%qs' at %C does not \"\n \t\t\t     \"have a default value\", param->name);\n-\t\t  return MATCH_ERROR;\n+\t\t  goto error_return;\n \t\t}\n \t    }\n \t}\n@@ -3247,6 +3296,17 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \n       if (kind_expr)\n \t{\n+\t  /* Variable expressions seem to default to BT_PROCEDURE.\n+\t     TODO find out why this is and fix it.  */\n+\t  if (kind_expr->ts.type != BT_INTEGER\n+\t      && kind_expr->ts.type != BT_PROCEDURE)\n+\t    {\n+\t      gfc_error (\"The parameter expression at %C must be of \"\n+\t\t         \"INTEGER type and not %s type\",\n+\t\t\t gfc_basic_typename (kind_expr->ts.type));\n+\t      goto error_return;\n+\t    }\n+\n \t  tail->expr = gfc_copy_expr (kind_expr);\n \t  /* Try simplification even for LEN expressions.  */\n \t  gfc_simplify_expr (tail->expr, 1);\n@@ -3257,7 +3317,7 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \n       if (!param->attr.pdt_kind)\n \t{\n-\t  if (!name_seen)\n+\t  if (!name_seen && actual_param)\n \t    actual_param = actual_param->next;\n \t  if (kind_expr)\n \t    {\n@@ -3273,16 +3333,14 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \t{\n \t  gfc_error (\"The KIND parameter '%qs' at %C cannot either be \"\n \t\t     \"ASSUMED or DEFERRED\", param->name);\n-\t  gfc_free_actual_arglist (type_param_spec_list);\n-\t  return MATCH_ERROR;\n+\t  goto error_return;\n \t}\n \n       if (!kind_expr || !gfc_is_constant_expr (kind_expr))\n \t{\n \t  gfc_error (\"The value for the KIND parameter '%qs' at %C does not \"\n \t\t     \"reduce to a constant expression\", param->name);\n-\t  gfc_free_actual_arglist (type_param_spec_list);\n-\t  return MATCH_ERROR;\n+\t  goto error_return;\n \t}\n \n       gfc_extract_int (kind_expr, &kind_value);\n@@ -3293,12 +3351,19 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n       gfc_free_expr (kind_expr);\n     }\n \n+  if (!name_seen && actual_param)\n+    {\n+      gfc_error (\"The type parameter spec list at %C contains too many \"\n+\t\t \"parameter expressions\");\n+      goto error_return;\n+    }\n+\n   /* Now we search for the PDT instance 'name'. If it doesn't exist, we\n      build it, using 'pdt' as a template.  */\n   if (gfc_get_symbol (name, pdt->ns, &instance))\n     {\n       gfc_error (\"Parameterized derived type at %C is ambiguous\");\n-      return MATCH_ERROR;\n+      goto error_return;\n     }\n \n   m = MATCH_YES;\n@@ -3370,7 +3435,7 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \t      gfc_error (\"Maximum extension level reached with type %qs at %L\",\n \t\t\t c2->ts.u.derived->name,\n \t\t\t &c2->ts.u.derived->declared_at);\n-\t      return MATCH_ERROR;\n+\t      goto error_return;\n \t    }\n \t  instance->attr.extension = c2->ts.u.derived->attr.extension + 1;\n \n@@ -3390,6 +3455,12 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \t  gfc_insert_kind_parameter_exprs (e);\n \t  gfc_extract_int (e, &c2->ts.kind);\n \t  gfc_free_expr (e);\n+\t  if (gfc_validate_kind (c2->ts.type, c2->ts.kind, true) < 0)\n+\t    {\n+\t      gfc_error (\"Kind %d not supported for type %s at %C\",\n+\t\t\t c2->ts.kind, gfc_basic_typename (c2->ts.type));\n+\t      goto error_return;\n+\t    }\n \t}\n \n       /* Similarly, set the string length if parameterized.  */\n@@ -3499,6 +3570,10 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n     *ext_param_list = type_param_spec_list;\n   *sym = instance;\n   return m;\n+\n+error_return:\n+  gfc_free_actual_arglist (type_param_spec_list);\n+  return MATCH_ERROR;\n }\n \n \n@@ -3829,6 +3904,19 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t}\n       if (sym->generic && !dt_sym)\n \tdt_sym = gfc_find_dt_in_generic (sym);\n+\n+      /* Host associated PDTs can get confused with their constructors\n+\t because they ar instantiated in the template's namespace.  */\n+      if (!dt_sym)\n+\t{\n+\t  if (gfc_find_symbol (dt_name, NULL, 1, &dt_sym))\n+\t    {\n+\t      gfc_error (\"Type name %qs at %C is ambiguous\", name);\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  if (dt_sym && !dt_sym->attr.pdt_type)\n+\t    dt_sym = NULL;\n+\t}\n     }\n   else if (ts->kind == -1)\n     {\n@@ -3861,14 +3949,14 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n   if (sym && sym->attr.flavor == FL_DERIVED\n       && sym->attr.pdt_template\n       && gfc_current_state () != COMP_DERIVED)\n-\t{\n-\t  m = gfc_get_pdt_instance (decl_type_param_list, &sym, NULL);\n-\t  if (m != MATCH_YES)\n-\t    return m;\n-\t  gcc_assert (!sym->attr.pdt_template && sym->attr.pdt_type);\n-\t  ts->u.derived = sym;\n-\t  strcpy (name, gfc_dt_lower_string (sym->name));\n-\t}\n+    {\n+      m = gfc_get_pdt_instance (decl_type_param_list, &sym, NULL);\n+      if (m != MATCH_YES)\n+\treturn m;\n+      gcc_assert (!sym->attr.pdt_template && sym->attr.pdt_type);\n+      ts->u.derived = sym;\n+      strcpy (name, gfc_dt_lower_string (sym->name));\n+    }\n \n   gfc_save_symbol_data (sym);\n   gfc_set_sym_referenced (sym);"}, {"sha": "87ea09f03d64a8cab9e02038d2c0c2f366e59f54", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -624,6 +624,20 @@ gfc_replace_expr (gfc_expr *dest, gfc_expr *src)\n bool\n gfc_extract_int (gfc_expr *expr, int *result, int report_error)\n {\n+  gfc_ref *ref;\n+\n+  /* A KIND component is a parameter too. The expression for it\n+     is stored in the initializer and should be consistent with\n+     the tests below.  */\n+  if (gfc_expr_attr(expr).pdt_kind)\n+    {\n+      for (ref = expr->ref; ref; ref = ref->next)\n+\t{\n+\t   if (ref->u.c.component->attr.pdt_kind)\n+\t     expr = ref->u.c.component->initializer;\n+\t}\n+    }\n+\n   if (expr->expr_type != EXPR_CONSTANT)\n     {\n       if (report_error > 0)\n@@ -2548,7 +2562,7 @@ gfc_check_init_expr (gfc_expr *e)\n       t = true;\n \n       /* This occurs when parsing pdt templates.  */\n-      if (e->symtree->n.sym->attr.pdt_kind)\n+      if (gfc_expr_attr (e).pdt_kind)\n \tbreak;\n \n       if (gfc_check_iter_variable (e))"}, {"sha": "25658d7c650b92f8814fa0622a2cd2c2a07ff61c", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -1796,11 +1796,6 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp, bool pdt)\n \n       if (sub_flag && !pdt && gfc_match_char ('*') == MATCH_YES)\n \t{\n-\t  if (pdt)\n-\t    {\n-\t      tail->spec_type = SPEC_ASSUMED;\n-\t      goto next;\n-\t    }\n \t  m = gfc_match_st_label (&label);\n \t  if (m == MATCH_NO)\n \t    gfc_error (\"Expected alternate return label at %C\");\n@@ -1829,6 +1824,15 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp, bool pdt)\n \t    }\n \t  else\n \t    tail->spec_type = SPEC_EXPLICIT;\n+\n+\t  m = match_keyword_arg (tail, head, pdt);\n+\t  if (m == MATCH_YES)\n+\t    {\n+\t      seen_keyword = 1;\n+\t      goto next;\n+\t    }\n+\t  if (m == MATCH_ERROR)\n+\t    goto cleanup;\n \t}\n \n       /* After the first keyword argument is seen, the following"}, {"sha": "68a76c4e4cf123e0b914938c2cfdd1d6511017e1", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -308,7 +308,7 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n           sym->ts.f90_type = sym->ts.type;\n         }\n     }\n-  \n+\n   return true;\n }\n \n@@ -464,7 +464,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \t  case FL_NAMELIST:\n \t    gfc_error (\"Namelist group name at %L cannot have the \"\n \t\t       \"SAVE attribute\", where);\n-\t    return false; \n+\t    return false;\n \t  case FL_PROCEDURE:\n \t    /* Conflicts between SAVE and PROCEDURE will be checked at\n \t       resolution stage, see \"resolve_fl_procedure\".  */\n@@ -513,7 +513,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)\n     conf (external, subroutine);\n \n-  if (attr->proc_pointer && !gfc_notify_std (GFC_STD_F2003, \n+  if (attr->proc_pointer && !gfc_notify_std (GFC_STD_F2003,\n \t\t\t\t\t     \"Procedure pointer at %C\"))\n     return false;\n \n@@ -1197,8 +1197,8 @@ gfc_add_protected (symbol_attribute *attr, const char *name, locus *where)\n \n   if (attr->is_protected)\n     {\n-\tif (!gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t     \"Duplicate PROTECTED attribute specified at %L\", \n+\tif (!gfc_notify_std (GFC_STD_LEGACY,\n+\t\t\t     \"Duplicate PROTECTED attribute specified at %L\",\n \t\t\t     where))\n \t  return false;\n     }\n@@ -1241,8 +1241,8 @@ gfc_add_save (symbol_attribute *attr, save_state s, const char *name,\n \n   if (s == SAVE_EXPLICIT && attr->save == SAVE_EXPLICIT)\n     {\n-\tif (!gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t     \"Duplicate SAVE attribute specified at %L\", \n+\tif (!gfc_notify_std (GFC_STD_LEGACY,\n+\t\t\t     \"Duplicate SAVE attribute specified at %L\",\n \t\t\t     where))\n \t  return false;\n     }\n@@ -1261,8 +1261,8 @@ gfc_add_value (symbol_attribute *attr, const char *name, locus *where)\n \n   if (attr->value)\n     {\n-\tif (!gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t     \"Duplicate VALUE attribute specified at %L\", \n+\tif (!gfc_notify_std (GFC_STD_LEGACY,\n+\t\t\t     \"Duplicate VALUE attribute specified at %L\",\n \t\t\t     where))\n \t  return false;\n     }\n@@ -1280,8 +1280,8 @@ gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n      given a VOLATILE attribute - unless it is a coarray (F2008, C560).  */\n \n   if (attr->volatile_ && attr->volatile_ns == gfc_current_ns)\n-    if (!gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t \"Duplicate VOLATILE attribute specified at %L\", \n+    if (!gfc_notify_std (GFC_STD_LEGACY,\n+\t\t\t \"Duplicate VOLATILE attribute specified at %L\",\n \t\t\t where))\n       return false;\n \n@@ -1299,8 +1299,8 @@ gfc_add_asynchronous (symbol_attribute *attr, const char *name, locus *where)\n      given a ASYNCHRONOUS attribute.  */\n \n   if (attr->asynchronous && attr->asynchronous_ns == gfc_current_ns)\n-    if (!gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t \"Duplicate ASYNCHRONOUS attribute specified at %L\", \n+    if (!gfc_notify_std (GFC_STD_LEGACY,\n+\t\t\t \"Duplicate ASYNCHRONOUS attribute specified at %L\",\n \t\t\t where))\n       return false;\n \n@@ -1814,10 +1814,10 @@ gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n     gfc_error_now (\"Duplicate BIND attribute specified at %L\", where);\n   else\n     attr->is_bind_c = 1;\n-  \n+\n   if (where == NULL)\n     where = &gfc_current_locus;\n-   \n+\n   if (!gfc_notify_std (GFC_STD_F2003, \"BIND(C) at %L\", where))\n     return false;\n \n@@ -1970,7 +1970,7 @@ bool\n gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n {\n   int is_proc_lang_bind_spec;\n-  \n+\n   /* In line with the other attributes, we only add bits but do not remove\n      them; cf. also PR 41034.  */\n   dest->ext_attr |= src->ext_attr;\n@@ -2081,7 +2081,7 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n     dest->is_c_interop = 1;\n   if (src->is_iso_c)\n     dest->is_iso_c = 1;\n-  \n+\n   if (src->external && !gfc_add_external (dest, where))\n     goto fail;\n   if (src->intrinsic && !gfc_add_intrinsic (dest, where))\n@@ -2341,7 +2341,7 @@ find_union_component (gfc_symbol *un, const char *name,\n    not found or the components are private.  If noaccess is set, no access\n    checks are done.  If silent is set, an error will not be generated if\n    the component cannot be found or accessed.\n-   \n+\n    If ref is not NULL, *ref is set to represent the chain of components\n    required to get to the ultimate component.\n \n@@ -2530,7 +2530,7 @@ free_st_labels (gfc_st_label *label)\n \n   free_st_labels (label->left);\n   free_st_labels (label->right);\n-  \n+\n   if (label->format != NULL)\n     gfc_free_expr (label->format);\n   free (label);\n@@ -3022,7 +3022,7 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)\n   p->f2k_derived = NULL;\n   p->assoc = NULL;\n   p->fn_result_spec = 0;\n-  \n+\n   return p;\n }\n \n@@ -3379,7 +3379,7 @@ find_common_symtree (gfc_symtree *st, gfc_common_head *head)\n     return st;\n \n   result = find_common_symtree (st->left, head);\n-  if (!result)  \n+  if (!result)\n     result = find_common_symtree (st->right, head);\n \n   return result;\n@@ -3403,7 +3403,7 @@ gfc_new_undo_checkpoint (gfc_undo_change_set &chg_syms)\n \n \n /* Restore previous state of symbol.  Just copy simple stuff.  */\n-  \n+\n static void\n restore_old_symbol (gfc_symbol *p)\n {\n@@ -3645,10 +3645,10 @@ free_old_symbol (gfc_symbol *sym)\n   if (sym->old_symbol == NULL)\n     return;\n \n-  if (sym->old_symbol->as != sym->as) \n+  if (sym->old_symbol->as != sym->as)\n     gfc_free_array_spec (sym->old_symbol->as);\n \n-  if (sym->old_symbol->value != sym->value) \n+  if (sym->old_symbol->value != sym->value)\n     gfc_free_expr (sym->old_symbol->value);\n \n   if (sym->old_symbol->formal != sym->formal)\n@@ -3741,7 +3741,7 @@ free_common_tree (gfc_symtree * common_tree)\n   free_common_tree (common_tree->right);\n \n   free (common_tree);\n-}  \n+}\n \n \n /* Recursive function that deletes an entire tree and all the common\n@@ -3890,7 +3890,7 @@ gfc_new_charlen (gfc_namespace *ns, gfc_charlen *old_cl)\n }\n \n \n-/* Free the charlen list from cl to end (end is not freed). \n+/* Free the charlen list from cl to end (end is not freed).\n    Free the whole list if end is NULL.  */\n \n void\n@@ -4047,7 +4047,7 @@ do_traverse_symtree (gfc_symtree *st, void (*st_func) (gfc_symtree *),\n   gcc_assert ((st_func && !sym_func) || (!st_func && sym_func));\n   nodes = count_st_nodes (st);\n   st_vec = XALLOCAVEC (gfc_symtree *, nodes);\n-  node_cntr = 0; \n+  node_cntr = 0;\n   fill_st_vector (st, st_vec, node_cntr);\n \n   if (sym_func)\n@@ -4265,7 +4265,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n   gfc_component *curr_comp = NULL;\n   bool is_c_interop = false;\n   bool retval = true;\n-   \n+\n   if (derived_sym == NULL)\n     gfc_internal_error (\"verify_bind_c_derived_type(): Given symbol is \"\n                         \"unexpectedly NULL\");\n@@ -4274,7 +4274,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n      so we don't repeat warnings/errors.  */\n   if (derived_sym->ts.is_c_interop)\n     return true;\n-  \n+\n   /* The derived type must have the BIND attribute to be interoperable\n      J3/04-007, Section 15.2.3.  */\n   if (derived_sym->attr.is_bind_c != 1)\n@@ -4285,7 +4285,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n                      &(derived_sym->declared_at));\n       retval = false;\n     }\n-  \n+\n   curr_comp = derived_sym->components;\n \n   /* Fortran 2003 allows an empty derived type.  C99 appears to disallow an\n@@ -4310,12 +4310,12 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n   /* Initialize the derived type as being C interoperable.\n      If we find an error in the components, this will be set false.  */\n   derived_sym->ts.is_c_interop = 1;\n-  \n+\n   /* Loop through the list of components to verify that the kind of\n      each is a C interoperable type.  */\n   do\n     {\n-      /* The components cannot be pointers (fortran sense).  \n+      /* The components cannot be pointers (fortran sense).\n          J3/04-007, Section 15.2.3, C1505.\t*/\n       if (curr_comp->attr.pointer != 0)\n         {\n@@ -4347,10 +4347,10 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n                      derived_sym->name, &(derived_sym->declared_at));\n           retval = false;\n         }\n-      \n+\n       /* BIND(C) derived types must have interoperable components.  */\n       if (curr_comp->ts.type == BT_DERIVED\n-\t  && curr_comp->ts.u.derived->ts.is_iso_c != 1 \n+\t  && curr_comp->ts.u.derived->ts.is_iso_c != 1\n           && curr_comp->ts.u.derived != derived_sym)\n         {\n           /* This should be allowed; the draft says a derived-type can not\n@@ -4361,9 +4361,9 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \t}\n       else\n \t{\n-\t  /* Grab the typespec for the given component and test the kind.  */ \n+\t  /* Grab the typespec for the given component and test the kind.  */\n \t  is_c_interop = gfc_verify_c_interop (&(curr_comp->ts));\n-\t  \n+\n \t  if (!is_c_interop)\n \t    {\n \t      /* Report warning and continue since not fatal.  The\n@@ -4395,9 +4395,9 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n                              &(curr_comp->loc));\n \t    }\n \t}\n-      \n+\n       curr_comp = curr_comp->next;\n-    } while (curr_comp != NULL); \n+    } while (curr_comp != NULL);\n \n \n   /* Make sure we don't have conflicts with the attributes.  */\n@@ -4422,7 +4422,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n      it's interoperable.  */\n   if (!retval)\n     derived_sym->ts.is_c_interop = 0;\n-  \n+\n   return retval;\n }\n \n@@ -4445,7 +4445,7 @@ gen_special_c_interop_ptr (gfc_symbol *tmp_sym, gfc_symtree *dt_symtree)\n   tmp_sym->ts.f90_type = BT_VOID;\n   tmp_sym->attr.flavor = FL_PARAMETER;\n   tmp_sym->ts.u.derived = dt_symtree->n.sym;\n-  \n+\n   /* Set the c_address field of c_null_ptr and c_null_funptr to\n      the value of NULL.\t */\n   tmp_sym->value = gfc_get_expr ();\n@@ -4480,10 +4480,10 @@ add_formal_arg (gfc_formal_arglist **head,\n       (*tail)->next = formal_arg;\n       (*tail) = formal_arg;\n     }\n-   \n+\n   (*tail)->sym = param_sym;\n   (*tail)->next = NULL;\n-   \n+\n   return;\n }\n \n@@ -4696,7 +4696,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n   switch (s)\n     {\n \n-#define NAMED_INTCST(a,b,c,d) case a : \n+#define NAMED_INTCST(a,b,c,d) case a :\n #define NAMED_REALCST(a,b,c,d) case a :\n #define NAMED_CMPXCST(a,b,c,d) case a :\n #define NAMED_LOGCST(a,b,c) case a :"}, {"sha": "ad989fd8ac2be1cd08bd740d9f3a1012c6880113", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -1,3 +1,15 @@\n+2017-09-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/82173\n+\t* gfortran.dg/pdt_4.f03 : Remove the 'is being used before it\n+\tis defined' error.\n+\t* gfortran.dg/pdt_6.f03 : New test.\n+\t* gfortran.dg/pdt_7.f03 : New test.\n+\t* gfortran.dg/pdt_8.f03 : New test.\n+\n+\tPR fortran/82168\n+\t* gfortran.dg/pdt_9.f03 : New test.\n+\n 2017-09-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82112"}, {"sha": "f585fae5f1edf07c854b5bd7902ff44ec603aaaf", "filename": "gcc/testsuite/gfortran.dg/pdt_4.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_4.f03?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -81,8 +81,8 @@ module vars\n   end select\n   deallocate (cz)\n contains\n-  subroutine foo(arg)               ! { dg-error \"has no IMPLICIT type\" }\n-    type (mytype(4, *)) :: arg      ! { dg-error \"is being used before it is defined\" }\n+  subroutine foo(arg)\n+    type (mytype(4, *)) :: arg      ! used to have an invalid \"is being used before it is defined\"\n   end subroutine\n   subroutine bar(arg)               ! { dg-error \"cannot have DEFERRED type parameters\" }\n     type (thytype(8, :, 4) :: arg"}, {"sha": "0c4bc6d3b80a621822f253ccc1dc723e53711d03", "filename": "gcc/testsuite/gfortran.dg/pdt_6.f03", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_6.f03?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+!\n+! Fixes of ICE on invalid & accepts invalid\n+!\n+! Contributed by Janus Weil  <janus@gcc.gnu.org>\n+!\n+implicit none\n+\n+type :: param_matrix(c,r)\n+  integer, len :: c,r\n+  real :: m(c,r)\n+end type\n+\n+type real_array(k)\n+  integer, kind :: k\n+  real(kind=k), allocatable :: r(:)\n+end type\n+\n+type(param_matrix(1)) :: m1       ! { dg-error \"does not contain enough parameter\" }\n+type(param_matrix(1,2)) :: m2     ! ok\n+type(param_matrix(1,2,3)) :: m3   ! { dg-error \"contains too many parameter\" }\n+type(param_matrix(1,2.5)) :: m4   ! { dg-error \"must be of INTEGER type\" }\n+\n+type(real_array(4)) :: a1         ! ok\n+type(real_array(5)) :: a2         ! { dg-error \"Kind 5 not supported for type REAL\" }\n+end"}, {"sha": "b987771aaa8eb957dadc8cadc82147bd5c760f26", "filename": "gcc/testsuite/gfortran.dg/pdt_7.f03", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_7.f03?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+!\n+! Rejected valid\n+!\n+! ! Contributed by Janus Weil  <janus@gcc.gnu.org>\n+!\n+implicit none\n+\n+type :: param_matrix(k,c,r)\n+  integer, kind :: k\n+  integer, len :: c,r\n+  real(kind=k) :: m(c,r)\n+end type\n+\n+type(param_matrix(8,3,2)) :: mat\n+real(kind=mat%k) :: m    ! Corrected error: Parameter \u2018mat\u2019 at (1) has not been declared or ...\n+\n+if (kind(m) .ne. 8) call abort\n+\n+end"}, {"sha": "d5e393e5e0c625b820d30d7b90ef18ac8684a702", "filename": "gcc/testsuite/gfortran.dg/pdt_8.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_8.f03?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+!\n+! Fixes of \"accepts invalid\".\n+! Note that the undeclared parameter 'y' in 't1' was originally in the\n+! type 't'. It turned out to be convenient to defer the error until the\n+! type is used in the declaration of 'z'.\n+!\n+! Contributed by Janus Weil  <janus@gcc.gnu.org>\n+!\n+implicit none\n+type :: t(i,a,x)         ! { dg-error \"does not|has neither\" }\n+  integer, kind :: k     ! { dg-error \"does not not appear in the type parameter list\" }\n+  integer :: i           ! { dg-error \"has neither the KIND nor LEN attribute\" }\n+  integer, kind :: a(3)  ! { dg-error \"must be a scalar\" }\n+  real, kind :: x        ! { dg-error \"must be INTEGER\" }\n+end type\n+\n+type :: t1(k,y)          ! { dg-error \"not declared as a component of the type\" }\n+  integer, kind :: k\n+end type\n+\n+type(t1(4,4)) :: z\n+end"}, {"sha": "afa1cddd163b1542bf0926414372aac4deae6374", "filename": "gcc/testsuite/gfortran.dg/pdt_9.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a4e7e305c1e12392ac35073b89f2ca0e7f8eda/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_9.f03?ref=18a4e7e305c1e12392ac35073b89f2ca0e7f8eda", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR82168 in which the declarations for 'a'\n+! and 'b' threw errors even though they are valid.\n+!\n+! Contributed by  <physiker@toast2.net>\n+!\n+module mod\n+  implicit none\n+  integer, parameter :: dp = kind (0.0d0)\n+  type, public :: v(z, k)\n+    integer, len :: z\n+    integer, kind :: k = kind(0.0)\n+    real(kind = k) :: e(z)\n+  end type v\n+end module mod\n+\n+program bug\n+  use mod\n+  implicit none\n+  type (v(2)) :: a     ! Missing parameter replaced by initializer.\n+  type (v(z=:, k=dp)), allocatable :: b ! Keyword was not working for '*' or ':'\n+end program bug"}]}