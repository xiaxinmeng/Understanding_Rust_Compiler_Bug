{"sha": "12a0a4d4821f9ff8af933551bf2569bcd5de9ec7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJhMGE0ZDQ4MjFmOWZmOGFmOTMzNTUxYmYyNTY5YmNkNWRlOWVjNw==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2010-06-03T07:53:17Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2010-06-03T07:53:17Z"}, "message": "arm.c (FL_TUNE): Define.\n\n2010-06-03  Paul Brook  <paul@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm.c (FL_TUNE): Define.\n\t(arm_default_cpu, arm_cpu_select): Remove.\n\t(all_cores): Populate core field.\n\t(arm_selected_arch, arm_selected_cpu, arm_selected_tune): New.\n\t(arm_find_cpu): New function.\n\t(arm_handle_option): Lookup cpu/architecture names.\n\t(arm_override_options): Cleanup mcpu/march/mtune handling.\n\t(arm_file_start): Ditto.\n\nFrom-SVN: r160213", "tree": {"sha": "f40e0ba762f9a973d2a00a2b07044e038c5609a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f40e0ba762f9a973d2a00a2b07044e038c5609a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7/comments", "author": null, "committer": null, "parents": [{"sha": "c3f247f4edf681cb26b66f318673d051667a4f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f247f4edf681cb26b66f318673d051667a4f16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f247f4edf681cb26b66f318673d051667a4f16"}], "stats": {"total": 197, "additions": 86, "deletions": 111}, "files": [{"sha": "c1603e36978f1675dc96d9fbc9110c1531b585b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12a0a4d4821f9ff8af933551bf2569bcd5de9ec7", "patch": "@@ -1,3 +1,14 @@\n+2010-06-03  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (FL_TUNE): Define.\n+\t(arm_default_cpu, arm_cpu_select): Remove.\n+\t(all_cores): Populate core field.\n+\t(arm_selected_arch, arm_selected_cpu, arm_selected_tune): New.\n+\t(arm_find_cpu): New function.\n+\t(arm_handle_option): Lookup cpu/architecture names.\n+\t(arm_override_options): Cleanup mcpu/march/mtune handling.\n+\t(arm_file_start): Ditto.\n+\n 2010-06-03  Alan Modra  <amodra@gmail.com>\n \n \tPR target/44169"}, {"sha": "b34086f40787ed9ae2d9138d10f82f9a9303fba9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 75, "deletions": 111, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a0a4d4821f9ff8af933551bf2569bcd5de9ec7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=12a0a4d4821f9ff8af933551bf2569bcd5de9ec7", "patch": "@@ -527,9 +527,6 @@ enum processor_type arm_tune = arm_none;\n /* The current tuning set.  */\n const struct tune_params *current_tune;\n \n-/* The default processor used if not overridden by commandline.  */\n-static enum processor_type arm_default_cpu = arm_none;\n-\n /* Which floating point hardware to schedule for.  */\n int arm_fpu_attr;\n \n@@ -585,6 +582,10 @@ static int thumb_call_reg_needed;\n \n #define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n \n+/* Flags that only effect tuning, not available instructions.  */\n+#define FL_TUNE\t\t(FL_WBUF | FL_VFPV2 | FL_STRONG | FL_LDSCHED \\\n+\t\t\t | FL_CO_PROC)\n+\n #define FL_FOR_ARCH2\tFL_NOTM\n #define FL_FOR_ARCH3\t(FL_FOR_ARCH2 | FL_MODE32)\n #define FL_FOR_ARCH3M\t(FL_FOR_ARCH3 | FL_ARCH3M)\n@@ -770,7 +771,7 @@ static const struct processors all_cores[] =\n {\n   /* ARM Cores */\n #define ARM_CORE(NAME, IDENT, ARCH, FLAGS, COSTS) \\\n-  {NAME, arm_none, #ARCH, FLAGS | FL_FOR_ARCH##ARCH, &arm_##COSTS##_tune},\n+  {NAME, IDENT, #ARCH, FLAGS | FL_FOR_ARCH##ARCH, &arm_##COSTS##_tune},\n #include \"arm-cores.def\"\n #undef ARM_CORE\n   {NULL, arm_none, NULL, 0, NULL}\n@@ -812,29 +813,12 @@ static const struct processors all_architectures[] =\n   {NULL, arm_none, NULL, 0 , NULL}\n };\n \n-struct arm_cpu_select\n-{\n-  const char *              string;\n-  const char *              name;\n-  const struct processors * processors;\n-};\n-\n-/* This is a magic structure.  The 'string' field is magically filled in\n-   with a pointer to the value specified by the user on the command line\n-   assuming that the user has specified such a value.  */\n \n-static struct arm_cpu_select arm_select[] =\n-{\n-  /* string\t  name            processors  */\n-  { NULL,\t\"-mcpu=\",\tall_cores  },\n-  { NULL,\t\"-march=\",\tall_architectures },\n-  { NULL,\t\"-mtune=\",\tall_cores }\n-};\n-\n-/* Defines representing the indexes into the above table.  */\n-#define ARM_OPT_SET_CPU 0\n-#define ARM_OPT_SET_ARCH 1\n-#define ARM_OPT_SET_TUNE 2\n+/* These are populated as commandline arguments are processed, or NULL\n+   if not specified.  */\n+static const struct processors *arm_selected_arch;\n+static const struct processors *arm_selected_cpu;\n+static const struct processors *arm_selected_tune;\n \n /* The name of the preprocessor macro to define for this architecture.  */\n \n@@ -1196,6 +1180,24 @@ arm_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n }\n \n+/* Lookup NAME in SEL.  */\n+\n+static const struct processors *\n+arm_find_cpu (const char *name, const struct processors *sel, const char *desc)\n+{\n+  if (!(name && *name))\n+    return NULL;\n+\n+  for (; sel->name != NULL; sel++)\n+    {\n+      if (streq (name, sel->name))\n+\treturn sel;\n+    }\n+\n+  error (\"bad value (%s) for %s switch\", name, desc);\n+  return NULL;\n+}\n+\n /* Implement TARGET_HANDLE_OPTION.  */\n \n static bool\n@@ -1204,11 +1206,11 @@ arm_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n   switch (code)\n     {\n     case OPT_march_:\n-      arm_select[1].string = arg;\n+      arm_selected_arch = arm_find_cpu(arg, all_architectures, \"-march\");\n       return true;\n \n     case OPT_mcpu_:\n-      arm_select[0].string = arg;\n+      arm_selected_cpu = arm_find_cpu(arg, all_cores, \"-mcpu\");\n       return true;\n \n     case OPT_mhard_float:\n@@ -1220,7 +1222,7 @@ arm_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n       return true;\n \n     case OPT_mtune_:\n-      arm_select[2].string = arg;\n+      arm_selected_tune = arm_find_cpu(arg, all_cores, \"-mtune\");\n       return true;\n \n     default:\n@@ -1320,88 +1322,52 @@ void\n arm_override_options (void)\n {\n   unsigned i;\n-  enum processor_type target_arch_cpu = arm_none;\n-  enum processor_type selected_cpu = arm_none;\n \n-  /* Set up the flags based on the cpu/architecture selected by the user.  */\n-  for (i = ARRAY_SIZE (arm_select); i--;)\n+  if (arm_selected_arch)\n     {\n-      struct arm_cpu_select * ptr = arm_select + i;\n-\n-      if (ptr->string != NULL && ptr->string[0] != '\\0')\n-        {\n-\t  const struct processors * sel;\n-\n-          for (sel = ptr->processors; sel->name != NULL; sel++)\n-            if (streq (ptr->string, sel->name))\n-              {\n-\t\t/* Set the architecture define.  */\n-\t\tif (i != ARM_OPT_SET_TUNE)\n-\t\t  sprintf (arm_arch_name, \"__ARM_ARCH_%s__\", sel->arch);\n-\n-\t\t/* Determine the processor core for which we should\n-\t\t   tune code-generation.  */\n-\t\tif (/* -mcpu= is a sensible default.  */\n-\t\t    i == ARM_OPT_SET_CPU\n-\t\t    /* -mtune= overrides -mcpu= and -march=.  */\n-\t\t    || i == ARM_OPT_SET_TUNE)\n-\t\t  arm_tune = (enum processor_type) (sel - ptr->processors);\n-\n-\t\t/* Remember the CPU associated with this architecture.\n-\t\t   If no other option is used to set the CPU type,\n-\t\t   we'll use this to guess the most suitable tuning\n-\t\t   options.  */\n-\t\tif (i == ARM_OPT_SET_ARCH)\n-\t\t  target_arch_cpu = sel->core;\n-\n-\t\tif (i == ARM_OPT_SET_CPU)\n-\t\t  selected_cpu = (enum processor_type) (sel - ptr->processors);\n-\t\t  \n-\t\tif (i != ARM_OPT_SET_TUNE)\n-\t\t  {\n-\t\t    /* If we have been given an architecture and a processor\n-\t\t       make sure that they are compatible.  We only generate\n-\t\t       a warning though, and we prefer the CPU over the\n-\t\t       architecture.  */\n-\t\t    if (insn_flags != 0 && (insn_flags ^ sel->flags))\n-\t\t      warning (0, \"switch -mcpu=%s conflicts with -march= switch\",\n-\t\t\t       ptr->string);\n-\n-\t\t    insn_flags = sel->flags;\n-\t\t  }\n-\n-                break;\n-              }\n-\n-          if (sel->name == NULL)\n-            error (\"bad value (%s) for %s switch\", ptr->string, ptr->name);\n-        }\n+      if (arm_selected_cpu)\n+\t{\n+\t  /* Check for conflict between mcpu and march.  */\n+\t  if ((arm_selected_cpu->flags ^ arm_selected_arch->flags) & ~FL_TUNE)\n+\t    {\n+\t      warning (0, \"switch -mcpu=%s conflicts with -march=%s switch\",\n+\t\t       arm_selected_cpu->name, arm_selected_arch->name);\n+\t      /* -march wins for code generation.\n+\t         -mcpu wins for default tuning.  */\n+\t      if (!arm_selected_tune)\n+\t\tarm_selected_tune = arm_selected_cpu;\n+\n+\t      arm_selected_cpu = arm_selected_arch;\n+\t    }\n+\t  else\n+\t    /* -mcpu wins.  */\n+\t    arm_selected_arch = NULL;\n+\t}\n+      else\n+\t/* Pick a CPU based on the architecture.  */\n+\tarm_selected_cpu = arm_selected_arch;\n     }\n \n-  /* Guess the tuning options from the architecture if necessary.  */\n-  if (arm_tune == arm_none)\n-    arm_tune = target_arch_cpu;\n-\n   /* If the user did not specify a processor, choose one for them.  */\n-  if (insn_flags == 0)\n+  if (!arm_selected_cpu)\n     {\n       const struct processors * sel;\n       unsigned int        sought;\n \n-      selected_cpu = (enum processor_type) TARGET_CPU_DEFAULT;\n-      if (selected_cpu == arm_none)\n+      arm_selected_cpu = &all_cores[TARGET_CPU_DEFAULT];\n+      if (!arm_selected_cpu->name)\n \t{\n #ifdef SUBTARGET_CPU_DEFAULT\n \t  /* Use the subtarget default CPU if none was specified by\n \t     configure.  */\n-\t  selected_cpu = (enum processor_type) SUBTARGET_CPU_DEFAULT;\n+\t  arm_selected_cpu = &all_cores[SUBTARGET_CPU_DEFAULT];\n #endif\n \t  /* Default to ARM6.  */\n-\t  if (selected_cpu == arm_none)\n-\t    selected_cpu = arm6;\n+\t  if (arm_selected_cpu->name)\n+\t    arm_selected_cpu = &all_cores[arm6];\n \t}\n-      sel = &all_cores[selected_cpu];\n \n+      sel = arm_selected_cpu;\n       insn_flags = sel->flags;\n \n       /* Now check to see if the user has specified some command line\n@@ -1462,20 +1428,21 @@ arm_override_options (void)\n \t      sel = best_fit;\n \t    }\n \n-\t  insn_flags = sel->flags;\n+\t  arm_selected_cpu = sel;\n \t}\n-      sprintf (arm_arch_name, \"__ARM_ARCH_%s__\", sel->arch);\n-      arm_default_cpu = (enum processor_type) (sel - all_cores);\n-      if (arm_tune == arm_none)\n-\tarm_tune = arm_default_cpu;\n     }\n \n-  /* The processor for which we should tune should now have been\n-     chosen.  */\n-  gcc_assert (arm_tune != arm_none);\n+  gcc_assert (arm_selected_cpu);\n+  /* The selected cpu may be an architecture, so lookup tuning by core ID.  */\n+  if (!arm_selected_tune)\n+    arm_selected_tune = &all_cores[arm_selected_cpu->core];\n+\n+  sprintf (arm_arch_name, \"__ARM_ARCH_%s__\", arm_selected_cpu->arch);\n+  insn_flags = arm_selected_cpu->flags;\n \n-  tune_flags = all_cores[(int)arm_tune].flags;\n-  current_tune = all_cores[(int)arm_tune].tune;\n+  arm_tune = arm_selected_tune->core;\n+  tune_flags = arm_selected_tune->flags;\n+  current_tune = arm_selected_tune->tune;\n \n   if (target_fp16_format_name)\n     {\n@@ -1858,7 +1825,7 @@ arm_override_options (void)\n   /* Enable -mfix-cortex-m3-ldrd by default for Cortex-M3 cores.  */\n   if (fix_cm3_ldrd == 2)\n     {\n-      if (selected_cpu == cortexm3)\n+      if (arm_selected_cpu->core == cortexm3)\n \tfix_cm3_ldrd = 1;\n       else\n \tfix_cm3_ldrd = 0;\n@@ -20167,13 +20134,10 @@ arm_file_start (void)\n   if (TARGET_BPABI)\n     {\n       const char *fpu_name;\n-      if (arm_select[0].string)\n-\tasm_fprintf (asm_out_file, \"\\t.cpu %s\\n\", arm_select[0].string);\n-      else if (arm_select[1].string)\n-\tasm_fprintf (asm_out_file, \"\\t.arch %s\\n\", arm_select[1].string);\n+      if (arm_selected_arch)\n+\tasm_fprintf (asm_out_file, \"\\t.arch %s\\n\", arm_selected_arch->name);\n       else\n-\tasm_fprintf (asm_out_file, \"\\t.cpu %s\\n\",\n-\t\t     all_cores[arm_default_cpu].name);\n+\tasm_fprintf (asm_out_file, \"\\t.cpu %s\\n\", arm_selected_cpu->name);\n \n       if (TARGET_SOFT_FLOAT)\n \t{"}]}