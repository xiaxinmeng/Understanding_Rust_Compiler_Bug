{"sha": "be482a8c830c9f79a14c76a901665707c34fe15a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU0ODJhOGM4MzBjOWY3OWExNGM3NmE5MDE2NjU3MDdjMzRmZTE1YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T11:59:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T11:59:08Z"}, "message": "[multiple changes]\n\n2011-11-21  Robert Dewar  <dewar@adacore.com>\n\n\t* sinput.ads: Minor comment fix.\n\n2011-11-21  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference, case First_Bit,\n\tLast_Bit, Position): Handle 2005 case.\n\n2011-11-21  Robert Dewar  <dewar@adacore.com>\n\n\t* s-atocou-builtin.adb (Decrement): Use Unrestricted_Access\n\tto deal with fact that we properly detect the error if Access\n\tis used.\n\t(Increment): Same fix.\n\t* s-taprop-linux.adb (Create_Task): Use Unrestricted_Access\n\tto deal with fact that we properly detect the error if Access\n\tis used.\n\t* sem_util.adb (Is_Volatile_Object): Properly record that A.B is\n\tvolatile if the B component is volatile. This affects the check\n\tfor passing such a by reference volatile actual to a non-volatile\n\tformal (which should be illegal)\n\n2011-11-21  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Freeze_Enumeration_Type): Make sure to set both\n\tsize and alignment for foreign convention enumeration types.\n\t* layout.adb (Set_Elem_Alignment): Redo setting of alignment\n\twhen size is set.\n\n2011-11-21  Yannick Moy  <moy@adacore.com>\n\n\t* checks.adb (Apply_Access_Check, Apply_Arithmetic_Overflow_Check,\n\tApply_Discriminant_Check, Apply_Divide_Check,\n\tApply_Selected_Length_Checks, Apply_Selected_Range_Checks,\n\tBuild_Discriminant_Checks, Insert_Range_Checks, Selected_Length_Checks,\n\tSelected_Range_Checks): Replace reference to Expander_Active\n\twith reference to Full_Expander_Active, so that expansion of\n\tchecks is not performed in Alfa mode\n\n2011-11-21  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-taprop-vms.adb (Create_Task): Use Unrestricted_Access to deal with\n\tfact that we properly detect the error if Access is used.\n\n2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* par-ch4.adb (P_Quantified_Expression): Add an Ada 2012 check.\n\n2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_imgv.adb: Add with and use clause for Errout.\n\t(Expand_Width_Attribute): Emit a warning when in\n\tconfigurable run-time mode to provide a better diagnostic message.\n\n2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* s-finmas.adb (Finalize): Add comment concerning double finalization.\n\n2011-11-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Access_Definition): If the access definition\n\tis itself the return type of an access to function definition\n\twhich is ultimately the return type of an access to subprogram\n\tdeclaration, its scope is the enclosing scope of the ultimate\n\taccess to subprogram.\n\n2011-11-21  Steve Baird  <baird@adacore.com>\n\n\t* sem_res.adb (Valid_Conversion): If a conversion was legal\n\tin the body of a generic, then the corresponding conversion is\n\tlegal in the expanded body of an instance of the generic.\n\nFrom-SVN: r181568", "tree": {"sha": "8ccd373effc49c9c552a0f33e7c0bc0215b16b92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ccd373effc49c9c552a0f33e7c0bc0215b16b92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be482a8c830c9f79a14c76a901665707c34fe15a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be482a8c830c9f79a14c76a901665707c34fe15a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be482a8c830c9f79a14c76a901665707c34fe15a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be482a8c830c9f79a14c76a901665707c34fe15a/comments", "author": null, "committer": null, "parents": [{"sha": "8e0aa19b43f234c3a7c41287d9fb985e2a6e882f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e0aa19b43f234c3a7c41287d9fb985e2a6e882f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e0aa19b43f234c3a7c41287d9fb985e2a6e882f"}], "stats": {"total": 396, "additions": 337, "deletions": 59}, "files": [{"sha": "d1aad1ded0a52e8065da57a613158f5c3f49e189", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -1,3 +1,76 @@\n+2011-11-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinput.ads: Minor comment fix.\n+\n+2011-11-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference, case First_Bit,\n+\tLast_Bit, Position): Handle 2005 case.\n+\n+2011-11-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-atocou-builtin.adb (Decrement): Use Unrestricted_Access\n+\tto deal with fact that we properly detect the error if Access\n+\tis used.\n+\t(Increment): Same fix.\n+\t* s-taprop-linux.adb (Create_Task): Use Unrestricted_Access\n+\tto deal with fact that we properly detect the error if Access\n+\tis used.\n+\t* sem_util.adb (Is_Volatile_Object): Properly record that A.B is\n+\tvolatile if the B component is volatile. This affects the check\n+\tfor passing such a by reference volatile actual to a non-volatile\n+\tformal (which should be illegal)\n+\n+2011-11-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Freeze_Enumeration_Type): Make sure to set both\n+\tsize and alignment for foreign convention enumeration types.\n+\t* layout.adb (Set_Elem_Alignment): Redo setting of alignment\n+\twhen size is set.\n+\n+2011-11-21  Yannick Moy  <moy@adacore.com>\n+\n+\t* checks.adb (Apply_Access_Check, Apply_Arithmetic_Overflow_Check,\n+\tApply_Discriminant_Check, Apply_Divide_Check,\n+\tApply_Selected_Length_Checks, Apply_Selected_Range_Checks,\n+\tBuild_Discriminant_Checks, Insert_Range_Checks, Selected_Length_Checks,\n+\tSelected_Range_Checks): Replace reference to Expander_Active\n+\twith reference to Full_Expander_Active, so that expansion of\n+\tchecks is not performed in Alfa mode\n+\n+2011-11-21  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-taprop-vms.adb (Create_Task): Use Unrestricted_Access to deal with\n+\tfact that we properly detect the error if Access is used.\n+\n+2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* par-ch4.adb (P_Quantified_Expression): Add an Ada 2012 check.\n+\n+2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_imgv.adb: Add with and use clause for Errout.\n+\t(Expand_Width_Attribute): Emit a warning when in\n+\tconfigurable run-time mode to provide a better diagnostic message.\n+\n+2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* s-finmas.adb (Finalize): Add comment concerning double finalization.\n+\n+2011-11-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Access_Definition): If the access definition\n+\tis itself the return type of an access to function definition\n+\twhich is ultimately the return type of an access to subprogram\n+\tdeclaration, its scope is the enclosing scope of the ultimate\n+\taccess to subprogram.\n+\n+2011-11-21  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_res.adb (Valid_Conversion): If a conversion was legal\n+\tin the body of a generic, then the corresponding conversion is\n+\tlegal in the expanded body of an instance of the generic.\n+\n 2011-11-21  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb: Minor reformatting."}, {"sha": "01f240fc03489aef93ccfac43bd1bdbd856d761d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -442,7 +442,7 @@ package body Checks is\n       --  are cases (e.g. with pragma Debug) where generating the checks\n       --  can cause real trouble).\n \n-      if not Expander_Active then\n+      if not Full_Expander_Active then\n          return;\n       end if;\n \n@@ -878,7 +878,7 @@ package body Checks is\n \n          if Backend_Overflow_Checks_On_Target\n            or else not Do_Overflow_Check (N)\n-           or else not Expander_Active\n+           or else not Full_Expander_Active\n            or else (Present (Parent (N))\n                      and then Nkind (Parent (N)) = N_Type_Conversion\n                      and then Integer_Promotion_Possible (Parent (N)))\n@@ -1178,7 +1178,7 @@ package body Checks is\n       --  Nothing to do if discriminant checks are suppressed or else no code\n       --  is to be generated\n \n-      if not Expander_Active\n+      if not Full_Expander_Active\n         or else Discriminant_Checks_Suppressed (T_Typ)\n       then\n          return;\n@@ -1462,7 +1462,7 @@ package body Checks is\n       --  Don't actually use this value\n \n    begin\n-      if Expander_Active\n+      if Full_Expander_Active\n         and then not Backend_Divide_Checks_On_Target\n         and then Check_Needed (Right, Division_Check)\n       then\n@@ -2118,7 +2118,7 @@ package body Checks is\n                       (not Length_Checks_Suppressed (Target_Typ));\n \n    begin\n-      if not Expander_Active then\n+      if not Full_Expander_Active then\n          return;\n       end if;\n \n@@ -2226,7 +2226,7 @@ package body Checks is\n                     (not Range_Checks_Suppressed (Target_Typ));\n \n    begin\n-      if not Expander_Active or else not Checks_On then\n+      if not Full_Expander_Active or else not Checks_On then\n          return;\n       end if;\n \n@@ -5309,7 +5309,7 @@ package body Checks is\n       --  enhanced to check for an always True value in the condition and to\n       --  generate a compilation warning???\n \n-      if not Expander_Active or else not Checks_On then\n+      if not Full_Expander_Active or else not Checks_On then\n          return;\n       end if;\n \n@@ -6236,7 +6236,7 @@ package body Checks is\n    --  Start of processing for Selected_Length_Checks\n \n    begin\n-      if not Expander_Active then\n+      if not Full_Expander_Active then\n          return Ret_Result;\n       end if;\n \n@@ -6810,7 +6810,7 @@ package body Checks is\n    --  Start of processing for Selected_Range_Checks\n \n    begin\n-      if not Expander_Active then\n+      if not Full_Expander_Active then\n          return Ret_Result;\n       end if;\n "}, {"sha": "1883d3628039f4134bc159fdc4d64c9066c35fd5", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -2117,21 +2117,38 @@ package body Exp_Attr is\n       --  computation to be completed in the back-end, since we don't know what\n       --  layout will be chosen.\n \n-      when Attribute_First_Bit => First_Bit : declare\n+      when Attribute_First_Bit => First_Bit_Attr : declare\n          CE : constant Entity_Id := Entity (Selector_Name (Pref));\n \n       begin\n-         if Known_Static_Component_Bit_Offset (CE) then\n+         --  In Ada 2005 (or later) if we have the standard nondefault\n+         --  bit order, then we return the original value as given in\n+         --  the component clause (RM 2005 13.5.2(3/2)).\n+\n+         if Present (Component_Clause (CE))\n+           and then Ada_Version >= Ada_2005\n+           and then not Reverse_Bit_Order (Scope (CE))\n+         then\n             Rewrite (N,\n               Make_Integer_Literal (Loc,\n-                Component_Bit_Offset (CE) mod System_Storage_Unit));\n+                Intval => Expr_Value (First_Bit (Component_Clause (CE)))));\n+            Analyze_And_Resolve (N, Typ);\n \n+         --  Otherwise (Ada 83/95 or Ada 2005 or later with reverse bit order),\n+         --  rewrite with normalized value if we know it statically.\n+\n+         elsif Known_Static_Component_Bit_Offset (CE) then\n+            Rewrite (N,\n+              Make_Integer_Literal (Loc,\n+                Component_Bit_Offset (CE) mod System_Storage_Unit));\n             Analyze_And_Resolve (N, Typ);\n \n+         --  Otherwise left to back end, just do universal integer checks\n+\n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n          end if;\n-      end First_Bit;\n+      end First_Bit_Attr;\n \n       -----------------\n       -- Fixed_Value --\n@@ -2680,24 +2697,41 @@ package body Exp_Attr is\n       --  the computation up to the back end, since we don't know what layout\n       --  will be chosen.\n \n-      when Attribute_Last_Bit => Last_Bit : declare\n+      when Attribute_Last_Bit => Last_Bit_Attr : declare\n          CE : constant Entity_Id := Entity (Selector_Name (Pref));\n \n       begin\n-         if Known_Static_Component_Bit_Offset (CE)\n+         --  In Ada 2005 (or later) if we have the standard nondefault\n+         --  bit order, then we return the original value as given in\n+         --  the component clause (RM 2005 13.5.2(4/2)).\n+\n+         if Present (Component_Clause (CE))\n+           and then Ada_Version >= Ada_2005\n+           and then not Reverse_Bit_Order (Scope (CE))\n+         then\n+            Rewrite (N,\n+              Make_Integer_Literal (Loc,\n+                Intval => Expr_Value (Last_Bit (Component_Clause (CE)))));\n+            Analyze_And_Resolve (N, Typ);\n+\n+         --  Otherwise (Ada 83/95 or Ada 2005 or later with reverse bit order),\n+         --  rewrite with normalized value if we know it statically.\n+\n+         elsif Known_Static_Component_Bit_Offset (CE)\n            and then Known_Static_Esize (CE)\n          then\n             Rewrite (N,\n               Make_Integer_Literal (Loc,\n                Intval => (Component_Bit_Offset (CE) mod System_Storage_Unit)\n                                 + Esize (CE) - 1));\n-\n             Analyze_And_Resolve (N, Typ);\n \n+         --  Otherwise leave to back end, just apply universal integer checks\n+\n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n          end if;\n-      end Last_Bit;\n+      end Last_Bit_Attr;\n \n       ------------------\n       -- Leading_Part --\n@@ -3495,21 +3529,41 @@ package body Exp_Attr is\n       --  the computation up to the back end, since we don't know what layout\n       --  will be chosen.\n \n-      when Attribute_Position => Position :\n+      when Attribute_Position => Position_Attr :\n       declare\n          CE : constant Entity_Id := Entity (Selector_Name (Pref));\n \n       begin\n          if Present (Component_Clause (CE)) then\n-            Rewrite (N,\n-              Make_Integer_Literal (Loc,\n-                Intval => Component_Bit_Offset (CE) / System_Storage_Unit));\n+\n+            --  In Ada 2005 (or later) if we have the standard nondefault\n+            --  bit order, then we return the original value as given in\n+            --  the component clause (RM 2005 13.5.2(2/2)).\n+\n+            if Ada_Version >= Ada_2005\n+              and then not Reverse_Bit_Order (Scope (CE))\n+            then\n+               Rewrite (N,\n+                  Make_Integer_Literal (Loc,\n+                    Intval => Expr_Value (Position (Component_Clause (CE)))));\n+\n+            --  Otherwise (Ada 83 or 95, or reverse bit order specified in\n+            --  later Ada version), return the normalized value.\n+\n+            else\n+               Rewrite (N,\n+                 Make_Integer_Literal (Loc,\n+                   Intval => Component_Bit_Offset (CE) / System_Storage_Unit));\n+            end if;\n+\n             Analyze_And_Resolve (N, Typ);\n \n+         --  If back end is doing things, just apply universal integer checks\n+\n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n          end if;\n-      end Position;\n+      end Position_Attr;\n \n       ----------\n       -- Pred --"}, {"sha": "d66824bc35f7af5b75f2c374d4155d5fa91a8cab", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,6 +27,7 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n+with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -1065,10 +1066,10 @@ package body Exp_Imgv is\n       Pref    : constant Node_Id    := Prefix (N);\n       Ptyp    : constant Entity_Id  := Etype (Pref);\n       Rtyp    : constant Entity_Id  := Root_Type (Ptyp);\n-      XX      : RE_Id;\n-      YY      : Entity_Id;\n       Arglist : List_Id;\n       Ttyp    : Entity_Id;\n+      XX      : RE_Id;\n+      YY      : Entity_Id;\n \n    begin\n       --  Types derived from Standard.Boolean\n@@ -1157,6 +1158,18 @@ package body Exp_Imgv is\n \n          if Discard_Names (Rtyp) then\n \n+            --  Emit a detailed warning in configurable run-time mode because\n+            --  loading RE_Null does not give a precise indication of the real\n+            --  issue.\n+\n+            if Configurable_Run_Time_Mode\n+              and then not Has_Warnings_Off (Rtyp)\n+            then\n+               Error_Msg_Name_1 := Attribute_Name (N);\n+               Error_Msg_N (\"?attribute % not supported in configurable \" &\n+                            \"run-time mode\", N);\n+            end if;\n+\n             --  This is a configurable run-time, or else a restriction is in\n             --  effect. In either case the attribute cannot be supported. Force\n             --  a load error from Rtsfind to generate an appropriate message,"}, {"sha": "d9759843b7268993d041cba5f1e65c864142726f", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -4239,14 +4239,16 @@ package body Freeze is\n       --  By default, if no size clause is present, an enumeration type with\n       --  Convention C is assumed to interface to a C enum, and has integer\n       --  size. This applies to types. For subtypes, verify that its base\n-      --  type has no size clause either.\n+      --  type has no size clause either. Treat other foreign conventions\n+      --  in the same way, and also make sure alignment is set right.\n \n       if Has_Foreign_Convention (Typ)\n         and then not Has_Size_Clause (Typ)\n         and then not Has_Size_Clause (Base_Type (Typ))\n         and then Esize (Typ) < Standard_Integer_Size\n       then\n          Init_Esize (Typ, Standard_Integer_Size);\n+         Set_Alignment (Typ, Alignment (Standard_Integer));\n \n       else\n          --  If the enumeration type interfaces to C, and it has a size clause"}, {"sha": "519fad0f357f587cde756efba3b7d657f7c79bf8", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 91, "deletions": 11, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -3088,7 +3088,7 @@ package body Layout is\n       end if;\n \n       --  Here we calculate the alignment as the largest power of two multiple\n-      --  of System.Storage_Unit that does not exceed either the actual size of\n+      --  of System.Storage_Unit that does not exceed either the object size of\n       --  the type, or the maximum allowed alignment.\n \n       declare\n@@ -3126,21 +3126,101 @@ package body Layout is\n             A := 2 * A;\n          end loop;\n \n-         --  Now we think we should set the alignment to A, but we skip this if\n-         --  an alignment is already set to a value greater than A (happens for\n-         --  derived types).\n+         --  If alignment is currently not set, then we can safetly set it to\n+         --  this new calculated value.\n \n-         --  However, if the alignment is known and too small it must be\n-         --  increased, this happens in a case like:\n+         if Unknown_Alignment (E) then\n+            Init_Alignment (E, A);\n+\n+         --  Cases where we have inherited an alignment\n+\n+         --  For constructed types, always reset the alignment, these are\n+         --  Generally invisible to the user anyway, and that way we are\n+         --  sure that no constructed types have weird alignments.\n+\n+         elsif not Comes_From_Source (E) then\n+            Init_Alignment (E, A);\n+\n+         --  If this inherited alignment is the same as the one we computed,\n+         --  then obviously everything is fine, and we do not need to reset it.\n \n-         --     type R is new Character;\n-         --     for R'Size use 16;\n+         elsif Alignment (E) = A then\n+            null;\n \n-         --  Here the alignment inherited from Character is 1, but it must be\n-         --  increased to 2 to reflect the increased size.\n+         --  Now we come to the difficult cases where we have inherited an\n+         --  alignment and size, but overridden the size but not the alignment.\n+\n+         elsif Has_Size_Clause (E) or else Has_Object_Size_Clause (E) then\n+\n+            --  This is tricky, it might be thought that we should try to\n+            --  inherit the alignment, since that's what the RM implies, but\n+            --  that leads to complex rules and oddities. Consider for example:\n+\n+            --    type R is new Character;\n+            --    for R'Size use 16;\n+\n+            --  It seems quite bogus in this case to inherit an alignment of 1\n+            --  from the parent type Character. Furthermore, if that's what the\n+            --  programmer really wanted for some odd reason, then they could\n+            --  specify the alignment they wanted.\n+\n+            --  Furthermore we really don't want to inherit the alignment in\n+            --  the case of a specified Object_Size for a subtype, since then\n+            --  there would be no way of overriding to give a reasonable value\n+            --  (we don't have an Object_Subtype attribute). Consider:\n+\n+            --    subtype R is new Character;\n+            --    for R'Object_Size use 16;\n+\n+            --  If we inherit the alignment of 1, then we have an odd\n+            --  inefficient alignment for the subtype, which cannot be fixed.\n+\n+            --  So we make the decision that if Size (or Object_Size) is given\n+            --  (and, in the case of a first subtype, the alignment is not set\n+            --  with a specific alignment clause). We reset the alignment to\n+            --  the appropriate value for the specified size. This is a nice\n+            --  simple rule to implement and document.\n+\n+            --  There is one slight glitch, which is that a confirming size\n+            --  clause can now change the alignment, which, if we really think\n+            --  that confirming rep clauses should have no effect, is a no-no.\n+\n+            --    type R is new Character;\n+            --    for R'Alignment use 2;\n+            --    type S is new R;\n+            --    for S'Size use Character'Size;\n+\n+            --  Now the alignment of S is 1 instead of 2, as a result of\n+            --  applying the above rule to the confirming rep clause for S. Not\n+            --  clear this is worth worrying about. If we recorded whether a\n+            --  size clause was confirming we could avoid this, but right now\n+            --  we have no way of doing that or easily figuring it out, so we\n+            --  don't bother.\n+\n+            --  Historical note. In versions of GNAT prior to Nov 6th, 2010, an\n+            --  odd distinction was made between inherited alignments greater\n+            --  than the computed alignment (where the larger alignment was\n+            --  inherited) and inherited alignments smaller than the computed\n+            --  alignment (where the smaller alignment was overridden). This\n+            --  was a dubious fix to get around an ACATS problem which seems\n+            --  to have disappeared anyway, and in any case, this peculiarity\n+            --  was never documented.\n \n-         if Unknown_Alignment (E) or else Alignment (E) < A then\n             Init_Alignment (E, A);\n+\n+         --  If no Size (or Object_Size) was specified, then we inherited the\n+         --  object size, so we should inherit the alignment as well and not\n+         --  modify it. This takes care of cases like:\n+\n+         --    type R is new Integer;\n+         --    for R'Alignment use 1;\n+         --    subtype S is R;\n+\n+         --  Here we have R has a default Object_Size of 32, and a specified\n+         --  alignment of 1, and it seeems right for S to inherit both values.\n+\n+         else\n+            null;\n          end if;\n       end;\n    end Set_Elem_Alignment;"}, {"sha": "59884d24c73cebad177bfa33618a0debdac8363a", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -2553,6 +2553,11 @@ package body Ch4 is\n       Node1  : Node_Id;\n \n    begin\n+      if Ada_Version < Ada_2012 then\n+         Error_Msg_SC (\"quantified expression is an Ada 2012 feature\");\n+         Error_Msg_SC (\"\\|unit must be compiled with -gnat2012 switch\");\n+      end if;\n+\n       Scan;  --  past FOR\n \n       Node1 := New_Node (N_Quantified_Expression, Prev_Token_Ptr);"}, {"sha": "f230721af007bc373d9b94ef6e087a40ed1784ab", "filename": "gcc/ada/s-atocou-builtin.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-atocou-builtin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-atocou-builtin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atocou-builtin.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -50,7 +50,12 @@ package body System.Atomic_Counters is\n \n    function Decrement (Item : in out Atomic_Counter) return Boolean is\n    begin\n-      return Sync_Sub_And_Fetch (Item.Value'Access, 1) = 0;\n+      --  Note: the use of Unrestricted_Access here is required because we\n+      --  are obtaining an access-to-volatile pointer to a non-volatile object.\n+      --  This is not allowed for [Unchecked_]Access, but is safe in this case\n+      --  because we know that no aliases are being created.\n+\n+      return Sync_Sub_And_Fetch (Item.Value'Unrestricted_Access, 1) = 0;\n    end Decrement;\n \n    ---------------\n@@ -59,7 +64,12 @@ package body System.Atomic_Counters is\n \n    procedure Increment (Item : in out Atomic_Counter) is\n    begin\n-      Sync_Add_And_Fetch (Item.Value'Access, 1);\n+      --  Note: the use of Unrestricted_Access here is required because we\n+      --  are obtaining an access-to-volatile pointer to a non-volatile object.\n+      --  This is not allowed for [Unchecked_]Access, but is safe in this case\n+      --  because we know that no aliases are being created.\n+\n+      Sync_Add_And_Fetch (Item.Value'Unrestricted_Access, 1);\n    end Increment;\n \n    ------------"}, {"sha": "918519b67812637e8d5c3b5417fd047bd5e69c33", "filename": "gcc/ada/s-finmas.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-finmas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-finmas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -181,6 +181,12 @@ package body System.Finalization_Masters is\n \n       if Master.Finalization_Started then\n          Unlock_Task.all;\n+\n+         --  Double finalization may occur during the handling of stand alone\n+         --  libraries or the finalization of a pool with subpools. Due to the\n+         --  potential aliasing of masters in these two cases, do not process\n+         --  the same master twice.\n+\n          return;\n       end if;\n "}, {"sha": "4e69ea4b321ad539db24a8b4b7a65bdec63e0588", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -990,11 +990,18 @@ package body System.Task_Primitives.Operations is\n       --  do not need to manipulate caller's signal mask at this point.\n       --  All tasks in RTS will have All_Tasks_Mask initially.\n \n-      Result := pthread_create\n-        (T.Common.LL.Thread'Access,\n-         Attributes'Access,\n-         Thread_Body_Access (Wrapper),\n-         To_Address (T));\n+      --  Note: the use of Unrestricted_Access in the following call is needed\n+      --  because otherwise we have an error of getting a access-to-volatile\n+      --  value which points to a non-volatile object. But in this case it is\n+      --  safe to do this, since we know we have no problems with aliasing and\n+      --  Unrestricted_Access bypasses this check.\n+\n+      Result :=\n+        pthread_create\n+          (T.Common.LL.Thread'Unrestricted_Access,\n+           Attributes'Access,\n+           Thread_Body_Access (Wrapper),\n+           To_Address (T));\n \n       pragma Assert\n         (Result = 0 or else Result = EAGAIN or else Result = ENOMEM);"}, {"sha": "e3134a5772dbd150ca5c2c6fff9238577cfa65fc", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -811,7 +811,7 @@ package body System.Task_Primitives.Operations is\n \n       Result :=\n         pthread_create\n-          (T.Common.LL.Thread'Access,\n+          (T.Common.LL.Thread'Unrestricted_Access,\n            Attributes'Access,\n            Thread_Body_Access (Wrapper),\n            To_Address (T));"}, {"sha": "87edd0e3218253107e80324710e3bd1a72049a45", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -726,13 +726,33 @@ package body Sem_Ch3 is\n \n       --  If the access definition is the return type of another access to\n       --  function, scope is the current one, because it is the one of the\n-      --  current type declaration.\n+      --  current type declaration, except for the pathological case below.\n \n       if Nkind_In (Related_Nod, N_Object_Declaration,\n                                 N_Access_Function_Definition)\n       then\n          Anon_Scope := Current_Scope;\n \n+         --  A pathological case: function returning access functions that\n+         --  return access functions, etc.  Each anonymous access type created\n+         --  is in the enclosing scope of the outermost function.\n+\n+         declare\n+            Par : Node_Id;\n+         begin\n+            Par := Related_Nod;\n+            while Nkind_In (Par,\n+                             N_Access_Function_Definition,\n+                             N_Access_Definition)\n+            loop\n+               Par := Parent (Par);\n+            end loop;\n+\n+            if Nkind (Par) = N_Function_Specification then\n+               Anon_Scope := Scope (Defining_Entity (Par));\n+            end if;\n+         end;\n+\n       --  For the anonymous function result case, retrieve the scope of the\n       --  function specification's associated entity rather than using the\n       --  current scope. The current scope will be the function itself if the"}, {"sha": "5798ae0fbef3e0aaa31505f88dfac2158ee62cc6", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -11069,6 +11069,11 @@ package body Sem_Res is\n               N);\n          return True;\n \n+      --  If it was legal in the generic, it's legal in the instance\n+\n+      elsif In_Instance_Body then\n+         return True;\n+\n       --  If both are tagged types, check legality of view conversions\n \n       elsif Is_Tagged_Type (Target_Type)"}, {"sha": "c073d20a05631d166eb89e9f57e1522b087ef904", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -8727,10 +8727,15 @@ package body Sem_Util is\n       then\n          return True;\n \n-      elsif Nkind (N) = N_Indexed_Component\n-        or else Nkind (N) = N_Selected_Component\n+      elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component)\n+        and then Is_Volatile_Prefix (Prefix (N))\n       then\n-         return Is_Volatile_Prefix (Prefix (N));\n+         return True;\n+\n+      elsif Nkind (N) = N_Selected_Component\n+        and then Is_Volatile (Entity (Selector_Name (N)))\n+      then\n+         return True;\n \n       else\n          return False;\n@@ -10833,9 +10838,7 @@ package body Sem_Util is\n                --  source. This excludes, for example, calls to a dispatching\n                --  assignment operation when the left-hand side is tagged.\n \n-               if Modification_Comes_From_Source\n-                 or else Alfa_Mode\n-               then\n+               if Modification_Comes_From_Source or else Alfa_Mode then\n                   Generate_Reference (Ent, Exp, 'm');\n \n                   --  If the target of the assignment is the bound variable"}, {"sha": "1d13f6e60be3bd6d9246119f65721193daf016bc", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be482a8c830c9f79a14c76a901665707c34fe15a/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=be482a8c830c9f79a14c76a901665707c34fe15a", "patch": "@@ -477,13 +477,13 @@ package Sinput is\n \n    --  In addition to the set of characters defined by the type in Types, in\n    --  wide character encoding, then the codes returning True for a call to\n-   --  System.UTF_32.Is_UTF_32_Line_Terminator are also recognized as ending\n-   --  a physical source line. This includes the standard codes defined above\n-   --  in addition to NEL (NEXT LINE), LINE SEPARATOR and PARAGRAPH SEPARATOR.\n-   --  Again, as in the case of VT and FF, the standard requires we recognize\n-   --  these as line terminators, but we consider them to be logical line\n-   --  terminators. The only physical line terminators recognized are the\n-   --  standard ones (CR, LF, or CR/LF).\n+   --  System.UTF_32.Is_UTF_32_Line_Terminator are also recognized as ending a\n+   --  source line. This includes the standard codes defined above in addition\n+   --  to NEL (NEXT LINE), LINE SEPARATOR and PARAGRAPH SEPARATOR. Again, as in\n+   --  the case of VT and FF, the standard requires we recognize these as line\n+   --  terminators, but we consider them to be logical line terminators. The\n+   --  only physical line terminators recognized are the standard ones (CR,\n+   --  LF, or CR/LF).\n \n    --  However, we do not recognize the NEL (16#85#) character as having the\n    --  significance of an end of line character when operating in normal 8-bit"}]}