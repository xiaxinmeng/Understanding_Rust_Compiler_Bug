{"sha": "b180d5fb7baab9d8a4b1002948c88b0896118bb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE4MGQ1ZmI3YmFhYjlkOGE0YjEwMDI5NDhjODhiMDg5NjExOGJiNg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2004-12-07T20:01:17Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2004-12-07T20:01:17Z"}, "message": "splay-tree.c (splay_tree_delete_helper): Redesign the logic so that recursion (and thus large stack space) is not needed.\n\n* splay-tree.c (splay_tree_delete_helper): Redesign the logic so\nthat recursion (and thus large stack space) is not needed.\n\nFrom-SVN: r91815", "tree": {"sha": "c3a5b4658ee1012d483a59845f513db1770bc251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3a5b4658ee1012d483a59845f513db1770bc251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b180d5fb7baab9d8a4b1002948c88b0896118bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b180d5fb7baab9d8a4b1002948c88b0896118bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b180d5fb7baab9d8a4b1002948c88b0896118bb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b180d5fb7baab9d8a4b1002948c88b0896118bb6/comments", "author": null, "committer": null, "parents": [{"sha": "354e49c1d99de9d40f4ddbbde0a1cedef09fff26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354e49c1d99de9d40f4ddbbde0a1cedef09fff26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354e49c1d99de9d40f4ddbbde0a1cedef09fff26"}], "stats": {"total": 60, "additions": 53, "deletions": 7}, "files": [{"sha": "378ee0af0d3a25b723d578cac29b7601fdc36bf0", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b180d5fb7baab9d8a4b1002948c88b0896118bb6/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b180d5fb7baab9d8a4b1002948c88b0896118bb6/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b180d5fb7baab9d8a4b1002948c88b0896118bb6", "patch": "@@ -1,3 +1,8 @@\n+2004-12-07  DJ Delorie  <dj@redhat.com>\n+\n+\t* splay-tree.c (splay_tree_delete_helper): Redesign the logic so\n+\tthat recursion (and thus large stack space) is not needed.\n+\n 2004-11-29  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* pex-unix.c: Fix the spelling of longjmp."}, {"sha": "b1410aa3005356ff02e56f2e38f27b099043e1f4", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b180d5fb7baab9d8a4b1002948c88b0896118bb6/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b180d5fb7baab9d8a4b1002948c88b0896118bb6/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=b180d5fb7baab9d8a4b1002948c88b0896118bb6", "patch": "@@ -59,18 +59,59 @@ splay_tree_delete_helper (sp, node)\n      splay_tree sp;\n      splay_tree_node node;\n {\n+  splay_tree_node pending = 0;\n+  splay_tree_node active = 0;\n+\n   if (!node)\n     return;\n \n-  splay_tree_delete_helper (sp, node->left);\n-  splay_tree_delete_helper (sp, node->right);\n+#define KDEL(x)  if (sp->delete_key) (*sp->delete_key)(x);\n+#define VDEL(x)  if (sp->delete_value) (*sp->delete_value)(x);\n+\n+  KDEL (node->key);\n+  VDEL (node->value);\n+\n+  /* We use the \"key\" field to hold the \"next\" pointer.  */\n+  node->key = (splay_tree_key)pending;\n+  pending = (splay_tree_node)node;\n+\n+  /* Now, keep processing the pending list until there aren't any\n+     more.  This is a little more complicated than just recursing, but\n+     it doesn't toast the stack for large trees.  */\n+\n+  while (pending)\n+    {\n+      active = pending;\n+      pending = 0;\n+      while (active)\n+\t{\n+\t  splay_tree_node temp;\n+\n+\t  /* active points to a node which has its key and value\n+\t     deallocated, we just need to process left and right.  */\n \n-  if (sp->delete_key)\n-    (*sp->delete_key)(node->key);\n-  if (sp->delete_value)\n-    (*sp->delete_value)(node->value);\n+\t  if (active->left)\n+\t    {\n+\t      KDEL (active->left->key);\n+\t      VDEL (active->left->value);\n+\t      active->left->key = (splay_tree_key)pending;\n+\t      pending = (splay_tree_node)(active->left);\n+\t    }\n+\t  if (active->right)\n+\t    {\n+\t      KDEL (active->right->key);\n+\t      VDEL (active->right->value);\n+\t      active->right->key = (splay_tree_key)pending;\n+\t      pending = (splay_tree_node)(active->right);\n+\t    }\n \n-  (*sp->deallocate) ((char*) node, sp->allocate_data);\n+\t  temp = active;\n+\t  active = (splay_tree_node)(temp->key);\n+\t  (*sp->deallocate) ((char*) temp, sp->allocate_data);\n+\t}\n+    }\n+#undef KDEL\n+#undef VDEL\n }\n \n /* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent"}]}