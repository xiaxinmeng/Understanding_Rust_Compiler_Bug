{"sha": "908a22351801ee5f0f364d14a55ae38f546565b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA4YTIyMzUxODAxZWU1ZjBmMzY0ZDE0YTU1YWUzOGY1NDY1NjViNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-11-27T20:47:55Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-11-27T20:47:55Z"}, "message": "re PR fortran/29389 (Statement functions are not recognized as pure when they are)\n\n2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29389\n\t*resolve.c (resolve_ordinary_assign): Use find_sym_in_expr to\n\ttest if a temporary should be written for a vector subscript\n\ton the lhs.\n\n\tPR fortran/33850\n\t* restore.c (pure_stmt_function): Add prototype and new\n\tfunction. Calls impure_stmt_fcn.\n\t(pure_function): Call it.\n\t(impure_stmt_fcn): New function.\n\n\t* expr.c (gfc_traverse_expr): Call *func for all expression\n\ttypes, not just variables. Add traversal of character lengths,\n\titerators and component character lengths and arrayspecs.\n\t(expr_set_symbols_referenced): Return false if not a variable.\n\t* trans-stmt.c (forall_replace, forall_restore): Ditto.\n\t* resolve.c (forall_index): Ditto.\n\t(sym_in_expr): New function.\n\t(find_sym_in_expr): Rewrite to traverse expression calling\n\tsym_in_expr.\n\t*trans-decl.c (expr_decls): New function.\n\t(generate_expr_decls): Rewrite to traverse expression calling\n\texpr_decls.\n\t*match.c (check_stmt_fcn): New function.\n\t(recursive_stmt_fcn): Rewrite to traverse expression calling\n\tcheck_stmt_fcn.\n\n2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29389\n\t* gfortran.dg/stfunc_6.f90: New test.\n\n\tPR fortran/33850\n\t* gfortran.dg/assign_10.f90: New test.\n\nFrom-SVN: r130472", "tree": {"sha": "02fd93e8d327aa79aa562c5f974746f1257b83be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02fd93e8d327aa79aa562c5f974746f1257b83be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/908a22351801ee5f0f364d14a55ae38f546565b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908a22351801ee5f0f364d14a55ae38f546565b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/908a22351801ee5f0f364d14a55ae38f546565b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908a22351801ee5f0f364d14a55ae38f546565b4/comments", "author": null, "committer": null, "parents": [{"sha": "0e5a218b31eb720caa70b19439e26f658f151070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5a218b31eb720caa70b19439e26f658f151070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5a218b31eb720caa70b19439e26f658f151070"}], "stats": {"total": 418, "additions": 214, "deletions": 204}, "files": [{"sha": "1c7742cd5b5c092c935afa9ff2d77778f6614f63", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -1,3 +1,32 @@\n+2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29389\n+\t*resolve.c (resolve_ordinary_assign): Use find_sym_in_expr to\n+\ttest if a temporary should be written for a vector subscript\n+\ton the lhs.\n+\n+\tPR fortran/33850\n+\t* restore.c (pure_stmt_function): Add prototype and new\n+\tfunction. Calls impure_stmt_fcn.\n+\t(pure_function): Call it.\n+\t(impure_stmt_fcn): New function.\n+\n+\t* expr.c (gfc_traverse_expr): Call *func for all expression\n+\ttypes, not just variables. Add traversal of character lengths,\n+\titerators and component character lengths and arrayspecs.\n+\t(expr_set_symbols_referenced): Return false if not a variable.\n+\t* trans-stmt.c (forall_replace, forall_restore): Ditto.\n+\t* resolve.c (forall_index): Ditto.\n+\t(sym_in_expr): New function.\n+\t(find_sym_in_expr): Rewrite to traverse expression calling\n+\tsym_in_expr.\n+\t*trans-decl.c (expr_decls): New function.\n+\t(generate_expr_decls): Rewrite to traverse expression calling\n+\texpr_decls.\n+\t*match.c (check_stmt_fcn): New function.\n+\t(recursive_stmt_fcn): Rewrite to traverse expression calling\n+\tcheck_stmt_fcn.\n+\n 2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33541"}, {"sha": "e33d97a869be92e284afee065269aae8d1ac4522", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -3010,14 +3010,18 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n   if (!expr)\n     return false;\n \n-  switch (expr->expr_type)\n-    {\n-    case EXPR_VARIABLE:\n-      gcc_assert (expr->symtree->n.sym);\n+  if ((*func) (expr, sym, &f))\n+    return true;\n \n-      if ((*func) (expr, sym, &f))\n-\treturn true;\n+  if (expr->ts.type == BT_CHARACTER\n+\t&& expr->ts.cl\n+\t&& expr->ts.cl->length\n+\t&& expr->ts.cl->length->expr_type != EXPR_CONSTANT\n+\t&& gfc_traverse_expr (expr->ts.cl->length, sym, func, f))\n+    return true;\n \n+  switch (expr->expr_type)\n+    {\n     case EXPR_FUNCTION:\n       for (args = expr->value.function.actual; args; args = args->next)\n \t{\n@@ -3026,6 +3030,7 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n \t}\n       break;\n \n+    case EXPR_VARIABLE:\n     case EXPR_CONSTANT:\n     case EXPR_NULL:\n     case EXPR_SUBSTRING:\n@@ -3034,7 +3039,21 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n     case EXPR_STRUCTURE:\n     case EXPR_ARRAY:\n       for (c = expr->value.constructor; c; c = c->next)\n-\tgfc_expr_set_symbols_referenced (c->expr);\n+\t{\n+\t  if (gfc_traverse_expr (c->expr, sym, func, f))\n+\t    return true;\n+\t  if (c->iterator)\n+\t    {\n+\t      if (gfc_traverse_expr (c->iterator->var, sym, func, f))\n+\t\treturn true;\n+\t      if (gfc_traverse_expr (c->iterator->start, sym, func, f))\n+\t\treturn true;\n+\t      if (gfc_traverse_expr (c->iterator->end, sym, func, f))\n+\t\treturn true;\n+\t      if (gfc_traverse_expr (c->iterator->step, sym, func, f))\n+\t\treturn true;\n+\t    }\n+\t}\n       break;\n \n     case EXPR_OP:\n@@ -3074,8 +3093,27 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n \t    return true;\n \t  break;\n \n-\t  case REF_COMPONENT:\n-\t    break;\n+\tcase REF_COMPONENT:\n+\t  if (ref->u.c.component->ts.type == BT_CHARACTER\n+\t\t&& ref->u.c.component->ts.cl\n+\t\t&& ref->u.c.component->ts.cl->length\n+\t\t&& ref->u.c.component->ts.cl->length->expr_type\n+\t\t     != EXPR_CONSTANT\n+\t\t&& gfc_traverse_expr (ref->u.c.component->ts.cl->length,\n+\t\t\t\t      sym, func, f))\n+\t    return true;\n+\n+\t  if (ref->u.c.component->as)\n+\t    for (i = 0; i < ref->u.c.component->as->rank; i++)\n+\t      {\n+\t\tif (gfc_traverse_expr (ref->u.c.component->as->lower[i],\n+\t\t\t\t       sym, func, f))\n+\t\t  return true;\n+\t\tif (gfc_traverse_expr (ref->u.c.component->as->upper[i],\n+\t\t\t\t       sym, func, f))\n+\t\t  return true;\n+\t      }\n+\t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n@@ -3092,6 +3130,8 @@ expr_set_symbols_referenced (gfc_expr *expr,\n \t\t\t     gfc_symbol *sym ATTRIBUTE_UNUSED,\n \t\t\t     int *f ATTRIBUTE_UNUSED)\n {\n+  if (expr->expr_type != EXPR_VARIABLE)\n+    return false;\n   gfc_set_sym_referenced (expr->symtree->n.sym);\n   return false;\n }"}, {"sha": "fe2a343bebcc029083b4316b9d95ee2b34fed666", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -3209,26 +3209,19 @@ gfc_match_equivalence (void)\n    12.5.4 requires that any variable of function that is implicitly typed\n    shall have that type confirmed by any subsequent type declaration.  The\n    implicit typing is conveniently done here.  */\n+static bool\n+recursive_stmt_fcn (gfc_expr *, gfc_symbol *);\n \n static bool\n-recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n+check_stmt_fcn (gfc_expr *e, gfc_symbol *sym, int *f ATTRIBUTE_UNUSED)\n {\n-  gfc_actual_arglist *arg;\n-  gfc_ref *ref;\n-  int i;\n \n   if (e == NULL)\n     return false;\n \n   switch (e->expr_type)\n     {\n     case EXPR_FUNCTION:\n-      for (arg = e->value.function.actual; arg; arg = arg->next)\n-\t{\n-\t  if (sym->name == arg->name || recursive_stmt_fcn (arg->expr, sym))\n-\t    return true;\n-\t}\n-\n       if (e->symtree == NULL)\n \treturn false;\n \n@@ -3255,46 +3248,18 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n \tgfc_set_default_type (e->symtree->n.sym, 0, NULL);\n       break;\n \n-    case EXPR_OP:\n-      if (recursive_stmt_fcn (e->value.op.op1, sym)\n-\t  || recursive_stmt_fcn (e->value.op.op2, sym))\n-\treturn true;\n-      break;\n-\n     default:\n       break;\n     }\n \n-  /* Component references do not need to be checked.  */\n-  if (e->ref)\n-    {\n-      for (ref = e->ref; ref; ref = ref->next)\n-\t{\n-\t  switch (ref->type)\n-\t    {\n-\t    case REF_ARRAY:\n-\t      for (i = 0; i < ref->u.ar.dimen; i++)\n-\t\t{\n-\t\t  if (recursive_stmt_fcn (ref->u.ar.start[i], sym)\n-\t\t      || recursive_stmt_fcn (ref->u.ar.end[i], sym)\n-\t\t      || recursive_stmt_fcn (ref->u.ar.stride[i], sym))\n-\t\t    return true;\n-\t\t}\n-\t      break;\n-\n-\t    case REF_SUBSTRING:\n-\t      if (recursive_stmt_fcn (ref->u.ss.start, sym)\n-\t\t  || recursive_stmt_fcn (ref->u.ss.end, sym))\n-\t\treturn true;\n+  return false;\n+}\n \n-\t      break;\n \n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  return false;\n+static bool\n+recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n+{\n+  return gfc_traverse_expr (e, sym, check_stmt_fcn, 0);\n }\n \n "}, {"sha": "eaa15d3962f94bf72a7a604780f18feb904a651c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 45, "deletions": 80, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -1665,6 +1665,8 @@ is_external_proc (gfc_symbol *sym)\n /* Figure out if a function reference is pure or not.  Also set the name\n    of the function for a potential error message.  Return nonzero if the\n    function is PURE, zero if not.  */\n+static int\n+pure_stmt_function (gfc_expr *, gfc_symbol *);\n \n static int\n pure_function (gfc_expr *e, const char **name)\n@@ -1676,7 +1678,7 @@ pure_function (gfc_expr *e, const char **name)\n   if (e->symtree != NULL\n         && e->symtree->n.sym != NULL\n         && e->symtree->n.sym->attr.proc == PROC_ST_FUNCTION)\n-    return 1;\n+    return pure_stmt_function (e, e->symtree->n.sym);\n \n   if (e->value.function.esym)\n     {\n@@ -1700,6 +1702,31 @@ pure_function (gfc_expr *e, const char **name)\n }\n \n \n+static bool\n+impure_stmt_fcn (gfc_expr *e, gfc_symbol *sym,\n+\t\t int *f ATTRIBUTE_UNUSED)\n+{\n+  const char *name;\n+\n+  /* Don't bother recursing into other statement functions\n+     since they will be checked individually for purity.  */\n+  if (e->expr_type != EXPR_FUNCTION\n+\t|| !e->symtree\n+\t|| e->symtree->n.sym == sym\n+\t|| e->symtree->n.sym->attr.proc == PROC_ST_FUNCTION)\n+    return false;\n+\n+  return pure_function (e, &name) ? false : true;\n+}\n+\n+\n+static int\n+pure_stmt_function (gfc_expr *e, gfc_symbol *sym)\n+{\n+  return gfc_traverse_expr (e, sym, impure_stmt_fcn, 0) ? 0 : 1;\n+}\n+\n+\n static try\n is_scalar_expr_ptr (gfc_expr *expr)\n {\n@@ -4369,8 +4396,9 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok)\n static bool\n forall_index (gfc_expr *expr, gfc_symbol *sym, int *f)\n {\n-  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n-\n+  if (expr->expr_type != EXPR_VARIABLE)\n+    return false;\n+  \n   /* A scalar assignment  */\n   if (!expr->ref || *f == 1)\n     {\n@@ -4552,85 +4580,20 @@ resolve_deallocate_expr (gfc_expr *e)\n }\n \n \n-/* Returns true if the expression e contains a reference the symbol sym.  */\n+/* Returns true if the expression e contains a reference to the symbol sym.  */\n static bool\n-find_sym_in_expr (gfc_symbol *sym, gfc_expr *e)\n+sym_in_expr (gfc_expr *e, gfc_symbol *sym, int *f ATTRIBUTE_UNUSED)\n {\n-  gfc_actual_arglist *arg;\n-  gfc_ref *ref;\n-  int i;\n-  bool rv = false;\n-\n-  if (e == NULL)\n-    return rv;\n-\n-  switch (e->expr_type)\n-    {\n-    case EXPR_FUNCTION:\n-      for (arg = e->value.function.actual; arg; arg = arg->next)\n-\trv = rv || find_sym_in_expr (sym, arg->expr);\n-      break;\n-\n-    /* If the variable is not the same as the dependent, 'sym', and\n-       it is not marked as being declared and it is in the same\n-       namespace as 'sym', add it to the local declarations.  */\n-    case EXPR_VARIABLE:\n-      if (sym == e->symtree->n.sym)\n-\treturn true;\n-      break;\n-\n-    case EXPR_OP:\n-      rv = rv || find_sym_in_expr (sym, e->value.op.op1);\n-      rv = rv || find_sym_in_expr (sym, e->value.op.op2);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  if (e->ref)\n-    {\n-      for (ref = e->ref; ref; ref = ref->next)\n-\t{\n-\t  switch (ref->type)\n-\t    {\n-\t    case REF_ARRAY:\n-\t      for (i = 0; i < ref->u.ar.dimen; i++)\n-\t\t{\n-\t\t  rv = rv || find_sym_in_expr (sym, ref->u.ar.start[i]);\n-\t\t  rv = rv || find_sym_in_expr (sym, ref->u.ar.end[i]);\n-\t\t  rv = rv || find_sym_in_expr (sym, ref->u.ar.stride[i]);\n-\t\t}\n-\t      break;\n-\n-\t    case REF_SUBSTRING:\n-\t      rv = rv || find_sym_in_expr (sym, ref->u.ss.start);\n-\t      rv = rv || find_sym_in_expr (sym, ref->u.ss.end);\n-\t      break;\n+  if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym == sym)\n+    return true;\n \n-\t    case REF_COMPONENT:\n-\t      if (ref->u.c.component->ts.type == BT_CHARACTER\n-\t\t  && ref->u.c.component->ts.cl->length->expr_type\n-\t\t     != EXPR_CONSTANT)\n-\t\trv = rv\n-\t\t     || find_sym_in_expr (sym,\n-\t\t\t\t\t  ref->u.c.component->ts.cl->length);\n+  return false;\n+}\n \n-\t      if (ref->u.c.component->as)\n-\t\tfor (i = 0; i < ref->u.c.component->as->rank; i++)\n-\t\t  {\n-\t\t    rv = rv\n-\t\t\t || find_sym_in_expr (sym,\n-\t\t\t\t\t      ref->u.c.component->as->lower[i]);\n-\t\t    rv = rv\n-\t\t\t || find_sym_in_expr (sym,\n-\t\t\t\t\t      ref->u.c.component->as->upper[i]);\n-\t\t  }\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  return rv;\n+static bool\n+find_sym_in_expr (gfc_symbol *sym, gfc_expr *e)\n+{\n+  return gfc_traverse_expr (e, sym, sym_in_expr, 0);\n }\n \n \n@@ -5970,14 +5933,16 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n     }\n \n   /* Ensure that a vector index expression for the lvalue is evaluated\n-     to a temporary.  */\n+     to a temporary if the lvalue symbol is referenced in it.  */\n   if (lhs->rank)\n     {\n       for (ref = lhs->ref; ref; ref= ref->next)\n \tif (ref->type == REF_ARRAY)\n \t  {\n \t    for (n = 0; n < ref->u.ar.dimen; n++)\n-\t      if (ref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n+\t      if (ref->u.ar.dimen_type[n] == DIMEN_VECTOR\n+\t\t    && find_sym_in_expr (lhs->symtree->n.sym,\n+\t\t\t\t\t ref->u.ar.start[n]))\n \t\tref->u.ar.start[n]\n \t\t\t= gfc_get_parentheses (ref->u.ar.start[n]);\n \t  }"}, {"sha": "84e722663222fd5fee896e2698f493cdabd3be00", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 15, "deletions": 69, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -2893,80 +2893,26 @@ gfc_generate_contained_functions (gfc_namespace * parent)\n static void\n generate_local_decl (gfc_symbol *);\n \n-static void\n-generate_expr_decls (gfc_symbol *sym, gfc_expr *e)\n-{\n-  gfc_actual_arglist *arg;\n-  gfc_ref *ref;\n-  int i;\n-\n-  if (e == NULL)\n-    return;\n-\n-  switch (e->expr_type)\n-    {\n-    case EXPR_FUNCTION:\n-      for (arg = e->value.function.actual; arg; arg = arg->next)\n-\tgenerate_expr_decls (sym, arg->expr);\n-      break;\n+/* Traverse expr, marking all EXPR_VARIABLE symbols referenced.  */\n \n-    /* If the variable is not the same as the dependent, 'sym', and\n-       it is not marked as being declared and it is in the same\n-       namespace as 'sym', add it to the local declarations.  */\n-    case EXPR_VARIABLE:\n-      if (sym == e->symtree->n.sym\n+static bool\n+expr_decls (gfc_expr *e, gfc_symbol *sym,\n+\t    int *f ATTRIBUTE_UNUSED)\n+{\n+  if (e->expr_type != EXPR_VARIABLE\n+\t    || sym == e->symtree->n.sym\n \t    || e->symtree->n.sym->mark\n \t    || e->symtree->n.sym->ns != sym->ns)\n-\treturn;\n-\n-      generate_local_decl (e->symtree->n.sym);\n-      break;\n-\n-    case EXPR_OP:\n-      generate_expr_decls (sym, e->value.op.op1);\n-      generate_expr_decls (sym, e->value.op.op2);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  if (e->ref)\n-    {\n-      for (ref = e->ref; ref; ref = ref->next)\n-\t{\n-\t  switch (ref->type)\n-\t    {\n-\t    case REF_ARRAY:\n-\t      for (i = 0; i < ref->u.ar.dimen; i++)\n-\t\t{\n-\t\t  generate_expr_decls (sym, ref->u.ar.start[i]);\n-\t\t  generate_expr_decls (sym, ref->u.ar.end[i]);\n-\t\t  generate_expr_decls (sym, ref->u.ar.stride[i]);\n-\t\t}\n-\t      break;\n+\treturn false;\n \n-\t    case REF_SUBSTRING:\n-\t      generate_expr_decls (sym, ref->u.ss.start);\n-\t      generate_expr_decls (sym, ref->u.ss.end);\n-\t      break;\n+  generate_local_decl (e->symtree->n.sym);\n+  return false;\n+}\n \n-\t    case REF_COMPONENT:\n-\t      if (ref->u.c.component->ts.type == BT_CHARACTER\n-\t\t    && ref->u.c.component->ts.cl->length->expr_type\n-\t\t\t\t\t\t!= EXPR_CONSTANT)\n-\t\tgenerate_expr_decls (sym, ref->u.c.component->ts.cl->length);\n-\n-\t      if (ref->u.c.component->as)\n-\t        for (i = 0; i < ref->u.c.component->as->rank; i++)\n-\t\t  {\n-\t\t    generate_expr_decls (sym, ref->u.c.component->as->lower[i]);\n-\t\t    generate_expr_decls (sym, ref->u.c.component->as->upper[i]);\n-\t\t  }\n-\t      break;\n-\t    }\n-\t}\n-    }\n+static void\n+generate_expr_decls (gfc_symbol *sym, gfc_expr *e)\n+{\n+  gfc_traverse_expr (e, sym, expr_decls, 0);\n }\n \n "}, {"sha": "c8343f3971b598f113ad2a1e77aee8ae85254675", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -1523,7 +1523,8 @@ static gfc_symtree *old_symtree;\n static bool\n forall_replace (gfc_expr *expr, gfc_symbol *sym, int *f)\n {\n-  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n+  if (expr->expr_type != EXPR_VARIABLE)\n+    return false;\n \n   if (*f == 2)\n     *f = 1;\n@@ -1544,7 +1545,8 @@ forall_restore (gfc_expr *expr,\n \t\tgfc_symbol *sym ATTRIBUTE_UNUSED,\n \t\tint *f ATTRIBUTE_UNUSED)\n {\n-  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n+  if (expr->expr_type != EXPR_VARIABLE)\n+    return false;\n \n   if (expr->symtree == new_symtree)\n     expr->symtree = old_symtree;"}, {"sha": "1769353aafa2891d26c7d8ff6f672384087b4518", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -1,3 +1,11 @@\n+2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29389\n+\t* gfortran.dg/stfunc_6.f90: New test.\n+\n+\tPR fortran/33850\n+\t* gfortran.dg/assign_10.f90: New test.\n+\n 2007-11-27  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33541"}, {"sha": "afe09d52c578056b424d169c0528028e9d38b1d5", "filename": "gcc/testsuite/gfortran.dg/assign_10.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_10.f90?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! { dg-options \"-O3 -fdump-tree-original\" }\n+! Tests the fix for PR33850, in which one of the two assignments\n+! below would produce an unnecessary temporary for the index\n+! expression, following the fix for PR33749.\n+!\n+! Contributed by Dick Hendrickson on comp.lang.fortran,\n+! \" Most elegant syntax for inverting a permutation?\" 20071006\n+!\n+  integer(4) :: p4(4) = (/2,4,1,3/)\n+  integer(4) :: q4(4) = (/2,4,1,3/)\n+  integer(8) :: p8(4) = (/2,4,1,3/)\n+  integer(8) :: q8(4) = (/2,4,1,3/)\n+  p4(q4) = (/(i, i = 1, 4)/)\n+  q4(q4) = (/(i, i = 1, 4)/)\n+  p8(q8) = (/(i, i = 1, 4)/)\n+  q8(q8) = (/(i, i = 1, 4)/)\n+  if (any(p4 .ne. q4)) call abort ()\n+  if (any(p8 .ne. q8)) call abort ()\n+end\n+! Whichever is the default length for array indices will yield\n+! parm 9 times, because a temporary is not necessary.  The other\n+! cases will all yield a temporary, so that atmp appears 27 times.\n+! Note that it is the kind conversion that generates the temp.\n+!\n+! { dg-final { scan-tree-dump-times \"parm\" 9 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"atmp\" 27 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "2ad791d3bbf100aa3f5a475c9dcb68c953b1f4da", "filename": "gcc/testsuite/gfortran.dg/stfunc_6.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstfunc_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a22351801ee5f0f364d14a55ae38f546565b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstfunc_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstfunc_6.f90?ref=908a22351801ee5f0f364d14a55ae38f546565b4", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! Tests the fix for the second bit of PR29389, in which the\n+! statement function would not be recognised as not PURE\n+! when it referenced a procedure that is not PURE.\n+!\n+! This is based on stfunc_4.f90 with the statement function made\n+! impure by a reference to 'v'.\n+!\n+! Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+\n+  INTEGER :: st1, i = 99, a(4), q = 6\n+  st1 (i) = i * i * i \n+  FORALL(i=1:4) a(i) = st1 (i) \n+  FORALL(i=1:4) a(i) = u (a(i)) - a(i)** 2 \n+  if (any (a .ne. 0)) call abort ()\n+  if (i .ne. 99) call abort ()\n+contains\n+  pure integer function u (x)\n+    integer,intent(in) :: x\n+    st2 (i) = i * v(i) ! { dg-error \"non-PURE procedure\" }\n+    u = st2(x)\n+  end function\n+  integer function v (x)\n+    integer,intent(in) :: x\n+    v = i\n+  end function\n+end"}]}