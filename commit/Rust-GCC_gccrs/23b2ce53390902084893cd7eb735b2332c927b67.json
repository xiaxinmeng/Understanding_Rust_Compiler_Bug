{"sha": "23b2ce53390902084893cd7eb735b2332c927b67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNiMmNlNTMzOTA5MDIwODQ4OTNjZDdlYjczNWIyMzMyYzkyN2I2Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:04:21Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:04:21Z"}, "message": "Initial revision\n\nFrom-SVN: r471", "tree": {"sha": "b6b6b56e6179556b50d580fdf62b979faf06781b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6b6b56e6179556b50d580fdf62b979faf06781b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23b2ce53390902084893cd7eb735b2332c927b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b2ce53390902084893cd7eb735b2332c927b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b2ce53390902084893cd7eb735b2332c927b67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b2ce53390902084893cd7eb735b2332c927b67/comments", "author": null, "committer": null, "parents": [{"sha": "2e8a660011cccec83ef9b443f9585226a7cc2989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e8a660011cccec83ef9b443f9585226a7cc2989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e8a660011cccec83ef9b443f9585226a7cc2989"}], "stats": {"total": 2849, "additions": 2849, "deletions": 0}, "files": [{"sha": "6a9d6d599be3e8c8a23f538d846c795174c32083", "filename": "gcc/emit-rtl.c", "status": "added", "additions": 2677, "deletions": 0, "changes": 2677, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b2ce53390902084893cd7eb735b2332c927b67/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b2ce53390902084893cd7eb735b2332c927b67/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=23b2ce53390902084893cd7eb735b2332c927b67", "patch": "@@ -0,0 +1,2677 @@\n+/* Emit RTL for the GNU C-Compiler expander.\n+   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Middle-to-low level generation of rtx code and insns.\n+\n+   This file contains the functions `gen_rtx', `gen_reg_rtx'\n+   and `gen_label_rtx' that are the usual ways of creating rtl\n+   expressions for most purposes.\n+\n+   It also has the functions for creating insns and linking\n+   them in the doubly-linked chain.\n+\n+   The patterns of the insns are created by machine-dependent\n+   routines in insn-emit.c, which is generated automatically from\n+   the machine description.  These routines use `gen_rtx' to make\n+   the individual rtx's of the pattern; what is machine dependent\n+   is the kind of rtx's they make and what arguments they use.  */\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"gvarargs.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"regs.h\"\n+#include \"insn-config.h\"\n+#include \"real.h\"\n+\n+/* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n+   After rtl generation, it is 1 plus the largest register number used.  */\n+\n+int reg_rtx_no = LAST_VIRTUAL_REGISTER + 1;\n+\n+/* This is *not* reset after each function.  It gives each CODE_LABEL\n+   in the entire compilation a unique label number.  */\n+\n+static int label_num = 1;\n+\n+/* Lowest label number in current function.  */\n+\n+static int first_label_num;\n+\n+/* Highest label number in current function.\n+   Zero means use the value of label_num instead.\n+   This is nonzero only when belatedly compiling an inline function.  */\n+\n+static int last_label_num;\n+\n+/* Value label_num had when set_new_first_and_last_label_number was called.\n+   If label_num has not changed since then, last_label_num is valid.  */\n+\n+static int base_label_num;\n+\n+/* Nonzero means do not generate NOTEs for source line numbers.  */\n+\n+static int no_line_numbers;\n+\n+/* Commonly used rtx's, so that we only need space for one copy.\n+   These are initialized once for the entire compilation.\n+   All of these except perhaps the floating-point CONST_DOUBLEs\n+   are unique; no other rtx-object will be equal to any of these.  */\n+\n+rtx pc_rtx;\t\t\t/* (PC) */\n+rtx cc0_rtx;\t\t\t/* (CC0) */\n+rtx cc1_rtx;\t\t\t/* (CC1) (not actually used nowadays) */\n+rtx const0_rtx;\t\t\t/* (CONST_INT 0) */\n+rtx const1_rtx;\t\t\t/* (CONST_INT 1) */\n+rtx const2_rtx;\t\t\t/* (CONST_INT 2) */\n+rtx constm1_rtx;\t\t/* (CONST_INT -1) */\n+rtx const_true_rtx;\t\t/* (CONST_INT STORE_FLAG_VALUE) */\n+\n+/* We record floating-point CONST_DOUBLEs in each floating-point mode for\n+   the values of 0, 1, and 2.  For the integer entries and VOIDmode, we\n+   record a copy of const[012]_rtx.  */\n+\n+rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n+\n+REAL_VALUE_TYPE dconst0;\n+REAL_VALUE_TYPE dconst1;\n+REAL_VALUE_TYPE dconst2;\n+REAL_VALUE_TYPE dconstm1;\n+\n+/* All references to the following fixed hard registers go through\n+   these unique rtl objects.  On machines where the frame-pointer and\n+   arg-pointer are the same register, they use the same unique object.\n+\n+   After register allocation, other rtl objects which used to be pseudo-regs\n+   may be clobbered to refer to the frame-pointer register.\n+   But references that were originally to the frame-pointer can be\n+   distinguished from the others because they contain frame_pointer_rtx.\n+\n+   In an inline procedure, the stack and frame pointer rtxs may not be\n+   used for anything else.  */\n+rtx stack_pointer_rtx;\t\t/* (REG:Pmode STACK_POINTER_REGNUM) */\n+rtx frame_pointer_rtx;\t\t/* (REG:Pmode FRAME_POINTER_REGNUM) */\n+rtx arg_pointer_rtx;\t\t/* (REG:Pmode ARG_POINTER_REGNUM) */\n+rtx struct_value_rtx;\t\t/* (REG:Pmode STRUCT_VALUE_REGNUM) */\n+rtx struct_value_incoming_rtx;\t/* (REG:Pmode STRUCT_VALUE_INCOMING_REGNUM) */\n+rtx static_chain_rtx;\t\t/* (REG:Pmode STATIC_CHAIN_REGNUM) */\n+rtx static_chain_incoming_rtx;\t/* (REG:Pmode STATIC_CHAIN_INCOMING_REGNUM) */\n+rtx pic_offset_table_rtx;\t/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */\n+\n+rtx virtual_incoming_args_rtx;\t/* (REG:Pmode VIRTUAL_INCOMING_ARGS_REGNUM) */\n+rtx virtual_stack_vars_rtx;\t/* (REG:Pmode VIRTUAL_STACK_VARS_REGNUM) */\n+rtx virtual_stack_dynamic_rtx;\t/* (REG:Pmode VIRTUAL_STACK_DYNAMIC_REGNUM) */\n+rtx virtual_outgoing_args_rtx;\t/* (REG:Pmode VIRTUAL_OUTGOING_ARGS_REGNUM) */\n+\n+/* We make one copy of (const_int C) where C is in\n+   [- MAX_SAVED_CONST_INT, MAX_SAVED_CONST_INT]\n+   to save space during the compilation and simplify comparisons of\n+   integers.  */\n+\n+#define MAX_SAVED_CONST_INT 64\n+\n+static rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n+\n+/* The ends of the doubly-linked chain of rtl for the current function.\n+   Both are reset to null at the start of rtl generation for the function.\n+   \n+   start_sequence saves both of these on `sequence_stack' and then\n+   starts a new, nested sequence of insns.  */\n+\n+static rtx first_insn = NULL;\n+static rtx last_insn = NULL;\n+\n+/* INSN_UID for next insn emitted.\n+   Reset to 1 for each function compiled.  */\n+\n+static int cur_insn_uid = 1;\n+\n+/* Line number and source file of the last line-number NOTE emitted.\n+   This is used to avoid generating duplicates.  */\n+\n+static int last_linenum = 0;\n+static char *last_filename = 0;\n+\n+/* A vector indexed by pseudo reg number.  The allocated length\n+   of this vector is regno_pointer_flag_length.  Since this\n+   vector is needed during the expansion phase when the total\n+   number of registers in the function is not yet known,\n+   it is copied and made bigger when necessary.  */\n+\n+char *regno_pointer_flag;\n+int regno_pointer_flag_length;\n+\n+/* Indexed by pseudo register number, gives the rtx for that pseudo.\n+   Allocated in parallel with regno_pointer_flag.  */\n+\n+rtx *regno_reg_rtx;\n+\n+/* Stack of pending (incomplete) sequences saved by `start_sequence'.\n+   Each element describes one pending sequence.\n+   The main insn-chain is saved in the last element of the chain,\n+   unless the chain is empty.  */\n+\n+struct sequence_stack *sequence_stack;\n+\n+/* start_sequence and gen_sequence can make a lot of rtx expressions which are\n+   shortly thrown away.  We use two mechanisms to prevent this waste:\n+\n+   First, we keep a list of the expressions used to represent the sequence\n+   stack in sequence_element_free_list.\n+\n+   Second, for sizes up to 5 elements, we keep a SEQUENCE and its associated\n+   rtvec for use by gen_sequence.  One entry for each size is sufficient\n+   because most cases are calls to gen_sequence followed by immediately\n+   emitting the SEQUENCE.  Reuse is safe since emitting a sequence is\n+   destructive on the insn in it anyway and hence can't be redone.\n+\n+   We do not bother to save this cached data over nested function calls.\n+   Instead, we just reinitialize them.  */\n+\n+#define SEQUENCE_RESULT_SIZE 5\n+\n+static struct sequence_stack *sequence_element_free_list;\n+static rtx sequence_result[SEQUENCE_RESULT_SIZE];\n+\n+extern int rtx_equal_function_value_matters;\n+\n+/* Filename and line number of last line-number note,\n+   whether we actually emitted it or not.  */\n+extern char *emit_filename;\n+extern int emit_lineno;\n+\n+rtx change_address ();\n+void init_emit ();\n+\f\n+/* rtx gen_rtx (code, mode, [element1, ..., elementn])\n+**\n+**\t    This routine generates an RTX of the size specified by\n+**\t<code>, which is an RTX code.   The RTX structure is initialized\n+**\tfrom the arguments <element1> through <elementn>, which are\n+**\tinterpreted according to the specific RTX type's format.   The\n+**\tspecial machine mode associated with the rtx (if any) is specified\n+**\tin <mode>.\n+**\n+**\t    gen_rtx() can be invoked in a way which resembles the lisp-like\n+**\trtx it will generate.   For example, the following rtx structure:\n+**\n+**\t      (plus:QI (mem:QI (reg:SI 1))\n+**\t\t       (mem:QI (plusw:SI (reg:SI 2) (reg:SI 3))))\n+**\n+**\t\t...would be generated by the following C code:\n+**\n+**\t    \tgen_rtx (PLUS, QImode,\n+**\t\t    gen_rtx (MEM, QImode,\n+**\t\t\tgen_rtx (REG, SImode, 1)),\n+**\t\t    gen_rtx (MEM, QImode,\n+**\t\t\tgen_rtx (PLUS, SImode,\n+**\t\t\t    gen_rtx (REG, SImode, 2),\n+**\t\t\t    gen_rtx (REG, SImode, 3)))),\n+*/\n+\n+/*VARARGS2*/\n+rtx\n+gen_rtx (va_alist)\n+     va_dcl\n+{\n+  va_list p;\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+  register int i;\t\t/* Array indices...\t\t\t*/\n+  register char *fmt;\t\t/* Current rtx's format...\t\t*/\n+  register rtx rt_val;\t\t/* RTX to return to caller...\t\t*/\n+\n+  va_start (p);\n+  code = va_arg (p, enum rtx_code);\n+  mode = va_arg (p, enum machine_mode);\n+\n+  if (code == CONST_INT)\n+    {\n+      int arg = va_arg (p, int);\n+\n+      if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n+\treturn const_int_rtx[arg + MAX_SAVED_CONST_INT];\n+\n+      if (const_true_rtx && arg == STORE_FLAG_VALUE)\n+\treturn const_true_rtx;\n+\n+      rt_val = rtx_alloc (code);\n+      INTVAL (rt_val) = arg;\n+    }\n+  else if (code == REG)\n+    {\n+      int regno = va_arg (p, int);\n+\n+      /* In case the MD file explicitly references the frame pointer, have\n+\t all such references point to the same frame pointer.  This is used\n+\t during frame pointer elimination to distinguish the explicit\n+\t references to these registers from pseudos that happened to be\n+\t assigned to them.\n+\n+\t If we have eliminated the frame pointer or arg pointer, we will\n+\t be using it as a normal register, for example as a spill register.\n+\t In such cases, we might be accessing it in a mode that is not\n+\t Pmode and therefore cannot use the pre-allocated rtx.  */\n+\n+      if (frame_pointer_rtx && regno == FRAME_POINTER_REGNUM && mode == Pmode)\n+\treturn frame_pointer_rtx;\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      if (arg_pointer_rtx && regno == ARG_POINTER_REGNUM && mode == Pmode)\n+\treturn arg_pointer_rtx;\n+#endif\n+      if (stack_pointer_rtx && regno == STACK_POINTER_REGNUM && mode == Pmode)\n+\treturn stack_pointer_rtx;\n+      else\n+\t{\n+\t  rt_val = rtx_alloc (code);\n+\t  rt_val->mode = mode;\n+\t  REGNO (rt_val) = regno;\n+\t  return rt_val;\n+\t}\n+    }\n+  else\n+    {\n+      rt_val = rtx_alloc (code);\t/* Allocate the storage space.  */\n+      rt_val->mode = mode;\t\t/* Store the machine mode...  */\n+\n+      fmt = GET_RTX_FORMAT (code);\t/* Find the right format...  */\n+      for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+\t{\n+\t  switch (*fmt++)\n+\t    {\n+\t    case '0':\t\t/* Unused field.  */\n+\t      break;\n+\n+\t    case 'i':\t\t/* An integer?  */\n+\t      XINT (rt_val, i) = va_arg (p, int);\n+\t      break;\n+\n+\t    case 's':\t\t/* A string?  */\n+\t      XSTR (rt_val, i) = va_arg (p, char *);\n+\t      break;\n+\n+\t    case 'e':\t\t/* An expression?  */\n+\t    case 'u':\t\t/* An insn?  Same except when printing.  */\n+\t      XEXP (rt_val, i) = va_arg (p, rtx);\n+\t      break;\n+\n+\t    case 'E':\t\t/* An RTX vector?  */\n+\t      XVEC (rt_val, i) = va_arg (p, rtvec);\n+\t      break;\n+\n+\t    default:\n+\t      abort();\n+\t    }\n+\t}\n+    }\n+  va_end (p);\n+  return rt_val;\t\t/* Return the new RTX...\t\t*/\n+}\n+\n+/* gen_rtvec (n, [rt1, ..., rtn])\n+**\n+**\t    This routine creates an rtvec and stores within it the\n+**\tpointers to rtx's which are its arguments.\n+*/\n+\n+/*VARARGS1*/\n+rtvec\n+gen_rtvec (va_alist)\n+     va_dcl\n+{\n+  int n, i;\n+  va_list p;\n+  rtx *vector;\n+\n+  va_start (p);\n+  n = va_arg (p, int);\n+\n+  if (n == 0)\n+    return NULL_RTVEC;\t\t/* Don't allocate an empty rtvec...\t*/\n+\n+  vector = (rtx *) alloca (n * sizeof (rtx));\n+  for (i = 0; i < n; i++)\n+    vector[i] = va_arg (p, rtx);\n+  va_end (p);\n+\n+  return gen_rtvec_v (n, vector);\n+}\n+\n+rtvec\n+gen_rtvec_v (n, argp)\n+     int n;\n+     rtx *argp;\n+{\n+  register int i;\n+  register rtvec rt_val;\n+\n+  if (n == 0)\n+    return NULL_RTVEC;\t\t/* Don't allocate an empty rtvec...\t*/\n+\n+  rt_val = rtvec_alloc (n);\t/* Allocate an rtvec...\t\t\t*/\n+\n+  for (i = 0; i < n; i++)\n+    rt_val->elem[i].rtx = *argp++;\n+\n+  return rt_val;\n+}\n+\f\n+/* Generate a REG rtx for a new pseudo register of mode MODE.\n+   This pseudo is assigned the next sequential register number.  */\n+\n+rtx\n+gen_reg_rtx (mode)\n+     enum machine_mode mode;\n+{\n+  register rtx val;\n+\n+  /* Don't let anything called by or after reload create new registers\n+     (actually, registers can't be created after flow, but this is a good\n+     approximation).  */\n+\n+  if (reload_in_progress || reload_completed)\n+    abort ();\n+\n+  /* Make sure regno_pointer_flag and regno_reg_rtx are large\n+     enough to have an element for this pseudo reg number.  */\n+\n+  if (reg_rtx_no == regno_pointer_flag_length)\n+    {\n+      rtx *new1;\n+      char *new =\n+\t(char *) oballoc (regno_pointer_flag_length * 2);\n+      bzero (new, regno_pointer_flag_length * 2);\n+      bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n+      regno_pointer_flag = new;\n+\n+      new1 = (rtx *) oballoc (regno_pointer_flag_length * 2 * sizeof (rtx));\n+      bzero (new1, regno_pointer_flag_length * 2 * sizeof (rtx));\n+      bcopy (regno_reg_rtx, new1, regno_pointer_flag_length * sizeof (rtx));\n+      regno_reg_rtx = new1;\n+\n+      regno_pointer_flag_length *= 2;\n+    }\n+\n+  val = gen_rtx (REG, mode, reg_rtx_no);\n+  regno_reg_rtx[reg_rtx_no++] = val;\n+  return val;\n+}\n+\n+/* Identify REG as a probable pointer register.  */\n+\n+void\n+mark_reg_pointer (reg)\n+     rtx reg;\n+{\n+  REGNO_POINTER_FLAG (REGNO (reg)) = 1;\n+}\n+\n+/* Return 1 plus largest pseudo reg number used in the current function.  */\n+\n+int\n+max_reg_num ()\n+{\n+  return reg_rtx_no;\n+}\n+\n+/* Return 1 + the largest label number used so far in the current function.  */\n+\n+int\n+max_label_num ()\n+{\n+  if (last_label_num && label_num == base_label_num)\n+    return last_label_num;\n+  return label_num;\n+}\n+\n+/* Return first label number used in this function (if any were used).  */\n+\n+int\n+get_first_label_num ()\n+{\n+  return first_label_num;\n+}\n+\f\n+/* Return a value representing some low-order bits of X, where the number\n+   of low-order bits is given by MODE.  Note that no conversion is done\n+   between floating-point and fixed-point values, rather, the bit \n+   representation is returned.\n+\n+   This function handles the cases in common between gen_lowpart, below,\n+   and two variants in cse.c and combine.c.  These are the cases that can\n+   be safely handled at all points in the compilation.\n+\n+   If this is not a case we can handle, return 0.  */\n+\n+rtx\n+gen_lowpart_common (mode, x)\n+     enum machine_mode mode;\n+     register rtx x;\n+{\n+  int word = 0;\n+\n+  if (GET_MODE (x) == mode)\n+    return x;\n+\n+  /* MODE must occupy no more words than the mode of X.  */\n+  if (GET_MODE (x) != VOIDmode\n+      && ((GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD\n+\t  > ((GET_MODE_SIZE (GET_MODE (x)) + (UNITS_PER_WORD - 1))\n+\t     / UNITS_PER_WORD)))\n+    return 0;\n+\n+  if (WORDS_BIG_ENDIAN && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+    word = ((GET_MODE_SIZE (GET_MODE (x))\n+\t     - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n+\t    / UNITS_PER_WORD);\n+\n+  if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)\n+      && GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      /* If we are getting the low-order part of something that has been\n+\t sign- or zero-extended, we can either just use the object being\n+\t extended or make a narrower extension.  If we want an even smaller\n+\t piece than the size of the object being extended, call ourselves\n+\t recursively.\n+\n+\t This case is used mostly by combine and cse.  */\n+\n+      if (GET_MODE (XEXP (x, 0)) == mode)\n+\treturn XEXP (x, 0);\n+      else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (XEXP (x, 0))))\n+\treturn gen_lowpart_common (mode, XEXP (x, 0));\n+      else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x)))\n+\treturn gen_rtx (GET_CODE (x), mode, XEXP (x, 0));\n+    }\n+  else if (GET_CODE (x) == SUBREG\n+\t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t       || GET_MODE_SIZE (mode) == GET_MODE_UNIT_SIZE (GET_MODE (x))))\n+    return (GET_MODE (SUBREG_REG (x)) == mode && SUBREG_WORD (x) == 0\n+\t    ? SUBREG_REG (x)\n+\t    : gen_rtx (SUBREG, mode, SUBREG_REG (x), SUBREG_WORD (x)));\n+  else if (GET_CODE (x) == REG)\n+    {\n+      /* If the register is not valid for MODE, return 0.  If we don't\n+\t do this, there is no way to fix up the resulting REG later.  */\n+      if (REGNO (x) < FIRST_PSEUDO_REGISTER\n+\t  && ! HARD_REGNO_MODE_OK (REGNO (x) + word, mode))\n+\treturn 0;\n+      else if (REGNO (x) < FIRST_PSEUDO_REGISTER\n+\t       /* integrate.c can't handle parts of a return value register. */\n+\t       && (! REG_FUNCTION_VALUE_P (x)\n+\t\t   || ! rtx_equal_function_value_matters))\n+\treturn gen_rtx (REG, mode, REGNO (x) + word);\n+      else\n+\treturn gen_rtx (SUBREG, mode, x, word);\n+    }\n+\n+  /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n+     from the low-order part of the constant.  */\n+  else if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE (x) == VOIDmode\n+\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n+    return (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_INT ? x\n+\t    : (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_INT\n+\t       && GET_CODE (x) == CONST_INT) ? x\n+\t    : gen_rtx (CONST_INT, VOIDmode,\n+\t\t       (GET_MODE_MASK (mode)\n+\t\t\t& (GET_CODE (x) == CONST_INT\n+\t\t\t   ? INTVAL (x) : CONST_DOUBLE_LOW (x)))));\n+\n+  /* Otherwise, we can't do this.  */\n+  return 0;\n+}\n+\f\n+/* Assuming that X is an rtx (e.g., MEM, REG or SUBREG) for a value,\n+   return an rtx (MEM, SUBREG, or CONST_INT) that refers to the\n+   least-significant part of X.\n+   MODE specifies how big a part of X to return;\n+   it usually should not be larger than a word.\n+   If X is a MEM whose address is a QUEUED, the value may be so also.  */\n+\n+rtx\n+gen_lowpart (mode, x)\n+     enum machine_mode mode;\n+     register rtx x;\n+{\n+  rtx result = gen_lowpart_common (mode, x);\n+\n+  if (result)\n+    return result;\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      /* The only additional case we can do is MEM.  */\n+      register int offset = 0;\n+      if (WORDS_BIG_ENDIAN)\n+\toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n+\t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+\n+      if (BYTES_BIG_ENDIAN)\n+\t/* Adjust the address so that the address-after-the-data\n+\t   is unchanged.  */\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n+\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n+\n+      return change_address (x, mode, plus_constant (XEXP (x, 0), offset));\n+    }\n+  else\n+    abort ();\n+}\n+\n+/* Return 1 iff X, assumed to be a SUBREG,\n+   refers to the least significant part of its containing reg.\n+   If X is not a SUBREG, always return 1 (it is its own low part!).  */\n+\n+int\n+subreg_lowpart_p (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) != SUBREG)\n+    return 1;\n+\n+  if (WORDS_BIG_ENDIAN\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD)\n+    return (SUBREG_WORD (x)\n+\t    == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+\t\t - MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD))\n+\t\t/ UNITS_PER_WORD));\n+\n+  return SUBREG_WORD (x) == 0;\n+}\n+\f\n+/* Return subword I of operand OP.\n+   The word number, I, is interpreted as the word number starting at the\n+   low-order address.  Word 0 is the low-order word if not WORDS_BIG_ENDIAN,\n+   otherwise it is the high-order word.\n+\n+   If we cannot extract the required word, we return zero.  Otherwise, an\n+   rtx corresponding to the requested word will be returned.\n+\n+   VALIDATE_ADDRESS is nonzero if the address should be validated.  Before\n+   reload has completed, a valid address will always be returned.  After\n+   reload, if a valid address cannot be returned, we return zero.\n+\n+   If VALIDATE_ADDRESS is zero, we simply form the required address; validating\n+   it is the responsibility of the caller.\n+\n+   MODE is the mode of OP in case it is a CONST_INT.  */\n+\n+rtx\n+operand_subword (op, i, validate_address, mode)\n+     rtx op;\n+     int i;\n+     int validate_address;\n+     enum machine_mode mode;\n+{\n+  int val;\n+  int size_ratio = HOST_BITS_PER_INT / BITS_PER_WORD;\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  if (mode == VOIDmode)\n+    abort ();\n+\n+  /* If OP is narrower than a word or if we want a word outside OP, fail.  */\n+  if (mode != BLKmode\n+      && (GET_MODE_SIZE (mode) < UNITS_PER_WORD\n+\t  || (i + 1) * UNITS_PER_WORD > GET_MODE_SIZE (mode)))\n+    return 0;\n+\n+  /* If OP is already an integer word, return it.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n+    return op;\n+\n+  /* If OP is a REG or SUBREG, we can handle it very simply.  */\n+  if (GET_CODE (op) == REG)\n+    {\n+      /* If the register is not valid for MODE, return 0.  If we don't\n+\t do this, there is no way to fix up the resulting REG later.  */\n+      if (REGNO (op) < FIRST_PSEUDO_REGISTER\n+\t  && ! HARD_REGNO_MODE_OK (REGNO (op) + i, word_mode))\n+\treturn 0;\n+      else if (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t       || (REG_FUNCTION_VALUE_P (op)\n+\t\t   && rtx_equal_function_value_matters))\n+\treturn gen_rtx (SUBREG, word_mode, op, i);\n+      else\n+\treturn gen_rtx (REG, word_mode, REGNO (op) + i);\n+    }\n+  else if (GET_CODE (op) == SUBREG)\n+    return gen_rtx (SUBREG, word_mode, SUBREG_REG (op), i + SUBREG_WORD (op));\n+\n+  /* Form a new MEM at the requested address.  */\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx addr = plus_constant (XEXP (op, 0), i * UNITS_PER_WORD);\n+      rtx new;\n+\n+      if (validate_address)\n+\t{\n+\t  if (reload_completed)\n+\t    {\n+\t      if (! strict_memory_address_p (word_mode, addr))\n+\t\treturn 0;\n+\t    }\n+\t  else\n+\t    addr = memory_address (word_mode, addr);\n+\t}\n+\n+      new = gen_rtx (MEM, word_mode, addr);\n+\n+      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (op);\n+      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (op);\n+      RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n+\n+      return new;\n+    }\n+\n+  /* The only remaining cases are when OP is a constant.  If the host and\n+     target floating formats are the same, handling two-word floating\n+     constants are easy.  */\n+  if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+\t&& HOST_BITS_PER_INT == BITS_PER_WORD)\n+       || flag_pretend_float)\n+      && GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n+      && GET_CODE (op) == CONST_DOUBLE)\n+    return gen_rtx (CONST_INT, VOIDmode,\n+\t\t    i ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op));\n+\n+  /* Single word float is a little harder, since single- and double-word\n+     values often do not have the same high-order bits.  We have already\n+     verified that we want the only defined word of the single-word value.  */\n+  if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+\t&& HOST_BITS_PER_INT == BITS_PER_WORD)\n+       || flag_pretend_float)\n+      && GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n+      && GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      double d;\n+      union {float f; int i; } u;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+\n+      u.f = d;\n+      return gen_rtx (CONST_INT, VOIDmode, u.i);\n+    }\n+      \n+  /* The only remaining cases that we can handle are integers.\n+     Convert to proper endianness now since these cases need it.\n+     At this point, i == 0 means the low-order word.  \n+\n+     Note that it must be that BITS_PER_WORD <= HOST_BITS_PER_INT.\n+     This is because if it were greater, it could only have been two\n+     times greater since we do not support making wider constants.  In\n+     that case, it MODE would have already been the proper size and\n+     it would have been handled above.  This means we do not have to\n+     worry about the case where we would be returning a CONST_DOUBLE.  */\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT\n+      || (GET_CODE (op) != CONST_INT && GET_CODE (op) != CONST_DOUBLE))\n+    return 0;\n+\n+  if (WORDS_BIG_ENDIAN)\n+    i = GET_MODE_SIZE (mode) / UNITS_PER_WORD - 1 - i;\n+\n+  /* Find out which word on the host machine this value is in and get\n+     it from the constant.  */\n+  val = (i / size_ratio == 0\n+\t ? (GET_CODE (op) == CONST_INT ? INTVAL (op) : CONST_DOUBLE_LOW (op))\n+\t : (GET_CODE (op) == CONST_INT\n+\t    ? (INTVAL (op) < 0 ? ~0 : 0) : CONST_DOUBLE_HIGH (op)));\n+\n+  /* If BITS_PER_WORD is smaller than an int, get the appropriate bits.  */\n+  if (BITS_PER_WORD < HOST_BITS_PER_INT)\n+    val = ((val >> ((i % size_ratio) * BITS_PER_WORD))\n+\t   & ((1 << (BITS_PER_WORD % HOST_BITS_PER_INT)) - 1));\n+\n+  return gen_rtx (CONST_INT, VOIDmode, val);\n+}\n+\n+/* Similar to `operand_subword', but never return 0.  If we can't extract\n+   the required subword, put OP into a register and try again.  If that fails,\n+   abort.  We always validate the address in this case.  It is not valid\n+   to call this function after reload; it is mostly meant for RTL\n+   generation. \n+\n+   MODE is the mode of OP, in case it is CONST_INT.  */\n+\n+rtx\n+operand_subword_force (op, i, mode)\n+     rtx op;\n+     int i;\n+     enum machine_mode mode;\n+{\n+  rtx result = operand_subword (op, i, 1, mode);\n+\n+  if (result)\n+    return result;\n+\n+  if (mode != BLKmode && mode != VOIDmode)\n+    op = force_reg (mode, op);\n+\n+  result = operand_subword (op, i, 1, mode);\n+  if (result == 0)\n+    abort ();\n+\n+  return result;\n+}\n+\f\n+/* Given a compare instruction, swap the operands.\n+   A test instruction is changed into a compare of 0 against the operand.  */\n+\n+void\n+reverse_comparison (insn)\n+     rtx insn;\n+{\n+  rtx body = PATTERN (insn);\n+  rtx comp;\n+\n+  if (GET_CODE (body) == SET)\n+    comp = SET_SRC (body);\n+  else\n+    comp = SET_SRC (XVECEXP (body, 0, 0));\n+\n+  if (GET_CODE (comp) == COMPARE)\n+    {\n+      rtx op0 = XEXP (comp, 0);\n+      rtx op1 = XEXP (comp, 1);\n+      XEXP (comp, 0) = op1;\n+      XEXP (comp, 1) = op0;\n+    }\n+  else\n+    {\n+      rtx new = gen_rtx (COMPARE, VOIDmode,\n+\t\t\t CONST0_RTX (GET_MODE (comp)), comp);\n+      if (GET_CODE (body) == SET)\n+\tSET_SRC (body) = new;\n+      else\n+\tSET_SRC (XVECEXP (body, 0, 0)) = new;\n+    }\n+}\n+\f\n+/* Return a memory reference like MEMREF, but with its mode changed\n+   to MODE and its address changed to ADDR.\n+   (VOIDmode means don't change the mode.\n+   NULL for ADDR means don't change the address.)  */\n+\n+rtx\n+change_address (memref, mode, addr)\n+     rtx memref;\n+     enum machine_mode mode;\n+     rtx addr;\n+{\n+  rtx new;\n+\n+  if (GET_CODE (memref) != MEM)\n+    abort ();\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (memref);\n+  if (addr == 0)\n+    addr = XEXP (memref, 0);\n+\n+  /* If reload is in progress or has completed, ADDR must be valid.\n+     Otherwise, we can call memory_address to make it valid.  */\n+  if (reload_completed || reload_in_progress)\n+    {\n+      if (! memory_address_p (mode, addr))\n+\tabort ();\n+    }\n+  else\n+    addr = memory_address (mode, addr);\n+\t\n+  new = gen_rtx (MEM, mode, addr);\n+  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (memref);\n+  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (memref);\n+  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (memref);\n+  return new;\n+}\n+\f\n+/* Return a newly created CODE_LABEL rtx with a unique label number.  */\n+\n+rtx\n+gen_label_rtx ()\n+{\n+  register rtx label = gen_rtx (CODE_LABEL, VOIDmode, 0, 0, 0, label_num++, 0);\n+  LABEL_NUSES (label) = 0;\n+  return label;\n+}\n+\f\n+/* For procedure integration.  */\n+\n+/* Return a newly created INLINE_HEADER rtx.  Should allocate this\n+   from a permanent obstack when the opportunity arises.  */\n+\n+rtx\n+gen_inline_header_rtx (first_insn, first_parm_insn, first_labelno,\n+\t\t       last_labelno, max_parm_regnum, max_regnum, args_size,\n+\t\t       pops_args, stack_slots, function_flags,\n+\t\t       outgoing_args_size, original_arg_vector,\n+\t\t       original_decl_initial)\n+     rtx first_insn, first_parm_insn;\n+     int first_labelno, last_labelno, max_parm_regnum, max_regnum, args_size;\n+     int pops_args;\n+     rtx stack_slots;\n+     int function_flags;\n+     int outgoing_args_size;\n+     rtvec original_arg_vector;\n+     rtx original_decl_initial;\n+{\n+  rtx header = gen_rtx (INLINE_HEADER, VOIDmode,\n+\t\t\tcur_insn_uid++, NULL,\n+\t\t\tfirst_insn, first_parm_insn,\n+\t\t\tfirst_labelno, last_labelno,\n+\t\t\tmax_parm_regnum, max_regnum, args_size, pops_args,\n+\t\t\tstack_slots, function_flags, outgoing_args_size,\n+\t\t\toriginal_arg_vector, original_decl_initial);\n+  return header;\n+}\n+\n+/* Install new pointers to the first and last insns in the chain.\n+   Used for an inline-procedure after copying the insn chain.  */\n+\n+void\n+set_new_first_and_last_insn (first, last)\n+     rtx first, last;\n+{\n+  first_insn = first;\n+  last_insn = last;\n+}\n+\n+/* Set the range of label numbers found in the current function.\n+   This is used when belatedly compiling an inline function.  */\n+\n+void\n+set_new_first_and_last_label_num (first, last)\n+     int first, last;\n+{\n+  base_label_num = label_num;\n+  first_label_num = first;\n+  last_label_num = last;\n+}\n+\f\n+/* Save all variables describing the current status into the structure *P.\n+   This is used before starting a nested function.  */\n+\n+void\n+save_emit_status (p)\n+     struct function *p;\n+{\n+  p->reg_rtx_no = reg_rtx_no;\n+  p->first_label_num = first_label_num;\n+  p->first_insn = first_insn;\n+  p->last_insn = last_insn;\n+  p->sequence_stack = sequence_stack;\n+  p->cur_insn_uid = cur_insn_uid;\n+  p->last_linenum = last_linenum;\n+  p->last_filename = last_filename;\n+  p->regno_pointer_flag = regno_pointer_flag;\n+  p->regno_pointer_flag_length = regno_pointer_flag_length;\n+  p->regno_reg_rtx = regno_reg_rtx;\n+}\n+\n+/* Restore all variables describing the current status from the structure *P.\n+   This is used after a nested function.  */\n+\n+void\n+restore_emit_status (p)\n+     struct function *p;\n+{\n+  int i;\n+\n+  reg_rtx_no = p->reg_rtx_no;\n+  first_label_num = p->first_label_num;\n+  first_insn = p->first_insn;\n+  last_insn = p->last_insn;\n+  sequence_stack = p->sequence_stack;\n+  cur_insn_uid = p->cur_insn_uid;\n+  last_linenum = p->last_linenum;\n+  last_filename = p->last_filename;\n+  regno_pointer_flag = p->regno_pointer_flag;\n+  regno_pointer_flag_length = p->regno_pointer_flag_length;\n+  regno_reg_rtx = p->regno_reg_rtx;\n+\n+  /* Clear our cache of rtx expressions for start_sequence and gen_sequence. */\n+  sequence_element_free_list = 0;\n+  for (i = 0; i < SEQUENCE_RESULT_SIZE; i++)\n+    sequence_result[i] = 0;\n+}\n+\f\n+/* Go through all the RTL insn bodies and copy any invalid shared structure.\n+   It does not work to do this twice, because the mark bits set here\n+   are not cleared afterwards.  */\n+\n+void\n+unshare_all_rtl (insn)\n+     register rtx insn;\n+{\n+  for (; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n+\t|| GET_CODE (insn) == CALL_INSN)\n+      {\n+\tPATTERN (insn) = copy_rtx_if_shared (PATTERN (insn));\n+\tREG_NOTES (insn) = copy_rtx_if_shared (REG_NOTES (insn));\n+\tLOG_LINKS (insn) = copy_rtx_if_shared (LOG_LINKS (insn));\n+      }\n+\n+  /* Make sure the addresses of stack slots found outside the insn chain\n+     (such as, in DECL_RTL of a variable) are not shared\n+     with the insn chain.\n+\n+     This special care is necessary when the stack slot MEM does not\n+     actually appear in the insn chain.  If it does appear, its address\n+     is unshared from all else at that point.  */\n+\n+  copy_rtx_if_shared (stack_slot_list);\n+}\n+\n+/* Mark ORIG as in use, and return a copy of it if it was already in use.\n+   Recursively does the same for subexpressions.  */\n+\n+rtx\n+copy_rtx_if_shared (orig)\n+     rtx orig;\n+{\n+  register rtx x = orig;\n+  register int i;\n+  register enum rtx_code code;\n+  register char *format_ptr;\n+  int copied = 0;\n+\n+  if (x == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+\n+  /* These types may be freely shared.  */\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+      /* SCRATCH must be shared because they represent distinct values. */\n+      return x;\n+\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case NOTE:\n+    case LABEL_REF:\n+    case BARRIER:\n+      /* The chain of insns is not being copied.  */\n+      return x;\n+\n+    case MEM:\n+      /* A MEM is allowed to be shared if its address is constant\n+\t or is a constant plus one of the special registers.  */\n+      if (CONSTANT_ADDRESS_P (XEXP (x, 0))\n+\t  || XEXP (x, 0) == virtual_stack_vars_rtx\n+\t  || XEXP (x, 0) == virtual_incoming_args_rtx)\n+\treturn x;\n+\n+      if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && (XEXP (XEXP (x, 0), 0) == virtual_stack_vars_rtx\n+\t      || XEXP (XEXP (x, 0), 0) == virtual_incoming_args_rtx)\n+\t  && CONSTANT_ADDRESS_P (XEXP (XEXP (x, 0), 1)))\n+\t{\n+\t  /* This MEM can appear in more than one place,\n+\t     but its address better not be shared with anything else.  */\n+\t  if (! x->used)\n+\t    XEXP (x, 0) = copy_rtx_if_shared (XEXP (x, 0));\n+\t  x->used = 1;\n+\t  return x;\n+\t}\n+    }\n+\n+  /* This rtx may not be shared.  If it has already been seen,\n+     replace it with a copy of itself.  */\n+\n+  if (x->used)\n+    {\n+      register rtx copy;\n+\n+      copy = rtx_alloc (code);\n+      bcopy (x, copy, (sizeof (*copy) - sizeof (copy->fld)\n+\t\t       + sizeof (copy->fld[0]) * GET_RTX_LENGTH (code)));\n+      x = copy;\n+      copied = 1;\n+    }\n+  x->used = 1;\n+\n+  /* Now scan the subexpressions recursively.\n+     We can store any replaced subexpressions directly into X\n+     since we know X is not shared!  Any vectors in X\n+     must be copied if X was copied.  */\n+\n+  format_ptr = GET_RTX_FORMAT (code);\n+\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  XEXP (x, i) = copy_rtx_if_shared (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'E':\n+\t  if (XVEC (x, i) != NULL)\n+\t    {\n+\t      register int j;\n+\n+\t      if (copied)\n+\t\tXVEC (x, i) = gen_rtvec_v (XVECLEN (x, i), &XVECEXP (x, i, 0));\n+\t      for (j = 0; j < XVECLEN (x, i); j++)\n+\t\tXVECEXP (x, i, j)\n+\t\t  = copy_rtx_if_shared (XVECEXP (x, i, j));\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  return x;\n+}\n+\n+/* Clear all the USED bits in X to allow copy_rtx_if_shared to be used\n+   to look for shared sub-parts.  */\n+\n+void\n+reset_used_flags (x)\n+     rtx x;\n+{\n+  register int i, j;\n+  register enum rtx_code code;\n+  register char *format_ptr;\n+  int copied = 0;\n+\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  /* These types may be freely shared so we needn't do any reseting\n+     for them.  */\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+      return;\n+\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case NOTE:\n+    case LABEL_REF:\n+    case BARRIER:\n+      /* The chain of insns is not being copied.  */\n+      return;\n+    }\n+\n+  x->used = 0;\n+\n+  format_ptr = GET_RTX_FORMAT (code);\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  reset_used_flags (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    reset_used_flags (XVECEXP (x, i, j));\n+\t  break;\n+\t}\n+    }\n+}\n+\f\n+/* Copy X if necessary so that it won't be altered by changes in OTHER.\n+   Return X or the rtx for the pseudo reg the value of X was copied into.\n+   OTHER must be valid as a SET_DEST.  */\n+\n+rtx\n+make_safe_from (x, other)\n+     rtx x, other;\n+{\n+  while (1)\n+    switch (GET_CODE (other))\n+      {\n+      case SUBREG:\n+\tother = SUBREG_REG (other);\n+\tbreak;\n+      case STRICT_LOW_PART:\n+      case SIGN_EXTEND:\n+      case ZERO_EXTEND:\n+\tother = XEXP (other, 0);\n+\tbreak;\n+      default:\n+\tgoto done;\n+      }\n+ done:\n+  if ((GET_CODE (other) == MEM\n+       && ! CONSTANT_P (x)\n+       && GET_CODE (x) != REG\n+       && GET_CODE (x) != SUBREG)\n+      || (GET_CODE (other) == REG\n+\t  && (REGNO (other) < FIRST_PSEUDO_REGISTER\n+\t      || reg_mentioned_p (other, x))))\n+    {\n+      rtx temp = gen_reg_rtx (GET_MODE (x));\n+      emit_move_insn (temp, x);\n+      return temp;\n+    }\n+  return x;\n+}\n+\f\n+/* Emission of insns (adding them to the doubly-linked list).  */\n+\n+/* Return the first insn of the current sequence or current function.  */\n+\n+rtx\n+get_insns ()\n+{\n+  return first_insn;\n+}\n+\n+/* Return the last insn emitted in current sequence or current function.  */\n+\n+rtx\n+get_last_insn ()\n+{\n+  return last_insn;\n+}\n+\n+/* Specify a new insn as the last in the chain.  */\n+\n+void\n+set_last_insn (insn)\n+     rtx insn;\n+{\n+  if (NEXT_INSN (insn) != 0)\n+    abort ();\n+  last_insn = insn;\n+}\n+\n+/* Return the last insn emitted, even if it is in a sequence now pushed.  */\n+\n+rtx\n+get_last_insn_anywhere ()\n+{\n+  struct sequence_stack *stack;\n+  if (last_insn)\n+    return last_insn;\n+  for (stack = sequence_stack; stack; stack = stack->next)\n+    if (stack->last != 0)\n+      return stack->last;\n+  return 0;\n+}\n+\n+/* Return a number larger than any instruction's uid in this function.  */\n+\n+int\n+get_max_uid ()\n+{\n+  return cur_insn_uid;\n+}\n+\f\n+/* Return the next insn.  If it is a SEQUENCE, return the first insn\n+   of the sequence.  */\n+\n+rtx\n+next_insn (insn)\n+     rtx insn;\n+{\n+  if (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn && GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the previous insn.  If it is a SEQUENCE, return the last insn\n+   of the sequence.  */\n+\n+rtx\n+previous_insn (insn)\n+     rtx insn;\n+{\n+  if (insn)\n+    {\n+      insn = PREV_INSN (insn);\n+      if (insn && GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\tinsn = XVECEXP (PATTERN (insn), 0, XVECLEN (PATTERN (insn), 0) - 1);\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the next insn after INSN that is not a NOTE.  This routine does not\n+   look inside SEQUENCEs.  */\n+\n+rtx\n+next_nonnote_insn (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0 || GET_CODE (insn) != NOTE)\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the previous insn before INSN that is not a NOTE.  This routine does\n+   not look inside SEQUENCEs.  */\n+\n+rtx\n+prev_nonnote_insn (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = PREV_INSN (insn);\n+      if (insn == 0 || GET_CODE (insn) != NOTE)\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;\n+   or 0, if there is none.  This routine does not look inside\n+   SEQUENCEs. */\n+\n+rtx\n+next_real_insn (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0 || GET_CODE (insn) == INSN\n+\t  || GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the last INSN, CALL_INSN or JUMP_INSN before INSN;\n+   or 0, if there is none.  This routine does not look inside\n+   SEQUENCEs.  */\n+\n+rtx\n+prev_real_insn (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = PREV_INSN (insn);\n+      if (insn == 0 || GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n+\t  || GET_CODE (insn) == JUMP_INSN)\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Find the next insn after INSN that really does something.  This routine\n+   does not look inside SEQUENCEs.  Until reload has completed, this is the\n+   same as next_real_insn.  */\n+\n+rtx\n+next_active_insn (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0\n+\t  || GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n+\t  || (GET_CODE (insn) == INSN\n+\t      && (! reload_completed\n+\t\t  || (GET_CODE (PATTERN (insn)) != USE\n+\t\t      && GET_CODE (PATTERN (insn)) != CLOBBER))))\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Find the last insn before INSN that really does something.  This routine\n+   does not look inside SEQUENCEs.  Until reload has completed, this is the\n+   same as prev_real_insn.  */\n+\n+rtx\n+prev_active_insn (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = PREV_INSN (insn);\n+      if (insn == 0\n+\t  || GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n+\t  || (GET_CODE (insn) == INSN\n+\t      && (! reload_completed\n+\t\t  || (GET_CODE (PATTERN (insn)) != USE\n+\t\t      && GET_CODE (PATTERN (insn)) != CLOBBER))))\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the next CODE_LABEL after the insn INSN, or 0 if there is none.  */\n+\n+rtx\n+next_label (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0 || GET_CODE (insn) == CODE_LABEL)\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the last CODE_LABEL before the insn INSN, or 0 if there is none.  */\n+\n+rtx\n+prev_label (insn)\n+     rtx insn;\n+{\n+  while (insn)\n+    {\n+      insn = PREV_INSN (insn);\n+      if (insn == 0 || GET_CODE (insn) == CODE_LABEL)\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\f\n+#ifdef HAVE_cc0\n+/* Return the next insn that uses CC0 after INSN, which is assumed to\n+   set it.  This is the inverse of prev_cc0_setter (i.e., prev_cc0_setter\n+   applied to the result of this function should yield INSN).\n+\n+   Normally, this is simply the next insn.  However, if a REG_CC_USER note\n+   is present, it contains the insn that uses CC0.\n+\n+   Return 0 if we can't find the insn.  */\n+\n+rtx\n+next_cc0_user (insn)\n+     rtx insn;\n+{\n+  rtx note = find_reg_note (insn, REG_CC_USER, 0);\n+\n+  if (note)\n+    return XEXP (note, 0);\n+\n+  insn = next_nonnote_insn (insn);\n+  if (insn && GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    insn = XVECEXP (PATTERN (insn), 0, 0);\n+\n+  if (insn && GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+      && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n+    return insn;\n+\n+  return 0;\n+}\n+\n+/* Find the insn that set CC0 for INSN.  Unless INSN has a REG_CC_SETTER\n+   note, it is the previous insn.  */\n+\n+rtx\n+prev_cc0_setter (insn)\n+     rtx insn;\n+{\n+  rtx note = find_reg_note (insn, REG_CC_SETTER, 0);\n+  rtx link;\n+\n+  if (note)\n+    return XEXP (note, 0);\n+\n+  insn = prev_nonnote_insn (insn);\n+  if (! sets_cc0_p (PATTERN (insn)))\n+    abort ();\n+\n+  return insn;\n+}\n+#endif\n+\f\n+/* Try splitting insns that can be split for better scheduling.\n+   PAT is the pattern which might split.\n+   TRIAL is the insn providing PAT.\n+   BACKWARDS is non-zero if we are scanning insns from last to first.\n+\n+   If this routine succeeds in splitting, it returns the first or last\n+   replacement insn depending on the value of BACKWARDS.  Otherwise, it\n+   returns TRIAL.  If the insn to be returned can be split, it will be.  */\n+\n+rtx\n+try_split (pat, trial, backwards)\n+     rtx pat, trial;\n+     int backwards;\n+{\n+  rtx before = PREV_INSN (trial);\n+  rtx after = NEXT_INSN (trial);\n+  rtx seq = split_insns (pat, trial);\n+  int has_barrier = 0;\n+  rtx tem;\n+\n+  /* If we are splitting a JUMP_INSN, it might be followed by a BARRIER.\n+     We may need to handle this specially.  */\n+  if (after && GET_CODE (after) == BARRIER)\n+    {\n+      has_barrier = 1;\n+      after = NEXT_INSN (after);\n+    }\n+\n+  if (seq)\n+    {\n+      /* SEQ can either be a SEQUENCE or the pattern of a single insn.\n+\t The latter case will normally arise only when being done so that\n+\t it, in turn, will be split (SFmode on the 29k is an example).  */\n+      if (GET_CODE (seq) == SEQUENCE)\n+\t{\n+\t  /* If we are splitting a JUMP_INSN, look for the JUMP_INSN in\n+\t     SEQ and copy our JUMP_LABEL to it.  If JUMP_LABEL is non-zero,\n+\t     increment the usage count so we don't delete the label.  */\n+\t  int i;\n+\n+\t  if (GET_CODE (trial) == JUMP_INSN)\n+\t    for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n+\t      if (GET_CODE (XVECEXP (seq, 0, i)) == JUMP_INSN)\n+\t\t{\n+\t\t  JUMP_LABEL (XVECEXP (seq, 0, i)) = JUMP_LABEL (trial);\n+\n+\t\t  if (JUMP_LABEL (trial))\n+\t\t    LABEL_NUSES (JUMP_LABEL (trial))++;\n+\t\t}\n+\n+\t  tem = emit_insn_after (seq, before);\n+\n+\t  delete_insn (trial);\n+\t  if (has_barrier)\n+\t    emit_barrier_after (tem);\n+\t}\n+      /* Avoid infinite loop if the result matches the original pattern.  */\n+      else if (rtx_equal_p (seq, pat))\n+\treturn trial;\n+      else\n+\t{\n+\t  PATTERN (trial) = seq;\n+\t  INSN_CODE (trial) = -1;\n+\t}\n+\n+      /* Set TEM to the insn we should return.  */\n+      tem = backwards ? prev_active_insn (after) : next_active_insn (before);\n+      return try_split (PATTERN (tem), tem, backwards);\n+    }\n+\n+  return trial;\n+}\n+\f\n+/* Make and return an INSN rtx, initializing all its slots.\n+   Store PATTERN in the pattern slots.\n+   PAT_FORMALS is an idea that never really went anywhere.  */\n+\n+rtx\n+make_insn_raw (pattern, pat_formals)\n+     rtx pattern;\n+     rtvec pat_formals;\n+{\n+  register rtx insn;\n+\n+  insn = rtx_alloc(INSN);\n+  INSN_UID(insn) = cur_insn_uid++;\n+\n+  PATTERN (insn) = pattern;\n+  INSN_CODE (insn) = -1;\n+  LOG_LINKS(insn) = NULL;\n+  REG_NOTES(insn) = NULL;\n+\n+  return insn;\n+}\n+\n+/* Like `make_insn' but make a JUMP_INSN instead of an insn.  */\n+\n+static rtx\n+make_jump_insn_raw (pattern, pat_formals)\n+     rtx pattern;\n+     rtvec pat_formals;\n+{\n+  register rtx insn;\n+\n+  insn = rtx_alloc(JUMP_INSN);\n+  INSN_UID(insn) = cur_insn_uid++;\n+\n+  PATTERN (insn) = pattern;\n+  INSN_CODE (insn) = -1;\n+  LOG_LINKS(insn) = NULL;\n+  REG_NOTES(insn) = NULL;\n+  JUMP_LABEL(insn) = NULL;\n+\n+  return insn;\n+}\n+\f\n+/* Add INSN to the end of the doubly-linked list.\n+   INSN may be an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER or NOTE.  */\n+\n+void\n+add_insn (insn)\n+     register rtx insn;\n+{\n+  PREV_INSN (insn) = last_insn;\n+  NEXT_INSN (insn) = 0;\n+\n+  if (NULL != last_insn)\n+    NEXT_INSN (last_insn) = insn;\n+\n+  if (NULL == first_insn)\n+    first_insn = insn;\n+\n+  last_insn = insn;\n+}\n+\n+/* Add INSN into the doubly-linked list after insn AFTER.  This should be the\n+   only function called to insert an insn once delay slots have been filled\n+   since only it knows how to update a SEQUENCE.  */\n+\n+void\n+add_insn_after (insn, after)\n+     rtx insn, after;\n+{\n+  rtx next = NEXT_INSN (after);\n+\n+  NEXT_INSN (insn) = next;\n+  PREV_INSN (insn) = after;\n+\n+  if (next)\n+    {\n+      PREV_INSN (next) = insn;\n+      if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == SEQUENCE)\n+\tPREV_INSN (XVECEXP (PATTERN (next), 0, 0)) = insn;\n+    }\n+  else if (last_insn == after)\n+    last_insn = insn;\n+  else\n+    {\n+      struct sequence_stack *stack = sequence_stack;\n+      /* Scan all pending sequences too.  */\n+      for (; stack; stack = stack->next)\n+\tif (after == stack->last)\n+\t  stack->last = insn;\n+    }\n+\n+  NEXT_INSN (after) = insn;\n+  if (GET_CODE (after) == INSN && GET_CODE (PATTERN (after)) == SEQUENCE)\n+    {\n+      rtx sequence = PATTERN (after);\n+      NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = insn;\n+    }\n+}\n+\n+/* Delete all insns made since FROM.\n+   FROM becomes the new last instruction.  */\n+\n+void\n+delete_insns_since (from)\n+     rtx from;\n+{\n+  if (from == 0)\n+    first_insn = 0;\n+  else\n+    NEXT_INSN (from) = 0;\n+  last_insn = from;\n+}\n+\n+/* Move a consecutive bunch of insns to a different place in the chain.\n+   The insns to be moved are those between FROM and TO.\n+   They are moved to a new position after the insn AFTER.\n+   AFTER must not be FROM or TO or any insn in between.\n+\n+   This function does not know about SEQUENCEs and hence should not be\n+   called after delay-slot filling has been done.  */\n+\n+void\n+reorder_insns (from, to, after)\n+     rtx from, to, after;\n+{\n+  /* Splice this bunch out of where it is now.  */\n+  if (PREV_INSN (from))\n+    NEXT_INSN (PREV_INSN (from)) = NEXT_INSN (to);\n+  if (NEXT_INSN (to))\n+    PREV_INSN (NEXT_INSN (to)) = PREV_INSN (from);\n+  if (last_insn == to)\n+    last_insn = PREV_INSN (from);\n+  if (first_insn == from)\n+    first_insn = NEXT_INSN (to);\n+\n+  /* Make the new neighbors point to it and it to them.  */\n+  if (NEXT_INSN (after))\n+    PREV_INSN (NEXT_INSN (after)) = to;\n+\n+  NEXT_INSN (to) = NEXT_INSN (after);\n+  PREV_INSN (from) = after;\n+  NEXT_INSN (after) = from;\n+  if (after == last_insn)\n+    last_insn = to;\n+}\n+\n+/* Return the line note insn preceding INSN.  */\n+\n+static rtx\n+find_line_note (insn)\n+     rtx insn;\n+{\n+  if (no_line_numbers)\n+    return 0;\n+\n+  for (; insn; insn = PREV_INSN (insn))\n+    if (GET_CODE (insn) == NOTE\n+        && NOTE_LINE_NUMBER (insn) >= 0)\n+      break;\n+\n+  return insn;\n+}\n+\n+/* Like reorder_insns, but inserts line notes to preserve the line numbers\n+   of the moved insns when debugging.  This may insert a note between AFTER\n+   and FROM, and another one after TO.  */\n+\n+void\n+reorder_insns_with_line_notes (from, to, after)\n+     rtx from, to, after;\n+{\n+  rtx from_line = find_line_note (from);\n+  rtx after_line = find_line_note (after);\n+\n+  reorder_insns (from, to, after);\n+\n+  if (from_line == after_line)\n+    return;\n+\n+  if (from_line)\n+    emit_line_note_after (NOTE_SOURCE_FILE (from_line),\n+\t\t\t  NOTE_LINE_NUMBER (from_line),\n+\t\t\t  after);\n+  if (after_line)\n+    emit_line_note_after (NOTE_SOURCE_FILE (after_line),\n+\t\t\t  NOTE_LINE_NUMBER (after_line),\n+\t\t\t  to);\n+}\n+\f\n+/* Emit an insn of given code and pattern\n+   at a specified place within the doubly-linked list.  */\n+\n+/* Make an instruction with body PATTERN\n+   and output it before the instruction BEFORE.  */\n+\n+rtx\n+emit_insn_before (pattern, before)\n+     register rtx pattern, before;\n+{\n+  register rtx insn = before;\n+\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    {\n+      register int i;\n+\n+      for (i = 0; i < XVECLEN (pattern, 0); i++)\n+\t{\n+\t  insn = XVECEXP (pattern, 0, i);\n+\t  add_insn_after (insn, PREV_INSN (before));\n+\t}\n+      if (XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n+\tsequence_result[XVECLEN (pattern, 0)] = pattern;\n+    }\n+  else\n+    {\n+      insn = make_insn_raw (pattern, 0);\n+      add_insn_after (insn, PREV_INSN (before));\n+    }\n+\n+  return insn;\n+}\n+\n+/* Make an instruction with body PATTERN and code JUMP_INSN\n+   and output it before the instruction BEFORE.  */\n+\n+rtx\n+emit_jump_insn_before (pattern, before)\n+     register rtx pattern, before;\n+{\n+  register rtx insn;\n+\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    insn = emit_insn_before (pattern, before);\n+  else\n+    {\n+      insn = make_jump_insn_raw (pattern, 0);\n+      add_insn_after (insn, PREV_INSN (before));\n+    }\n+\n+  return insn;\n+}\n+\n+/* Make an instruction with body PATTERN and code CALL_INSN\n+   and output it before the instruction BEFORE.  */\n+\n+rtx\n+emit_call_insn_before (pattern, before)\n+     register rtx pattern, before;\n+{\n+  rtx insn = emit_insn_before (pattern, before);\n+  PUT_CODE (insn, CALL_INSN);\n+  return insn;\n+}\n+\n+/* Make an insn of code BARRIER\n+   and output it before the insn AFTER.  */\n+\n+rtx\n+emit_barrier_before (before)\n+     register rtx before;\n+{\n+  register rtx insn = rtx_alloc (BARRIER);\n+\n+  INSN_UID (insn) = cur_insn_uid++;\n+\n+  add_insn_after (insn, PREV_INSN (before));\n+  return insn;\n+}\n+\n+/* Emit a note of subtype SUBTYPE before the insn BEFORE.  */\n+\n+rtx\n+emit_note_before (subtype, before)\n+     int subtype;\n+     rtx before;\n+{\n+  register rtx note = rtx_alloc (NOTE);\n+  INSN_UID (note) = cur_insn_uid++;\n+  NOTE_SOURCE_FILE (note) = 0;\n+  NOTE_LINE_NUMBER (note) = subtype;\n+\n+  add_insn_after (note, PREV_INSN (before));\n+  return note;\n+}\n+\f\n+/* Make an insn of code INSN with body PATTERN\n+   and output it after the insn AFTER.  */\n+\n+rtx\n+emit_insn_after (pattern, after)\n+     register rtx pattern, after;\n+{\n+  register rtx insn = after;\n+\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    {\n+      register int i;\n+\n+      for (i = 0; i < XVECLEN (pattern, 0); i++)\n+\t{\n+\t  insn = XVECEXP (pattern, 0, i);\n+\t  add_insn_after (insn, after);\n+\t  after = insn;\n+\t}\n+      if (XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n+\tsequence_result[XVECLEN (pattern, 0)] = pattern;\n+    }\n+  else\n+    {\n+      insn = make_insn_raw (pattern, 0);\n+      add_insn_after (insn, after);\n+    }\n+\n+  return insn;\n+}\n+\n+/* Make an insn of code JUMP_INSN with body PATTERN\n+   and output it after the insn AFTER.  */\n+\n+rtx\n+emit_jump_insn_after (pattern, after)\n+     register rtx pattern, after;\n+{\n+  register rtx insn;\n+\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    insn = emit_insn_after (pattern, after);\n+  else\n+    {\n+      insn = make_jump_insn_raw (pattern, 0);\n+      add_insn_after (insn, after);\n+    }\n+\n+  return insn;\n+}\n+\n+/* Make an insn of code BARRIER\n+   and output it after the insn AFTER.  */\n+\n+rtx\n+emit_barrier_after (after)\n+     register rtx after;\n+{\n+  register rtx insn = rtx_alloc (BARRIER);\n+\n+  INSN_UID (insn) = cur_insn_uid++;\n+\n+  add_insn_after (insn, after);\n+  return insn;\n+}\n+\n+/* Emit the label LABEL after the insn AFTER.  */\n+\n+rtx\n+emit_label_after (label, after)\n+     rtx label, after;\n+{\n+  /* This can be called twice for the same label\n+     as a result of the confusion that follows a syntax error!\n+     So make it harmless.  */\n+  if (INSN_UID (label) == 0)\n+    {\n+      INSN_UID (label) = cur_insn_uid++;\n+      add_insn_after (label, after);\n+    }\n+\n+  return label;\n+}\n+\n+/* Emit a note of subtype SUBTYPE after the insn AFTER.  */\n+\n+rtx\n+emit_note_after (subtype, after)\n+     int subtype;\n+     rtx after;\n+{\n+  register rtx note = rtx_alloc (NOTE);\n+  INSN_UID (note) = cur_insn_uid++;\n+  NOTE_SOURCE_FILE (note) = 0;\n+  NOTE_LINE_NUMBER (note) = subtype;\n+  add_insn_after (note, after);\n+  return note;\n+}\n+\n+/* Emit a line note for FILE and LINE after the insn AFTER.  */\n+\n+rtx\n+emit_line_note_after (file, line, after)\n+     char *file;\n+     int line;\n+     rtx after;\n+{\n+  register rtx note;\n+\n+  if (no_line_numbers && line > 0)\n+    {\n+      cur_insn_uid++;\n+      return 0;\n+    }\n+\n+  note  = rtx_alloc (NOTE);\n+  INSN_UID (note) = cur_insn_uid++;\n+  NOTE_SOURCE_FILE (note) = file;\n+  NOTE_LINE_NUMBER (note) = line;\n+  add_insn_after (note, after);\n+  return note;\n+}\n+\f\n+/* Make an insn of code INSN with pattern PATTERN\n+   and add it to the end of the doubly-linked list.\n+   If PATTERN is a SEQUENCE, take the elements of it\n+   and emit an insn for each element.\n+\n+   Returns the last insn emitted.  */\n+\n+rtx\n+emit_insn (pattern)\n+     rtx pattern;\n+{\n+  rtx insn = last_insn;\n+\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    {\n+      register int i;\n+\n+      for (i = 0; i < XVECLEN (pattern, 0); i++)\n+\t{\n+\t  insn = XVECEXP (pattern, 0, i);\n+\t  add_insn (insn);\n+\t}\n+      if (XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n+\tsequence_result[XVECLEN (pattern, 0)] = pattern;\n+    }\n+  else\n+    {\n+      insn = make_insn_raw (pattern, NULL);\n+      add_insn (insn);\n+    }\n+\n+  return insn;\n+}\n+\n+/* Emit the insns in a chain starting with INSN.\n+   Return the last insn emitted.  */\n+\n+rtx\n+emit_insns (insn)\n+     rtx insn;\n+{\n+  rtx last = 0;\n+\n+  while (insn)\n+    {\n+      rtx next = NEXT_INSN (insn);\n+      add_insn (insn);\n+      last = insn;\n+      insn = next;\n+    }\n+\n+  return last;\n+}\n+\n+/* Emit the insns in a chain starting with INSN and place them in front of\n+   the insn BEFORE.  Return the last insn emitted.  */\n+\n+rtx\n+emit_insns_before (insn, before)\n+     rtx insn;\n+     rtx before;\n+{\n+  rtx last = 0;\n+\n+  while (insn)\n+    {\n+      rtx next = NEXT_INSN (insn);\n+      add_insn_after (insn, PREV_INSN (before));\n+      last = insn;\n+      insn = next;\n+    }\n+\n+  return last;\n+}\n+\n+/* Make an insn of code JUMP_INSN with pattern PATTERN\n+   and add it to the end of the doubly-linked list.  */\n+\n+rtx\n+emit_jump_insn (pattern)\n+     rtx pattern;\n+{\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    return emit_insn (pattern);\n+  else\n+    {\n+      register rtx insn = make_jump_insn_raw (pattern, NULL);\n+      add_insn (insn);\n+      return insn;\n+    }\n+}\n+\n+/* Make an insn of code CALL_INSN with pattern PATTERN\n+   and add it to the end of the doubly-linked list.  */\n+\n+rtx\n+emit_call_insn (pattern)\n+     rtx pattern;\n+{\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    return emit_insn (pattern);\n+  else\n+    {\n+      register rtx insn = make_insn_raw (pattern, NULL);\n+      add_insn (insn);\n+      PUT_CODE (insn, CALL_INSN);\n+      return insn;\n+    }\n+}\n+\n+/* Add the label LABEL to the end of the doubly-linked list.  */\n+\n+rtx\n+emit_label (label)\n+     rtx label;\n+{\n+  /* This can be called twice for the same label\n+     as a result of the confusion that follows a syntax error!\n+     So make it harmless.  */\n+  if (INSN_UID (label) == 0)\n+    {\n+      INSN_UID (label) = cur_insn_uid++;\n+      add_insn (label);\n+    }\n+  return label;\n+}\n+\n+/* Make an insn of code BARRIER\n+   and add it to the end of the doubly-linked list.  */\n+\n+rtx\n+emit_barrier ()\n+{\n+  register rtx barrier = rtx_alloc (BARRIER);\n+  INSN_UID (barrier) = cur_insn_uid++;\n+  add_insn (barrier);\n+  return barrier;\n+}\n+\n+/* Make an insn of code NOTE\n+   with data-fields specified by FILE and LINE\n+   and add it to the end of the doubly-linked list,\n+   but only if line-numbers are desired for debugging info.  */\n+\n+rtx\n+emit_line_note (file, line)\n+     char *file;\n+     int line;\n+{\n+  emit_filename = file;\n+  emit_lineno = line;\n+\n+#if 0\n+  if (no_line_numbers)\n+    return 0;\n+#endif\n+\n+  return emit_note (file, line);\n+}\n+\n+/* Make an insn of code NOTE\n+   with data-fields specified by FILE and LINE\n+   and add it to the end of the doubly-linked list.\n+   If it is a line-number NOTE, omit it if it matches the previous one.  */\n+\n+rtx\n+emit_note (file, line)\n+     char *file;\n+     int line;\n+{\n+  register rtx note;\n+\n+  if (line > 0)\n+    {\n+      if (file && last_filename && !strcmp (file, last_filename)\n+\t  && line == last_linenum)\n+\treturn 0;\n+      last_filename = file;\n+      last_linenum = line;\n+    }\n+\n+  if (no_line_numbers && line > 0)\n+    {\n+      cur_insn_uid++;\n+      return 0;\n+    }\n+\n+  note = rtx_alloc (NOTE);\n+  INSN_UID (note) = cur_insn_uid++;\n+  NOTE_SOURCE_FILE (note) = file;\n+  NOTE_LINE_NUMBER (note) = line;\n+  add_insn (note);\n+  return note;\n+}\n+\n+/* Emit a NOTE, and don't omit it even if LINE it the previous note.  */\n+\n+rtx\n+emit_line_note_force (file, line)\n+     char *file;\n+     int line;\n+{\n+  last_linenum = -1;\n+  return emit_line_note (file, line);\n+}\n+\n+/* Cause next statement to emit a line note even if the line number\n+   has not changed.  This is used at the beginning of a function.  */\n+\n+void\n+force_next_line_note ()\n+{\n+  last_linenum = -1;\n+}\n+\f\n+/* Return an indication of which type of insn should have X as a body.\n+   The value is CODE_LABEL, INSN, CALL_INSN or JUMP_INSN.  */\n+\n+enum rtx_code\n+classify_insn (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) == CODE_LABEL)\n+    return CODE_LABEL;\n+  if (GET_CODE (x) == CALL)\n+    return CALL_INSN;\n+  if (GET_CODE (x) == RETURN)\n+    return JUMP_INSN;\n+  if (GET_CODE (x) == SET)\n+    {\n+      if (SET_DEST (x) == pc_rtx)\n+\treturn JUMP_INSN;\n+      else if (GET_CODE (SET_SRC (x)) == CALL)\n+\treturn CALL_INSN;\n+      else\n+\treturn INSN;\n+    }\n+  if (GET_CODE (x) == PARALLEL)\n+    {\n+      register int j;\n+      for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n+\tif (GET_CODE (XVECEXP (x, 0, j)) == CALL)\n+\t  return CALL_INSN;\n+\telse if (GET_CODE (XVECEXP (x, 0, j)) == SET\n+\t\t && SET_DEST (XVECEXP (x, 0, j)) == pc_rtx)\n+\t  return JUMP_INSN;\n+\telse if (GET_CODE (XVECEXP (x, 0, j)) == SET\n+\t\t && GET_CODE (SET_SRC (XVECEXP (x, 0, j))) == CALL)\n+\t  return CALL_INSN;\n+    }\n+  return INSN;\n+}\n+\n+/* Emit the rtl pattern X as an appropriate kind of insn.\n+   If X is a label, it is simply added into the insn chain.  */\n+\n+rtx\n+emit (x)\n+     rtx x;\n+{\n+  enum rtx_code code = classify_insn (x);\n+\n+  if (code == CODE_LABEL)\n+    return emit_label (x);\n+  else if (code == INSN)\n+    return emit_insn (x);\n+  else if (code == JUMP_INSN)\n+    {\n+      register rtx insn = emit_jump_insn (x);\n+      if (simplejump_p (insn) || GET_CODE (x) == RETURN)\n+\treturn emit_barrier ();\n+      return insn;\n+    }\n+  else if (code == CALL_INSN)\n+    return emit_call_insn (x);\n+  else\n+    abort ();\n+}\n+\f\n+/* Begin emitting insns to a sequence which can be packaged in an RTL_EXPR.  */\n+\n+void\n+start_sequence ()\n+{\n+  struct sequence_stack *tem;\n+\n+  if (sequence_element_free_list)\n+    {\n+      /* Reuse a previously-saved struct sequence_stack.  */\n+      tem = sequence_element_free_list;\n+      sequence_element_free_list = tem->next;\n+    }\n+  else\n+    tem = (struct sequence_stack *) permalloc (sizeof (struct sequence_stack));\n+\n+  tem->next = sequence_stack;\n+  tem->first = first_insn;\n+  tem->last = last_insn;\n+\n+  sequence_stack = tem;\n+\n+  first_insn = 0;\n+  last_insn = 0;\n+}\n+\n+/* Set up the insn chain starting with FIRST\n+   as the current sequence, saving the previously current one.  */\n+\n+void\n+push_to_sequence (first)\n+     rtx first;\n+{\n+  rtx last;\n+\n+  start_sequence ();\n+\n+  for (last = first; last && NEXT_INSN (last); last = NEXT_INSN (last));\n+\n+  first_insn = first;\n+  last_insn = last;\n+}\n+\n+/* After emitting to a sequence, restore previous saved state.\n+\n+   To get the contents of the sequence just made,\n+   you must call `gen_sequence' *before* calling here.  */\n+\n+void\n+end_sequence ()\n+{\n+  struct sequence_stack *tem = sequence_stack;\n+\n+  first_insn = tem->first;\n+  last_insn = tem->last;\n+  sequence_stack = tem->next;\n+\n+  tem->next = sequence_element_free_list;\n+  sequence_element_free_list = tem;\n+}\n+\n+/* Return 1 if currently emitting into a sequence.  */\n+\n+int\n+in_sequence_p ()\n+{\n+  return sequence_stack != 0;\n+}\n+\n+/* Generate a SEQUENCE rtx containing the insns already emitted\n+   to the current sequence.\n+\n+   This is how the gen_... function from a DEFINE_EXPAND\n+   constructs the SEQUENCE that it returns.  */\n+\n+rtx\n+gen_sequence ()\n+{\n+  rtx result;\n+  rtx tem;\n+  rtvec newvec;\n+  int i;\n+  int len;\n+\n+  /* Count the insns in the chain.  */\n+  len = 0;\n+  for (tem = first_insn; tem; tem = NEXT_INSN (tem))\n+    len++;\n+\n+  /* If only one insn, return its pattern rather than a SEQUENCE.\n+     (Now that we cache SEQUENCE expressions, it isn't worth special-casing\n+     the case of an empty list.)  */\n+  if (len == 1\n+      && (GET_CODE (first_insn) == INSN\n+\t  || GET_CODE (first_insn) == JUMP_INSN\n+\t  || GET_CODE (first_insn) == CALL_INSN))\n+    return PATTERN (first_insn);\n+\n+  /* Put them in a vector.  See if we already have a SEQUENCE of the\n+     appropriate length around.  */\n+  if (len < SEQUENCE_RESULT_SIZE && (result = sequence_result[len]) != 0)\n+    sequence_result[len] = 0;\n+  else\n+    {\n+      /* Ensure that this rtl goes in saveable_obstack, since we may be\n+\t caching it.  */\n+      int in_current_obstack = rtl_in_saveable_obstack ();\n+      result = gen_rtx (SEQUENCE, VOIDmode, rtvec_alloc (len));\n+      if (in_current_obstack)\n+\trtl_in_current_obstack ();\n+    }\n+\n+  for (i = 0, tem = first_insn; tem; tem = NEXT_INSN (tem), i++)\n+    XVECEXP (result, 0, i) = tem;\n+\n+  return result;\n+}\n+\f\n+/* Set up regno_reg_rtx, reg_rtx_no and regno_pointer_flag\n+   according to the chain of insns starting with FIRST.\n+\n+   Also set cur_insn_uid to exceed the largest uid in that chain.\n+\n+   This is used when an inline function's rtl is saved\n+   and passed to rest_of_compilation later.  */\n+\n+static void restore_reg_data_1 ();\n+\n+void\n+restore_reg_data (first)\n+     rtx first;\n+{\n+  register rtx insn;\n+  int i;\n+  register int max_uid = 0;\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_UID (insn) >= max_uid)\n+\tmax_uid = INSN_UID (insn);\n+\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase NOTE:\n+\tcase CODE_LABEL:\n+\tcase BARRIER:\n+\t  break;\n+\n+\tcase JUMP_INSN:\n+\tcase CALL_INSN:\n+\tcase INSN:\n+\t  restore_reg_data_1 (PATTERN (insn));\n+\t  break;\n+\t}\n+    }\n+\n+  /* Don't duplicate the uids already in use.  */\n+  cur_insn_uid = max_uid + 1;\n+\n+  /* If any regs are missing, make them up.  \n+\n+     ??? word_mode is not necessarily the right mode.  Most likely these REGs\n+     are never used.  At some point this should be checked.  */\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < reg_rtx_no; i++)\n+    if (regno_reg_rtx[i] == 0)\n+      regno_reg_rtx[i] = gen_rtx (REG, word_mode, i);\n+}\n+\n+static void\n+restore_reg_data_1 (orig)\n+     rtx orig;\n+{\n+  register rtx x = orig;\n+  register int i;\n+  register enum rtx_code code;\n+  register char *format_ptr;\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case LABEL_REF:\n+      return;\n+\n+    case REG:\n+      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  /* Make sure regno_pointer_flag and regno_reg_rtx are large\n+\t     enough to have an element for this pseudo reg number.  */\n+\t  if (REGNO (x) >= reg_rtx_no)\n+\t    {\n+\t      reg_rtx_no = REGNO (x);\n+\n+\t      if (reg_rtx_no >= regno_pointer_flag_length)\n+\t\t{\n+\t\t  int newlen = MAX (regno_pointer_flag_length * 2,\n+\t\t\t\t    reg_rtx_no + 30);\n+\t\t  rtx *new1;\n+\t\t  char *new = (char *) oballoc (newlen);\n+\t\t  bzero (new, newlen);\n+\t\t  bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n+\n+\t\t  new1 = (rtx *) oballoc (newlen * sizeof (rtx));\n+\t\t  bzero (new1, newlen * sizeof (rtx));\n+\t\t  bcopy (regno_reg_rtx, new1, regno_pointer_flag_length * sizeof (rtx));\n+\n+\t\t  regno_pointer_flag = new;\n+\t\t  regno_reg_rtx = new1;\n+\t\t  regno_pointer_flag_length = newlen;\n+\t\t}\n+\t      reg_rtx_no ++;\n+\t    }\n+\t  regno_reg_rtx[REGNO (x)] = x;\n+\t}\n+      return;\n+\n+    case MEM:\n+      if (GET_CODE (XEXP (x, 0)) == REG)\n+\tmark_reg_pointer (XEXP (x, 0));\n+      restore_reg_data_1 (XEXP (x, 0));\n+      return;\n+    }\n+\n+  /* Now scan the subexpressions recursively.  */\n+\n+  format_ptr = GET_RTX_FORMAT (code);\n+\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  restore_reg_data_1 (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'E':\n+\t  if (XVEC (x, i) != NULL)\n+\t    {\n+\t      register int j;\n+\n+\t      for (j = 0; j < XVECLEN (x, i); j++)\n+\t\trestore_reg_data_1 (XVECEXP (x, i, j));\n+\t    }\n+\t  break;\n+\t}\n+    }\n+}\n+\f\n+/* Initialize data structures and variables in this file\n+   before generating rtl for each function.  */\n+\n+void\n+init_emit ()\n+{\n+  int i;\n+\n+  first_insn = NULL;\n+  last_insn = NULL;\n+  cur_insn_uid = 1;\n+  reg_rtx_no = LAST_VIRTUAL_REGISTER + 1;\n+  last_linenum = 0;\n+  last_filename = 0;\n+  first_label_num = label_num;\n+  last_label_num = 0;\n+\n+  /* Clear the start_sequence/gen_sequence cache.  */\n+  sequence_element_free_list = 0;\n+  for (i = 0; i < SEQUENCE_RESULT_SIZE; i++)\n+    sequence_result[i] = 0;\n+\n+  /* Init the tables that describe all the pseudo regs.  */\n+\n+  regno_pointer_flag_length = LAST_VIRTUAL_REGISTER + 101;\n+\n+  regno_pointer_flag \n+    = (char *) oballoc (regno_pointer_flag_length);\n+  bzero (regno_pointer_flag, regno_pointer_flag_length);\n+\n+  regno_reg_rtx \n+    = (rtx *) oballoc (regno_pointer_flag_length * sizeof (rtx));\n+  bzero (regno_reg_rtx, regno_pointer_flag_length * sizeof (rtx));\n+\n+  /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n+  regno_reg_rtx[VIRTUAL_INCOMING_ARGS_REGNUM] = virtual_incoming_args_rtx;\n+  regno_reg_rtx[VIRTUAL_STACK_VARS_REGNUM] = virtual_stack_vars_rtx;\n+  regno_reg_rtx[VIRTUAL_STACK_DYNAMIC_REGNUM] = virtual_stack_dynamic_rtx;\n+  regno_reg_rtx[VIRTUAL_OUTGOING_ARGS_REGNUM] = virtual_outgoing_args_rtx;\n+}\n+\n+/* Create some permanent unique rtl objects shared between all functions.\n+   LINE_NUMBERS is nonzero if line numbers are to be generated.  */\n+\n+void\n+init_emit_once (line_numbers)\n+     int line_numbers;\n+{\n+  int i;\n+  enum machine_mode mode;\n+\n+  no_line_numbers = ! line_numbers;\n+\n+  sequence_stack = NULL;\n+\n+  /* Create the unique rtx's for certain rtx codes and operand values.  */\n+\n+  pc_rtx = gen_rtx (PC, VOIDmode);\n+  cc0_rtx = gen_rtx (CC0, VOIDmode);\n+\n+  /* Don't use gen_rtx here since gen_rtx in this case\n+     tries to use these variables.  */\n+  for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n+    {\n+      const_int_rtx[i + MAX_SAVED_CONST_INT] = rtx_alloc (CONST_INT);\n+      PUT_MODE (const_int_rtx[i + MAX_SAVED_CONST_INT], VOIDmode);\n+      INTVAL (const_int_rtx[i + MAX_SAVED_CONST_INT]) = i;\n+    }\n+\n+  /* These four calls obtain some of the rtx expressions made above.  */\n+  const0_rtx = gen_rtx (CONST_INT, VOIDmode, 0);\n+  const1_rtx = gen_rtx (CONST_INT, VOIDmode, 1);\n+  const2_rtx = gen_rtx (CONST_INT, VOIDmode, 2);\n+  constm1_rtx = gen_rtx (CONST_INT, VOIDmode, -1);\n+\n+  /* This will usually be one of the above constants, but may be a new rtx.  */\n+  const_true_rtx = gen_rtx (CONST_INT, VOIDmode, STORE_FLAG_VALUE);\n+\n+  dconst0 = REAL_VALUE_ATOF (\"0\");\n+  dconst1 = REAL_VALUE_ATOF (\"1\");\n+  dconst2 = REAL_VALUE_ATOF (\"2\");\n+  dconstm1 = REAL_VALUE_ATOF (\"-1\");\n+\n+  for (i = 0; i <= 2; i++)\n+    {\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t{\n+\t  rtx tem = rtx_alloc (CONST_DOUBLE);\n+\t  union real_extract u;\n+\n+\t  bzero (&u, sizeof u);  /* Zero any holes in a structure.  */\n+\t  u.d = i == 0 ? dconst0 : i == 1 ? dconst1 : dconst2;\n+\n+\t  bcopy (&u, &CONST_DOUBLE_LOW (tem), sizeof u);\n+\t  CONST_DOUBLE_MEM (tem) = cc0_rtx;\n+\t  PUT_MODE (tem, mode);\n+\n+\t  const_tiny_rtx[i][(int) mode] = tem;\n+\t}\n+\n+      const_tiny_rtx[i][(int) VOIDmode] = gen_rtx (CONST_INT, VOIDmode, i);\n+\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\tconst_tiny_rtx[i][(int) mode] = gen_rtx (CONST_INT, VOIDmode, i);\n+    }\n+\n+  stack_pointer_rtx = gen_rtx (REG, Pmode, STACK_POINTER_REGNUM);\n+  frame_pointer_rtx = gen_rtx (REG, Pmode, FRAME_POINTER_REGNUM);\n+\n+  if (FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM)\n+    arg_pointer_rtx = frame_pointer_rtx;\n+  else if (STACK_POINTER_REGNUM == ARG_POINTER_REGNUM)\n+    arg_pointer_rtx = stack_pointer_rtx;\n+  else\n+    arg_pointer_rtx = gen_rtx (REG, Pmode, ARG_POINTER_REGNUM);\n+\n+  /* Create the virtual registers.  Do so here since the following objects\n+     might reference them.  */\n+\n+  virtual_incoming_args_rtx = gen_rtx (REG, Pmode,\n+\t\t\t\t       VIRTUAL_INCOMING_ARGS_REGNUM);\n+  virtual_stack_vars_rtx = gen_rtx (REG, Pmode,\n+\t\t\t\t    VIRTUAL_STACK_VARS_REGNUM);\n+  virtual_stack_dynamic_rtx = gen_rtx (REG, Pmode,\n+\t\t\t\t       VIRTUAL_STACK_DYNAMIC_REGNUM);\n+  virtual_outgoing_args_rtx = gen_rtx (REG, Pmode,\n+\t\t\t\t       VIRTUAL_OUTGOING_ARGS_REGNUM);\n+\n+#ifdef STRUCT_VALUE\n+  struct_value_rtx = STRUCT_VALUE;\n+#else\n+  struct_value_rtx = gen_rtx (REG, Pmode, STRUCT_VALUE_REGNUM);\n+#endif\n+\n+#ifdef STRUCT_VALUE_INCOMING\n+  struct_value_incoming_rtx = STRUCT_VALUE_INCOMING;\n+#else\n+#ifdef STRUCT_VALUE_INCOMING_REGNUM\n+  struct_value_incoming_rtx\n+    = gen_rtx (REG, Pmode, STRUCT_VALUE_INCOMING_REGNUM);\n+#else\n+  struct_value_incoming_rtx = struct_value_rtx;\n+#endif\n+#endif\n+\n+#ifdef STATIC_CHAIN_REGNUM\n+  static_chain_rtx = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n+\n+#ifdef STATIC_CHAIN_INCOMING_REGNUM\n+  if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n+    static_chain_incoming_rtx = gen_rtx (REG, Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n+  else\n+#endif\n+    static_chain_incoming_rtx = static_chain_rtx;\n+#endif\n+\n+#ifdef STATIC_CHAIN\n+  static_chain_rtx = STATIC_CHAIN;\n+\n+#ifdef STATIC_CHAIN_INCOMING\n+  static_chain_incoming_rtx = STATIC_CHAIN_INCOMING;\n+#else\n+  static_chain_incoming_rtx = static_chain_rtx;\n+#endif\n+#endif\n+\n+#ifdef PIC_OFFSET_TABLE_REGNUM\n+  pic_offset_table_rtx = gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM);\n+#endif\n+}"}, {"sha": "f4cdbffc7f344b918d4386029a05b8a60ff67c8a", "filename": "gcc/loop.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b2ce53390902084893cd7eb735b2332c927b67/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b2ce53390902084893cd7eb735b2332c927b67/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=23b2ce53390902084893cd7eb735b2332c927b67", "patch": "@@ -0,0 +1,172 @@\n+/* Loop optimization definitions for GNU C-Compiler\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Get the luid of an insn.  Catch the error of trying to reference the LUID\n+   of an insn added during loop, since these don't have LUIDs.  */\n+\n+#define INSN_LUID(INSN)\t\t\t\\\n+  (INSN_UID (INSN) < max_uid_for_loop ? uid_luid[INSN_UID (INSN)] \\\n+   : (abort (), -1))\n+\n+/* A \"basic induction variable\" or biv is a pseudo reg that is set\n+   (within this loop) only by incrementing or decrementing it.  */\n+/* A \"general induction variable\" or giv is a pseudo reg whose\n+   value is a linear function of a biv.  */\n+\n+/* Bivs are recognized by `basic_induction_var';\n+   Givs by `general_induct_var'.  */\n+\n+/* An enum for the two different types of givs, those that are used\n+   as memory addresses and those that are calculated into registers.  */\n+enum g_types { DEST_ADDR, DEST_REG };\n+\n+/* A `struct induction' is created for every instruction that sets\n+   an induction variable (either a biv or a giv).  */\n+\n+struct induction\n+{\n+  rtx insn;\t\t\t/* The insn that sets a biv or giv */\n+  rtx new_reg;\t\t\t/* New register, containing strength reduced\n+\t\t\t\t   version of this giv.  */\n+  rtx src_reg;\t\t\t/* Biv from which this giv is computed.\n+\t\t\t\t   (If this is a biv, then this is the biv.) */\n+  enum g_types giv_type;\t/* Indicate whether DEST_ADDR or DEST_REG */\n+  rtx dest_reg;\t\t\t/* Destination register for insn: this is the\n+\t\t\t\t   register which was the biv or giv.\n+\t\t\t\t   For a biv, this equals src_reg.\n+\t\t\t\t   For a DEST_ADDR type giv, this is 0.  */\n+  rtx *location;\t\t/* Place in the insn where this giv occurs.\n+\t\t\t\t   If GIV_TYPE is DEST_REG, this is 0.  */\n+  enum machine_mode mode;\t/* The mode of this biv or giv */\n+  enum machine_mode mem_mode;\t/* For DEST_ADDR, mode of the memory object. */\n+  rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n+  rtx add_val;\t\t\t/* Additive constant for that product.  */\n+  int benefit;\t\t\t/* Gain from eliminating this insn.  */\n+  rtx final_value;\t\t/* If the giv is used outside the loop, and its\n+\t\t\t\t   final value could be calculated, it is put\n+\t\t\t\t   here, and the giv is made replaceable.  Set\n+\t\t\t\t   the giv to this value before the loop.  */\n+  unsigned replaceable : 1;\t/* 1 if we can substitute the strength-reduced\n+\t\t\t\t   variable for the original variable.\n+\t\t\t\t   0 means they must be kept separate and the\n+\t\t\t\t   new one must be copied into the old pseudo\n+\t\t\t\t   reg each time the old one is set.  */\n+  unsigned not_replaceable : 1;\t/* Used to prevent duplicating work.  This is\n+\t\t\t\t   1 if we know that the giv definitely can\n+\t\t\t\t   not be made replaceable, in which case we\n+\t\t\t\t   don't bother checking the variable again\n+\t\t\t\t   even if further info is available.\n+\t\t\t\t   Both this and the above can be zero.  */\n+  unsigned ignore : 1;\t\t/* 1 prohibits further processing of giv */\n+  unsigned always_computable : 1;/* 1 if this set occurs each iteration */\n+  unsigned cant_derive : 1;\t/* For giv's, 1 if this giv cannot derive\n+\t\t\t\t   another giv.  This occurs in many cases\n+\t\t\t\t   where a giv's lifetime spans an update to\n+\t\t\t\t   a biv. */\n+  unsigned combined_with : 1;\t/* 1 if this giv has been combined with.  It\n+\t\t\t\t   then cannot combine with any other giv.  */\n+  unsigned maybe_dead : 1;\t/* 1 if this giv might be dead.  In that case,\n+\t\t\t\t   we won't use it to eliminate a biv, it\n+\t\t\t\t   would probably lose. */\n+  int lifetime;\t\t\t/* Length of life of this giv */\n+  int times_used;\t\t/* # times this giv is used. */\n+  rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n+\t\t\t\t   subtracted from add_val when this giv\n+\t\t\t\t   derives another.  This occurs when the\n+\t\t\t\t   giv spans a biv update by incrementation. */\n+  struct induction *next_iv;\t/* For givs, links together all givs that are\n+\t\t\t\t   based on the same biv.  For bivs, links\n+\t\t\t\t   together all biv entries that refer to the\n+\t\t\t\t   same biv register.  */\n+  struct induction *same;\t/* If this giv has been combined with another\n+\t\t\t\t   giv, this points to the base giv.  The base\n+\t\t\t\t   giv will have COMBINED_WITH non-zero.  */\n+  int const_adjust;\t\t/* Used by loop unrolling, when an address giv\n+\t\t\t\t   is split, and a constant is eliminated from\n+\t\t\t\t   the address, the -constant is stored here\n+\t\t\t\t   for later use. */\n+};\n+\n+/* A `struct iv_class' is created for each biv.  */\n+\n+struct iv_class {\n+  int regno;\t\t\t/* Pseudo reg which is the biv.  */\n+  int biv_count;\t\t/* Number of insns setting this reg.  */\n+  struct induction *biv;\t/* List of all insns that set this reg.  */\n+  int giv_count;\t\t/* Number of DEST_REG givs computed from this\n+\t\t\t\t   biv.  The resulting count is only used in\n+\t\t\t\t   check_dbra_loop.  */\n+  struct induction *giv;\t/* List of all insns that compute a giv\n+\t\t\t\t   from this reg.  */\n+  int total_benefit;\t\t/* Sum of BENEFITs of all those givs */\n+  rtx initial_value;\t\t/* Value of reg at loop start */\n+  rtx initial_test;\t\t/* Test performed on BIV before loop */\n+  struct iv_class *next;\t/* Links all class structures together */\n+  rtx init_insn;\t\t/* insn which intializes biv, 0 if none. */\n+  rtx init_set;\t\t\t/* SET of INIT_INSN, if any. */\n+  unsigned incremented : 1;\t/* 1 if somewhere incremented/decremented */\n+  unsigned eliminable : 1;\t/* 1 if plausible candidate for elimination. */\n+  unsigned nonneg : 1;\t\t/* 1 if we added a REG_NONNEG note for this. */\n+  unsigned reversed : 1;\t/* 1 if we reversed the loop that this\n+\t\t\t\t   biv controls. */\n+};\n+\n+/* Definitions used by the basic induction variable discovery code.  */\n+enum iv_mode { UNKNOWN_INDUCT, BASIC_INDUCT, NOT_BASIC_INDUCT,\n+\t\t GENERAL_INDUCT };\n+\n+/* Variables declared in loop.c, but also needed in unroll.c.  */\n+\n+extern int *uid_luid;\n+extern int max_uid_for_loop;\n+extern int *uid_loop_num;\n+extern int *loop_outer_loop;\n+extern rtx *loop_number_exit_labels;\n+extern unsigned long loop_n_iterations;\n+extern int max_reg_before_loop;\n+\n+extern FILE *loop_dump_stream;\n+\n+extern enum iv_mode *reg_iv_type;\n+extern struct induction **reg_iv_info;\n+extern struct iv_class **reg_biv_class;\n+extern struct iv_class *loop_iv_list;\n+\n+/* Forward declarations for non-static functions declared in loop.c and\n+   unroll.c.  */\n+int invariant_p ();\n+rtx get_condition_for_loop ();\n+void emit_iv_add_mult ();\n+\n+/* Variables declared in stmt.c but also needed in loop.c.  */\n+\n+extern union tree_node **loop_number_first_block;\n+extern union tree_node **loop_number_last_block;\n+extern int *loop_number_block_level;\n+\n+/* Forward declarations for non-static functions declared in stmt.c.  */\n+void find_loop_tree_blocks ();\n+void unroll_block_trees ();\n+\n+void unroll_loop ();\n+rtx biv_total_increment ();\n+unsigned long loop_iterations ();\n+rtx final_biv_value ();\n+rtx final_giv_value ();\n+void emit_unrolled_add ();"}]}