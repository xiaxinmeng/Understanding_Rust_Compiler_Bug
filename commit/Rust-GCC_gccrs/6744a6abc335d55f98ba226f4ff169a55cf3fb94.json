{"sha": "6744a6abc335d55f98ba226f4ff169a55cf3fb94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0NGE2YWJjMzM1ZDU1Zjk4YmEyMjZmNGZmMTY5YTU1Y2YzZmI5NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-11-29T10:32:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-11-29T10:32:08Z"}, "message": "cgraph.c (same_body_alias_1): Break out of\n\n\n\t* cgraph.c (same_body_alias_1): Break out of\n\t(same_body_alias): ... here; remove comdat check; it is handled\n\tin cp already.\n\t(cgraph_add_thunk): New.\n\t(dump_cgraph_node): Dump aliases and thunks.\n\t* cgraph.h (cgraph_thunk_info): New structure.\n\t(struct cgraph_node): Add thunk info.\n\t(cgraph_add_thunk): New.\n\t* cgraphunit.c (cgraph_emit_thunks): Remove.\n\t(cgraph_finalize_compilation_unit): Do not call cgraph_emit_thunks.\n\t(assemble_thunk): New function.\n\t(cgraph_expand_function): Handle thunks.\n\t(thunk_adjust): New.\n\t(init_lowered_empty_function): New.\n\t* optimize.c (maybe_clone_body): Emit thunks associated to alias.\n\t* Make-lang.in (method.o): Add dependency on gimple.h.\n\t* method.c: Include gimple.h\n\t(make_alias_for_thunk): Use same body alias instead of assemble_alias.\n\t(use_thunk): Drop codegen; use cgraph_add_thunk; gimplify\n\tgeneric thunks.\n\t* semantics.c (expand_or_defer_fn): Emit associated thunks.\n\t* cp-objcp-common.h (LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS): Remove.\n\t* lto-cgraph.c (lto_output_node): Stream thunk info.\n\t(input_node): Likewise.\n\t* langhooks.h (lang_hooks_for_callgraph): Remove emit_associated_thunks.\n\t* langhooks-def.h (LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS): Remove.\n\t(LANG_HOOKS_CALLGRAPH_INITIALIZER): Update.\n\t* i386.c (x86_output_mi_thunk): Make output prettier.\n\nFrom-SVN: r154736", "tree": {"sha": "2260e6f71c9022e13476588b282bc487939fa1e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2260e6f71c9022e13476588b282bc487939fa1e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6744a6abc335d55f98ba226f4ff169a55cf3fb94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6744a6abc335d55f98ba226f4ff169a55cf3fb94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6744a6abc335d55f98ba226f4ff169a55cf3fb94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6744a6abc335d55f98ba226f4ff169a55cf3fb94/comments", "author": null, "committer": null, "parents": [{"sha": "e55690913ecef32cb80d5f169a9aa50fd5ae4a98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e55690913ecef32cb80d5f169a9aa50fd5ae4a98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e55690913ecef32cb80d5f169a9aa50fd5ae4a98"}], "stats": {"total": 785, "additions": 557, "deletions": 228}, "files": [{"sha": "aedf2aef8e84b22ce329a50533e2aab787e35de0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -1,3 +1,27 @@\n+2009-11-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (same_body_alias_1): Break out of\n+\t(same_body_alias): ... here; remove comdat check; it is handled\n+\tin cp already.\n+\t(cgraph_add_thunk): New.\n+\t(dump_cgraph_node): Dump aliases and thunks.\n+\t* cgraph.h (cgraph_thunk_info): New structure.\n+\t(struct cgraph_node): Add thunk info.\n+\t(cgraph_add_thunk): New.\n+\t* cgraphunit.c (cgraph_emit_thunks): Remove.\n+\t(cgraph_finalize_compilation_unit): Do not call cgraph_emit_thunks.\n+\t(assemble_thunk): New function.\n+\t(cgraph_expand_function): Handle thunks.\n+\t(thunk_adjust): New.\n+\t(init_lowered_empty_function): New.\n+\t* cp-objcp-common.h (LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS): Remove.\n+\t* lto-cgraph.c (lto_output_node): Stream thunk info.\n+\t(input_node): Likewise.\n+\t* langhooks.h (lang_hooks_for_callgraph): Remove emit_associated_thunks.\n+\t* langhooks-def.h (LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS): Remove.\n+\t(LANG_HOOKS_CALLGRAPH_INITIALIZER): Update.\n+\t* i386.c (x86_output_mi_thunk): Make output prettier.\n+\n 2009-11-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/42183"}, {"sha": "651618c4232782c4faf20c1239fcd6756f51887e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -85,6 +85,7 @@ The callgraph:\n #include \"tree-flow.h\"\n #include \"value-prof.h\"\n #include \"except.h\"\n+#include \"diagnostic.h\"\n \n static void cgraph_node_remove_callers (struct cgraph_node *node);\n static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n@@ -507,29 +508,15 @@ cgraph_node (tree decl)\n   return node;\n }\n \n-/* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n-   Same body aliases are output whenever the body of DECL is output,\n-   and cgraph_node (ALIAS) transparently returns cgraph_node (DECL).  */\n+/* Mark ALIAS as an alias to DECL.  */\n \n-bool\n-cgraph_same_body_alias (tree alias, tree decl)\n+static struct cgraph_node *\n+cgraph_same_body_alias_1 (tree alias, tree decl)\n {\n   struct cgraph_node key, *alias_node, *decl_node, **slot;\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   gcc_assert (TREE_CODE (alias) == FUNCTION_DECL);\n-  gcc_assert (!assembler_name_hash);\n-\n-#ifndef ASM_OUTPUT_DEF\n-  /* If aliases aren't supported by the assembler, fail.  */\n-  return false;\n-#endif\n-\n-  /* Comdat same body aliases are only supported when comdat groups\n-     are supported and the symbols are weak.  */\n-  if (DECL_ONE_ONLY (decl) && (!HAVE_COMDAT_GROUP || !DECL_WEAK (decl)))\n-    return false;\n-\n   decl_node = cgraph_node (decl);\n \n   key.decl = alias;\n@@ -538,7 +525,7 @@ cgraph_same_body_alias (tree alias, tree decl)\n \n   /* If the cgraph_node has been already created, fail.  */\n   if (*slot)\n-    return false;\n+    return NULL;\n \n   alias_node = cgraph_allocate_node ();\n   alias_node->decl = alias;\n@@ -548,9 +535,56 @@ cgraph_same_body_alias (tree alias, tree decl)\n   if (decl_node->same_body)\n     decl_node->same_body->previous = alias_node;\n   alias_node->next = decl_node->same_body;\n+  alias_node->thunk.alias = decl;\n   decl_node->same_body = alias_node;\n   *slot = alias_node;\n-  return true;\n+  return alias_node;\n+}\n+\n+/* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n+   Same body aliases are output whenever the body of DECL is output,\n+   and cgraph_node (ALIAS) transparently returns cgraph_node (DECL).   */\n+\n+bool\n+cgraph_same_body_alias (tree alias, tree decl)\n+{\n+#ifndef ASM_OUTPUT_DEF\n+  /* If aliases aren't supported by the assembler, fail.  */\n+  return false;\n+#endif\n+\n+  /*gcc_assert (!assembler_name_hash);*/\n+\n+  return cgraph_same_body_alias_1 (alias, decl) != NULL;\n+}\n+\n+void\n+cgraph_add_thunk (tree alias, tree decl, bool this_adjusting,\n+\t\t  HOST_WIDE_INT fixed_offset, HOST_WIDE_INT virtual_value,\n+\t\t  tree virtual_offset,\n+\t\t  tree real_alias)\n+{\n+  struct cgraph_node *node = cgraph_get_node (alias);\n+\n+  if (node)\n+    {\n+      gcc_assert (node->local.finalized);\n+      gcc_assert (!node->same_body);\n+      cgraph_remove_node (node);\n+    }\n+  \n+  node = cgraph_same_body_alias_1 (alias, decl);\n+  gcc_assert (node);\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (!virtual_offset\n+  \t      || tree_int_cst_equal (virtual_offset, size_int (virtual_value)));\n+#endif\n+  node->thunk.fixed_offset = fixed_offset;\n+  node->thunk.this_adjusting = this_adjusting;\n+  node->thunk.virtual_value = virtual_value;\n+  node->thunk.virtual_offset_p = virtual_offset != NULL;\n+  node->thunk.alias = real_alias;\n+  node->thunk.thunk_p = true;\n }\n \n /* Returns the cgraph node assigned to DECL or NULL if no cgraph node\n@@ -1646,6 +1680,27 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \tfprintf(f, \"(can throw external) \");\n     }\n   fprintf (f, \"\\n\");\n+\n+  if (node->same_body)\n+    {\n+      struct cgraph_node *n;\n+      fprintf (f, \"  aliases & thunks:\");\n+      for (n = node->same_body; n; n = n->next)\n+        {\n+          fprintf (f, \" %s/%i\", cgraph_node_name (n), n->uid);\n+\t  if (n->thunk.thunk_p)\n+\t    {\n+\t      fprintf (f, \" (thunk of %s fixed ofset %i virtual value %i has \"\n+\t\t       \"virtual offset %i\",\n+\t      \t       lang_hooks.decl_printable_name (n->thunk.alias, 2),\n+\t\t       (int)n->thunk.fixed_offset,\n+\t\t       (int)n->thunk.virtual_value,\n+\t\t       (int)n->thunk.virtual_offset_p);\n+\t      fprintf (f, \")\");\n+\t    }\n+\t}\n+      fprintf (f, \"\\n\");\n+    }\n }\n \n "}, {"sha": "1017176ff3ff4f6c62b3ac81b7419952083f70f2", "filename": "gcc/cgraph.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -69,6 +69,19 @@ struct GTY(()) inline_summary\n   int time_inlining_benefit;\n };\n \n+/* Information about thunk, used only for same body aliases.  */\n+\n+struct GTY(()) cgraph_thunk_info {\n+  /* Information about the thunk.  */\n+  HOST_WIDE_INT fixed_offset;\n+  HOST_WIDE_INT virtual_value;\n+  tree alias;\n+  bool this_adjusting;\n+  bool virtual_offset_p;\n+  /* Set to true when alias node is thunk.  */\n+  bool thunk_p;\n+};\n+\n /* Information about the function collected locally.\n    Available after function is analyzed.  */\n \n@@ -184,8 +197,8 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   struct cgraph_node *prev_sibling_clone;\n   struct cgraph_node *clones;\n   struct cgraph_node *clone_of;\n-  /* For normal nodes pointer to the list of alias nodes, in alias\n-     nodes pointer to the normal node.  */\n+  /* For normal nodes pointer to the list of alias and thunk nodes,\n+     in alias/thunk nodes pointer to the normal node.  */\n   struct cgraph_node *same_body;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n@@ -202,6 +215,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n   struct cgraph_clone_info clone;\n+  struct cgraph_thunk_info thunk;\n \n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n@@ -244,8 +258,8 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   unsigned alias : 1;\n   /* Set for nodes that was constructed and finalized by frontend.  */\n   unsigned finalized_by_frontend : 1;\n-  /* Set for alias nodes, same_body points to the node they are alias of\n-     and they are linked through the next/previous pointers.  */\n+  /* Set for alias and thunk nodes, same_body points to the node they are alias\n+     of and they are linked through the next/previous pointers.  */\n   unsigned same_body_alias : 1;\n };\n \n@@ -423,6 +437,7 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n struct cgraph_node * cgraph_get_node (tree);\n struct cgraph_node *cgraph_node (tree);\n bool cgraph_same_body_alias (tree, tree);\n+void cgraph_add_thunk (tree, tree, bool, HOST_WIDE_INT, HOST_WIDE_INT, tree, tree);\n void cgraph_remove_same_body_alias (struct cgraph_node *);\n struct cgraph_node *cgraph_node_for_asm (tree);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);"}, {"sha": "e3825433d87eae395254e0b47c16c1d7749262f0", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 366, "deletions": 38, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -149,6 +149,9 @@ static GTY (()) VEC(tree, gc) *static_ctors;\n /* A vector of FUNCTION_DECLs declared as static destructors.  */\n static GTY (()) VEC(tree, gc) *static_dtors;\n \n+/* Used for vtable lookup in thunk adjusting.  */\n+static GTY (()) tree vtable_entry_type;\n+\n /* When target does not have ctors and dtors, we call all constructor\n    and destructor by special initialization/destruction function\n    recognized by collect2.\n@@ -741,8 +744,13 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t    debug_gimple_stmt (stmt);\n \t\t\t    error_found = true;\n \t\t\t  }\n-\t\t\tif (!clone_of_p (cgraph_node (decl), e->callee)\n-\t\t\t    && !e->callee->global.inlined_to)\n+\t\t\tif (e->callee->same_body_alias)\n+\t\t\t  {\n+\t\t\t    error (\"edge points to same body alias:\");\n+\t\t\t    debug_tree (e->callee->decl);\n+\t\t\t  }\n+\t\t\telse if (!clone_of_p (cgraph_node (decl), e->callee)\n+\t\t\t         && !e->callee->global.inlined_to)\n \t\t\t  {\n \t\t\t    error (\"edge points to wrong declaration:\");\n \t\t\t    debug_tree (e->callee->decl);\n@@ -1034,35 +1042,6 @@ cgraph_analyze_functions (void)\n }\n \n \n-/* Emit thunks for every node in the cgraph.\n-   FIXME: We really ought to emit thunks only for functions that are needed.  */\n-\n-static void\n-cgraph_emit_thunks (void)\n-{\n-  struct cgraph_node *n, *alias;\n-\n-  for (n = cgraph_nodes; n; n = n->next)\n-    {\n-      /* Only emit thunks on functions defined in this TU.\n-\t Note that this may emit more thunks than strictly necessary.\n-\t During optimization some nodes may disappear.  It would be\n-\t nice to only emit thunks only for the functions that will be\n-\t emitted, but we cannot know that until the inliner and other\n-\t IPA passes have run (see the sequencing of the call to\n-\t cgraph_mark_functions_to_output in cgraph_optimize).  */\n-      if (n->reachable\n-\t  && !DECL_EXTERNAL (n->decl))\n-\t{\n-\t  lang_hooks.callgraph.emit_associated_thunks (n->decl);\n-\t  for (alias = n->same_body; alias; alias = alias->next)\n-\t    if (!DECL_EXTERNAL (alias->decl))\n-\t      lang_hooks.callgraph.emit_associated_thunks (alias->decl);\n-\t}\n-    }\n-}\n-\n-\n /* Analyze the whole compilation unit once it is parsed completely.  */\n \n void\n@@ -1093,10 +1072,6 @@ cgraph_finalize_compilation_unit (void)\n      remove unreachable nodes.  */\n   cgraph_analyze_functions ();\n \n-  /* Emit thunks for reachable nodes, if needed.  */\n-  if (lang_hooks.callgraph.emit_associated_thunks)\n-    cgraph_emit_thunks ();\n-\n   /* Mark alias targets necessary and emit diagnostics.  */\n   finish_aliases_1 ();\n \n@@ -1159,6 +1134,347 @@ cgraph_mark_functions_to_output (void)\n     }\n }\n \n+/* DECL is FUNCTION_DECL.  Initialize datastructures so DECL is a function\n+   in lowered gimple form.\n+   \n+   Set current_function_decl and cfun to newly constructed empty function body.\n+   return basic block in the function body.  */\n+\n+static basic_block\n+init_lowered_empty_function (tree decl)\n+{\n+  basic_block bb;\n+\n+  current_function_decl = decl;\n+  allocate_struct_function (decl, false);\n+  gimple_register_cfg_hooks ();\n+  init_empty_tree_cfg ();\n+  init_tree_ssa (cfun);\n+  init_ssa_operands ();\n+  cfun->gimple_df->in_ssa_p = true;\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+\n+  DECL_SAVED_TREE (decl) = error_mark_node;\n+  cfun->curr_properties |=\n+    (PROP_gimple_lcf | PROP_gimple_leh | PROP_cfg | PROP_referenced_vars |\n+     PROP_ssa);\n+\n+  /* Create BB for body of the function and connect it properly.  */\n+  bb = create_basic_block (NULL, (void *) 0, ENTRY_BLOCK_PTR);\n+  make_edge (ENTRY_BLOCK_PTR, bb, 0);\n+  make_edge (bb, EXIT_BLOCK_PTR, 0);\n+\n+  return bb;\n+}\n+\n+/* Adjust PTR by the constant FIXED_OFFSET, and by the vtable\n+   offset indicated by VIRTUAL_OFFSET, if that is\n+   non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and\n+   zero for a result adjusting thunk.  */\n+\n+static tree\n+thunk_adjust (gimple_stmt_iterator * bsi,\n+\t      tree ptr, bool this_adjusting,\n+\t      HOST_WIDE_INT fixed_offset, tree virtual_offset)\n+{\n+  gimple stmt;\n+  tree ret;\n+\n+  if (this_adjusting)\n+    {\n+      stmt = gimple_build_assign (ptr,\n+\t\t\t\t  fold_build2_loc (input_location,\n+\t\t\t\t\t\t   POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t   TREE_TYPE (ptr), ptr,\n+\t\t\t\t\t\t   size_int (fixed_offset)));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+    }\n+\n+  /* If there's a virtual offset, look up that value in the vtable and\n+     adjust the pointer again.  */\n+  if (virtual_offset)\n+    {\n+      tree vtabletmp;\n+      tree vtabletmp2;\n+      tree vtabletmp3;\n+      tree offsettmp;\n+\n+      if (!vtable_entry_type)\n+\t{\n+\t  tree vfunc_type = make_node (FUNCTION_TYPE);\n+\t  TREE_TYPE (vfunc_type) = integer_type_node;\n+\t  TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n+\t  layout_type (vfunc_type);\n+\n+\t  vtable_entry_type = build_pointer_type (vfunc_type);\n+\t}\n+\n+      vtabletmp =\n+\tcreate_tmp_var (build_pointer_type\n+\t\t\t(build_pointer_type (vtable_entry_type)), \"vptr\");\n+\n+      /* The vptr is always at offset zero in the object.  */\n+      stmt = gimple_build_assign (vtabletmp,\n+\t\t\t\t  build1 (NOP_EXPR, TREE_TYPE (vtabletmp),\n+\t\t\t\t\t  ptr));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+      mark_symbols_for_renaming (stmt);\n+      find_referenced_vars_in (stmt);\n+\n+      /* Form the vtable address.  */\n+      vtabletmp2 = create_tmp_var (TREE_TYPE (TREE_TYPE (vtabletmp)),\n+\t\t\t\t   \"vtableaddr\");\n+      stmt = gimple_build_assign (vtabletmp2,\n+\t\t\t\t  build1 (INDIRECT_REF,\n+\t\t\t\t\t  TREE_TYPE (vtabletmp2), vtabletmp));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+      mark_symbols_for_renaming (stmt);\n+      find_referenced_vars_in (stmt);\n+\n+      /* Find the entry with the vcall offset.  */\n+      stmt = gimple_build_assign (vtabletmp2,\n+\t\t\t\t  fold_build2_loc (input_location,\n+\t\t\t\t\t\t   POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t   TREE_TYPE (vtabletmp2),\n+\t\t\t\t\t\t   vtabletmp2,\n+\t\t\t\t\t\t   fold_convert (sizetype,\n+\t\t\t\t\t\t\t\t virtual_offset)));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Get the offset itself.  */\n+      vtabletmp3 = create_tmp_var (TREE_TYPE (TREE_TYPE (vtabletmp2)),\n+\t\t\t\t   \"vcalloffset\");\n+      stmt = gimple_build_assign (vtabletmp3,\n+\t\t\t\t  build1 (INDIRECT_REF,\n+\t\t\t\t\t  TREE_TYPE (vtabletmp3),\n+\t\t\t\t\t  vtabletmp2));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+      mark_symbols_for_renaming (stmt);\n+      find_referenced_vars_in (stmt);\n+\n+      /* Cast to sizetype.  */\n+      offsettmp = create_tmp_var (sizetype, \"offset\");\n+      stmt = gimple_build_assign (offsettmp, fold_convert (sizetype, vtabletmp3));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+      mark_symbols_for_renaming (stmt);\n+      find_referenced_vars_in (stmt);\n+\n+      /* Adjust the `this' pointer.  */\n+      ptr = fold_build2_loc (input_location,\n+\t\t\t     POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t\t     offsettmp);\n+    }\n+\n+  if (!this_adjusting)\n+    /* Adjust the pointer by the constant.  */\n+    {\n+      tree ptrtmp;\n+\n+      if (TREE_CODE (ptr) == VAR_DECL)\n+        ptrtmp = ptr;\n+      else\n+        {\n+          ptrtmp = create_tmp_var (TREE_TYPE (ptr), \"ptr\");\n+          stmt = gimple_build_assign (ptrtmp, ptr);\n+\t  gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\t  mark_symbols_for_renaming (stmt);\n+\t  find_referenced_vars_in (stmt);\n+\t}\n+      ptr = fold_build2_loc (input_location,\n+\t\t\t     POINTER_PLUS_EXPR, TREE_TYPE (ptrtmp), ptrtmp,\n+\t\t\t     size_int (fixed_offset));\n+    }\n+\n+  /* Emit the statement and gimplify the adjustment expression.  */\n+  ret = create_tmp_var (TREE_TYPE (ptr), \"adjusted_this\");\n+  stmt = gimple_build_assign (ret, ptr);\n+  mark_symbols_for_renaming (stmt);\n+  find_referenced_vars_in (stmt);\n+  gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+  return ret;\n+}\n+\n+/* Produce assembler for thunk NODE.  */\n+\n+static void\n+assemble_thunk (struct cgraph_node *node)\n+{\n+  bool this_adjusting = node->thunk.this_adjusting;\n+  HOST_WIDE_INT fixed_offset = node->thunk.fixed_offset;\n+  HOST_WIDE_INT virtual_value = node->thunk.virtual_value;\n+  tree virtual_offset = NULL;\n+  tree alias = node->thunk.alias;\n+  tree thunk_fndecl = node->decl;\n+  tree a = DECL_ARGUMENTS (thunk_fndecl);\n+\n+  current_function_decl = thunk_fndecl;\n+\n+  if (this_adjusting\n+      && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n+\t\t\t\t\t      virtual_value, alias))\n+    {\n+      const char *fnname;\n+      tree fn_block;\n+      \n+      DECL_RESULT (thunk_fndecl)\n+\t= build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n+\t\t      RESULT_DECL, 0, integer_type_node);\n+      fnname = IDENTIFIER_POINTER (DECL_NAME (thunk_fndecl));\n+\n+      /* The back end expects DECL_INITIAL to contain a BLOCK, so we\n+\t create one.  */\n+      fn_block = make_node (BLOCK);\n+      BLOCK_VARS (fn_block) = a;\n+      DECL_INITIAL (thunk_fndecl) = fn_block;\n+      init_function_start (thunk_fndecl);\n+      cfun->is_thunk = 1;\n+      assemble_start_function (thunk_fndecl, fnname);\n+\n+      targetm.asm_out.output_mi_thunk (asm_out_file, thunk_fndecl,\n+\t\t\t\t       fixed_offset, virtual_value, alias);\n+\n+      assemble_end_function (thunk_fndecl, fnname);\n+      init_insn_lengths ();\n+      free_after_compilation (cfun);\n+      set_cfun (NULL);\n+      TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n+    }\n+  else\n+    {\n+      tree restype;\n+      basic_block bb, then_bb, else_bb, return_bb;\n+      gimple_stmt_iterator bsi;\n+      int nargs = 0;\n+      tree arg;\n+      int i;\n+      tree resdecl;\n+      tree restmp = NULL;\n+      VEC(tree, heap) *vargs;\n+\n+      gimple call;\n+      gimple ret;\n+\n+      DECL_IGNORED_P (thunk_fndecl) = 1;\n+      bitmap_obstack_initialize (NULL);\n+\n+      if (node->thunk.virtual_offset_p)\n+        virtual_offset = size_int (virtual_value);\n+\n+      /* Build the return declaration for the function.  */\n+      restype = TREE_TYPE (TREE_TYPE (thunk_fndecl));\n+      if (DECL_RESULT (thunk_fndecl) == NULL_TREE)\n+\t{\n+\t  resdecl = build_decl (input_location, RESULT_DECL, 0, restype);\n+\t  DECL_ARTIFICIAL (resdecl) = 1;\n+\t  DECL_IGNORED_P (resdecl) = 1;\n+\t  DECL_RESULT (thunk_fndecl) = resdecl;\n+\t}\n+      else\n+\tresdecl = DECL_RESULT (thunk_fndecl);\n+\n+      bb = then_bb = else_bb = return_bb = init_lowered_empty_function (thunk_fndecl);\n+\n+      bsi = gsi_start_bb (bb);\n+\n+      /* Build call to the function being thunked.  */\n+      if (!VOID_TYPE_P (restype))\n+\t{\n+\t  if (!is_gimple_reg_type (restype))\n+\t    {\n+\t      restmp = resdecl;\n+\t      cfun->local_decls = tree_cons (NULL_TREE, restmp, cfun->local_decls);\n+\t      BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;\n+\t    }\n+\t  else\n+            restmp = create_tmp_var_raw (restype, \"retval\");\n+\t}\n+\n+      for (arg = a; arg; arg = TREE_CHAIN (arg))\n+        nargs++;\n+      vargs = VEC_alloc (tree, heap, nargs);\n+      if (this_adjusting)\n+        VEC_quick_push (tree, vargs,\n+\t\t\tthunk_adjust (&bsi,\n+\t\t\t\t      a, 1, fixed_offset,\n+\t\t\t\t      virtual_offset));\n+      else\n+        VEC_quick_push (tree, vargs, a);\n+      for (i = 1, arg = TREE_CHAIN (a); i < nargs; i++, arg = TREE_CHAIN (arg))\n+        VEC_quick_push (tree, vargs, arg);\n+      call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n+      VEC_free (tree, heap, vargs);\n+      gimple_call_set_cannot_inline (call, true);\n+      gimple_call_set_from_thunk (call, true);\n+      if (restmp)\n+        gimple_call_set_lhs (call, restmp);\n+      gsi_insert_after (&bsi, call, GSI_NEW_STMT);\n+      mark_symbols_for_renaming (call);\n+      find_referenced_vars_in (call);\n+      update_stmt (call);\n+\n+      if (restmp && !this_adjusting)\n+        {\n+\t  tree true_label = NULL_TREE, false_label = NULL_TREE;\n+\n+\t  if (TREE_CODE (TREE_TYPE (restmp)) == POINTER_TYPE)\n+\t    {\n+\t      gimple stmt;\n+\t      /* If the return type is a pointer, we need to\n+\t\t protect against NULL.  We know there will be an\n+\t\t adjustment, because that's why we're emitting a\n+\t\t thunk.  */\n+\t      then_bb = create_basic_block (NULL, (void *) 0, bb);\n+\t      return_bb = create_basic_block (NULL, (void *) 0, then_bb);\n+\t      else_bb = create_basic_block (NULL, (void *) 0, else_bb);\n+\t      remove_edge (single_succ_edge (bb));\n+\t      true_label = gimple_block_label (then_bb);\n+\t      false_label = gimple_block_label (else_bb);\n+\t      stmt = gimple_build_cond (NE_EXPR, restmp,\n+\t      \t\t\t\tfold_convert (TREE_TYPE (restmp),\n+\t\t\t\t\t\t      integer_zero_node),\n+\t      \t\t\t        NULL_TREE, NULL_TREE);\n+\t      gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t      make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n+\t      make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n+\t      make_edge (return_bb, EXIT_BLOCK_PTR, 0);\n+\t      make_edge (then_bb, return_bb, EDGE_FALLTHRU);\n+\t      make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n+\t      bsi = gsi_last_bb (then_bb);\n+\t    }\n+\n+\t  restmp = thunk_adjust (&bsi, restmp, /*this_adjusting=*/0,\n+\t\t\t         fixed_offset, virtual_offset);\n+\t  if (true_label)\n+\t    {\n+\t      gimple stmt;\n+\t      bsi = gsi_last_bb (else_bb);\n+\t      stmt = gimple_build_assign (restmp, fold_convert (TREE_TYPE (restmp),\n+\t\t\t\t\t\t\t\tinteger_zero_node));\n+\t      gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t      bsi = gsi_last_bb (return_bb);\n+\t    }\n+\t}\n+      else\n+        gimple_call_set_tail (call, true);\n+\n+      /* Build return value.  */\n+      ret = gimple_build_return (restmp);\n+      gsi_insert_after (&bsi, ret, GSI_NEW_STMT);\n+\n+      delete_unreachable_blocks ();\n+      update_ssa (TODO_update_ssa);\n+\n+      cgraph_remove_same_body_alias (node);\n+      /* Since we want to emit the thunk, we explicitly mark its name as\n+\t referenced.  */\n+      mark_decl_referenced (thunk_fndecl);\n+      cgraph_add_new_function (thunk_fndecl, true);\n+      bitmap_obstack_release (NULL);\n+    }\n+  current_function_decl = NULL;\n+}\n+\n /* Expand function specified by NODE.  */\n \n static void\n@@ -1182,10 +1498,22 @@ cgraph_expand_function (struct cgraph_node *node)\n   current_function_decl = NULL;\n   if (node->same_body)\n     {\n-      struct cgraph_node *alias;\n+      struct cgraph_node *alias, *next;\n       bool saved_alias = node->alias;\n-      for (alias = node->same_body; alias; alias = alias->next)\n-\tassemble_alias (alias->decl, DECL_ASSEMBLER_NAME (decl));\n+      for (alias = node->same_body;\n+      \t   alias && alias->next; alias = alias->next)\n+        ;\n+      /* Walk aliases in the order they were created; it is possible that\n+         thunks reffers to the aliases made earlier.  */\n+      for (; alias; alias = next)\n+        {\n+\t  next = alias->previous;\n+\t  if (!alias->thunk.thunk_p)\n+\t    assemble_alias (alias->decl,\n+\t\t\t    DECL_ASSEMBLER_NAME (alias->thunk.alias));\n+\t  else\n+\t    assemble_thunk (alias);\n+\t}\n       node->alias = saved_alias;\n     }\n   gcc_assert (!cgraph_preserve_function_body_p (decl));"}, {"sha": "37fe24f6798491a4ddb03984db1d55044f4a85a5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -26002,7 +26002,10 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n   /* Adjust the this parameter by a fixed constant.  */\n   if (delta)\n     {\n-      xops[0] = GEN_INT (delta);\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n+         Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      bool sub = delta < 0 || delta == 128;\n+      xops[0] = GEN_INT (sub ? -delta : delta);\n       xops[1] = this_reg ? this_reg : this_param;\n       if (TARGET_64BIT)\n \t{\n@@ -26014,8 +26017,13 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \t      xops[0] = tmp;\n \t      xops[1] = this_param;\n \t    }\n-\t  output_asm_insn (\"add{q}\\t{%0, %1|%1, %0}\", xops);\n+\t  if (sub)\n+\t    output_asm_insn (\"sub{q}\\t{%0, %1|%1, %0}\", xops);\n+\t  else\n+\t    output_asm_insn (\"add{q}\\t{%0, %1|%1, %0}\", xops);\n \t}\n+      else if (sub)\n+\toutput_asm_insn (\"sub{l}\\t{%0, %1|%1, %0}\", xops);\n       else\n \toutput_asm_insn (\"add{l}\\t{%0, %1|%1, %0}\", xops);\n     }"}, {"sha": "ab252ea9804e41dd2bbb92ab8385e881cf308b5d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -1,3 +1,13 @@\n+2009-11-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* optimize.c (maybe_clone_body): Emit thunks associated to alias.\n+\t* Make-lang.in (method.o): Add dependency on gimple.h.\n+\t* method.c: Include gimple.h\n+\t(make_alias_for_thunk): Use same body alias instead of assemble_alias.\n+\t(use_thunk): Drop codegen; use cgraph_add_thunk; gimplify\n+\tgeneric thunks.\n+\t* semantics.c (expand_or_defer_fn): Emit associated thunks.\n+\n 2009-11-28  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/36408"}, {"sha": "ef44201bb95eade752e5f61daed65cfc5e0bba3c", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -275,7 +275,7 @@ cp/friend.o: cp/friend.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(RTL_H) toplev.h \\\n cp/init.o: cp/init.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(RTL_H) $(EXPR_H) \\\n   toplev.h except.h $(TARGET_H)\n cp/method.o: cp/method.c $(CXX_TREE_H) $(TM_H) toplev.h $(RTL_H) $(EXPR_H) \\\n-  $(TM_P_H) $(TARGET_H) $(DIAGNOSTIC_H) gt-cp-method.h\n+  $(TM_P_H) $(TARGET_H) $(DIAGNOSTIC_H) gt-cp-method.h $(GIMPLE_H)\n cp/cvt.o: cp/cvt.c $(CXX_TREE_H) $(TM_H) cp/decl.h $(FLAGS_H) toplev.h \\\n   convert.h $(TARGET_H)\n cp/search.o: cp/search.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h $(RTL_H)"}, {"sha": "1a97ad2b1190e92f31fe5c656aebbcccefd17a82", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -104,8 +104,6 @@ extern bool cp_function_decl_explicit_p (tree decl);\n \n #undef LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR\n #define LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR cxx_callgraph_analyze_expr\n-#undef LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS\n-#define LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS emit_associated_thunks\n \n #undef LANG_HOOKS_MAKE_TYPE\n #define LANG_HOOKS_MAKE_TYPE cxx_make_type"}, {"sha": "cda7ed3b863487001f40e27755c49e64d1c65af0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 14, "deletions": 150, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"diagnostic.h\"\n #include \"cgraph.h\"\n+#include \"gimple.h\"\n \n /* Various flags to control the mangling process.  */\n \n@@ -58,7 +59,6 @@ enum mangling_flags\n \n typedef enum mangling_flags mangling_flags;\n \n-static tree thunk_adjust (tree, bool, HOST_WIDE_INT, tree);\n static void do_build_assign_ref (tree);\n static void do_build_copy_constructor (tree);\n static tree synthesize_exception_spec (tree, tree (*) (tree, void *), void *);\n@@ -205,56 +205,6 @@ finish_thunk (tree thunk)\n   SET_DECL_ASSEMBLER_NAME (thunk, name);\n }\n \n-/* Adjust PTR by the constant FIXED_OFFSET, and by the vtable\n-   offset indicated by VIRTUAL_OFFSET, if that is\n-   non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and\n-   zero for a result adjusting thunk.  */\n-\n-static tree\n-thunk_adjust (tree ptr, bool this_adjusting,\n-\t      HOST_WIDE_INT fixed_offset, tree virtual_offset)\n-{\n-  if (this_adjusting)\n-    /* Adjust the pointer by the constant.  */\n-    ptr = fold_build2_loc (input_location,\n-\t\t       POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t       size_int (fixed_offset));\n-\n-  /* If there's a virtual offset, look up that value in the vtable and\n-     adjust the pointer again.  */\n-  if (virtual_offset)\n-    {\n-      tree vtable;\n-\n-      ptr = save_expr (ptr);\n-      /* The vptr is always at offset zero in the object.  */\n-      vtable = build1 (NOP_EXPR,\n-\t\t       build_pointer_type (build_pointer_type\n-\t\t\t\t\t   (vtable_entry_type)),\n-\t\t       ptr);\n-      /* Form the vtable address.  */\n-      vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n-      /* Find the entry with the vcall offset.  */\n-      vtable = fold_build2_loc (input_location,\n-\t\t\t    POINTER_PLUS_EXPR, TREE_TYPE (vtable), vtable,\n-\t\t\t    fold_convert (sizetype, virtual_offset));\n-      /* Get the offset itself.  */\n-      vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n-      /* Adjust the `this' pointer.  */\n-      ptr = fold_build2_loc (input_location,\n-\t\t\t POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t\t fold_convert (sizetype, vtable));\n-    }\n-\n-  if (!this_adjusting)\n-    /* Adjust the pointer by the constant.  */\n-    ptr = fold_build2_loc (input_location,\n-\t\t       POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t       size_int (fixed_offset));\n-\n-  return ptr;\n-}\n-\n static GTY (()) int thunk_labelno;\n \n /* Create a static alias to function.  */\n@@ -303,7 +253,11 @@ make_alias_for_thunk (tree function)\n   alias = make_alias_for (function, get_identifier (buf));\n \n   if (!flag_syntax_only)\n-    assemble_alias (alias, DECL_ASSEMBLER_NAME (function));\n+    {\n+      bool ok = cgraph_same_body_alias (alias, function);\n+      DECL_ASSEMBLER_NAME (function);\n+      gcc_assert (ok);\n+    }\n \n   return alias;\n }\n@@ -416,42 +370,15 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n     }\n   a = nreverse (t);\n   DECL_ARGUMENTS (thunk_fndecl) = a;\n-\n-  if (this_adjusting\n-      && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n-\t\t\t\t\t      virtual_value, alias))\n-    {\n-      const char *fnname;\n-      tree fn_block;\n-      \n-      current_function_decl = thunk_fndecl;\n-      DECL_RESULT (thunk_fndecl)\n-\t= build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n-\t\t      RESULT_DECL, 0, integer_type_node);\n-      fnname = IDENTIFIER_POINTER (DECL_NAME (thunk_fndecl));\n-      /* The back end expects DECL_INITIAL to contain a BLOCK, so we\n-\t create one.  */\n-      fn_block = make_node (BLOCK);\n-      BLOCK_VARS (fn_block) = a;\n-      DECL_INITIAL (thunk_fndecl) = fn_block;\n-      init_function_start (thunk_fndecl);\n-      cfun->is_thunk = 1;\n-      assemble_start_function (thunk_fndecl, fnname);\n-\n-      targetm.asm_out.output_mi_thunk (asm_out_file, thunk_fndecl,\n-\t\t\t\t       fixed_offset, virtual_value, alias);\n-\n-      assemble_end_function (thunk_fndecl, fnname);\n-      init_insn_lengths ();\n-      free_after_compilation (cfun);\n-      current_function_decl = 0;\n-      set_cfun (NULL);\n-      TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n-    }\n-  else\n+  TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n+  cgraph_add_thunk (thunk_fndecl, function,\n+\t\t    this_adjusting, fixed_offset, virtual_value,\n+\t\t    virtual_offset, alias);\n+\n+  if (!this_adjusting\n+      || !targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n+\t\t\t\t\t       virtual_value, alias))\n     {\n-      int i;\n-      tree *argarray = (tree *) alloca (list_length (a) * sizeof (tree));\n       /* If this is a covariant thunk, or we don't have the necessary\n \t code for efficient thunks, generate a thunk function that\n \t just makes a call to the real function.  Unfortunately, this\n@@ -460,69 +387,6 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       if (varargs_function_p (function))\n \terror (\"generic thunk code fails for method %q#D which uses %<...%>\",\n \t       function);\n-\n-      DECL_RESULT (thunk_fndecl) = NULL_TREE;\n-\n-      start_preparsed_function (thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n-      /* We don't bother with a body block for thunks.  */\n-\n-      /* There's no need to check accessibility inside the thunk body.  */\n-      push_deferring_access_checks (dk_no_check);\n-\n-      t = a;\n-      if (this_adjusting)\n-\tt = thunk_adjust (t, /*this_adjusting=*/1,\n-\t\t\t  fixed_offset, virtual_offset);\n-\n-      /* Build up the call to the real function.  */\n-      argarray[0] = t;\n-      for (i = 1, a = TREE_CHAIN (a); a; a = TREE_CHAIN (a), i++)\n-\targarray[i] = a;\n-      t = build_call_a (alias, i, argarray);\n-      CALL_FROM_THUNK_P (t) = 1;\n-      CALL_CANNOT_INLINE_P (t) = 1;\n-\n-      if (VOID_TYPE_P (TREE_TYPE (t)))\n-\tfinish_expr_stmt (t);\n-      else\n-\t{\n-\t  if (!this_adjusting)\n-\t    {\n-\t      tree cond = NULL_TREE;\n-\n-\t      if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n-\t\t{\n-\t\t  /* If the return type is a pointer, we need to\n-\t\t     protect against NULL.  We know there will be an\n-\t\t     adjustment, because that's why we're emitting a\n-\t\t     thunk.  */\n-\t\t  t = save_expr (t);\n-\t\t  cond = cp_convert (boolean_type_node, t);\n-\t\t}\n-\n-\t      t = thunk_adjust (t, /*this_adjusting=*/0,\n-\t\t\t\tfixed_offset, virtual_offset);\n-\t      if (cond)\n-\t\tt = build3 (COND_EXPR, TREE_TYPE (t), cond, t,\n-\t\t\t    cp_convert (TREE_TYPE (t), integer_zero_node));\n-\t    }\n-\t  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (t)))\n-\t    t = build_cplus_new (TREE_TYPE (t), t);\n-\t  finish_return_stmt (t);\n-\t}\n-\n-      /* Since we want to emit the thunk, we explicitly mark its name as\n-\t referenced.  */\n-      mark_decl_referenced (thunk_fndecl);\n-\n-      /* But we don't want debugging information about it.  */\n-      DECL_IGNORED_P (thunk_fndecl) = 1;\n-\n-      /* Re-enable access control.  */\n-      pop_deferring_access_checks ();\n-\n-      thunk_fndecl = finish_function (0);\n-      cgraph_add_new_function (thunk_fndecl, false);\n     }\n \n   pop_from_top_level ();"}, {"sha": "838a7305a710b5d51b6207b535fb6e9b072563c4", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -250,7 +250,10 @@ maybe_clone_body (tree fn)\n \t  && DECL_INTERFACE_KNOWN (fns[0])\n \t  && !DECL_ONE_ONLY (fns[0])\n \t  && cgraph_same_body_alias (clone, fns[0]))\n-\talias = true;\n+\t{\n+\t  alias = true;\n+\t  emit_associated_thunks (clone);\n+\t}\n \n       /* Build the delete destructor by calling complete destructor\n          and delete function.  */"}, {"sha": "0a1a547d13dc075224bb7e51777c1bbed7a7c43e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -3445,6 +3445,7 @@ expand_or_defer_fn (tree fn)\n \n       /* Expand or defer, at the whim of the compilation unit manager.  */\n       cgraph_finalize_function (fn, function_depth > 1);\n+      emit_associated_thunks (fn);\n \n       function_depth--;\n     }"}, {"sha": "e5a6171f0678569420982ac53458492c6763eb34", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -3172,6 +3172,7 @@ ira (FILE *f)\n \n   ira_assert (current_loops == NULL);\n   flow_loops_find (&ira_loops);\n+  record_loop_exits ();\n   current_loops = &ira_loops;\n \n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n@@ -3215,6 +3216,7 @@ ira (FILE *f)\n \t  df_analyze ();\n \n \t  flow_loops_find (&ira_loops);\n+\t  record_loop_exits ();\n \t  current_loops = &ira_loops;\n \n \t  setup_allocno_assignment_flags ();"}, {"sha": "f6ef3f10fc8985c04e7a96911d9ea45c9fa1c2f0", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -126,11 +126,9 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n }\n \n #define LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR lhd_callgraph_analyze_expr\n-#define LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS NULL\n \n #define LANG_HOOKS_CALLGRAPH_INITIALIZER { \\\n-  LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR, \\\n-  LANG_HOOKS_CALLGRAPH_EMIT_ASSOCIATED_THUNKS, \\\n+  LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR \\\n }\n \n /* Hooks for tree gimplification.  */"}, {"sha": "faac14af859d5108159c28b894475f2b070c8307", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -49,9 +49,6 @@ struct lang_hooks_for_callgraph\n   /* The node passed is a language-specific tree node.  If its contents\n      are relevant to use of other declarations, mark them.  */\n   tree (*analyze_expr) (tree *, int *);\n-\n-  /* Emit thunks associated to function.  */\n-  void (*emit_associated_thunks) (tree);\n };\n \n /* The following hooks are used by tree-dump.c.  */"}, {"sha": "309a1e6e96426a5fdb579fe28c7b1f3f1611838f", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -317,6 +317,21 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t{\n \t  lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n \t\t\t\t    alias->decl);\n+\t  if (alias->thunk.thunk_p)\n+\t    {\n+              lto_output_uleb128_stream\n+\t         (ob->main_stream,\n+\t      \t  1 + (alias->thunk.this_adjusting != 0) * 2\n+\t\t  + (alias->thunk.virtual_offset_p != 0) * 4);\n+\t      lto_output_uleb128_stream (ob->main_stream,\n+\t      \t\t\t\t alias->thunk.fixed_offset);\n+\t      lto_output_uleb128_stream (ob->main_stream,\n+\t      \t\t\t\t alias->thunk.virtual_value);\n+\t      lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n+\t\t\t\t\talias->thunk.alias);\n+\t    }\n+\t  else\n+            lto_output_uleb128_stream (ob->main_stream, 0);\n \t  alias = alias->previous;\n \t}\n       while (alias);\n@@ -575,9 +590,24 @@ input_node (struct lto_file_decl_data *file_data,\n   while (same_body_count-- > 0)\n     {\n       tree alias_decl;\n+      int type;\n       decl_index = lto_input_uleb128 (ib);\n       alias_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-      cgraph_same_body_alias (alias_decl, fn_decl);\n+      type = lto_input_uleb128 (ib);\n+      if (!type)\n+        cgraph_same_body_alias (alias_decl, fn_decl);\n+      else\n+        {\n+\t  HOST_WIDE_INT fixed_offset = lto_input_uleb128 (ib);\n+\t  HOST_WIDE_INT virtual_value = lto_input_uleb128 (ib);\n+\t  tree real_alias;\n+\t  decl_index = lto_input_uleb128 (ib);\n+\t  real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+\t  cgraph_add_thunk (alias_decl, fn_decl, type & 2, fixed_offset,\n+\t  \t\t    virtual_value,\n+\t\t\t    (type & 4) ? size_int (virtual_value) : NULL_TREE,\n+\t\t\t    real_alias);\n+\t}\n     }\n   return node;\n }"}, {"sha": "10baf62b0c0bf6d158a6d011ec25d8dd490cd428", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6744a6abc335d55f98ba226f4ff169a55cf3fb94/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=6744a6abc335d55f98ba226f4ff169a55cf3fb94", "patch": "@@ -3832,10 +3832,6 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   (*debug_hooks->outlining_inline_function) (cg_edge->callee->decl);\n \n   /* Update callgraph if needed.  */\n-  if (cg_edge->callee->clone_of\n-      && !cg_edge->callee->clone_of->next_sibling_clone\n-      && !cg_edge->callee->analyzed)\n-    cgraph_remove_node (cg_edge->callee);\n   cgraph_remove_node (cg_edge->callee);\n \n   id->block = NULL_TREE;"}]}