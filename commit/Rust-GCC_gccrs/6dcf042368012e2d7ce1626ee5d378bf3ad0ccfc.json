{"sha": "6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjZjA0MjM2ODAxMmUyZDdjZTE2MjZlZTVkMzc4YmYzYWQwY2NmYw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-20T18:01:18Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-07-28T12:37:16Z"}, "message": "libstdc++: Do not over-size hashtable buckets on range insertion\n\nWe used to consider range size on insertion but on unique keys container\nnot all range values might be inserted resulting in over-sizing. In this\ncase we just consider user reservation and if none then the container will\nadapt to actually inserted elements.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/hashtable.h\n\t(_Hashtable<>(_InputIterator, _InputIterator, size_t, const _H1&,\n\tconst _H2&, const _Hash&, const _Equal&, const _ExtractKey&,\n\tconst allocator_type&, true_type)): New.\n\t(_Hashtable<>(_InputIterator, _InputIterator, size_t, const _H1&,\n\tconst _H2&, const _Hash&, const _Equal&, const _ExtractKey&,\n\tconst allocator_type&, false_type)): New.\n\t(_Hashtable<>(_InputIterator, _InputIterator, size_t, const _H1&,\n\tconst _H2&, const _Hash&, const _Equal&, const _ExtractKey&,\n\tconst allocator_type&)): Delegate to latters.\n\t(operator=(initializer_list<value_type>)): Rehash if too small.\n\t(_M_insert(_Arg&&, const _NodeGenerator&, true_type)): Remove\n\tsize_t len parameter.\n\t* include/bits/hashtable_policy.h (_Insert_base<>::_M_insert_range):\n\tDo not try to get input range distance.\n\t* testsuite/23_containers/unordered_set/cons/bucket_hint.cc: New test.\n\t* testsuite/23_containers/unordered_set/modifiers/insert.cc: New test.", "tree": {"sha": "890eb6dcaf21e33ce399cd90b97b8c3691f80502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/890eb6dcaf21e33ce399cd90b97b8c3691f80502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/comments", "author": null, "committer": null, "parents": [{"sha": "f40888fff7c4dab6d654ae4f7598f23bc472d2d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40888fff7c4dab6d654ae4f7598f23bc472d2d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40888fff7c4dab6d654ae4f7598f23bc472d2d1"}], "stats": {"total": 255, "additions": 210, "deletions": 45}, "files": [{"sha": "9d1ad59255370aaf1ec47390c0279cd376807c53", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "patch": "@@ -460,6 +460,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__hashtable_alloc(__node_alloc_type(__a))\n       { }\n \n+      template<typename _InputIterator>\n+\t_Hashtable(_InputIterator __first, _InputIterator __last,\n+\t\t   size_type __bkt_count_hint,\n+\t\t   const _H1&, const _H2&, const _Hash&,\n+\t\t   const _Equal&, const _ExtractKey&,\n+\t\t   const allocator_type&,\n+\t\t   true_type __uks);\n+\n+      template<typename _InputIterator>\n+\t_Hashtable(_InputIterator __first, _InputIterator __last,\n+\t\t   size_type __bkt_count_hint,\n+\t\t   const _H1&, const _H2&, const _Hash&,\n+\t\t   const _Equal&, const _ExtractKey&,\n+\t\t   const allocator_type&,\n+\t\t   false_type __uks);\n+\n     public:\n       // Constructor, destructor, assignment, swap\n       _Hashtable() = default;\n@@ -468,13 +484,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t const _Equal&, const _ExtractKey&,\n \t\t const allocator_type&);\n \n-      template<typename _InputIterator>\n-\t_Hashtable(_InputIterator __first, _InputIterator __last,\n-\t\t   size_type __bkt_count_hint,\n-\t\t   const _H1&, const _H2&, const _Hash&,\n-\t\t   const _Equal&, const _ExtractKey&,\n-\t\t   const allocator_type&);\n-\n       _Hashtable(const _Hashtable&);\n \n       _Hashtable(_Hashtable&&) noexcept;\n@@ -484,6 +493,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable(_Hashtable&&, const allocator_type&);\n \n       // Use delegating constructors.\n+      template<typename _InputIterator>\n+\t_Hashtable(_InputIterator __first, _InputIterator __last,\n+\t\t   size_type __bkt_count_hint,\n+\t\t   const _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t\t   const _Equal& __eq, const _ExtractKey& __exk,\n+\t\t   const allocator_type& __a)\n+\t: _Hashtable(__first, __last, __bkt_count_hint,\n+\t\t     __h1, __h2, __h, __eq, __exk, __a, __unique_keys{})\n+\t{ }\n+\n       explicit\n       _Hashtable(const allocator_type& __a)\n       : __hashtable_alloc(__node_alloc_type(__a))\n@@ -540,7 +559,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);\n \t_M_before_begin._M_nxt = nullptr;\n \tclear();\n-\tthis->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys());\n+\n+\t// We consider that all elements of __l are going to be inserted.\n+\tauto __l_bkt_count = _M_rehash_policy._M_bkt_for_elements(__l.size());\n+\n+\t// Do not shrink to keep potential user reservation.\n+\tif (_M_bucket_count < __l_bkt_count)\n+\t  rehash(__l_bkt_count);\n+\n+\tthis->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys{});\n \treturn *this;\n       }\n \n@@ -749,41 +776,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Emplace with hint, useless when keys are unique.\n       template<typename... _Args>\n \titerator\n-\t_M_emplace(const_iterator, true_type __uk, _Args&&... __args)\n-\t{ return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }\n+\t_M_emplace(const_iterator, true_type __uks, _Args&&... __args)\n+\t{ return _M_emplace(__uks, std::forward<_Args>(__args)...).first; }\n \n       template<typename... _Args>\n \titerator\n-\t_M_emplace(const_iterator, false_type, _Args&&... __args);\n+\t_M_emplace(const_iterator, false_type __uks, _Args&&... __args);\n \n       template<typename _Arg, typename _NodeGenerator>\n \tstd::pair<iterator, bool>\n-\t_M_insert(_Arg&&, const _NodeGenerator&, true_type, size_type = 1);\n+\t_M_insert(_Arg&&, const _NodeGenerator&, true_type __uks);\n \n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n \t_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,\n-\t\t  false_type __uk)\n+\t\t  false_type __uks)\n \t{\n \t  return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,\n-\t\t\t   __uk);\n+\t\t\t   __uks);\n \t}\n \n       // Insert with hint, not used when keys are unique.\n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n \t_M_insert(const_iterator, _Arg&& __arg,\n-\t\t  const _NodeGenerator& __node_gen, true_type __uk)\n+\t\t  const _NodeGenerator& __node_gen, true_type __uks)\n \t{\n \t  return\n-\t    _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;\n+\t    _M_insert(std::forward<_Arg>(__arg), __node_gen, __uks).first;\n \t}\n \n       // Insert with hint when keys are not unique.\n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n \t_M_insert(const_iterator, _Arg&&,\n-\t\t  const _NodeGenerator&, false_type);\n+\t\t  const _NodeGenerator&, false_type __uks);\n \n       size_type\n       _M_erase(true_type, const key_type&);\n@@ -1032,7 +1059,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t size_type __bkt_count_hint,\n \t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n \t\t const _Equal& __eq, const _ExtractKey& __exk,\n-\t\t const allocator_type& __a)\n+\t\t const allocator_type& __a, true_type /* __uks */)\n+      : _Hashtable(__bkt_count_hint, __h1, __h2, __h, __eq, __exk, __a)\n+      {\n+\tfor (; __f != __l; ++__f)\n+\t  this->insert(*__f);\n+      }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    template<typename _InputIterator>\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+      _Hashtable(_InputIterator __f, _InputIterator __l,\n+\t\t size_type __bkt_count_hint,\n+\t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t\t const _Equal& __eq, const _ExtractKey& __exk,\n+\t\t const allocator_type& __a, false_type /* __uks */)\n       : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)\n       {\n \tauto __nb_elems = __detail::__distance_fw(__f, __l);\n@@ -1802,8 +1847,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, true_type,\n-\t\tsize_type __n_elt)\n+      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen,\n+\t\ttrue_type /* __uks */)\n       -> pair<iterator, bool>\n       {\n \tconst key_type& __k = this->_M_extract()(__v);\n@@ -1815,7 +1860,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n \tauto __pos\n-\t  = _M_insert_unique_node(__k, __bkt, __code, __node._M_node, __n_elt);\n+\t  = _M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n \t__node._M_node = nullptr;\n \treturn { __pos, true };\n       }\n@@ -1830,7 +1875,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_insert(const_iterator __hint, _Arg&& __v,\n-\t\tconst _NodeGenerator& __node_gen, false_type)\n+\t\tconst _NodeGenerator& __node_gen,\n+\t\tfalse_type /* __uks */)\n       -> iterator\n       {\n \t// First compute the hash code so that we don't do anything if it"}, {"sha": "26ea9bf29ce3680c73883f3272cc60202a086956", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "patch": "@@ -820,28 +820,28 @@ namespace __detail\n       template<typename _InputIterator, typename _NodeGetter>\n \tvoid\n \t_M_insert_range(_InputIterator __first, _InputIterator __last,\n-\t\t\tconst _NodeGetter&, true_type);\n+\t\t\tconst _NodeGetter&, true_type __uks);\n \n       template<typename _InputIterator, typename _NodeGetter>\n \tvoid\n \t_M_insert_range(_InputIterator __first, _InputIterator __last,\n-\t\t\tconst _NodeGetter&, false_type);\n+\t\t\tconst _NodeGetter&, false_type __uks);\n \n     public:\n       __ireturn_type\n       insert(const value_type& __v)\n       {\n \t__hashtable& __h = _M_conjure_hashtable();\n \t__node_gen_type __node_gen(__h);\n-\treturn __h._M_insert(__v, __node_gen, __unique_keys());\n+\treturn __h._M_insert(__v, __node_gen, __unique_keys{});\n       }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __v)\n       {\n \t__hashtable& __h = _M_conjure_hashtable();\n \t__node_gen_type __node_gen(__h);\t\n-\treturn __h._M_insert(__hint, __v, __node_gen, __unique_keys());\n+\treturn __h._M_insert(__hint, __v, __node_gen, __unique_keys{});\n       }\n \n       template<typename _KType, typename... _Args>\n@@ -876,7 +876,7 @@ namespace __detail\n \t{\n \t  __hashtable& __h = _M_conjure_hashtable();\n \t  __node_gen_type __node_gen(__h);\n-\t  return _M_insert_range(__first, __last, __node_gen, __unique_keys());\n+\t  return _M_insert_range(__first, __last, __node_gen, __unique_keys{});\n \t}\n     };\n \n@@ -889,21 +889,11 @@ namespace __detail\n       _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n \t\t    _RehashPolicy, _Traits>::\n       _M_insert_range(_InputIterator __first, _InputIterator __last,\n-\t\t      const _NodeGetter& __node_gen, true_type)\n+\t\t      const _NodeGetter& __node_gen, true_type __uks)\n       {\n-\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n-\tif (__n_elt == 0)\n-\t  return;\n-\n \t__hashtable& __h = _M_conjure_hashtable();\n \tfor (; __first != __last; ++__first)\n-\t  {\n-\t    if (__h._M_insert(*__first, __node_gen, __unique_keys(),\n-\t\t\t      __n_elt).second)\n-\t      __n_elt = 1;\n-\t    else if (__n_elt != 1)\n-\t      --__n_elt;\n-\t  }\n+\t  __h._M_insert(*__first, __node_gen, __uks);\n       }\n \n   template<typename _Key, typename _Value, typename _Alloc,\n@@ -915,7 +905,7 @@ namespace __detail\n       _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n \t\t    _RehashPolicy, _Traits>::\n       _M_insert_range(_InputIterator __first, _InputIterator __last,\n-\t\t      const _NodeGetter& __node_gen, false_type)\n+\t\t      const _NodeGetter& __node_gen, false_type __uks)\n       {\n \tusing __rehash_type = typename __hashtable::__rehash_type;\n \tusing __rehash_state = typename __hashtable::__rehash_state;\n@@ -936,7 +926,7 @@ namespace __detail\n \t  __h._M_rehash(__do_rehash.second, __saved_state);\n \n \tfor (; __first != __last; ++__first)\n-\t  __h._M_insert(*__first, __node_gen, __unique_keys());\n+\t  __h._M_insert(*__first, __node_gen, __uks);\n       }\n \n   /**\n@@ -986,7 +976,7 @@ namespace __detail\n       {\n \t__hashtable& __h = this->_M_conjure_hashtable();\n \t__node_gen_type __node_gen(__h);\n-\treturn __h._M_insert(std::move(__v), __node_gen, __unique_keys());\n+\treturn __h._M_insert(std::move(__v), __node_gen, __unique_keys{});\n       }\n \n       iterator\n@@ -995,7 +985,7 @@ namespace __detail\n \t__hashtable& __h = this->_M_conjure_hashtable();\n \t__node_gen_type __node_gen(__h);\n \treturn __h._M_insert(__hint, std::move(__v), __node_gen,\n-\t\t\t     __unique_keys());\n+\t\t\t     __unique_keys{});\n       }\n     };\n \n@@ -1036,15 +1026,15 @@ namespace __detail\n \tinsert(_Pair&& __v)\n \t{\n \t  __hashtable& __h = this->_M_conjure_hashtable();\n-\t  return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));\n+\t  return __h._M_emplace(__unique_keys{}, std::forward<_Pair>(__v));\n \t}\n \n       template<typename _Pair, typename = _IFconsp<_Pair>>\n \titerator\n \tinsert(const_iterator __hint, _Pair&& __v)\n \t{\n \t  __hashtable& __h = this->_M_conjure_hashtable();\n-\t  return __h._M_emplace(__hint, __unique_keys(),\n+\t  return __h._M_emplace(__hint, __unique_keys{},\n \t\t\t\tstd::forward<_Pair>(__v));\n \t}\n    };"}, {"sha": "100eb5a27df8f9a0914357daea8129ce006c0678", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/cons/bucket_hint.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fbucket_hint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fbucket_hint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fbucket_hint.cc?ref=6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <vector>\n+#include <forward_list>\n+#include <unordered_set>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::unordered_set<int> a;\n+  a.reserve(2);\n+\n+  std::unordered_set<int> b({ 0, 1, 0, 1, 0, 1, 0, 1 }, a.bucket_count());\n+  VERIFY( b.bucket_count() == a.bucket_count() );\n+}\n+\n+void test02()\n+{\n+  std::unordered_set<int> a;\n+  a.reserve(2);\n+\n+  std::vector<int> v { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };\n+\n+  std::unordered_set<int> b(v.begin(), v.end(), a.bucket_count());\n+  VERIFY( b.bucket_count() == a.bucket_count() );\n+}\n+\n+void test03()\n+{\n+  std::unordered_set<int> a;\n+  a.reserve(2);\n+\n+  std::forward_list<int> fl { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };\n+\n+  std::unordered_set<int> b(fl.begin(), fl.end(), a.bucket_count());\n+  VERIFY( b.bucket_count() == a.bucket_count() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "acf01c73b1b1a13a79a20748f8917e207e82d809", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/modifiers/insert.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Finsert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Finsert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Finsert.cc?ref=6dcf042368012e2d7ce1626ee5d378bf3ad0ccfc", "patch": "@@ -0,0 +1,66 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <vector>\n+#include <forward_list>\n+#include <unordered_set>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::unordered_set<int> a;\n+  a.reserve(2);\n+\n+  auto bkt_count = a.bucket_count();\n+  a.insert({ 0, 1, 0, 1, 0, 1, 0, 1 });\n+  VERIFY( a.bucket_count() == bkt_count );\n+}\n+\n+void test02()\n+{\n+  std::unordered_set<int> a;\n+  a.reserve(2);\n+\n+  std::vector<int> v { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };\n+\n+  auto bkt_count = a.bucket_count();\n+  a.insert(v.begin(), v.end());\n+  VERIFY( a.bucket_count() == bkt_count );\n+}\n+\n+void test03()\n+{\n+  std::unordered_set<int> a;\n+  a.reserve(2);\n+\n+  std::forward_list<int> fl { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };\n+\n+  auto bkt_count = a.bucket_count();\n+  a.insert(fl.begin(), fl.end());\n+  VERIFY( a.bucket_count() == bkt_count );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}]}