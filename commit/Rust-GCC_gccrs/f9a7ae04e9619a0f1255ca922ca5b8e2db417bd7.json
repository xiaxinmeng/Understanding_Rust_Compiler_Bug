{"sha": "f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlhN2FlMDRlOTYxOWEwZjEyNTVjYTkyMmNhNWI4ZTJkYjQxN2JkNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-03T21:42:49Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-03T21:42:49Z"}, "message": "cp-tree.h (TMPL_ARGS_LEVEL): Clarify comment.\n\n\t* cp-tree.h (TMPL_ARGS_LEVEL): Clarify comment.\n\t(INNERMOST_TEMPLATE_ARGS): New macro.\n\t(innermost_args): Remove.\n\t(get_innermost_template_args): New function.\n\t* decl2.c (arg_assoc_class): Use INNERMOST_TEMPLATE_ARGS.\n\t* error.c (dump_function_decl): Be caution when using\n\tmost_general_template.\n\t* method.c (build_template_parm_names):  Use\n\tINNERMOST_TEMPLATE_ARGS.\n\t* pt.c (add_to_template_args): Tidy comment\n\t(get_innermost_template_args): New function.\n\t(check_explicit_specialization): Clear DECL_INITIAL for a new\n\tspecialization.\n\t(process_partial_specialization): Use INNERMOST_TEMPLATE_ARGS.\n\tTidy.\n\t(push_template_decl): Always register specializations of the most\n\tgeneral template.\n\t(convert_template_argument): Use INNERMOST_TEMPLATE_ARGS.\n\t(coerce_template_parms): Likewise.\n\t(lookup_template_class): Likewise.\n\t(innermost_args): Remove.\n\t(tsubst_decl): Use INNERMOST_TEMPLATE_ARGS.\n\t(tsubst_decl): Handle tricky specializations.  Use\n\tget_innermost_template_args.\n\t(instantiate_template): Simplify handling of partial\n\tinstantiations.\n\t(get_class_bindings): Use INNERMOST_TEMPLATE_ARGS.\n\t(most_general_template): Reimplement, in a more straightforward\n\tmanner.\n\t(regenerate_decl_from_template): Tweak formatting.  Use\n\tTMPL_ARGS_DEPTH for clarity.\n\t(set_mangled_name_for_template_decl): Use INNERMOST_ARGS.\n\n\t* dump.c (dequeue_and_dump): Dump information about thunks.\n\nFrom-SVN: r34384", "tree": {"sha": "c8c18186a914c188e0eea1b59ef946c745c24831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8c18186a914c188e0eea1b59ef946c745c24831"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/comments", "author": null, "committer": null, "parents": [{"sha": "22ad59662f441c8cf3c3bf8dba16d3815897fa04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ad59662f441c8cf3c3bf8dba16d3815897fa04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22ad59662f441c8cf3c3bf8dba16d3815897fa04"}], "stats": {"total": 325, "additions": 228, "deletions": 97}, "files": [{"sha": "9930544eed1ac79876902abd1535cf5ea6cbfca0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -1,3 +1,40 @@\n+2000-06-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (TMPL_ARGS_LEVEL): Clarify comment.\n+\t(INNERMOST_TEMPLATE_ARGS): New macro.\n+\t(innermost_args): Remove.\n+\t(get_innermost_template_args): New function.\n+\t* decl2.c (arg_assoc_class): Use INNERMOST_TEMPLATE_ARGS.\n+\t* error.c (dump_function_decl): Be caution when using\n+\tmost_general_template.\n+\t* method.c (build_template_parm_names):  Use\n+\tINNERMOST_TEMPLATE_ARGS.\n+\t* pt.c (add_to_template_args): Tidy comment\n+\t(get_innermost_template_args): New function.\n+\t(check_explicit_specialization): Clear DECL_INITIAL for a new\n+\tspecialization.\n+\t(process_partial_specialization): Use INNERMOST_TEMPLATE_ARGS.\n+\tTidy.\n+\t(push_template_decl): Always register specializations of the most\n+\tgeneral template.\n+\t(convert_template_argument): Use INNERMOST_TEMPLATE_ARGS.\n+\t(coerce_template_parms): Likewise.\n+\t(lookup_template_class): Likewise.\n+\t(innermost_args): Remove.\n+\t(tsubst_decl): Use INNERMOST_TEMPLATE_ARGS.\n+\t(tsubst_decl): Handle tricky specializations.  Use\n+\tget_innermost_template_args.\n+\t(instantiate_template): Simplify handling of partial\n+\tinstantiations.\n+\t(get_class_bindings): Use INNERMOST_TEMPLATE_ARGS.\n+\t(most_general_template): Reimplement, in a more straightforward\n+\tmanner.\n+\t(regenerate_decl_from_template): Tweak formatting.  Use\n+\tTMPL_ARGS_DEPTH for clarity.\n+\t(set_mangled_name_for_template_decl): Use INNERMOST_ARGS.\n+\t\n+\t* dump.c (dequeue_and_dump): Dump information about thunks.\n+\n 2000-06-02  Jason Merrill  <jason@casey.soma.redhat.com>\n \n \t* exception.cc (__cp_pop_exception): If we aren't popping or"}, {"sha": "b9a9eb6e94b8c769ad8a47dd72c4d4a0517f238d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -2325,8 +2325,8 @@ struct lang_decl\n #define TMPL_ARGS_DEPTH(NODE)\t\t\t\t\t\\\n   (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (NODE) ? TREE_VEC_LENGTH (NODE) : 1)\n \n-/* The LEVELth level of the template ARGS.  Note that template\n-   parameter levels are indexed from 1, not from 0.  */\n+/* The LEVELth level of the template ARGS.  The outermost level of of\n+   args is level 1, not level 0.  */\n #define TMPL_ARGS_LEVEL(ARGS, LEVEL)\t\t\\\n   (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS) \t\\\n    ? TREE_VEC_ELT ((ARGS), (LEVEL) - 1) : ARGS)\n@@ -2352,6 +2352,10 @@ struct lang_decl\n    : (TREE_CODE (NODE) == TREE_VEC \t\t\t\\\n       ? TREE_VEC_LENGTH (NODE) : list_length (NODE)))\n \n+/* Returns the innermost level of template arguments in ARGS.  */\n+#define INNERMOST_TEMPLATE_ARGS(NODE) \\\n+  (get_innermost_template_args ((NODE), 1))\n+\n /* The number of levels of template parameters given by NODE.  */\n #define TMPL_PARMS_DEPTH(NODE) \\\n   (TREE_INT_CST_HIGH (TREE_PURPOSE (NODE)))\n@@ -4298,7 +4302,7 @@ extern int maybe_clone_body                     PARAMS ((tree));\n /* in pt.c */\n extern void init_pt                             PARAMS ((void));\n extern void check_template_shadow\t\tPARAMS ((tree));\n-extern tree innermost_args\t\t\tPARAMS ((tree));\n+extern tree get_innermost_template_args         PARAMS ((tree, int));\n extern tree tsubst\t\t\t\tPARAMS ((tree, tree, int, tree));\n extern tree tsubst_expr\t\t\t\tPARAMS ((tree, tree, int, tree));\n extern tree tsubst_copy\t\t\t\tPARAMS ((tree, tree, int, tree));"}, {"sha": "a942bd7959629eb92d7cd77da508705fefbe54bc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -4798,7 +4798,7 @@ arg_assoc_class (k, type)\n   /* Process template arguments.  */\n   if (CLASSTYPE_TEMPLATE_INFO (type))\n     {\n-      list = innermost_args (CLASSTYPE_TI_ARGS (type));\n+      list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n       for (i = 0; i < TREE_VEC_LENGTH (list); ++i) \n         arg_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n     }"}, {"sha": "09fbf4bba8cfe5eb023e7850b13737d4295abb19", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -578,6 +578,13 @@ dequeue_and_dump (di)\n \t    dump_string (di, \"operator\");\n \t  if (DECL_CONV_FN_P (t))\n \t    dump_string (di, \"conversion\");\n+\t  if (DECL_THUNK_P (t))\n+\t    {\n+\t      dump_string (di, \"thunk\");\n+\t      dump_int (di, \"dlta\", THUNK_DELTA (t));\n+\t      dump_int (di, \"vcll\", THUNK_VCALL_OFFSET (t));\n+\t      dump_child (\"fn\", DECL_INITIAL (t));\n+\t    }\n \t  if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n \t    {\n \t      if (DECL_GLOBAL_CTOR_P (t))"}, {"sha": "82ba33deb8b047091f7c1f2aa2d3f2a8d6c8c0c2", "filename": "gcc/cp/error.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -1111,10 +1111,15 @@ dump_function_decl (t, flags)\n   /* Pretty print template instantiations only.  */\n   if (DECL_USE_TEMPLATE (t) && DECL_TEMPLATE_INFO (t))\n     {\n+      tree tmpl;\n+\n       template_args = DECL_TI_ARGS (t);\n-      t = most_general_template (t);\n-      if (TREE_CODE (t) == TEMPLATE_DECL)\n-\ttemplate_parms = DECL_TEMPLATE_PARMS (t);\n+      tmpl = most_general_template (t);\n+      if (tmpl && TREE_CODE (tmpl) == TEMPLATE_DECL)\n+\t{\n+\t  template_parms = DECL_TEMPLATE_PARMS (tmpl);\n+\t  t = tmpl;\n+\t}\n     }\n \n   fntype = TREE_TYPE (t);"}, {"sha": "578e1c8a6869d98d8a65575a3912827924851af4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -945,7 +945,7 @@ build_template_parm_names (parmlist, arglist)\n      tree arglist;\n {\n   int i, nparms;\n-  tree inner_args = innermost_args (arglist);\n+  tree inner_args = INNERMOST_TEMPLATE_ARGS (arglist);\n \n   nparms = TREE_VEC_LENGTH (parmlist);\n   icat (nparms);"}, {"sha": "18b0d6afd1cc9e3713fb60550c6c504c7fe6f57e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 134, "deletions": 89, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -474,9 +474,7 @@ is_member_template_class (t)\n #endif\n \n /* Return a new template argument vector which contains all of ARGS,\n-   but has as its innermost set of arguments the EXTRA_ARGS.  The\n-   resulting vector will be built on a temporary obstack, and so must\n-   be explicitly copied to the permanent obstack, if required.  */\n+   but has as its innermost set of arguments the EXTRA_ARGS.  */\n \n static tree\n add_to_template_args (args, extra_args)\n@@ -535,6 +533,39 @@ add_outermost_template_args (args, extra_args)\n   return new_args;\n }\n \n+/* Return the N levels of innermost template arguments from the ARGS.  */\n+\n+tree\n+get_innermost_template_args (args, n)\n+     tree args;\n+     int n;\n+{\n+  tree new_args;\n+  int extra_levels;\n+  int i;\n+\n+  my_friendly_assert (n >= 0, 20000603);\n+\n+  /* If N is 1, just return the innermost set of template arguments.  */\n+  if (n == 1)\n+    return TMPL_ARGS_LEVEL (args, TMPL_ARGS_DEPTH (args));\n+  \n+  /* If we're not removing anything, just return the arguments we were\n+     given.  */\n+  extra_levels = TMPL_ARGS_DEPTH (args) - n;\n+  my_friendly_assert (extra_levels >= 0, 20000603);\n+  if (extra_levels == 0)\n+    return args;\n+\n+  /* Make a new set of arguments, not containing the outer arguments.  */\n+  new_args = make_tree_vec (n);\n+  for (i = 1; i <= n; ++i)\n+    SET_TMPL_ARGS_LEVEL (new_args, i, \n+\t\t\t TMPL_ARGS_LEVEL (args, i + extra_levels));\n+\n+  return new_args;\n+}\n+\n /* We've got a template header coming up; push to a new level for storing\n    the parms.  */\n \n@@ -1484,13 +1515,13 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      return instantiate_template (tmpl, targs);\n \t    }\n \n-\t  /* If this is both a template specialization, then it's a\n-\t     specialization of a member template of a template class.\n-\t     In that case we want to return the TEMPLATE_DECL, not the\n-\t     specialization of it.  */\n+\t  /* If this is a specialization of a member template of a\n+\t     template class.  In we want to return the TEMPLATE_DECL,\n+\t     not the specialization of it.  */\n \t  if (tsk == tsk_template)\n \t    {\n \t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n+\t      DECL_INITIAL (DECL_TEMPLATE_RESULT (tmpl)) = NULL_TREE;\n \t      return tmpl;\n \t    }\n \n@@ -2025,7 +2056,7 @@ process_partial_specialization (decl)\n   tree type = TREE_TYPE (decl);\n   tree maintmpl = CLASSTYPE_TI_TEMPLATE (type);\n   tree specargs = CLASSTYPE_TI_ARGS (type);\n-  tree inner_args = innermost_args (specargs);\n+  tree inner_args = INNERMOST_TEMPLATE_ARGS (specargs);\n   tree inner_parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n   tree main_inner_parms = DECL_INNERMOST_TEMPLATE_PARMS (maintmpl);\n   int nargs = TREE_VEC_LENGTH (inner_args);\n@@ -2082,7 +2113,7 @@ process_partial_specialization (decl)\n     if (tpd.parms[i] == 0)\n       {\n \t/* One of the template parms was not used in the\n-           specialization.  */\n+\t   specialization.  */\n \tif (!did_error_intro)\n \t  {\n \t    cp_error (\"template parameters not used in partial specialization:\");\n@@ -2097,9 +2128,10 @@ process_partial_specialization (decl)\n \n      The argument list of the specialization shall not be identical to\n      the implicit argument list of the primary template.  */\n-  if (comp_template_args (inner_args, \n-\t\t\t  innermost_args (CLASSTYPE_TI_ARGS (TREE_TYPE\n-\t\t\t\t\t\t\t     (maintmpl)))))\n+  if (comp_template_args \n+      (inner_args, \n+       INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE\n+\t\t\t\t\t\t   (maintmpl)))))\n     cp_error (\"partial specialization `%T' does not specialize any template arguments\", type);\n \n   /* [temp.class.spec]\n@@ -2502,7 +2534,9 @@ push_template_decl_real (decl, is_friend)\n \t  DECL_TEMPLATE_INFO (new_tmpl) \n \t    = tree_cons (tmpl, args, NULL_TREE);\n \n-\t  register_specialization (new_tmpl, tmpl, args);\n+\t  register_specialization (new_tmpl, \n+\t\t\t\t   most_general_template (tmpl), \n+\t\t\t\t   args);\n \t  return decl;\n \t}\n \n@@ -3124,7 +3158,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n   tree inner_args;\n   int is_type, requires_type, is_tmpl_type, requires_tmpl_type;\n   \n-  inner_args = innermost_args (args);\n+  inner_args = INNERMOST_TEMPLATE_ARGS (args);\n \n   if (TREE_CODE (arg) == TREE_LIST \n       && TREE_TYPE (arg) != NULL_TREE\n@@ -3322,7 +3356,7 @@ coerce_template_parms (parms, args, in_decl,\n   tree new_args;\n   tree new_inner_args;\n \n-  inner_args = innermost_args (args);\n+  inner_args = INNERMOST_TEMPLATE_ARGS (args);\n   nargs = NUM_TMPL_ARGS (inner_args);\n   nparms = TREE_VEC_LENGTH (parms);\n \n@@ -3469,7 +3503,7 @@ mangle_class_name_for_template (name, parms, arglist)\n   cat (name);\n   ccat ('<');\n   nparms = TREE_VEC_LENGTH (parms);\n-  arglist = innermost_args (arglist);\n+  arglist = INNERMOST_TEMPLATE_ARGS (arglist);\n   my_friendly_assert (nparms == TREE_VEC_LENGTH (arglist), 268);\n   for (i = 0; i < nparms; i++)\n     {\n@@ -3824,7 +3858,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       else\n \targlist\n \t  = coerce_template_parms (INNERMOST_TEMPLATE_PARMS (parmlist),\n-\t\t\t\t   innermost_args (arglist),\n+\t\t\t\t   INNERMOST_TEMPLATE_ARGS (arglist),\n \t\t\t\t   template, 1, 1);\n \n       if (arglist == error_mark_node)\n@@ -5143,17 +5177,6 @@ maybe_fold_nontype_arg (arg)\n   return arg;\n }\n \n-/* Return the TREE_VEC with the arguments for the innermost template header,\n-   where ARGS is either that or the VEC of VECs for all the\n-   arguments.  */\n-\n-tree\n-innermost_args (args)\n-     tree args;\n-{\n-  return TMPL_ARGS_LEVEL (args, TMPL_ARGS_DEPTH (args));\n-}\n-\n /* Substitute ARGS into the vector of template arguments T.  */\n \n static tree\n@@ -5548,7 +5571,7 @@ tsubst_decl (t, args, type, in_decl)\n \t\t\tspec_args, /*complain=*/1, in_decl); \n \t    DECL_TI_TEMPLATE (new_fn) = fn;\n \t    register_specialization (new_fn, r, \n-\t\t\t\t     innermost_args (spec_args));\n+\t\t\t\t     INNERMOST_TEMPLATE_ARGS (spec_args));\n \t  }\n \n \t/* Record this partial instantiation.  */\n@@ -5593,7 +5616,19 @@ tsubst_decl (t, args, type, in_decl)\n \t\tbreak;\n \t      }\n \n-\t    /* Here, we deal with the peculiar case:\n+\t    /* We can see more levels of arguments than parameters if\n+\t       there was a specialization of a member template, like\n+\t       this:\n+\n+\t         template <class T> struct S { template <class U> void f(); }\n+\t\t template <> template <class U> void S<int>::f(U); \n+\n+\t       Here, we'll be subtituting into the specialization,\n+\t       because that's where we can find the code we actually\n+\t       want to generate, but we'll have enough arguments for\n+\t       the most general template.\t       \n+\n+\t       We also deal with the peculiar case:\n \n \t\t template <class T> struct S { \n \t\t   template <class U> friend void f();\n@@ -5618,21 +5653,7 @@ tsubst_decl (t, args, type, in_decl)\n \t      TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (t))); \n \t    if (args_depth > parms_depth\n \t\t&& !DECL_TEMPLATE_SPECIALIZATION (t))\n-\t      {\n-\t\tmy_friendly_assert (DECL_FRIEND_P (t), 0);\n-\n-\t\tif (parms_depth > 1)\n-\t\t  {\n-\t\t    int i;\n-\n-\t\t    args = make_tree_vec (parms_depth);\n-\t\t    for (i = 0; i < parms_depth; ++i)\n-\t\t      TREE_VEC_ELT (args, i) = \n-\t\t\tTREE_VEC_ELT (args, i + (args_depth - parms_depth));\n-\t\t  }\n-\t\telse\n-\t\t  args = TREE_VEC_ELT (args, args_depth - parms_depth);\n-\t      }\n+\t      args = get_innermost_template_args (args, parms_depth);\n \t  }\n \telse\n \t  {\n@@ -7440,25 +7461,23 @@ instantiate_template (tmpl, targ_ptr)\n   if (spec != NULL_TREE)\n     return spec;\n \n-  if (DECL_TEMPLATE_INFO (tmpl) && !DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+  gen_tmpl = most_general_template (tmpl);\n+  if (tmpl != gen_tmpl)\n     {\n       /* The TMPL is a partial instantiation.  To get a full set of\n \t arguments we must add the arguments used to perform the\n \t partial instantiation.  */\n       targ_ptr = add_outermost_template_args (DECL_TI_ARGS (tmpl),\n \t\t\t\t\t      targ_ptr);\n-      gen_tmpl = most_general_template (tmpl);\n \n       /* Check to see if we already have this specialization.  */\n       spec = retrieve_specialization (gen_tmpl, targ_ptr);\n       if (spec != NULL_TREE)\n \treturn spec;\n     }\n-  else\n-    gen_tmpl = tmpl;\n \n   len = DECL_NTPARMS (gen_tmpl);\n-  inner_args = innermost_args (targ_ptr);\n+  inner_args = INNERMOST_TEMPLATE_ARGS (targ_ptr);\n   i = len;\n   while (i--)\n     {\n@@ -8885,7 +8904,7 @@ get_class_bindings (tparms, parms, args)\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n   tree vec = make_tree_vec (ntparms);\n \n-  args = innermost_args (args);\n+  args = INNERMOST_TEMPLATE_ARGS (args);\n \n   if (unify (tparms, vec, parms, args, UNIFY_ALLOW_NONE))\n     return NULL_TREE;\n@@ -8970,7 +8989,9 @@ most_specialized (fns, decl, explicit_args)\n }\n \n /* If DECL is a specialization of some template, return the most\n-   general such template.  For example, given:\n+   general such template.  Otherwise, returns NULL_TREE.\n+\n+   For example, given:\n \n      template <class T> struct S { template <class U> void f(U); };\n \n@@ -8987,14 +9008,37 @@ tree\n most_general_template (decl)\n      tree decl;\n {\n-  while (DECL_TEMPLATE_INFO (decl)\n-\t && !(TREE_CODE (decl) == TEMPLATE_DECL\n-\t      && DECL_TEMPLATE_SPECIALIZATION (decl))\n-\t /* The DECL_TI_TEMPLATE can be a LOOKUP_EXPR or\n-\t    IDENTIFIER_NODE in some cases.  (See cp-tree.h for\n-\t    details.)  */\n-\t && TREE_CODE (DECL_TI_TEMPLATE (decl)) == TEMPLATE_DECL)\n-    decl = DECL_TI_TEMPLATE (decl);\n+  /* If DECL is a FUNCTION_DECL, find the TEMPLATE_DECL of which it is\n+     an immediate specialization.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (DECL_TEMPLATE_INFO (decl)) {\n+\tdecl = DECL_TI_TEMPLATE (decl);\n+\n+\t/* The DECL_TI_TEMPLATE can be an IDENTIFIER_NODE for a\n+\t   template friend.  */\n+\tif (TREE_CODE (decl) != TEMPLATE_DECL)\n+\t  return NULL_TREE;\n+      } else\n+\treturn NULL_TREE;\n+    }\n+\n+  /* Look for more and more general templates.  */\n+  while (DECL_TEMPLATE_INFO (decl))\n+    {\n+      /* The DECL_TI_TEMPLATE can be a LOOKUP_EXPR or IDENTIFIER_NODE\n+\t in some cases.  (See cp-tree.h for details.)  */\n+      if (TREE_CODE (DECL_TI_TEMPLATE (decl)) != TEMPLATE_DECL)\n+\tbreak;\n+\n+      /* Stop if we run into an explicitly specialized class template.  */\n+      if (!DECL_NAMESPACE_SCOPE_P (decl)\n+\t  && DECL_CONTEXT (decl)\n+\t  && CLASSTYPE_TEMPLATE_SPECIALIZATION (DECL_CONTEXT (decl)))\n+\tbreak;\n+\n+      decl = DECL_TI_TEMPLATE (decl);\n+    }\n \n   return decl;\n }\n@@ -9345,10 +9389,13 @@ regenerate_decl_from_template (decl, tmpl)\n      tree decl;\n      tree tmpl;\n {\n+  /* The most general version of TMPL.  */\n+  tree gen_tmpl;\n+  /* The arguments used to instantiate DECL, from the most general\n+     template.  */\n   tree args;\n   tree code_pattern;\n   tree new_decl;\n-  tree gen_tmpl;\n   int unregistered;\n \n   args = DECL_TI_ARGS (decl);\n@@ -9474,32 +9521,30 @@ instantiate_decl (d, defer_ok)\n      and an instantiation of S<double>::f<int>.  We want TD to be the\n      specialization S<T>::f<int>, not the more general S<T>::f<U>.  */\n   td = tmpl;\n-  for (td = tmpl;\n-       /* An instantiation cannot have a definition, so we need a\n-\t  more general template.  */\n-       DECL_TEMPLATE_INSTANTIATION (td)\n-\t /* We must also deal with friend templates.  Given:\n-\n-\t      template <class T> struct S { \n-\t\ttemplate <class U> friend void f() {};\n-\t      };\n-\t \n-\t    S<int>::f<U> say, is not an instantiation of S<T>::f<U>,\n-\t    so far as the language is concerned, but that's still\n-\t    where we get the pattern for the instantiation from.  On\n-\t    ther hand, if the definition comes outside the class, say:\n-\n- \t      template <class T> struct S { \n-\t        template <class U> friend void f();\n-              };\n-\t      template <class U> friend void f() {}\n-\n-\t    we don't need to look any further.  That's what the check for\n-\t    DECL_INITIAL is for.  */\n-\t|| (TREE_CODE (d) == FUNCTION_DECL\n-\t    && DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (td)\n-\t    && !DECL_INITIAL (DECL_TEMPLATE_RESULT (td)));\n-       )\n+  while (/* An instantiation cannot have a definition, so we need a\n+\t    more general template.  */\n+\t DECL_TEMPLATE_INSTANTIATION (td)\n+\t   /* We must also deal with friend templates.  Given:\n+\n+\t\ttemplate <class T> struct S { \n+\t\t  template <class U> friend void f() {};\n+\t\t};\n+\n+\t      S<int>::f<U> say, is not an instantiation of S<T>::f<U>,\n+\t      so far as the language is concerned, but that's still\n+\t      where we get the pattern for the instantiation from.  On\n+\t      ther hand, if the definition comes outside the class, say:\n+\n+\t\ttemplate <class T> struct S { \n+\t\t  template <class U> friend void f();\n+\t\t};\n+\t\ttemplate <class U> friend void f() {}\n+\n+\t      we don't need to look any further.  That's what the check for\n+\t      DECL_INITIAL is for.  */\n+\t  || (TREE_CODE (d) == FUNCTION_DECL\n+\t      && DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (td)\n+\t      && !DECL_INITIAL (DECL_TEMPLATE_RESULT (td))))\n     {\n       /* The present template, TD, should not be a definition.  If it\n \t were a definition, we should be using it!  Note that we\n@@ -9941,7 +9986,7 @@ set_mangled_name_for_template_decl (decl)\n \n       /* Replace the innermost level of the TARGS with NULL_TREEs to\n \t let tsubst know not to subsitute for those parameters.  */\n-      partial_args = make_tree_vec (TREE_VEC_LENGTH (targs));\n+      partial_args = make_tree_vec (TMPL_ARGS_DEPTH (targs));\n       for (i = 1; i < TMPL_ARGS_DEPTH (targs); ++i)\n \tSET_TMPL_ARGS_LEVEL (partial_args, i,\n \t\t\t     TMPL_ARGS_LEVEL (targs, i));\n@@ -9966,7 +10011,7 @@ set_mangled_name_for_template_decl (decl)\n   /* Now, get the innermost parameters and arguments, and figure out\n      the parameter and return types.  */\n   tparms = INNERMOST_TEMPLATE_PARMS (tparms);\n-  targs = innermost_args (targs);\n+  targs = INNERMOST_TEMPLATE_ARGS (targs);\n   ret_type = TREE_TYPE (fn_type);\n   parm_types = TYPE_ARG_TYPES (fn_type);\n "}, {"sha": "caeceea1d9f522887842a539a54bd78a83d2f825", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp96.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp96.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp96.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp96.C?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -0,0 +1,17 @@\n+// Build don't link:\n+// Origin: Jason Merrill <jason@cygnus.com>\n+\n+template <class T> struct A {\n+  template <class U> void f(U);\n+};\n+\n+template <>\n+template <class U>\n+void A<int>::f(U);\n+\n+A<int> a;\n+\n+void g ()\n+{\n+  a.f (3);\n+}"}, {"sha": "511beaea57dd59dae4e1071e13816c1113e70176", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp97.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp97.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp97.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp97.C?ref=f9a7ae04e9619a0f1255ca922ca5b8e2db417bd7", "patch": "@@ -0,0 +1,16 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T> struct A {\n+  template <class U> int f(U) { return 1; }\n+};\n+\n+template <>\n+template <class U>\n+int A<int>::f(U) { return 0; }\n+\n+A<int> a;\n+\n+int main ()\n+{\n+  return a.f (3);\n+}"}]}