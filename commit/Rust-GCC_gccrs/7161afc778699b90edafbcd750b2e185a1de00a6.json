{"sha": "7161afc778699b90edafbcd750b2e185a1de00a6", "node_id": "C_kwDOANBUbNoAKDcxNjFhZmM3Nzg2OTliOTBlZGFmYmNkNzUwYjJlMTg1YTFkZTAwYTY", "commit": {"author": {"name": "Andrea Corallo", "email": "andrea.corallo@arm.com", "date": "2021-12-06T10:42:11Z"}, "committer": {"name": "Andrea Corallo", "email": "andrea.corallo@arm.com", "date": "2023-01-23T10:28:11Z"}, "message": "[PATCH 6/15] arm: Add pointer authentication for stack-unwinding runtime\n\nThis patch adds authentication for when the stack is unwound when an\nexception is taken.  All the changes here are done to the runtime code\nin libgcc's unwinder code for Arm target. All the changes are guarded\nunder defined (__ARM_FEATURE_PAC_DEFAULT) and activated only if the\n+pacbti feature is switched on for the architecture. This means that\nswitching on the target feature via -march or -mcpu is sufficient and\n-mbranch-protection need not be enabled. This ensures that the\nunwinder is authenticated only if the PACBTI instructions are\navailable in the non-NOP space as it uses AUTG.  Just generating\nPAC/AUT instructions using -mbranch-protection will not enable\nauthentication on the unwinder.\n\nPre-approved with the requested changes here\n<https://gcc.gnu.org/pipermail/gcc-patches/2021-December/586555.html>.\n\ngcc/ChangeLog:\n\n\t* ginclude/unwind-arm-common.h (_Unwind_VRS_RegClass): Introduce\n\tnew pseudo register class _UVRSC_PAC.\n\nlibgcc/ChangeLog:\n\t* config/arm/pr-support.c (__gnu_unwind_execute): Decode\n\texception opcode (0xb4) for saving RA_AUTH_CODE and authenticate\n\twith AUTG if found.\n\t* config/arm/unwind-arm.c (struct pseudo_regs): New.\n\t(phase1_vrs): Introduce new field to store pseudo-reg state.\n\t(phase2_vrs): Likewise.\n\t(_Unwind_VRS_Get): Load pseudo register state from virtual reg set.\n\t(_Unwind_VRS_Set): Store pseudo register state to virtual reg set.\n\t(_Unwind_VRS_Pop): Load pseudo register value from stack into VRS.\n\nCo-Authored-By: Tejas Belagod  <tbelagod@arm.com>\nCo-Authored-By: Srinath Parvathaneni <srinath.parvathaneni@arm.com>", "tree": {"sha": "a70f35995eac4ee621970c49e84c3105c56b46ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a70f35995eac4ee621970c49e84c3105c56b46ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7161afc778699b90edafbcd750b2e185a1de00a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7161afc778699b90edafbcd750b2e185a1de00a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7161afc778699b90edafbcd750b2e185a1de00a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7161afc778699b90edafbcd750b2e185a1de00a6/comments", "author": {"login": "AndreaCorallo", "id": 6765576, "node_id": "MDQ6VXNlcjY3NjU1NzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6765576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreaCorallo", "html_url": "https://github.com/AndreaCorallo", "followers_url": "https://api.github.com/users/AndreaCorallo/followers", "following_url": "https://api.github.com/users/AndreaCorallo/following{/other_user}", "gists_url": "https://api.github.com/users/AndreaCorallo/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreaCorallo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreaCorallo/subscriptions", "organizations_url": "https://api.github.com/users/AndreaCorallo/orgs", "repos_url": "https://api.github.com/users/AndreaCorallo/repos", "events_url": "https://api.github.com/users/AndreaCorallo/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreaCorallo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AndreaCorallo", "id": 6765576, "node_id": "MDQ6VXNlcjY3NjU1NzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6765576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreaCorallo", "html_url": "https://github.com/AndreaCorallo", "followers_url": "https://api.github.com/users/AndreaCorallo/followers", "following_url": "https://api.github.com/users/AndreaCorallo/following{/other_user}", "gists_url": "https://api.github.com/users/AndreaCorallo/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreaCorallo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreaCorallo/subscriptions", "organizations_url": "https://api.github.com/users/AndreaCorallo/orgs", "repos_url": "https://api.github.com/users/AndreaCorallo/repos", "events_url": "https://api.github.com/users/AndreaCorallo/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreaCorallo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dffcafd88ced273fb0b2e8b754b44472d73458f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dffcafd88ced273fb0b2e8b754b44472d73458f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dffcafd88ced273fb0b2e8b754b44472d73458f7"}], "stats": {"total": 63, "additions": 62, "deletions": 1}, "files": [{"sha": "3ee0a6b1f27dbb4ee893c0d545db9d4120a587d4", "filename": "gcc/ginclude/unwind-arm-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7161afc778699b90edafbcd750b2e185a1de00a6/gcc%2Fginclude%2Funwind-arm-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7161afc778699b90edafbcd750b2e185a1de00a6/gcc%2Fginclude%2Funwind-arm-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Funwind-arm-common.h?ref=7161afc778699b90edafbcd750b2e185a1de00a6", "patch": "@@ -127,7 +127,8 @@ extern \"C\" {\n       _UVRSC_VFP = 1,       /* vfp */\n       _UVRSC_FPA = 2,       /* fpa */\n       _UVRSC_WMMXD = 3,     /* Intel WMMX data register */\n-      _UVRSC_WMMXC = 4      /* Intel WMMX control register */\n+      _UVRSC_WMMXC = 4,     /* Intel WMMX control register */\n+      _UVRSC_PAC = 5        /* Armv8.1-M Mainline PAC/AUTH pseudo-register */\n     }\n   _Unwind_VRS_RegClass;\n "}, {"sha": "abacfb62212c2aa0020a71654d3dd248cbea9dcd", "filename": "libgcc/config/arm/pr-support.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7161afc778699b90edafbcd750b2e185a1de00a6/libgcc%2Fconfig%2Farm%2Fpr-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7161afc778699b90edafbcd750b2e185a1de00a6/libgcc%2Fconfig%2Farm%2Fpr-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Fpr-support.c?ref=7161afc778699b90edafbcd750b2e185a1de00a6", "patch": "@@ -106,6 +106,7 @@ __gnu_unwind_execute (_Unwind_Context * context, __gnu_unwind_state * uws)\n {\n   _uw op;\n   int set_pc;\n+  int set_pac = 0;\n   _uw reg;\n \n   set_pc = 0;\n@@ -114,6 +115,27 @@ __gnu_unwind_execute (_Unwind_Context * context, __gnu_unwind_state * uws)\n       op = next_unwind_byte (uws);\n       if (op == CODE_FINISH)\n \t{\n+\t  /* When we reach end, we have to authenticate R12 we just popped\n+\t     earlier.\n+\n+\t     Note: while the check provides additional security against a\n+\t     corrupted unwind chain, it isn't essential for correct unwinding\n+\t     of an uncorrupted chain.  */\n+#if defined(TARGET_HAVE_PACBTI)\n+\t  if (set_pac)\n+\t    {\n+\t      _uw sp;\n+\t      _uw lr;\n+\t      _uw pac;\n+\t      _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &sp);\n+\t      _Unwind_VRS_Get (context, _UVRSC_CORE, R_LR, _UVRSD_UINT32, &lr);\n+\t      _Unwind_VRS_Get (context, _UVRSC_PAC, R_IP,\n+\t\t\t       _UVRSD_UINT32, &pac);\n+\t      __asm__ __volatile__\n+\t\t(\"autg %0, %1, %2\" : : \"r\"(pac), \"r\"(lr), \"r\"(sp) :);\n+\t    }\n+#endif\n+\n \t  /* If we haven't already set pc then copy it from lr.  */\n \t  if (!set_pc)\n \t    {\n@@ -227,6 +249,16 @@ __gnu_unwind_execute (_Unwind_Context * context, __gnu_unwind_state * uws)\n \t\treturn _URC_FAILURE;\n \t      continue;\n \t    }\n+\t  /* Pop PAC off the stack into VRS pseudo.pac.  */\n+\t  if (op == 0xb4)\n+\t    {\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_PAC, 0, _UVRSD_UINT32)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      set_pac = 1;\n+\t      continue;\n+\t    }\n+\n \t  if ((op & 0xfc) == 0xb4)  /* Obsolete FPA.  */\n \t    return _URC_FAILURE;\n "}, {"sha": "b91821ce8361de3d8f50873e49d83d19d1a961dd", "filename": "libgcc/config/arm/unwind-arm.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7161afc778699b90edafbcd750b2e185a1de00a6/libgcc%2Fconfig%2Farm%2Funwind-arm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7161afc778699b90edafbcd750b2e185a1de00a6/libgcc%2Fconfig%2Farm%2Funwind-arm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Funwind-arm.c?ref=7161afc778699b90edafbcd750b2e185a1de00a6", "patch": "@@ -64,6 +64,12 @@ struct wmmxc_regs\n   _uw wc[4];\n };\n \n+/*  Holds value of pseudo registers eg. PAC.  */\n+struct pseudo_regs\n+{\n+  _uw pac;\n+};\n+\n /* The ABI specifies that the unwind routines may only use core registers,\n    except when actually manipulating coprocessor state.  This allows\n    us to write one implementation that works on all platforms by\n@@ -78,6 +84,9 @@ typedef struct\n   /* The first fields must be the same as a phase2_vrs.  */\n   _uw demand_save_flags;\n   struct core_regs core;\n+  /* Armv8.1-M Mainline PAC/AUTH values.  This field should be in the same field\n+     order as phase2_vrs.  */\n+  struct pseudo_regs pseudo;\n   _uw prev_sp; /* Only valid during forced unwinding.  */\n   struct vfp_regs vfp;\n   struct vfpv3_regs vfp_regs_16_to_31;\n@@ -99,6 +108,7 @@ typedef struct\n {\n   _uw demand_save_flags;\n   struct core_regs core;\n+  struct pseudo_regs pac;\n } phase2_vrs;\n \n /* Coprocessor register state manipulation functions.  */\n@@ -175,6 +185,10 @@ _Unwind_VRS_Result _Unwind_VRS_Get (_Unwind_Context *context,\n     case _UVRSC_WMMXC:\n       return _UVRSR_NOT_IMPLEMENTED;\n \n+    case _UVRSC_PAC:\n+      *(_uw *) valuep = vrs->pseudo.pac;\n+      return _UVRSR_OK;\n+\n     default:\n       return _UVRSR_FAILED;\n     }\n@@ -206,6 +220,10 @@ _Unwind_VRS_Result _Unwind_VRS_Set (_Unwind_Context *context,\n     case _UVRSC_WMMXC:\n       return _UVRSR_NOT_IMPLEMENTED;\n \n+    case _UVRSC_PAC:\n+      vrs->pseudo.pac = *(_uw *) valuep;\n+      return _UVRSR_OK;\n+\n     default:\n       return _UVRSR_FAILED;\n     }\n@@ -246,6 +264,16 @@ _Unwind_VRS_Result _Unwind_VRS_Pop (_Unwind_Context *context,\n       }\n       return _UVRSR_OK;\n \n+    case _UVRSC_PAC:\n+      {\n+\t_uw *ptr = (_uw *) vrs->core.r[R_SP];\n+\tif (discriminator != 0)\n+\t  return _UVRSR_FAILED;\n+\tvrs->pseudo.pac = *(ptr++);\n+\tvrs->core.r[R_SP] = (_uw) ptr;\n+\treturn _UVRSR_OK;\n+      }\n+\n     case _UVRSC_VFP:\n       {\n \t_uw start = discriminator >> 16;"}]}