{"sha": "40c34beef620ed13c4113c893ed4335ccc1b8f92", "node_id": "C_kwDOANBUbNoAKDQwYzM0YmVlZjYyMGVkMTNjNDExM2M4OTNlZDQzMzVjY2MxYjhmOTI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-03T19:35:18Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-03T19:35:18Z"}, "message": "c++: requires-expr and access checking [PR107179]\n\nLike during satisfaction, we also need to avoid deferring access checks\nduring substitution of a requires-expr because the outcome of an access\ncheck can determine the value of the requires-expr.  Otherwise (in\ndeferred access checking contexts such as within a base-clause), the\nrequires-expr may evaluate to the wrong result, and along the way a\nfailed access check may leak out from it into a non-SFINAE context and\ncause a hard error (as in the below testcase).\n\n\tPR c++/107179\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (tsubst_requires_expr): Make sure we're not\n\tdeferring access checks.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-requires31.C: New test.", "tree": {"sha": "08e929a363fa50b11f45169d0ea92b8507491e30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08e929a363fa50b11f45169d0ea92b8507491e30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40c34beef620ed13c4113c893ed4335ccc1b8f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c34beef620ed13c4113c893ed4335ccc1b8f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c34beef620ed13c4113c893ed4335ccc1b8f92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c34beef620ed13c4113c893ed4335ccc1b8f92/comments", "author": null, "committer": null, "parents": [{"sha": "095de980339f2fe0ff2add112c4d5ab9175b8f58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095de980339f2fe0ff2add112c4d5ab9175b8f58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095de980339f2fe0ff2add112c4d5ab9175b8f58"}], "stats": {"total": 18, "additions": 18, "deletions": 0}, "files": [{"sha": "f6ef078171a7f7e540d38f23e1c1ca5a76f6bbc1", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c34beef620ed13c4113c893ed4335ccc1b8f92/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c34beef620ed13c4113c893ed4335ccc1b8f92/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=40c34beef620ed13c4113c893ed4335ccc1b8f92", "patch": "@@ -2252,6 +2252,9 @@ tsubst_requires_expr (tree t, tree args, sat_info info)\n {\n   local_specialization_stack stack (lss_copy);\n \n+  /* We need to check access during the substitution.  */\n+  deferring_access_check_sentinel acs (dk_no_deferred);\n+\n   /* A requires-expression is an unevaluated context.  */\n   cp_unevaluated u;\n "}, {"sha": "cd26b9ca07771016d24154e32764a112a34821e6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires31.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c34beef620ed13c4113c893ed4335ccc1b8f92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c34beef620ed13c4113c893ed4335ccc1b8f92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires31.C?ref=40c34beef620ed13c4113c893ed4335ccc1b8f92", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/107179\n+// { dg-do compile { target c++20 } }\n+\n+template<bool B> struct bool_constant { static constexpr bool value = B; };\n+\n+template<typename T>\n+  struct is_implicitly_default_constructible\n+  : bool_constant<requires { T(); }>\n+  { };\n+\n+struct X { private: X(); };\n+struct Y { };\n+\n+static_assert( !is_implicitly_default_constructible<X>::value );\n+static_assert(  is_implicitly_default_constructible<Y>::value );"}]}