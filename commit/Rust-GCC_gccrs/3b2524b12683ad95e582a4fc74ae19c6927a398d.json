{"sha": "3b2524b12683ad95e582a4fc74ae19c6927a398d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyNTI0YjEyNjgzYWQ5NWU1ODJhNGZjNzRhZTE5YzY5MjdhMzk4ZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-02-10T16:09:42Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-02-10T16:09:42Z"}, "message": "hashtable.h: Fold in include/tr1_impl/hashtable.h for C++0x use.\n\n2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/bits/hashtable.h: Fold in include/tr1_impl/hashtable.h\n\tfor C++0x use.\n\t* include/bits/hashtable_policy.h: New, copy and adjust for\n\tC++0x use, include/tr1_impl/hashtable_policy.h; fix erase and\n\tinsert member functions per n3000.\n\t* include/bits/unordered_map.h: Likewise for include/tr1_impl/\n\tunordered_map.\n\t* include/bits/unordered_set.h: Likewise for include/tr1_impl/\n\tunordered_set.\n\t* include/Makefile.am: Adjust.\n\t* include/Makefile.in: Regenerate.\n\t* include/tr1/unordered_map: Adjust.\n\t* include/tr1/unordered_set: Likewise.\n\t* include/tr1_impl/unordered_map: Adjust, now used only by tr1.\n\t* include/tr1_impl/hashtable: Likewise.\n\t* include/tr1_impl/hashtable_policy.h: Likewise.\n\t* include/tr1_impl/unordered_set: Likewise.\n\t* include/std/unordered_map: Adjust and simplify includes.\n\t* include/std/unordered_set: Likewise.\n\t* include/debug/unordered_map: Adjuse erase and insert members.\n\t* include/debug/unordered_set: Likewise.\n\t* include/profile/unordered_map: Likewise.\n\t* include/profile/unordered_set: Likewise.\n\t* testsuite/util/exception/safety.h: Fix for the updated erase and\n\tinsert member functions of the unordered_containers.\n\t* testsuite/23_containers/unordered_map/erase/1.cc: New.\n\t* testsuite/23_containers/unordered_map/erase/24061-map.cc: Likewise.\n\t* testsuite/23_containers/unordered_map/insert/map_single.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_map/insert/array_syntax.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_map/insert/24061-map.cc: Likewise.\n\t* testsuite/23_containers/unordered_map/insert/map_range.cc: Likewise.\n\t* testsuite/23_containers/set/operators/1_neg.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/erase/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/erase/\n\t24061-multimap.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/insert/\n\t24061-multimap.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/insert/\n\tmultimap_range.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/insert/\n\tmultimap_single.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/erase/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/erase/24061-set.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/insert/set_single.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/insert/24061-set.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/insert/set_range.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/erase/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/erase/\n\t24061-multiset.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/insert/\n\t24061-multiset.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/insert/\n\tmultiset_range.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/insert/\n\tmultiset_single.cc: Likewise.\n\n\t* testsuite/23_containers/set/operators/1_neg.cc: Tweak dg-errors\n\tto avoid spurious fails in debug-mode.\n\t* testsuite/23_containers/map/operators/1_neg.cc: Likewise.\n\nFrom-SVN: r156661", "tree": {"sha": "88ec53b5787238bd38592fc81959492719765e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88ec53b5787238bd38592fc81959492719765e0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b2524b12683ad95e582a4fc74ae19c6927a398d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2524b12683ad95e582a4fc74ae19c6927a398d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b2524b12683ad95e582a4fc74ae19c6927a398d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2524b12683ad95e582a4fc74ae19c6927a398d/comments", "author": null, "committer": null, "parents": [{"sha": "45406a12e9b888ad287fd56f279591718ac2ac2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45406a12e9b888ad287fd56f279591718ac2ac2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45406a12e9b888ad287fd56f279591718ac2ac2b"}], "stats": {"total": 5619, "additions": 4921, "deletions": 698}, "files": [{"sha": "5b5672e243cd720e7a3343f92bde57b47ea070f4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,3 +1,67 @@\n+2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/bits/hashtable.h: Fold in include/tr1_impl/hashtable.h\n+\tfor C++0x use.\n+\t* include/bits/hashtable_policy.h: New, copy and adjust for\n+\tC++0x use, include/tr1_impl/hashtable_policy.h; fix erase and\n+\tinsert member functions per n3000.\n+\t* include/bits/unordered_map.h: Likewise for include/tr1_impl/\n+\tunordered_map.\n+\t* include/bits/unordered_set.h: Likewise for include/tr1_impl/\n+\tunordered_set.\n+\t* include/Makefile.am: Adjust.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/tr1/unordered_map: Adjust.\n+\t* include/tr1/unordered_set: Likewise.\n+\t* include/tr1_impl/unordered_map: Adjust, now used only by tr1.\n+\t* include/tr1_impl/hashtable: Likewise.\n+\t* include/tr1_impl/hashtable_policy.h: Likewise.\n+\t* include/tr1_impl/unordered_set: Likewise.\n+\t* include/std/unordered_map: Adjust and simplify includes.\n+\t* include/std/unordered_set: Likewise.\n+\t* include/debug/unordered_map: Adjuse erase and insert members.\n+\t* include/debug/unordered_set: Likewise.\n+\t* include/profile/unordered_map: Likewise.\n+\t* include/profile/unordered_set: Likewise.\n+\t* testsuite/util/exception/safety.h: Fix for the updated erase and\n+\tinsert member functions of the unordered_containers.\n+\t* testsuite/23_containers/unordered_map/erase/1.cc: New.\n+\t* testsuite/23_containers/unordered_map/erase/24061-map.cc: Likewise.\n+\t* testsuite/23_containers/unordered_map/insert/map_single.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_map/insert/array_syntax.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_map/insert/24061-map.cc: Likewise.\n+\t* testsuite/23_containers/unordered_map/insert/map_range.cc: Likewise.\n+\t* testsuite/23_containers/set/operators/1_neg.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/erase/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/erase/\n+\t24061-multimap.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/insert/\n+\t24061-multimap.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/insert/\n+\tmultimap_range.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/insert/\n+\tmultimap_single.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/erase/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/erase/24061-set.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/insert/set_single.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/insert/24061-set.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/insert/set_range.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/erase/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/erase/\n+\t24061-multiset.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/insert/\n+\t24061-multiset.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/insert/\n+\tmultiset_range.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/insert/\n+\tmultiset_single.cc: Likewise.\n+\n+\t* testsuite/23_containers/set/operators/1_neg.cc: Tweak dg-errors\n+\tto avoid spurious fails in debug-mode.\n+\t* testsuite/23_containers/map/operators/1_neg.cc: Likewise.\n+\n 2010-02-09  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/std/streambuf: Adjust doxygen group markup."}, {"sha": "167871507dd285adb0de0b88586fb1aafac9d163", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n #o# Makefile for the include subdirectory of the GNU C++ Standard library.\n ##\n-## Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+## Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n ## Free Software Foundation, Inc.\n ##\n ## This file is part of the libstdc++ version 3 distribution.\n@@ -102,6 +102,7 @@ bits_headers = \\\n \t${bits_srcdir}/gslice.h \\\n \t${bits_srcdir}/gslice_array.h \\\n \t${bits_srcdir}/hashtable.h \\\n+\t${bits_srcdir}/hashtable_policy.h \\\n \t${bits_srcdir}/indirect_array.h \\\n \t${bits_srcdir}/ios_base.h \\\n \t${bits_srcdir}/istream.tcc \\\n@@ -154,6 +155,8 @@ bits_headers = \\\n \t${bits_srcdir}/streambuf.tcc \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/unique_ptr.h \\\n+\t${bits_srcdir}/unordered_map.h \\\n+\t${bits_srcdir}/unordered_set.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n \t${bits_srcdir}/valarray_before.h \\"}, {"sha": "cd6e5c5349601aadd4c4b1e491241d340ddb8b45", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -344,6 +344,7 @@ bits_headers = \\\n \t${bits_srcdir}/gslice.h \\\n \t${bits_srcdir}/gslice_array.h \\\n \t${bits_srcdir}/hashtable.h \\\n+\t${bits_srcdir}/hashtable_policy.h \\\n \t${bits_srcdir}/indirect_array.h \\\n \t${bits_srcdir}/ios_base.h \\\n \t${bits_srcdir}/istream.tcc \\\n@@ -396,6 +397,8 @@ bits_headers = \\\n \t${bits_srcdir}/streambuf.tcc \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/unique_ptr.h \\\n+\t${bits_srcdir}/unordered_map.h \\\n+\t${bits_srcdir}/unordered_set.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n \t${bits_srcdir}/valarray_before.h \\"}, {"sha": "96bb8ac63e66031db77bb0318ec14b85e92b9999", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 1148, "deletions": 23, "changes": 1171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n // hashtable.h header -*- C++ -*-\n \n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,27 +32,1152 @@\n \n #pragma GCC system_header\n \n-#ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n-#endif\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/hashtable>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/hashtable>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+#include <bits/hashtable_policy.h>\n \n-#endif // _HASHTABLE_H\n+namespace std\n+{\n+  // Class template _Hashtable, class definition.\n+  \n+  // Meaning of class template _Hashtable's template parameters\n+  \n+  // _Key and _Value: arbitrary CopyConstructible types.\n+  \n+  // _Allocator: an allocator type ([lib.allocator.requirements]) whose\n+  // value type is Value.  As a conforming extension, we allow for\n+  // value type != Value.\n+\n+  // _ExtractKey: function object that takes a object of type Value\n+  // and returns a value of type _Key.\n+  \n+  // _Equal: function object that takes two objects of type k and returns\n+  // a bool-like value that is true if the two objects are considered equal.\n+  \n+  // _H1: the hash function.  A unary function object with argument type\n+  // Key and result type size_t.  Return values should be distributed\n+  // over the entire range [0, numeric_limits<size_t>:::max()].\n+  \n+  // _H2: the range-hashing function (in the terminology of Tavori and\n+  // Dreizin).  A binary function object whose argument types and result\n+  // type are all size_t.  Given arguments r and N, the return value is\n+  // in the range [0, N).\n+  \n+  // _Hash: the ranged hash function (Tavori and Dreizin). A binary function\n+  // whose argument types are _Key and size_t and whose result type is\n+  // size_t.  Given arguments k and N, the return value is in the range\n+  // [0, N).  Default: hash(k, N) = h2(h1(k), N).  If _Hash is anything other\n+  // than the default, _H1 and _H2 are ignored.\n+  \n+  // _RehashPolicy: Policy class with three members, all of which govern\n+  // the bucket count. _M_next_bkt(n) returns a bucket count no smaller\n+  // than n.  _M_bkt_for_elements(n) returns a bucket count appropriate\n+  // for an element count of n.  _M_need_rehash(n_bkt, n_elt, n_ins)\n+  // determines whether, if the current bucket count is n_bkt and the\n+  // current element count is n_elt, we need to increase the bucket\n+  // count.  If so, returns make_pair(true, n), where n is the new\n+  // bucket count.  If not, returns make_pair(false, <anything>).\n+  \n+  // ??? Right now it is hard-wired that the number of buckets never\n+  // shrinks.  Should we allow _RehashPolicy to change that?\n+  \n+  // __cache_hash_code: bool.  true if we store the value of the hash\n+  // function along with the value.  This is a time-space tradeoff.\n+  // Storing it may improve lookup speed by reducing the number of times\n+  // we need to call the Equal function.\n+  \n+  // __constant_iterators: bool.  true if iterator and const_iterator are\n+  // both constant iterator types.  This is true for unordered_set and\n+  // unordered_multiset, false for unordered_map and unordered_multimap.\n+  \n+  // __unique_keys: bool.  true if the return value of _Hashtable::count(k)\n+  // is always at most one, false if it may be an arbitrary number.  This\n+  // true for unordered_set and unordered_map, false for unordered_multiset\n+  // and unordered_multimap.\n+  \n+  template<typename _Key, typename _Value, typename _Allocator,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, \n+\t   typename _RehashPolicy,\n+\t   bool __cache_hash_code,\n+\t   bool __constant_iterators,\n+\t   bool __unique_keys>\n+    class _Hashtable\n+    : public __detail::_Rehash_base<_RehashPolicy,\n+\t\t\t\t    _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t\t       _ExtractKey,\n+\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t       _RehashPolicy,\n+\t\t\t\t\t       __cache_hash_code,\n+\t\t\t\t\t       __constant_iterators,\n+\t\t\t\t\t       __unique_keys> >,\n+      public __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t       _H1, _H2, _Hash, __cache_hash_code>,\n+      public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,\n+\t\t\t\t _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t\t    _ExtractKey,\n+\t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t    _RehashPolicy,\n+\t\t\t\t\t    __cache_hash_code,\n+\t\t\t\t\t    __constant_iterators,\n+\t\t\t\t\t    __unique_keys> >\n+    {\n+    public:\n+      typedef _Allocator                                  allocator_type;\n+      typedef _Value                                      value_type;\n+      typedef _Key                                        key_type;\n+      typedef _Equal                                      key_equal;\n+      // mapped_type, if present, comes from _Map_base.\n+      // hasher, if present, comes from _Hash_code_base.\n+      typedef typename _Allocator::difference_type        difference_type;\n+      typedef typename _Allocator::size_type              size_type;\n+      typedef typename _Allocator::pointer                pointer;\n+      typedef typename _Allocator::const_pointer          const_pointer;\n+      typedef typename _Allocator::reference              reference;\n+      typedef typename _Allocator::const_reference        const_reference;\n+      \n+      typedef __detail::_Node_iterator<value_type, __constant_iterators,\n+\t\t\t\t       __cache_hash_code>\n+                                                          local_iterator;\n+      typedef __detail::_Node_const_iterator<value_type,\n+\t\t\t\t\t     __constant_iterators,\n+\t\t\t\t\t     __cache_hash_code>\n+                                                          const_local_iterator;\n+\n+      typedef __detail::_Hashtable_iterator<value_type, __constant_iterators,\n+\t\t\t\t\t    __cache_hash_code>\n+                                                          iterator;\n+      typedef __detail::_Hashtable_const_iterator<value_type,\n+\t\t\t\t\t\t  __constant_iterators,\n+\t\t\t\t\t\t  __cache_hash_code>\n+                                                          const_iterator;\n+\n+      template<typename _Key2, typename _Value2, typename _Ex2, bool __unique2,\n+\t       typename _Hashtable2>\n+        friend struct __detail::_Map_base;\n+\n+    private:\n+      typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;\n+      typedef typename _Allocator::template rebind<_Node>::other\n+                                                        _Node_allocator_type;\n+      typedef typename _Allocator::template rebind<_Node*>::other\n+                                                        _Bucket_allocator_type;\n+\n+      typedef typename _Allocator::template rebind<_Value>::other\n+                                                        _Value_allocator_type;\n+\n+      _Node_allocator_type   _M_node_allocator;\n+      _Node**                _M_buckets;\n+      size_type              _M_bucket_count;\n+      size_type              _M_element_count;\n+      _RehashPolicy          _M_rehash_policy;\n+      \n+      _Node*\n+      _M_allocate_node(const value_type& __v);\n+  \n+      void\n+      _M_deallocate_node(_Node* __n);\n+  \n+      void\n+      _M_deallocate_nodes(_Node**, size_type);\n+\n+      _Node**\n+      _M_allocate_buckets(size_type __n);\n+  \n+      void\n+      _M_deallocate_buckets(_Node**, size_type __n);\n+\n+    public:\t\t\t    \n+      // Constructor, destructor, assignment, swap\n+      _Hashtable(size_type __bucket_hint,\n+\t\t const _H1&, const _H2&, const _Hash&,\n+\t\t const _Equal&, const _ExtractKey&,\n+\t\t const allocator_type&);\n+  \n+      template<typename _InputIterator>\n+        _Hashtable(_InputIterator __first, _InputIterator __last,\n+\t\t   size_type __bucket_hint,\n+\t\t   const _H1&, const _H2&, const _Hash&, \n+\t\t   const _Equal&, const _ExtractKey&,\n+\t\t   const allocator_type&);\n+  \n+      _Hashtable(const _Hashtable&);\n+\n+      _Hashtable(_Hashtable&&);\n+      \n+      _Hashtable&\n+      operator=(const _Hashtable&);\n+\n+      ~_Hashtable();\n+\n+      void swap(_Hashtable&);\n+\n+      // Basic container operations\n+      iterator\n+      begin()\n+      {\n+\titerator __i(_M_buckets);\n+\tif (!__i._M_cur_node)\n+\t  __i._M_incr_bucket();\n+\treturn __i;\n+      }\n+\n+      const_iterator\n+      begin() const\n+      {\n+\tconst_iterator __i(_M_buckets);\n+\tif (!__i._M_cur_node)\n+\t  __i._M_incr_bucket();\n+\treturn __i;\n+      }\n+\n+      iterator\n+      end()\n+      { return iterator(_M_buckets + _M_bucket_count); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_M_buckets + _M_bucket_count); }\n+\n+      const_iterator\n+      cbegin() const\n+      {\n+\tconst_iterator __i(_M_buckets);\n+\tif (!__i._M_cur_node)\n+\t  __i._M_incr_bucket();\n+\treturn __i;\n+      }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_M_buckets + _M_bucket_count); }\n+\n+      size_type\n+      size() const\n+      { return _M_element_count; }\n+  \n+      bool\n+      empty() const\n+      { return size() == 0; }\n+\n+      allocator_type\n+      get_allocator() const\n+      { return allocator_type(_M_node_allocator); }\n+\n+      _Value_allocator_type\n+      _M_get_Value_allocator() const\n+      { return _Value_allocator_type(_M_node_allocator); }\n+\n+      size_type\n+      max_size() const\n+      { return _M_node_allocator.max_size(); }\n+\n+      // Observers\n+      key_equal\n+      key_eq() const\n+      { return this->_M_eq; }\n+\n+      // hash_function, if present, comes from _Hash_code_base.\n+\n+      // Bucket operations\n+      size_type\n+      bucket_count() const\n+      { return _M_bucket_count; }\n+  \n+      size_type\n+      max_bucket_count() const\n+      { return max_size(); }\n+  \n+      size_type\n+      bucket_size(size_type __n) const\n+      { return std::distance(begin(__n), end(__n)); }\n+  \n+      size_type\n+      bucket(const key_type& __k) const\n+      { \n+\treturn this->_M_bucket_index(__k, this->_M_hash_code(__k),\n+\t\t\t\t     bucket_count());\n+      }\n+\n+      local_iterator\n+      begin(size_type __n)\n+      { return local_iterator(_M_buckets[__n]); }\n+\n+      local_iterator\n+      end(size_type)\n+      { return local_iterator(0); }\n+\n+      const_local_iterator\n+      begin(size_type __n) const\n+      { return const_local_iterator(_M_buckets[__n]); }\n+\n+      const_local_iterator\n+      end(size_type) const\n+      { return const_local_iterator(0); }\n+\n+      // DR 691.\n+      const_local_iterator\n+      cbegin(size_type __n) const\n+      { return const_local_iterator(_M_buckets[__n]); }\n+\n+      const_local_iterator\n+      cend(size_type) const\n+      { return const_local_iterator(0); }\n+\n+      float\n+      load_factor() const\n+      { \n+\treturn static_cast<float>(size()) / static_cast<float>(bucket_count());\n+      }\n+\n+      // max_load_factor, if present, comes from _Rehash_base.\n+\n+      // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n+      // useful if _RehashPolicy is something other than the default.\n+      const _RehashPolicy&\n+      __rehash_policy() const\n+      { return _M_rehash_policy; }\n+      \n+      void \n+      __rehash_policy(const _RehashPolicy&);\n+\n+      // Lookup.\n+      iterator\n+      find(const key_type& __k);\n+\n+      const_iterator\n+      find(const key_type& __k) const;\n+\n+      size_type\n+      count(const key_type& __k) const;\n+\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __k);\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __k) const;\n+\n+    private:\t\t\t// Find, insert and erase helper functions\n+      // ??? This dispatching is a workaround for the fact that we don't\n+      // have partial specialization of member templates; it would be\n+      // better to just specialize insert on __unique_keys.  There may be a\n+      // cleaner workaround.\n+      typedef typename std::conditional<__unique_keys,\n+\t\t\t\t\tstd::pair<iterator, bool>,\n+\t\t\t\t\titerator>::type\n+        _Insert_Return_Type;\n+\n+      typedef typename std::conditional<__unique_keys,\n+\t\t\t\t\tstd::_Select1st<_Insert_Return_Type>,\n+\t\t\t\t\tstd::_Identity<_Insert_Return_Type>\n+                                   >::type\n+        _Insert_Conv_Type;\n+\n+      _Node*\n+      _M_find_node(_Node*, const key_type&,\n+\t\t   typename _Hashtable::_Hash_code_type) const;\n+\n+      iterator\n+      _M_insert_bucket(const value_type&, size_type,\n+\t\t       typename _Hashtable::_Hash_code_type);\n+\n+      std::pair<iterator, bool>\n+      _M_insert(const value_type&, std::true_type);\n+\n+      iterator\n+      _M_insert(const value_type&, std::false_type);\n+\n+      void\n+      _M_erase_node(_Node*, _Node**);\n+\n+    public:\t\t\t\t\n+      // Insert and erase\n+      _Insert_Return_Type\n+      insert(const value_type& __v) \n+      { return _M_insert(__v, std::integral_constant<bool,\n+\t\t\t __unique_keys>()); }\n+\n+      iterator\n+      insert(const_iterator, const value_type& __v)\n+      { return iterator(_Insert_Conv_Type()(this->insert(__v))); }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last);\n+\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { this->insert(__l.begin(), __l.end()); }\n+\n+      iterator\n+      erase(const_iterator);\n+\n+      size_type\n+      erase(const key_type&);\n \n+      iterator\n+      erase(const_iterator, const_iterator);\n+\n+      void\n+      clear();\n+\n+      // Set number of buckets to be appropriate for container of n element.\n+      void rehash(size_type __n);\n+      \n+    private:\n+      // Unconditionally change size of bucket array to n.\n+      void _M_rehash(size_type __n);\n+    };\n+\n+\n+  // Definitions of class template _Hashtable's out-of-line member functions.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node*\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_allocate_node(const value_type& __v)\n+    {\n+      _Node* __n = _M_node_allocator.allocate(1);\n+      __try\n+\t{\n+\t  _M_node_allocator.construct(__n, __v);\n+\t  __n->_M_next = 0;\n+\t  return __n;\n+\t}\n+      __catch(...)\n+\t{\n+\t  _M_node_allocator.deallocate(__n, 1);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_node(_Node* __n)\n+    {\n+      _M_node_allocator.destroy(__n);\n+      _M_node_allocator.deallocate(__n, 1);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_nodes(_Node** __array, size_type __n)\n+    {\n+      for (size_type __i = 0; __i < __n; ++__i)\n+\t{\n+\t  _Node* __p = __array[__i];\n+\t  while (__p)\n+\t    {\n+\t      _Node* __tmp = __p;\n+\t      __p = __p->_M_next;\n+\t      _M_deallocate_node(__tmp);\n+\t    }\n+\t  __array[__i] = 0;\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node**\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_allocate_buckets(size_type __n)\n+    {\n+      _Bucket_allocator_type __alloc(_M_node_allocator);\n+\n+      // We allocate one extra bucket to hold a sentinel, an arbitrary\n+      // non-null pointer.  Iterator increment relies on this.\n+      _Node** __p = __alloc.allocate(__n + 1);\n+      std::fill(__p, __p + __n, (_Node*) 0);\n+      __p[__n] = reinterpret_cast<_Node*>(0x1000);\n+      return __p;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_buckets(_Node** __p, size_type __n)\n+    {\n+      _Bucket_allocator_type __alloc(_M_node_allocator);\n+      __alloc.deallocate(__p, __n + 1);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(size_type __bucket_hint,\n+\t       const _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t       const _Equal& __eq, const _ExtractKey& __exk,\n+\t       const allocator_type& __a)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__exk, __eq,\n+\t\t\t\t\t\t\t__h1, __h2, __h),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+      _M_node_allocator(__a),\n+      _M_bucket_count(0),\n+      _M_element_count(0),\n+      _M_rehash_policy()\n+    {\n+      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename _InputIterator>\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _Hashtable(_InputIterator __f, _InputIterator __l,\n+\t\t size_type __bucket_hint,\n+\t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t\t const _Equal& __eq, const _ExtractKey& __exk,\n+\t\t const allocator_type& __a)\n+      : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n+\t__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t  _H1, _H2, _Hash, __chc>(__exk, __eq,\n+\t\t\t\t\t\t\t  __h1, __h2, __h),\n+\t__detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+\t_M_node_allocator(__a),\n+\t_M_bucket_count(0),\n+\t_M_element_count(0),\n+\t_M_rehash_policy()\n+      {\n+\t_M_bucket_count = std::max(_M_rehash_policy._M_next_bkt(__bucket_hint),\n+\t\t\t\t   _M_rehash_policy.\n+\t\t\t\t   _M_bkt_for_elements(__detail::\n+\t\t\t\t\t\t       __distance_fw(__f,\n+\t\t\t\t\t\t\t\t     __l)));\n+\t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n+\t__try\n+\t  {\n+\t    for (; __f != __l; ++__f)\n+\t      this->insert(*__f);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    clear();\n+\t    _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+  \n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(const _Hashtable& __ht)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n+      _M_node_allocator(__ht._M_node_allocator),\n+      _M_bucket_count(__ht._M_bucket_count),\n+      _M_element_count(__ht._M_element_count),\n+      _M_rehash_policy(__ht._M_rehash_policy)\n+    {\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n+      __try\n+\t{\n+\t  for (size_type __i = 0; __i < __ht._M_bucket_count; ++__i)\n+\t    {\n+\t      _Node* __n = __ht._M_buckets[__i];\n+\t      _Node** __tail = _M_buckets + __i;\n+\t      while (__n)\n+\t\t{\n+\t\t  *__tail = _M_allocate_node(__n->_M_v);\n+\t\t  this->_M_copy_code(*__tail, __n);\n+\t\t  __tail = &((*__tail)->_M_next);\n+\t\t  __n = __n->_M_next;\n+\t\t}\n+\t    }\n+\t}\n+      __catch(...)\n+\t{\n+\t  clear();\n+\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(_Hashtable&& __ht)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n+      _M_node_allocator(__ht._M_node_allocator),\n+      _M_bucket_count(__ht._M_bucket_count),\n+      _M_element_count(__ht._M_element_count),\n+      _M_rehash_policy(__ht._M_rehash_policy),\n+      _M_buckets(__ht._M_buckets)\n+    {\n+      size_type __n_bkt = __ht._M_rehash_policy._M_next_bkt(0);\n+      __ht._M_buckets = __ht._M_allocate_buckets(__n_bkt);\n+      __ht._M_bucket_count = __n_bkt;\n+      __ht._M_element_count = 0;\n+      __ht._M_rehash_policy = _RehashPolicy();\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>&\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    operator=(const _Hashtable& __ht)\n+    {\n+      _Hashtable __tmp(__ht);\n+      this->swap(__tmp);\n+      return *this;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    ~_Hashtable()\n+    {\n+      clear();\n+      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    swap(_Hashtable& __x)\n+    {\n+      // The only base class with member variables is hash_code_base.  We\n+      // define _Hash_code_base::_M_swap because different specializations\n+      // have different members.\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t_H1, _H2, _Hash, __chc>::_M_swap(__x);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator,\n+\t\t\t\t\t\t\t__x._M_node_allocator);\n+\n+      std::swap(_M_rehash_policy, __x._M_rehash_policy);\n+      std::swap(_M_buckets, __x._M_buckets);\n+      std::swap(_M_bucket_count, __x._M_bucket_count);\n+      std::swap(_M_element_count, __x._M_element_count);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    __rehash_policy(const _RehashPolicy& __pol)\n+    {\n+      _M_rehash_policy = __pol;\n+      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);\n+      if (__n_bkt > _M_bucket_count)\n+\t_M_rehash(__n_bkt);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    find(const key_type& __k)\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n+      return __p ? iterator(__p, _M_buckets + __n) : this->end();\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::const_iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    find(const key_type& __k) const\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n+      return __p ? const_iterator(__p, _M_buckets + __n) : this->end();\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::size_type\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    count(const key_type& __k) const\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __result = 0;\n+      for (_Node* __p = _M_buckets[__n]; __p; __p = __p->_M_next)\n+\tif (this->_M_compare(__k, __code, __p))\n+\t  ++__result;\n+      return __result;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator,\n+\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    equal_range(const key_type& __k)\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node** __head = _M_buckets + __n;\n+      _Node* __p = _M_find_node(*__head, __k, __code);\n+      \n+      if (__p)\n+\t{\n+\t  _Node* __p1 = __p->_M_next;\n+\t  for (; __p1; __p1 = __p1->_M_next)\n+\t    if (!this->_M_compare(__k, __code, __p1))\n+\t      break;\n+\n+\t  iterator __first(__p, __head);\n+\t  iterator __last(__p1, __head);\n+\t  if (!__p1)\n+\t    __last._M_incr_bucket();\n+\t  return std::make_pair(__first, __last);\n+\t}\n+      else\n+\treturn std::make_pair(this->end(), this->end());\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::const_iterator,\n+\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::const_iterator>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    equal_range(const key_type& __k) const\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node** __head = _M_buckets + __n;\n+      _Node* __p = _M_find_node(*__head, __k, __code);\n+\n+      if (__p)\n+\t{\n+\t  _Node* __p1 = __p->_M_next;\n+\t  for (; __p1; __p1 = __p1->_M_next)\n+\t    if (!this->_M_compare(__k, __code, __p1))\n+\t      break;\n+\n+\t  const_iterator __first(__p, __head);\n+\t  const_iterator __last(__p1, __head);\n+\t  if (!__p1)\n+\t    __last._M_incr_bucket();\n+\t  return std::make_pair(__first, __last);\n+\t}\n+      else\n+\treturn std::make_pair(this->end(), this->end());\n+    }\n+\n+  // Find the node whose key compares equal to k, beginning the search\n+  // at p (usually the head of a bucket).  Return nil if no node is found.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n+\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node* \n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_find_node(_Node* __p, const key_type& __k,\n+\t\ttypename _Hashtable::_Hash_code_type __code) const\n+    {\n+      for (; __p; __p = __p->_M_next)\n+\tif (this->_M_compare(__k, __code, __p))\n+\t  return __p;\n+      return false;\n+    }\n+\n+  // Insert v in bucket n (assumes no element with its key already present).\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert_bucket(const value_type& __v, size_type __n,\n+\t\t     typename _Hashtable::_Hash_code_type __code)\n+    {\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t  _M_element_count, 1);\n+\n+      // Allocate the new node before doing the rehash so that we don't\n+      // do a rehash if the allocation throws.\n+      _Node* __new_node = _M_allocate_node(__v);\n+\n+      __try\n+\t{\n+\t  if (__do_rehash.first)\n+\t    {\n+\t      const key_type& __k = this->_M_extract(__v);\n+\t      __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n+\t      _M_rehash(__do_rehash.second);\n+\t    }\n+\n+\t  __new_node->_M_next = _M_buckets[__n];\n+\t  this->_M_store_code(__new_node, __code);\n+\t  _M_buckets[__n] = __new_node;\n+\t  ++_M_element_count;\n+\t  return iterator(__new_node, _M_buckets + __n);\n+\t}\n+      __catch(...)\n+\t{\n+\t  _M_deallocate_node(__new_node);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  // Insert v if no element with its key is already present.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator, bool>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert(const value_type& __v, std::true_type)\n+    {\n+      const key_type& __k = this->_M_extract(__v);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\n+      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))\n+\treturn std::make_pair(iterator(__p, _M_buckets + __n), false);\n+      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);\n+    }\n+\n+  // Insert v unconditionally.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert(const value_type& __v, std::false_type)\n+    {\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t  _M_element_count, 1);\n+      if (__do_rehash.first)\n+\t_M_rehash(__do_rehash.second);\n+ \n+      const key_type& __k = this->_M_extract(__v);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\n+      // First find the node, avoid leaking new_node if compare throws.\n+      _Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);\n+      _Node* __new_node = _M_allocate_node(__v);\n+\n+      if (__prev)\n+\t{\n+\t  __new_node->_M_next = __prev->_M_next;\n+\t  __prev->_M_next = __new_node;\n+\t}\n+      else\n+\t{\n+\t  __new_node->_M_next = _M_buckets[__n];\n+\t  _M_buckets[__n] = __new_node;\n+\t}\n+      this->_M_store_code(__new_node, __code);\n+\n+      ++_M_element_count;\n+      return iterator(__new_node, _M_buckets + __n);\n+    }\n+\n+  // For erase(iterator) and erase(const_iterator).\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_erase_node(_Node* __p, _Node** __b)\n+    {\n+      _Node* __cur = *__b;\n+      if (__cur == __p)\n+\t*__b = __cur->_M_next;\n+      else\n+\t{\n+\t  _Node* __next = __cur->_M_next;\n+\t  while (__next != __p)\n+\t    {\n+\t      __cur = __next;\n+\t      __next = __cur->_M_next;\n+\t    }\n+\t  __cur->_M_next = __next->_M_next;\n+\t}\n+\n+      _M_deallocate_node(__p);\n+      --_M_element_count;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename _InputIterator>\n+      void \n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      insert(_InputIterator __first, _InputIterator __last)\n+      {\n+\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n+\tstd::pair<bool, std::size_t> __do_rehash\n+\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t    _M_element_count, __n_elt);\n+\tif (__do_rehash.first)\n+\t  _M_rehash(__do_rehash.second);\n+\n+\tfor (; __first != __last; ++__first)\n+\t  this->insert(*__first);\n+      }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const_iterator __it)\n+    {\n+      iterator __result(__it._M_cur_node, __it._M_cur_bucket);\n+      ++__result;\n+      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n+      return __result;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::size_type\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const key_type& __k)\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      size_type __result = 0;\n+      \n+      _Node** __slot = _M_buckets + __n;\n+      while (*__slot && !this->_M_compare(__k, __code, *__slot))\n+\t__slot = &((*__slot)->_M_next);\n+\n+      _Node** __saved_slot = 0;\n+      while (*__slot && this->_M_compare(__k, __code, *__slot))\n+\t{\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 526. Is it undefined if a function in the standard changes\n+\t  // in parameters?\n+\t  if (&this->_M_extract((*__slot)->_M_v) != &__k)\n+\t    {\n+              _Node* __p = *__slot;\n+              *__slot = __p->_M_next;\n+\t      _M_deallocate_node(__p);\n+\t      --_M_element_count;\n+\t      ++__result;\n+\t    }\n+\t  else\n+\t    {\n+\t      __saved_slot = __slot;\n+\t      __slot = &((*__slot)->_M_next);\n+\t    }\n+\t}\n+\n+      if (__saved_slot)\n+\t{\n+\t  _Node* __p = *__saved_slot;\n+\t  *__saved_slot = __p->_M_next;\n+\t  _M_deallocate_node(__p);\n+\t  --_M_element_count;\n+\t  ++__result;\n+\t}\n+\n+      return __result;\n+    }\n+\n+  // ??? This could be optimized by taking advantage of the bucket\n+  // structure, but it's not clear that it's worth doing.  It probably\n+  // wouldn't even be an optimization unless the load factor is large.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const_iterator __first, const_iterator __last)\n+    {\n+      while (__first != __last)\n+\t__first = this->erase(__first);\n+      return iterator(__last._M_cur_node, __last._M_cur_bucket);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    clear()\n+    {\n+      _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n+      _M_element_count = 0;\n+    }\n+ \n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    rehash(size_type __n)\n+    {\n+      _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),\n+\t\t\t _M_rehash_policy._M_bkt_for_elements(_M_element_count\n+\t\t\t\t\t\t\t      + 1)));\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_rehash(size_type __n)\n+    {\n+      _Node** __new_array = _M_allocate_buckets(__n);\n+      __try\n+\t{\n+\t  for (size_type __i = 0; __i < _M_bucket_count; ++__i)\n+\t    while (_Node* __p = _M_buckets[__i])\n+\t      {\n+\t\tstd::size_t __new_index = this->_M_bucket_index(__p, __n);\n+\t\t_M_buckets[__i] = __p->_M_next;\n+\t\t__p->_M_next = __new_array[__new_index];\n+\t\t__new_array[__new_index] = __p;\n+\t      }\n+\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t  _M_bucket_count = __n;\n+\t  _M_buckets = __new_array;\n+\t}\n+      __catch(...)\n+\t{\n+\t  // A failure here means that a hash function threw an exception.\n+\t  // We can't restore the previous state without calling the hash\n+\t  // function again, so the only sensible recovery is to delete\n+\t  // everything.\n+\t  _M_deallocate_nodes(__new_array, __n);\n+\t  _M_deallocate_buckets(__new_array, __n);\n+\t  _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n+\t  _M_element_count = 0;\n+\t  __throw_exception_again;\n+\t}\n+    }\n+}\n+\n+#endif // _HASHTABLE_H"}, {"sha": "4eccc889682486225cf7cf045fc3b281187be7fd", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "added", "additions": 854, "deletions": 0, "changes": 854, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,854 @@\n+// Internal policy header for unordered_set and unordered_map -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/hashtable_policy.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _HASHTABLE_POLICY_H\n+#define _HASHTABLE_POLICY_H 1\n+\n+namespace std\n+{\n+namespace __detail\n+{\n+  // Helper function: return distance(first, last) for forward\n+  // iterators, or 0 for input iterators.\n+  template<class _Iterator>\n+    inline typename std::iterator_traits<_Iterator>::difference_type\n+    __distance_fw(_Iterator __first, _Iterator __last,\n+\t\t  std::input_iterator_tag)\n+    { return 0; }\n+\n+  template<class _Iterator>\n+    inline typename std::iterator_traits<_Iterator>::difference_type\n+    __distance_fw(_Iterator __first, _Iterator __last,\n+\t\t  std::forward_iterator_tag)\n+    { return std::distance(__first, __last); }\n+\n+  template<class _Iterator>\n+    inline typename std::iterator_traits<_Iterator>::difference_type\n+    __distance_fw(_Iterator __first, _Iterator __last)\n+    {\n+      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;\n+      return __distance_fw(__first, __last, _Tag());\n+    }\n+\n+  template<typename _RAIter, typename _Tp>\n+    _RAIter\n+    __lower_bound(_RAIter __first, _RAIter __last, const _Tp& __val)\n+    {\n+      typedef typename std::iterator_traits<_RAIter>::difference_type _DType;\n+\n+      _DType __len = __last - __first;\n+      while (__len > 0)\n+\t{\n+\t  _DType __half = __len >> 1;\n+\t  _RAIter __middle = __first + __half;\n+\t  if (*__middle < __val)\n+\t    {\n+\t      __first = __middle;\n+\t      ++__first;\n+\t      __len = __len - __half - 1;\n+\t    }\n+\t  else\n+\t    __len = __half;\n+\t}\n+      return __first;\n+    }\n+\n+  // Auxiliary types used for all instantiations of _Hashtable: nodes\n+  // and iterators.\n+  \n+  // Nodes, used to wrap elements stored in the hash table.  A policy\n+  // template parameter of class template _Hashtable controls whether\n+  // nodes also store a hash code. In some cases (e.g. strings) this\n+  // may be a performance win.\n+  template<typename _Value, bool __cache_hash_code>\n+    struct _Hash_node;\n+\n+  template<typename _Value>\n+    struct _Hash_node<_Value, true>\n+    {\n+      _Value       _M_v;\n+      std::size_t  _M_hash_code;\n+      _Hash_node*  _M_next;\n+\n+      template<typename... _Args>\n+        _Hash_node(_Args&&... __args)\n+\t: _M_v(std::forward<_Args>(__args)...),\n+\t  _M_hash_code(), _M_next() { }\n+    };\n+\n+  template<typename _Value>\n+    struct _Hash_node<_Value, false>\n+    {\n+      _Value       _M_v;\n+      _Hash_node*  _M_next;\n+\n+      template<typename... _Args>\n+        _Hash_node(_Args&&... __args)\n+\t: _M_v(std::forward<_Args>(__args)...),\n+\t  _M_next() { }\n+    };\n+\n+  // Local iterators, used to iterate within a bucket but not between\n+  // buckets.\n+  template<typename _Value, bool __cache>\n+    struct _Node_iterator_base\n+    {\n+      _Node_iterator_base(_Hash_node<_Value, __cache>* __p)\n+      : _M_cur(__p) { }\n+      \n+      void\n+      _M_incr()\n+      { _M_cur = _M_cur->_M_next; }\n+\n+      _Hash_node<_Value, __cache>*  _M_cur;\n+    };\n+\n+  template<typename _Value, bool __cache>\n+    inline bool\n+    operator==(const _Node_iterator_base<_Value, __cache>& __x,\n+\t       const _Node_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur == __y._M_cur; }\n+\n+  template<typename _Value, bool __cache>\n+    inline bool\n+    operator!=(const _Node_iterator_base<_Value, __cache>& __x,\n+\t       const _Node_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur != __y._M_cur; }\n+\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Node_iterator\n+    : public _Node_iterator_base<_Value, __cache>\n+    {\n+      typedef _Value                                   value_type;\n+      typedef typename std::conditional<__constant_iterators,\n+\t\t\t\t\tconst _Value*, _Value*>::type\n+                                                       pointer;\n+      typedef typename std::conditional<__constant_iterators,\n+\t\t\t\t\tconst _Value&, _Value&>::type\n+                                                       reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      _Node_iterator()\n+      : _Node_iterator_base<_Value, __cache>(0) { }\n+\n+      explicit\n+      _Node_iterator(_Hash_node<_Value, __cache>* __p)\n+      : _Node_iterator_base<_Value, __cache>(__p) { }\n+\n+      reference\n+      operator*() const\n+      { return this->_M_cur->_M_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->_M_cur->_M_v; }\n+\n+      _Node_iterator&\n+      operator++()\n+      { \n+\tthis->_M_incr();\n+\treturn *this; \n+      }\n+  \n+      _Node_iterator\n+      operator++(int)\n+      { \n+\t_Node_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n+      }\n+    };\n+\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Node_const_iterator\n+    : public _Node_iterator_base<_Value, __cache>\n+    {\n+      typedef _Value                                   value_type;\n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      _Node_const_iterator()\n+      : _Node_iterator_base<_Value, __cache>(0) { }\n+\n+      explicit\n+      _Node_const_iterator(_Hash_node<_Value, __cache>* __p)\n+      : _Node_iterator_base<_Value, __cache>(__p) { }\n+\n+      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,\n+\t\t\t   __cache>& __x)\n+      : _Node_iterator_base<_Value, __cache>(__x._M_cur) { }\n+\n+      reference\n+      operator*() const\n+      { return this->_M_cur->_M_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->_M_cur->_M_v; }\n+\n+      _Node_const_iterator&\n+      operator++()\n+      { \n+\tthis->_M_incr();\n+\treturn *this; \n+      }\n+  \n+      _Node_const_iterator\n+      operator++(int)\n+      { \n+\t_Node_const_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n+      }\n+    };\n+\n+  template<typename _Value, bool __cache>\n+    struct _Hashtable_iterator_base\n+    {\n+      _Hashtable_iterator_base(_Hash_node<_Value, __cache>* __node,\n+\t\t\t       _Hash_node<_Value, __cache>** __bucket)\n+      : _M_cur_node(__node), _M_cur_bucket(__bucket) { }\n+\n+      void\n+      _M_incr()\n+      {\n+\t_M_cur_node = _M_cur_node->_M_next;\n+\tif (!_M_cur_node)\n+\t  _M_incr_bucket();\n+      }\n+\n+      void\n+      _M_incr_bucket();\n+\n+      _Hash_node<_Value, __cache>*   _M_cur_node;\n+      _Hash_node<_Value, __cache>**  _M_cur_bucket;\n+    };\n+\n+  // Global iterators, used for arbitrary iteration within a hash\n+  // table.  Larger and more expensive than local iterators.\n+  template<typename _Value, bool __cache>\n+    void\n+    _Hashtable_iterator_base<_Value, __cache>::\n+    _M_incr_bucket()\n+    {\n+      ++_M_cur_bucket;\n+\n+      // This loop requires the bucket array to have a non-null sentinel.\n+      while (!*_M_cur_bucket)\n+\t++_M_cur_bucket;\n+      _M_cur_node = *_M_cur_bucket;\n+    }\n+\n+  template<typename _Value, bool __cache>\n+    inline bool\n+    operator==(const _Hashtable_iterator_base<_Value, __cache>& __x,\n+\t       const _Hashtable_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur_node == __y._M_cur_node; }\n+\n+  template<typename _Value, bool __cache>\n+    inline bool\n+    operator!=(const _Hashtable_iterator_base<_Value, __cache>& __x,\n+\t       const _Hashtable_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur_node != __y._M_cur_node; }\n+\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Hashtable_iterator\n+    : public _Hashtable_iterator_base<_Value, __cache>\n+    {\n+      typedef _Value                                   value_type;\n+      typedef typename std::conditional<__constant_iterators,\n+\t\t\t\t\tconst _Value*, _Value*>::type\n+                                                       pointer;\n+      typedef typename std::conditional<__constant_iterators,\n+\t\t\t\t\tconst _Value&, _Value&>::type\n+                                                       reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      _Hashtable_iterator()\n+      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }\n+\n+      _Hashtable_iterator(_Hash_node<_Value, __cache>* __p,\n+\t\t\t  _Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }\n+\n+      explicit\n+      _Hashtable_iterator(_Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }\n+\n+      reference\n+      operator*() const\n+      { return this->_M_cur_node->_M_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->_M_cur_node->_M_v; }\n+\n+      _Hashtable_iterator&\n+      operator++()\n+      { \n+\tthis->_M_incr();\n+\treturn *this;\n+      }\n+  \n+      _Hashtable_iterator\n+      operator++(int)\n+      { \n+\t_Hashtable_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n+      }\n+    };\n+\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Hashtable_const_iterator\n+    : public _Hashtable_iterator_base<_Value, __cache>\n+    {\n+      typedef _Value                                   value_type;\n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      _Hashtable_const_iterator()\n+      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }\n+\n+      _Hashtable_const_iterator(_Hash_node<_Value, __cache>* __p,\n+\t\t\t\t_Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }\n+\n+      explicit\n+      _Hashtable_const_iterator(_Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }\n+\n+      _Hashtable_const_iterator(const _Hashtable_iterator<_Value,\n+\t\t\t\t__constant_iterators, __cache>& __x)\n+      : _Hashtable_iterator_base<_Value, __cache>(__x._M_cur_node,\n+\t\t\t\t\t\t  __x._M_cur_bucket) { }\n+\n+      reference\n+      operator*() const\n+      { return this->_M_cur_node->_M_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->_M_cur_node->_M_v; }\n+\n+      _Hashtable_const_iterator&\n+      operator++()\n+      { \n+\tthis->_M_incr();\n+\treturn *this;\n+      }\n+  \n+      _Hashtable_const_iterator\n+      operator++(int)\n+      { \n+\t_Hashtable_const_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n+      }\n+    };\n+\n+\n+  // Many of class template _Hashtable's template parameters are policy\n+  // classes.  These are defaults for the policies.\n+\n+  // Default range hashing function: use division to fold a large number\n+  // into the range [0, N).\n+  struct _Mod_range_hashing\n+  {\n+    typedef std::size_t first_argument_type;\n+    typedef std::size_t second_argument_type;\n+    typedef std::size_t result_type;\n+\n+    result_type\n+    operator()(first_argument_type __num, second_argument_type __den) const\n+    { return __num % __den; }\n+  };\n+\n+  // Default ranged hash function H.  In principle it should be a\n+  // function object composed from objects of type H1 and H2 such that\n+  // h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n+  // h1 and h2.  So instead we'll just use a tag to tell class template\n+  // hashtable to do that composition.\n+  struct _Default_ranged_hash { };\n+\n+  // Default value for rehash policy.  Bucket size is (usually) the\n+  // smallest prime that keeps the load factor small enough.\n+  struct _Prime_rehash_policy\n+  {\n+    _Prime_rehash_policy(float __z = 1.0)\n+    : _M_max_load_factor(__z), _M_growth_factor(2.f), _M_next_resize(0) { }\n+\n+    float\n+    max_load_factor() const\n+    { return _M_max_load_factor; }      \n+\n+    // Return a bucket size no smaller than n.\n+    std::size_t\n+    _M_next_bkt(std::size_t __n) const;\n+    \n+    // Return a bucket count appropriate for n elements\n+    std::size_t\n+    _M_bkt_for_elements(std::size_t __n) const;\n+    \n+    // __n_bkt is current bucket count, __n_elt is current element count,\n+    // and __n_ins is number of elements to be inserted.  Do we need to\n+    // increase bucket count?  If so, return make_pair(true, n), where n\n+    // is the new bucket count.  If not, return make_pair(false, 0).\n+    std::pair<bool, std::size_t>\n+    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n+\t\t   std::size_t __n_ins) const;\n+\n+    enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };\n+\n+    float                _M_max_load_factor;\n+    float                _M_growth_factor;\n+    mutable std::size_t  _M_next_resize;\n+  };\n+\n+  extern const unsigned long __prime_list[];\n+\n+  // XXX This is a hack.  There's no good reason for any of\n+  // _Prime_rehash_policy's member functions to be inline.  \n+\n+  // Return a prime no smaller than n.\n+  inline std::size_t\n+  _Prime_rehash_policy::\n+  _M_next_bkt(std::size_t __n) const\n+  {\n+    const unsigned long* __p = __lower_bound(__prime_list, __prime_list\n+\t\t\t\t\t     + _S_n_primes, __n);\n+    _M_next_resize = \n+      static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));\n+    return *__p;\n+  }\n+\n+  // Return the smallest prime p such that alpha p >= n, where alpha\n+  // is the load factor.\n+  inline std::size_t\n+  _Prime_rehash_policy::\n+  _M_bkt_for_elements(std::size_t __n) const\n+  {\n+    const float __min_bkts = __n / _M_max_load_factor;\n+    const unsigned long* __p = __lower_bound(__prime_list, __prime_list\n+\t\t\t\t\t     + _S_n_primes, __min_bkts);\n+    _M_next_resize =\n+      static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));\n+    return *__p;\n+  }\n+\n+  // Finds the smallest prime p such that alpha p > __n_elt + __n_ins.\n+  // If p > __n_bkt, return make_pair(true, p); otherwise return\n+  // make_pair(false, 0).  In principle this isn't very different from \n+  // _M_bkt_for_elements.\n+\n+  // The only tricky part is that we're caching the element count at\n+  // which we need to rehash, so we don't have to do a floating-point\n+  // multiply for every insertion.\n+\n+  inline std::pair<bool, std::size_t>\n+  _Prime_rehash_policy::\n+  _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n+\t\t std::size_t __n_ins) const\n+  {\n+    if (__n_elt + __n_ins > _M_next_resize)\n+      {\n+\tfloat __min_bkts = ((float(__n_ins) + float(__n_elt))\n+\t\t\t    / _M_max_load_factor);\n+\tif (__min_bkts > __n_bkt)\n+\t  {\n+\t    __min_bkts = std::max(__min_bkts, _M_growth_factor * __n_bkt);\n+\t    const unsigned long* __p =\n+\t      __lower_bound(__prime_list, __prime_list + _S_n_primes,\n+\t\t\t    __min_bkts);\n+\t    _M_next_resize = static_cast<std::size_t>\n+\t      (__builtin_ceil(*__p * _M_max_load_factor));\n+\t    return std::make_pair(true, *__p);\n+\t  }\n+\telse \n+\t  {\n+\t    _M_next_resize = static_cast<std::size_t>\n+\t      (__builtin_ceil(__n_bkt * _M_max_load_factor));\n+\t    return std::make_pair(false, 0);\n+\t  }\n+      }\n+    else\n+      return std::make_pair(false, 0);\n+  }\n+\n+  // Base classes for std::tr1::_Hashtable.  We define these base\n+  // classes because in some cases we want to do different things\n+  // depending on the value of a policy class.  In some cases the\n+  // policy class affects which member functions and nested typedefs\n+  // are defined; we handle that by specializing base class templates.\n+  // Several of the base class templates need to access other members\n+  // of class template _Hashtable, so we use the \"curiously recurring\n+  // template pattern\" for them.\n+\n+  // class template _Map_base.  If the hashtable has a value type of the\n+  // form pair<T1, T2> and a key extraction policy that returns the\n+  // first part of the pair, the hashtable gets a mapped_type typedef.\n+  // If it satisfies those criteria and also has unique keys, then it\n+  // also gets an operator[].  \n+  template<typename _Key, typename _Value, typename _Ex, bool __unique,\n+\t   typename _Hashtable>\n+    struct _Map_base { };\n+\t  \n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, false, _Hashtable>\n+    {\n+      typedef typename _Pair::second_type mapped_type;\n+    };\n+\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>\n+    {\n+      typedef typename _Pair::second_type mapped_type;\n+      \n+      mapped_type&\n+      operator[](const _Key& __k);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 761. unordered_map needs an at() member function.\n+      mapped_type&\n+      at(const _Key& __k);\n+\n+      const mapped_type&\n+      at(const _Key& __k) const;\n+    };\n+\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n+\t\t       true, _Hashtable>::mapped_type&\n+    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n+    operator[](const _Key& __k)\n+    {\n+      _Hashtable* __h = static_cast<_Hashtable*>(this);\n+      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code,\n+\t\t\t\t\t     __h->_M_bucket_count);\n+\n+      typename _Hashtable::_Node* __p =\n+\t__h->_M_find_node(__h->_M_buckets[__n], __k, __code);\n+      if (!__p)\n+\treturn __h->_M_insert_bucket(std::make_pair(__k, mapped_type()),\n+\t\t\t\t     __n, __code)->second;\n+      return (__p->_M_v).second;\n+    }\n+\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n+\t\t       true, _Hashtable>::mapped_type&\n+    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n+    at(const _Key& __k)\n+    {\n+      _Hashtable* __h = static_cast<_Hashtable*>(this);\n+      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code,\n+\t\t\t\t\t     __h->_M_bucket_count);\n+\n+      typename _Hashtable::_Node* __p =\n+\t__h->_M_find_node(__h->_M_buckets[__n], __k, __code);\n+      if (!__p)\n+\t__throw_out_of_range(__N(\"_Map_base::at\"));\n+      return (__p->_M_v).second;\n+    }\n+\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    const typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n+\t\t\t     true, _Hashtable>::mapped_type&\n+    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n+    at(const _Key& __k) const\n+    {\n+      const _Hashtable* __h = static_cast<const _Hashtable*>(this);\n+      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code,\n+\t\t\t\t\t     __h->_M_bucket_count);\n+\n+      typename _Hashtable::_Node* __p =\n+\t__h->_M_find_node(__h->_M_buckets[__n], __k, __code);\n+      if (!__p)\n+\t__throw_out_of_range(__N(\"_Map_base::at\"));\n+      return (__p->_M_v).second;\n+    }\n+\n+  // class template _Rehash_base.  Give hashtable the max_load_factor\n+  // functions iff the rehash policy is _Prime_rehash_policy.\n+  template<typename _RehashPolicy, typename _Hashtable>\n+    struct _Rehash_base { };\n+\n+  template<typename _Hashtable>\n+    struct _Rehash_base<_Prime_rehash_policy, _Hashtable>\n+    {\n+      float\n+      max_load_factor() const\n+      {\n+\tconst _Hashtable* __this = static_cast<const _Hashtable*>(this);\n+\treturn __this->__rehash_policy().max_load_factor();\n+      }\n+\n+      void\n+      max_load_factor(float __z)\n+      {\n+\t_Hashtable* __this = static_cast<_Hashtable*>(this);\n+\t__this->__rehash_policy(_Prime_rehash_policy(__z));\n+      }\n+    };\n+\n+  // Class template _Hash_code_base.  Encapsulates two policy issues that\n+  // aren't quite orthogonal.\n+  //   (1) the difference between using a ranged hash function and using\n+  //       the combination of a hash function and a range-hashing function.\n+  //       In the former case we don't have such things as hash codes, so\n+  //       we have a dummy type as placeholder.\n+  //   (2) Whether or not we cache hash codes.  Caching hash codes is\n+  //       meaningless if we have a ranged hash function.\n+  // We also put the key extraction and equality comparison function \n+  // objects here, for convenience.\n+  \n+  // Primary template: unused except as a hook for specializations.  \n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   bool __cache_hash_code>\n+    struct _Hash_code_base;\n+\n+  // Specialization: ranged hash function, no caching hash codes.  H1\n+  // and H2 are provided but ignored.  We define a dummy hash code type.\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Hash, false>\n+    {\n+    protected:\n+      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+\t\t      const _H1&, const _H2&, const _Hash& __h)\n+      : _M_extract(__ex), _M_eq(__eq), _M_ranged_hash(__h) { }\n+\n+      typedef void* _Hash_code_type;\n+  \n+      _Hash_code_type\n+      _M_hash_code(const _Key& __key) const\n+      { return 0; }\n+  \n+      std::size_t\n+      _M_bucket_index(const _Key& __k, _Hash_code_type,\n+\t\t      std::size_t __n) const\n+      { return _M_ranged_hash(__k, __n); }\n+\n+      std::size_t\n+      _M_bucket_index(const _Hash_node<_Value, false>* __p,\n+\t\t      std::size_t __n) const\n+      { return _M_ranged_hash(_M_extract(__p->_M_v), __n); }\n+  \n+      bool\n+      _M_compare(const _Key& __k, _Hash_code_type,\n+\t\t _Hash_node<_Value, false>* __n) const\n+      { return _M_eq(__k, _M_extract(__n->_M_v)); }\n+\n+      void\n+      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n+      { }\n+\n+      void\n+      _M_copy_code(_Hash_node<_Value, false>*,\n+\t\t   const _Hash_node<_Value, false>*) const\n+      { }\n+      \n+      void\n+      _M_swap(_Hash_code_base& __x)\n+      {\n+\tstd::swap(_M_extract, __x._M_extract);\n+\tstd::swap(_M_eq, __x._M_eq);\n+\tstd::swap(_M_ranged_hash, __x._M_ranged_hash);\n+      }\n+\n+    protected:\n+      _ExtractKey  _M_extract;\n+      _Equal       _M_eq;\n+      _Hash        _M_ranged_hash;\n+    };\n+\n+\n+  // No specialization for ranged hash function while caching hash codes.\n+  // That combination is meaningless, and trying to do it is an error.\n+  \n+  \n+  // Specialization: ranged hash function, cache hash codes.  This\n+  // combination is meaningless, so we provide only a declaration\n+  // and no definition.  \n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Hash, true>;\n+\n+  // Specialization: hash function and range-hashing function, no\n+  // caching of hash codes.  H is provided but ignored.  Provides\n+  // typedef and accessor required by TR1.  \n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Default_ranged_hash, false>\n+    {\n+      typedef _H1 hasher;\n+\n+      hasher\n+      hash_function() const\n+      { return _M_h1; }\n+\n+    protected:\n+      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+\t\t      const _H1& __h1, const _H2& __h2,\n+\t\t      const _Default_ranged_hash&)\n+      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }\n+\n+      typedef std::size_t _Hash_code_type;\n+\n+      _Hash_code_type\n+      _M_hash_code(const _Key& __k) const\n+      { return _M_h1(__k); }\n+      \n+      std::size_t\n+      _M_bucket_index(const _Key&, _Hash_code_type __c,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(__c, __n); }\n+\n+      std::size_t\n+      _M_bucket_index(const _Hash_node<_Value, false>* __p,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(_M_h1(_M_extract(__p->_M_v)), __n); }\n+\n+      bool\n+      _M_compare(const _Key& __k, _Hash_code_type,\n+\t\t _Hash_node<_Value, false>* __n) const\n+      { return _M_eq(__k, _M_extract(__n->_M_v)); }\n+\n+      void\n+      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n+      { }\n+\n+      void\n+      _M_copy_code(_Hash_node<_Value, false>*,\n+\t\t   const _Hash_node<_Value, false>*) const\n+      { }\n+\n+      void\n+      _M_swap(_Hash_code_base& __x)\n+      {\n+\tstd::swap(_M_extract, __x._M_extract);\n+\tstd::swap(_M_eq, __x._M_eq);\n+\tstd::swap(_M_h1, __x._M_h1);\n+\tstd::swap(_M_h2, __x._M_h2);\n+      }\n+\n+    protected:\n+      _ExtractKey  _M_extract;\n+      _Equal       _M_eq;\n+      _H1          _M_h1;\n+      _H2          _M_h2;\n+    };\n+\n+  // Specialization: hash function and range-hashing function, \n+  // caching hash codes.  H is provided but ignored.  Provides\n+  // typedef and accessor required by TR1.\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Default_ranged_hash, true>\n+    {\n+      typedef _H1 hasher;\n+      \n+      hasher\n+      hash_function() const\n+      { return _M_h1; }\n+\n+    protected:\n+      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+\t\t      const _H1& __h1, const _H2& __h2,\n+\t\t      const _Default_ranged_hash&)\n+      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }\n+\n+      typedef std::size_t _Hash_code_type;\n+  \n+      _Hash_code_type\n+      _M_hash_code(const _Key& __k) const\n+      { return _M_h1(__k); }\n+  \n+      std::size_t\n+      _M_bucket_index(const _Key&, _Hash_code_type __c,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(__c, __n); }\n+\n+      std::size_t\n+      _M_bucket_index(const _Hash_node<_Value, true>* __p,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(__p->_M_hash_code, __n); }\n+\n+      bool\n+      _M_compare(const _Key& __k, _Hash_code_type __c,\n+\t\t _Hash_node<_Value, true>* __n) const\n+      { return __c == __n->_M_hash_code && _M_eq(__k, _M_extract(__n->_M_v)); }\n+\n+      void\n+      _M_store_code(_Hash_node<_Value, true>* __n, _Hash_code_type __c) const\n+      { __n->_M_hash_code = __c; }\n+\n+      void\n+      _M_copy_code(_Hash_node<_Value, true>* __to,\n+\t\t   const _Hash_node<_Value, true>* __from) const\n+      { __to->_M_hash_code = __from->_M_hash_code; }\n+\n+      void\n+      _M_swap(_Hash_code_base& __x)\n+      {\n+\tstd::swap(_M_extract, __x._M_extract);\n+\tstd::swap(_M_eq, __x._M_eq);\n+\tstd::swap(_M_h1, __x._M_h1);\n+\tstd::swap(_M_h2, __x._M_h2);\n+      }\n+      \n+    protected:\n+      _ExtractKey  _M_extract;\n+      _Equal       _M_eq;\n+      _H1          _M_h1;\n+      _H2          _M_h2;\n+    };\n+} // namespace __detail\n+}\n+\n+#endif // _HASHTABLE_POLICY_H"}, {"sha": "77236d3aca6f9da1f1e9f77a57e6be9351ea0d3e", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,340 @@\n+// unordered_map implementation -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/unordered_map.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _UNORDERED_MAP_H\n+#define _UNORDERED_MAP_H\n+\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n+\n+  // XXX When we get typedef templates these class definitions\n+  // will be unnecessary.\n+  template<class _Key, class _Tp,\n+\t   class _Hash = hash<_Key>,\n+\t   class _Pred = std::equal_to<_Key>,\n+\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n+\t   bool __cache_hash_code = false>\n+    class __unordered_map\n+    : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n+\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred, \n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, false, true>\n+    {\n+      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n+\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, false, true>\n+        _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+\n+      explicit\n+      __unordered_map(size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(),\n+\t\t      const key_equal& __eql = key_equal(),\n+\t\t      const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(),\n+\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        __unordered_map(_InputIterator __f, _InputIterator __l, \n+\t\t\tsize_type __n = 10,\n+\t\t\tconst hasher& __hf = hasher(), \n+\t\t\tconst key_equal& __eql = key_equal(), \n+\t\t\tconst allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(),\n+\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+\t{ }\n+\n+      __unordered_map(__unordered_map&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+    };\n+  \n+  template<class _Key, class _Tp,\n+\t   class _Hash = hash<_Key>,\n+\t   class _Pred = std::equal_to<_Key>,\n+\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n+\t   bool __cache_hash_code = false>\n+    class __unordered_multimap\n+    : public _Hashtable<_Key, std::pair<const _Key, _Tp>,\n+\t\t\t_Alloc,\n+\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, false, false>\n+    {\n+      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>,\n+\t\t\t _Alloc,\n+\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, false, false>\n+        _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      \n+      explicit\n+      __unordered_multimap(size_type __n = 10,\n+\t\t\t   const hasher& __hf = hasher(),\n+\t\t\t   const key_equal& __eql = key_equal(),\n+\t\t\t   const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(),\n+\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+      { }\n+\n+\n+      template<typename _InputIterator>\n+        __unordered_multimap(_InputIterator __f, _InputIterator __l, \n+\t\t\t     typename _Base::size_type __n = 0,\n+\t\t\t     const hasher& __hf = hasher(), \n+\t\t\t     const key_equal& __eql = key_equal(), \n+\t\t\t     const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(),\n+\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+        { }\n+\n+      __unordered_multimap(__unordered_multimap&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+    };\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline void\n+    swap(__unordered_map<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __x,\n+\t __unordered_map<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline void\n+    swap(__unordered_multimap<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __x,\n+\t __unordered_multimap<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n+\n+\n+  /**\n+   *  @brief A standard container composed of unique keys (containing\n+   *  at most one of each key value) that associates values of another type\n+   *  with the keys.\n+   *\n+   *  @ingroup unordered_associative_containers\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n+   *  <a href=\"tables.html#xx\">unordered associative container</a>\n+   *\n+   *  @param  Key  Type of key objects.\n+   *  @param  Tp  Type of mapped objects.\n+   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n+   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n+   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   *\n+   * The resulting value type of the container is std::pair<const Key, Tp>.\n+   */\n+  template<class _Key, class _Tp,\n+\t   class _Hash = hash<_Key>,\n+\t   class _Pred = std::equal_to<_Key>,\n+\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n+    class unordered_map\n+    : public __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n+    {\n+      typedef __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n+\n+    public:\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+\n+      explicit\n+      unordered_map(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        unordered_map(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_map(unordered_map&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_map(initializer_list<value_type> __l,\n+\t\t    size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+      { }\n+\n+      unordered_map&\n+      operator=(unordered_map&& __x)\n+      {\n+\t// NB: DR 1204.\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\t\n+      }\n+\n+      unordered_map&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l.begin(), __l.end());\n+\treturn *this;\n+      }\n+    };\n+  \n+  /**\n+   *  @brief A standard container composed of equivalent keys\n+   *  (possibly containing multiple of each key value) that associates\n+   *  values of another type with the keys.\n+   *\n+   *  @ingroup unordered_associative_containers\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n+   *  <a href=\"tables.html#xx\">unordered associative container</a>\n+   *\n+   *  @param  Key  Type of key objects.\n+   *  @param  Tp  Type of mapped objects.\n+   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n+   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n+   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   *\n+   * The resulting value type of the container is std::pair<const Key, Tp>.\n+   */\n+  template<class _Key, class _Tp,\n+\t   class _Hash = hash<_Key>,\n+\t   class _Pred = std::equal_to<_Key>,\n+\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n+    class unordered_multimap\n+    : public __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n+    {\n+      typedef __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n+\n+    public:\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      \n+      explicit\n+      unordered_multimap(size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      { }\n+\n+\n+      template<typename _InputIterator>\n+        unordered_multimap(_InputIterator __f, _InputIterator __l, \n+\t\t\t   typename _Base::size_type __n = 0,\n+\t\t\t   const hasher& __hf = hasher(), \n+\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_multimap(unordered_multimap&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_multimap(initializer_list<value_type> __l,\n+\t\t\t size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+      { }\n+\n+      unordered_multimap&\n+      operator=(unordered_multimap&& __x)\n+      {\n+\t// NB: DR 1204.\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\t\n+      }\n+\n+      unordered_multimap&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l.begin(), __l.end());\n+\treturn *this;\n+      }\n+    };\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+_GLIBCXX_END_NESTED_NAMESPACE\n+\n+#endif /* _UNORDERED_MAP_H */"}, {"sha": "a20fbf4b05d52645d7e7aeff820ad4a9ed60273c", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,331 @@\n+// unordered_set implementation -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/unordered_set.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _UNORDERED_SET_H\n+#define _UNORDERED_SET_H\n+\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n+\n+  // XXX When we get typedef templates these class definitions\n+  // will be unnecessary.\n+  template<class _Value,\n+\t   class _Hash = hash<_Value>,\n+\t   class _Pred = std::equal_to<_Value>,\n+\t   class _Alloc = std::allocator<_Value>,\n+\t   bool __cache_hash_code = false>\n+    class __unordered_set\n+    : public _Hashtable<_Value, _Value, _Alloc,\n+\t\t\tstd::_Identity<_Value>, _Pred,\n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, true, true>\n+    {\n+      typedef _Hashtable<_Value, _Value, _Alloc,\n+\t\t\t std::_Identity<_Value>, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, true, true>\n+        _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      \n+      explicit\n+      __unordered_set(size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(),\n+\t\t      const key_equal& __eql = key_equal(),\n+\t\t      const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(), __eql,\n+\t      std::_Identity<_Value>(), __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        __unordered_set(_InputIterator __f, _InputIterator __l, \n+\t\t\tsize_type __n = 10,\n+\t\t\tconst hasher& __hf = hasher(), \n+\t\t\tconst key_equal& __eql = key_equal(), \n+\t\t\tconst allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(), __eql,\n+\t\tstd::_Identity<_Value>(), __a)\n+        { }\n+\n+      __unordered_set(__unordered_set&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+    };\n+\n+  template<class _Value,\n+\t   class _Hash = hash<_Value>,\n+\t   class _Pred = std::equal_to<_Value>,\n+\t   class _Alloc = std::allocator<_Value>,\n+\t   bool __cache_hash_code = false>\n+    class __unordered_multiset\n+    : public _Hashtable<_Value, _Value, _Alloc,\n+\t\t\tstd::_Identity<_Value>, _Pred,\n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, true, false>\n+    {\n+      typedef _Hashtable<_Value, _Value, _Alloc,\n+\t\t\t std::_Identity<_Value>, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, true, false>\n+        _Base;\n+\n+    public:\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      \n+      explicit\n+      __unordered_multiset(size_type __n = 10,\n+\t\t\t   const hasher& __hf = hasher(),\n+\t\t\t   const key_equal& __eql = key_equal(),\n+\t\t\t   const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(), __eql,\n+\t      std::_Identity<_Value>(), __a)\n+      { }\n+\n+\n+      template<typename _InputIterator>\n+        __unordered_multiset(_InputIterator __f, _InputIterator __l, \n+\t\t\t     typename _Base::size_type __n = 0,\n+\t\t\t     const hasher& __hf = hasher(), \n+\t\t\t     const key_equal& __eql = key_equal(), \n+\t\t\t     const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(), __eql,\n+\t\tstd::_Identity<_Value>(), __a)\n+        { }\n+\n+      __unordered_multiset(__unordered_multiset&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+    };\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline void\n+    swap(__unordered_set<_Value, _Hash, _Pred, _Alloc, __cache_hash_code>& __x,\n+\t __unordered_set<_Value, _Hash, _Pred, _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline void\n+    swap(__unordered_multiset<_Value, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __x,\n+\t __unordered_multiset<_Value, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n+\n+\n+  /**\n+   *  @brief A standard container composed of unique keys (containing\n+   *  at most one of each key value) in which the elements' keys are\n+   *  the elements themselves.\n+   *\n+   *  @ingroup unordered_associative_containers\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n+   *  <a href=\"tables.html#xx\">unordered associative container</a>\n+   *\n+   *  @param  Value  Type of key objects.\n+   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n+   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n+   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   */\n+  template<class _Value,\n+\t   class _Hash = hash<_Value>,\n+\t   class _Pred = std::equal_to<_Value>,\n+\t   class _Alloc = std::allocator<_Value> >\n+    class unordered_set\n+    : public __unordered_set<_Value, _Hash, _Pred, _Alloc>\n+    {\n+      typedef __unordered_set<_Value, _Hash, _Pred, _Alloc>  _Base;\n+\n+    public:\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      \n+      explicit\n+      unordered_set(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        unordered_set(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_set(unordered_set&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_set(initializer_list<value_type> __l,\n+\t\t    size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+      { }\n+\n+      unordered_set&\n+      operator=(unordered_set&& __x)\n+      {\n+\t// NB: DR 1204.\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\t\n+      }\n+\n+      unordered_set&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l.begin(), __l.end());\n+\treturn *this;\n+      }\n+    };\n+\n+  /**\n+   *  @brief A standard container composed of equivalent keys\n+   *  (possibly containing multiple of each key value) in which the\n+   *  elements' keys are the elements themselves.\n+   *\n+   *  @ingroup unordered_associative_containers\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n+   *  <a href=\"tables.html#xx\">unordered associative container</a>\n+   *\n+   *  @param  Value  Type of key objects.\n+   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n+   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n+   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   */\n+  template<class _Value,\n+\t   class _Hash = hash<_Value>,\n+\t   class _Pred = std::equal_to<_Value>,\n+\t   class _Alloc = std::allocator<_Value> >\n+    class unordered_multiset\n+    : public __unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n+    {\n+      typedef __unordered_multiset<_Value, _Hash, _Pred, _Alloc>  _Base;\n+\n+    public:\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+      \n+      explicit\n+      unordered_multiset(size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a)\n+      { }\n+\n+\n+      template<typename _InputIterator>\n+        unordered_multiset(_InputIterator __f, _InputIterator __l, \n+\t\t\t   typename _Base::size_type __n = 0,\n+\t\t\t   const hasher& __hf = hasher(), \n+\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_multiset(unordered_multiset&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_multiset(initializer_list<value_type> __l,\n+\t\t\t size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n+      { }\n+\n+      unordered_multiset&\n+      operator=(unordered_multiset&& __x)\n+      {\n+\t// NB: DR 1204.\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x);\n+\treturn *this;\t\n+      }\n+\n+      unordered_multiset&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l.begin(), __l.end());\n+\treturn *this;\n+      }\n+    };\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+_GLIBCXX_END_NESTED_NAMESPACE\n+\n+#endif /* _UNORDERED_SET_H */\n+"}, {"sha": "53ce7c0961910f8e46845a20464ae31fb3fc8495", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 8, "deletions": 62, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -183,19 +183,11 @@ namespace __debug\n       }\n \n       iterator\n-      insert(iterator, const value_type& __obj)\n-      {\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t__pair_type __res = _Base::insert(__obj);\n-\treturn iterator(__res.first, this);\n-      }\n-\n-      const_iterator\n       insert(const_iterator, const value_type& __obj)\n       {\n \ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n \t__pair_type __res = _Base::insert(__obj);\n-\treturn const_iterator(__res.first, this);\n+\treturn iterator(__res.first, this);\n       }\n \n       void\n@@ -252,35 +244,14 @@ namespace __debug\n       }\n \n       iterator\n-      erase(iterator __it)\n-      {\n-\t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n-\treturn iterator(_Base::erase(__it.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n \t__it._M_invalidate();\n-\treturn const_iterator(_Base::erase(__it.base()), this);\n+\treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n-      erase(iterator __first, iterator __last)\n-      {\n-\t__glibcxx_check_erase_range(__first, __last);\n-\tfor (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n@@ -289,8 +260,8 @@ namespace __debug\n \t  const_iterator __victim = __tmp++;\n \t  __victim._M_invalidate();\n \t}\n-\treturn const_iterator(_Base::erase(__first.base(),\n-\t\t\t\t\t   __last.base()), this);\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n       }\n \n       _Base&\n@@ -453,12 +424,8 @@ namespace __debug\n       { return iterator(_Base::insert(__obj), this); }\n \n       iterator\n-      insert(iterator, const value_type& __obj)\n-      { return iterator(_Base::insert(__obj), this); }\n-\n-      const_iterator\n       insert(const_iterator, const value_type& __obj)\n-      { return const_iterator(_Base::insert(__obj), this); }\n+      { return iterator(_Base::insert(__obj), this); }\n \n       void\n       insert(std::initializer_list<value_type> __l)\n@@ -514,35 +481,14 @@ namespace __debug\n       }\n \n       iterator\n-      erase(iterator __it)\n-      {\n-\t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n-\treturn iterator(_Base::erase(__it.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n \t__it._M_invalidate();\n-\treturn const_iterator(_Base::erase(__it.base()), this);\n+\treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n-      erase(iterator __first, iterator __last)\n-      {\n-\t__glibcxx_check_erase_range(__first, __last);\n-\tfor (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n@@ -551,8 +497,8 @@ namespace __debug\n \t  const_iterator __victim = __tmp++;\n \t  __victim._M_invalidate();\n \t}\n-\treturn const_iterator(_Base::erase(__first.base(),\n-\t\t\t\t\t   __last.base()), this);\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n       }\n \n       _Base&"}, {"sha": "19ff42408fdb9bef9f4137206b4aa70465010b4e", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 8, "deletions": 62, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -183,19 +183,11 @@ namespace __debug\n       }\n \n       iterator\n-      insert(iterator, const value_type& __obj)\n-      {\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t__pair_type __res = _Base::insert(__obj);\n-\treturn iterator(__res.first, this);\n-      }\n-\n-      const_iterator\n       insert(const_iterator, const value_type& __obj)\n       {\n \ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n \t__pair_type __res = _Base::insert(__obj);\n-\treturn const_iterator(__res.first, this);\n+\treturn iterator(__res.first, this);\n       }\n \n       void\n@@ -252,35 +244,14 @@ namespace __debug\n       }\n \n       iterator\n-      erase(iterator __it)\n-      {\n-\t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n-\treturn iterator(_Base::erase(__it.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n \t__it._M_invalidate();\n-\treturn const_iterator(_Base::erase(__it.base()), this);\n+\treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n-      erase(iterator __first, iterator __last)\n-      {\n-\t__glibcxx_check_erase_range(__first, __last);\n-\tfor (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n@@ -289,8 +260,8 @@ namespace __debug\n \t  const_iterator __victim = __tmp++;\n \t  __victim._M_invalidate();\n \t}\n-\treturn const_iterator(_Base::erase(__first.base(),\n-\t\t\t\t\t   __last.base()), this);\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n       }\n \n       _Base&\n@@ -451,12 +422,8 @@ namespace __debug\n       { return iterator(_Base::insert(__obj), this); }\n \n       iterator\n-      insert(iterator, const value_type& __obj)\n-      { return iterator(_Base::insert(__obj), this); }\n-\n-      const_iterator\n       insert(const_iterator, const value_type& __obj)\n-      { return const_iterator(_Base::insert(__obj), this); }\n+      { return iterator(_Base::insert(__obj), this); }\n \n       void\n       insert(std::initializer_list<value_type> __l)\n@@ -512,35 +479,14 @@ namespace __debug\n       }\n \n       iterator\n-      erase(iterator __it)\n-      {\n-\t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n-\treturn iterator(_Base::erase(__it.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n \t__it._M_invalidate();\n-\treturn const_iterator(_Base::erase(__it.base()), this);\n+\treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n-      erase(iterator __first, iterator __last)\n-      {\n-\t__glibcxx_check_erase_range(__first, __last);\n-\tfor (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n-      }\n-\n-      const_iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n@@ -549,8 +495,8 @@ namespace __debug\n \t  const_iterator __victim = __tmp++;\n \t  __victim._M_invalidate();\n \t}\n-\treturn const_iterator(_Base::erase(__first.base(),\n-\t\t\t\t\t   __last.base()), this);\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n       }\n \n       _Base&"}, {"sha": "61f32f3036f46f1c29b59bccd38f0ff184fb3d2b", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 71, "deletions": 83, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -186,31 +186,22 @@ namespace __profile\n       }\n \n       iterator\n-      insert(iterator __iter, const value_type& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        iterator res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size, _Base::bucket_count()); \n-        return res;\n-      }\n-\n-      const_iterator\n       insert(const_iterator __iter, const value_type& __v)\n       { \n         size_type __old_size = _Base::bucket_count(); \n-        const_iterator res =_Base::insert(__iter, __v);\n+        iterator __res = _Base::insert(__iter, __v);\n         _M_profile_resize(__old_size, _Base::bucket_count()); \n-        return res;\n+        return __res;\n       }\n \n       template<typename _InputIter>\n-      void\n-      insert(_InputIter __first, _InputIter __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first.base(), __last.base());\n-        _M_profile_resize(__old_size, _Base::bucket_count()); \n-      }\n+        void\n+        insert(_InputIter __first, _InputIter __last)\n+        {\n+\t  size_type __old_size = _Base::bucket_count(); \n+\t  _Base::insert(__first.base(), __last.base());\n+\t  _M_profile_resize(__old_size, _Base::bucket_count()); \n+\t}\n \n       void\n       insert(const value_type* __first, const value_type* __last)\n@@ -233,51 +224,54 @@ namespace __profile\n \n       void\n       swap(unordered_map& __x)\n-      {\n-        _Base::swap(__x);\n-      }\n-      \n+      { _Base::swap(__x); }\n+\n       void rehash(size_type __n)\n       {\n         size_type __old_size =  _Base::bucket_count();\n         _Base::rehash(__n);\n         _M_profile_resize(__old_size, _Base::bucket_count()); \n       }\n+\n     private:\n-      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      void\n+      _M_profile_resize(size_type __old_size, size_type __new_size)\n       {\n         if (__old_size != __new_size)\n-        {\n-          __profcxx_hashtable_resize(this, __old_size, __new_size);\n-        }\n+\t  __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n-      void _M_profile_destruct()\n+\n+      void\n+      _M_profile_destruct()\n       {\n         size_type __hops = 0, __lc = 0, __chain = 0;\n-        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n-        {\n-          while (it._M_cur_node->_M_next) {\n-             __chain++;\n-             it++;\n-          }\n-          if (__chain) {\n-            __chain++;\n-            __lc = __lc > __chain ? __lc : __chain;  \n-            __hops += __chain * (__chain - 1) / 2;\n-            __chain = 0;\n-          }\n-        }\n+        for (iterator __it = _M_base().begin(); __it != _M_base().end();\n+\t     ++__it)\n+\t  {\n+\t    while (__it._M_cur_node->_M_next)\n+\t      {\n+\t\t++__chain;\n+\t\t++__it;\n+\t      }\n+\t    if (__chain)\n+\t      {\n+\t\t++__chain;\n+\t\t__lc = __lc > __chain ? __lc : __chain;  \n+\t\t__hops += __chain * (__chain - 1) / 2;\n+\t\t__chain = 0;\n+\t      }\n+\t  }\n         __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops); \n       }\n    };\n+\n   template<typename _Key, typename _Tp, typename _Hash,\n-       typename _Pred, typename _Alloc>\n+\t   typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n-\n #undef _GLIBCXX_BASE\n #undef _GLIBCXX_STD_BASE\n #define _GLIBCXX_BASE unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n@@ -412,31 +406,22 @@ namespace __profile\n       }\n \n       iterator\n-      insert(iterator __iter, const value_type& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        iterator res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size, _Base::bucket_count()); \n-        return res;\n-      }\n-\n-      const_iterator\n       insert(const_iterator __iter, const value_type& __v)\n       { \n         size_type __old_size = _Base::bucket_count(); \n-        const_iterator res =_Base::insert(__iter, __v);\n+        iterator __res =_Base::insert(__iter, __v);\n         _M_profile_resize(__old_size, _Base::bucket_count()); \n-        return res;\n+        return __res;\n       }\n \n       template<typename _InputIter>\n-      void\n-      insert(_InputIter __first, _InputIter __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first.base(), __last.base());\n-        _M_profile_resize(__old_size, _Base::bucket_count()); \n-      }\n+        void\n+        insert(_InputIter __first, _InputIter __last)\n+        {\n+\t  size_type __old_size = _Base::bucket_count(); \n+\t  _Base::insert(__first.base(), __last.base());\n+\t  _M_profile_resize(__old_size, _Base::bucket_count()); \n+\t}\n \n       void\n       insert(const value_type* __first, const value_type* __last)\n@@ -448,50 +433,53 @@ namespace __profile\n \n       void\n       swap(unordered_multimap& __x)\n-      {\n-        _Base::swap(__x);\n-      }\n+      { _Base::swap(__x); }\n \n       void rehash(size_type __n)\n       {\n         size_type __old_size =  _Base::bucket_count();\n         _Base::rehash(__n);\n         _M_profile_resize(__old_size, _Base::bucket_count()); \n       }\n+\n     private:\n-      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      void\n+      _M_profile_resize(size_type __old_size, size_type __new_size)\n       {\n         if (__old_size != __new_size)\n-        {\n           __profcxx_hashtable_resize(this, __old_size, __new_size);\n-        }\n       }\n \n-      void _M_profile_destruct()\n+      void\n+      _M_profile_destruct()\n       {\n         size_type __hops = 0, __lc = 0, __chain = 0;\n-        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n-        {\n-          while (it._M_cur_node->_M_next) {\n-             __chain++;\n-             it++;\n-          }\n-          if (__chain) {\n-            __chain++;\n-            __lc = __lc > __chain ? __lc : __chain;\n-            __hops += __chain * (__chain - 1) / 2;\n-            __chain = 0;\n-          }\n-        }\n+        for (iterator __it = _M_base().begin(); __it != _M_base().end();\n+\t     ++__it)\n+\t  {\n+\t    while (__it._M_cur_node->_M_next)\n+\t      {\n+\t\t++__chain;\n+\t\t++__it;\n+\t      }\n+\t    if (__chain)\n+\t      {\n+\t\t++__chain;\n+\t\t__lc = __lc > __chain ? __lc : __chain;\n+\t\t__hops += __chain * (__chain - 1) / 2;\n+\t\t__chain = 0;\n+\t      }\n+\t  }\n         __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops);\n       }\n \n     };\n+\n   template<typename _Key, typename _Tp, typename _Hash,\n-       typename _Pred, typename _Alloc>\n+\t   typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n } // namespace __profile"}, {"sha": "0c0de77a58b25ee58cd0295ca1ad594eaad2207a", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 64, "deletions": 71, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -184,31 +184,22 @@ namespace __profile\n       }\n \n       iterator\n-      insert(iterator __iter, const value_type& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        iterator res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size,  _Base::bucket_count()); \n-        return res;\n-      }\n-\n-      const_iterator\n       insert(const_iterator __iter, const value_type& __v)\n       { \n         size_type __old_size = _Base::bucket_count(); \n-        const_iterator res =_Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size,  _Base::bucket_count()); \n-        return res;\n+        iterator __res = _Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return __res;\n       }\n \n       template<typename _InputIter>\n-      void\n-      insert(_InputIter __first, _InputIter __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first, __last);\n-        _M_profile_resize(__old_size,  _Base::bucket_count()); \n-      }\n+        void\n+        insert(_InputIter __first, _InputIter __last)\n+        {\n+\t  size_type __old_size = _Base::bucket_count(); \n+\t  _Base::insert(__first, __last);\n+\t  _M_profile_resize(__old_size,  _Base::bucket_count()); \n+\t}\n \n       void\n       insert(const value_type* __first, const value_type* __last)\n@@ -232,37 +223,43 @@ namespace __profile\n       const _Base&\n       _M_base() const { return *this; }\n \n-      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      void\n+      _M_profile_resize(size_type __old_size, size_type __new_size)\n       {\n         if (__old_size != __new_size)\n-        {\n-          __profcxx_hashtable_resize(this, __old_size, __new_size);\n-        }\n+\t  __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n-      void _M_profile_destruct()\n+\n+      void\n+      _M_profile_destruct()\n       {\n         size_type __hops = 0, __lc = 0, __chain = 0;\n-        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n+        for (iterator __it = _M_base().begin(); __it != _M_base().end();\n+\t     ++__it)\n         {\n-          while (it._M_cur_node->_M_next) {\n-             __chain++;\n-             it++;\n-          }\n-          if (__chain) {\n-            __chain++;\n-            __lc = __lc > __chain ? __lc : __chain;\n-            __hops += __chain * (__chain - 1) / 2;\n-            __chain = 0;\n-          }\n+          while (__it._M_cur_node->_M_next)\n+\t    {\n+\t      ++__chain;\n+\t      ++__it;\n+\t    }\n+\n+          if (__chain)\n+\t    {\n+\t      ++__chain;\n+\t      __lc = __lc > __chain ? __lc : __chain;\n+\t      __hops += __chain * (__chain - 1) / 2;\n+\t      __chain = 0;\n+\t    }\n         }\n         __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops);\n       }\n \n    };\n+\n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n-     unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n #undef _GLIBCXX_BASE\n@@ -399,31 +396,22 @@ namespace __profile\n       }\n \n       iterator\n-      insert(iterator __iter, const value_type& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        iterator res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size,  _Base::bucket_count()); \n-        return res;\n-      }\n-\n-      const_iterator\n       insert(const_iterator __iter, const value_type& __v)\n       { \n         size_type __old_size = _Base::bucket_count(); \n-        const_iterator res =_Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size,  _Base::bucket_count()); \n-        return res;\n+        iterator __res = _Base::insert(__iter, __v);\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return __res;\n       }\n \n       template<typename _InputIter>\n-      void\n-      insert(_InputIter __first, _InputIter __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first, __last);\n-        _M_profile_resize(__old_size,  _Base::bucket_count()); \n-      }\n+        void\n+        insert(_InputIter __first, _InputIter __last)\n+        {\n+\t  size_type __old_size = _Base::bucket_count(); \n+\t  _Base::insert(__first, __last);\n+\t  _M_profile_resize(__old_size,  _Base::bucket_count()); \n+\t}\n \n       void\n       insert(const value_type* __first, const value_type* __last)\n@@ -447,38 +435,43 @@ namespace __profile\n       const _Base&\n       _M_base() const { return *this; }\n \n-      void _M_profile_resize(size_type __old_size, size_type __new_size)\n+      void\n+      _M_profile_resize(size_type __old_size, size_type __new_size)\n       {\n         if (__old_size != __new_size)\n-        {\n           __profcxx_hashtable_resize(this, __old_size, __new_size);\n-        }\n       }\n \n-      void _M_profile_destruct()\n+      void\n+      _M_profile_destruct()\n       {\n         size_type __hops = 0, __lc = 0, __chain = 0;\n-        for (iterator it = _M_base().begin(); it != _M_base().end(); it++)\n+        for (iterator __it = _M_base().begin(); __it != _M_base().end();\n+\t     ++__it)\n         {\n-          while (it._M_cur_node->_M_next) {\n-             __chain++;\n-             it++;\n-          }\n-          if (__chain) {\n-            __chain++;\n-            __lc = __lc > __chain ? __lc : __chain;\n-            __hops += __chain * (__chain - 1) / 2;\n-            __chain = 0;\n-          }\n+          while (__it._M_cur_node->_M_next)\n+\t    {\n+             ++__chain;\n+             ++__it;\n+\t    }\n+\n+          if (__chain)\n+\t    {\n+\t      ++__chain;\n+\t      __lc = __lc > __chain ? __lc : __chain;\n+\t      __hops += __chain * (__chain - 1) / 2;\n+\t      __chain = 0;\n+\t    }\n         }\n         __profcxx_hashtable_destruct2(this, __lc,  _Base::size(), __hops);\n       }\n \n    };\n+\n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n-     unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n } // namespace __profile"}, {"sha": "2fe3666054366f3578c164b4feca0acae7500bf0", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n // <unordered_map> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -35,10 +35,6 @@\n # include <c++0x_warning.h>\n #else\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n #include <utility>\n #include <type_traits>\n #include <initializer_list>\n@@ -48,26 +44,7 @@\n #include <bits/stringfwd.h>\n #include <bits/functional_hash.h>\n #include <bits/hashtable.h>\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/unordered_map>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL) || defined(_GLIBCXX_PROFILE)\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace _GLIBCXX_STD_D {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 _GLIBCXX_STD_D\n-#else\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1 \n-#endif\n-#  include <tr1_impl/unordered_map>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+#include <bits/unordered_map.h>\n \n #ifdef _GLIBCXX_DEBUG\n # include <debug/unordered_map>"}, {"sha": "9eaa22f8a53ca17e5549b726077b5af8c3991e77", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n // <unordered_set> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -35,10 +35,6 @@\n # include <c++0x_warning.h>\n #else\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n #include <utility>\n #include <type_traits>\n #include <initializer_list>\n@@ -48,26 +44,7 @@\n #include <bits/stringfwd.h>\n #include <bits/functional_hash.h>\n #include <bits/hashtable.h>\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/unordered_set>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL) || defined(_GLIBCXX_PROFILE) \n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace _GLIBCXX_STD_D {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 _GLIBCXX_STD_D\n-#else\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1 \n-#endif\n-#  include <tr1_impl/unordered_set>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+#include <bits/unordered_set.h>\n \n #ifdef _GLIBCXX_DEBUG\n # include <debug/unordered_set>"}, {"sha": "4ac2d58aefb5899012fe0af71f1bf04393b6e5ac", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n // TR1 unordered_map -*- C++ -*-\n \n-// Copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2007, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,10 +31,6 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <utility>\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n@@ -43,19 +39,6 @@\n #include <tr1/type_traits>\n #include <tr1/functional_hash.h>\n #include <tr1/hashtable.h>\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/unordered_map>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/unordered_map>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+#include <tr1_impl/unordered_map>\n \n #endif // _GLIBCXX_TR1_UNORDERED_MAP"}, {"sha": "73e3adb34e64d39512771baf1a4750aa523c3469", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n // TR1 unordered_set -*- C++ -*-\n \n-// Copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2007, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,10 +31,6 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <utility>\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n@@ -43,19 +39,6 @@\n #include <tr1/type_traits>\n #include <tr1/functional_hash.h>\n #include <tr1/hashtable.h>\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/unordered_set>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/unordered_set>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+#include <tr1_impl/unordered_set>\n \n #endif // _GLIBCXX_TR1_UNORDERED_SET"}, {"sha": "5be91b010687a493d2c486372087a5a49ad10edb", "filename": "libstdc++-v3/include/tr1_impl/hashtable", "status": "modified", "additions": 9, "deletions": 80, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -49,8 +49,8 @@\n \n namespace std\n { \n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n+namespace tr1\n+{\n   // Class template _Hashtable, class definition.\n   \n   // Meaning of class template _Hashtable's template parameters\n@@ -215,11 +215,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t   const allocator_type&);\n   \n       _Hashtable(const _Hashtable&);\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      _Hashtable(_Hashtable&&);\n-#endif\n-      \n+    \n       _Hashtable&\n       operator=(const _Hashtable&);\n \n@@ -254,21 +250,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       end() const\n       { return const_iterator(_M_buckets + _M_bucket_count); }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      const_iterator\n-      cbegin() const\n-      {\n-\tconst_iterator __i(_M_buckets);\n-\tif (!__i._M_cur_node)\n-\t  __i._M_incr_bucket();\n-\treturn __i;\n-      }\n-\n-      const_iterator\n-      cend() const\n-      { return const_iterator(_M_buckets + _M_bucket_count); }\n-#endif\n-\n       size_type\n       size() const\n       { return _M_element_count; }\n@@ -332,17 +313,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       end(size_type) const\n       { return const_local_iterator(0); }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      // DR 691.\n-      const_local_iterator\n-      cbegin(size_type __n) const\n-      { return const_local_iterator(_M_buckets[__n]); }\n-\n-      const_local_iterator\n-      cend(size_type) const\n-      { return const_local_iterator(0); }\n-#endif\n-\n       float\n       load_factor() const\n       { \n@@ -400,10 +370,10 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t       typename _Hashtable::_Hash_code_type);\n \n       std::pair<iterator, bool>\n-      _M_insert(const value_type&, std::_GLIBCXX_TR1 true_type);\n+      _M_insert(const value_type&, std::tr1::true_type);\n \n       iterator\n-      _M_insert(const value_type&, std::_GLIBCXX_TR1 false_type);\n+      _M_insert(const value_type&, std::tr1::false_type);\n \n       void\n       _M_erase_node(_Node*, _Node**);\n@@ -412,7 +382,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       // Insert and erase\n       _Insert_Return_Type\n       insert(const value_type& __v) \n-      { return _M_insert(__v, std::_GLIBCXX_TR1 integral_constant<bool,\n+      { return _M_insert(__v, std::tr1::integral_constant<bool,\n \t\t\t __unique_keys>()); }\n \n       iterator\n@@ -427,12 +397,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n         void\n         insert(_InputIterator __first, _InputIterator __last);\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      void\n-      insert(initializer_list<value_type> __l)\n-      { this->insert(__l.begin(), __l.end()); }\n-#endif\n-\n       iterator\n       erase(iterator);\n \n@@ -475,11 +439,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       _Node* __n = _M_node_allocator.allocate(1);\n       __try\n \t{\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-\t  _M_node_allocator.construct(__n, __v);\n-#else\n \t  _M_get_Value_allocator().construct(&__n->_M_v, __v);\n-#endif\n \t  __n->_M_next = 0;\n \t  return __n;\n \t}\n@@ -499,11 +459,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     _M_deallocate_node(_Node* __n)\n     {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      _M_node_allocator.destroy(__n);\n-#else\n       _M_get_Value_allocator().destroy(&__n->_M_v);\n-#endif\n       _M_node_allocator.deallocate(__n, 1);\n     }\n \n@@ -668,32 +624,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t}\n     }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _Hashtable(_Hashtable&& __ht)\n-    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n-      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n-      _M_node_allocator(__ht._M_node_allocator),\n-      _M_bucket_count(__ht._M_bucket_count),\n-      _M_element_count(__ht._M_element_count),\n-      _M_rehash_policy(__ht._M_rehash_policy),\n-      _M_buckets(__ht._M_buckets)\n-    {\n-      size_type __n_bkt = __ht._M_rehash_policy._M_next_bkt(0);\n-      __ht._M_buckets = __ht._M_allocate_buckets(__n_bkt);\n-      __ht._M_bucket_count = __n_bkt;\n-      __ht._M_element_count = 0;\n-      __ht._M_rehash_policy = _RehashPolicy();\n-    }\n-#endif\n-\n   template<typename _Key, typename _Value, \n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n@@ -966,7 +896,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t\t\t  __chc, __cit, __uk>::iterator, bool>\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert(const value_type& __v, std::_GLIBCXX_TR1 true_type)\n+  _M_insert(const value_type& __v, std::tr1::true_type)\n     {\n       const key_type& __k = this->_M_extract(__v);\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n@@ -987,7 +917,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t\t__chc, __cit, __uk>::iterator\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert(const value_type& __v, std::_GLIBCXX_TR1 false_type)\n+    _M_insert(const value_type& __v, std::tr1::false_type)\n     {\n       std::pair<bool, std::size_t> __do_rehash\n \t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n@@ -1253,6 +1183,5 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  __throw_exception_again;\n \t}\n     }\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n+}\n }"}, {"sha": "6b2dd342c17a1b73a2809886b07de37d88c29a7c", "filename": "libstdc++-v3/include/tr1_impl/hashtable_policy.h", "status": "modified", "additions": 4, "deletions": 67, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable_policy.h?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n // Internal policy header for TR1 unordered_set and unordered_map -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,8 +29,8 @@\n \n namespace std\n { \n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n+namespace tr1\n+{\n namespace __detail\n {\n   // Helper function: return distance(first, last) for forward\n@@ -94,27 +94,13 @@ namespace __detail\n       _Value       _M_v;\n       std::size_t  _M_hash_code;\n       _Hash_node*  _M_next;\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      template<typename... _Args>\n-        _Hash_node(_Args&&... __args)\n-\t  : _M_v(std::forward<_Args>(__args)...),\n-\t    _M_hash_code(), _M_next() { }\n-#endif\n     };\n \n   template<typename _Value>\n     struct _Hash_node<_Value, false>\n     {\n       _Value       _M_v;\n       _Hash_node*  _M_next;\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      template<typename... _Args>\n-        _Hash_node(_Args&&... __args)\n-\t  : _M_v(std::forward<_Args>(__args)...),\n-\t    _M_next() { }\n-#endif\n     };\n \n   // Local iterators, used to iterate within a bucket but not between\n@@ -545,16 +531,6 @@ namespace __detail\n       \n       mapped_type&\n       operator[](const _Key& __k);\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // DR 761. unordered_map needs an at() member function.\n-      mapped_type&\n-      at(const _Key& __k);\n-\n-      const mapped_type&\n-      at(const _Key& __k) const;\n-#endif\n     };\n \n   template<typename _Key, typename _Pair, typename _Hashtable>\n@@ -576,44 +552,6 @@ namespace __detail\n       return (__p->_M_v).second;\n     }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n-\t\t       true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    at(const _Key& __k)\n-    {\n-      _Hashtable* __h = static_cast<_Hashtable*>(this);\n-      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code,\n-\t\t\t\t\t     __h->_M_bucket_count);\n-\n-      typename _Hashtable::_Node* __p =\n-\t__h->_M_find_node(__h->_M_buckets[__n], __k, __code);\n-      if (!__p)\n-\t__throw_out_of_range(__N(\"_Map_base::at\"));\n-      return (__p->_M_v).second;\n-    }\n-\n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    const typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n-\t\t\t     true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    at(const _Key& __k) const\n-    {\n-      const _Hashtable* __h = static_cast<const _Hashtable*>(this);\n-      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code,\n-\t\t\t\t\t     __h->_M_bucket_count);\n-\n-      typename _Hashtable::_Node* __p =\n-\t__h->_M_find_node(__h->_M_buckets[__n], __k, __code);\n-      if (!__p)\n-\t__throw_out_of_range(__N(\"_Map_base::at\"));\n-      return (__p->_M_v).second;\n-    }\n-#endif\n-\n   // class template _Rehash_base.  Give hashtable the max_load_factor\n   // functions iff the rehash policy is _Prime_rehash_policy.\n   template<typename _RehashPolicy, typename _Hashtable>\n@@ -860,6 +798,5 @@ namespace __detail\n       _H2          _M_h2;\n     };\n } // namespace __detail\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n+}\n }"}, {"sha": "54b1e5629544e72a8fe756f3db098abb2edc07f8", "filename": "libstdc++-v3/include/tr1_impl/unordered_map", "status": "modified", "additions": 4, "deletions": 76, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,6 @@\n // TR1 unordered_map -*- C++ -*-\n \n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,8 +29,8 @@\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n+namespace tr1\n+{\n   // XXX When we get typedef templates these class definitions\n   // will be unnecessary.\n   template<class _Key, class _Tp,\n@@ -80,11 +80,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(),\n \t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n \t{ }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      __unordered_map(__unordered_map&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-#endif\n     };\n   \n   template<class _Key, class _Tp,\n@@ -137,11 +132,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(),\n \t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n         { }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      __unordered_multimap(__unordered_multimap&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-#endif\n     };\n \n   template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n@@ -213,37 +203,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      unordered_map(unordered_map&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-\n-      unordered_map(initializer_list<value_type> __l,\n-\t\t    size_type __n = 10,\n-\t\t    const hasher& __hf = hasher(),\n-\t\t    const key_equal& __eql = key_equal(),\n-\t\t    const allocator_type& __a = allocator_type())\n-\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n-      { }\n-\n-      unordered_map&\n-      operator=(unordered_map&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\t\n-      }\n-\n-      unordered_map&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-#endif\n     };\n   \n   /**\n@@ -298,36 +257,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      unordered_multimap(unordered_multimap&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-\n-      unordered_multimap(initializer_list<value_type> __l,\n-\t\t\t size_type __n = 10,\n-\t\t\t const hasher& __hf = hasher(),\n-\t\t\t const key_equal& __eql = key_equal(),\n-\t\t\t const allocator_type& __a = allocator_type())\n-\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n-      { }\n-\n-      unordered_multimap&\n-      operator=(unordered_multimap&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\t\n-      }\n-\n-      unordered_multimap&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-#endif\n     };\n \n   template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n@@ -341,6 +270,5 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n     swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n \t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n+}\n }"}, {"sha": "6967ae5c34363c246c17d98977e0dd225d713ef3", "filename": "libstdc++-v3/include/tr1_impl/unordered_set", "status": "modified", "additions": 3, "deletions": 76, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -29,8 +29,8 @@\n \n namespace std\n { \n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n+namespace tr1\n+{\n   // XXX When we get typedef templates these class definitions\n   // will be unnecessary.\n   template<class _Value,\n@@ -80,11 +80,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(), __eql,\n \t\tstd::_Identity<_Value>(), __a)\n         { }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      __unordered_set(__unordered_set&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-#endif\n     };\n \n   template<class _Value,\n@@ -135,11 +130,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(), __eql,\n \t\tstd::_Identity<_Value>(), __a)\n         { }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      __unordered_multiset(__unordered_multiset&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-#endif\n     };\n \n   template<class _Value, class _Hash, class _Pred, class _Alloc,\n@@ -206,37 +196,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      unordered_set(unordered_set&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-\n-      unordered_set(initializer_list<value_type> __l,\n-\t\t    size_type __n = 10,\n-\t\t    const hasher& __hf = hasher(),\n-\t\t    const key_equal& __eql = key_equal(),\n-\t\t    const allocator_type& __a = allocator_type())\n-\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n-      { }\n-\n-      unordered_set&\n-      operator=(unordered_set&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\t\n-      }\n-\n-      unordered_set&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-#endif\n     };\n \n   /**\n@@ -287,37 +246,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t\t   const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      unordered_multiset(unordered_multiset&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-\n-      unordered_multiset(initializer_list<value_type> __l,\n-\t\t\t size_type __n = 10,\n-\t\t\t const hasher& __hf = hasher(),\n-\t\t\t const key_equal& __eql = key_equal(),\n-\t\t\t const allocator_type& __a = allocator_type())\n-\t: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n-      { }\n-\n-      unordered_multiset&\n-      operator=(unordered_multiset&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\t\n-      }\n-\n-      unordered_multiset&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-#endif\n     };\n \n   template<class _Value, class _Hash, class _Pred, class _Alloc>\n@@ -331,6 +259,5 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n     swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n \t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n+}\n }"}, {"sha": "c5fd9cd0db6e4ab228f3c13f7691b3b92e17c7ba", "filename": "libstdc++-v3/testsuite/23_containers/map/operators/1_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,7 @@\n // { dg-do compile }\n \n-// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n+// 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -40,6 +41,5 @@ void test01()\n   test &= itr != mapByName.end(); // { dg-error \"no\" } \n   test &= itr == mapByName.end(); // { dg-error \"no\" } \n }\n- \n-// { dg-error \"candidate is\" \"\" { target *-*-* } 212 }\n-// { dg-error \"candidate is\" \"\" { target *-*-* } 216 }\n+\n+// { dg-excess-errors \"\" }"}, {"sha": "babd6db2b2baa8ff303557540882441ac838122e", "filename": "libstdc++-v3/testsuite/23_containers/set/operators/1_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -1,6 +1,7 @@\n // { dg-do compile }\n \n-// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n+// 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -39,5 +40,4 @@ void test01()\n   test &= itr == setByName.end(); // { dg-error \"no\" } \n }\n \n-// { dg-error \"candidate is\" \"\" { target *-*-* } 287 }\n-// { dg-error \"candidate is\" \"\" { target *-*-* } 291 }\n+// { dg-excess-errors \"\" }"}, {"sha": "f9b74e08c8d10cd19481b488428e994d8f6dfba4", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/erase/1.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F1.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,129 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef Map::iterator       iterator;\n+  typedef Map::const_iterator const_iterator;\n+  typedef Map::value_type     value_type;\n+\n+  Map m1;\n+\n+  m1.insert(value_type(\"because to why\", 1));\n+  m1.insert(value_type(\"the stockholm syndrome\", 2));\n+  m1.insert(value_type(\"a cereous night\", 3));\n+  m1.insert(value_type(\"eeilo\", 4));\n+  m1.insert(value_type(\"protean\", 5));\n+  m1.insert(value_type(\"the way you are when\", 6));\n+  m1.insert(value_type(\"tillsammans\", 7));\n+  m1.insert(value_type(\"umbra/penumbra\", 8));\n+  m1.insert(value_type(\"belonging (no longer mix)\", 9));\n+  m1.insert(value_type(\"one line behind\", 10));\n+  VERIFY( m1.size() == 10 );\n+\n+  VERIFY( m1.erase(\"eeilo\") == 1 );\n+  VERIFY( m1.size() == 9 );\n+  iterator it1 = m1.find(\"eeilo\");\n+  VERIFY( it1 == m1.end() );\n+\n+  VERIFY( m1.erase(\"tillsammans\") == 1 );\n+  VERIFY( m1.size() == 8 );\n+  iterator it2 = m1.find(\"tillsammans\");\n+  VERIFY( it2 == m1.end() );\n+\n+  // Must work (see DR 526)\n+  iterator it3 = m1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 != m1.end() );\n+  VERIFY( m1.erase(it3->first) == 1 );\n+  VERIFY( m1.size() == 7 );\n+  it3 = m1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 == m1.end() );\n+\n+  VERIFY( !m1.erase(\"abra\") );\n+  VERIFY( m1.size() == 7 );\n+\n+  VERIFY( !m1.erase(\"eeilo\") );\n+  VERIFY( m1.size() == 7 );\n+\n+  VERIFY( m1.erase(\"because to why\") == 1 );\n+  VERIFY( m1.size() == 6 );\n+  iterator it4 = m1.find(\"because to why\");\n+  VERIFY( it4 == m1.end() );\n+\n+  iterator it5 = m1.find(\"umbra/penumbra\");\n+  iterator it6 = m1.find(\"one line behind\");\n+  VERIFY( it5 != m1.end() );\n+  VERIFY( it6 != m1.end() );\n+\n+  VERIFY( m1.find(\"the stockholm syndrome\") != m1.end() );\n+  VERIFY( m1.find(\"a cereous night\") != m1.end() );\n+  VERIFY( m1.find(\"the way you are when\") != m1.end() );\n+  VERIFY( m1.find(\"a cereous night\") != m1.end() );\n+\n+  VERIFY( m1.erase(it5->first) == 1 );\n+  VERIFY( m1.size() == 5 );\n+  it5 = m1.find(\"umbra/penumbra\");\n+  VERIFY( it5 == m1.end() );\n+\n+  VERIFY( m1.erase(it6->first) == 1 );\n+  VERIFY( m1.size() == 4 );\n+  it6 = m1.find(\"one line behind\");\n+  VERIFY( it6 == m1.end() );\n+\n+  iterator it7 = m1.begin();\n+  iterator it8 = it7;\n+  ++it8;\n+  iterator it9 = it8;\n+  ++it9;\n+\n+  VERIFY( m1.erase(it8->first) == 1 );\n+  VERIFY( m1.size() == 3 );\n+  VERIFY( ++it7 == it9 );\n+\n+  iterator it10 = it9;\n+  ++it10;\n+  iterator it11 = it10;\n+\n+  VERIFY( m1.erase(it9->first) == 1 );\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( ++it10 == m1.end() );\n+\n+  VERIFY( m1.erase(m1.begin()) != m1.end() );  \n+  VERIFY( m1.size() == 1 );\n+  VERIFY( m1.begin() == it11 );\n+\n+  VERIFY( m1.erase(m1.begin()->first) == 1 );  \n+  VERIFY( m1.size() == 0 );\n+  VERIFY( m1.begin() == m1.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "87ab474a8263fa46a003a03689d9969a7e348e32", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/erase/24061-map.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F24061-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F24061-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F24061-map.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,105 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef Map::iterator       iterator;\n+  typedef Map::const_iterator const_iterator;\n+  typedef Map::value_type     value_type;\n+  \n+  Map m1;\n+\n+  m1.insert(value_type(\"all the love in the world\", 1));\n+  m1.insert(value_type(\"you know what you are?\", 2));\n+  m1.insert(value_type(\"the collector\", 3));\n+  m1.insert(value_type(\"the hand that feeds\", 4));\n+  m1.insert(value_type(\"love is not enough\", 5));\n+  m1.insert(value_type(\"every day is exactly the same\", 6));\n+  m1.insert(value_type(\"with teeth\", 7));\n+  m1.insert(value_type(\"only\", 8));\n+  m1.insert(value_type(\"getting smaller\", 9));\n+  m1.insert(value_type(\"sunspots\", 10)); \n+  VERIFY( m1.size() == 10 );\n+\n+  iterator it1 = m1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = m1.erase(it1);\n+  VERIFY( m1.size() == 9 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = m1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = m1.erase(it4, it5);\n+  VERIFY( m1.size() == 7 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = m1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = m1.erase(it7);\n+  VERIFY( m1.size() == 6 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = m1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = m1.erase(it10, it11);\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+  VERIFY( ++it12 == m1.end() );\n+\n+  iterator it13 = m1.erase(m1.begin(), m1.end());\n+  VERIFY( m1.size() == 0 );\n+  VERIFY( it13 == it12 );\n+  VERIFY( it13 == m1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d9a1878702d118c934e9e13694fda7520ce030fb", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/24061-map.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F24061-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F24061-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F24061-map.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef Map::iterator       iterator;\n+  typedef Map::const_iterator const_iterator;\n+  typedef Map::value_type     value_type;\n+\n+  Map m1;\n+  \n+  iterator it1 = m1.insert(m1.begin(),\n+\t\t\t   value_type(\"all the love in the world\", 1));\n+  VERIFY( m1.size() == 1 );\n+  VERIFY( *it1 == value_type(\"all the love in the world\", 1) );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = m1.insert(cit1,\n+\t\t\t\t  value_type(\"you know what you are?\", 2));\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == value_type(\"you know what you are?\", 2) );\n+\n+  iterator it2 = m1.insert(it1, value_type(\"all the love in the world\", 3));\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( it2 == it1 );\n+  VERIFY( *it2 == value_type(\"all the love in the world\", 1) );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "11fddbb39dd0a3b4ecc4a14f873bc1e7575e33e5", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/array_syntax.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Array version of insert\n+\n+#include <string>\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  m[\"red\"] = 17;\n+  VERIFY(m.size() == 1);\n+  VERIFY(m.begin()->first == \"red\");\n+  VERIFY(m.begin()->second == 17);\n+  VERIFY(m[\"red\"] == 17);\n+\n+  m[\"blue\"] = 9;\n+  VERIFY(m.size() == 2);\n+  VERIFY(m[\"blue\"] == 9);\n+\n+  m[\"red\"] = 5;\n+  VERIFY(m.size() == 2);\n+  VERIFY(m[\"red\"] == 5);\n+  VERIFY(m[\"blue\"] == 9);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "5e5298c0469c540e18dce6666c18ded83e3e189c", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/map_range.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_range.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,97 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <string>\n+#include <iterator>\n+#include <algorithm>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  Pair A[5] =\n+    {\n+      Pair(\"red\", 5),\n+      Pair(\"green\", 9),\n+      Pair(\"blue\", 3),\n+      Pair(\"cyan\", 8),\n+      Pair(\"magenta\", 7)\n+    };\n+\n+  m.insert(A+0, A+5);\n+  VERIFY(m.size() == 5);\n+  VERIFY(std::distance(m.begin(), m.end()) == 5);\n+\n+  VERIFY(m[\"red\"] == 5);\n+  VERIFY(m[\"green\"] == 9);\n+  VERIFY(m[\"blue\"] == 3);\n+  VERIFY(m[\"cyan\"] == 8);\n+  VERIFY(m[\"magenta\"] == 7);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  Pair A[9] =\n+    {\n+      Pair(\"red\", 5),\n+      Pair(\"green\", 9),\n+      Pair(\"red\", 19),\n+      Pair(\"blue\", 3),\n+      Pair(\"blue\", 60),\n+      Pair(\"cyan\", 8),\n+      Pair(\"magenta\", 7),\n+      Pair(\"blue\", 99),\n+      Pair(\"green\", 33)\n+    };\n+\n+  m.insert(A+0, A+9);\n+  VERIFY(m.size() == 5);\n+  VERIFY(std::distance(m.begin(), m.end()) == 5);\n+\n+  VERIFY(m[\"red\"] == 5);\n+  VERIFY(m[\"green\"] == 9);\n+  VERIFY(m[\"blue\"] == 3);\n+  VERIFY(m[\"cyan\"] == 8);\n+  VERIFY(m[\"magenta\"] == 7);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "3905e26c9fc5c5864b71f338cc189c8bbb593d46", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/map_single.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,72 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  std::pair<Map::iterator, bool> p = m.insert(Pair(\"abcde\", 3));\n+  VERIFY(p.second);\n+  VERIFY(m.size() == 1);\n+  VERIFY(std::distance(m.begin(), m.end()) == 1);\n+  VERIFY(p.first == m.begin());\n+  VERIFY(p.first->first == \"abcde\");\n+  VERIFY(p.first->second == 3);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  std::pair<Map::iterator, bool> p1 = m.insert(Pair(\"abcde\", 3));\n+  std::pair<Map::iterator, bool> p2 = m.insert(Pair(\"abcde\", 7));\n+\n+  VERIFY(p1.second);\n+  VERIFY(!p2.second);\n+  VERIFY(m.size() == 1);\n+  VERIFY(p1.first == p2.first);\n+  VERIFY(p1.first->first == \"abcde\");\n+  VERIFY(p2.first->second == 3);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "0aa1a071871ffa60864afa134ebe2c6ee9e34e5c", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/1.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F1.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,129 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multimap<std::string, int> Mmap;\n+  typedef Mmap::iterator       iterator;\n+  typedef Mmap::const_iterator const_iterator;\n+  typedef Mmap::value_type     value_type;\n+\n+  Mmap mm1;\n+\n+  mm1.insert(value_type(\"because to why\", 1));\n+  mm1.insert(value_type(\"the stockholm syndrome\", 2));\n+  mm1.insert(value_type(\"a cereous night\", 3));\n+  mm1.insert(value_type(\"eeilo\", 4));\n+  mm1.insert(value_type(\"protean\", 5));\n+  mm1.insert(value_type(\"the way you are when\", 6));\n+  mm1.insert(value_type(\"tillsammans\", 7));\n+  mm1.insert(value_type(\"umbra/penumbra\", 8));\n+  mm1.insert(value_type(\"belonging (no longer mix)\", 9));\n+  mm1.insert(value_type(\"one line behind\", 10));\n+  VERIFY( mm1.size() == 10 );\n+\n+  VERIFY( mm1.erase(\"eeilo\") == 1 );\n+  VERIFY( mm1.size() == 9 );\n+  iterator it1 = mm1.find(\"eeilo\");\n+  VERIFY( it1 == mm1.end() );\n+\n+  VERIFY( mm1.erase(\"tillsammans\") == 1 );\n+  VERIFY( mm1.size() == 8 );\n+  iterator it2 = mm1.find(\"tillsammans\");\n+  VERIFY( it2 == mm1.end() );\n+\n+  // Must work (see DR 526)\n+  iterator it3 = mm1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 != mm1.end() );\n+  VERIFY( mm1.erase(it3->first) == 1 );\n+  VERIFY( mm1.size() == 7 );\n+  it3 = mm1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 == mm1.end() );\n+\n+  VERIFY( !mm1.erase(\"abra\") );\n+  VERIFY( mm1.size() == 7 );\n+\n+  VERIFY( !mm1.erase(\"eeilo\") );\n+  VERIFY( mm1.size() == 7 );\n+\n+  VERIFY( mm1.erase(\"because to why\") == 1 );\n+  VERIFY( mm1.size() == 6 );\n+  iterator it4 = mm1.find(\"because to why\");\n+  VERIFY( it4 == mm1.end() );\n+\n+  iterator it5 = mm1.find(\"umbra/penumbra\");\n+  iterator it6 = mm1.find(\"one line behind\");\n+  VERIFY( it5 != mm1.end() );\n+  VERIFY( it6 != mm1.end() );\n+\n+  VERIFY( mm1.find(\"the stockholm syndrome\") != mm1.end() );\n+  VERIFY( mm1.find(\"a cereous night\") != mm1.end() );\n+  VERIFY( mm1.find(\"the way you are when\") != mm1.end() );\n+  VERIFY( mm1.find(\"a cereous night\") != mm1.end() );\n+\n+  VERIFY( mm1.erase(it5->first) == 1 );\n+  VERIFY( mm1.size() == 5 );\n+  it5 = mm1.find(\"umbra/penumbra\");\n+  VERIFY( it5 == mm1.end() );\n+\n+  VERIFY( mm1.erase(it6->first) == 1 );\n+  VERIFY( mm1.size() == 4 );\n+  it6 = mm1.find(\"one line behind\");\n+  VERIFY( it6 == mm1.end() );\n+\n+  iterator it7 = mm1.begin();\n+  iterator it8 = it7;\n+  ++it8;\n+  iterator it9 = it8;\n+  ++it9;\n+\n+  VERIFY( mm1.erase(it8->first) == 1 );\n+  VERIFY( mm1.size() == 3 );\n+  VERIFY( ++it7 == it9 );\n+\n+  iterator it10 = it9;\n+  ++it10;\n+  iterator it11 = it10;\n+\n+  VERIFY( mm1.erase(it9->first) == 1 );\n+  VERIFY( mm1.size() == 2 );\n+  VERIFY( ++it10 == mm1.end() );\n+\n+  VERIFY( mm1.erase(mm1.begin()) != mm1.end() );  \n+  VERIFY( mm1.size() == 1 );\n+  VERIFY( mm1.begin() == it11 );\n+\n+  VERIFY( mm1.erase(mm1.begin()->first) == 1 );  \n+  VERIFY( mm1.size() == 0 );\n+  VERIFY( mm1.begin() == mm1.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "545d08278d6f630a200f887078e863a444bfea35", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/24061-multimap.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F24061-multimap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F24061-multimap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F24061-multimap.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multimap<std::string, int> Mmap;\n+  typedef Mmap::iterator       iterator;\n+  typedef Mmap::const_iterator const_iterator;\n+  typedef Mmap::value_type     value_type;\n+  \n+  Mmap mm1;\n+\n+  mm1.insert(value_type(\"all the love in the world\", 1));\n+  mm1.insert(value_type(\"you know what you are?\", 2));\n+  mm1.insert(value_type(\"the collector\", 3));\n+  mm1.insert(value_type(\"the hand that feeds\", 4));\n+  mm1.insert(value_type(\"love is not enough\", 5));\n+  mm1.insert(value_type(\"every day is exactly the same\", 6));\n+  mm1.insert(value_type(\"with teeth\", 7));\n+  mm1.insert(value_type(\"only\", 8));\n+  mm1.insert(value_type(\"getting smaller\", 9));\n+  mm1.insert(value_type(\"sunspots\", 10));\n+\n+  mm1.insert(value_type(\"you know what you are?\", 5));\n+  mm1.insert(value_type(\"the collector\", 6));\n+  mm1.insert(value_type(\"the hand that feeds\", 7));\n+  VERIFY( mm1.size() == 13 );\n+\n+  iterator it1 = mm1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = mm1.erase(it1);\n+  VERIFY( mm1.size() == 12 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = mm1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = mm1.erase(it4, it5);\n+  VERIFY( mm1.size() == 10 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = mm1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = mm1.erase(it7);\n+  VERIFY( mm1.size() == 9 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = mm1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = mm1.erase(it10, it11);\n+  VERIFY( mm1.size() == 5 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+\n+  iterator it13 = mm1.erase(mm1.begin(), mm1.end());\n+  VERIFY( mm1.size() == 0 );\n+  VERIFY( it13 == mm1.end() );\n+  VERIFY( it13 == mm1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "136580662f7b711c50824639c2791b93e1dfb65b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/24061-multimap.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F24061-multimap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F24061-multimap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F24061-multimap.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multimap<std::string, int> Mmap;\n+  typedef Mmap::iterator       iterator;\n+  typedef Mmap::const_iterator const_iterator;\n+  typedef Mmap::value_type     value_type;\n+\n+  Mmap mm1;\n+  \n+  iterator it1 = mm1.insert(mm1.begin(),\n+\t\t\t    value_type(\"all the love in the world\", 1));\n+  VERIFY( mm1.size() == 1 );\n+  VERIFY( *it1 == value_type(\"all the love in the world\", 1) );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = mm1.insert(cit1,\n+\t\t\t\t   value_type(\"you know what you are?\", 2));\n+  VERIFY( mm1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == value_type(\"you know what you are?\", 2) );\n+\n+  iterator it2 = mm1.insert(it1, value_type(\"all the love in the world\", 3));\n+  VERIFY( mm1.size() == 3 );\n+  VERIFY( it2 != it1 );\n+  VERIFY( *it2 == value_type(\"all the love in the world\", 3) );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b7f405b763d662975e5b5c62672c07bca5579df8", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/multimap_range.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_range.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,91 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <string>\n+#include <iterator>\n+#include <algorithm>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multimap<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  Pair A[5] =\n+    {\n+      Pair(\"red\", 5),\n+      Pair(\"green\", 9),\n+      Pair(\"blue\", 3),\n+      Pair(\"cyan\", 8),\n+      Pair(\"magenta\", 7)\n+    };\n+\n+  m.insert(A+0, A+5);\n+  VERIFY(m.size() == 5);\n+  VERIFY(std::distance(m.begin(), m.end()) == 5);\n+\n+  for (int i = 0; i < 5; ++i)\n+    VERIFY(std::find(m.begin(), m.end(), A[i]) != m.end());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multimap<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  Pair A[9] =\n+    {\n+      Pair(\"red\", 5),\n+      Pair(\"green\", 9),\n+      Pair(\"red\", 19),\n+      Pair(\"blue\", 3),\n+      Pair(\"blue\", 60),\n+      Pair(\"cyan\", 8),\n+      Pair(\"magenta\", 7),\n+      Pair(\"blue\", 99),\n+      Pair(\"green\", 33)\n+    };\n+\n+  m.insert(A+0, A+9);\n+  VERIFY(m.size() == 9);\n+  VERIFY(std::distance(m.begin(), m.end()) == 9);\n+\n+  for (int i = 0; i < 9; ++i)\n+    VERIFY(std::find(m.begin(), m.end(), A[i]) != m.end());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "1864098f582ff9f86194ca6b3448323690b9c887", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/multimap_single.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,76 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multimap<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  Map::iterator i = m.insert(Pair(\"abcde\", 3));\n+  VERIFY(m.size() == 1);\n+  VERIFY(std::distance(m.begin(), m.end()) == 1);\n+  VERIFY(i == m.begin());\n+  VERIFY(i->first == \"abcde\");\n+  VERIFY(i->second == 3);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multimap<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  m.insert(Pair(\"abcde\", 3));\n+  m.insert(Pair(\"abcde\", 7));\n+\n+  VERIFY(m.size() == 2);\n+  VERIFY(std::distance(m.begin(), m.end()) == 2);\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY(i1->first == \"abcde\");\n+  VERIFY(i2->first == \"abcde\");\n+  VERIFY((i1->second == 3 && i2->second == 7) ||\n+\t (i1->second == 7 && i2->second == 3));\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "9951838e9de72f1be20e0c2547f9603858a53aad", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/erase/1.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F1.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,128 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multiset<std::string> Mset;\n+  typedef Mset::iterator       iterator;\n+  typedef Mset::const_iterator const_iterator;\n+\n+  Mset ms1;\n+  \n+  ms1.insert(\"because to why\");\n+  ms1.insert(\"the stockholm syndrome\");\n+  ms1.insert(\"a cereous night\");\n+  ms1.insert(\"eeilo\");\n+  ms1.insert(\"protean\");\n+  ms1.insert(\"the way you are when\");\n+  ms1.insert(\"tillsammans\");\n+  ms1.insert(\"umbra/penumbra\");\n+  ms1.insert(\"belonging (no longer mix)\");\n+  ms1.insert(\"one line behind\");\n+  VERIFY( ms1.size() == 10 );\n+\n+  VERIFY( ms1.erase(\"eeilo\") == 1 );\n+  VERIFY( ms1.size() == 9 );\n+  iterator it1 = ms1.find(\"eeilo\");\n+  VERIFY( it1 == ms1.end() );\n+\n+  VERIFY( ms1.erase(\"tillsammans\") == 1 );\n+  VERIFY( ms1.size() == 8 );\n+  iterator it2 = ms1.find(\"tillsammans\");\n+  VERIFY( it2 == ms1.end() );\n+\n+  // Must work (see DR 526)\n+  iterator it3 = ms1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 != ms1.end() );\n+  VERIFY( ms1.erase(*it3) == 1 );\n+  VERIFY( ms1.size() == 7 );\n+  it3 = ms1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 == ms1.end() );\n+\n+  VERIFY( !ms1.erase(\"abra\") );\n+  VERIFY( ms1.size() == 7 );\n+\n+  VERIFY( !ms1.erase(\"eeilo\") );\n+  VERIFY( ms1.size() == 7 );\n+\n+  VERIFY( ms1.erase(\"because to why\") == 1 );\n+  VERIFY( ms1.size() == 6 );\n+  iterator it4 = ms1.find(\"because to why\");\n+  VERIFY( it4 == ms1.end() );\n+\n+  iterator it5 = ms1.find(\"umbra/penumbra\");\n+  iterator it6 = ms1.find(\"one line behind\");\n+  VERIFY( it5 != ms1.end() );\n+  VERIFY( it6 != ms1.end() );\n+\n+  VERIFY( ms1.find(\"the stockholm syndrome\") != ms1.end() );\n+  VERIFY( ms1.find(\"a cereous night\") != ms1.end() );\n+  VERIFY( ms1.find(\"the way you are when\") != ms1.end() );\n+  VERIFY( ms1.find(\"a cereous night\") != ms1.end() );\n+\n+  VERIFY( ms1.erase(*it5) == 1 );\n+  VERIFY( ms1.size() == 5 );\n+  it5 = ms1.find(\"umbra/penumbra\");\n+  VERIFY( it5 == ms1.end() );\n+\n+  VERIFY( ms1.erase(*it6) == 1 );\n+  VERIFY( ms1.size() == 4 );\n+  it6 = ms1.find(\"one line behind\");\n+  VERIFY( it6 == ms1.end() );\n+\n+  iterator it7 = ms1.begin();\n+  iterator it8 = it7;\n+  ++it8;\n+  iterator it9 = it8;\n+  ++it9;\n+\n+  VERIFY( ms1.erase(*it8) == 1 );\n+  VERIFY( ms1.size() == 3 );\n+  VERIFY( ++it7 == it9 );\n+\n+  iterator it10 = it9;\n+  ++it10;\n+  iterator it11 = it10;\n+\n+  VERIFY( ms1.erase(*it9) == 1 );\n+  VERIFY( ms1.size() == 2 );\n+  VERIFY( ++it10 == ms1.end() );\n+\n+  VERIFY( ms1.erase(ms1.begin()) != ms1.end() );  \n+  VERIFY( ms1.size() == 1 );\n+  VERIFY( ms1.begin() == it11 );\n+\n+  VERIFY( ms1.erase(*ms1.begin()) == 1 );  \n+  VERIFY( ms1.size() == 0 );\n+  VERIFY( ms1.begin() == ms1.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c5eea6eeebcf39b7a3ea896a4296a38c1af8477f", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/erase/24061-multiset.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F24061-multiset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F24061-multiset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F24061-multiset.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,107 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multiset<std::string> Mset;\n+  typedef Mset::iterator       iterator;\n+  typedef Mset::const_iterator const_iterator;\n+\n+  Mset ms1;\n+  \n+  ms1.insert(\"all the love in the world\");\n+  ms1.insert(\"you know what you are?\");\n+  ms1.insert(\"the collector\");\n+  ms1.insert(\"the hand that feeds\");\n+  ms1.insert(\"love is not enough\");\n+  ms1.insert(\"every day is exactly the same\");\n+  ms1.insert(\"with teeth\");\n+  ms1.insert(\"only\");\n+  ms1.insert(\"getting smaller\");\n+  ms1.insert(\"sunspots\");\n+\n+  ms1.insert(\"the hand that feeds\");\n+  ms1.insert(\"love is not enough\");\n+  ms1.insert(\"every day is exactly the same\");\n+  VERIFY( ms1.size() == 13 );\n+\n+  iterator it1 = ms1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = ms1.erase(it1);\n+  VERIFY( ms1.size() == 12 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = ms1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = ms1.erase(it4, it5);\n+  VERIFY( ms1.size() == 10 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = ms1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = ms1.erase(it7);\n+  VERIFY( ms1.size() == 9 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = ms1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = ms1.erase(it10, it11);\n+  VERIFY( ms1.size() == 5 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+\n+  iterator it13 = ms1.erase(ms1.begin(), ms1.end());\n+  VERIFY( ms1.size() == 0 );\n+  VERIFY( it13 == ms1.end() );\n+  VERIFY( it13 == ms1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6d8b34d3e8c949eceb46725a3ef536d183f4665b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/insert/24061-multiset.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F24061-multiset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F24061-multiset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F24061-multiset.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multiset<std::string> Mset;\n+  typedef Mset::iterator       iterator;\n+  typedef Mset::const_iterator const_iterator;\n+\n+  Mset ms1;\n+  \n+  iterator it1 = ms1.insert(ms1.begin(), \"all the love in the world\");\n+  VERIFY( ms1.size() == 1 );\n+  VERIFY( *it1 == \"all the love in the world\" );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = ms1.insert(cit1, \"you know what you are?\");\n+  VERIFY( ms1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == \"you know what you are?\" );\n+\n+  iterator it2 = ms1.insert(it1, \"all the love in the world\");\n+  VERIFY( ms1.size() == 3 );\n+  VERIFY( it2 != it1 );\n+  VERIFY( *it2 == \"all the love in the world\" );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "571346fd5c2791b90ca2aa02b25e8df60d3bcc08", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/insert/multiset_range.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_range.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,79 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <string>\n+#include <iterator>\n+#include <algorithm>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multiset<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  const int N = 10;\n+  const std::string A[N] = { \"red\", \"green\", \"blue\", \"violet\", \"cyan\",\n+\t\t\t     \"magenta\", \"yellow\", \"orange\", \"pink\", \"gray\" };\n+\n+  s.insert(A+0, A+N);\n+  VERIFY(s.size() == static_cast<unsigned int>(N));\n+  VERIFY(std::distance(s.begin(), s.end()) == N);\n+\n+  for (int i = 0; i < N; ++i) {\n+    std::string str = A[i];\n+    Set::iterator it = std::find(s.begin(), s.end(), str);\n+    VERIFY(it != s.end());\n+  }\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multiset<int> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  const int N = 8;\n+  const int A[N] = { 3, 7, 4, 8, 2, 4, 6, 7 };\n+\n+  s.insert(A+0, A+N);\n+  VERIFY(s.size() == static_cast<unsigned int>(N));\n+  VERIFY(std::distance(s.begin(), s.end()) == N);\n+\n+  VERIFY(std::count(s.begin(), s.end(), 2) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 3) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 4) == 2);\n+  VERIFY(std::count(s.begin(), s.end(), 6) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 7) == 2);\n+  VERIFY(std::count(s.begin(), s.end(), 8) == 1);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "f275e9a9bdde29041207e585181c60946d020eda", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/insert/multiset_single.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_single.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,67 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multiset<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  Set::iterator i = s.insert(\"abcde\");\n+  VERIFY(s.size() == 1);\n+  VERIFY(std::distance(s.begin(), s.end()) == 1);\n+  VERIFY(i == s.begin());\n+  VERIFY(*i == \"abcde\");\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multiset<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  s.insert(\"abcde\");\n+  Set::iterator i = s.insert(\"abcde\");\n+  VERIFY(s.size() == 2);\n+  VERIFY(std::distance(s.begin(), s.end()) == 2);\n+  VERIFY(*i == \"abcde\");\n+  \n+  Set::iterator i2 = s.begin();\n+  ++i2;\n+  VERIFY(i == s.begin() || i == i2);\n+  VERIFY(*(s.begin()) == \"abcde\" && *i2 == \"abcde\");\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "8f59773d802310633546263eca3b231a975fa7db", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/erase/1.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F1.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,128 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_set<std::string> Set;\n+  typedef Set::iterator       iterator;\n+  typedef Set::const_iterator const_iterator;\n+\n+  Set s1;\n+  \n+  s1.insert(\"because to why\");\n+  s1.insert(\"the stockholm syndrome\");\n+  s1.insert(\"a cereous night\");\n+  s1.insert(\"eeilo\");\n+  s1.insert(\"protean\");\n+  s1.insert(\"the way you are when\");\n+  s1.insert(\"tillsammans\");\n+  s1.insert(\"umbra/penumbra\");\n+  s1.insert(\"belonging (no longer mix)\");\n+  s1.insert(\"one line behind\");\n+  VERIFY( s1.size() == 10 );\n+\n+  VERIFY( s1.erase(\"eeilo\") == 1 );\n+  VERIFY( s1.size() == 9 );\n+  iterator it1 = s1.find(\"eeilo\");\n+  VERIFY( it1 == s1.end() );\n+\n+  VERIFY( s1.erase(\"tillsammans\") == 1 );\n+  VERIFY( s1.size() == 8 );\n+  iterator it2 = s1.find(\"tillsammans\");\n+  VERIFY( it2 == s1.end() );\n+\n+  // Must work (see DR 526)\n+  iterator it3 = s1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 != s1.end() );\n+  VERIFY( s1.erase(*it3) == 1 );\n+  VERIFY( s1.size() == 7 );\n+  it3 = s1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 == s1.end() );\n+\n+  VERIFY( !s1.erase(\"abra\") );\n+  VERIFY( s1.size() == 7 );\n+\n+  VERIFY( !s1.erase(\"eeilo\") );\n+  VERIFY( s1.size() == 7 );\n+\n+  VERIFY( s1.erase(\"because to why\") == 1 );\n+  VERIFY( s1.size() == 6 );\n+  iterator it4 = s1.find(\"because to why\");\n+  VERIFY( it4 == s1.end() );\n+\n+  iterator it5 = s1.find(\"umbra/penumbra\");\n+  iterator it6 = s1.find(\"one line behind\");\n+  VERIFY( it5 != s1.end() );\n+  VERIFY( it6 != s1.end() );\n+\n+  VERIFY( s1.find(\"the stockholm syndrome\") != s1.end() );\n+  VERIFY( s1.find(\"a cereous night\") != s1.end() );\n+  VERIFY( s1.find(\"the way you are when\") != s1.end() );\n+  VERIFY( s1.find(\"a cereous night\") != s1.end() );\n+\n+  VERIFY( s1.erase(*it5) == 1 );\n+  VERIFY( s1.size() == 5 );\n+  it5 = s1.find(\"umbra/penumbra\");\n+  VERIFY( it5 == s1.end() );\n+\n+  VERIFY( s1.erase(*it6) == 1 );\n+  VERIFY( s1.size() == 4 );\n+  it6 = s1.find(\"one line behind\");\n+  VERIFY( it6 == s1.end() );\n+\n+  iterator it7 = s1.begin();\n+  iterator it8 = it7;\n+  ++it8;\n+  iterator it9 = it8;\n+  ++it9;\n+\n+  VERIFY( s1.erase(*it8) == 1 );\n+  VERIFY( s1.size() == 3 );\n+  VERIFY( ++it7 == it9 );\n+\n+  iterator it10 = it9;\n+  ++it10;\n+  iterator it11 = it10;\n+\n+  VERIFY( s1.erase(*it9) == 1 );\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( ++it10 == s1.end() );\n+\n+  VERIFY( s1.erase(s1.begin()) != s1.end() );  \n+  VERIFY( s1.size() == 1 );\n+  VERIFY( s1.begin() == it11 );\n+\n+  VERIFY( s1.erase(*s1.begin()) == 1 );  \n+  VERIFY( s1.size() == 0 );\n+  VERIFY( s1.begin() == s1.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b4cdde62d571a88974f7b15d03e1d2be2ec1223a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/erase/24061-set.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F24061-set.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F24061-set.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F24061-set.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,104 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_set<std::string> Set;\n+  typedef Set::iterator       iterator;\n+  typedef Set::const_iterator const_iterator;\n+\n+  Set s1;\n+  \n+  s1.insert(\"all the love in the world\");\n+  s1.insert(\"you know what you are?\");\n+  s1.insert(\"the collector\");\n+  s1.insert(\"the hand that feeds\");\n+  s1.insert(\"love is not enough\");\n+  s1.insert(\"every day is exactly the same\");\n+  s1.insert(\"with teeth\");\n+  s1.insert(\"only\");\n+  s1.insert(\"getting smaller\");\n+  s1.insert(\"sunspots\");\n+  VERIFY( s1.size() == 10 );\n+\n+  iterator it1 = s1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = s1.erase(it1);\n+  VERIFY( s1.size() == 9 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = s1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = s1.erase(it4, it5);\n+  VERIFY( s1.size() == 7 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = s1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = s1.erase(it7);\n+  VERIFY( s1.size() == 6 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = s1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = s1.erase(it10, it11);\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+  VERIFY( ++it12 == s1.end() );\n+\n+  iterator it13 = s1.erase(s1.begin(), s1.end());\n+  VERIFY( s1.size() == 0 );\n+  VERIFY( it13 == s1.end() );\n+  VERIFY( it13 == s1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "54add351282ffdb18701f58c0e9b12495623f9b4", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/24061-set.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F24061-set.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F24061-set.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F24061-set.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_set<std::string> Set;\n+  typedef Set::iterator       iterator;\n+  typedef Set::const_iterator const_iterator;\n+\n+  Set s1;\n+  \n+  iterator it1 = s1.insert(s1.begin(), \"all the love in the world\");\n+  VERIFY( s1.size() == 1 );\n+  VERIFY( *it1 == \"all the love in the world\" );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = s1.insert(cit1, \"you know what you are?\");\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == \"you know what you are?\" );\n+\n+  iterator it2 = s1.insert(it1, \"all the love in the world\");\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( it2 == it1 );\n+  VERIFY( *it2 == \"all the love in the world\" );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "86bd326bde427dd68e6bec90c6621b37c3e71791", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/set_range.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_range.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,77 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <string>\n+#include <iterator>\n+#include <algorithm>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::unordered_set<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  const int N = 10;\n+  const std::string A[N] = { \"red\", \"green\", \"blue\", \"violet\", \"cyan\",\n+\t\t\t     \"magenta\", \"yellow\", \"orange\", \"pink\", \"gray\" };\n+\n+  s.insert(A+0, A+N);\n+  VERIFY(s.size() == static_cast<unsigned int>(N));\n+  VERIFY(std::distance(s.begin(), s.end()) == N);\n+\n+  for (int i = 0; i < N; ++i) {\n+    std::string str = A[i];\n+    Set::iterator it = std::find(s.begin(), s.end(), str);\n+    VERIFY(it != s.end());\n+  }\n+}\n+\n+void test02()\n+{\n+  typedef std::unordered_set<int> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  const int N = 8;\n+  const int A[N] = { 3, 7, 4, 8, 2, 4, 6, 7 };\n+\n+  s.insert(A+0, A+N);\n+  VERIFY(s.size() == 6);\n+  VERIFY(std::distance(s.begin(), s.end()) == 6);\n+\n+  VERIFY(std::count(s.begin(), s.end(), 2) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 3) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 4) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 6) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 7) == 1);\n+  VERIFY(std::count(s.begin(), s.end(), 8) == 1);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "d1288ce4255ac2d0ae74b43c9491254530576da5", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/set_single.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_single.cc?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_set<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  std::pair<Set::iterator, bool> p = s.insert(\"abcde\");\n+  VERIFY(p.second);\n+  VERIFY(s.size() == 1);\n+  VERIFY(std::distance(s.begin(), s.end()) == 1);\n+  VERIFY(p.first == s.begin());\n+  VERIFY(*p.first == \"abcde\");\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_set<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  std::pair<Set::iterator, bool> p1 = s.insert(\"abcde\");\n+  std::pair<Set::iterator, bool> p2 = s.insert(\"abcde\");  \n+  VERIFY(p1.second);\n+  VERIFY(!p2.second);\n+  VERIFY(s.size() == 1);\n+  VERIFY(p1.first == p2.first);\n+  VERIFY(*p1.first == \"abcde\");\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "23862bcdbeef6537e101d27d2174bd3ab0aa726c", "filename": "libstdc++-v3/testsuite/util/exception/safety.h", "status": "modified", "additions": 138, "deletions": 2, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2524b12683ad95e582a4fc74ae19c6927a398d/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h?ref=3b2524b12683ad95e582a4fc74ae19c6927a398d", "patch": "@@ -275,6 +275,78 @@ namespace __gnu_test\n \t  _F_erase_range(&container_type::erase_after) { }\n       };\n \n+    // Specializations for the unordered containers.\n+    template<typename _Tp1, typename _Tp2, typename _Tp3,\n+\t     typename _Tp4, typename _Tp5>\n+      struct erase_base<std::unordered_map<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>>\n+      {\n+\ttypedef std::unordered_map<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\n+\titerator (container_type::* _F_erase_point)(const_iterator);\n+\titerator (container_type::* _F_erase_range)(const_iterator,\n+\t\t\t\t\t\t    const_iterator);\n+\n+\terase_base()\n+\t: _F_erase_point(&container_type::erase),\n+\t  _F_erase_range(&container_type::erase) { }\n+      };\n+\n+    template<typename _Tp1, typename _Tp2, typename _Tp3,\n+\t     typename _Tp4, typename _Tp5>\n+      struct erase_base<std::unordered_multimap<_Tp1, _Tp2, _Tp3,\n+\t\t\t\t\t\t_Tp4, _Tp5>>\n+      {\n+\ttypedef std::unordered_multimap<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\n+\titerator (container_type::* _F_erase_point)(const_iterator);\n+\titerator (container_type::* _F_erase_range)(const_iterator,\n+\t\t\t\t\t\t    const_iterator);\n+\n+\terase_base()\n+\t: _F_erase_point(&container_type::erase),\n+\t  _F_erase_range(&container_type::erase) { }\n+      };\n+\n+    template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+      struct erase_base<std::unordered_set<_Tp1, _Tp2, _Tp3, _Tp4>>\n+      {\n+\ttypedef std::unordered_set<_Tp1, _Tp2, _Tp3, _Tp4>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\n+\titerator (container_type::* _F_erase_point)(const_iterator);\n+\titerator (container_type::* _F_erase_range)(const_iterator,\n+\t\t\t\t\t\t    const_iterator);\n+\n+\terase_base()\n+\t: _F_erase_point(&container_type::erase),\n+\t  _F_erase_range(&container_type::erase) { }\n+      };\n+\n+    template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+      struct erase_base<std::unordered_multiset<_Tp1, _Tp2, _Tp3, _Tp4>>\n+      {\n+\ttypedef std::unordered_multiset<_Tp1, _Tp2, _Tp3, _Tp4>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\n+\titerator (container_type::* _F_erase_point)(const_iterator);\n+\titerator (container_type::* _F_erase_range)(const_iterator,\n+\t\t\t\t\t\t    const_iterator);\n+\n+\terase_base()\n+\t: _F_erase_point(&container_type::erase),\n+\t  _F_erase_range(&container_type::erase) { }\n+      };\n+\n     template<typename _Tp, bool = traits<_Tp>::has_erase::value>\n       struct erase_point : public erase_base<_Tp>\n       {\n@@ -532,15 +604,79 @@ namespace __gnu_test\n       {\n \ttypedef std::forward_list<_Tp1, _Tp2> container_type;\n \ttypedef typename container_type::iterator \titerator;\n-\ttypedef typename container_type::const_iterator \tconst_iterator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n \ttypedef typename container_type::value_type \tvalue_type;\n \n \titerator (container_type::* _F_insert_point)(const_iterator,\n-\t\t\t\t\t\t   const value_type&);\n+\t\t\t\t\t\t     const value_type&);\n \n \tinsert_base() : _F_insert_point(&container_type::insert_after) { }\n       };\n \n+    // Likewise for the unordered containers.\n+    template<typename _Tp1, typename _Tp2, typename _Tp3,\n+\t     typename _Tp4, typename _Tp5>\n+      struct insert_base<std::unordered_map<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>>\n+      {\n+\ttypedef std::unordered_map<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\titerator (container_type::* _F_insert_point)(const_iterator,\n+\t\t\t\t\t\t     const value_type&);\n+\n+\tinsert_base() : _F_insert_point(&container_type::insert) { }\n+      };\n+\n+    template<typename _Tp1, typename _Tp2, typename _Tp3,\n+\t     typename _Tp4, typename _Tp5>\n+      struct insert_base<std::unordered_multimap<_Tp1, _Tp2, _Tp3,\n+\t\t\t\t\t\t _Tp4, _Tp5>>\n+      {\n+\ttypedef std::unordered_multimap<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\titerator (container_type::* _F_insert_point)(const_iterator,\n+\t\t\t\t\t\t     const value_type&);\n+\n+\tinsert_base() : _F_insert_point(&container_type::insert) { }\n+      };\n+\n+    template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+      struct insert_base<std::unordered_set<_Tp1, _Tp2, _Tp3, _Tp4>>\n+      {\n+\ttypedef std::unordered_set<_Tp1, _Tp2, _Tp3, _Tp4>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\titerator (container_type::* _F_insert_point)(const_iterator,\n+\t\t\t\t\t\t     const value_type&);\n+\n+\tinsert_base() : _F_insert_point(&container_type::insert) { }\n+      };\n+\n+    template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+      struct insert_base<std::unordered_multiset<_Tp1, _Tp2, _Tp3, _Tp4>>\n+      {\n+\ttypedef std::unordered_multiset<_Tp1, _Tp2, _Tp3, _Tp4>\n+\t                                                container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator const_iterator;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\titerator (container_type::* _F_insert_point)(const_iterator,\n+\t\t\t\t\t\t     const value_type&);\n+\n+\tinsert_base() : _F_insert_point(&container_type::insert) { }\n+      };\n+\n     template<typename _Tp, bool = traits<_Tp>::has_insert::value>\n       struct insert_point : public insert_base<_Tp>\n       {"}]}