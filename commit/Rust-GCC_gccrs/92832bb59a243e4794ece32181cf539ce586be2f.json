{"sha": "92832bb59a243e4794ece32181cf539ce586be2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI4MzJiYjU5YTI0M2U0Nzk0ZWNlMzIxODFjZjUzOWNlNTg2YmUyZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-09-02T10:50:41Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-09-02T10:50:41Z"}, "message": "Update basic block profiling.\n\nFrom-SVN: r5249", "tree": {"sha": "f23a1dabf061c86aef05637db8a61df8e1d2014e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f23a1dabf061c86aef05637db8a61df8e1d2014e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92832bb59a243e4794ece32181cf539ce586be2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92832bb59a243e4794ece32181cf539ce586be2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92832bb59a243e4794ece32181cf539ce586be2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92832bb59a243e4794ece32181cf539ce586be2f/comments", "author": null, "committer": null, "parents": [{"sha": "9d436547f74b4828480c6d8efddc8bd2afc752aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d436547f74b4828480c6d8efddc8bd2afc752aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d436547f74b4828480c6d8efddc8bd2afc752aa"}], "stats": {"total": 541, "additions": 473, "deletions": 68}, "files": [{"sha": "7fce7ed0b7f27f08e5b4d3124db3ce3952b3a756", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=92832bb59a243e4794ece32181cf539ce586be2f", "patch": "@@ -971,7 +971,7 @@ reorg.o : reorg.c $(CONFIG_H) $(RTL_H) conditions.h hard-reg-set.h \\\n    flags.h output.h\n sched.o : sched.c $(CONFIG_H) $(RTL_H) basic-block.h regs.h hard-reg-set.h \\\n    flags.h insn-config.h insn-attr.h\n-final.o : final.c $(CONFIG_H) $(RTL_H) gvarargs.h flags.h regs.h \\\n+final.o : final.c $(CONFIG_H) $(RTL_H) $(TREE_H) gvarargs.h flags.h regs.h \\\n    recog.h conditions.h insn-config.h insn-attr.h real.h output.h \\\n    hard-reg-set.h insn-flags.h insn-codes.h gstab.h xcoffout.h defaults.h\n recog.o : recog.c $(CONFIG_H) $(RTL_H)  \\"}, {"sha": "86b3414c16b97e68a4c60aeeaa07c6f47fe4d340", "filename": "gcc/config/m68k/sun3.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2Fconfig%2Fm68k%2Fsun3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2Fconfig%2Fm68k%2Fsun3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3.h?ref=92832bb59a243e4794ece32181cf539ce586be2f", "patch": "@@ -275,3 +275,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n           asm_fprintf (FILE, \"%I0r%s\", dstr);\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\\\n     } while (0)\n+\n+#undef BLOCK_PROFILER_CODE\n+#define BLOCK_PROFILER_CODE\t\t\t\t\t\t\\\n+extern int ___tcov_init;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+__bb_init_func (blocks)\t\t\t\t\t\t\t\\\n+\tstruct bb *blocks;\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (! ___tcov_init)\t\t\t\t\t\t\t\\\n+    ___tcov_init_func ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  ___bb_link (blocks->filename, blocks->counts, blocks->ncounts);\t\\\n+}"}, {"sha": "7541c1802b058bc6524b784c76f39cdd2f0c27bf", "filename": "gcc/final.c", "status": "modified", "additions": 277, "deletions": 49, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=92832bb59a243e4794ece32181cf539ce586be2f", "patch": "@@ -45,6 +45,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"config.h\"\n #include \"gvarargs.h\"\n+#include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"insn-config.h\"\n@@ -137,6 +138,9 @@ static rtx debug_insn = 0;\n /* Line number of last NOTE.  */\n static int last_linenum;\n \n+/* Filename of last NOTE.  */\n+static char *last_filename;\n+\n /* Number of basic blocks seen so far;\n    used if profile_block_flag is set.  */\n static int count_basic_blocks;\n@@ -239,6 +243,37 @@ rtx final_sequence;\n /* Indexed by line number, nonzero if there is a note for that line.  */\n \n static char *line_note_exists;\n+\n+/* Linked list to hold line numbers for each basic block.  */\n+\n+struct bb_list {\n+  struct bb_list *next;\t\t/* pointer to next basic block */\n+  int line_num;\t\t\t/* line number */\n+  int file_label_num;\t\t/* LPBC<n> label # for stored filename */\n+  int func_label_num;\t\t/* LPBC<n> label # for stored function name */\n+};\n+\n+static struct bb_list *bb_head\t= 0;\t\t/* Head of basic block list */\n+static struct bb_list **bb_tail = &bb_head;\t/* Ptr to store next bb ptr */\n+static int bb_file_label_num\t= -1;\t\t/* Current label # for file */\n+static int bb_func_label_num\t= -1;\t\t/* Current label # for func */\n+\n+/* Linked list to hold the strings for each file and function name output.  */\n+\n+struct bb_str {\n+  struct bb_str *next;\t\t/* pointer to next string */\n+  char *string;\t\t\t/* string */\n+  int label_num;\t\t/* label number */\n+  int length;\t\t\t/* string length */\n+};\n+\n+static struct bb_str *sbb_head\t= 0;\t\t/* Head of string list.  */\n+static struct bb_str **sbb_tail\t= &sbb_head;\t/* Ptr to store next bb str */\n+static int sbb_label_num\t= 0;\t\t/* Last label used */\n+\n+static int add_bb_string PROTO((char *, int));\n+static void add_bb PROTO((FILE *));\n+\n \f\n /* Initialize data in final at the beginning of a compilation.  */\n \n@@ -264,34 +299,81 @@ end_final (filename)\n \n   if (profile_block_flag)\n     {\n-      char name[12];\n+      char name[20];\n+      int align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n+      int size = (INT_TYPE_SIZE / BITS_PER_UNIT) * count_basic_blocks;\n+      int rounded = size;\n+      struct bb_list *ptr;\n+      struct bb_str *sptr;\n+\n+      rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n+      rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+\t\t * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n \n       data_section ();\n \n-      /* Output the main header, of 6 words:\n+      /* Output the main header, of 10 words:\n \t 0:  1 if this file's initialized, else 0.\n-\t 1:  address of file name.\n-\t 2:  address of table of counts.\n-\t 4:  number of counts in the table.\n-\t 5:  always 0, for compatibility with Sun.\n-\t 6:  extra word added by GNU: address of address table\n-\t      which contains addresses of basic blocks,\n-\t      in parallel with the table of counts.  */\n-      ASM_OUTPUT_ALIGN (asm_out_file,\n-\t\t\texact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+\t 1:  address of file name (LPBX1).\n+\t 2:  address of table of counts (LPBX2).\n+\t 3:  number of counts in the table.\n+\t 4:  always 0, for compatibility with Sun.\n+\n+         The following are GNU extensions:\n+\n+\t 5:  address of table of start addrs of basic blocks (LPBX3).\n+\t 6:  Number of bytes in this header.\n+\t 7:  address of table of function names (LPBX4).\n+\t 8:  address of table of line numbers (LPBX5) or 0.\n+\t 9:  address of table of file names (LPBX6) or 0.  */\n+\n+      ASM_OUTPUT_ALIGN (asm_out_file, align);\n \n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 0);\n+      /* zero word */\n       assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\n+      /* address of filename */\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 1);\n       assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+\n+      /* address of count table */\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n       assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+\n+      /* count of the # of basic blocks */\n       assemble_integer (GEN_INT (count_basic_blocks), UNITS_PER_WORD, 1);\n+\n+      /* zero word (link field) */\n       assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\n+      /* address of basic block start address table */\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n       assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n \n-      /* Output the file name.  */\n+      /* byte count for extended structure.  */\n+      assemble_integer (GEN_INT (10 * UNITS_PER_WORD), UNITS_PER_WORD, 1);\n+\n+      /* address of function name table */\n+      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 4);\n+      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+\n+      /* address of line number and filename tables if debugging.  */\n+      if (write_symbols != NO_DEBUG)\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 5);\n+\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 6);\n+\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+\t}\n+      else\n+\t{\n+\t  assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\t  assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\t}\n+\n+      /* Output the file name changing the suffix to .d for Sun tcov\n+\t compatibility.  */\n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 1);\n       {\n \tint len = strlen (filename);\n@@ -302,29 +384,98 @@ end_final (filename)\n \tassemble_string (data_file, strlen (data_file) + 1);\n       }\n \n-      /* Realign data section.  */\n-      ASM_OUTPUT_ALIGN (asm_out_file,\n-\t\t\texact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-\n       /* Make space for the table of counts.  */\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 2);\n-      if (count_basic_blocks != 0)\n-\tassemble_zeros (INT_TYPE_SIZE / BITS_PER_UNIT * count_basic_blocks);\n+      if (flag_no_common || size == 0)\n+\t{\n+\t  /* Realign data section.  */\n+\t  ASM_OUTPUT_ALIGN (asm_out_file, align);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 2);\n+\t  if (size != 0)\n+\t    assemble_zeros (size);\n+\t}\n+      else\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n+#ifdef ASM_OUTPUT_SHARED_LOCAL\n+\t  if (flag_shared_data)\n+\t    ASM_OUTPUT_SHARED_LOCAL (asm_out_file, name, size, rounded);\n+\t  else\n+#endif\n+#ifdef ASM_OUTPUT_ALIGNED_LOCAL\n+\t    ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, align);\n+#else\n+\t    ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+#endif\n+\t}\n \n-      /* Output the table of addresses.  */\n+      /* Output any basic block strings */\n       readonly_data_section ();\n+      if (sbb_head)\n+\t{\n+\t  ASM_OUTPUT_ALIGN (asm_out_file, align);\n+\t  for (sptr = sbb_head; sptr != 0; sptr = sptr->next)\n+\t    {\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBC\", sptr->label_num);\n+\t      assemble_string (sptr->string, sptr->length);\n+\t    }\n+\t}\n+\n+      /* Output the table of addresses.  */\n       /* Realign in new section */\n-      ASM_OUTPUT_ALIGN (asm_out_file,\n-\t\t\tfloor_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+      ASM_OUTPUT_ALIGN (asm_out_file, align);\n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 3);\n       for (i = 0; i < count_basic_blocks; i++)\n \t{\n-\t  char name[12];\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPB\", i);\n \t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name),\n \t\t\t    UNITS_PER_WORD, 1);\n \t}\n \n+      /* Output the table of function names.  */\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 4);\n+      for ((ptr = bb_head), (i = 0); ptr != 0; (ptr = ptr->next), i++)\n+\t{\n+\t  if (ptr->func_label_num >= 0)\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBC\", ptr->func_label_num);\n+\t      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name),\n+\t\t\t\tUNITS_PER_WORD, 1);\n+\t    }\n+\t  else\n+\t    assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\t}\n+\n+      for ( ; i < count_basic_blocks; i++)\n+\tassemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\n+      if (write_symbols != NO_DEBUG)\n+\t{\n+\t  /* Output the table of line numbers.  */\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 5);\n+\t  for ((ptr = bb_head), (i = 0); ptr != 0; (ptr = ptr->next), i++)\n+\t    assemble_integer (GEN_INT (ptr->line_num), UNITS_PER_WORD, 1);\n+\n+\t  for ( ; i < count_basic_blocks; i++)\n+\t    assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\n+\t  /* Output the table of file names.  */\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 6);\n+\t  for ((ptr = bb_head), (i = 0); ptr != 0; (ptr = ptr->next), i++)\n+\t    {\n+\t      if (ptr->file_label_num >= 0)\n+\t\t{\n+\t\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBC\", ptr->file_label_num);\n+\t\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name),\n+\t\t\t\t    UNITS_PER_WORD, 1);\n+\t\t}\n+\t      else\n+\t\tassemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\t    }\n+\n+\t  for ( ; i < count_basic_blocks; i++)\n+\t    assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\t}\n+\n       /* End with the address of the table of addresses,\n \t so we can find it easily, as the last word in the file's text.  */\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n@@ -761,6 +912,15 @@ final_start_function (first, file, optimize)\n     profile_after_prologue (file);\n \n   profile_label_no++;\n+\n+  /* If we are doing basic block profiling, remember a printable version\n+     of the function name.  */\n+  if (profile_block_flag)\n+    {\n+      char *junk = \"function\";\n+      bb_func_label_num =\n+\tadd_bb_string ((*decl_printable_name) (current_function_decl, &junk), FALSE);\n+    }\n }\n \n static void\n@@ -894,9 +1054,92 @@ final_end_function (first, file, optimize)\n     xcoffout_end_epilogue (file);\n #endif\n \n+  bb_func_label_num = -1;\t/* not in function, nuke label # */\n+\n   /* If FUNCTION_EPILOGUE is not defined, then the function body\n      itself contains return instructions wherever needed.  */\n }\n+\f\n+/* Add a block to the linked list that remembers the current line/file/function\n+   for basic block profiling.  Emit the label in front of the basic block and\n+   the instructions that increment the count field.  */\n+\n+static void\n+add_bb (file)\n+     FILE *file;\n+{\n+  struct bb_list *ptr = (struct bb_list *) permalloc (sizeof (struct bb_list));\n+\n+  /* Add basic block to linked list.  */\n+  ptr->next = 0;\n+  ptr->line_num = last_linenum;\n+  ptr->file_label_num = bb_file_label_num;\n+  ptr->func_label_num = bb_func_label_num;\n+  *bb_tail = ptr;\n+  bb_tail = &ptr->next;\n+\n+  /* Enable the table of basic-block use counts\n+     to point at the code it applies to.  */\n+  ASM_OUTPUT_INTERNAL_LABEL (file, \"LPB\", count_basic_blocks);\n+\n+  /* Before first insn of this basic block, increment the\n+     count of times it was entered.  */\n+#ifdef BLOCK_PROFILER\n+  BLOCK_PROFILER (file, count_basic_blocks);\n+  CC_STATUS_INIT;\n+#endif\n+\n+  new_block = 0;\n+  count_basic_blocks++;\n+}\n+\n+/* Add a string to be used for basic block profiling.  */\n+\n+static int\n+add_bb_string (string, perm_p)\n+     char *string;\n+     int perm_p;\n+{\n+  int len;\n+  struct bb_str *ptr = 0;\n+\n+  if (!string)\n+    {\n+      string = \"<unknown>\";\n+      perm_p = TRUE;\n+    }\n+\n+  /* Allocate a new string if the current string isn't permanent.  If\n+     the string is permanent search for the same string in other\n+     allocations.  */\n+\n+  len = strlen (string) + 1;\n+  if (!perm_p)\n+    {\n+      char *p = (char *) permalloc (len);\n+      bcopy (string, p, len);\n+      string = p;\n+    }\n+  else\n+    for (ptr = sbb_head; ptr != (struct bb_str *)0; ptr = ptr->next)\n+      if (ptr->string == string)\n+\tbreak;\n+\n+  /* Allocate a new string block if we need to.  */\n+  if (!ptr)\n+    {\n+      ptr = (struct bb_str *) permalloc (sizeof (*ptr));\n+      ptr->next = 0;\n+      ptr->length = len;\n+      ptr->label_num = sbb_label_num++;\n+      ptr->string = string;\n+      *sbb_tail = ptr;\n+      sbb_tail = &ptr->next;\n+    }\n+\n+  return ptr->label_num;\n+}\n+\n \f\n /* Output assembler code for some insns: all or part of a function.\n    For description of args, see `final_start_function', above.\n@@ -974,19 +1217,7 @@ final (first, file, optimize, prescan)\n   /* Do basic-block profiling here\n      if the last insn was a conditional branch.  */\n   if (profile_block_flag && new_block)\n-    {\n-      new_block = 0;\n-      /* Enable the table of basic-block use counts\n-\t to point at the code it applies to.  */\n-      ASM_OUTPUT_INTERNAL_LABEL (file, \"LPB\", count_basic_blocks);\n-      /* Before first insn of this basic block, increment the\n-\t count of times it was entered.  */\n-#ifdef BLOCK_PROFILER\n-      BLOCK_PROFILER (file, count_basic_blocks);\n-      CC_STATUS_INIT;\n-#endif\n-      count_basic_blocks++;\n-    }\n+    add_bb (file);\n }\n \f\n /* The final scan for one insn, INSN.\n@@ -1354,19 +1585,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t/* Do basic-block profiling when we reach a new block.\n \t   Done here to avoid jump tables.  */\n \tif (profile_block_flag && new_block)\n-\t  {\n-\t    new_block = 0;\n-\t    /* Enable the table of basic-block use counts\n-\t       to point at the code it applies to.  */\n-\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LPB\", count_basic_blocks);\n-\t    /* Before first insn of this basic block, increment the\n-\t       count of times it was entered.  */\n-#ifdef BLOCK_PROFILER\n-\t    BLOCK_PROFILER (file, count_basic_blocks);\n-\t    CC_STATUS_INIT;\n-#endif\n-\t    count_basic_blocks++;\n-\t  }\n+\t  add_bb (file);\n \n \tif (GET_CODE (body) == ASM_INPUT)\n \t  {\n@@ -1777,6 +1996,15 @@ output_source_line (file, insn)\n   char ltext_label_name[100];\n   register char *filename = NOTE_SOURCE_FILE (insn);\n \n+  /* Remember filename for basic block profiling.\n+     Filenames are allocated on the permanent obstack\n+     or are passed in ARGV, so we don't have to save\n+     the string.  */\n+\n+  if (profile_block_flag && last_filename != filename)\n+    bb_file_label_num = add_bb_string (filename, TRUE);\n+\n+  last_filename = filename;\n   last_linenum = NOTE_LINE_NUMBER (insn);\n \n   if (write_symbols != NO_DEBUG)"}, {"sha": "48c0b91d5d86eced9f8189a2b79cff15d2bdd983", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 182, "deletions": 18, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92832bb59a243e4794ece32181cf539ce586be2f/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=92832bb59a243e4794ece32181cf539ce586be2f", "patch": "@@ -1285,35 +1285,199 @@ __eprintf (string, expression, line, filename)\n #endif\n \n #ifdef L_bb\n-/* Avoid warning from ranlib about empty object file.  */\n-void\n-__bb_avoid_warning ()\n-{}\n \n-#if defined (__sun__) && defined (__mc68000__)\n+/* Structure emitted by -a  */\n struct bb\n {\n-  int initialized;\n-  char *filename;\n-  int *counts;\n-  int ncounts;\n-  int zero_word;\n-  int *addresses;\n+  long zero_word;\n+  const char *filename;\n+  long *counts;\n+  long ncounts;\n+  struct bb *next;\n+  const unsigned long *addresses;\n+\n+  /* Older GCC's did not emit these fields.  */\n+  long nwords;\n+  const char **functions;\n+  const long *line_nums;\n+  const char **filenames;\n };\n \n-extern int ___tcov_init;\n+#ifdef BLOCK_PROFILER_CODE\n+BLOCK_PROFILER_CODE\n+#else\n+\n+/* Simple minded basic block profiling output dumper for\n+   systems that don't provde tcov support.  At present,\n+   it requires atexit and stdio.  */\n+\n+#include <stdio.h>\n \n-__bb_init_func (blocks)\n-\tstruct bb *blocks;\n+#ifdef HAVE_ATEXIT\n+extern void atexit (void (*) (void));\n+#define ON_EXIT(FUNC,ARG) atexit ((FUNC))\n+#else\n+#ifdef sun\n+extern void on_exit (void*, void*);\n+#define ON_EXIT(FUNC,ARG) on_exit ((FUNC), (ARG))\n+#endif\n+#endif\n+\n+static struct bb *bb_head = (struct bb *)0;\n+\n+/* Return the number of digits needed to print a value */\n+/* __inline__ */ static int num_digits (long value, int base)\n {\n-  if (! ___tcov_init)\n-    ___tcov_init_func ();\n+  int minus = (value < 0 && base != 16);\n+  unsigned long v = (minus) ? -value : value;\n+  int ret = minus;\n \n-  ___bb_link (blocks->filename, blocks->counts, blocks->ncounts);\n+  do\n+    {\n+      v /= base;\n+      ret++;\n+    }\n+  while (v);\n+\n+  return ret;\n }\n \n+void\n+__bb_exit_func (void)\n+{\n+  FILE *file = fopen (\"bb.out\", \"a\");\n+  long time_value;\n+\n+  if (!file)\n+    perror (\"bb.out\");\n+\n+  else\n+    {\n+      struct bb *ptr;\n+\n+      /* This is somewhat type incorrect, but it avoids worrying about\n+\t exactly where time.h is included from.  It should be ok unless\n+\t a void * differs from other pointer formats, or if sizeof(long)\n+\t is < sizeof (time_t).  It would be nice if we could assume the\n+\t use of rationale standards here.  */\n+\n+      time((void *) &time_value);\n+      fprintf (file, \"Basic block profiling finished on %s\\n\", ctime ((void *) &time_value));\n+\n+      /* We check the length field explicitly in order to allow compatibility\n+\t with older GCC's which did not provide it.  */\n+\n+      for (ptr = bb_head; ptr != (struct bb *)0; ptr = ptr->next)\n+\t{\n+\t  int i;\n+\t  int func_p\t= (ptr->nwords >= sizeof (struct bb) && ptr->nwords <= 1000);\n+\t  int line_p\t= (func_p && ptr->line_nums);\n+\t  int file_p\t= (func_p && ptr->filenames);\n+\t  long ncounts\t= ptr->ncounts;\n+\t  long cnt_max  = 0;\n+\t  long line_max = 0;\n+\t  long addr_max = 0;\n+\t  int file_len\t= 0;\n+\t  int func_len\t= 0;\n+\t  int blk_len\t= num_digits (ncounts, 10);\n+\t  int cnt_len;\n+\t  int line_len;\n+\t  int addr_len;\n+\n+\t  fprintf (file, \"File %s, %ld basic blocks \\n\\n\",\n+\t\t   ptr->filename, ncounts);\n+\n+\t  /* Get max values for each field.  */\n+\t  for (i = 0; i < ncounts; i++)\n+\t    {\n+\t      const char *p;\n+\t      int len;\n+\n+\t      if (cnt_max < ptr->counts[i])\n+\t\tcnt_max = ptr->counts[i];\n+\n+\t      if (addr_max < ptr->addresses[i])\n+\t\taddr_max = ptr->addresses[i];\n+\n+\t      if (line_p && line_max < ptr->line_nums[i])\n+\t\tline_max = ptr->line_nums[i];\n+\n+\t      if (func_p)\n+\t\t{\n+\t\t  p = (ptr->functions[i]) ? (ptr->functions[i]) : \"<none>\";\n+\t\t  len = strlen (p);\n+\t\t  if (func_len < len)\n+\t\t    func_len = len;\n+\t\t}\n+\n+\t      if (file_p)\n+\t\t{\n+\t\t  p = (ptr->filenames[i]) ? (ptr->filenames[i]) : \"<none>\";\n+\t\t  len = strlen (p);\n+\t\t  if (file_len < len)\n+\t\t    file_len = len;\n+\t\t}\n+\t    }\n+\n+\t  addr_len = num_digits (addr_max, 16);\n+\t  cnt_len  = num_digits (cnt_max, 10);\n+\t  line_len = num_digits (line_max, 10);\n+\n+\t  /* Now print out the basic block information.  */\n+\t  for (i = 0; i < ncounts; i++)\n+\t    {\n+\t      fprintf (file,\n+\t\t       \"    Block #%*d: executed %*ld time(s) address=0x%.*lx\",\n+\t\t       blk_len, i+1,\n+\t\t       cnt_len, ptr->counts[i],\n+\t\t       addr_len, ptr->addresses[i]);\n+\n+\t      if (func_p)\n+\t\tfprintf (file, \" function=%-*s\", func_len,\n+\t\t\t (ptr->functions[i]) ? ptr->functions[i] : \"<none>\");\n+\n+\t      if (line_p)\n+\t\tfprintf (file, \" line=%*d\", line_len, ptr->line_nums[i]);\n+\n+\t      if (file_p)\n+\t\tfprintf (file, \" file=%s\",\n+\t\t\t (ptr->filenames[i]) ? ptr->filenames[i] : \"<none>\");\n+\n+\t      fprintf (file, \"\\n\");\n+\t    }\n+\n+\t  fprintf (file, \"\\n\");\n+\t  fflush (file);\n+\t}\n+\n+      fprintf (file, \"\\n\\n\");\n+      fclose (file);\n+    }\n+}\n+\n+void\n+__bb_init_func (struct bb *blocks)\n+{\n+  /* User is supposed to check whether the first word is non-0,\n+     but just in case.... */\n+\n+  if (blocks->zero_word)\n+    return;\n+\n+#ifdef ON_EXIT\n+  /* Initialize destructor.  */\n+  if (!bb_head)\n+    ON_EXIT (__bb_exit_func, 0);\n #endif\n-#endif\n+\n+  /* Set up linked list.  */\n+  blocks->zero_word = 1;\n+  blocks->next = bb_head;\n+  bb_head = blocks;\n+}\n+\n+#endif\t/* !BLOCK_PROFILER_CODE */\n+#endif\t/* L_bb */\n \f\n /* frills for C++ */\n "}]}