{"sha": "e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUzYTE2ZTc1ZjNjYmFhYTQ2ZTVjZTJmYzFlZDQ0OWExOGVlZjdkOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-02-01T01:09:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-02-01T01:09:35Z"}, "message": "lower-subreg.c: New file.\n\ngcc/:\n\t* lower-subreg.c: New file.\n\t* rtl.def (CONCATN): Define.\n\t* passes.c (init_optimization_passes): Add pass_lower_subreg and\n\tpass_lower_subreg2.\n\t* emit-rtl.c (update_reg_offset): New static function, broken out\n\tof gen_rtx_REG_offset.\n\t(gen_rtx_REG_offset): Call update_reg_offset.\n\t(gen_reg_rtx_offset): New function.\n\t* regclass.c: Revert patch of 2006-03-05, restoring\n\treg_scan_update.\n\t(clear_reg_info_regno): New function.\n\t* dwarf2out.c (concatn_loc_descriptor): New static function.\n\t(loc_descriptor): Handle CONCATN.\n\t* common.opt (fsplit_wide_types): New option.\n\t* opts.c (decode_options): Set flag_split_wide_types when\n\toptimizing.\n\t* timevar.def (TV_LOWER_SUBREG): Define.\n\t* rtl.h (gen_reg_rtx_offset): Declare.\n\t(reg_scan_update): Declare.\n\t* regs.h (clear_reg_info_regno): Declare.\n\t* tree-pass.h (pass_lower_subreg): Declare.\n\t(pass_lower_subreg2): Declare.\n\t* doc/invoke.texi (Option Summary): List -fno-split-wide-types.\n\t(Optimize Options): Add -fsplit-wide-types to -O1 list.  Document\n\t-fsplit-wide-types.\n\t* doc/rtl.texi (Regs and Memory): Document concat and concatn.\n\t* Makefile.in (OBJS-common): Add lower-subreg.o.\n\t(lower-subreg.o): New target.\ngcc/testsuite/:\n\t* gcc.dg/lower-subreg-1.c (test): New test.\n\nFrom-SVN: r121453", "tree": {"sha": "ef18ae23759d8cebf30524fd23a40023979adb9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef18ae23759d8cebf30524fd23a40023979adb9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/comments", "author": null, "committer": null, "parents": [{"sha": "15c48c45f552564d65a3cc869b2a8f896492f05f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c48c45f552564d65a3cc869b2a8f896492f05f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15c48c45f552564d65a3cc869b2a8f896492f05f"}], "stats": {"total": 1391, "additions": 1358, "deletions": 33}, "files": [{"sha": "57598a01cea9f7c64e18976ce1a32e16ba0f0c08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,3 +1,35 @@\n+2007-01-31  Richard Henderson  <rth@redhat.com>\n+\t    Ian Lance Taylor  <iant@google.com>\n+\n+\t* lower-subreg.c: New file.\n+\t* rtl.def (CONCATN): Define.\n+\t* passes.c (init_optimization_passes): Add pass_lower_subreg and\n+\tpass_lower_subreg2.\n+\t* emit-rtl.c (update_reg_offset): New static function, broken out\n+\tof gen_rtx_REG_offset.\n+\t(gen_rtx_REG_offset): Call update_reg_offset.\n+\t(gen_reg_rtx_offset): New function.\n+\t* regclass.c: Revert patch of 2006-03-05, restoring\n+\treg_scan_update.\n+\t(clear_reg_info_regno): New function.\n+\t* dwarf2out.c (concatn_loc_descriptor): New static function.\n+\t(loc_descriptor): Handle CONCATN.\n+\t* common.opt (fsplit_wide_types): New option.\n+\t* opts.c (decode_options): Set flag_split_wide_types when\n+\toptimizing.\n+\t* timevar.def (TV_LOWER_SUBREG): Define.\n+\t* rtl.h (gen_reg_rtx_offset): Declare.\n+\t(reg_scan_update): Declare.\n+\t* regs.h (clear_reg_info_regno): Declare.\n+\t* tree-pass.h (pass_lower_subreg): Declare.\n+\t(pass_lower_subreg2): Declare.\n+\t* doc/invoke.texi (Option Summary): List -fno-split-wide-types.\n+\t(Optimize Options): Add -fsplit-wide-types to -O1 list.  Document\n+\t-fsplit-wide-types.\n+\t* doc/rtl.texi (Regs and Memory): Document concat and concatn.\n+\t* Makefile.in (OBJS-common): Add lower-subreg.o.\n+\t(lower-subreg.o): New target.\n+\n 2007-01-31  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/sh/sh.h (HAVE_SECONDARY_RELOADS): Remove."}, {"sha": "f22407f8f79808e267251f7ff2ad24a073472c99", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1023,6 +1023,7 @@ OBJS-common = \\\n \tloop-iv.o \\\n \tloop-unroll.o \\\n \tloop-unswitch.o \\\n+\tlower-subreg.o \\\n \tmode-switching.o \\\n \tmodulo-sched.o \\\n \tomp-low.o \\\n@@ -2772,6 +2773,10 @@ hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)\n pretty-print.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h $(PRETTY_PRINT_H) \\\n    $(TREE_H)\n errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h $(BCONFIG_H)\n+lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(MACHMODE_H) $(TM_H) $(RTL_H) $(TM_P_H) $(TIMEVAR_H) $(FLAGS_H) \\\n+   insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) $(OBSTACK_H) bitmap.h \\\n+   $(EXPR_H) $(REGS_H) tree-pass.h\n \n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\"}, {"sha": "0f1020c157fb7b37cb5da064a36267bfe9645ae4", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,6 @@\n ; Options for the language- and target-independent parts of the compiler.\n \n-; Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+; Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -861,6 +861,10 @@ fsplit-ivs-in-unroller\n Common Report Var(flag_split_ivs_in_unroller) Init(1)\n Split lifetimes of induction variables when loops are unrolled\n \n+fsplit-wide-types\n+Common Report Var(flag_split_wide_types)\n+Split wide types into independent registers\n+\n fvariable-expansion-in-unroller\n Common Report Var(flag_variable_expansion_in_unroller)\n Apply variable expansion when loops are unrolled"}, {"sha": "c7d1c5d187caa8e9d0d1b3aef9583d717e10974f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -340,7 +340,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsched2-use-superblocks @gol\n -fsched2-use-traces -fsee -freschedule-modulo-scheduled-loops @gol\n -fsection-anchors  -fsignaling-nans  -fsingle-precision-constant @gol\n--fstack-protector  -fstack-protector-all @gol\n+-fno-split-wide-types -fstack-protector  -fstack-protector-all @gol\n -fstrict-aliasing  -fstrict-overflow  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -fsplit-ivs-in-unroller -funswitch-loops @gol\n@@ -4600,6 +4600,7 @@ compilation time.\n -fcprop-registers @gol\n -fif-conversion @gol\n -fif-conversion2 @gol\n+-fsplit-wide-types @gol\n -ftree-ccp @gol\n -ftree-dce @gol\n -ftree-dominator-opts @gol\n@@ -4938,6 +4939,16 @@ the condition is known to be true or false.\n \n Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -fsplit-wide-types\n+@opindex -fsplit-wide-types\n+When using a type that occupies multiple registers, such as @code{long\n+long} on a 32-bit system, split the registers apart and allocate them\n+independently.  This normally generates better code for those types,\n+but may make debugging more difficult.\n+\n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3},\n+@option{-Os}.\n+\n @item -fcse-follow-jumps\n @opindex fcse-follow-jumps\n In common subexpression elimination, scan through jump instructions"}, {"sha": "0498062786ffa82696f475dbce031004f360ecf0", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1774,6 +1774,19 @@ is always @code{Pmode}.  If there are any @code{addressof}\n expressions left in the function after CSE, @var{reg} is forced into the\n stack and the @code{addressof} expression is replaced with a @code{plus}\n expression for the address of its stack slot.\n+\n+@findex concat\n+@item (concat@var{m} @var{rtx} @var{rtx})\n+This RTX represents the concatenation of two other RTXs.  This is used\n+for complex values.  It should only appear in the RTL attached to\n+declarations and during RTL generation.  It should not appear in the\n+ordinary insn chain.\n+\n+@findex concatn\n+@item (concatn@var{m} [@var{rtx} ...])\n+This RTX represents the concatenation of all the @var{rtx} to make a\n+single value.  Like @code{concat}, this should only appear in\n+declarations, and not in the insn chain.\n @end table\n \n @node Arithmetic"}, {"sha": "861ede5f95af5a5e58db1f70f03f1434e29140bc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,6 @@\n /* Output Dwarf2 format symbol table information from GCC.\n    Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Gary Funck (gary@intrepid.com).\n    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).\n    Extensively modified by Jason Merrill (jason@cygnus.com).\n@@ -9043,6 +9043,32 @@ concat_loc_descriptor (rtx x0, rtx x1)\n   return cc_loc_result;\n }\n \n+/* Return a descriptor that describes the concatenation of N\n+   locations.  */\n+\n+static dw_loc_descr_ref\n+concatn_loc_descriptor (rtx concatn)\n+{\n+  unsigned int i;\n+  dw_loc_descr_ref cc_loc_result = NULL;\n+  unsigned int n = XVECLEN (concatn, 0);\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      dw_loc_descr_ref ref;\n+      rtx x = XVECEXP (concatn, 0, i);\n+\n+      ref = loc_descriptor (x);\n+      if (ref == NULL)\n+\treturn NULL;\n+\n+      add_loc_descr (&cc_loc_result, ref);\n+      add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x)));\n+    }\n+\n+  return cc_loc_result;\n+}\n+\n /* Output a proper Dwarf location descriptor for a variable or parameter\n    which is either allocated in a register or in a memory location.  For a\n    register, we just generate an OP_REG and the register number.  For a\n@@ -9080,6 +9106,10 @@ loc_descriptor (rtx rtl)\n       loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1));\n       break;\n \n+    case CONCATN:\n+      loc_result = concatn_loc_descriptor (rtl);\n+      break;\n+\n     case VAR_LOCATION:\n       /* Single part.  */\n       if (GET_CODE (XEXP (rtl, 1)) != PARALLEL)"}, {"sha": "871ca386b02368a3938217e25a4239da3dc8b989", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,6 @@\n /* Emit RTL for the GCC expander.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -812,13 +812,12 @@ gen_reg_rtx (enum machine_mode mode)\n   return val;\n }\n \n-/* Generate a register with same attributes as REG, but offsetted by OFFSET.\n+/* Update NEW with the same attributes as REG, but offsetted by OFFSET.\n    Do the big endian correction if needed.  */\n \n-rtx\n-gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno, int offset)\n+static void\n+update_reg_offset (rtx new, rtx reg, int offset)\n {\n-  rtx new = gen_rtx_REG (mode, regno);\n   tree decl;\n   HOST_WIDE_INT var_size;\n \n@@ -860,7 +859,7 @@ gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno, int off\n   if ((BYTES_BIG_ENDIAN || WORDS_BIG_ENDIAN)\n       && decl != NULL\n       && offset > 0\n-      && GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (mode)\n+      && GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (GET_MODE (new))\n       && ((var_size = int_size_in_bytes (TREE_TYPE (decl))) > 0\n \t  && var_size < GET_MODE_SIZE (GET_MODE (reg))))\n     {\n@@ -904,6 +903,30 @@ gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno, int off\n \n   REG_ATTRS (new) = get_reg_attrs (REG_EXPR (reg),\n \t\t\t\t   REG_OFFSET (reg) + offset);\n+}\n+\n+/* Generate a register with same attributes as REG, but offsetted by\n+   OFFSET.  */\n+\n+rtx\n+gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno,\n+\t\t    int offset)\n+{\n+  rtx new = gen_rtx_REG (mode, regno);\n+\n+  update_reg_offset (new, reg, offset);\n+  return new;\n+}\n+\n+/* Generate a new pseudo-register with the same attributes as REG, but\n+   offsetted by OFFSET.  */\n+\n+rtx\n+gen_reg_rtx_offset (rtx reg, enum machine_mode mode, int offset)\n+{\n+  rtx new = gen_reg_rtx (mode);\n+\n+  update_reg_offset (new, reg, offset);\n   return new;\n }\n "}, {"sha": "7227624583be0633545695d9fc344ef7402e2a67", "filename": "gcc/lower-subreg.c", "status": "added", "additions": 1130, "deletions": 0, "changes": 1130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -0,0 +1,1130 @@\n+/* Decompose multiword subregs.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>\n+\t\t  Ian Lance Taylor <iant@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"machmode.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"timevar.h\"\n+#include \"flags.h\"\n+#include \"insn-config.h\"\n+#include \"obstack.h\"\n+#include \"basic-block.h\"\n+#include \"recog.h\"\n+#include \"bitmap.h\"\n+#include \"expr.h\"\n+#include \"regs.h\"\n+#include \"tree-pass.h\"\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+# undef STACK_GROWS_DOWNWARD\n+# define STACK_GROWS_DOWNWARD 1\n+#else\n+# define STACK_GROWS_DOWNWARD 0\n+#endif\n+\n+DEF_VEC_P (bitmap);\n+DEF_VEC_ALLOC_P (bitmap,heap);\n+\n+/* Decompose multi-word pseudo-registers into individual\n+   pseudo-registers when possible.  This is possible when all the uses\n+   of a multi-word register are via SUBREG, or are copies of the\n+   register to another location.  Breaking apart the register permits\n+   more CSE and permits better register allocation.  */\n+\n+/* Bit N in this bitmap is set if regno N is used in a context in\n+   which we can decompose it.  */\n+static bitmap decomposable_context;\n+\n+/* Bit N in this bitmap is set if regno N is used in a context in\n+   which it can not be decomposed.  */\n+static bitmap non_decomposable_context;\n+\n+/* Bit N in the bitmap in element M of this array is set if there is a\n+   copy from reg M to reg N.  */\n+static VEC(bitmap,heap) *reg_copy_graph;\n+\n+/* If INSN is a single set between two objects, return the single set.\n+   Such an insn can always be decomposed.  INSN should have been\n+   passed to recog and extract_insn before this is called.  */\n+\n+static rtx\n+simple_move (rtx insn)\n+{\n+  rtx x;\n+  rtx set;\n+  enum machine_mode mode;\n+\n+  if (recog_data.n_operands != 2)\n+    return NULL_RTX;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return NULL_RTX;\n+\n+  x = SET_DEST (set);\n+  if (x != recog_data.operand[0] && x != recog_data.operand[1])\n+    return NULL_RTX;\n+  if (GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+  if (!OBJECT_P (x))\n+    return NULL_RTX;\n+  if (MEM_P (x)\n+      && (MEM_VOLATILE_P (x)\n+\t  || mode_dependent_address_p (XEXP (x, 0))))\n+    return NULL_RTX;\n+\n+  x = SET_SRC (set);\n+  if (x != recog_data.operand[0] && x != recog_data.operand[1])\n+    return NULL_RTX;\n+  if (GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+  if (!OBJECT_P (x) && GET_CODE (x) != ASM_OPERANDS)\n+    return NULL_RTX;\n+  if (MEM_P (x)\n+      && (MEM_VOLATILE_P (x)\n+\t  || mode_dependent_address_p (XEXP (x, 0))))\n+    return NULL_RTX;\n+\n+  /* We try to decompose in integer modes, to avoid generating\n+     inefficient code copying between integer and floating point\n+     registers.  That means that we can't decompose if this is a\n+     non-integer mode for which there is no integer mode of the same\n+     size.  */\n+  mode = GET_MODE (SET_SRC (set));\n+  if (!SCALAR_INT_MODE_P (mode)\n+      && (mode_for_size (GET_MODE_SIZE (mode) * BITS_PER_UNIT, MODE_INT, 0)\n+\t  == BLKmode))\n+    return NULL_RTX;\n+\n+  return set;\n+}\n+\n+/* If SET is a copy from one multi-word pseudo-register to another,\n+   record that in reg_copy_graph.  Return whether it is such a\n+   copy.  */\n+\n+static bool\n+find_pseudo_copy (rtx set)\n+{\n+  rtx dest = SET_DEST (set);\n+  rtx src = SET_SRC (set);\n+  unsigned int rd, rs;\n+  bitmap b;\n+\n+  if (!REG_P (dest) || !REG_P (src))\n+    return false;\n+\n+  rd = REGNO (dest);\n+  rs = REGNO (src);\n+  if (HARD_REGISTER_NUM_P (rd) || HARD_REGISTER_NUM_P (rs))\n+    return false;\n+\n+  if (GET_MODE_SIZE (GET_MODE (dest)) <= UNITS_PER_WORD)\n+    return false;\n+\n+  b = VEC_index (bitmap, reg_copy_graph, rs);\n+  if (b == NULL)\n+    {\n+      b = BITMAP_ALLOC (NULL);\n+      VEC_replace (bitmap, reg_copy_graph, rs, b);\n+    }\n+\n+  bitmap_set_bit (b, rd);\n+\n+  return true;\n+}\n+\n+/* Look through the registers in DECOMPOSABLE_CONTEXT.  For each case\n+   where they are copied to another register, add the register to\n+   which they are copied to DECOMPOSABLE_CONTEXT.  Use\n+   NON_DECOMPOSABLE_CONTEXT to limit this--we don't bother to track\n+   copies of registers which are in NON_DECOMPOSABLE_CONTEXT.  */\n+\n+static void\n+propagate_pseudo_copies (void)\n+{\n+  bitmap queue, propagate;\n+\n+  queue = BITMAP_ALLOC (NULL);\n+  propagate = BITMAP_ALLOC (NULL);\n+\n+  bitmap_copy (queue, decomposable_context);\n+  do\n+    {\n+      bitmap_iterator iter;\n+      unsigned int i;\n+\n+      bitmap_clear (propagate);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (queue, 0, i, iter)\n+\t{\n+\t  bitmap b = VEC_index (bitmap, reg_copy_graph, i);\n+\t  if (b)\n+\t    bitmap_ior_and_compl_into (propagate, b, non_decomposable_context);\n+\t}\n+\n+      bitmap_and_compl (queue, propagate, decomposable_context);\n+      bitmap_ior_into (decomposable_context, propagate);\n+    }\n+  while (!bitmap_empty_p (queue));\n+\n+  BITMAP_FREE (queue);\n+  BITMAP_FREE (propagate);\n+}\n+\n+/* A pointer to one of these values is passed to\n+   find_decomposable_subregs via for_each_rtx.  */\n+\n+enum classify_move_insn\n+{\n+  /* Not a simple move from one location to another.  */\n+  NOT_SIMPLE_MOVE,\n+  /* A simple move from one pseudo-register to another with no\n+     REG_RETVAL note.  */\n+  SIMPLE_PSEUDO_REG_MOVE,\n+  /* A simple move involving a non-pseudo-register, or from one\n+     pseudo-register to another with a REG_RETVAL note.  */\n+  SIMPLE_MOVE\n+};\n+\n+/* This is called via for_each_rtx.  If we find a SUBREG which we\n+   could use to decompose a pseudo-register, set a bit in\n+   DECOMPOSABLE_CONTEXT.  If we find an unadorned register which is\n+   not a simple pseudo-register copy, DATA will point at the type of\n+   move, and we set a bit in DECOMPOSABLE_CONTEXT or\n+   NON_DECOMPOSABLE_CONTEXT as appropriate.  */\n+\n+static int\n+find_decomposable_subregs (rtx *px, void *data)\n+{\n+  enum classify_move_insn *pcmi = (enum classify_move_insn *) data;\n+  rtx x = *px;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+\n+  if (GET_CODE (x) == SUBREG)\n+    {\n+      rtx inner = SUBREG_REG (x);\n+      unsigned int regno, outer_size, inner_size, outer_words, inner_words;\n+\n+      if (!REG_P (inner))\n+\treturn 0;\n+\n+      regno = REGNO (inner);\n+      if (HARD_REGISTER_NUM_P (regno))\n+\treturn -1;\n+\n+      outer_size = GET_MODE_SIZE (GET_MODE (x));\n+      inner_size = GET_MODE_SIZE (GET_MODE (inner));\n+      outer_words = (outer_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      inner_words = (inner_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+      /* We only try to decompose single word subregs of multi-word\n+\t registers.  When we find one, we return -1 to avoid iterating\n+\t over the inner register.\n+\n+\t ??? This doesn't allow, e.g., DImode subregs of TImode values\n+\t on 32-bit targets.  We would need to record the way the\n+\t pseudo-register was used, and only decompose if all the uses\n+\t were the same number and size of pieces.  Hopefully this\n+\t doesn't happen much.  */\n+\n+      if (outer_words == 1 && inner_words > 1)\n+\t{\n+\t  bitmap_set_bit (decomposable_context, regno);\n+\t  return -1;\n+\t}\n+    }\n+  else if (GET_CODE (x) == REG)\n+    {\n+      unsigned int regno;\n+\n+      /* We will see an outer SUBREG before we see the inner REG, so\n+\t when we see a plain REG here it means a direct reference to\n+\t the register.\n+\n+\t If this is not a simple copy from one location to another,\n+\t then we can not decompose this register.  If this is a simple\n+\t copy from one pseudo-register to another, with no REG_RETVAL\n+\t note, and the mode is right, then we mark the register as\n+\t decomposable.  Otherwise we don't say anything about this\n+\t register--it could be decomposed, but whether that would be\n+\t profitable depends upon how it is used elsewhere.\n+\n+\t We only set bits in the bitmap for multi-word\n+\t pseudo-registers, since those are the only ones we care about\n+\t and it keeps the size of the bitmaps down.  */\n+\n+      regno = REGNO (x);\n+      if (!HARD_REGISTER_NUM_P (regno)\n+\t  && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+\t{\n+\t  switch (*pcmi)\n+\t    {\n+\t    case NOT_SIMPLE_MOVE:\n+\t      bitmap_set_bit (non_decomposable_context, regno);\n+\t      break;\n+\t    case SIMPLE_PSEUDO_REG_MOVE:\n+\t      if (MODES_TIEABLE_P (GET_MODE (x), word_mode))\n+\t\tbitmap_set_bit (decomposable_context, regno);\n+\t      break;\n+\t    case SIMPLE_MOVE:\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Decompose REGNO into word-sized components.  We smash the REG node\n+   in place.  This ensures that (1) something goes wrong quickly if we\n+   fail to make some replacement, and (2) the debug information inside\n+   the symbol table is automatically kept up to date.  */\n+\n+static void\n+decompose_register (unsigned int regno)\n+{\n+  rtx reg;\n+  unsigned int words, i;\n+  rtvec v;\n+\n+  reg = regno_reg_rtx[regno];\n+\n+  regno_reg_rtx[regno] = NULL_RTX;\n+  clear_reg_info_regno (regno);\n+\n+  words = GET_MODE_SIZE (GET_MODE (reg));\n+  words = (words + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  v = rtvec_alloc (words);\n+  for (i = 0; i < words; ++i)\n+    RTVEC_ELT (v, i) = gen_reg_rtx_offset (reg, word_mode, i * UNITS_PER_WORD);\n+\n+  PUT_CODE (reg, CONCATN);\n+  XVEC (reg, 0) = v;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"; Splitting reg %u ->\", regno);\n+      for (i = 0; i < words; ++i)\n+\tfprintf (dump_file, \" %u\", REGNO (XVECEXP (reg, 0, i)));\n+      fputc ('\\n', dump_file);\n+    }\n+}\n+\n+/* Get a SUBREG of a CONCATN.  */\n+\n+static rtx\n+simplify_subreg_concatn (enum machine_mode outermode, rtx op,\n+\t\t\t unsigned int byte)\n+{\n+  unsigned int inner_size;\n+  enum machine_mode innermode;\n+  rtx part;\n+  unsigned int final_offset;\n+\n+  gcc_assert (GET_CODE (op) == CONCATN);\n+  gcc_assert (byte % GET_MODE_SIZE (outermode) == 0);\n+\n+  innermode = GET_MODE (op);\n+  gcc_assert (byte < GET_MODE_SIZE (innermode));\n+  gcc_assert (GET_MODE_SIZE (outermode) <= GET_MODE_SIZE (innermode));\n+\n+  inner_size = GET_MODE_SIZE (innermode) / XVECLEN (op, 0);\n+  part = XVECEXP (op, 0, byte / inner_size);\n+  final_offset = byte % inner_size;\n+  if (final_offset + GET_MODE_SIZE (outermode) > inner_size)\n+    return NULL_RTX;\n+\n+  return simplify_gen_subreg (outermode, part, GET_MODE (part), final_offset);\n+}\n+\n+/* Wrapper around simplify_gen_subreg which handles CONCATN.  */\n+\n+static rtx\n+simplify_gen_subreg_concatn (enum machine_mode outermode, rtx op,\n+\t\t\t     enum machine_mode innermode, unsigned int byte)\n+{\n+  /* We have to handle generating a SUBREG of a SUBREG of a CONCATN.\n+     If OP is a SUBREG of a CONCATN, then it must be a simple mode\n+     change with the same size and offset 0, or it must extract a\n+     part.  We shouldn't see anything else here.  */\n+  if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == CONCATN)\n+    {\n+      rtx op2;\n+\n+      if ((GET_MODE_SIZE (GET_MODE (op))\n+\t   == GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n+\t  && SUBREG_BYTE (op) == 0)\n+\treturn simplify_gen_subreg_concatn (outermode, SUBREG_REG (op),\n+\t\t\t\t\t    GET_MODE (SUBREG_REG (op)), byte);\n+\n+      op2 = simplify_subreg_concatn (GET_MODE (op), SUBREG_REG (op),\n+\t\t\t\t     SUBREG_BYTE (op));\n+      if (op2 == NULL_RTX)\n+\t{\n+\t  /* We don't handle paradoxical subregs here.  */\n+\t  gcc_assert (GET_MODE_SIZE (outermode)\n+\t\t      <= GET_MODE_SIZE (GET_MODE (op)));\n+\t  gcc_assert (GET_MODE_SIZE (GET_MODE (op))\n+\t\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))));\n+\t  op2 = simplify_subreg_concatn (outermode, SUBREG_REG (op),\n+\t\t\t\t\t byte + SUBREG_BYTE (op));\n+\t  gcc_assert (op2 != NULL_RTX);\n+\t  return op2;\n+\t}\n+\n+      op = op2;\n+      gcc_assert (op != NULL_RTX);\n+      gcc_assert (innermode == GET_MODE (op));\n+    }\n+  if (GET_CODE (op) == CONCATN)\n+    return simplify_subreg_concatn (outermode, op, byte);\n+  return simplify_gen_subreg (outermode, op, innermode, byte);\n+}\n+\n+/* Return whether we should resolve X into the registers into which it\n+   was decomposed.  */\n+\n+static bool\n+resolve_reg_p (rtx x)\n+{\n+  return GET_CODE (x) == CONCATN;\n+}\n+\n+/* Return whether X is a SUBREG of a register which we need to\n+   resolve.  */\n+\n+static bool\n+resolve_subreg_p (rtx x)\n+{\n+  if (GET_CODE (x) != SUBREG)\n+    return false;\n+  return resolve_reg_p (SUBREG_REG (x));\n+}\n+\n+/* This is called via for_each_rtx.  Look for SUBREGs which need to be\n+   decomposed.  */\n+\n+static int\n+resolve_subreg_use (rtx *px, void *data)\n+{\n+  rtx insn = (rtx) data;\n+  rtx x = *px;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+\n+  if (resolve_subreg_p (x))\n+    {\n+      x = simplify_subreg_concatn (GET_MODE (x), SUBREG_REG (x),\n+\t\t\t\t   SUBREG_BYTE (x));\n+\n+      /* It is possible for a note to contain a reference which we can\n+\t decompose.  In this case, return 1 to the caller to indicate\n+\t that the note must be removed.  */\n+      if (!x)\n+\t{\n+\t  gcc_assert(!insn);\n+\t  return 1;\n+\t}\n+\n+      validate_change (insn, px, x, 1);\n+      return -1;\n+    }\n+\n+  if (resolve_reg_p (x))\n+    {\n+      /* Return 1 to the caller to indicate that we found a direct\n+\t reference to a register which is being decomposed.  This can\n+\t happen inside notes.  */\n+      gcc_assert (!insn);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* If there is a REG_LIBCALL note on OLD_START, move it to NEW_START,\n+   and link the corresponding REG_RETVAL note to NEW_START.  */\n+\n+static void\n+move_libcall_note (rtx old_start, rtx new_start)\n+{\n+  rtx note0, note1, end;\n+\n+  note0 = find_reg_note (old_start, REG_LIBCALL, NULL);\n+  if (note0 == NULL_RTX)\n+    return;\n+\n+  remove_note (old_start, note0);\n+  end = XEXP (note0, 0);\n+  note1 = find_reg_note (end, REG_RETVAL, NULL);\n+\n+  XEXP (note0, 1) = REG_NOTES (new_start);\n+  REG_NOTES (new_start) = note0;\n+  XEXP (note1, 0) = new_start;\n+}\n+\n+/* Remove any REG_RETVAL note, the corresponding REG_LIBCALL note, and\n+   any markers for a no-conflict block.  We have decomposed the\n+   registers so the non-conflict is now obvious.  */\n+\n+static void\n+remove_retval_note (rtx insn1)\n+{\n+  rtx note0, insn0, note1, insn;\n+\n+  note1 = find_reg_note (insn1, REG_RETVAL, NULL);\n+  if (note1 == NULL_RTX)\n+    return;\n+\n+  insn0 = XEXP (note1, 0);\n+  note0 = find_reg_note (insn0, REG_LIBCALL, NULL);\n+\n+  remove_note (insn0, note0);\n+  remove_note (insn1, note1);\n+\n+  for (insn = insn0; insn != insn1; insn = NEXT_INSN (insn))\n+    {\n+      while (1)\n+\t{\n+\t  rtx note;\n+\n+\t  note = find_reg_note (insn, REG_NO_CONFLICT, NULL);\n+\t  if (note == NULL_RTX)\n+\t    break;\n+\t  remove_note (insn, note);\n+\t}\n+    }\n+}\n+\n+/* Resolve any decomposed registers which appear in register notes on\n+   INSN.  */\n+\n+static void\n+resolve_reg_notes (rtx insn)\n+{\n+  rtx *pnote, note;\n+\n+  note = find_reg_equal_equiv_note (insn);\n+  if (note)\n+    {\n+      if (for_each_rtx (&XEXP (note, 0), resolve_subreg_use, NULL))\n+\t{\n+\t  remove_note (insn, note);\n+\t  remove_retval_note (insn);\n+\t}\n+    }\n+\n+  pnote = &REG_NOTES (insn);\n+  while (*pnote != NULL_RTX)\n+    {\n+      bool delete = false;\n+\n+      note = *pnote;\n+      switch (REG_NOTE_KIND (note))\n+\t{\n+\tcase REG_NO_CONFLICT:\n+\t  if (resolve_reg_p (XEXP (note, 0)))\n+\t    delete = true;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      if (delete)\n+\t*pnote = XEXP (note, 1);\n+      else\n+\tpnote = &XEXP (note, 1);\n+    }\n+}\n+\n+/* Return whether X can not be decomposed into subwords.  */\n+\n+static bool\n+cannot_decompose_p (rtx x)\n+{\n+  if (REG_P (x))\n+    {\n+      unsigned int regno = REGNO (x);\n+\n+      if (HARD_REGISTER_NUM_P (regno))\n+\treturn !validate_subreg (word_mode, GET_MODE (x), x, UNITS_PER_WORD);\n+      else\n+\treturn bitmap_bit_p (non_decomposable_context, regno);\n+    }\n+\n+  return false;\n+}\n+\n+/* Decompose the registers used in a simple move SET within INSN.  If\n+   we don't change anything, return INSN, otherwise return the start\n+   of the sequence of moves.  */\n+\n+static rtx\n+resolve_simple_move (rtx set, rtx insn)\n+{\n+  rtx src, dest, real_dest, insns;\n+  enum machine_mode orig_mode, dest_mode;\n+  unsigned int words;\n+  bool pushing;\n+\n+  src = SET_SRC (set);\n+  dest = SET_DEST (set);\n+  orig_mode = GET_MODE (dest);\n+\n+  words = (GET_MODE_SIZE (orig_mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  if (words <= 1)\n+    return insn;\n+\n+  start_sequence ();\n+\n+  /* We have to handle copying from a SUBREG of a decomposed reg where\n+     the SUBREG is larger than word size.  Rather than assume that we\n+     can take a word_mode SUBREG of the destination, we copy to a new\n+     register and then copy that to the destination.  */\n+\n+  real_dest = NULL_RTX;\n+\n+  if (GET_CODE (src) == SUBREG\n+      && resolve_reg_p (SUBREG_REG (src))\n+      && (SUBREG_BYTE (src) != 0\n+\t  || (GET_MODE_SIZE (orig_mode)\n+\t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))))\n+    {\n+      real_dest = dest;\n+      dest = gen_reg_rtx (orig_mode);\n+      if (REG_P (real_dest))\n+\tREG_ATTRS (dest) = REG_ATTRS (real_dest);\n+    }\n+\n+  /* Similarly if we are copying to a SUBREG of a decomposed reg where\n+     the SUBREG is larger than word size.  */\n+\n+  if (GET_CODE (dest) == SUBREG\n+      && resolve_reg_p (SUBREG_REG (dest))\n+      && (SUBREG_BYTE (dest) != 0\n+\t  || (GET_MODE_SIZE (orig_mode)\n+\t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))))\n+    {\n+      rtx reg, minsn, smove;\n+\n+      reg = gen_reg_rtx (orig_mode);\n+      minsn = emit_move_insn (reg, src);\n+      smove = single_set (minsn);\n+      gcc_assert (smove != NULL_RTX);\n+      resolve_simple_move (smove, minsn);\n+      src = reg;\n+    }\n+\n+  /* If we didn't have any big SUBREGS of decomposed registers, and\n+     neither side of the move is a register we are decomposing, then\n+     we don't have to do anything here.  */\n+\n+  if (src == SET_SRC (set)\n+      && dest == SET_DEST (set)\n+      && !resolve_reg_p (src)\n+      && !resolve_subreg_p (src)\n+      && !resolve_reg_p (dest)\n+      && !resolve_subreg_p (dest))\n+    {\n+      end_sequence ();\n+      return insn;\n+    }\n+\n+  /* If SRC is a register which we can't decompose, or has side\n+     effects, we need to move via a temporary register.  */\n+\n+  if (cannot_decompose_p (src)\n+      || side_effects_p (src)\n+      || GET_CODE (src) == ASM_OPERANDS)\n+    {\n+      rtx reg;\n+\n+      reg = gen_reg_rtx (orig_mode);\n+      emit_move_insn (reg, src);\n+      src = reg;\n+    }\n+\n+  /* If DEST is a register which we can't decompose, or has side\n+     effects, we need to first move to a temporary register.  We\n+     handle the common case of pushing an operand directly.  We also\n+     go through a temporary register if it holds a floating point\n+     value.  This gives us better code on systems which can't move\n+     data easily between integer and floating point registers.  */\n+\n+  dest_mode = orig_mode;\n+  pushing = push_operand (dest, dest_mode);\n+  if (cannot_decompose_p (dest)\n+      || (side_effects_p (dest) && !pushing)\n+      || (!SCALAR_INT_MODE_P (dest_mode)\n+\t  && !resolve_reg_p (dest)\n+\t  && !resolve_subreg_p (dest)))\n+    {\n+      if (real_dest == NULL_RTX)\n+\treal_dest = dest;\n+      if (!SCALAR_INT_MODE_P (dest_mode))\n+\t{\n+\t  dest_mode = mode_for_size (GET_MODE_SIZE (dest_mode) * BITS_PER_UNIT,\n+\t\t\t\t     MODE_INT, 0);\n+\t  gcc_assert (dest_mode != BLKmode);\n+\t}\n+      dest = gen_reg_rtx (dest_mode);\n+      if (REG_P (real_dest))\n+\tREG_ATTRS (dest) = REG_ATTRS (real_dest);\n+    }\n+\n+  if (pushing)\n+    {\n+      unsigned int i, j, jinc;\n+\n+      gcc_assert (GET_MODE_SIZE (orig_mode) % UNITS_PER_WORD == 0);\n+      gcc_assert (GET_CODE (XEXP (dest, 0)) != PRE_MODIFY);\n+      gcc_assert (GET_CODE (XEXP (dest, 0)) != POST_MODIFY);\n+\n+      if (WORDS_BIG_ENDIAN == STACK_GROWS_DOWNWARD)\n+\t{\n+\t  j = 0;\n+\t  jinc = 1;\n+\t}\n+      else\n+\t{\n+\t  j = words - 1;\n+\t  jinc = -1;\n+\t}\n+\n+      for (i = 0; i < words; ++i, j += jinc)\n+\t{\n+\t  rtx temp;\n+\n+\t  temp = copy_rtx (XEXP (dest, 0));\n+\t  temp = adjust_automodify_address_nv (dest, word_mode, temp,\n+\t\t\t\t\t       j * UNITS_PER_WORD);\n+\t  emit_move_insn (temp,\n+\t\t\t  simplify_gen_subreg_concatn (word_mode, src,\n+\t\t\t\t\t\t       orig_mode,\n+\t\t\t\t\t\t       j * UNITS_PER_WORD));\n+\t}\n+    }\n+  else\n+    {\n+      unsigned int i;\n+\n+      if (REG_P (dest) && !HARD_REGISTER_NUM_P (REGNO (dest)))\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, dest));\n+\n+      for (i = 0; i < words; ++i)\n+\temit_move_insn (simplify_gen_subreg_concatn (word_mode, dest,\n+\t\t\t\t\t\t     dest_mode,\n+\t\t\t\t\t\t     i * UNITS_PER_WORD),\n+\t\t\tsimplify_gen_subreg_concatn (word_mode, src,\n+\t\t\t\t\t\t     orig_mode,\n+\t\t\t\t\t\t     i * UNITS_PER_WORD));\n+    }\n+\n+  if (real_dest != NULL_RTX)\n+    {\n+      rtx mdest, minsn, smove;\n+\n+      if (dest_mode == orig_mode)\n+\tmdest = dest;\n+      else\n+\tmdest = simplify_gen_subreg (orig_mode, dest, GET_MODE (dest), 0);\n+      minsn = emit_move_insn (real_dest, mdest);\n+\n+      smove = single_set (minsn);\n+      gcc_assert (smove != NULL_RTX);\n+\n+      resolve_simple_move (smove, minsn);\n+    }\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  emit_insn_before (insns, insn);\n+\n+  move_libcall_note (insn, insns);\n+  remove_retval_note (insn);\n+  delete_insn (insn);\n+\n+  return insns;\n+}\n+\n+/* Change a CLOBBER of a decomposed register into a CLOBBER of the\n+   component registers.  Return whether we changed something.  */\n+\n+static bool\n+resolve_clobber (rtx pat, rtx insn)\n+{\n+  rtx reg;\n+  enum machine_mode orig_mode;\n+  unsigned int words, i;\n+\n+  reg = XEXP (pat, 0);\n+  if (!resolve_reg_p (reg))\n+    return false;\n+\n+  orig_mode = GET_MODE (reg);\n+  words = GET_MODE_SIZE (orig_mode);\n+  words = (words + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  XEXP (pat, 0) = simplify_subreg_concatn (word_mode, reg, 0);\n+  for (i = words - 1; i > 0; --i)\n+    {\n+      rtx x;\n+\n+      x = simplify_subreg_concatn (word_mode, reg, i * UNITS_PER_WORD);\n+      x = gen_rtx_CLOBBER (VOIDmode, x);\n+      emit_insn_after (x, insn);\n+    }\n+\n+  return true;\n+}\n+\n+/* A USE of a decomposed register is no longer meaningful.  Return\n+   whether we changed something.  */\n+\n+static bool\n+resolve_use (rtx pat, rtx insn)\n+{\n+  if (resolve_reg_p (XEXP (pat, 0)) || resolve_subreg_p (XEXP (pat, 0)))\n+    {\n+      delete_insn (insn);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Look for registers which are always accessed via word-sized SUBREGs\n+   or via copies.  Decompose these registers into several word-sized\n+   pseudo-registers.  */\n+\n+static void\n+decompose_multiword_subregs (bool update_life)\n+{\n+  unsigned int max;\n+  basic_block bb;\n+\n+  max = max_reg_num ();\n+\n+  /* First see if there are any multi-word pseudo-registers.  If there\n+     aren't, there is nothing we can do.  This should speed up this\n+     pass in the normal case, since it should be faster than scanning\n+     all the insns.  */\n+  {\n+    unsigned int i;\n+\n+    for (i = FIRST_PSEUDO_REGISTER; i < max; ++i)\n+      {\n+\tif (regno_reg_rtx[i] != NULL\n+\t    && GET_MODE_SIZE (GET_MODE (regno_reg_rtx[i])) > UNITS_PER_WORD)\n+\t  break;\n+      }\n+    if (i == max)\n+      return;\n+  }\n+\n+  /* FIXME: When the dataflow branch is merged, we can change this\n+     code to look for each multi-word pseudo-register and to find each\n+     insn which sets or uses that register.  That should be faster\n+     than scanning all the insns.  */\n+\n+  decomposable_context = BITMAP_ALLOC (NULL);\n+  non_decomposable_context = BITMAP_ALLOC (NULL);\n+\n+  reg_copy_graph = VEC_alloc (bitmap, heap, max);\n+  VEC_safe_grow (bitmap, heap, reg_copy_graph, max);\n+  memset (VEC_address (bitmap, reg_copy_graph), 0, sizeof (bitmap) * max);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn;\n+\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  rtx set;\n+\t  enum classify_move_insn cmi;\n+\t  int i, n;\n+\n+\t  if (!INSN_P (insn)\n+\t      || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t      || GET_CODE (PATTERN (insn)) == USE)\n+\t    continue;\n+\n+\t  recog_memoized (insn);\n+\t  extract_insn (insn);\n+\n+\t  set = simple_move (insn);\n+\n+\t  if (!set)\n+\t    cmi = NOT_SIMPLE_MOVE;\n+\t  else\n+\t    {\n+\t      bool retval;\n+\n+\t      retval = find_reg_note (insn, REG_RETVAL, NULL_RTX) != NULL_RTX;\n+\n+\t      if (find_pseudo_copy (set) && !retval)\n+\t\tcmi = SIMPLE_PSEUDO_REG_MOVE;\n+\t      else if (retval\n+\t\t       && REG_P (SET_SRC (set))\n+\t\t       && HARD_REGISTER_P (SET_SRC (set)))\n+\t\t{\n+\t\t  rtx note;\n+\n+\t\t  /* We don't want to decompose an assignment which\n+\t\t     copies the value returned by a libcall to a\n+\t\t     pseudo-register.  Doing that will lose the RETVAL\n+\t\t     note with no real gain.  */\n+\t\t  cmi = NOT_SIMPLE_MOVE;\n+\n+\t\t  /* If we have a RETVAL note, there should be an\n+\t\t     EQUAL note.  We don't want to decompose any\n+\t\t     registers which that EQUAL note refers to\n+\t\t     directly.  If we do, we will no longer know the\n+\t\t     value of the libcall.  */\n+\t\t  note = find_reg_equal_equiv_note (insn);\n+\t\t  if (note != NULL_RTX)\n+\t\t    for_each_rtx (&XEXP (note, 0), find_decomposable_subregs,\n+\t\t\t\t  &cmi);\n+\t\t}\n+\t      else\n+\t\tcmi = SIMPLE_MOVE;\n+\t    }\n+\n+\t  n = recog_data.n_operands;\n+\t  for (i = 0; i < n; ++i)\n+\t    {\n+\t      for_each_rtx (&recog_data.operand[i],\n+\t\t\t    find_decomposable_subregs,\n+\t\t\t    &cmi);\n+\n+\t      /* We handle ASM_OPERANDS as a special case to support\n+\t\t things like x86 rdtsc which returns a DImode value.\n+\t\t We can decompose the output, which will certainly be\n+\t\t operand 0, but not the inputs.  */\n+\n+\t      if (cmi == SIMPLE_MOVE\n+\t\t  && GET_CODE (SET_SRC (set)) == ASM_OPERANDS)\n+\t\t{\n+\t\t  gcc_assert (i == 0);\n+\t\t  cmi = NOT_SIMPLE_MOVE;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  bitmap_and_compl_into (decomposable_context, non_decomposable_context);\n+  if (!bitmap_empty_p (decomposable_context))\n+    {\n+      int hold_no_new_pseudos = no_new_pseudos;\n+      int max_regno = max_reg_num ();\n+      sbitmap blocks;\n+      bitmap_iterator iter;\n+      unsigned int regno;\n+\n+      propagate_pseudo_copies ();\n+\n+      no_new_pseudos = 0;\n+      blocks = sbitmap_alloc (last_basic_block);\n+      sbitmap_zero (blocks);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (decomposable_context, 0, regno, iter)\n+\tdecompose_register (regno);\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  rtx insn;\n+\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    {\n+\t      rtx next, pat;\n+\t      bool changed;\n+\n+\t      if (!INSN_P (insn))\n+\t\tcontinue;\n+\n+\t      next = NEXT_INSN (insn);\n+\t      changed = false;\n+\n+\t      pat = PATTERN (insn);\n+\t      if (GET_CODE (pat) == CLOBBER)\n+\t\t{\n+\t\t  if (resolve_clobber (pat, insn))\n+\t\t    changed = true;\n+\t\t}\n+\t      else if (GET_CODE (pat) == USE)\n+\t\t{\n+\t\t  if (resolve_use (pat, insn))\n+\t\t    changed = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx set;\n+\t\t  int i;\n+\n+\t\t  recog_memoized (insn);\n+\t\t  extract_insn (insn);\n+\n+\t\t  set = simple_move (insn);\n+\t\t  if (set)\n+\t\t    {\n+\t\t      rtx orig_insn = insn;\n+\n+\t\t      insn = resolve_simple_move (set, insn);\n+\t\t      if (insn != orig_insn)\n+\t\t\t{\n+\t\t\t  changed = true;\n+\n+\t\t\t  recog_memoized (insn);\n+\t\t\t  extract_insn (insn);\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  for (i = recog_data.n_operands - 1; i >= 0; --i)\n+\t\t    for_each_rtx (recog_data.operand_loc[i],\n+\t\t\t\t  resolve_subreg_use,\n+\t\t\t\t  insn);\n+\n+\t\t  resolve_reg_notes (insn);\n+\n+\t\t  if (num_validated_changes () > 0)\n+\t\t    {\n+\t\t      for (i = recog_data.n_dups - 1; i >= 0; --i)\n+\t\t\t{\n+\t\t\t  rtx *pl = recog_data.dup_loc[i];\n+\t\t\t  int dup_num = recog_data.dup_num[i];\n+\t\t\t  rtx *px = recog_data.operand_loc[dup_num];\n+\n+\t\t\t  validate_change (insn, pl, *px, 1);\n+\t\t\t}\n+\n+\t\t      i = apply_change_group ();\n+\t\t      gcc_assert (i);\n+\n+\t\t      changed = true;\n+\t\t    }\n+\t\t}\n+\n+\t      if (changed)\n+\t\t{\n+\t\t  SET_BIT (blocks, bb->index);\n+\t\t  reg_scan_update (insn, next, max_regno);\n+\t\t}\n+\t    }\n+\t}\n+\n+      no_new_pseudos = hold_no_new_pseudos;\n+\n+      if (update_life)\n+\tupdate_life_info (blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t  PROP_DEATH_NOTES);\n+\n+      sbitmap_free (blocks);\n+    }\n+\n+  {\n+    unsigned int i;\n+    bitmap b;\n+\n+    for (i = 0; VEC_iterate (bitmap, reg_copy_graph, i, b); ++i)\n+      if (b)\n+\tBITMAP_FREE (b);\n+  }\n+\n+  VEC_free (bitmap, heap, reg_copy_graph);  \n+\n+  BITMAP_FREE (decomposable_context);\n+  BITMAP_FREE (non_decomposable_context);\n+}\n+\f\n+/* Gate function for lower subreg pass.  */\n+\n+static bool\n+gate_handle_lower_subreg (void)\n+{\n+  return flag_split_wide_types != 0;\n+}\n+\n+/* Implement first lower subreg pass.  */\n+\n+static unsigned int\n+rest_of_handle_lower_subreg (void)\n+{\n+  decompose_multiword_subregs (false);\n+  return 0;\n+}\n+\n+/* Implement second lower subreg pass.  */\n+\n+static unsigned int\n+rest_of_handle_lower_subreg2 (void)\n+{\n+  decompose_multiword_subregs (true);\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_lower_subreg =\n+{\n+  \"subreg\",\t                        /* name */\n+  gate_handle_lower_subreg,             /* gate */\n+  rest_of_handle_lower_subreg,          /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_LOWER_SUBREG,                      /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'u'                                   /* letter */\n+};\n+\n+struct tree_opt_pass pass_lower_subreg2 =\n+{\n+  \"subreg2\",\t                        /* name */\n+  gate_handle_lower_subreg,             /* gate */\n+  rest_of_handle_lower_subreg2,          /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_LOWER_SUBREG,                      /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'U'                                   /* letter */\n+};"}, {"sha": "aacc1a3ebb6e59857b6390821b9c147e396f1a77", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -445,6 +445,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_if_conversion2 = 1;\n       flag_ipa_pure_const = 1;\n       flag_ipa_reference = 1;\n+      flag_split_wide_types = 1;\n       flag_tree_ccp = 1;\n       flag_tree_dce = 1;\n       flag_tree_dom = 1;"}, {"sha": "d700ae93bcf598860748d5c8e3a7ffc8ae2e49e2", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,7 @@\n /* Top level of GCC compilers (cc1, cc1plus, etc.)\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -663,6 +664,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_unshare_all_rtl);\n   NEXT_PASS (pass_instantiate_virtual_regs);\n   NEXT_PASS (pass_jump2);\n+  NEXT_PASS (pass_lower_subreg);\n   NEXT_PASS (pass_cse);\n   NEXT_PASS (pass_rtl_fwprop);\n   NEXT_PASS (pass_gcse);\n@@ -682,6 +684,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_partition_blocks);\n   NEXT_PASS (pass_regmove);\n   NEXT_PASS (pass_split_all_insns);\n+  NEXT_PASS (pass_lower_subreg2);\n   NEXT_PASS (pass_mode_switching);\n   NEXT_PASS (pass_see);\n   NEXT_PASS (pass_recompute_reg_usage);"}, {"sha": "0a1114dabc7b1482efc423ad916a68b749affefa", "filename": "gcc/regclass.c", "status": "modified", "additions": 64, "deletions": 18, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,6 @@\n /* Compute register class preferences for pseudo-registers.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996\n-   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -859,7 +859,7 @@ static void record_address_regs (enum machine_mode, rtx, int, enum rtx_code,\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n static int auto_inc_dec_reg_p (rtx, enum machine_mode);\n #endif\n-static void reg_scan_mark_refs (rtx, rtx, int);\n+static void reg_scan_mark_refs (rtx, rtx, int, unsigned int);\n \n /* Wrapper around REGNO_OK_FOR_INDEX_P, to allow pseudo registers.  */\n \n@@ -2292,6 +2292,14 @@ free_reg_info (void)\n   regno_allocated = 0;\n   reg_n_max = 0;\n }\n+\n+/* Clear the information stored for REGNO.  */\n+void\n+clear_reg_info_regno (unsigned int regno)\n+{\n+  if (regno < regno_allocated)\n+    memset (VEC_index (reg_info_p, reg_n_info, regno), 0, sizeof (reg_info));\n+}\n \f\n /* This is the `regscan' pass of the compiler, run just before cse\n    and again just before loop.\n@@ -2333,22 +2341,50 @@ reg_scan (rtx f, unsigned int nregs)\n \tif (GET_CODE (pat) == PARALLEL\n \t    && XVECLEN (pat, 0) > max_parallel)\n \t  max_parallel = XVECLEN (pat, 0);\n-\treg_scan_mark_refs (pat, insn, 0);\n+\treg_scan_mark_refs (pat, insn, 0, 0);\n \n \tif (REG_NOTES (insn))\n-\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1);\n+\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1, 0);\n       }\n \n   max_parallel += max_set_parallel;\n \n   timevar_pop (TV_REG_SCAN);\n }\n \n+/* Update 'regscan' information by looking at the insns\n+   from FIRST to LAST.  Some new REGs have been created,\n+   and any REG with number greater than OLD_MAX_REGNO is\n+   such a REG.  We only update information for those.  */\n+\n+void\n+reg_scan_update (rtx first, rtx last, unsigned int old_max_regno)\n+{\n+  rtx insn;\n+\n+  allocate_reg_info (max_reg_num (), FALSE, FALSE);\n+\n+  for (insn = first; insn != last; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      {\n+\trtx pat = PATTERN (insn);\n+\tif (GET_CODE (pat) == PARALLEL\n+\t    && XVECLEN (pat, 0) > max_parallel)\n+\t  max_parallel = XVECLEN (pat, 0);\n+\treg_scan_mark_refs (pat, insn, 0, old_max_regno);\n+\n+\tif (REG_NOTES (insn))\n+\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1, old_max_regno);\n+      }\n+}\n+\n /* X is the expression to scan.  INSN is the insn it appears in.\n-   NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.  */\n+   NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.\n+   We should only record information for REGs with numbers\n+   greater than or equal to MIN_REGNO.  */\n \n static void\n-reg_scan_mark_refs (rtx x, rtx insn, int note_flag)\n+reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n {\n   enum rtx_code code;\n   rtx dest;\n@@ -2375,35 +2411,43 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag)\n       {\n \tunsigned int regno = REGNO (x);\n \n-\tif (!note_flag)\n-\t  REGNO_LAST_UID (regno) = INSN_UID (insn);\n-\tif (REGNO_FIRST_UID (regno) == 0)\n-\t  REGNO_FIRST_UID (regno) = INSN_UID (insn);\n+\tif (regno >= min_regno)\n+\t  {\n+\t    if (!note_flag)\n+\t      REGNO_LAST_UID (regno) = INSN_UID (insn);\n+\t    if (REGNO_FIRST_UID (regno) == 0)\n+\t      REGNO_FIRST_UID (regno) = INSN_UID (insn);\n+\t    /* If we are called by reg_scan_update() (indicated by min_regno\n+\t       being set), we also need to update the reference count.  */\n+\t    if (min_regno)\n+\t      REG_N_REFS (regno)++;\n+\t  }\n       }\n       break;\n \n     case EXPR_LIST:\n       if (XEXP (x, 0))\n-\treg_scan_mark_refs (XEXP (x, 0), insn, note_flag);\n+\treg_scan_mark_refs (XEXP (x, 0), insn, note_flag, min_regno);\n       if (XEXP (x, 1))\n-\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag);\n+\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag, min_regno);\n       break;\n \n     case INSN_LIST:\n       if (XEXP (x, 1))\n-\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag);\n+\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag, min_regno);\n       break;\n \n     case CLOBBER:\n       {\n \trtx reg = XEXP (x, 0);\n-\tif (REG_P (reg))\n+\tif (REG_P (reg)\n+\t    && REGNO (reg) >= min_regno)\n \t  {\n \t    REG_N_SETS (REGNO (reg))++;\n \t    REG_N_REFS (REGNO (reg))++;\n \t  }\n \telse if (MEM_P (reg))\n-\t  reg_scan_mark_refs (XEXP (reg, 0), insn, note_flag);\n+\t  reg_scan_mark_refs (XEXP (reg, 0), insn, note_flag, min_regno);\n       }\n       break;\n \n@@ -2420,7 +2464,8 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag)\n       if (GET_CODE (dest) == PARALLEL)\n \tmax_set_parallel = MAX (max_set_parallel, XVECLEN (dest, 0) - 1);\n \n-      if (REG_P (dest))\n+      if (REG_P (dest)\n+\t  && REGNO (dest) >= min_regno)\n \t{\n \t  REG_N_SETS (REGNO (dest))++;\n \t  REG_N_REFS (REGNO (dest))++;\n@@ -2440,6 +2485,7 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag)\n \n       if (REG_P (SET_DEST (x))\n \t  && REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER\n+\t  && REGNO (SET_DEST (x)) >= min_regno\n \t  /* If the destination pseudo is set more than once, then other\n \t     sets might not be to a pointer value (consider access to a\n \t     union in two threads of control in the presence of global\n@@ -2500,12 +2546,12 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag)\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  {\n \t    if (fmt[i] == 'e')\n-\t      reg_scan_mark_refs (XEXP (x, i), insn, note_flag);\n+\t      reg_scan_mark_refs (XEXP (x, i), insn, note_flag, min_regno);\n \t    else if (fmt[i] == 'E' && XVEC (x, i) != 0)\n \t      {\n \t\tint j;\n \t\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t\t  reg_scan_mark_refs (XVECEXP (x, i, j), insn, note_flag);\n+\t\t  reg_scan_mark_refs (XVECEXP (x, i, j), insn, note_flag, min_regno);\n \t      }\n \t  }\n       }"}, {"sha": "ddc1adbd524381decb2e7d91bd5ef331b4eaebc1", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,6 @@\n /* Define per-register tables for data flow info and register allocation.\n    Copyright (C) 1987, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2003, 2004 Free Software Foundation, Inc.\n+   1999, 2000, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -237,6 +237,9 @@ extern int caller_save_needed;\n /* Allocate reg_n_info tables */\n extern void allocate_reg_info (size_t, int, int);\n \n+/* Clear the register information for regno.  */\n+extern void clear_reg_info_regno (unsigned int);\n+\n /* Specify number of hard registers given machine mode occupy.  */\n extern unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n "}, {"sha": "f203b27f4aace9e191bce90615fff68f04898689", "filename": "gcc/rtl.def", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -2,7 +2,7 @@\n    Register Transfer Expressions (rtx's) that make up the\n    Register Transfer Language (rtl) used in the Back End of the GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2004,\n-   2005, 2006\n+   2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -388,6 +388,12 @@ DEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", RTX_EXTRA)\n    in DECL_RTLs and during RTL generation, but not in the insn chain.  */\n DEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", RTX_OBJ)\n \n+/* (CONCATN [a1 a2 ... an]) represents the virtual concatenation of\n+   all An to make a value.  This is an extension of CONCAT to larger\n+   number of components.  Like CONCAT, it should not appear in the\n+   insn chain.  Every element of the CONCATN is the same size.  */\n+DEF_RTL_EXPR(CONCATN, \"concatn\", \"E\", RTX_OBJ)\n+\n /* A memory location; operand is the address.  The second operand is the\n    alias set to which this MEM belongs.  We use `0' instead of `w' for this\n    field so that the field need not be specified in machine descriptions.  */"}, {"sha": "4ebb0a7428bc13b62c36ecf77d6e3a726284e291", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,7 @@\n /* Register Transfer Language (RTL) definitions for GCC\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1471,6 +1472,7 @@ extern int rtx_equal_p (rtx, rtx);\n extern rtvec gen_rtvec_v (int, rtx *);\n extern rtx gen_reg_rtx (enum machine_mode);\n extern rtx gen_rtx_REG_offset (rtx, enum machine_mode, unsigned int, int);\n+extern rtx gen_reg_rtx_offset (rtx, enum machine_mode, int);\n extern rtx gen_label_rtx (void);\n extern rtx gen_lowpart_common (enum machine_mode, rtx);\n \n@@ -2162,6 +2164,7 @@ extern void init_reg_sets (void);\n extern void regclass_init (void);\n extern void regclass (rtx, int);\n extern void reg_scan (rtx, unsigned int);\n+extern void reg_scan_update (rtx, rtx, unsigned int);\n extern void fix_register (const char *, int, int);\n extern void init_subregs_of_mode (void);\n extern void record_subregs_of_mode (rtx);"}, {"sha": "656fc1fe2e3f98f03a30e78e15d46b4489f98aec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,3 +1,7 @@\n+2007-01-31  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/lower-subreg-1.c (test): New test.\n+\n 2007-01-30  Geoffrey Keating  <geoffk@apple.com>\n \n \t* g++.dg/eh/simd-4.C (main): Also catch SIGSEGV."}, {"sha": "d376c745414f94aedd956b8e35159bcdc4441bef", "filename": "gcc/testsuite/gcc.dg/lower-subreg-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-rtl-subreg\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+long long test (long long a, long long b) { return a | b; }\n+\n+/* { dg-final { scan-rtl-dump \"Splitting reg\" \"subreg\" } } */\n+/* { dg-final { cleanup-tree-dump \"subreg\" } } */"}, {"sha": "a30efc56f2feea66d050f7e8f8cc0388c84eefd3", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions for timing variables used to\n    measure run-time performance of the compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Alex Samuel <samuel@codesourcery.com>\n \n@@ -128,6 +128,7 @@ DEFTIMEVAR (TV_OVERLOAD              , \"overload resolution\")\n DEFTIMEVAR (TV_TEMPLATE_INSTANTIATION, \"template instantiation\")\n DEFTIMEVAR (TV_EXPAND\t\t     , \"expand\")\n DEFTIMEVAR (TV_VARCONST              , \"varconst\")\n+DEFTIMEVAR (TV_LOWER_SUBREG\t     , \"lower subreg\")\n DEFTIMEVAR (TV_JUMP                  , \"jump\")\n DEFTIMEVAR (TV_FWPROP                , \"forward prop\")\n DEFTIMEVAR (TV_CSE                   , \"CSE\")"}, {"sha": "bb6261371c12d3e37a0aedc4a8213ebf1ac99dea", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e53a16e75f3cbaaa46e5ce2fc1ed449a18eef7d9", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for describing one tree-ssa optimization pass.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>\n \n This file is part of GCC.\n@@ -337,6 +337,7 @@ extern struct tree_opt_pass pass_instantiate_virtual_regs;\n extern struct tree_opt_pass pass_rtl_fwprop;\n extern struct tree_opt_pass pass_rtl_fwprop_addr;\n extern struct tree_opt_pass pass_jump2;\n+extern struct tree_opt_pass pass_lower_subreg;\n extern struct tree_opt_pass pass_cse;\n extern struct tree_opt_pass pass_gcse;\n extern struct tree_opt_pass pass_jump_bypass;\n@@ -360,6 +361,7 @@ extern struct tree_opt_pass pass_if_after_combine;\n extern struct tree_opt_pass pass_partition_blocks;\n extern struct tree_opt_pass pass_regmove;\n extern struct tree_opt_pass pass_split_all_insns;\n+extern struct tree_opt_pass pass_lower_subreg2;\n extern struct tree_opt_pass pass_mode_switching;\n extern struct tree_opt_pass pass_see;\n extern struct tree_opt_pass pass_recompute_reg_usage;"}]}