{"sha": "4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2ZWIzNWE2ZGJlNmM5ODA4Nzc5Y2E0NDY2NjdmOGE4Mzc0YTExYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-19T21:02:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-19T21:02:06Z"}, "message": "ipa-devirt.c (type_in_anonymous_namespace_p): Return true or implicit declarations.\n\n\n\t* ipa-devirt.c (type_in_anonymous_namespace_p): Return true\n\tor implicit declarations.\n\t(odr_type_p): Check that TYPE_NAME is TYPE_DECL before looking\n\tinto it.\n\t(get_odr_type): Check type has linkage before adding bases.\n\t(register_odr_type): Check that type has linkage before adding it.\n\t(type_known_to_have_no_deriavations_p): Rename to ..\n\t(type_known_to_have_no_derivations_p): This one.\n\t* ipa-utils.h (type_known_to_have_no_deriavations_p): Rename to ..\n\t(type_known_to_have_no_derivations_p): This one.\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::restrict_to_inner_type): Check that\n\ttype has linkage.\n\nFrom-SVN: r223415", "tree": {"sha": "931fdcb291847f90f2d4c69e3f993bf2c4cd3d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/931fdcb291847f90f2d4c69e3f993bf2c4cd3d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/comments", "author": null, "committer": null, "parents": [{"sha": "296a8c2f54dd8bf2f84c687db8329f179774220e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296a8c2f54dd8bf2f84c687db8329f179774220e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/296a8c2f54dd8bf2f84c687db8329f179774220e"}], "stats": {"total": 33, "additions": 27, "deletions": 6}, "files": [{"sha": "f9d91ecf2053d125543a42c6a0d6d6f93d4bd39f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "patch": "@@ -1,3 +1,19 @@\n+2015-05-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (type_in_anonymous_namespace_p): Return true\n+\tor implicit declarations.\n+\t(odr_type_p): Check that TYPE_NAME is TYPE_DECL before looking\n+\tinto it.\n+\t(get_odr_type): Check type has linkage before adding bases.\n+\t(register_odr_type): Check that type has linkage before adding it.\n+\t(type_known_to_have_no_deriavations_p): Rename to ..\n+\t(type_known_to_have_no_derivations_p): This one.\n+\t* ipa-utils.h (type_known_to_have_no_deriavations_p): Rename to ..\n+\t(type_known_to_have_no_derivations_p): This one.\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::restrict_to_inner_type): Check that\n+\ttype has linkage.\n+\n 2015-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* stor-layout.c (finalize_type_size): Use AGGREGATE_TYPE_P."}, {"sha": "09c3b5b045586ef42ded142369ddb8fb3030f1c2", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "patch": "@@ -269,6 +269,8 @@ type_in_anonymous_namespace_p (const_tree t)\n \n   if (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)))\n     {\n+      if (DECL_ARTIFICIAL (TYPE_NAME (t)))\n+\treturn true;\n       tree ctx = DECL_CONTEXT (TYPE_NAME (t));\n       while (ctx)\n \t{\n@@ -296,7 +298,7 @@ odr_type_p (const_tree t)\n      to care, since it is used only for type merging.  */\n   gcc_checking_assert (in_lto_p || flag_lto);\n \n-  return (TYPE_NAME (t)\n+  return (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n           && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n }\n \n@@ -2124,6 +2126,7 @@ get_odr_type (tree type, bool insert)\n     }\n \n   if (build_bases && TREE_CODE (type) == RECORD_TYPE && TYPE_BINFO (type)\n+      && type_with_linkage_p (type)\n       && type == TYPE_MAIN_VARIANT (type))\n     {\n       tree binfo = TYPE_BINFO (type);\n@@ -2183,7 +2186,8 @@ register_odr_type (tree type)\n      makes it possible that non-ODR type is main_odr_variant of ODR type.\n      Things may get smoother if LTO FE set mangled name of those types same\n      way as C++ FE does.  */\n-  if (odr_type_p (main_odr_variant (TYPE_MAIN_VARIANT (type))))\n+  if (odr_type_p (main_odr_variant (TYPE_MAIN_VARIANT (type)))\n+      && odr_type_p (TYPE_MAIN_VARIANT (type)))\n     get_odr_type (TYPE_MAIN_VARIANT (type), true);\n   if (TYPE_MAIN_VARIANT (type) != type && odr_type_p (main_odr_variant (type)))\n     get_odr_type (type, true);\n@@ -2192,7 +2196,7 @@ register_odr_type (tree type)\n /* Return true if type is known to have no derivations.  */\n \n bool\n-type_known_to_have_no_deriavations_p (tree t)\n+type_known_to_have_no_derivations_p (tree t)\n {\n   return (type_all_derivations_known_p (t)\n \t  && (TYPE_FINAL_P (t)"}, {"sha": "083648d7e4213969179d77b9293e9473d2a69590", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "patch": "@@ -269,7 +269,8 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t\t types.  Testing it here may help us to avoid speculation.  */\n \t      if (otr_type && TREE_CODE (outer_type) == RECORD_TYPE\n \t\t  && (!in_lto_p || odr_type_p (outer_type))\n-\t\t  && type_known_to_have_no_deriavations_p (outer_type))\n+\t\t  && type_with_linkage_p (outer_type)\n+\t\t  && type_known_to_have_no_derivations_p (outer_type))\n \t\tmaybe_derived_type = false;\n \n \t      /* Type can not contain itself on an non-zero offset.  In that case\n@@ -393,7 +394,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t    goto no_useful_type_info;\n \n \t  cur_offset = new_offset;\n-\t  type = subtype;\n+\t  type = TYPE_MAIN_VARIANT (subtype);\n \t  if (!speculative)\n \t    {\n \t      outer_type = type;"}, {"sha": "46c82dafd80f99dd7137a43337ef2b538d4e1e91", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6eb35a6dbe6c9808779ca446667f8a8374a11b/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=4d6eb35a6dbe6c9808779ca446667f8a8374a11b", "patch": "@@ -80,7 +80,7 @@ bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT\n tree subbinfo_with_vtable_at_offset (tree, unsigned HOST_WIDE_INT, tree);\n void compare_virtual_tables (varpool_node *, varpool_node *);\n bool type_all_derivations_known_p (const_tree);\n-bool type_known_to_have_no_deriavations_p (tree);\n+bool type_known_to_have_no_derivations_p (tree);\n bool contains_polymorphic_type_p (const_tree);\n void register_odr_type (tree);\n bool types_must_be_same_for_odr (tree, tree);"}]}