{"sha": "52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJjMTFlZjZhM2ViMGUyMDU4OTlkZjBmNTRjMWM0MWJlMzFjOGFlOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-16T16:38:26Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-16T16:38:26Z"}, "message": "decl.c (qualify_lookup): New fn.\n\n\t* decl.c (qualify_lookup): New fn.\n\t(lookup_name_real): Use it.\n\t* decl2.c (add_using_namespace): When directly using a namespace\n\tthat was indirect before, promote it.\n\t* cp-tree.h (LOOKUP_PREFER_TYPES, LOOKUP_PREFER_NAMESPACES,\n\tLOOKUP_PREFER_BOTH, LOOKUP_NAMESPACES_ONLY, LOOKUP_TYPES_ONLY,\n\tLOOKUP_QUALIFIERS_ONLY, LOOKUP_TEMPLATES_EXPECTED): New macros.\n\t* decl.c (select_decl): Replace two flag parameters by one.\n\t(unqualified_namespace_lookup): Likewise, pass flag.\n\t(lookup_flags): New function.\n\t(lookup_name_real): Compute flags, pass them.\n\t(lookup_namespace_name): Call with zero-flag.\n\t* decl2.c (ambiguous_decl): Add flag parameter, complain only\n\taccording to flags.\n\t(lookup_using_namespace, qualified_lookup_using_namespace):\n\tAdd flag parameter, pass them through.\n\t* lex.c (do_scoped_id): Call with zero-flag.\n\nFrom-SVN: r21218", "tree": {"sha": "cbe972f9255ef0c0563c1646d2e79d46177a5784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbe972f9255ef0c0563c1646d2e79d46177a5784"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/comments", "author": null, "committer": null, "parents": [{"sha": "a942e89c9a5eb08a050d632d21ad12a1de25c65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a942e89c9a5eb08a050d632d21ad12a1de25c65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a942e89c9a5eb08a050d632d21ad12a1de25c65b"}], "stats": {"total": 251, "additions": 183, "deletions": 68}, "files": [{"sha": "1abd30d818db92e5c14c2518ef9db8ae068c273a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "patch": "@@ -1,3 +1,27 @@\n+1998-07-16  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (qualify_lookup): New fn.\n+\t(lookup_name_real): Use it.\n+\n+1998-07-16  Martin v. Loewis  <loewis@informatik.hu-berlin.de>\n+\n+\t* decl2.c (add_using_namespace): When directly using a namespace\n+\tthat was indirect before, promote it.\n+\n+\t* cp-tree.h (LOOKUP_PREFER_TYPES, LOOKUP_PREFER_NAMESPACES,\n+\tLOOKUP_PREFER_BOTH, LOOKUP_NAMESPACES_ONLY, LOOKUP_TYPES_ONLY,\n+\tLOOKUP_QUALIFIERS_ONLY, LOOKUP_TEMPLATES_EXPECTED): New macros.\n+\t* decl.c (select_decl): Replace two flag parameters by one.\n+\t(unqualified_namespace_lookup): Likewise, pass flag.\n+\t(lookup_flags): New function.\n+\t(lookup_name_real): Compute flags, pass them.\n+\t(lookup_namespace_name): Call with zero-flag.\n+\t* decl2.c (ambiguous_decl): Add flag parameter, complain only\n+\taccording to flags.\n+\t(lookup_using_namespace, qualified_lookup_using_namespace):\n+\tAdd flag parameter, pass them through.\n+\t* lex.c (do_scoped_id): Call with zero-flag.\n+\n 1998-07-16  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck.c (convert_for_assignment): Use comptypes."}, {"sha": "3f8840a7609b3bd5bf917c2ab869aaab39e5360d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "patch": "@@ -2174,7 +2174,16 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    LOOKUP_NO_CONVERSION means that user-defined conversions are not\n      permitted.  Built-in conversions are permitted.\n    LOOKUP_DESTRUCTOR means explicit call to destructor.\n-   LOOKUP_NO_TEMP_BIND means temporaries will not be bound to references.  */\n+   LOOKUP_NO_TEMP_BIND means temporaries will not be bound to references.\n+\n+   These are used in global lookup to support elaborated types and\n+   qualifiers.\n+   \n+   LOOKUP_PREFER_TYPES means not to accept objects, and possibly namespaces.\n+   LOOKUP_PREFER_NAMESPACES means not to accept objects, and possibly types.\n+   LOOKUP_PREFER_BOTH means class-or-namespace-name.\n+   LOOKUP_TEMPLATES_EXPECTED means that class templates also count\n+     as types.  */\n \n #define LOOKUP_PROTECT (1)\n #define LOOKUP_COMPLAIN (2)\n@@ -2189,6 +2198,17 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define LOOKUP_NO_CONVERSION (512)\n #define LOOKUP_DESTRUCTOR (512)\n #define LOOKUP_NO_TEMP_BIND (1024)\n+#define LOOKUP_PREFER_TYPES (2048)\n+#define LOOKUP_PREFER_NAMESPACES (4096)\n+#define LOOKUP_PREFER_BOTH (6144)\n+#define LOOKUP_TEMPLATES_EXPECTED (8192)\n+\n+#define LOOKUP_NAMESPACES_ONLY(f)  \\\n+  (((f) & LOOKUP_PREFER_NAMESPACES) && !((f) & LOOKUP_PREFER_TYPES))\n+#define LOOKUP_TYPES_ONLY(f)  \\\n+  (!((f) & LOOKUP_PREFER_NAMESPACES) && ((f) & LOOKUP_PREFER_TYPES))\n+#define LOOKUP_QUALIFIERS_ONLY(f)     ((f) & LOOKUP_PREFER_BOTH)\n+     \n \n /* These flags are used by the conversion code.\n    CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined).\n@@ -2386,8 +2406,8 @@ extern tree lookup_name_current_level\t\tPROTO((tree));\n extern tree lookup_name_namespace_only          PROTO((tree));\n extern void begin_only_namespace_names          PROTO((void));\n extern void end_only_namespace_names            PROTO((void));\n-extern int  lookup_using_namespace              PROTO((tree,tree,tree,tree));\n-extern int  qualified_lookup_using_namespace    PROTO((tree,tree,tree));\n+extern int  lookup_using_namespace              PROTO((tree,tree,tree,tree,int));\n+extern int  qualified_lookup_using_namespace    PROTO((tree,tree,tree,int));\n extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));\n extern void init_decl_processing\t\tPROTO((void));\n extern int init_type_desc\t\t\tPROTO((void));"}, {"sha": "0801ab83a86bff38e427db22e4af06c09ec34832", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 63, "deletions": 36, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "patch": "@@ -4646,7 +4646,7 @@ lookup_namespace_name (namespace, name)\n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n   \n   val = binding_init (&_b);\n-  if (!qualified_lookup_using_namespace (name, namespace, val))\n+  if (!qualified_lookup_using_namespace (name, namespace, val, 0))\n     return error_mark_node;\n \n   if (BINDING_VALUE (val))\n@@ -4736,13 +4736,13 @@ make_typename_type (context, name)\n /* Select the right _DECL from multiple choices. */\n \n static tree\n-select_decl (binding, prefer_type, namespaces_only)\n+select_decl (binding, flags)\n      tree binding;\n-     int prefer_type, namespaces_only;\n+     int flags;\n {\n   tree val;\n   val = BINDING_VALUE (binding);\n-  if (namespaces_only)\n+  if (LOOKUP_NAMESPACES_ONLY (flags))\n     {\n       /* We are not interested in types. */\n       if (val && TREE_CODE (val) == NAMESPACE_DECL)\n@@ -4753,10 +4753,11 @@ select_decl (binding, prefer_type, namespaces_only)\n   /* If we could have a type and\n      we have nothing or we need a type and have none.  */\n   if (BINDING_TYPE (binding)\n-      && (!val || (prefer_type && TREE_CODE (val) != TYPE_DECL)))\n+      && (!val || ((flags & LOOKUP_PREFER_TYPES)\n+                   && TREE_CODE (val) != TYPE_DECL)))\n     val = TYPE_STUB_DECL (BINDING_TYPE (binding));\n   /* Don't return non-types if we really prefer types. */\n-  else if (val && prefer_type > 1  && TREE_CODE (val) != TYPE_DECL\n+  else if (val && LOOKUP_TYPES_ONLY (flags)  && TREE_CODE (val) != TYPE_DECL\n \t   && (!looking_for_template || TREE_CODE (val) != TEMPLATE_DECL))\n     val = NULL_TREE;\n   return val;\n@@ -4766,10 +4767,9 @@ select_decl (binding, prefer_type, namespaces_only)\n    using namespace statements. */\n \n static tree\n-unqualified_namespace_lookup (name, prefer_type, namespaces_only)\n+unqualified_namespace_lookup (name, flags)\n      tree name;\n-     int prefer_type;\n-     int namespaces_only;\n+     int flags;\n {\n   struct tree_binding _binding;\n   tree b = binding_init (&_binding);\n@@ -4791,7 +4791,8 @@ unqualified_namespace_lookup (name, prefer_type, namespaces_only)\n       for (level = current_binding_level; \n \t   !level->namespace_p;\n \t   level = level->level_chain)\n-\tif (!lookup_using_namespace (name, b, level->using_directives, scope))\n+\tif (!lookup_using_namespace (name, b, level->using_directives,\n+                                     scope, flags))\n \t  /* Give up because of error. */\n \t  return NULL_TREE;\n \n@@ -4801,14 +4802,14 @@ unqualified_namespace_lookup (name, prefer_type, namespaces_only)\n       while (1)\n \t{\n \t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter), \n-\t\t\t\t       scope))\n+\t\t\t\t       scope, flags))\n \t    /* Give up because of error. */\n \t    return NULL_TREE;\n \t  if (siter == scope) break;\n \t  siter = CP_DECL_CONTEXT (siter);\n \t}\n \n-      val = select_decl (b, prefer_type, namespaces_only);\n+      val = select_decl (b, flags);\n       if (scope == global_namespace)\n \tbreak;\n       scope = DECL_CONTEXT (scope);\n@@ -4818,6 +4819,38 @@ unqualified_namespace_lookup (name, prefer_type, namespaces_only)\n   return val;\n }\n \n+/* Combine prefer_type and namespaces_only into flags.  */\n+\n+static int\n+lookup_flags (prefer_type, namespaces_only)\n+  int prefer_type, namespaces_only;\n+{\n+  if (namespaces_only)\n+    return LOOKUP_PREFER_NAMESPACES;\n+  if (prefer_type > 1)\n+    return LOOKUP_PREFER_TYPES;\n+  if (prefer_type > 0)\n+    return LOOKUP_PREFER_BOTH;\n+  return 0;\n+}\n+\n+/* Given a lookup that returned VAL, use FLAGS to decide if we want to\n+   ignore it or not.  Subroutine of lookup_name_real.  */\n+\n+static tree\n+qualify_lookup (val, flags)\n+     tree val;\n+     int flags;\n+{\n+  if (val == NULL_TREE)\n+    return val;\n+  if (LOOKUP_NAMESPACES_ONLY (flags) && TREE_CODE (val) != NAMESPACE_DECL)\n+    return NULL_TREE;\n+  if (LOOKUP_TYPES_ONLY (flags) && TREE_CODE (val) != TYPE_DECL)\n+    return NULL_TREE;\n+  return val;\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -4841,11 +4874,12 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   int yylex = 0;\n   tree from_obj = NULL_TREE;\n   tree locval, classval;\n+  int flags;\n \n   /* Hack: copy flag set by parser, if set. */\n   if (only_namespace_names)\n     namespaces_only = 1;\n-  \n+\n   if (prefer_type == -2)\n     {\n       extern int looking_for_typename;\n@@ -4854,6 +4888,13 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       yylex = 1;\n       prefer_type = looking_for_typename;\n \n+      flags = lookup_flags (prefer_type, namespaces_only);\n+      /* During parsing, we need to complain. */\n+      flags |= LOOKUP_COMPLAIN;\n+      /* If the next thing is '<', class templates are types. */\n+      if (looking_for_template)\n+        flags |= LOOKUP_TEMPLATES_EXPECTED;\n+\n       /* std:: becomes :: for now.  */\n       if (got_scope == std_node)\n \tgot_scope = void_type_node;\n@@ -4879,9 +4920,9 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t    {\n \t      struct tree_binding b;\n \t      val = binding_init (&b);\n-\t      if (!qualified_lookup_using_namespace (name, type, val))\n+\t      if (!qualified_lookup_using_namespace (name, type, val, flags))\n \t\treturn NULL_TREE;\n-\t      val = select_decl (val, prefer_type, namespaces_only);\n+\t      val = select_decl (val, flags);\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n \t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n@@ -4922,29 +4963,13 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       else if (got_object && val)\n \tfrom_obj = val;\n     }\n+  else\n+    flags = lookup_flags (prefer_type, namespaces_only);\n \n   locval = classval = NULL_TREE;\n \n-  if (!current_binding_level->namespace_p\n-      && IDENTIFIER_LOCAL_VALUE (name))\n-    switch (TREE_CODE (IDENTIFIER_LOCAL_VALUE (name)))\n-      {\n-      case NAMESPACE_DECL:\n-        /* A namespace is rejected only if we strictly require types. */\n-        if (prefer_type <= 1)\n-          locval = IDENTIFIER_LOCAL_VALUE (name);\n-        break;\n-      case TYPE_DECL:\n-        /* A type is rejected only if we strictly require namespaces. */\n-        if (!namespaces_only)\n-          locval = IDENTIFIER_LOCAL_VALUE (name);\n-        break;\n-      default:\n-        /* We require neither types or namespaces. */\n-        if (!namespaces_only && prefer_type <= 0)\n-          locval = IDENTIFIER_LOCAL_VALUE (name);\n-        break;\n-      }\n+  if (! namespace_bindings_p ())\n+    locval = qualify_lookup (IDENTIFIER_LOCAL_VALUE (name), flags);\n \n   /* In C++ class fields are between local and global scope,\n      just before the global scope.  */\n@@ -4972,6 +4997,8 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t created the COMPONENT_REF or anything like that.  */\n       if (classval == NULL_TREE)\n \tclassval = lookup_nested_field (name, ! yylex);\n+\n+      classval = qualify_lookup (classval, flags);\n     }\n \n   if (locval && classval)\n@@ -5003,7 +5030,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   else if (classval)\n     val = classval;\n   else\n-    val = unqualified_namespace_lookup (name, prefer_type, namespaces_only);\n+    val = unqualified_namespace_lookup (name, flags);\n \n  done:\n   if (val)"}, {"sha": "bd32d627dbcb6502d4622ec1fd958d38aa4c10b2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 72, "deletions": 28, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "patch": "@@ -60,7 +60,7 @@ static void finish_sigtable_vardecl PROTO((tree, tree));\n static int is_namespace_ancestor PROTO((tree, tree));\n static tree namespace_ancestor PROTO((tree, tree));\n static void add_using_namespace PROTO((tree, tree, int));\n-static tree ambiguous_decl PROTO((tree, tree, tree));\n+static tree ambiguous_decl PROTO((tree, tree, tree,int));\n static tree build_anon_union_vars PROTO((tree, tree*, int, int));\n static void check_decl_namespace PROTO((void));\n \n@@ -3857,15 +3857,21 @@ add_using_namespace (user, used, indirect)\n      tree used;\n      int indirect;\n {\n-  tree iter;\n+  tree t;\n   /* Using oneself is a no-op. */\n   if (user == used)\n     return;\n   my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n   my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n   /* Check if we already have this. */\n-  if (purpose_member (used, DECL_NAMESPACE_USING (user)) != NULL_TREE)\n-    return;\n+  t = purpose_member (used, DECL_NAMESPACE_USING (user));\n+  if (t != NULL_TREE)\n+    {\n+      if (!indirect)\n+\t/* Promote to direct usage. */\n+\tTREE_INDIRECT_USING (t) = 0;\n+      return;\n+    }\n \n   /* Add used to the user's using list. */\n   DECL_NAMESPACE_USING (user) \n@@ -3879,13 +3885,13 @@ add_using_namespace (user, used, indirect)\n     = perm_tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n \n   /* Recursively add all namespaces used. */\n-  for (iter = DECL_NAMESPACE_USING (used); iter; iter = TREE_CHAIN (iter))\n+  for (t = DECL_NAMESPACE_USING (used); t; t = TREE_CHAIN (t))\n     /* indirect usage */\n-    add_using_namespace (user, TREE_PURPOSE (iter), 1);\n+    add_using_namespace (user, TREE_PURPOSE (t), 1);\n \n   /* Tell everyone using us about the new used namespaces. */\n-  for (iter = DECL_NAMESPACE_USERS (user); iter; iter = TREE_CHAIN (iter))\n-    add_using_namespace (TREE_PURPOSE (iter), used, 1);\n+  for (t = DECL_NAMESPACE_USERS (user); t; t = TREE_CHAIN (t))\n+    add_using_namespace (TREE_PURPOSE (t), used, 1);\n }\n \n /* Combines two sets of overloaded functions into an OVERLOAD chain.\n@@ -3916,42 +3922,77 @@ merge_functions (s1, s2)\n    XXX I don't want to repeat the entire duplicate_decls here */\n \n static tree\n-ambiguous_decl (name, old, new)\n+ambiguous_decl (name, old, new, flags)\n      tree name;\n      tree old;\n      tree new;\n+     int flags;\n {\n+  tree val, type;\n   my_friendly_assert (old != NULL_TREE, 393);\n   /* Copy the value. */\n+  val = BINDING_VALUE (new);\n+  if (val)\n+    switch (TREE_CODE (val))\n+      {\n+      case TEMPLATE_DECL:\n+        /* If we expect types or namespaces, and not templates,\n+           or this is not a template class. */\n+        if (LOOKUP_QUALIFIERS_ONLY (flags)\n+            && (!(flags & LOOKUP_TEMPLATES_EXPECTED)\n+                || !DECL_CLASS_TEMPLATE_P (val)))\n+          val = NULL_TREE;\n+        break;\n+      case TYPE_DECL:\n+        if (LOOKUP_NAMESPACES_ONLY (flags))\n+          val = NULL_TREE;\n+        break;\n+      case NAMESPACE_DECL:\n+        if (LOOKUP_TYPES_ONLY (flags))\n+          val = NULL_TREE;\n+        break;\n+      default:\n+        if (LOOKUP_QUALIFIERS_ONLY (flags))\n+          val = NULL_TREE;\n+      }\n+        \n   if (!BINDING_VALUE (old))\n-    BINDING_VALUE (old) = BINDING_VALUE (new);\n-  else if (BINDING_VALUE (new) \n-\t   && BINDING_VALUE (new) != BINDING_VALUE (old))\n+    BINDING_VALUE (old) = val;\n+  else if (val && val != BINDING_VALUE (old))\n     {\n       if (is_overloaded_fn (BINDING_VALUE (old)) \n-\t  && is_overloaded_fn (BINDING_VALUE (new)))\n+\t  && is_overloaded_fn (val))\n \t{\n \t  BINDING_VALUE (old) = merge_functions (BINDING_VALUE (old),\n-\t\t\t\t\t\t BINDING_VALUE (new));\n+\t\t\t\t\t\t val);\n \t}\n       else\n \t{\n \t  /* Some declarations are functions, some are not. */\n-\t  cp_error (\"use of `%D' is ambiguous\", name);\n-\t  cp_error_at (\"  first declared as `%#D' here\", BINDING_VALUE (old));\n-\t  cp_error_at (\"  also declared as `%#D' here\", BINDING_VALUE (new));\n+          if (flags & LOOKUP_COMPLAIN)\n+            {\n+              cp_error (\"use of `%D' is ambiguous\", name);\n+              cp_error_at (\"  first declared as `%#D' here\",\n+                           BINDING_VALUE (old));\n+              cp_error_at (\"  also declared as `%#D' here\", val);\n+            }\n \t  return error_mark_node;\n \t}\n     }\n   /* ... and copy the type. */\n+  type = BINDING_TYPE (new);\n+  if (LOOKUP_NAMESPACES_ONLY (flags))\n+    type = NULL_TREE;\n   if (!BINDING_TYPE (old))\n-    BINDING_TYPE (old) = BINDING_TYPE (new);\n-  else if(BINDING_TYPE (new)\n-\t  && BINDING_TYPE (old) != BINDING_TYPE (new))\n+    BINDING_TYPE (old) = type;\n+  else if(type && BINDING_TYPE (old) != type)\n     {\n-      cp_error (\"`%D' denotes an ambiguous type\",name);\n-      cp_error_at (\"first type here\", BINDING_TYPE (old));\n-      cp_error_at (\"other type here\", BINDING_TYPE (new));\n+      if (flags & LOOKUP_COMPLAIN)\n+        {\n+          cp_error (\"`%D' denotes an ambiguous type\",name);\n+          cp_error_at (\"  first type here\", BINDING_TYPE (old));\n+          cp_error_at (\"  other type here\", type);\n+        }\n     }\n   return old;\n }\n@@ -3961,8 +4002,9 @@ ambiguous_decl (name, old, new)\n    Returns zero on errors. */\n \n int\n-lookup_using_namespace (name, val, usings, scope)\n+lookup_using_namespace (name, val, usings, scope, flags)\n      tree name, val, usings, scope;\n+     int flags;\n {\n   tree iter;\n   tree val1;\n@@ -3973,7 +4015,7 @@ lookup_using_namespace (name, val, usings, scope)\n       {\n \tval1 = binding_for_name (name, TREE_PURPOSE (iter));\n \t/* Resolve ambiguities. */\n-\tval = ambiguous_decl (name, val, val1);\n+\tval = ambiguous_decl (name, val, val1, flags);\n       }\n   return val != error_mark_node;\n }\n@@ -3984,10 +4026,11 @@ lookup_using_namespace (name, val, usings, scope)\n    or 0 on error. */\n \n int\n-qualified_lookup_using_namespace (name, scope, result)\n+qualified_lookup_using_namespace (name, scope, result, flags)\n      tree name;\n      tree scope;\n      tree result;\n+     int flags;\n {\n   /* Maintain a list of namespaces visited... */\n   tree seen = NULL_TREE;\n@@ -3997,7 +4040,8 @@ qualified_lookup_using_namespace (name, scope, result)\n   while (scope && (result != error_mark_node))\n     {\n       seen = temp_tree_cons (scope, NULL_TREE, seen);\n-      result = ambiguous_decl (name, result, binding_for_name (name, scope));\n+      result = ambiguous_decl (name, result,\n+                               binding_for_name (name, scope), flags);\n       if (!BINDING_VALUE (result) && !BINDING_TYPE (result))\n \t/* Consider using directives. */\n \tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n@@ -4437,7 +4481,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n \n   *newval = *newtype = NULL_TREE;\n   decls = binding_init (&_decls);\n-  if (!qualified_lookup_using_namespace (name, scope, decls))\n+  if (!qualified_lookup_using_namespace (name, scope, decls, 0))\n     /* Lookup error */\n     return;\n "}, {"sha": "8573a8543fe53b1363317bd934898ec9f4fd2100", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c11ef6a3eb0e205899df0f54c1c41be31c8ae9/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=52c11ef6a3eb0e205899df0f54c1c41be31c8ae9", "patch": "@@ -3014,7 +3014,7 @@ do_scoped_id (token, parsing)\n     {\n       struct tree_binding _b;\n       id = binding_init (&_b);\n-      if (!qualified_lookup_using_namespace (token, global_namespace, id))\n+      if (!qualified_lookup_using_namespace (token, global_namespace, id, 0))\n \tid = NULL_TREE;\n       else\n \tid = BINDING_VALUE (id);"}]}