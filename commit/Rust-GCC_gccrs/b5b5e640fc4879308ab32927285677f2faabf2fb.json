{"sha": "b5b5e640fc4879308ab32927285677f2faabf2fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjViNWU2NDBmYzQ4NzkzMDhhYjMyOTI3Mjg1Njc3ZjJmYWFiZjJmYg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-02-18T13:32:01Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-02-18T13:32:01Z"}, "message": "[multiple changes]\n\n2008-02-18  Pedro Lamarao <pedro.lamarao@mndfck.org>\n\n\t* include/std/tuple: Fixes for moveable, non-copyable types.\n\t* testsuite/20_util/tuple/moveable2.cc: New.\n\n2008-02-18  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/std/tuple (operator+(tuple<>&&, tuple<>&&): Remove.\n\nFrom-SVN: r132389", "tree": {"sha": "b96d593f1275f1808cedb582809de42fa73f172a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b96d593f1275f1808cedb582809de42fa73f172a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5b5e640fc4879308ab32927285677f2faabf2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b5e640fc4879308ab32927285677f2faabf2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5b5e640fc4879308ab32927285677f2faabf2fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b5e640fc4879308ab32927285677f2faabf2fb/comments", "author": null, "committer": null, "parents": [{"sha": "fce9c862a68b9719a328b34b997ee96ba40d73be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce9c862a68b9719a328b34b997ee96ba40d73be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fce9c862a68b9719a328b34b997ee96ba40d73be"}], "stats": {"total": 171, "additions": 124, "deletions": 47}, "files": [{"sha": "68ca46a0397840e5cd964723a38dcf3d66e9fdca", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b5e640fc4879308ab32927285677f2faabf2fb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b5e640fc4879308ab32927285677f2faabf2fb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b5b5e640fc4879308ab32927285677f2faabf2fb", "patch": "@@ -1,3 +1,12 @@\n+2008-02-18  Pedro Lamarao <pedro.lamarao@mndfck.org>\n+\n+\t* include/std/tuple: Fixes for moveable, non-copyable types.\n+\t* testsuite/20_util/tuple/moveable2.cc: New.\n+\n+2008-02-18  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/std/tuple (operator+(tuple<>&&, tuple<>&&): Remove.\n+\n 2008-02-17  Ed Smith-Rowland  <3dw4rd@verizon.net>\n \n \t* include/tr1/poly_laguerre.tcc: Doxygen fixes."}, {"sha": "b870234c1298f0446ef5a5924a09889694a91aba", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b5e640fc4879308ab32927285677f2faabf2fb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b5e640fc4879308ab32927285677f2faabf2fb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=b5b5e640fc4879308ab32927285677f2faabf2fb", "patch": "@@ -72,11 +72,12 @@ namespace std\n       _Head_base()\n       : _Head() { }\n \n-      _Head_base(typename __add_c_ref<_Head>::type __h)\n+      _Head_base(const _Head& __h)\n       : _Head(__h) { }\n \n-      _Head_base(typename std::remove_reference<_Head>::type&& __h)\n-      : _Head(std::forward<_Head>(__h)) { }\n+      template<typename _UHead>\n+      _Head_base(_UHead&& __h)\n+      : _Head(std::forward<_UHead>(__h)) { }\n \n       _Head&       _M_head()       { return *this; }\n       const _Head& _M_head() const { return *this; }\n@@ -88,11 +89,12 @@ namespace std\n       _Head_base()\n       : _M_head_impl() { }\n \n-      _Head_base(typename __add_c_ref<_Head>::type __h)\n+      _Head_base(const _Head& __h)\n       : _M_head_impl(__h) { }\n \n-      _Head_base(typename std::remove_reference<_Head>::type&& __h)\n-      : _M_head_impl(std::move(__h)) { }\n+      template<typename _UHead>\n+      _Head_base(_UHead&& __h)\n+      : _M_head_impl(std::forward<_UHead>(__h)) { }\n \n       _Head&       _M_head()       { return _M_head_impl; }\n       const _Head& _M_head() const { return _M_head_impl; }        \n@@ -141,32 +143,32 @@ namespace std\n       : _Inherited(), _Base() { }\n \n       explicit \n-      _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n-\t\t  typename __add_c_ref<_Tail>::type... __tail)\n+      _Tuple_impl(const _Head& __head, const _Tail&... __tail)\n       : _Inherited(__tail...), _Base(__head) { }\n \n       template<typename _UHead, typename... _UTail> \n         explicit\n-        _Tuple_impl(typename std::remove_reference<_UHead>::type&& __head,\n-\t\t    typename std::remove_reference<_UTail>::type&&... __tail)\n-\t: _Inherited(std::forward<_Inherited>(__tail)...),\n-\t  _Base(std::forward<_Base>(__head)) { }\n+        _Tuple_impl(_UHead&& __head, _UTail&&... __tail)\n+\t: _Inherited(std::forward<_UTail>(__tail)...),\n+\t  _Base(std::forward<_UHead>(__head)) { }\n \n       _Tuple_impl(const _Tuple_impl& __in)\n       : _Inherited(__in._M_tail()), _Base(__in._M_head()) { }\n \n       _Tuple_impl(_Tuple_impl&& __in)\n-      : _Inherited(std::forward<_Inherited>(__in._M_tail())),\n-\t_Base(std::forward<_Base>(__in._M_head())) { }\n+      : _Inherited(std::move<_Inherited&&>(__in._M_tail())),\n+\t_Base(std::forward<_Head>(__in._M_head())) { }\n \n       template<typename... _UElements>\n         _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n \t: _Inherited(__in._M_tail()), _Base(__in._M_head()) { }\n \n       template<typename... _UElements>\n         _Tuple_impl(_Tuple_impl<_Idx, _UElements...>&& __in)\n-\t: _Inherited(std::forward<_Inherited>(__in._M_tail())),\n-\t  _Base(std::forward<_Base>(__in._M_head())) { }\n+\t: _Inherited(std::move<typename _Tuple_impl<_Idx, _UElements...>::\n+\t\t     _Inherited&&>(__in._M_tail())),\n+\t  _Base(std::forward<typename _Tuple_impl<_Idx, _UElements...>::\n+\t\t_Base>(__in._M_head())) { }\n \n       _Tuple_impl&\n       operator=(const _Tuple_impl& __in)\n@@ -219,21 +221,28 @@ namespace std\n       template<typename... _UElements>\n         explicit\n         tuple(_UElements&&... __elements)\n-\t: _Inherited(std::forward<_UElements>(__elements)...) { }\n+\t: _Inherited(std::forward<_UElements>(__elements)...) {\t}\n \n       tuple(const tuple& __in)\n-      : _Inherited(__in) { }\n+      : _Inherited(static_cast<const _Inherited&>(__in)) { }\n \n       tuple(tuple&& __in)\n-      : _Inherited(std::move(__in)) { }\n+      : _Inherited(std::move<_Inherited>(__in)) { }\n \n       template<typename... _UElements>\n         tuple(const tuple<_UElements...>& __in)\n-\t: _Inherited(__in) { }\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n \n       template<typename... _UElements>\n         tuple(tuple<_UElements...>&& __in)\n-\t: _Inherited(std::move(__in)) { }\n+\t: _Inherited(std::move<_Tuple_impl<0, _UElements...> >(__in)) { }\n+\n+      // XXX http://gcc.gnu.org/ml/libstdc++/2008-02/msg00047.html\n+      template<typename... _UElements>\n+        tuple(tuple<_UElements...>& __in)\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n \n       tuple&\n       operator=(const tuple& __in)\n@@ -288,34 +297,26 @@ namespace std\n \t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n \n       tuple(const tuple& __in)\n-      : _Inherited(__in) { }\n+      : _Inherited(static_cast<const _Inherited&>(__in)) { }\n \n       tuple(tuple&& __in)\n-      : _Inherited(std::move(__in)) { }\n+      : _Inherited(std::move<_Inherited>(__in)) { }\n \n       template<typename _U1, typename _U2>\n         tuple(const tuple<_U1, _U2>& __in)\n-\t: _Inherited(__in) { }\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n \n       template<typename _U1, typename _U2>\n         tuple(tuple<_U1, _U2>&& __in)\n-\t: _Inherited(std::move(__in)) { }\n+\t: _Inherited(std::move<_Tuple_impl<0, _U1, _U2> >(__in)) { }\n \n       template<typename _U1, typename _U2>\n         tuple(const pair<_U1, _U2>& __in)\n-\t: _Inherited(_Tuple_impl<0, \n-\t\t     typename __add_c_ref<_U1>::type,\n-\t\t     typename __add_c_ref<_U2>::type>(__in.first, \n-\t\t\t\t\t\t      __in.second))\n-        { }\n+\t: _Inherited(__in.first, __in.second) { }\n \n       template<typename _U1, typename _U2>\n         tuple(pair<_U1, _U2>&& __in)\n-\t: _Inherited(_Tuple_impl<0, \n-\t\t     typename std::remove_reference<_U1>::type&&,\n-\t\t     typename std::remove_reference<_U2>::type&&>\n-\t\t     (std::move(__in.first), std::move(__in.second)))\n-        { }\n+\t: _Inherited(std::move(__in.first), std::move(__in.second)) { }\n \n       tuple&\n       operator=(const tuple& __in)\n@@ -555,8 +556,8 @@ namespace std\n \t\t       const __index_holder<_TIdx...>&, \n \t\t       const tuple<_UElements...>& __u,\n \t\t       const __index_holder<_UIdx...>&)\n-    { return tuple<_TElements..., _UElements...>(std::move(get<_TIdx>(__t))...,\n-\t\t\t\t\t\t get<_UIdx>(__u)...); }\n+    { return tuple<_TElements..., _UElements...>\n+\t(std::move(get<_TIdx>(__t))..., get<_UIdx>(__u)...); }\n \n   template<typename... _TElements, int... _TIdx,\n \t   typename... _UElements, int... _UIdx>\n@@ -565,8 +566,8 @@ namespace std\n \t\t       const __index_holder<_TIdx...>&, \n \t\t       tuple<_UElements...>&& __u,\n \t\t       const __index_holder<_UIdx...>&)\n-    { return tuple<_TElements..., _UElements...>(get<_TIdx>(__t)...,\n-\t\t\t\t\t\t std::move(get<_UIdx>(__u))...); }\n+    { return tuple<_TElements..., _UElements...>\n+\t(get<_TIdx>(__t)..., std::move(get<_UIdx>(__u))...); }\n \n   template<typename... _TElements, int... _TIdx,\n \t   typename... _UElements, int... _UIdx> \n@@ -575,8 +576,8 @@ namespace std\n \t\t       const __index_holder<_TIdx...>&, \n \t\t       tuple<_UElements...>&& __u,\n \t\t       const __index_holder<_UIdx...>&)\n-    { return tuple<_TElements..., _UElements...>(std::move(get<_TIdx>(__t))...,\n-\t\t\t\t\t\t std::move(get<_UIdx>(__u))...); }\n+    { return tuple<_TElements..., _UElements...>\n+\t(std::move(get<_TIdx>(__t))..., std::move(get<_UIdx>(__u))...); }\n \n   template<typename... _TElements, typename... _UElements>\n     inline tuple<_TElements..., _UElements...> \n@@ -618,12 +619,6 @@ namespace std\n \t\t\t\t__make_index_holder<_UElements...>::type());\n     }\n \n-  template<typename... _TElements, typename... _UElements>\n-    tuple<_TElements..., _UElements...>\n-    operator+(tuple<_TElements...>&& __t, tuple<_UElements...>&& __u)\n-    { return tuple_cat(std::forward<decltype(__t)>(__t),\n-\t\t       std::forward<decltype(__u)>(__u)); }\n-\n   template<typename... _Elements>\n     inline tuple<_Elements&...>\n     tie(_Elements&... __args)"}, {"sha": "ae7a4e2279dcf846ba753d22d2e5f9419e66e8c7", "filename": "libstdc++-v3/testsuite/20_util/tuple/moveable2.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b5e640fc4879308ab32927285677f2faabf2fb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fmoveable2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b5e640fc4879308ab32927285677f2faabf2fb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fmoveable2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fmoveable2.cc?ref=b5b5e640fc4879308ab32927285677f2faabf2fb", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <tuple>\n+#include <utility>\n+\n+struct MoveOnly\n+{\n+  MoveOnly () { }\n+  \n+  MoveOnly (MoveOnly&&) { }\n+\n+  MoveOnly& operator=(MoveOnly&&)\n+  { return *this; }\n+\n+private:\n+  MoveOnly(MoveOnly const&); // = delete\n+  MoveOnly& operator=(MoveOnly const&); // = delete\n+};\n+\n+MoveOnly\n+make_move_only ()\n+{ return MoveOnly(); }\n+\n+// http://gcc.gnu.org/ml/libstdc++/2008-02/msg00046.html\n+void test01()\n+{\n+  typedef std::tuple<MoveOnly> move_only_tuple;\n+\n+  move_only_tuple t1(make_move_only());\n+  move_only_tuple t2(std::move(t1));\n+  move_only_tuple t3 = std::move(t2);\n+  t1 = std::move(t3);\n+\n+  typedef std::tuple<MoveOnly, MoveOnly> move_only_tuple2;\n+\n+  move_only_tuple2 t4(make_move_only(), make_move_only());\n+  move_only_tuple2 t5(std::move(t4));\n+  move_only_tuple2 t6 = std::move(t5);\n+  t4 = std::move(t6);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}