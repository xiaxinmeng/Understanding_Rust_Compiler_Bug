{"sha": "7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20", "node_id": "C_kwDOANBUbNoAKDdiOTBmMDdmNzc4Y2FhNWUwOWYzZGMyMGE4YzNkYTFmNGNmNjBjMjA", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-07-07T20:46:29Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-07-07T20:46:29Z"}, "message": "c++: generic targs and identity substitution [PR105956]\n\nIn r13-1045-gcb7fd1ea85feea I assumed that substitution into generic\nDECL_TI_ARGS corresponds to an identity mapping of the given arguments,\nand hence its safe to always elide such substitution.  But this PR\ndemonstrates that such a substitution isn't always the identity mapping,\nin particular when there's an ARGUMENT_PACK_SELECT argument, which gets\nhandled specially during substitution:\n\n  * when substituting an APS into a template parameter, we strip the\n    APS to its underlying argument;\n  * and when substituting an APS into a pack expansion, we strip the\n    APS to its underlying argument pack.\n\nIn this testcase, when expanding the pack expansion pattern (idx + Ns)...\nwith Ns={0,1}, we specialize idx twice, first with Ns=APS<0,{0,1}> and\nthen Ns=APS<1,{0,1}>.  The DECL_TI_ARGS of idx are the generic template\narguments of the enclosing class template impl, so before r13-1045,\nwe'd substitute into its DECL_TI_ARGS which gave Ns={0,1} as desired.\nBut after r13-1045, we elide this substitution and end up attempting to\nhash the original Ns argument, an APS, which ICEs.\n\nSo this patch reverts that part of r13-1045.  I considered using\npreserve_args in this case instead, but that'd break the static_assert\nin the testcase because preserve_args always strips APS to its\nunderlying argument, but here we want to strip it to its underlying\nargument pack, so we'd incorrectly end up forming the specializations\nimpl<0>::idx and impl<1>::idx instead of impl<0,1>::idx.\n\nAlthough we can't elide the substitution into DECL_TI_ARGS in light of\nARGUMENT_PACK_SELECT, it should still be safe to elide template argument\ncoercion in the case of a non-template decl, which this patch preserves.\n\nIt's unfortunate that we need to remove this optimization just because\nit doesn't hold for one special tree code.  So this patch implements a\nheuristic in tsubst_template_args to avoid allocating a new TREE_VEC if\nthe substituted elements are identical to those of a level from ARGS, as\nwell as a similar heuristic for tsubst_argument_pack.  It turns out that\nabout 40% of all calls to tsubst_template_args benefit from this, and it\nreduces memory usage by about 4% for e.g. range-v3's zip.cpp (relative to\nr13-1045) which more than makes up for the reversion.\n\n\tPR c++/105956\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (template_arg_to_parm): Define.\n\t(tsubst_argument_pack): Try to reuse the corresponding\n\tARGUMENT_PACK from 'args' when substituting into a generic\n\tARGUMENT_PACK for a variadic template parameter.\n\t(tsubst_template_args): Move variable declarations closer to\n\ttheir first use.  Replace 'orig_t' with 'r'.  Rename 'need_new'\n\tto 'const_subst_p'.  Heuristically detect if the substituted\n\telements are identical to that of a level from 'args' and avoid\n\tallocating a new TREE_VEC if so.  Add sanity check for the\n\tlength of the new TREE_VEC, and remove dead ARGUMENT_PACK_P test.\n\t(tsubst_decl) <case TYPE_DECL, case VAR_DECL>: Revert\n\tr13-1045-gcb7fd1ea85feea change for avoiding substitution into\n\tDECL_TI_ARGS, but still avoid coercion in this case.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/variadic183.C: New test.", "tree": {"sha": "ce5b7e4e6e7f79679efeb04fbe90cda6a3963b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce5b7e4e6e7f79679efeb04fbe90cda6a3963b69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20/comments", "author": null, "committer": null, "parents": [{"sha": "52f538fa4a13d5d439f6db2c2657791fbddd934c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52f538fa4a13d5d439f6db2c2657791fbddd934c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52f538fa4a13d5d439f6db2c2657791fbddd934c"}], "stats": {"total": 216, "additions": 152, "deletions": 64}, "files": [{"sha": "59ee50c152d94baef2d9bb067c3e668bb3310ca5", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 138, "deletions": 64, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n      Fixed by: C++20 modules.  */\n \n #include \"config.h\"\n+#define INCLUDE_ALGORITHM // for std::equal\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"cp-tree.h\"\n@@ -4916,6 +4917,32 @@ template_parm_to_arg (tree t)\n   return t;\n }\n \n+/* If T looks like a generic template argument produced by template_parm_to_arg,\n+   return the corresponding template parameter, otherwise return NULL_TREE.  */\n+\n+static tree\n+template_arg_to_parm (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return NULL_TREE;\n+\n+  if (ARGUMENT_PACK_P (t))\n+    {\n+      tree args = ARGUMENT_PACK_ARGS (t);\n+      if (TREE_VEC_LENGTH (args) == 1\n+\t  && PACK_EXPANSION_P (TREE_VEC_ELT (args, 0)))\n+\tt = PACK_EXPANSION_PATTERN (TREE_VEC_ELT (args, 0));\n+    }\n+\n+  if (REFERENCE_REF_P (t))\n+    t = TREE_OPERAND (t, 0);\n+\n+  if (TEMPLATE_PARM_P (t))\n+    return t;\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Given a single level of template parameters (a TREE_VEC), return it\n    as a set of template arguments.  */\n \n@@ -13516,26 +13543,49 @@ tree\n tsubst_argument_pack (tree orig_arg, tree args, tsubst_flags_t complain,\n \t\t      tree in_decl)\n {\n+  /* This flag is used only during deduction, and we don't expect to\n+     substitute such ARGUMENT_PACKs.  */\n+  gcc_assert (!ARGUMENT_PACK_INCOMPLETE_P (orig_arg));\n+\n   /* Substitute into each of the arguments.  */\n   tree pack_args = tsubst_template_args (ARGUMENT_PACK_ARGS (orig_arg),\n \t\t\t\t\t args, complain, in_decl);\n-  tree new_arg = error_mark_node;\n-  if (pack_args != error_mark_node)\n-    {\n-      if (TYPE_P (orig_arg))\n-\t{\n-\t  new_arg = cxx_make_type (TREE_CODE (orig_arg));\n-\t  SET_TYPE_STRUCTURAL_EQUALITY (new_arg);\n-\t}\n-      else\n-\t{\n-\t  new_arg = make_node (TREE_CODE (orig_arg));\n-\t  TREE_CONSTANT (new_arg) = TREE_CONSTANT (orig_arg);\n-\t}\n+  if (pack_args == error_mark_node)\n+    return error_mark_node;\n \n-      ARGUMENT_PACK_ARGS (new_arg) = pack_args;\n+  if (pack_args == ARGUMENT_PACK_ARGS (orig_arg))\n+    return orig_arg;\n+\n+  /* If we're substituting into a generic ARGUMENT_PACK for a variadic\n+     template parameter, we might be able to avoid allocating a new\n+     ARGUMENT_PACK and reuse the corresponding ARGUMENT_PACK from ARGS\n+     if the substituted result is identical to it.  */\n+  if (tree parm = template_arg_to_parm (orig_arg))\n+    {\n+      int level, index;\n+      template_parm_level_and_index (parm, &level, &index);\n+      if (TMPL_ARGS_DEPTH (args) >= level)\n+\tif (tree arg = TMPL_ARG (args, level, index))\n+\t  if (TREE_CODE (arg) == TREE_CODE (orig_arg)\n+\t      && ARGUMENT_PACK_ARGS (arg) == pack_args)\n+\t    {\n+\t      gcc_assert (!ARGUMENT_PACK_INCOMPLETE_P (arg));\n+\t      return arg;\n+\t    }\n     }\n \n+  tree new_arg;\n+  if (TYPE_P (orig_arg))\n+    {\n+      new_arg = cxx_make_type (TREE_CODE (orig_arg));\n+      SET_TYPE_STRUCTURAL_EQUALITY (new_arg);\n+    }\n+  else\n+    {\n+      new_arg = make_node (TREE_CODE (orig_arg));\n+      TREE_CONSTANT (new_arg) = TREE_CONSTANT (orig_arg);\n+    }\n+  ARGUMENT_PACK_ARGS (new_arg) = pack_args;\n   return new_arg;\n }\n \n@@ -13544,17 +13594,17 @@ tsubst_argument_pack (tree orig_arg, tree args, tsubst_flags_t complain,\n tree\n tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n-  tree orig_t = t;\n-  int len, need_new = 0, i, expanded_len_adjust = 0, out;\n-  tree *elts;\n-\n   if (t == error_mark_node)\n     return error_mark_node;\n \n-  len = TREE_VEC_LENGTH (t);\n-  elts = XALLOCAVEC (tree, len);\n+  const int len = TREE_VEC_LENGTH (t);\n+  tree *elts = XALLOCAVEC (tree, len);\n+  int expanded_len_adjust = 0;\n \n-  for (i = 0; i < len; i++)\n+  /* True iff the substituted result is identical to T.  */\n+  bool const_subst_p = true;\n+\n+  for (int i = 0; i < len; i++)\n     {\n       tree orig_arg = TREE_VEC_ELT (t, i);\n       tree new_arg;\n@@ -13587,49 +13637,84 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n       elts[i] = new_arg;\n       if (new_arg != orig_arg)\n-\tneed_new = 1;\n+\tconst_subst_p = false;\n     }\n \n-  if (!need_new)\n+  if (const_subst_p)\n     return t;\n \n+  tree maybe_reuse = NULL_TREE;\n+\n+  /* If ARGS and T are both multi-level, the substituted result may be\n+     identical to ARGS.  */\n+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (t)\n+      && TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args)\n+      && TMPL_ARGS_DEPTH (t) == TMPL_ARGS_DEPTH (args))\n+    maybe_reuse = args;\n+  /* If T appears to be a vector of generic template arguments, the\n+     substituted result may be identical to the corresponding level\n+     from ARGS.  */\n+  else if (tree parm = template_arg_to_parm (TREE_VEC_ELT (t, 0)))\n+    {\n+      int level, index;\n+      template_parm_level_and_index (parm, &level, &index);\n+      if (index == 0 && TMPL_ARGS_DEPTH (args) >= level)\n+\tmaybe_reuse = TMPL_ARGS_LEVEL (args, level);\n+    }\n+\n+  /* If the substituted result is identical to MAYBE_REUSE, return\n+     it and avoid allocating a new TREE_VEC, as an optimization.  */\n+  if (maybe_reuse != NULL_TREE\n+      && TREE_VEC_LENGTH (maybe_reuse) == len\n+      && std::equal (elts, elts+len, TREE_VEC_BEGIN (maybe_reuse)))\n+    return maybe_reuse;\n+\n+  /* If T consists of only a pack expansion for which substitution yielded\n+     a TREE_VEC of the expanded elements, then reuse that TREE_VEC instead\n+     of effectively making a copy.  */\n+  if (len == 1\n+      && PACK_EXPANSION_P (TREE_VEC_ELT (t, 0))\n+      && TREE_CODE (elts[0]) == TREE_VEC)\n+    return elts[0];\n+\n   /* Make space for the expanded arguments coming from template\n      argument packs.  */\n-  t = make_tree_vec (len + expanded_len_adjust);\n-  /* ORIG_T can contain TREE_VECs. That happens if ORIG_T contains the\n+  tree r = make_tree_vec (len + expanded_len_adjust);\n+  /* T can contain TREE_VECs. That happens if T contains the\n      arguments for a member template.\n-     In that case each TREE_VEC in ORIG_T represents a level of template\n-     arguments, and ORIG_T won't carry any non defaulted argument count.\n+     In that case each TREE_VEC in T represents a level of template\n+     arguments, and T won't carry any non defaulted argument count.\n      It will rather be the nested TREE_VECs that will carry one.\n-     In other words, ORIG_T carries a non defaulted argument count only\n+     In other words, T carries a non defaulted argument count only\n      if it doesn't contain any nested TREE_VEC.  */\n-  if (NON_DEFAULT_TEMPLATE_ARGS_COUNT (orig_t))\n+  if (NON_DEFAULT_TEMPLATE_ARGS_COUNT (t))\n     {\n-      int count = GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (orig_t);\n+      int count = GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (t);\n       count += expanded_len_adjust;\n-      SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (t, count);\n+      SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (r, count);\n     }\n-  for (i = 0, out = 0; i < len; i++)\n+\n+  int out = 0;\n+  for (int i = 0; i < len; i++)\n     {\n-      tree orig_arg = TREE_VEC_ELT (orig_t, i);\n+      tree orig_arg = TREE_VEC_ELT (t, i);\n       if (orig_arg\n-\t  && (PACK_EXPANSION_P (orig_arg) || ARGUMENT_PACK_P (orig_arg))\n+\t  && PACK_EXPANSION_P (orig_arg)\n           && TREE_CODE (elts[i]) == TREE_VEC)\n         {\n-          int idx;\n-\n           /* Now expand the template argument pack \"in place\".  */\n-          for (idx = 0; idx < TREE_VEC_LENGTH (elts[i]); idx++, out++)\n-            TREE_VEC_ELT (t, out) = TREE_VEC_ELT (elts[i], idx);\n+\t  for (int idx = 0; idx < TREE_VEC_LENGTH (elts[i]); idx++, out++)\n+\t    TREE_VEC_ELT (r, out) = TREE_VEC_ELT (elts[i], idx);\n         }\n       else\n         {\n-          TREE_VEC_ELT (t, out) = elts[i];\n+\t  TREE_VEC_ELT (r, out) = elts[i];\n           out++;\n         }\n     }\n+  gcc_assert (out == TREE_VEC_LENGTH (r));\n \n-  return t;\n+  return r;\n }\n \n /* Substitute ARGS into one level PARMS of template parameters.  */\n@@ -14965,32 +15050,21 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n \t    if (!spec)\n \t      {\n-\t\tint args_depth = TMPL_ARGS_DEPTH (args);\n-\t\tint parms_depth = TMPL_ARGS_DEPTH (DECL_TI_ARGS (t));\n \t\ttmpl = DECL_TI_TEMPLATE (t);\n \t\tgen_tmpl = most_general_template (tmpl);\n-\t\tif (args_depth == parms_depth\n-\t\t    && !PRIMARY_TEMPLATE_P (gen_tmpl))\n-\t\t  /* The DECL_TI_ARGS in this case are the generic template\n-\t\t     arguments for the enclosing class template, so we can\n-\t\t     shortcut substitution (which would just be the identity\n-\t\t     mapping).  */\n-\t\t  argvec = args;\n-\t\telse\n-\t\t  {\n-\t\t    argvec = tsubst (DECL_TI_ARGS (t), args, complain, in_decl);\n-\t\t    /* Coerce the innermost arguments again if necessary.  If\n-\t\t       there's fewer levels of args than of parms, then the\n-\t\t       substitution could not have changed the innermost args\n-\t\t       (modulo level lowering).  */\n-\t\t    if (args_depth >= parms_depth && argvec != error_mark_node)\n-\t\t      argvec = (coerce_innermost_template_parms\n-\t\t\t\t(DECL_TEMPLATE_PARMS (gen_tmpl),\n-\t\t\t\t argvec, t, complain,\n-\t\t\t\t /*all*/true, /*defarg*/true));\n-\t\t    if (argvec == error_mark_node)\n-\t\t      RETURN (error_mark_node);\n-\t\t  }\n+\t\targvec = tsubst (DECL_TI_ARGS (t), args, complain, in_decl);\n+\t\tif (argvec != error_mark_node\n+\t\t    && PRIMARY_TEMPLATE_P (gen_tmpl)\n+\t\t    && TMPL_ARGS_DEPTH (args) >= TMPL_ARGS_DEPTH (argvec))\n+\t\t  /* We're fully specializing a template declaration, so\n+\t\t     we need to coerce the innermost arguments corresponding to\n+\t\t     the template.  */\n+\t\t  argvec = (coerce_innermost_template_parms\n+\t\t\t    (DECL_TEMPLATE_PARMS (gen_tmpl),\n+\t\t\t     argvec, t, complain,\n+\t\t\t     /*all*/true, /*defarg*/true));\n+\t\tif (argvec == error_mark_node)\n+\t\t  RETURN (error_mark_node);\n \t\thash = spec_hasher::hash (gen_tmpl, argvec);\n \t\tspec = retrieve_specialization (gen_tmpl, argvec, hash);\n \t      }"}, {"sha": "27444ebb59455648d64cf8db016308753c8557b7", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic183.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic183.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic183.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic183.C?ref=7b90f07f778caa5e09f3dc20a8c3da1f4cf60c20", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/105956\n+// { dg-do compile { target c++11 } }\n+\n+template<int...> struct list;\n+\n+template<int... Ns> struct impl {\n+  static const int idx = 0;\n+  using type = list<(idx + Ns)...>;\n+\n+  static constexpr const int* a[2] = {(Ns, &idx)...};\n+  static_assert(a[0] == &idx && a[1] == &idx, \"\");\n+};\n+\n+template struct impl<0, 1>;"}]}