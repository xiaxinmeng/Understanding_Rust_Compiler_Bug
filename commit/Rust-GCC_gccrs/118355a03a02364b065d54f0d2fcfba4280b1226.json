{"sha": "118355a03a02364b065d54f0d2fcfba4280b1226", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE4MzU1YTAzYTAyMzY0YjA2NWQ1NGYwZDJmY2ZiYTQyODBiMTIyNg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-10-07T07:25:32Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-07T07:25:32Z"}, "message": "expr.c (cmpstr_optab, [...]): New.\n\n\t* expr.c (cmpstr_optab, cmpmem_optab): New.\n\t* genopinit.c: Initialize them.\n\t* optabs.h: Declare them.\n\t* optabs.c (init_optabs): Clear them.\n\t(prepare_cmp_insn):  Use cmpstr_optab and cmpmem_optab to find\n\tblock memory compare insns, not conditional chains.  Restructure\n\tthe fallback generation of a call to memcmp/bcmp for better\n\treadability.\n\nFrom-SVN: r72185", "tree": {"sha": "d4a8b3ee4b8b88dd468603c0b19601f19c2ce133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4a8b3ee4b8b88dd468603c0b19601f19c2ce133"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/118355a03a02364b065d54f0d2fcfba4280b1226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118355a03a02364b065d54f0d2fcfba4280b1226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118355a03a02364b065d54f0d2fcfba4280b1226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118355a03a02364b065d54f0d2fcfba4280b1226/comments", "author": null, "committer": null, "parents": [{"sha": "d04a575f62b621e3df75c2cd7823a6613a2f1dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d04a575f62b621e3df75c2cd7823a6613a2f1dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d04a575f62b621e3df75c2cd7823a6613a2f1dc8"}], "stats": {"total": 165, "additions": 78, "deletions": 87}, "files": [{"sha": "411503e7b0fbc785b53a4421e8aae0a1f88618e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=118355a03a02364b065d54f0d2fcfba4280b1226", "patch": "@@ -1,3 +1,14 @@\n+2003-10-07  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* expr.c (cmpstr_optab, cmpmem_optab): New.\n+\t* genopinit.c: Initialize them.\n+\t* optabs.h: Declare them.\n+\t* optabs.c (init_optabs): Clear them.\n+\t(prepare_cmp_insn):  Use cmpstr_optab and cmpmem_optab to find\n+\tblock memory compare insns, not conditional chains.  Restructure\n+\tthe fallback generation of a call to memcmp/bcmp for better\n+\treadability.\n+\n 2003-10-07  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (MIPS_MAX_FIRST_STACK_STEP): New macro."}, {"sha": "9c912d0b60a02ed09011e1ef086b1d098b7381e9", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=118355a03a02364b065d54f0d2fcfba4280b1226", "patch": "@@ -235,6 +235,11 @@ enum insn_code movstr_optab[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block clears.  */\n enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n \n+/* These arrays record the insn_code of two different kinds of insns\n+   to perform block compares.  */\n+enum insn_code cmpstr_optab[NUM_MACHINE_MODES];\n+enum insn_code cmpmem_optab[NUM_MACHINE_MODES];\n+\n /* Stack of EXPR_WITH_FILE_LOCATION nested expressions.  */\n struct file_stack *expr_wfl_stack;\n "}, {"sha": "71fbbbf3621d81a552ce62389751747d5ca0ab8a", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=118355a03a02364b065d54f0d2fcfba4280b1226", "patch": "@@ -150,7 +150,9 @@ static const char * const optabs[] =\n   \"reload_in_optab[$A] = CODE_FOR_$(reload_in$a$)\",\n   \"reload_out_optab[$A] = CODE_FOR_$(reload_out$a$)\",\n   \"movstr_optab[$A] = CODE_FOR_$(movstr$a$)\",\n-  \"clrstr_optab[$A] = CODE_FOR_$(clrstr$a$)\" };\n+  \"clrstr_optab[$A] = CODE_FOR_$(clrstr$a$)\",\n+  \"cmpstr_optab[$A] = CODE_FOR_$(cmpstr$a$)\",\n+  \"cmpmem_optab[$A] = CODE_FOR_$(cmpmem$a$)\" };\n \n static void gen_insn (rtx);\n "}, {"sha": "3733d63799b9b9466f89743eade4febdfa3ed94b", "filename": "gcc/optabs.c", "status": "modified", "additions": 54, "deletions": 86, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=118355a03a02364b065d54f0d2fcfba4280b1226", "patch": "@@ -3571,105 +3571,71 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \n   if (mode == BLKmode)\n     {\n+      enum machine_mode cmp_mode, result_mode;\n+      enum insn_code cmp_code;\n+      tree length_type;\n+      rtx libfunc;\n       rtx result;\n-      enum machine_mode result_mode;\n-      rtx opalign ATTRIBUTE_UNUSED\n+      rtx opalign\n \t= GEN_INT (MIN (MEM_ALIGN (x), MEM_ALIGN (y)) / BITS_PER_UNIT);\n \n+      if (size == 0)\n+\tabort ();\n+\n       emit_queue ();\n       x = protect_from_queue (x, 0);\n       y = protect_from_queue (y, 0);\n+      size = protect_from_queue (size, 0);\n \n-      if (size == 0)\n-\tabort ();\n-#ifdef HAVE_cmpmemqi\n-      if (HAVE_cmpmemqi\n-\t  && GET_CODE (size) == CONST_INT\n-\t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (QImode)))\n-\t{\n-\t  result_mode = insn_data[(int) CODE_FOR_cmpmemqi].operand[0].mode;\n-\t  result = gen_reg_rtx (result_mode);\n-\t  emit_insn (gen_cmpmemqi (result, x, y, size, opalign));\n-\t}\n-      else\n-#endif\n-#ifdef HAVE_cmpmemhi\n-      if (HAVE_cmpmemhi\n-\t  && GET_CODE (size) == CONST_INT\n-\t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (HImode)))\n-\t{\n-\t  result_mode = insn_data[(int) CODE_FOR_cmpmemhi].operand[0].mode;\n-\t  result = gen_reg_rtx (result_mode);\n-\t  emit_insn (gen_cmpmemhi (result, x, y, size, opalign));\n-\t}\n-      else\n-#endif\n-#ifdef HAVE_cmpmemsi\n-      if (HAVE_cmpmemsi)\n+      /* Try to use a memory block compare insn - either cmpstr\n+\t or cmpmem will do.  */\n+      for (cmp_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   cmp_mode != VOIDmode;\n+\t   cmp_mode = GET_MODE_WIDER_MODE (cmp_mode))\n \t{\n-\t  result_mode = insn_data[(int) CODE_FOR_cmpmemsi].operand[0].mode;\n+\t  cmp_code = cmpmem_optab[cmp_mode];\n+\t  if (cmp_code == CODE_FOR_nothing)\n+\t    cmp_code = cmpstr_optab[cmp_mode];\n+\t  if (cmp_code == CODE_FOR_nothing)\n+\t    continue;\n+\n+\t  /* Must make sure the size fits the insn's mode.  */\n+\t  if ((GET_CODE (size) == CONST_INT\n+\t       && INTVAL (size) >= (1 << GET_MODE_BITSIZE (cmp_mode)))\n+\t      || (GET_MODE_BITSIZE (GET_MODE (size))\n+\t\t  > GET_MODE_BITSIZE (cmp_mode)))\n+\t    continue;\n+\n+\t  result_mode = insn_data[cmp_code].operand[0].mode;\n \t  result = gen_reg_rtx (result_mode);\n-\t  size = protect_from_queue (size, 0);\n-\t  emit_insn (gen_cmpmemsi (result, x, y,\n-\t\t\t\t   convert_to_mode (SImode, size, 1),\n-\t\t\t\t   opalign));\n-\t}\n-      else\n-#endif\n-#ifdef HAVE_cmpstrqi\n-      if (HAVE_cmpstrqi\n-\t  && GET_CODE (size) == CONST_INT\n-\t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (QImode)))\n-\t{\n-\t  result_mode = insn_data[(int) CODE_FOR_cmpstrqi].operand[0].mode;\n-\t  result = gen_reg_rtx (result_mode);\n-\t  emit_insn (gen_cmpstrqi (result, x, y, size, opalign));\n-\t}\n-      else\n-#endif\n-#ifdef HAVE_cmpstrhi\n-      if (HAVE_cmpstrhi\n-\t  && GET_CODE (size) == CONST_INT\n-\t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (HImode)))\n-\t{\n-\t  result_mode = insn_data[(int) CODE_FOR_cmpstrhi].operand[0].mode;\n-\t  result = gen_reg_rtx (result_mode);\n-\t  emit_insn (gen_cmpstrhi (result, x, y, size, opalign));\n-\t}\n-      else\n-#endif\n-#ifdef HAVE_cmpstrsi\n-      if (HAVE_cmpstrsi)\n-\t{\n-\t  result_mode = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n-\t  result = gen_reg_rtx (result_mode);\n-\t  size = protect_from_queue (size, 0);\n-\t  emit_insn (gen_cmpstrsi (result, x, y,\n-\t\t\t\t   convert_to_mode (SImode, size, 1),\n-\t\t\t\t   opalign));\n+\t  size = convert_to_mode (cmp_mode, size, 1);\n+\t  emit_insn (GEN_FCN (cmp_code) (result, x, y, size, opalign));\n+\n+\t  *px = result;\n+\t  *py = const0_rtx;\n+\t  *pmode = result_mode;\n+\t  return;\n \t}\n-      else\n-#endif\n-\t{\n+\n+      /* Otherwise call a library function, memcmp if we've got it,\n+\t bcmp otherwise.  */\n #ifdef TARGET_MEM_FUNCTIONS\n-\t  result = emit_library_call_value (memcmp_libfunc, NULL_RTX, LCT_PURE_MAKE_BLOCK,\n-\t\t\t\t\t    TYPE_MODE (integer_type_node), 3,\n-\t\t\t\t\t    XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n-\t\t\t\t\t    convert_to_mode (TYPE_MODE (sizetype), size,\n-\t\t\t\t\t\t\t     TREE_UNSIGNED (sizetype)),\n-\t\t\t\t\t    TYPE_MODE (sizetype));\n+      libfunc = memcmp_libfunc;\n+      length_type = sizetype;\n #else\n-\t  result = emit_library_call_value (bcmp_libfunc, NULL_RTX, LCT_PURE_MAKE_BLOCK,\n-\t\t\t\t\t    TYPE_MODE (integer_type_node), 3,\n-\t\t\t\t\t    XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n-\t\t\t\t\t    convert_to_mode (TYPE_MODE (integer_type_node),\n-\t\t\t\t\t\t\t     size,\n-\t\t\t\t\t\t\t     TREE_UNSIGNED (integer_type_node)),\n-\t\t\t\t\t    TYPE_MODE (integer_type_node));\n+      libfunc = bcmp_libfunc;\n+      length_type = integer_type_node;\n #endif\n-\n-\t  result_mode = TYPE_MODE (integer_type_node);\n-\t}\n+      result_mode = TYPE_MODE (integer_type_node);\n+      cmp_mode = TYPE_MODE (length_type);\n+      size = convert_to_mode (TYPE_MODE (length_type), size,\n+\t\t\t      TREE_UNSIGNED (length_type));\n+\n+      result = emit_library_call_value (libfunc, 0, LCT_PURE_MAKE_BLOCK,\n+\t\t\t\t\tresult_mode, 3,\n+\t\t\t\t\tXEXP (x, 0), Pmode,\n+\t\t\t\t\tXEXP (y, 0), Pmode,\n+\t\t\t\t\tsize, cmp_mode);\n       *px = result;\n       *py = const0_rtx;\n       *pmode = result_mode;\n@@ -5330,6 +5296,8 @@ init_optabs (void)\n     {\n       movstr_optab[i] = CODE_FOR_nothing;\n       clrstr_optab[i] = CODE_FOR_nothing;\n+      cmpstr_optab[i] = CODE_FOR_nothing;\n+      cmpmem_optab[i] = CODE_FOR_nothing;\n \n #ifdef HAVE_SECONDARY_RELOADS\n       reload_in_optab[i] = reload_out_optab[i] = CODE_FOR_nothing;"}, {"sha": "20d5df60cd426efd7804a214248fb6e1319ff69c", "filename": "gcc/optabs.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118355a03a02364b065d54f0d2fcfba4280b1226/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=118355a03a02364b065d54f0d2fcfba4280b1226", "patch": "@@ -348,6 +348,11 @@ extern enum insn_code movstr_optab[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block clears.  */\n extern enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n \n+/* These arrays record the insn_code of two different kinds of insns\n+   to perform block compares.  */\n+extern enum insn_code cmpstr_optab[NUM_MACHINE_MODES];\n+extern enum insn_code cmpmem_optab[NUM_MACHINE_MODES];\n+\n /* Define functions given in optabs.c.  */\n \n /* Expand a binary operation given optab and rtx operands.  */"}]}