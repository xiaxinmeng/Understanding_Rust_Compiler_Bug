{"sha": "ec77b14454cfb80c70a0b17b7ced31c8956af30b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM3N2IxNDQ1NGNmYjgwYzcwYTBiMTdiN2NlZDMxYzg5NTZhZjMwYg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-02-24T16:32:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T16:32:04Z"}, "message": "sem_prag.adb (Analyze_Global_Item): Move the check concerning the use of volatile objects as global items in a...\n\n2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Global_Item): Move the check concerning\n\tthe use of volatile objects as global items in a function to\n\tthe variable related checks section.\n\t* sem_util.adb (Async_Readers_Enabled): Directly call\n\tHas_Enabled_Property.\n\t(Async_Writers_Enabled): Directly call Has_Enabled_Property.\n\t(Effective_Reads_Enabled): Directly call Has_Enabled_Property.\n\t(Effective_Writes_Enabled): Directly call Has_Enabled_Property.\n\t(Has_Enabled_Property): Rename formal parameter State_Id to Item_Id.\n\tUpdate the comment on usage. State_Has_Enabled_Property how handles\n\tthe original logic of the routine. Add processing for variables.\n\t(State_Has_Enabled_Property): New routine.\n\t(Variable_Has_Enabled_Property): New routine.\n\nFrom-SVN: r208077", "tree": {"sha": "939fc74fa146ce33b7c21e0acfb828e61c831b1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/939fc74fa146ce33b7c21e0acfb828e61c831b1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec77b14454cfb80c70a0b17b7ced31c8956af30b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec77b14454cfb80c70a0b17b7ced31c8956af30b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec77b14454cfb80c70a0b17b7ced31c8956af30b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec77b14454cfb80c70a0b17b7ced31c8956af30b/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32bba3c9d848935dbec4b070093574a34b0817a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32bba3c9d848935dbec4b070093574a34b0817a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32bba3c9d848935dbec4b070093574a34b0817a4"}], "stats": {"total": 281, "additions": 180, "deletions": 101}, "files": [{"sha": "97636e9a7f5bcc74a4b104d90dd980a854fb1d70", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77b14454cfb80c70a0b17b7ced31c8956af30b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77b14454cfb80c70a0b17b7ced31c8956af30b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ec77b14454cfb80c70a0b17b7ced31c8956af30b", "patch": "@@ -1,3 +1,19 @@\n+2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Global_Item): Move the check concerning\n+\tthe use of volatile objects as global items in a function to\n+\tthe variable related checks section.\n+\t* sem_util.adb (Async_Readers_Enabled): Directly call\n+\tHas_Enabled_Property.\n+\t(Async_Writers_Enabled): Directly call Has_Enabled_Property.\n+\t(Effective_Reads_Enabled): Directly call Has_Enabled_Property.\n+\t(Effective_Writes_Enabled): Directly call Has_Enabled_Property.\n+\t(Has_Enabled_Property): Rename formal parameter State_Id to Item_Id.\n+\tUpdate the comment on usage. State_Has_Enabled_Property how handles\n+\tthe original logic of the routine. Add processing for variables.\n+\t(State_Has_Enabled_Property): New routine.\n+\t(Variable_Has_Enabled_Property): New routine.\n+\n 2014-02-24  Robert Dewar  <dewar@adacore.com>\n \n \t* sinfo.ads, sem_ch12.adb, sem_res.adb, sem_ch4.adb, par-ch12.adb:"}, {"sha": "ba462275685128b4531e6309507ed141f50e1acd", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77b14454cfb80c70a0b17b7ced31c8956af30b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77b14454cfb80c70a0b17b7ced31c8956af30b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ec77b14454cfb80c70a0b17b7ced31c8956af30b", "patch": "@@ -2060,16 +2060,28 @@ package body Sem_Prag is\n \n                --  Variable related checks\n \n-               else\n+               elsif Is_SPARK_Volatile_Object (Item_Id) then\n+\n+                  --  A volatile object cannot appear as a global item of a\n+                  --  function. This check is only relevant when SPARK_Mode is\n+                  --  on as it is not a standard Ada legality rule.\n+\n+                  if SPARK_Mode = On\n+                    and then Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n+                  then\n+                     Error_Msg_NE\n+                       (\"volatile object & cannot act as global item of a \"\n+                        & \"function (SPARK RM 7.1.3(9))\", Item, Item_Id);\n+                     return;\n+\n                   --  A volatile object with property Effective_Reads set to\n                   --  True must have mode Output or In_Out.\n \n-                  if Is_SPARK_Volatile_Object (Item_Id)\n-                    and then Effective_Reads_Enabled (Item_Id)\n+                  elsif Effective_Reads_Enabled (Item_Id)\n                     and then Global_Mode = Name_Input\n                   then\n                      Error_Msg_NE\n-                       (\"volatile item & with property Effective_Reads must \"\n+                       (\"volatile object & with property Effective_Reads must \"\n                         & \"have mode In_Out or Output (SPARK RM 7.1.3(11))\",\n                         Item, Item_Id);\n                      return;\n@@ -2100,19 +2112,6 @@ package body Sem_Prag is\n                Check_Mode_Restriction_In_Enclosing_Context (Item, Item_Id);\n             end if;\n \n-            --  A volatile object cannot appear as a global item of a function.\n-            --  This check is only relevant when SPARK_Mode is on as it is not\n-            --  a standard Ada legality rule.\n-\n-            if SPARK_Mode = On\n-              and then Is_SPARK_Volatile_Object (Item)\n-              and then Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n-            then\n-               Error_Msg_NE\n-                 (\"volatile object & cannot act as global item of a function \"\n-                  & \"(SPARK RM 7.1.3(9))\", Item, Item_Id);\n-            end if;\n-\n             --  The same entity might be referenced through various way. Check\n             --  the entity of the item rather than the item itself.\n "}, {"sha": "3f872161fdff785701956cffbc389434a8a23467", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 148, "deletions": 84, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77b14454cfb80c70a0b17b7ced31c8956af30b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77b14454cfb80c70a0b17b7ced31c8956af30b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ec77b14454cfb80c70a0b17b7ced31c8956af30b", "patch": "@@ -116,11 +116,11 @@ package body Sem_Util is\n    --  have a default.\n \n    function Has_Enabled_Property\n-     (State_Id : Node_Id;\n+     (Item_Id  : Entity_Id;\n       Property : Name_Id) return Boolean;\n    --  Subsidiary to routines Async_xxx_Enabled and Effective_xxx_Enabled.\n-   --  Determine whether an abstract state denoted by its entity State_Id has\n-   --  enabled property Property.\n+   --  Determine whether an abstract state or a variable denoted by entity\n+   --  Item_Id has enabled property Property.\n \n    function Has_Null_Extension (T : Entity_Id) return Boolean;\n    --  T is a derived tagged type. Check whether the type extension is null.\n@@ -575,12 +575,7 @@ package body Sem_Util is\n \n    function Async_Readers_Enabled (Id : Entity_Id) return Boolean is\n    begin\n-      if Ekind (Id) = E_Abstract_State then\n-         return Has_Enabled_Property (Id, Name_Async_Readers);\n-\n-      else pragma Assert (Ekind (Id) = E_Variable);\n-         return Present (Get_Pragma (Id, Pragma_Async_Readers));\n-      end if;\n+      return Has_Enabled_Property (Id, Name_Async_Readers);\n    end Async_Readers_Enabled;\n \n    ---------------------------\n@@ -589,12 +584,7 @@ package body Sem_Util is\n \n    function Async_Writers_Enabled (Id : Entity_Id) return Boolean is\n    begin\n-      if Ekind (Id) = E_Abstract_State then\n-         return Has_Enabled_Property (Id, Name_Async_Writers);\n-\n-      else pragma Assert (Ekind (Id) = E_Variable);\n-         return Present (Get_Pragma (Id, Pragma_Async_Writers));\n-      end if;\n+      return Has_Enabled_Property (Id, Name_Async_Writers);\n    end Async_Writers_Enabled;\n \n    --------------------------------------\n@@ -4737,12 +4727,7 @@ package body Sem_Util is\n \n    function Effective_Reads_Enabled (Id : Entity_Id) return Boolean is\n    begin\n-      if Ekind (Id) = E_Abstract_State then\n-         return Has_Enabled_Property (Id, Name_Effective_Reads);\n-\n-      else pragma Assert (Ekind (Id) = E_Variable);\n-         return Present (Get_Pragma (Id, Pragma_Effective_Reads));\n-      end if;\n+      return Has_Enabled_Property (Id, Name_Effective_Reads);\n    end Effective_Reads_Enabled;\n \n    ------------------------------\n@@ -4751,12 +4736,7 @@ package body Sem_Util is\n \n    function Effective_Writes_Enabled (Id : Entity_Id) return Boolean is\n    begin\n-      if Ekind (Id) = E_Abstract_State then\n-         return Has_Enabled_Property (Id, Name_Effective_Writes);\n-\n-      else pragma Assert (Ekind (Id) = E_Variable);\n-         return Present (Get_Pragma (Id, Pragma_Effective_Writes));\n-      end if;\n+      return Has_Enabled_Property (Id, Name_Effective_Writes);\n    end Effective_Writes_Enabled;\n \n    ------------------------------\n@@ -7292,89 +7272,173 @@ package body Sem_Util is\n    --------------------------\n \n    function Has_Enabled_Property\n-     (State_Id : Node_Id;\n+     (Item_Id  : Entity_Id;\n       Property : Name_Id) return Boolean\n    is\n-      Decl     : constant Node_Id := Parent (State_Id);\n-      Opt      : Node_Id;\n-      Opt_Nam  : Node_Id;\n-      Prop     : Node_Id;\n-      Prop_Nam : Node_Id;\n-      Props    : Node_Id;\n+      function State_Has_Enabled_Property return Boolean;\n+      --  Determine whether a state denoted by Item_Id has the property\n \n-   begin\n-      --  The declaration of an external abstract state appears as an extension\n-      --  aggregate. If this is not the case, properties can never be set.\n+      function Variable_Has_Enabled_Property return Boolean;\n+      --  Determine whether a variable denoted by Item_Id has the property\n \n-      if Nkind (Decl) /= N_Extension_Aggregate then\n-         return False;\n-      end if;\n+      --------------------------------\n+      -- State_Has_Enabled_Property --\n+      --------------------------------\n \n-      --  When External appears as a simple option, it automatically enables\n-      --  all properties.\n+      function State_Has_Enabled_Property return Boolean is\n+         Decl     : constant Node_Id := Parent (Item_Id);\n+         Opt      : Node_Id;\n+         Opt_Nam  : Node_Id;\n+         Prop     : Node_Id;\n+         Prop_Nam : Node_Id;\n+         Props    : Node_Id;\n \n-      Opt := First (Expressions (Decl));\n-      while Present (Opt) loop\n-         if Nkind (Opt) = N_Identifier\n-           and then Chars (Opt) = Name_External\n-         then\n-            return True;\n+      begin\n+         --  The declaration of an external abstract state appears as an\n+         --  extension aggregate. If this is not the case, properties can never\n+         --  be set.\n+\n+         if Nkind (Decl) /= N_Extension_Aggregate then\n+            return False;\n          end if;\n \n-         Next (Opt);\n-      end loop;\n+         --  When External appears as a simple option, it automatically enables\n+         --  all properties.\n+\n+         Opt := First (Expressions (Decl));\n+         while Present (Opt) loop\n+            if Nkind (Opt) = N_Identifier\n+              and then Chars (Opt) = Name_External\n+            then\n+               return True;\n+            end if;\n \n-      --  When External specifies particular properties, inspect those and\n-      --  find the desired one (if any).\n+            Next (Opt);\n+         end loop;\n \n-      Opt := First (Component_Associations (Decl));\n-      while Present (Opt) loop\n-         Opt_Nam := First (Choices (Opt));\n+         --  When External specifies particular properties, inspect those and\n+         --  find the desired one (if any).\n \n-         if Nkind (Opt_Nam) = N_Identifier\n-           and then Chars (Opt_Nam) = Name_External\n-         then\n-            Props := Expression (Opt);\n+         Opt := First (Component_Associations (Decl));\n+         while Present (Opt) loop\n+            Opt_Nam := First (Choices (Opt));\n \n-            --  Multiple properties appear as an aggregate\n+            if Nkind (Opt_Nam) = N_Identifier\n+              and then Chars (Opt_Nam) = Name_External\n+            then\n+               Props := Expression (Opt);\n \n-            if Nkind (Props) = N_Aggregate then\n+               --  Multiple properties appear as an aggregate\n \n-               --  Simple property form\n+               if Nkind (Props) = N_Aggregate then\n \n-               Prop := First (Expressions (Props));\n-               while Present (Prop) loop\n-                  if Chars (Prop) = Property then\n-                     return True;\n-                  end if;\n+                  --  Simple property form\n \n-                  Next (Prop);\n-               end loop;\n+                  Prop := First (Expressions (Props));\n+                  while Present (Prop) loop\n+                     if Chars (Prop) = Property then\n+                        return True;\n+                     end if;\n \n-               --  Property with expression form\n+                     Next (Prop);\n+                  end loop;\n \n-               Prop := First (Component_Associations (Props));\n-               while Present (Prop) loop\n-                  Prop_Nam := First (Choices (Prop));\n+                  --  Property with expression form\n \n-                  if Chars (Prop_Nam) = Property then\n-                     return Is_True (Expr_Value (Expression (Prop)));\n-                  end if;\n+                  Prop := First (Component_Associations (Props));\n+                  while Present (Prop) loop\n+                     Prop_Nam := First (Choices (Prop));\n \n-                  Next (Prop);\n-               end loop;\n+                     if Chars (Prop_Nam) = Property then\n+                        return Is_True (Expr_Value (Expression (Prop)));\n+                     end if;\n \n-            --  Single property\n+                     Next (Prop);\n+                  end loop;\n \n-            else\n-               return Chars (Props) = Property;\n+               --  Single property\n+\n+               else\n+                  return Chars (Props) = Property;\n+               end if;\n             end if;\n+\n+            Next (Opt);\n+         end loop;\n+\n+         return False;\n+      end State_Has_Enabled_Property;\n+\n+      -----------------------------------\n+      -- Variable_Has_Enabled_Property --\n+      -----------------------------------\n+\n+      function Variable_Has_Enabled_Property return Boolean is\n+         AR : constant Node_Id :=\n+                Get_Pragma (Item_Id, Pragma_Async_Readers);\n+         AW : constant Node_Id :=\n+                Get_Pragma (Item_Id, Pragma_Async_Writers);\n+         ER : constant Node_Id :=\n+                Get_Pragma (Item_Id, Pragma_Effective_Reads);\n+         EW : constant Node_Id :=\n+                Get_Pragma (Item_Id, Pragma_Effective_Writes);\n+      begin\n+         --  A non-volatile object can never possess external properties\n+\n+         if not Is_SPARK_Volatile_Object (Item_Id) then\n+            return False;\n+\n+         --  External properties related to variables come in two flavors -\n+         --  explicit and implicit. The explicit case is characterized by the\n+         --  presence of a property pragma while the implicit case lacks all\n+         --  such pragmas.\n+\n+         elsif Property = Name_Async_Readers\n+           and then\n+             (Present (AR)\n+                or else\n+             (No (AW) and then No (ER) and then No (EW)))\n+         then\n+            return True;\n+\n+         elsif Property = Name_Async_Writers\n+           and then\n+             (Present (AW)\n+                or else\n+             (No (AR) and then No (ER) and then No (EW)))\n+         then\n+            return True;\n+\n+         elsif Property = Name_Effective_Reads\n+           and then\n+             (Present (ER)\n+                or else\n+             (No (AR) and then No (AW) and then No (EW)))\n+         then\n+            return True;\n+\n+         elsif Property = Name_Effective_Writes\n+           and then\n+             (Present (EW)\n+                or else\n+             (No (AR) and then No (AW) and then No (ER)))\n+         then\n+            return True;\n+\n+         else\n+            return False;\n          end if;\n+      end Variable_Has_Enabled_Property;\n \n-         Next (Opt);\n-      end loop;\n+   --  Start of processing for Has_Enabled_Property\n \n-      return False;\n+   begin\n+      if Ekind (Item_Id) = E_Abstract_State then\n+         return State_Has_Enabled_Property;\n+\n+      else pragma Assert (Ekind (Item_Id) = E_Variable);\n+         return Variable_Has_Enabled_Property;\n+      end if;\n    end Has_Enabled_Property;\n \n    --------------------"}]}