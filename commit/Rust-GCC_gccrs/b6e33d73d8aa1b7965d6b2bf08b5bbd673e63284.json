{"sha": "b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZlMzNkNzNkOGFhMWI3OTY1ZDZiMmJmMDhiNWJiZDY3M2U2MzI4NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-04-30T14:40:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-04-30T14:40:10Z"}, "message": "lto-wrapper.c (ltrans_priorities): New static var.\n\n\n\t* lto-wrapper.c (ltrans_priorities): New static var.\n\t(cmp_priority): New.\n\t(run_gcc): Read priorities and if doing parallel build order\n\tthe Makefile by them.\n\n\t* lto.c (cmp_partitions_size): Remove.\n\t(lto_wpa_write_files): Also output priorities; do not sort partitions.\n\t(cmp_partition_order): Move to ...\n\t* lto-partition.c (cmp_partition_order): ...\n\t(lto_1_to_1_map): Sort partitions.\n\nFrom-SVN: r259767", "tree": {"sha": "c0fe97d393dbf048a5c52b48b8a109e50d80dc35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0fe97d393dbf048a5c52b48b8a109e50d80dc35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/comments", "author": null, "committer": null, "parents": [{"sha": "fee69672c29005d68d5cddff587c535b6a8c4982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee69672c29005d68d5cddff587c535b6a8c4982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee69672c29005d68d5cddff587c535b6a8c4982"}], "stats": {"total": 113, "additions": 68, "deletions": 45}, "files": [{"sha": "a3ea6420dfad768aa5181ae5014fdbc2f312a574", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "patch": "@@ -1,3 +1,10 @@\n+2018-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-wrapper.c (ltrans_priorities): New static var.\n+\t(cmp_priority): New.\n+\t(run_gcc): Read priorities and if doing parallel build order\n+\tthe Makefile by them.\n+\n 2018-04-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* input.h (builtins_location_check): Convert to a STATIC_ASSERT."}, {"sha": "a61d5dd2e44a7ac6d6920326d4e7427b3b1336d6", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "patch": "@@ -65,6 +65,7 @@ static enum lto_mode_d lto_mode = LTO_MODE_NONE;\n static char *ltrans_output_file;\n static char *flto_out;\n static unsigned int nr;\n+static int *ltrans_priorities;\n static char **input_names;\n static char **output_names;\n static char **offload_names;\n@@ -1018,6 +1019,13 @@ debug_objcopy (const char *infile)\n   return outfile;\n }\n \n+/* Helper for qsort: compare priorities for parallel compilation.  */\n+\n+int\n+cmp_priority (const void *a, const void *b)\n+{\n+  return *((const int *)b)-*((const int *)a);\n+}\n \n \n /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n@@ -1477,6 +1485,7 @@ run_gcc (unsigned argc, char *argv[])\n       FILE *stream = fopen (ltrans_output_file, \"r\");\n       FILE *mstream = NULL;\n       struct obstack env_obstack;\n+      int priority;\n \n       if (!stream)\n \tfatal_error (input_location, \"fopen: %s: %m\", ltrans_output_file);\n@@ -1492,6 +1501,14 @@ run_gcc (unsigned argc, char *argv[])\n \t  size_t len;\n \n \t  buf = input_name;\n+          if (fscanf (stream, \"%i\\n\", &priority) != 1)\n+\t    {\n+\t      if (!feof (stream))\n+\t        fatal_error (input_location,\n+\t\t             \"Corrupted ltrans output file %s\",\n+\t\t\t     ltrans_output_file);\n+\t      break;\n+\t    }\n cont:\n \t  if (!fgets (buf, piece, stream))\n \t    break;\n@@ -1508,8 +1525,12 @@ run_gcc (unsigned argc, char *argv[])\n \t    output_name = &input_name[1];\n \n \t  nr++;\n+\t  ltrans_priorities\n+\t     = (int *)xrealloc (ltrans_priorities, nr * sizeof (int) * 2);\n \t  input_names = (char **)xrealloc (input_names, nr * sizeof (char *));\n \t  output_names = (char **)xrealloc (output_names, nr * sizeof (char *));\n+\t  ltrans_priorities[(nr-1)*2] = priority;\n+\t  ltrans_priorities[(nr-1)*2+1] = nr-1;\n \t  input_names[nr-1] = input_name;\n \t  output_names[nr-1] = output_name;\n \t}\n@@ -1521,6 +1542,7 @@ run_gcc (unsigned argc, char *argv[])\n \t{\n \t  makefile = make_temp_file (\".mk\");\n \t  mstream = fopen (makefile, \"w\");\n+\t  qsort (ltrans_priorities, nr, sizeof (int) * 2, cmp_priority);\n \t}\n \n       /* Execute the LTRANS stage for each input file (or prepare a\n@@ -1586,7 +1608,10 @@ run_gcc (unsigned argc, char *argv[])\n \n \t  fprintf (mstream, \"all:\");\n \t  for (i = 0; i < nr; ++i)\n-\t    fprintf (mstream, \" \\\\\\n\\t%s\", output_names[i]);\n+\t    {\n+\t      int j = ltrans_priorities[i*2 + 1];\n+\t      fprintf (mstream, \" \\\\\\n\\t%s\", output_names[j]);\n+\t    }\n \t  fprintf (mstream, \"\\n\");\n \t  fclose (mstream);\n \t  if (!jobserver)\n@@ -1630,6 +1655,7 @@ run_gcc (unsigned argc, char *argv[])\n \t  free (input_names[i]);\n \t}\n       nr = 0;\n+      free (ltrans_priorities);\n       free (output_names);\n       free (input_names);\n       free (list_option_full);"}, {"sha": "77e5915b1632f3e28dda1fc1fe4247c074089901", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "patch": "@@ -1,3 +1,11 @@\n+2018-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (cmp_partitions_size): Remove.\n+\t(lto_wpa_write_files): Also output priorities; do not sort partitions.\n+\t(cmp_partition_order): Move to ...\n+\t* lto-partition.c (cmp_partition_order): ...\n+\t(lto_1_to_1_map): Sort partitions.\n+\n 2018-04-20  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (lto_balanced_map): Fix sanity check."}, {"sha": "637e5e24b980e4f0ac434e6517982b39f32a56aa", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "patch": "@@ -42,6 +42,24 @@ vec<ltrans_partition> ltrans_partitions;\n static void add_symbol_to_partition (ltrans_partition part, symtab_node *node);\n \n \n+/* Helper for qsort; compare partitions and return one with smaller order.  */\n+\n+static int\n+cmp_partitions_order (const void *a, const void *b)\n+{\n+  const struct ltrans_partition_def *pa\n+     = *(struct ltrans_partition_def *const *)a;\n+  const struct ltrans_partition_def *pb\n+     = *(struct ltrans_partition_def *const *)b;\n+  int ordera = -1, orderb = -1;\n+\n+  if (lto_symtab_encoder_size (pa->encoder))\n+    ordera = lto_symtab_encoder_deref (pa->encoder, 0)->order;\n+  if (lto_symtab_encoder_size (pb->encoder))\n+    orderb = lto_symtab_encoder_deref (pb->encoder, 0)->order;\n+  return orderb - ordera;\n+}\n+\n /* Create new partition with name NAME.  */\n \n static ltrans_partition\n@@ -334,6 +352,9 @@ lto_1_to_1_map (void)\n   if (!npartitions)\n     new_partition (\"empty\");\n \n+  /* Order partitions by order of symbols because they are linked into binary\n+     that way.  */\n+  ltrans_partitions.qsort (cmp_partitions_order);\n }\n \n /* Maximal partitioning.  Put every new symbol into new partition if possible.  */"}, {"sha": "d2ccaf676893785a60c31c58f13163d2e1b9c1ca", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 44, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "patch": "@@ -2327,38 +2327,6 @@ free_section_data (struct lto_file_decl_data *file_data ATTRIBUTE_UNUSED,\n \n static lto_file *current_lto_file;\n \n-/* Helper for qsort; compare partitions and return one with smaller size.\n-   We sort from greatest to smallest so parallel build doesn't stale on the\n-   longest compilation being executed too late.  */\n-\n-static int\n-cmp_partitions_size (const void *a, const void *b)\n-{\n-  const struct ltrans_partition_def *pa\n-     = *(struct ltrans_partition_def *const *)a;\n-  const struct ltrans_partition_def *pb\n-     = *(struct ltrans_partition_def *const *)b;\n-  return pb->insns - pa->insns;\n-}\n-\n-/* Helper for qsort; compare partitions and return one with smaller order.  */\n-\n-static int\n-cmp_partitions_order (const void *a, const void *b)\n-{\n-  const struct ltrans_partition_def *pa\n-     = *(struct ltrans_partition_def *const *)a;\n-  const struct ltrans_partition_def *pb\n-     = *(struct ltrans_partition_def *const *)b;\n-  int ordera = -1, orderb = -1;\n-\n-  if (lto_symtab_encoder_size (pa->encoder))\n-    ordera = lto_symtab_encoder_deref (pa->encoder, 0)->order;\n-  if (lto_symtab_encoder_size (pb->encoder))\n-    orderb = lto_symtab_encoder_deref (pb->encoder, 0)->order;\n-  return orderb - ordera;\n-}\n-\n /* Actually stream out ENCODER into TEMP_FILENAME.  */\n \n static void\n@@ -2468,7 +2436,8 @@ lto_wpa_write_files (void)\n   ltrans_partition part;\n   FILE *ltrans_output_list_stream;\n   char *temp_filename;\n-  vec <char *>temp_filenames = vNULL;\n+  auto_vec <char *>temp_filenames;\n+  auto_vec <int>temp_priority;\n   size_t blen;\n \n   /* Open the LTRANS output list.  */\n@@ -2496,15 +2465,6 @@ lto_wpa_write_files (void)\n \n   n_sets = ltrans_partitions.length ();\n \n-  /* Sort partitions by size so small ones are compiled last.\n-     FIXME: Even when not reordering we may want to output one list for parallel make\n-     and other for final link command.  */\n-\n-  if (!flag_profile_reorder_functions || !flag_profile_use)\n-    ltrans_partitions.qsort (flag_toplevel_reorder\n-\t\t\t   ? cmp_partitions_size\n-\t\t\t   : cmp_partitions_order);\n-\n   for (i = 0; i < n_sets; i++)\n     {\n       ltrans_partition part = ltrans_partitions[i];\n@@ -2556,6 +2516,7 @@ lto_wpa_write_files (void)\n \n       part->encoder = NULL;\n \n+      temp_priority.safe_push (part->insns);\n       temp_filenames.safe_push (xstrdup (temp_filename));\n     }\n   ltrans_output_list_stream = fopen (ltrans_output_list, \"w\");\n@@ -2565,13 +2526,13 @@ lto_wpa_write_files (void)\n   for (i = 0; i < n_sets; i++)\n     {\n       unsigned int len = strlen (temp_filenames[i]);\n-      if (fwrite (temp_filenames[i], 1, len, ltrans_output_list_stream) < len\n+      if (fprintf (ltrans_output_list_stream, \"%i\\n\", temp_priority[i]) < 0\n+\t  || fwrite (temp_filenames[i], 1, len, ltrans_output_list_stream) < len\n \t  || fwrite (\"\\n\", 1, 1, ltrans_output_list_stream) < 1)\n \tfatal_error (input_location, \"writing to LTRANS output list %s: %m\",\n \t\t     ltrans_output_list);\n      free (temp_filenames[i]);\n     }\n-  temp_filenames.release();\n \n   lto_stats.num_output_files += n_sets;\n "}]}