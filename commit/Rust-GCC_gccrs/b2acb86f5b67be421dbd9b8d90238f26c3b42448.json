{"sha": "b2acb86f5b67be421dbd9b8d90238f26c3b42448", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJhY2I4NmY1YjY3YmU0MjFkYmQ5YjhkOTAyMzhmMjZjM2I0MjQ0OA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-06-06T15:50:28Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-06-06T15:50:28Z"}, "message": "stl_alloc.h: Cleanups.\n\n\n\n2003-06-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/stl_alloc.h: Cleanups.\n\t* include/ext/functional: Same.\n\t* include/ext/hash_map: Same.\n\t* include/ext/hash_set: Same.\n\t* include/ext/iterator: Same.\n\t* include/ext/memory: Same.\n\t* include/ext/numeric: Same.\n\t* include/ext/rb_tree: Same.\n\t* include/ext/ropeimpl.h: Same.\n\t* include/ext/slist: Same.\n\t* include/ext/stdio_filebuf.h: Same.\n\t* include/ext/stdio_sync_filebuf.h: Same.\n\t* include/ext/stl_rope.h: Move to...\n\t* include/ext/rope: ...here.\n\t* include/ext/stl_hash_fun.h: Move to...\n\t* include/ext/hash_fun.h: ...here.\n\t* include/ext/stl_hashtable.h: Move to...\n\t* include/ext/hashtable.h: ...here.\n\t* include/backward/hashtable.h: Reflect new names.\n\t* include/Makefile.am: Same.\n\t* include/Makefile.in: Regenerated.\n\nFrom-SVN: r67551", "tree": {"sha": "5e4a19a16ece761c718d5e8ef56f353f2ffd46ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e4a19a16ece761c718d5e8ef56f353f2ffd46ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2acb86f5b67be421dbd9b8d90238f26c3b42448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2acb86f5b67be421dbd9b8d90238f26c3b42448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2acb86f5b67be421dbd9b8d90238f26c3b42448", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2acb86f5b67be421dbd9b8d90238f26c3b42448/comments", "author": null, "committer": null, "parents": [{"sha": "744f6f0984e3b00f2dc1d451087543526e1cc672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744f6f0984e3b00f2dc1d451087543526e1cc672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/744f6f0984e3b00f2dc1d451087543526e1cc672"}], "stats": {"total": 5430, "additions": 2679, "deletions": 2751}, "files": [{"sha": "286c5c85a47675e524f50a53d06c82c60e597afa", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -1,3 +1,27 @@\n+2003-06-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/stl_alloc.h: Cleanups.\n+\t* include/ext/functional: Same.\n+\t* include/ext/hash_map: Same.\n+\t* include/ext/hash_set: Same.\n+\t* include/ext/iterator: Same.\n+\t* include/ext/memory: Same.\n+\t* include/ext/numeric: Same.\n+\t* include/ext/rb_tree: Same.\n+\t* include/ext/ropeimpl.h: Same.\n+\t* include/ext/slist: Same.\n+\t* include/ext/stdio_filebuf.h: Same.\n+\t* include/ext/stdio_sync_filebuf.h: Same.\n+\t* include/ext/stl_rope.h: Move to...\n+\t* include/ext/rope: ...here.\n+\t* include/ext/stl_hash_fun.h: Move to...\n+\t* include/ext/hash_fun.h: ...here.\n+\t* include/ext/stl_hashtable.h: Move to...\n+\t* include/ext/hashtable.h: ...here.\n+\t* include/backward/hashtable.h: Reflect new names.\n+\t* include/Makefile.am: Same.\n+\t* include/Makefile.in: Regenerated.\n+\n 2003-06-05  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/9024\t"}, {"sha": "5c200dcd8a7d2ac4076bb91143748ad87b232da4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -228,9 +228,9 @@ ext_headers = \\\n \t${ext_srcdir}/rope \\\n \t${ext_srcdir}/ropeimpl.h \\\n \t${ext_srcdir}/slist \\\n-\t${ext_srcdir}/stl_hash_fun.h \\\n-\t${ext_srcdir}/stl_hashtable.h \\\n-\t${ext_srcdir}/stl_rope.h\n+\t${ext_srcdir}/hash_fun.h \\\n+\t${ext_srcdir}/hashtable.h \n+\n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = @C_INCLUDE_DIR@"}, {"sha": "7dfd79311e11012c5ba9decffd51430742027de4", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -126,6 +126,7 @@ enable_shared = @enable_shared@\n enable_static = @enable_static@\n glibcpp_CXX = @glibcpp_CXX@\n glibcpp_MOFILES = @glibcpp_MOFILES@\n+glibcpp_PCHFLAGS = @glibcpp_PCHFLAGS@\n glibcpp_POFILES = @glibcpp_POFILES@\n glibcpp_basedir = @glibcpp_basedir@\n glibcpp_localedir = @glibcpp_localedir@\n@@ -348,9 +349,8 @@ ext_headers = \\\n \t${ext_srcdir}/rope \\\n \t${ext_srcdir}/ropeimpl.h \\\n \t${ext_srcdir}/slist \\\n-\t${ext_srcdir}/stl_hash_fun.h \\\n-\t${ext_srcdir}/stl_hashtable.h \\\n-\t${ext_srcdir}/stl_rope.h\n+\t${ext_srcdir}/hash_fun.h \\\n+\t${ext_srcdir}/hashtable.h \n \n \n # This is the common subset of files that all three \"C\" header models use."}, {"sha": "a707d9e2522ddec877a773d35ce41279c41c8187", "filename": "libstdc++-v3/include/backward/hashtable.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -61,7 +61,7 @@\n #define _CPP_BACKWARD_HASHTABLE_H 1\n \n #include \"backward_warning.h\"\n-#include <ext/stl_hashtable.h>\n+#include <ext/hashtable.h>\n #include \"algo.h\"\n #include \"alloc.h\"\n #include \"vector.h\""}, {"sha": "3d26d6d645dc113cf9e1d70f1b7e654ab461d752", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -83,7 +83,6 @@\n #include <cstring>\n #include <bits/functexcept.h>   // For __throw_bad_alloc\n #include <bits/stl_threads.h>\n-\n #include <bits/atomicity.h>\n \n namespace std\n@@ -172,8 +171,6 @@ namespace std\n         }\n     }\n \n-  // Should not be referenced within the library anymore.\n-  typedef __new_alloc                 __mem_interface;\n \n   /**\n    *  @if maint"}, {"sha": "c8b4b61a6cf705fea668dfa108cdb2319987253d", "filename": "libstdc++-v3/include/ext/functional", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -60,9 +60,10 @@\n  */\n \n #ifndef _EXT_FUNCTIONAL\n-#define _EXT_FUNCTIONAL\n+#define _EXT_FUNCTIONAL 1\n \n #pragma GCC system_header\n+\n #include <functional>\n \n namespace __gnu_cxx\n@@ -388,8 +389,7 @@ template <class _Ret, class _Tp, class _Arg>\n inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n   { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n-\n } // namespace __gnu_cxx\n \n-#endif /* _EXT_FUNCTIONAL */\n+#endif \n "}, {"sha": "154252663feb76985aea8c7497ed08341dcbe6bd", "filename": "libstdc++-v3/include/ext/hash_fun.h", "status": "renamed", "additions": 51, "deletions": 55, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -1,6 +1,6 @@\n // 'struct hash' from SGI -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -53,74 +53,70 @@\n  *\n  */\n \n-/** @file ext/stl_hash_fun.h\n+/** @file ext/hash_fun.h\n  *  This file is a GNU extension to the Standard C++ Library (possibly\n  *  containing extensions from the HP/SGI STL subset).  You should only\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef _CPP_BITS_STL_HASH_FUN_H\n-#define _CPP_BITS_STL_HASH_FUN_H 1\n+#ifndef _HASH_FUN_H\n+#define _HASH_FUN_H 1\n \n #include <cstddef>\n \n namespace __gnu_cxx\n {\n-using std::size_t;\n+  using std::size_t;\n+\n+  template <class _Key> struct hash { };\n+\n+  inline size_t \n+  __stl_hash_string(const char* __s)\n+  {\n+    unsigned long __h = 0; \n+    for ( ; *__s; ++__s)\n+      __h = 5*__h + *__s;    \n+    return size_t(__h);\n+  }\n+\n+  template<> struct hash<char*>\n+  {\n+    size_t operator()(const char* __s) const \n+    { return __stl_hash_string(__s); }\n+  };\n+  \n+  template<> struct hash<const char*>\n+  {\n+    size_t operator()(const char* __s) const \n+    { return __stl_hash_string(__s); }\n+  };\n \n-template <class _Key> struct hash { };\n+  template<> struct hash<char> \n+  { size_t operator()(char __x) const { return __x; } };\n \n-inline size_t __stl_hash_string(const char* __s)\n-{\n-  unsigned long __h = 0; \n-  for ( ; *__s; ++__s)\n-    __h = 5*__h + *__s;\n-  \n-  return size_t(__h);\n-}\n+  template<> struct hash<unsigned char> \n+  { size_t operator()(unsigned char __x) const { return __x; } };\n \n-template<> struct hash<char*>\n-{\n-  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n-};\n+  template<> struct hash<signed char> \n+  { size_t operator()(unsigned char __x) const { return __x; } };\n \n-template<> struct hash<const char*>\n-{\n-  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n-};\n-\n-template<> struct hash<char> {\n-  size_t operator()(char __x) const { return __x; }\n-};\n-template<> struct hash<unsigned char> {\n-  size_t operator()(unsigned char __x) const { return __x; }\n-};\n-template<> struct hash<signed char> {\n-  size_t operator()(unsigned char __x) const { return __x; }\n-};\n-template<> struct hash<short> {\n-  size_t operator()(short __x) const { return __x; }\n-};\n-template<> struct hash<unsigned short> {\n-  size_t operator()(unsigned short __x) const { return __x; }\n-};\n-template<> struct hash<int> {\n-  size_t operator()(int __x) const { return __x; }\n-};\n-template<> struct hash<unsigned int> {\n-  size_t operator()(unsigned int __x) const { return __x; }\n-};\n-template<> struct hash<long> {\n-  size_t operator()(long __x) const { return __x; }\n-};\n-template<> struct hash<unsigned long> {\n-  size_t operator()(unsigned long __x) const { return __x; }\n-};\n+  template<> struct hash<short> \n+  { size_t operator()(short __x) const { return __x; } };\n \n-} // namespace __gnu_cxx\n+  template<> struct hash<unsigned short> \n+  { size_t operator()(unsigned short __x) const { return __x; } };\n+\n+  template<> struct hash<int> \n+  { size_t operator()(int __x) const { return __x; } };\n+\n+  template<> struct hash<unsigned int> \n+  { size_t operator()(unsigned int __x) const { return __x; } };\n \n-#endif /* _CPP_BITS_STL_HASH_FUN_H */\n+  template<> struct hash<long> \n+  { size_t operator()(long __x) const { return __x; } };\n+\n+  template<> struct hash<unsigned long> \n+  { size_t operator()(unsigned long __x) const { return __x; } };\n+} // namespace __gnu_cxx\n \n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif ", "previous_filename": "libstdc++-v3/include/ext/stl_hash_fun.h"}, {"sha": "d35acf8496c606c94845d7f1a928b166eee2b8f5", "filename": "libstdc++-v3/include/ext/hash_map", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -59,30 +59,28 @@\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef __SGI_STL_INTERNAL_HASH_MAP_H\n-#define __SGI_STL_INTERNAL_HASH_MAP_H\n+#ifndef _HASH_MAP \n+#define _HASH_MAP 1\n \n-#include <ext/stl_hashtable.h>\n+#include <ext/hashtable.h>\n #include <bits/concept_check.h>\n \n namespace __gnu_cxx\n {\n-using std::equal_to;\n-using std::allocator;\n-using std::pair;\n-using std::_Select1st;\n-\n-// Forward declaration of equality operator; needed for friend declaration.\n-\n-template <class _Key, class _Tp,\n-          class _HashFcn  = hash<_Key>,\n-          class _EqualKey = equal_to<_Key>,\n-          class _Alloc =  allocator<_Tp> >\n-class hash_map;\n-\n-template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>\n-inline bool operator==(const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&,\n-                       const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&);\n+  using std::equal_to;\n+  using std::allocator;\n+  using std::pair;\n+  using std::_Select1st;\n+\n+  // Forward declaration of equality operator; needed for friend\n+  // declaration.\n+  template<class _Key, class _Tp, class _HashFcn  = hash<_Key>,\n+\t    class _EqualKey = equal_to<_Key>, class _Alloc =  allocator<_Tp> >\n+    class hash_map;\n+\n+  template<class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>\n+  inline bool operator==(const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&,\n+\t\t\t const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&);\n /**\n  *  This is an SGI extension.\n  *  @ingroup SGIextensions\n@@ -444,11 +442,6 @@ public:\n   insert_iterator<_Container>& operator++() { return *this; }\n   insert_iterator<_Container>& operator++(int) { return *this; }\n };\n-\n } // namespace std\n \n-#endif /* __SGI_STL_INTERNAL_HASH_MAP_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif"}, {"sha": "acb0a3f4f9da93d3650b831091736ccda2553147", "filename": "libstdc++-v3/include/ext/hash_set", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -59,31 +59,30 @@\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef __SGI_STL_INTERNAL_HASH_SET_H\n-#define __SGI_STL_INTERNAL_HASH_SET_H\n+#ifndef _HASH_SET\n+#define _HASH_SET 1\n \n-#include <ext/stl_hashtable.h>\n+#include <ext/hashtable.h>\n #include <bits/concept_check.h>\n \n namespace __gnu_cxx\n {\n-using std::equal_to;\n-using std::allocator;\n-using std::pair;\n-using std::_Identity;\n-\n-// Forward declaration of equality operator; needed for friend declaration.\n-\n-template <class _Value,\n-          class _HashFcn  = hash<_Value>,\n-          class _EqualKey = equal_to<_Value>,\n-          class _Alloc =  allocator<_Value> >\n-class hash_set;\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n-operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2);\n+  using std::equal_to;\n+  using std::allocator;\n+  using std::pair;\n+  using std::_Identity;\n+\n+  // Forward declaration of equality operator; needed for friend\n+  // declaration.\n+  template <class _Value, class _HashFcn  = hash<_Value>,\n+\t    class _EqualKey = equal_to<_Value>, \n+\t    class _Alloc =  allocator<_Value> >\n+  class hash_set;\n+\n+  template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline bool \n+    operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n+\t       const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2);\n \n /**\n  *  This is an SGI extension.\n@@ -435,11 +434,6 @@ public:\n   insert_iterator<_Container>& operator++() { return *this; }\n   insert_iterator<_Container>& operator++(int) { return *this; }\n };\n-\n } // namespace std\n \n-#endif /* __SGI_STL_INTERNAL_HASH_SET_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif "}, {"sha": "435221c93c7884f4cbef63b9f1b3db705e008545", "filename": "libstdc++-v3/include/ext/hashtable.h", "status": "renamed", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -53,14 +53,14 @@\n  *\n  */\n \n-/** @file ext/stl_hashtable.h\n+/** @file ext/hashtable.h\n  *  This file is a GNU extension to the Standard C++ Library (possibly\n  *  containing extensions from the HP/SGI STL subset).  You should only\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef __SGI_STL_INTERNAL_HASHTABLE_H\n-#define __SGI_STL_INTERNAL_HASHTABLE_H\n+#ifndef _HASHTABLE_H\n+#define _HASHTABLE_H 1\n \n // Hashtable class, used to implement the hashed associative containers\n // hash_set, hash_map, hash_multiset, and hash_multimap.\n@@ -69,7 +69,7 @@\n #include <iterator>\n #include <bits/stl_algo.h>\n #include <bits/stl_function.h>\n-#include <ext/stl_hash_fun.h>\n+#include <ext/hash_fun.h>\n \n namespace __gnu_cxx\n {\n@@ -210,13 +210,14 @@ bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n                 const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2);\n \n \n-// Hashtables handle allocators a bit differently than other containers\n-//  do.  If we're using standard-conforming allocators, then a hashtable\n-//  unconditionally has a member variable to hold its allocator, even if\n-//  it so happens that all instances of the allocator type are identical.\n-// This is because, for hashtables, this extra storage is negligible.  \n-//  Additionally, a base class wouldn't serve any other purposes; it \n-//  wouldn't, for example, simplify the exception-handling code.\n+// Hashtables handle allocators a bit differently than other\n+// containers do.  If we're using standard-conforming allocators, then\n+// a hashtable unconditionally has a member variable to hold its\n+// allocator, even if it so happens that all instances of the\n+// allocator type are identical.  This is because, for hashtables,\n+// this extra storage is negligible.  Additionally, a base class\n+// wouldn't serve any other purposes; it wouldn't, for example,\n+// simplify the exception-handling code.\n \n template <class _Val, class _Key, class _HashFcn,\n           class _ExtractKey, class _EqualKey, class _Alloc>\n@@ -986,11 +987,6 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n       __throw_exception_again;\n     }\n }\n-\n } // namespace __gnu_cxx\n \n-#endif /* __SGI_STL_INTERNAL_HASHTABLE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif", "previous_filename": "libstdc++-v3/include/ext/stl_hashtable.h"}, {"sha": "2a14a4232824c07becacf315a601e2cc8df4e5ff", "filename": "libstdc++-v3/include/ext/iterator", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -60,19 +60,20 @@\n  */\n \n #ifndef _EXT_ITERATOR\n-#define _EXT_ITERATOR\n+#define _EXT_ITERATOR 1\n \n #pragma GCC system_header\n+\n #include <bits/concept_check.h>\n #include <iterator>\n \n namespace __gnu_cxx\n {\n-\n-  // There are two signatures for distance.  In addition to the one taking\n-  // two iterators and returning a result, there is another taking two\n-  // iterators and a reference-to-result variable, and returning nothing.\n-  // The latter seems to be an SGI extension.   -- pedwards\n+  // There are two signatures for distance.  In addition to the one\n+  // taking two iterators and returning a result, there is another\n+  // taking two iterators and a reference-to-result variable, and\n+  // returning nothing.  The latter seems to be an SGI extension.  \n+  // -- pedwards\n   template<typename _InputIterator, typename _Distance>\n     inline void\n     __distance(_InputIterator __first, _InputIterator __last,\n@@ -106,8 +107,7 @@ namespace __gnu_cxx\n       // concept requirements -- taken care of in __distance\n       __distance(__first, __last, __n, std::__iterator_category(__first));\n     }\n-\n } // namespace __gnu_cxx\n \n-#endif /* _EXT_ITERATOR */\n+#endif \n "}, {"sha": "8a3a335195f7aad1ba836455e975c57dc4c85247", "filename": "libstdc++-v3/include/ext/memory", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -60,9 +60,10 @@\n  */\n \n #ifndef _EXT_MEMORY\n-#define _EXT_MEMORY\n+#define _EXT_MEMORY 1\n \n #pragma GCC system_header\n+\n #include <memory>\n #include <bits/stl_tempbuf.h>\n \n@@ -73,30 +74,29 @@ namespace __gnu_cxx\n   using std::__iterator_category;\n   using std::_Temporary_buffer;\n   \n-\n   template<typename _InputIter, typename _Size, typename _ForwardIter>\n     pair<_InputIter, _ForwardIter>\n     __uninitialized_copy_n(_InputIter __first, _Size __count,\n-\t\t\t   _ForwardIter __result,\n-\t\t\t   std::input_iterator_tag)\n+\t\t\t   _ForwardIter __result, std::input_iterator_tag)\n     {\n       _ForwardIter __cur = __result;\n-      try {\n-\tfor ( ; __count > 0 ; --__count, ++__first, ++__cur) \n-\t  std::_Construct(&*__cur, *__first);\n-\treturn pair<_InputIter, _ForwardIter>(__first, __cur);\n-      }\n+      try \n+\t{\n+\t  for ( ; __count > 0 ; --__count, ++__first, ++__cur) \n+\t    std::_Construct(&*__cur, *__first);\n+\t  return pair<_InputIter, _ForwardIter>(__first, __cur);\n+\t}\n       catch(...)\n \t{\n \t  std::_Destroy(__result, __cur);\n \t  __throw_exception_again; \n \t}\n     }\n-\n+  \n   template<typename _RandomAccessIter, typename _Size, typename _ForwardIter>\n     inline pair<_RandomAccessIter, _ForwardIter>\n     __uninitialized_copy_n(_RandomAccessIter __first, _Size __count,\n-\t\t\t   _ForwardIter __result,\n+\t\t\t   _ForwardIter __result, \n \t\t\t   std::random_access_iterator_tag)\n     {\n       _RandomAccessIter __last = __first + __count;\n@@ -108,7 +108,8 @@ namespace __gnu_cxx\n   template<typename _InputIter, typename _Size, typename _ForwardIter>\n     inline pair<_InputIter, _ForwardIter>\n     __uninitialized_copy_n(_InputIter __first, _Size __count,\n-\t\t\t _ForwardIter __result) {\n+\t\t\t _ForwardIter __result) \n+    {\n       return __uninitialized_copy_n(__first, __count, __result,\n \t\t\t\t    __iterator_category(__first));\n     }\n@@ -126,7 +127,8 @@ namespace __gnu_cxx\n   template<typename _InputIter, typename _Size, typename _ForwardIter>\n     inline pair<_InputIter, _ForwardIter>\n     uninitialized_copy_n(_InputIter __first, _Size __count,\n-\t\t\t _ForwardIter __result) {\n+\t\t\t _ForwardIter __result) \n+    {\n       return __uninitialized_copy_n(__first, __count, __result,\n \t\t\t\t    __iterator_category(__first));\n     }\n@@ -152,19 +154,18 @@ namespace __gnu_cxx\n    *\n    *  @ingroup SGIextensions\n   */\n-  template <class _ForwardIterator, \n-\t    class _Tp \n+  template <class _ForwardIterator, class _Tp \n \t      = typename std::iterator_traits<_ForwardIterator>::value_type >\n   struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>\n   {\n     /// Requests storage large enough to hold a copy of [first,last).\n     temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)\n-      : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}\n+    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) { }\n+\n     /// Destroys objects and frees storage.\n-    ~temporary_buffer() {}\n+    ~temporary_buffer() { }\n   };\n-\n } // namespace __gnu_cxx\n \n-#endif /* _EXT_MEMORY */\n+#endif\n "}, {"sha": "8b40dabbaf6e26fa8fa98f45984cd1abbddbc317", "filename": "libstdc++-v3/include/ext/numeric", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -60,9 +60,10 @@\n  */\n \n #ifndef _EXT_NUMERIC\n-#define _EXT_NUMERIC\n+#define _EXT_NUMERIC 1\n \n #pragma GCC system_header\n+\n #include <bits/concept_check.h>\n #include <numeric>\n \n@@ -71,8 +72,7 @@\n namespace __gnu_cxx\n {\n   // Returns __x ** __n, where __n >= 0.  _Note that \"multiplication\"\n-  // is required to be associative, but not necessarily commutative.\n-   \n+  // is required to be associative, but not necessarily commutative.   \n   template<typename _Tp, typename _Integer, typename _MonoidOperation>\n     _Tp\n     __power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n@@ -102,14 +102,13 @@ namespace __gnu_cxx\n     __power(_Tp __x, _Integer __n)\n     { return __power(__x, __n, std::multiplies<_Tp>()); }\n \n-  // Alias for the internal name __power.  Note that power is an extension,\n-  // not part of the C++ standard.\n-\n   /**\n    *  This is an SGI extension.\n    *  @ingroup SGIextensions\n    *  @doctodo\n   */\n+  // Alias for the internal name __power.  Note that power is an extension,\n+  // not part of the C++ standard.\n   template<typename _Tp, typename _Integer, typename _MonoidOperation>\n     inline _Tp\n     power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n@@ -125,13 +124,12 @@ namespace __gnu_cxx\n     power(_Tp __x, _Integer __n)\n     { return __power(__x, __n); }\n \n-  // iota is not part of the C++ standard.  It is an extension.\n-\n   /**\n    *  This is an SGI extension.\n    *  @ingroup SGIextensions\n    *  @doctodo\n   */\n+  // iota is not part of the C++ standard.  It is an extension.\n   template<typename _ForwardIter, typename _Tp>\n     void \n     iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n@@ -144,8 +142,7 @@ namespace __gnu_cxx\n       while (__first != __last)\n \t*__first++ = __value++;\n     }\n-\n } // namespace __gnu_cxx\n \n-#endif /* _EXT_NUMERIC */\n+#endif\n "}, {"sha": "f0aed4714f9605a0340b57373e118e77717d7133", "filename": "libstdc++-v3/include/ext/rb_tree", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -59,39 +59,39 @@\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef _EXT_RB_TREE\n-#define _EXT_RB_TREE\n+#ifndef _RB_TREE\n+#define _RB_TREE 1\n \n #pragma GCC system_header\n+\n #include <bits/stl_tree.h>\n \n namespace __gnu_cxx\n {\n-using std::_Rb_tree;\n-using std::allocator;\n-\n-// Class rb_tree is not part of the C++ standard.  It is provided for\n-// compatibility with the HP STL.\n-\n-/**\n- *  This is an SGI extension.\n- *  @ingroup SGIextensions\n- *  @doctodo\n-*/\n-template <class _Key, class _Value, class _KeyOfValue, class _Compare,\n-          class _Alloc = allocator<_Value> >\n-struct rb_tree : public _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc>\n-{\n-  typedef _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc> _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  rb_tree(const _Compare& __comp = _Compare(),\n-          const allocator_type& __a = allocator_type())\n-    : _Base(__comp, __a) {}\n+  using std::_Rb_tree;\n+  using std::allocator;\n   \n-  ~rb_tree() {}\n-};\n+  // Class rb_tree is not part of the C++ standard.  It is provided for\n+  // compatibility with the HP STL.\n \n+  /**\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+   *  @doctodo\n+   */\n+  template <class _Key, class _Value, class _KeyOfValue, class _Compare,\n+\t    class _Alloc = allocator<_Value> >\n+  struct rb_tree : public _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc>\n+  {\n+    typedef _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc> _Base;\n+    typedef typename _Base::allocator_type allocator_type;\n+    \n+    rb_tree(const _Compare& __comp = _Compare(),\n+\t    const allocator_type& __a = allocator_type())\n+      : _Base(__comp, __a) { }\n+    \n+    ~rb_tree() { }\n+  };\n } // namespace __gnu_cxx\n \n-#endif /* _EXT_RB_TREE */\n+#endif "}, {"sha": "d621ba84aa0fe5921a02f482135328746a1a60fe", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 2468, "deletions": 8, "changes": 2476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -46,8 +46,8 @@\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef __SGI_STL_ROPE\n-#define __SGI_STL_ROPE\n+#ifndef _ROPE\n+#define _ROPE 1\n \n #include <bits/stl_algobase.h>\n #include <bits/stl_algo.h>\n@@ -56,11 +56,2471 @@\n #include <bits/stl_alloc.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n-#include <ext/stl_hash_fun.h>\n-#include <ext/stl_rope.h>\n+#include <ext/hash_fun.h>\n \n-#endif /* __SGI_STL_ROPE */\n \n-// Local Variables:\n-// mode:C++\n-// End:\n+# ifdef __GC\n+#   define __GC_CONST const\n+# else\n+#   include <bits/stl_threads.h>\n+#   define __GC_CONST   // constant except for deallocation\n+# endif\n+\n+#include <ext/memory> // For uninitialized_copy_n\n+\n+namespace __gnu_cxx\n+{\n+using std::size_t;\n+using std::ptrdiff_t;\n+using std::allocator;\n+using std::iterator;\n+using std::reverse_iterator;\n+using std::_Alloc_traits;\n+using std::_Destroy;\n+using std::_Refcount_Base;\n+\n+// The _S_eos function is used for those functions that\n+// convert to/from C-like strings to detect the end of the string.\n+\n+// The end-of-C-string character.\n+// This is what the draft standard says it should be.\n+template <class _CharT>\n+inline _CharT _S_eos(_CharT*) { return _CharT(); }\n+\n+// Test for basic character types.\n+// For basic character types leaves having a trailing eos.\n+template <class _CharT>\n+inline bool _S_is_basic_char_type(_CharT*) { return false; }\n+template <class _CharT>\n+inline bool _S_is_one_byte_char_type(_CharT*) { return false; }\n+\n+inline bool _S_is_basic_char_type(char*) { return true; }\n+inline bool _S_is_one_byte_char_type(char*) { return true; }\n+inline bool _S_is_basic_char_type(wchar_t*) { return true; }\n+\n+// Store an eos iff _CharT is a basic character type.\n+// Do not reference _S_eos if it isn't.\n+template <class _CharT>\n+inline void _S_cond_store_eos(_CharT&) {}\n+\n+inline void _S_cond_store_eos(char& __c) { __c = 0; }\n+inline void _S_cond_store_eos(wchar_t& __c) { __c = 0; }\n+\n+// char_producers are logically functions that generate a section of\n+// a string.  These can be convereted to ropes.  The resulting rope\n+// invokes the char_producer on demand.  This allows, for example,\n+// files to be viewed as ropes without reading the entire file.\n+template <class _CharT>\n+class char_producer {\n+    public:\n+        virtual ~char_producer() {};\n+        virtual void operator()(size_t __start_pos, size_t __len, \n+                                _CharT* __buffer) = 0;\n+        // Buffer should really be an arbitrary output iterator.\n+        // That way we could flatten directly into an ostream, etc.\n+        // This is thoroughly impossible, since iterator types don't\n+        // have runtime descriptions.\n+};\n+\n+// Sequence buffers:\n+//\n+// Sequence must provide an append operation that appends an\n+// array to the sequence.  Sequence buffers are useful only if\n+// appending an entire array is cheaper than appending element by element.\n+// This is true for many string representations.\n+// This should  perhaps inherit from ostream<sequence::value_type>\n+// and be implemented correspondingly, so that they can be used\n+// for formatted.  For the sake of portability, we don't do this yet.\n+//\n+// For now, sequence buffers behave as output iterators.  But they also\n+// behave a little like basic_ostringstream<sequence::value_type> and a\n+// little like containers.\n+\n+template<class _Sequence, size_t _Buf_sz = 100>\n+class sequence_buffer : public iterator<std::output_iterator_tag,void,void,void,void>\n+{\n+    public:\n+        typedef typename _Sequence::value_type value_type;\n+    protected:\n+        _Sequence* _M_prefix;\n+        value_type _M_buffer[_Buf_sz];\n+        size_t     _M_buf_count;\n+    public:\n+        void flush() {\n+            _M_prefix->append(_M_buffer, _M_buffer + _M_buf_count);\n+            _M_buf_count = 0;\n+        }\n+        ~sequence_buffer() { flush(); }\n+        sequence_buffer() : _M_prefix(0), _M_buf_count(0) {}\n+        sequence_buffer(const sequence_buffer& __x) {\n+            _M_prefix = __x._M_prefix;\n+            _M_buf_count = __x._M_buf_count;\n+            copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);\n+        }\n+        sequence_buffer(sequence_buffer& __x) {\n+            __x.flush();\n+            _M_prefix = __x._M_prefix;\n+            _M_buf_count = 0;\n+        }\n+        sequence_buffer(_Sequence& __s) : _M_prefix(&__s), _M_buf_count(0) {}\n+        sequence_buffer& operator= (sequence_buffer& __x) {\n+            __x.flush();\n+            _M_prefix = __x._M_prefix;\n+            _M_buf_count = 0;\n+            return *this;\n+        }\n+        sequence_buffer& operator= (const sequence_buffer& __x) {\n+            _M_prefix = __x._M_prefix;\n+            _M_buf_count = __x._M_buf_count;\n+            copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);\n+            return *this;\n+        }\n+        void push_back(value_type __x)\n+        {\n+            if (_M_buf_count < _Buf_sz) {\n+                _M_buffer[_M_buf_count] = __x;\n+                ++_M_buf_count;\n+            } else {\n+                flush();\n+                _M_buffer[0] = __x;\n+                _M_buf_count = 1;\n+            }\n+        }\n+        void append(value_type* __s, size_t __len)\n+        {\n+            if (__len + _M_buf_count <= _Buf_sz) {\n+                size_t __i = _M_buf_count;\n+                size_t __j = 0;\n+                for (; __j < __len; __i++, __j++) {\n+                    _M_buffer[__i] = __s[__j];\n+                }\n+                _M_buf_count += __len;\n+            } else if (0 == _M_buf_count) {\n+                _M_prefix->append(__s, __s + __len);\n+            } else {\n+                flush();\n+                append(__s, __len);\n+            }\n+        }\n+        sequence_buffer& write(value_type* __s, size_t __len)\n+        {\n+            append(__s, __len);\n+            return *this;\n+        }\n+        sequence_buffer& put(value_type __x)\n+        {\n+            push_back(__x);\n+            return *this;\n+        }\n+        sequence_buffer& operator=(const value_type& __rhs)\n+        {\n+            push_back(__rhs);\n+            return *this;\n+        }\n+        sequence_buffer& operator*() { return *this; }\n+        sequence_buffer& operator++() { return *this; }\n+        sequence_buffer& operator++(int) { return *this; }\n+};\n+\n+// The following should be treated as private, at least for now.\n+template<class _CharT>\n+class _Rope_char_consumer {\n+    public:\n+        // If we had member templates, these should not be virtual.\n+        // For now we need to use run-time parametrization where\n+        // compile-time would do.  Hence this should all be private\n+        // for now.\n+        // The symmetry with char_producer is accidental and temporary.\n+        virtual ~_Rope_char_consumer() {};\n+        virtual bool operator()(const _CharT* __buffer, size_t __len) = 0;\n+};\n+\n+// First a lot of forward declarations.  The standard seems to require\n+// much stricter \"declaration before use\" than many of the implementations\n+// that preceded it.\n+template<class _CharT, class _Alloc=allocator<_CharT> > class rope;\n+template<class _CharT, class _Alloc> struct _Rope_RopeConcatenation;\n+template<class _CharT, class _Alloc> struct _Rope_RopeLeaf;\n+template<class _CharT, class _Alloc> struct _Rope_RopeFunction;\n+template<class _CharT, class _Alloc> struct _Rope_RopeSubstring;\n+template<class _CharT, class _Alloc> class _Rope_iterator;\n+template<class _CharT, class _Alloc> class _Rope_const_iterator;\n+template<class _CharT, class _Alloc> class _Rope_char_ref_proxy;\n+template<class _CharT, class _Alloc> class _Rope_char_ptr_proxy;\n+\n+template<class _CharT, class _Alloc>\n+bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n+                 const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y);\n+\n+template<class _CharT, class _Alloc>\n+_Rope_const_iterator<_CharT,_Alloc> operator-\n+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+         ptrdiff_t __n);\n+\n+template<class _CharT, class _Alloc>\n+_Rope_const_iterator<_CharT,_Alloc> operator+\n+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+         ptrdiff_t __n);\n+\n+template<class _CharT, class _Alloc>\n+_Rope_const_iterator<_CharT,_Alloc> operator+\n+        (ptrdiff_t __n,\n+         const _Rope_const_iterator<_CharT,_Alloc>& __x);\n+\n+template<class _CharT, class _Alloc>\n+bool operator== \n+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n+\n+template<class _CharT, class _Alloc>\n+bool operator< \n+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n+\n+template<class _CharT, class _Alloc>\n+ptrdiff_t operator- \n+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n+\n+template<class _CharT, class _Alloc>\n+_Rope_iterator<_CharT,_Alloc> operator-\n+        (const _Rope_iterator<_CharT,_Alloc>& __x,\n+         ptrdiff_t __n);\n+\n+template<class _CharT, class _Alloc>\n+_Rope_iterator<_CharT,_Alloc> operator+\n+        (const _Rope_iterator<_CharT,_Alloc>& __x,\n+         ptrdiff_t __n);\n+\n+template<class _CharT, class _Alloc>\n+_Rope_iterator<_CharT,_Alloc> operator+\n+        (ptrdiff_t __n,\n+         const _Rope_iterator<_CharT,_Alloc>& __x);\n+\n+template<class _CharT, class _Alloc>\n+bool operator== \n+        (const _Rope_iterator<_CharT,_Alloc>& __x,\n+         const _Rope_iterator<_CharT,_Alloc>& __y);\n+\n+template<class _CharT, class _Alloc>\n+bool operator< \n+        (const _Rope_iterator<_CharT,_Alloc>& __x,\n+         const _Rope_iterator<_CharT,_Alloc>& __y);\n+\n+template<class _CharT, class _Alloc>\n+ptrdiff_t operator- \n+        (const _Rope_iterator<_CharT,_Alloc>& __x,\n+         const _Rope_iterator<_CharT,_Alloc>& __y);\n+\n+template<class _CharT, class _Alloc>\n+rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n+                               const rope<_CharT,_Alloc>& __right);\n+        \n+template<class _CharT, class _Alloc>\n+rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n+                               const _CharT* __right);\n+        \n+template<class _CharT, class _Alloc>\n+rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n+                               _CharT __right);\n+        \n+// Some helpers, so we can use power on ropes.\n+// See below for why this isn't local to the implementation.\n+\n+// This uses a nonstandard refcount convention.\n+// The result has refcount 0.\n+template<class _CharT, class _Alloc>\n+struct _Rope_Concat_fn\n+       : public std::binary_function<rope<_CharT,_Alloc>, rope<_CharT,_Alloc>,\n+                                     rope<_CharT,_Alloc> > {\n+        rope<_CharT,_Alloc> operator() (const rope<_CharT,_Alloc>& __x,\n+                                const rope<_CharT,_Alloc>& __y) {\n+                    return __x + __y;\n+        }\n+};\n+\n+template <class _CharT, class _Alloc>\n+inline\n+rope<_CharT,_Alloc>\n+identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n+{\n+    return rope<_CharT,_Alloc>();\n+}\n+\n+\n+//\n+// What follows should really be local to rope.  Unfortunately,\n+// that doesn't work, since it makes it impossible to define generic\n+// equality on rope iterators.  According to the draft standard, the\n+// template parameters for such an equality operator cannot be inferred\n+// from the occurrence of a member class as a parameter.\n+// (SGI compilers in fact allow this, but the __result wouldn't be\n+// portable.)\n+// Similarly, some of the static member functions are member functions\n+// only to avoid polluting the global namespace, and to circumvent\n+// restrictions on type inference for template functions.\n+//\n+\n+//\n+// The internal data structure for representing a rope.  This is\n+// private to the implementation.  A rope is really just a pointer\n+// to one of these.\n+//\n+// A few basic functions for manipulating this data structure\n+// are members of _RopeRep.  Most of the more complex algorithms\n+// are implemented as rope members.\n+//\n+// Some of the static member functions of _RopeRep have identically\n+// named functions in rope that simply invoke the _RopeRep versions.\n+//\n+// A macro to introduce various allocation and deallocation functions\n+// These need to be defined differently depending on whether or not\n+// we are using standard conforming allocators, and whether the allocator\n+// instances have real state.  Thus this macro is invoked repeatedly\n+// with different definitions of __ROPE_DEFINE_ALLOC.\n+// __ROPE_DEFINE_ALLOC(type,name) defines \n+//   type * name_allocate(size_t) and\n+//   void name_deallocate(tipe *, size_t)\n+// Both functions may or may not be static.\n+\n+#define __ROPE_DEFINE_ALLOCS(__a) \\\n+        __ROPE_DEFINE_ALLOC(_CharT,_Data) /* character data */ \\\n+        typedef _Rope_RopeConcatenation<_CharT,__a> __C; \\\n+        __ROPE_DEFINE_ALLOC(__C,_C) \\\n+        typedef _Rope_RopeLeaf<_CharT,__a> __L; \\\n+        __ROPE_DEFINE_ALLOC(__L,_L) \\\n+        typedef _Rope_RopeFunction<_CharT,__a> __F; \\\n+        __ROPE_DEFINE_ALLOC(__F,_F) \\\n+        typedef _Rope_RopeSubstring<_CharT,__a> __S; \\\n+        __ROPE_DEFINE_ALLOC(__S,_S)\n+\n+//  Internal rope nodes potentially store a copy of the allocator\n+//  instance used to allocate them.  This is mostly redundant.\n+//  But the alternative would be to pass allocator instances around\n+//  in some form to nearly all internal functions, since any pointer\n+//  assignment may result in a zero reference count and thus require\n+//  deallocation.\n+//  The _Rope_rep_base class encapsulates\n+//  the differences between SGI-style allocators and standard-conforming\n+//  allocators.\n+\n+#define __STATIC_IF_SGI_ALLOC  /* not static */\n+\n+// Base class for ordinary allocators.\n+template <class _CharT, class _Allocator, bool _IsStatic>\n+class _Rope_rep_alloc_base {\n+public:\n+  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return _M_data_allocator; }\n+  _Rope_rep_alloc_base(size_t __size, const allocator_type& __a)\n+        : _M_size(__size), _M_data_allocator(__a) {}\n+  size_t _M_size;       // This is here only to avoid wasting space\n+                // for an otherwise empty base class.\n+\n+  \n+protected:\n+    allocator_type _M_data_allocator;\n+\n+# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n+        typedef typename \\\n+          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n+        /*static*/ _Tp * __name##_allocate(size_t __n) \\\n+          { return __name##Allocator(_M_data_allocator).allocate(__n); } \\\n+        void __name##_deallocate(_Tp* __p, size_t __n) \\\n+          { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }\n+  __ROPE_DEFINE_ALLOCS(_Allocator);\n+# undef __ROPE_DEFINE_ALLOC\n+};\n+\n+// Specialization for allocators that have the property that we don't\n+//  actually have to store an allocator object.  \n+template <class _CharT, class _Allocator>\n+class _Rope_rep_alloc_base<_CharT,_Allocator,true> {\n+public:\n+  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+  _Rope_rep_alloc_base(size_t __size, const allocator_type&)\n+                : _M_size(__size) {}\n+  size_t _M_size;\n+  \n+protected:\n+\n+# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n+        typedef typename \\\n+          _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \\\n+        typedef typename \\\n+          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n+        static _Tp* __name##_allocate(size_t __n) \\\n+                { return __name##Alloc::allocate(__n); } \\\n+        void __name##_deallocate(_Tp *__p, size_t __n) \\\n+                { __name##Alloc::deallocate(__p, __n); }\n+  __ROPE_DEFINE_ALLOCS(_Allocator);\n+# undef __ROPE_DEFINE_ALLOC\n+};\n+\n+template <class _CharT, class _Alloc>\n+struct _Rope_rep_base\n+  : public _Rope_rep_alloc_base<_CharT,_Alloc,\n+                                _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n+{\n+  typedef _Rope_rep_alloc_base<_CharT,_Alloc,\n+                               _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n+          _Base;\n+  typedef typename _Base::allocator_type allocator_type;\n+  _Rope_rep_base(size_t __size, const allocator_type& __a)\n+    : _Base(__size, __a) {}\n+};    \n+\n+\n+template<class _CharT, class _Alloc>\n+struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n+# ifndef __GC\n+    , _Refcount_Base\n+# endif\n+{\n+    public:\n+    enum { _S_max_rope_depth = 45 };\n+    enum _Tag {_S_leaf, _S_concat, _S_substringfn, _S_function};\n+    _Tag _M_tag:8;\n+    bool _M_is_balanced:8;\n+    unsigned char _M_depth;\n+    __GC_CONST _CharT* _M_c_string;\n+    __gthread_mutex_t _M_c_string_lock;\n+                        /* Flattened version of string, if needed.  */\n+                        /* typically 0.                             */\n+                        /* If it's not 0, then the memory is owned  */\n+                        /* by this node.                            */\n+                        /* In the case of a leaf, this may point to */\n+                        /* the same memory as the data field.       */\n+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n+                        allocator_type;\n+    _Rope_RopeRep(_Tag __t, int __d, bool __b, size_t __size,\n+                  allocator_type __a)\n+        : _Rope_rep_base<_CharT,_Alloc>(__size, __a),\n+#         ifndef __GC\n+          _Refcount_Base(1),\n+#         endif\n+          _M_tag(__t), _M_is_balanced(__b), _M_depth(__d), _M_c_string(0)\n+#ifdef __GTHREAD_MUTEX_INIT\n+    {\n+\t// Do not copy a POSIX/gthr mutex once in use.  However, bits are bits.\n+\t__gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n+\t_M_c_string_lock = __tmp;\n+    }\n+#else\n+    { __GTHREAD_MUTEX_INIT_FUNCTION (&_M_c_string_lock); }\n+#endif\n+#   ifdef __GC\n+        void _M_incr () {}\n+#   endif\n+        static void _S_free_string(__GC_CONST _CharT*, size_t __len,\n+                                   allocator_type __a);\n+#       define __STL_FREE_STRING(__s, __l, __a) _S_free_string(__s, __l, __a);\n+                        // Deallocate data section of a leaf.\n+                        // This shouldn't be a member function.\n+                        // But its hard to do anything else at the\n+                        // moment, because it's templatized w.r.t.\n+                        // an allocator.\n+                        // Does nothing if __GC is defined.\n+#   ifndef __GC\n+          void _M_free_c_string();\n+          void _M_free_tree();\n+                        // Deallocate t. Assumes t is not 0.\n+          void _M_unref_nonnil()\n+          {\n+              if (0 == _M_decr()) _M_free_tree();\n+          }\n+          void _M_ref_nonnil()\n+          {\n+              _M_incr();\n+          }\n+          static void _S_unref(_Rope_RopeRep* __t)\n+          {\n+              if (0 != __t) {\n+                  __t->_M_unref_nonnil();\n+              }\n+          }\n+          static void _S_ref(_Rope_RopeRep* __t)\n+          {\n+              if (0 != __t) __t->_M_incr();\n+          }\n+          static void _S_free_if_unref(_Rope_RopeRep* __t)\n+          {\n+              if (0 != __t && 0 == __t->_M_ref_count) __t->_M_free_tree();\n+          }\n+#   else /* __GC */\n+          void _M_unref_nonnil() {}\n+          void _M_ref_nonnil() {}\n+          static void _S_unref(_Rope_RopeRep*) {}\n+          static void _S_ref(_Rope_RopeRep*) {}\n+          static void _S_free_if_unref(_Rope_RopeRep*) {}\n+#   endif\n+\n+};\n+\n+template<class _CharT, class _Alloc>\n+struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {\n+  public:\n+    // Apparently needed by VC++\n+    // The data fields of leaves are allocated with some\n+    // extra space, to accommodate future growth and for basic\n+    // character types, to hold a trailing eos character.\n+    enum { _S_alloc_granularity = 8 };\n+    static size_t _S_rounded_up_size(size_t __n) {\n+        size_t __size_with_eos;\n+             \n+        if (_S_is_basic_char_type((_CharT*)0)) {\n+            __size_with_eos = __n + 1;\n+        } else {\n+            __size_with_eos = __n;\n+        }\n+#       ifdef __GC\n+           return __size_with_eos;\n+#       else\n+           // Allow slop for in-place expansion.\n+           return (__size_with_eos + _S_alloc_granularity-1)\n+                        &~ (_S_alloc_granularity-1);\n+#       endif\n+    }\n+    __GC_CONST _CharT* _M_data; /* Not necessarily 0 terminated. */\n+                                /* The allocated size is         */\n+                                /* _S_rounded_up_size(size), except */\n+                                /* in the GC case, in which it   */\n+                                /* doesn't matter.               */\n+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n+                        allocator_type;\n+    _Rope_RopeLeaf(__GC_CONST _CharT* __d, size_t __size, allocator_type __a)\n+        : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_leaf,\n+\t\t\t\t       0, true, __size, __a),\n+          _M_data(__d)\n+        {\n+        if (_S_is_basic_char_type((_CharT *)0)) {\n+            // already eos terminated.\n+            this->_M_c_string = __d;\n+        }\n+    }\n+        // The constructor assumes that d has been allocated with\n+        // the proper allocator and the properly padded size.\n+        // In contrast, the destructor deallocates the data:\n+# ifndef __GC\n+    ~_Rope_RopeLeaf() {\n+        if (_M_data != this->_M_c_string) {\n+            _M_free_c_string();\n+        }\n+        __STL_FREE_STRING(_M_data, this->_M_size, get_allocator());\n+    }\n+# endif\n+};\n+\n+template<class _CharT, class _Alloc>\n+struct _Rope_RopeConcatenation : public _Rope_RopeRep<_CharT,_Alloc> {\n+  public:\n+    _Rope_RopeRep<_CharT,_Alloc>* _M_left;\n+    _Rope_RopeRep<_CharT,_Alloc>* _M_right;\n+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n+                        allocator_type;\n+    _Rope_RopeConcatenation(_Rope_RopeRep<_CharT,_Alloc>* __l,\n+                             _Rope_RopeRep<_CharT,_Alloc>* __r,\n+                             allocator_type __a)\n+\n+      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_concat,\n+                                     std::max(__l->_M_depth, __r->_M_depth) + 1,\n+                                     false,\n+                                     __l->_M_size + __r->_M_size, __a),\n+        _M_left(__l), _M_right(__r)\n+      {}\n+# ifndef __GC\n+    ~_Rope_RopeConcatenation() {\n+        _M_free_c_string();\n+        _M_left->_M_unref_nonnil();\n+        _M_right->_M_unref_nonnil();\n+    }\n+# endif\n+};\n+\n+template<class _CharT, class _Alloc>\n+struct _Rope_RopeFunction : public _Rope_RopeRep<_CharT,_Alloc> {\n+  public:\n+    char_producer<_CharT>* _M_fn;\n+#   ifndef __GC\n+      bool _M_delete_when_done; // Char_producer is owned by the\n+                                // rope and should be explicitly\n+                                // deleted when the rope becomes\n+                                // inaccessible.\n+#   else\n+      // In the GC case, we either register the rope for\n+      // finalization, or not.  Thus the field is unnecessary;\n+      // the information is stored in the collector data structures.\n+      // We do need a finalization procedure to be invoked by the\n+      // collector.\n+      static void _S_fn_finalization_proc(void * __tree, void *) {\n+        delete ((_Rope_RopeFunction *)__tree) -> _M_fn;\n+      }\n+#   endif\n+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n+                                        allocator_type;\n+    _Rope_RopeFunction(char_producer<_CharT>* __f, size_t __size,\n+                        bool __d, allocator_type __a)\n+      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_function,\n+\t\t\t\t     0, true, __size, __a)\n+      , _M_fn(__f)\n+#       ifndef __GC\n+      , _M_delete_when_done(__d)\n+#       endif\n+    {\n+#       ifdef __GC\n+            if (__d) {\n+                GC_REGISTER_FINALIZER(\n+                  this, _Rope_RopeFunction::_S_fn_finalization_proc, 0, 0, 0);\n+            }\n+#       endif\n+    }\n+# ifndef __GC\n+    ~_Rope_RopeFunction() {\n+          _M_free_c_string();\n+          if (_M_delete_when_done) {\n+              delete _M_fn;\n+          }\n+    }\n+# endif\n+};\n+// Substring results are usually represented using just\n+// concatenation nodes.  But in the case of very long flat ropes\n+// or ropes with a functional representation that isn't practical.\n+// In that case, we represent the __result as a special case of\n+// RopeFunction, whose char_producer points back to the rope itself.\n+// In all cases except repeated substring operations and\n+// deallocation, we treat the __result as a RopeFunction.\n+template<class _CharT, class _Alloc>\n+struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n+                             public char_producer<_CharT> {\n+  public:\n+    // XXX this whole class should be rewritten.\n+    _Rope_RopeRep<_CharT,_Alloc>* _M_base;      // not 0\n+    size_t _M_start;\n+    virtual void operator()(size_t __start_pos, size_t __req_len,\n+                            _CharT* __buffer) {\n+        switch(_M_base->_M_tag) {\n+            case _Rope_RopeFunction<_CharT,_Alloc>::_S_function:\n+            case _Rope_RopeFunction<_CharT,_Alloc>::_S_substringfn:\n+              {\n+                char_producer<_CharT>* __fn =\n+                        ((_Rope_RopeFunction<_CharT,_Alloc>*)_M_base)->_M_fn;\n+                (*__fn)(__start_pos + _M_start, __req_len, __buffer);\n+              }\n+              break;\n+            case _Rope_RopeFunction<_CharT,_Alloc>::_S_leaf:\n+              {\n+                __GC_CONST _CharT* __s =\n+                        ((_Rope_RopeLeaf<_CharT,_Alloc>*)_M_base)->_M_data;\n+                uninitialized_copy_n(__s + __start_pos + _M_start, __req_len,\n+                                     __buffer);\n+              }\n+              break;\n+            default:\n+\t      break;\n+        }\n+    }\n+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n+        allocator_type;\n+    _Rope_RopeSubstring(_Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,\n+                          size_t __l, allocator_type __a)\n+      : _Rope_RopeFunction<_CharT,_Alloc>(this, __l, false, __a),\n+        char_producer<_CharT>(),\n+        _M_base(__b),\n+        _M_start(__s)\n+    {\n+#       ifndef __GC\n+            _M_base->_M_ref_nonnil();\n+#       endif\n+        this->_M_tag = _Rope_RopeFunction<_CharT,_Alloc>::_S_substringfn;\n+    }\n+    virtual ~_Rope_RopeSubstring()\n+      { \n+#       ifndef __GC\n+          _M_base->_M_unref_nonnil();\n+          // _M_free_c_string();  -- done by parent class\n+#       endif\n+      }\n+};\n+\n+\n+// Self-destructing pointers to Rope_rep.\n+// These are not conventional smart pointers.  Their\n+// only purpose in life is to ensure that unref is called\n+// on the pointer either at normal exit or if an exception\n+// is raised.  It is the caller's responsibility to\n+// adjust reference counts when these pointers are initialized\n+// or assigned to.  (This convention significantly reduces\n+// the number of potentially expensive reference count\n+// updates.)\n+#ifndef __GC\n+  template<class _CharT, class _Alloc>\n+  struct _Rope_self_destruct_ptr {\n+    _Rope_RopeRep<_CharT,_Alloc>* _M_ptr;\n+    ~_Rope_self_destruct_ptr() \n+      { _Rope_RopeRep<_CharT,_Alloc>::_S_unref(_M_ptr); }\n+#ifdef __EXCEPTIONS\n+        _Rope_self_destruct_ptr() : _M_ptr(0) {};\n+#else\n+        _Rope_self_destruct_ptr() {};\n+#endif\n+    _Rope_self_destruct_ptr(_Rope_RopeRep<_CharT,_Alloc>* __p) : _M_ptr(__p) {}\n+    _Rope_RopeRep<_CharT,_Alloc>& operator*() { return *_M_ptr; }\n+    _Rope_RopeRep<_CharT,_Alloc>* operator->() { return _M_ptr; }\n+    operator _Rope_RopeRep<_CharT,_Alloc>*() { return _M_ptr; }\n+    _Rope_self_destruct_ptr& operator= (_Rope_RopeRep<_CharT,_Alloc>* __x)\n+        { _M_ptr = __x; return *this; }\n+  };\n+#endif\n+\n+// Dereferencing a nonconst iterator has to return something\n+// that behaves almost like a reference.  It's not possible to\n+// return an actual reference since assignment requires extra\n+// work.  And we would get into the same problems as with the\n+// CD2 version of basic_string.\n+template<class _CharT, class _Alloc>\n+class _Rope_char_ref_proxy {\n+    friend class rope<_CharT,_Alloc>;\n+    friend class _Rope_iterator<_CharT,_Alloc>;\n+    friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;\n+#   ifdef __GC\n+        typedef _Rope_RopeRep<_CharT,_Alloc>* _Self_destruct_ptr;\n+#   else\n+        typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;\n+#   endif\n+    typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n+    typedef rope<_CharT,_Alloc> _My_rope;\n+    size_t _M_pos;\n+    _CharT _M_current;\n+    bool _M_current_valid;\n+    _My_rope* _M_root;     // The whole rope.\n+  public:\n+    _Rope_char_ref_proxy(_My_rope* __r, size_t __p)\n+      :  _M_pos(__p), _M_current_valid(false), _M_root(__r) {}\n+    _Rope_char_ref_proxy(const _Rope_char_ref_proxy& __x)\n+      : _M_pos(__x._M_pos), _M_current_valid(false), _M_root(__x._M_root) {}\n+        // Don't preserve cache if the reference can outlive the\n+        // expression.  We claim that's not possible without calling\n+        // a copy constructor or generating reference to a proxy\n+        // reference.  We declare the latter to have undefined semantics.\n+    _Rope_char_ref_proxy(_My_rope* __r, size_t __p, _CharT __c)\n+      : _M_pos(__p), _M_current(__c), _M_current_valid(true), _M_root(__r) {}\n+    inline operator _CharT () const;\n+    _Rope_char_ref_proxy& operator= (_CharT __c);\n+    _Rope_char_ptr_proxy<_CharT,_Alloc> operator& () const;\n+    _Rope_char_ref_proxy& operator= (const _Rope_char_ref_proxy& __c) {\n+        return operator=((_CharT)__c); \n+    }\n+};\n+\n+template<class _CharT, class __Alloc>\n+inline void swap(_Rope_char_ref_proxy <_CharT, __Alloc > __a,\n+                 _Rope_char_ref_proxy <_CharT, __Alloc > __b) {\n+    _CharT __tmp = __a;\n+    __a = __b;\n+    __b = __tmp;\n+}\n+\n+template<class _CharT, class _Alloc>\n+class _Rope_char_ptr_proxy {\n+    // XXX this class should be rewritten.\n+    friend class _Rope_char_ref_proxy<_CharT,_Alloc>;\n+    size_t _M_pos;\n+    rope<_CharT,_Alloc>* _M_root;     // The whole rope.\n+  public:\n+    _Rope_char_ptr_proxy(const _Rope_char_ref_proxy<_CharT,_Alloc>& __x) \n+      : _M_pos(__x._M_pos), _M_root(__x._M_root) {}\n+    _Rope_char_ptr_proxy(const _Rope_char_ptr_proxy& __x)\n+      : _M_pos(__x._M_pos), _M_root(__x._M_root) {}\n+    _Rope_char_ptr_proxy() {}\n+    _Rope_char_ptr_proxy(_CharT* __x) : _M_root(0), _M_pos(0) {\n+    }\n+    _Rope_char_ptr_proxy& \n+    operator= (const _Rope_char_ptr_proxy& __x) {\n+        _M_pos = __x._M_pos;\n+        _M_root = __x._M_root;\n+        return *this;\n+    }\n+    template<class _CharT2, class _Alloc2>\n+    friend bool operator== (const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __x,\n+                            const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __y);\n+    _Rope_char_ref_proxy<_CharT,_Alloc> operator*() const {\n+        return _Rope_char_ref_proxy<_CharT,_Alloc>(_M_root, _M_pos);\n+    }\n+};\n+\n+\n+// Rope iterators:\n+// Unlike in the C version, we cache only part of the stack\n+// for rope iterators, since they must be efficiently copyable.\n+// When we run out of cache, we have to reconstruct the iterator\n+// value.\n+// Pointers from iterators are not included in reference counts.\n+// Iterators are assumed to be thread private.  Ropes can\n+// be shared.\n+\n+template<class _CharT, class _Alloc>\n+class _Rope_iterator_base\n+  : public iterator<std::random_access_iterator_tag, _CharT>\n+{\n+    friend class rope<_CharT,_Alloc>;\n+  public:\n+    typedef _Alloc _allocator_type; // used in _Rope_rotate, VC++ workaround\n+    typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n+        // Borland doesn't want this to be protected.\n+  protected:\n+    enum { _S_path_cache_len = 4 }; // Must be <= 9.\n+    enum { _S_iterator_buf_len = 15 };\n+    size_t _M_current_pos;\n+    _RopeRep* _M_root;     // The whole rope.\n+    size_t _M_leaf_pos;    // Starting position for current leaf\n+    __GC_CONST _CharT* _M_buf_start;\n+                        // Buffer possibly\n+                        // containing current char.\n+    __GC_CONST _CharT* _M_buf_ptr;\n+                        // Pointer to current char in buffer.\n+                        // != 0 ==> buffer valid.\n+    __GC_CONST _CharT* _M_buf_end;\n+                        // One past __last valid char in buffer.\n+    // What follows is the path cache.  We go out of our\n+    // way to make this compact.\n+    // Path_end contains the bottom section of the path from\n+    // the root to the current leaf.\n+    const _RopeRep* _M_path_end[_S_path_cache_len];\n+    int _M_leaf_index;     // Last valid __pos in path_end;\n+                        // _M_path_end[0] ... _M_path_end[leaf_index-1]\n+                        // point to concatenation nodes.\n+    unsigned char _M_path_directions;\n+                          // (path_directions >> __i) & 1 is 1\n+                          // iff we got from _M_path_end[leaf_index - __i - 1]\n+                          // to _M_path_end[leaf_index - __i] by going to the\n+                          // __right. Assumes path_cache_len <= 9.\n+    _CharT _M_tmp_buf[_S_iterator_buf_len];\n+                        // Short buffer for surrounding chars.\n+                        // This is useful primarily for \n+                        // RopeFunctions.  We put the buffer\n+                        // here to avoid locking in the\n+                        // multithreaded case.\n+    // The cached path is generally assumed to be valid\n+    // only if the buffer is valid.\n+    static void _S_setbuf(_Rope_iterator_base& __x);\n+                                        // Set buffer contents given\n+                                        // path cache.\n+    static void _S_setcache(_Rope_iterator_base& __x);\n+                                        // Set buffer contents and\n+                                        // path cache.\n+    static void _S_setcache_for_incr(_Rope_iterator_base& __x);\n+                                        // As above, but assumes path\n+                                        // cache is valid for previous posn.\n+    _Rope_iterator_base() {}\n+    _Rope_iterator_base(_RopeRep* __root, size_t __pos)\n+      : _M_current_pos(__pos), _M_root(__root), _M_buf_ptr(0) {}\n+    void _M_incr(size_t __n);\n+    void _M_decr(size_t __n);\n+  public:\n+    size_t index() const { return _M_current_pos; }\n+    _Rope_iterator_base(const _Rope_iterator_base& __x) {\n+        if (0 != __x._M_buf_ptr) {\n+            *this = __x;\n+        } else {\n+            _M_current_pos = __x._M_current_pos;\n+            _M_root = __x._M_root;\n+            _M_buf_ptr = 0;\n+        }\n+    }\n+};\n+\n+template<class _CharT, class _Alloc> class _Rope_iterator;\n+\n+template<class _CharT, class _Alloc>\n+class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n+    friend class rope<_CharT,_Alloc>;\n+  protected:\n+      typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n+      // The one from the base class may not be directly visible.\n+    _Rope_const_iterator(const _RopeRep* __root, size_t __pos):\n+                   _Rope_iterator_base<_CharT,_Alloc>(\n+                     const_cast<_RopeRep*>(__root), __pos)\n+                   // Only nonconst iterators modify root ref count\n+    {}\n+  public:\n+    typedef _CharT reference;   // Really a value.  Returning a reference\n+                                // Would be a mess, since it would have\n+                                // to be included in refcount.\n+    typedef const _CharT* pointer;\n+\n+  public:\n+    _Rope_const_iterator() {};\n+    _Rope_const_iterator(const _Rope_const_iterator& __x) :\n+                                _Rope_iterator_base<_CharT,_Alloc>(__x) { }\n+    _Rope_const_iterator(const _Rope_iterator<_CharT,_Alloc>& __x);\n+    _Rope_const_iterator(const rope<_CharT,_Alloc>& __r, size_t __pos) :\n+        _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos) {}\n+    _Rope_const_iterator& operator= (const _Rope_const_iterator& __x) {\n+        if (0 != __x._M_buf_ptr) {\n+            *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;\n+        } else {\n+            this->_M_current_pos = __x._M_current_pos;\n+            this->_M_root = __x._M_root;\n+            this->_M_buf_ptr = 0;\n+        }\n+        return(*this);\n+    }\n+    reference operator*() {\n+        if (0 == this->_M_buf_ptr) _S_setcache(*this);\n+        return *this->_M_buf_ptr;\n+    }\n+    _Rope_const_iterator& operator++() {\n+        __GC_CONST _CharT* __next;\n+        if (0 != this->_M_buf_ptr\n+\t    && (__next = this->_M_buf_ptr + 1) < this->_M_buf_end) {\n+            this->_M_buf_ptr = __next;\n+            ++this->_M_current_pos;\n+        } else {\n+            _M_incr(1);\n+        }\n+        return *this;\n+    }\n+    _Rope_const_iterator& operator+=(ptrdiff_t __n) {\n+        if (__n >= 0) {\n+            _M_incr(__n);\n+        } else {\n+            _M_decr(-__n);\n+        }\n+        return *this;\n+    }\n+    _Rope_const_iterator& operator--() {\n+        _M_decr(1);\n+        return *this;\n+    }\n+    _Rope_const_iterator& operator-=(ptrdiff_t __n) {\n+        if (__n >= 0) {\n+            _M_decr(__n);\n+        } else {\n+            _M_incr(-__n);\n+        }\n+        return *this;\n+    }\n+    _Rope_const_iterator operator++(int) {\n+        size_t __old_pos = this->_M_current_pos;\n+        _M_incr(1);\n+        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);\n+        // This makes a subsequent dereference expensive.\n+        // Perhaps we should instead copy the iterator\n+        // if it has a valid cache?\n+    }\n+    _Rope_const_iterator operator--(int) {\n+        size_t __old_pos = this->_M_current_pos;\n+        _M_decr(1);\n+        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);\n+    }\n+    template<class _CharT2, class _Alloc2>\n+    friend _Rope_const_iterator<_CharT2,_Alloc2> operator-\n+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n+         ptrdiff_t __n);\n+    template<class _CharT2, class _Alloc2>\n+    friend _Rope_const_iterator<_CharT2,_Alloc2> operator+\n+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n+         ptrdiff_t __n);\n+    template<class _CharT2, class _Alloc2>\n+    friend _Rope_const_iterator<_CharT2,_Alloc2> operator+\n+        (ptrdiff_t __n,\n+         const _Rope_const_iterator<_CharT2,_Alloc2>& __x);\n+    reference operator[](size_t __n) {\n+        return rope<_CharT,_Alloc>::_S_fetch(this->_M_root,\n+\t\t\t\t\t     this->_M_current_pos + __n);\n+    }\n+\n+    template<class _CharT2, class _Alloc2>\n+    friend bool operator==\n+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n+         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n+    template<class _CharT2, class _Alloc2>\n+    friend bool operator< \n+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n+         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n+    template<class _CharT2, class _Alloc2>\n+    friend ptrdiff_t operator-\n+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n+         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n+};\n+\n+template<class _CharT, class _Alloc>\n+class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n+    friend class rope<_CharT,_Alloc>;\n+  protected:\n+    typedef typename _Rope_iterator_base<_CharT,_Alloc>::_RopeRep _RopeRep;\n+    rope<_CharT,_Alloc>* _M_root_rope;\n+        // root is treated as a cached version of this,\n+        // and is used to detect changes to the underlying\n+        // rope.\n+        // Root is included in the reference count.\n+        // This is necessary so that we can detect changes reliably.\n+        // Unfortunately, it requires careful bookkeeping for the\n+        // nonGC case.\n+    _Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos)\n+      : _Rope_iterator_base<_CharT,_Alloc>(__r->_M_tree_ptr, __pos),\n+        _M_root_rope(__r) \n+      { _RopeRep::_S_ref(this->_M_root);\n+        if (!(__r -> empty()))_S_setcache(*this); }\n+\n+    void _M_check();\n+  public:\n+    typedef _Rope_char_ref_proxy<_CharT,_Alloc>  reference;\n+    typedef _Rope_char_ref_proxy<_CharT,_Alloc>* pointer;\n+\n+  public:\n+    rope<_CharT,_Alloc>& container() { return *_M_root_rope; }\n+    _Rope_iterator() {\n+        this->_M_root = 0;  // Needed for reference counting.\n+    };\n+    _Rope_iterator(const _Rope_iterator& __x) :\n+        _Rope_iterator_base<_CharT,_Alloc>(__x) {\n+        _M_root_rope = __x._M_root_rope;\n+        _RopeRep::_S_ref(this->_M_root);\n+    }\n+    _Rope_iterator(rope<_CharT,_Alloc>& __r, size_t __pos);\n+    ~_Rope_iterator() {\n+        _RopeRep::_S_unref(this->_M_root);\n+    }\n+    _Rope_iterator& operator= (const _Rope_iterator& __x) {\n+        _RopeRep* __old = this->_M_root;\n+\n+        _RopeRep::_S_ref(__x._M_root);\n+        if (0 != __x._M_buf_ptr) {\n+            _M_root_rope = __x._M_root_rope;\n+            *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;\n+        } else {\n+\t    this->_M_current_pos = __x._M_current_pos;\n+            this->_M_root = __x._M_root;\n+            _M_root_rope = __x._M_root_rope;\n+            this->_M_buf_ptr = 0;\n+        }\n+        _RopeRep::_S_unref(__old);\n+        return(*this);\n+    }\n+    reference operator*() {\n+        _M_check();\n+        if (0 == this->_M_buf_ptr) {\n+            return _Rope_char_ref_proxy<_CharT,_Alloc>(\n+               _M_root_rope, this->_M_current_pos);\n+        } else {\n+            return _Rope_char_ref_proxy<_CharT,_Alloc>(\n+               _M_root_rope, this->_M_current_pos, *this->_M_buf_ptr);\n+        }\n+    }\n+    _Rope_iterator& operator++() {\n+        _M_incr(1);\n+        return *this;\n+    }\n+    _Rope_iterator& operator+=(ptrdiff_t __n) {\n+        if (__n >= 0) {\n+            _M_incr(__n);\n+        } else {\n+            _M_decr(-__n);\n+        }\n+        return *this;\n+    }\n+    _Rope_iterator& operator--() {\n+        _M_decr(1);\n+        return *this;\n+    }\n+    _Rope_iterator& operator-=(ptrdiff_t __n) {\n+        if (__n >= 0) {\n+            _M_decr(__n);\n+        } else {\n+            _M_incr(-__n);\n+        }\n+        return *this;\n+    }\n+    _Rope_iterator operator++(int) {\n+        size_t __old_pos = this->_M_current_pos;\n+        _M_incr(1);\n+        return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);\n+    }\n+    _Rope_iterator operator--(int) {\n+        size_t __old_pos = this->_M_current_pos;\n+        _M_decr(1);\n+        return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);\n+    }\n+    reference operator[](ptrdiff_t __n) {\n+        return _Rope_char_ref_proxy<_CharT,_Alloc>(\n+          _M_root_rope, this->_M_current_pos + __n);\n+    }\n+\n+    template<class _CharT2, class _Alloc2>\n+    friend bool operator==\n+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n+         const _Rope_iterator<_CharT2,_Alloc2>& __y);\n+    template<class _CharT2, class _Alloc2>\n+    friend bool operator<\n+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n+         const _Rope_iterator<_CharT2,_Alloc2>& __y);\n+    template<class _CharT2, class _Alloc2>\n+    friend ptrdiff_t operator-\n+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n+         const _Rope_iterator<_CharT2,_Alloc2>& __y);\n+    template<class _CharT2, class _Alloc2>\n+    friend _Rope_iterator<_CharT2,_Alloc2> operator-\n+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n+         ptrdiff_t __n);\n+    template<class _CharT2, class _Alloc2>\n+    friend _Rope_iterator<_CharT2,_Alloc2> operator+\n+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n+         ptrdiff_t __n);\n+    template<class _CharT2, class _Alloc2>\n+    friend _Rope_iterator<_CharT2,_Alloc2> operator+\n+        (ptrdiff_t __n,\n+         const _Rope_iterator<_CharT2,_Alloc2>& __x);\n+};\n+\n+//  The rope base class encapsulates\n+//  the differences between SGI-style allocators and standard-conforming\n+//  allocators.\n+\n+// Base class for ordinary allocators.\n+template <class _CharT, class _Allocator, bool _IsStatic>\n+class _Rope_alloc_base {\n+public:\n+  typedef _Rope_RopeRep<_CharT,_Allocator> _RopeRep;\n+  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return _M_data_allocator; }\n+  _Rope_alloc_base(_RopeRep *__t, const allocator_type& __a)\n+        : _M_tree_ptr(__t), _M_data_allocator(__a) {}\n+  _Rope_alloc_base(const allocator_type& __a)\n+        : _M_data_allocator(__a) {}\n+  \n+protected:\n+  // The only data members of a rope:\n+    allocator_type _M_data_allocator;\n+    _RopeRep* _M_tree_ptr;\n+\n+# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n+        typedef typename \\\n+          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n+        _Tp* __name##_allocate(size_t __n) const \\\n+          { return __name##Allocator(_M_data_allocator).allocate(__n); } \\\n+        void __name##_deallocate(_Tp *__p, size_t __n) const \\\n+                { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }\n+  __ROPE_DEFINE_ALLOCS(_Allocator)\n+# undef __ROPE_DEFINE_ALLOC\n+};\n+\n+// Specialization for allocators that have the property that we don't\n+//  actually have to store an allocator object.  \n+template <class _CharT, class _Allocator>\n+class _Rope_alloc_base<_CharT,_Allocator,true> {\n+public:\n+  typedef _Rope_RopeRep<_CharT,_Allocator> _RopeRep;\n+  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+  _Rope_alloc_base(_RopeRep *__t, const allocator_type&)\n+                : _M_tree_ptr(__t) {}\n+  _Rope_alloc_base(const allocator_type&) {}\n+  \n+protected:\n+  // The only data member of a rope:\n+    _RopeRep *_M_tree_ptr;\n+\n+# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n+        typedef typename \\\n+          _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \\\n+        typedef typename \\\n+          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n+        static _Tp* __name##_allocate(size_t __n) \\\n+          { return __name##Alloc::allocate(__n); } \\\n+        static void __name##_deallocate(_Tp *__p, size_t __n) \\\n+          { __name##Alloc::deallocate(__p, __n); }\n+  __ROPE_DEFINE_ALLOCS(_Allocator)\n+# undef __ROPE_DEFINE_ALLOC\n+};\n+\n+template <class _CharT, class _Alloc>\n+struct _Rope_base \n+  : public _Rope_alloc_base<_CharT,_Alloc,\n+                            _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n+{\n+  typedef _Rope_alloc_base<_CharT,_Alloc,\n+                            _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n+          _Base;\n+  typedef typename _Base::allocator_type allocator_type;\n+  typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n+        // The one in _Base may not be visible due to template rules.\n+  _Rope_base(_RopeRep* __t, const allocator_type& __a) : _Base(__t, __a) {}\n+  _Rope_base(const allocator_type& __a) : _Base(__a) {}\n+};    \n+\n+\n+/**\n+ *  This is an SGI extension.\n+ *  @ingroup SGIextensions\n+ *  @doctodo\n+*/\n+template <class _CharT, class _Alloc>\n+class rope : public _Rope_base<_CharT,_Alloc> {\n+    public:\n+        typedef _CharT value_type;\n+        typedef ptrdiff_t difference_type;\n+        typedef size_t size_type;\n+        typedef _CharT const_reference;\n+        typedef const _CharT* const_pointer;\n+        typedef _Rope_iterator<_CharT,_Alloc> iterator;\n+        typedef _Rope_const_iterator<_CharT,_Alloc> const_iterator;\n+        typedef _Rope_char_ref_proxy<_CharT,_Alloc> reference;\n+        typedef _Rope_char_ptr_proxy<_CharT,_Alloc> pointer;\n+\n+        friend class _Rope_iterator<_CharT,_Alloc>;\n+        friend class _Rope_const_iterator<_CharT,_Alloc>;\n+        friend struct _Rope_RopeRep<_CharT,_Alloc>;\n+        friend class _Rope_iterator_base<_CharT,_Alloc>;\n+        friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;\n+        friend class _Rope_char_ref_proxy<_CharT,_Alloc>;\n+        friend struct _Rope_RopeSubstring<_CharT,_Alloc>;\n+\n+    protected:\n+        typedef _Rope_base<_CharT,_Alloc> _Base;\n+        typedef typename _Base::allocator_type allocator_type;\n+        using _Base::_M_tree_ptr;\n+        typedef __GC_CONST _CharT* _Cstrptr;\n+\n+        static _CharT _S_empty_c_str[1];\n+\n+        static bool _S_is0(_CharT __c) { return __c == _S_eos((_CharT*)0); }\n+        enum { _S_copy_max = 23 };\n+                // For strings shorter than _S_copy_max, we copy to\n+                // concatenate.\n+\n+        typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n+        typedef _Rope_RopeConcatenation<_CharT,_Alloc> _RopeConcatenation;\n+        typedef _Rope_RopeLeaf<_CharT,_Alloc> _RopeLeaf;\n+        typedef _Rope_RopeFunction<_CharT,_Alloc> _RopeFunction;\n+        typedef _Rope_RopeSubstring<_CharT,_Alloc> _RopeSubstring;\n+\n+        // Retrieve a character at the indicated position.\n+        static _CharT _S_fetch(_RopeRep* __r, size_type __pos);\n+\n+#       ifndef __GC\n+            // Obtain a pointer to the character at the indicated position.\n+            // The pointer can be used to change the character.\n+            // If such a pointer cannot be produced, as is frequently the\n+            // case, 0 is returned instead.\n+            // (Returns nonzero only if all nodes in the path have a refcount\n+            // of 1.)\n+            static _CharT* _S_fetch_ptr(_RopeRep* __r, size_type __pos);\n+#       endif\n+\n+        static bool _S_apply_to_pieces(\n+                                // should be template parameter\n+                                _Rope_char_consumer<_CharT>& __c,\n+                                const _RopeRep* __r,\n+                                size_t __begin, size_t __end);\n+                                // begin and end are assumed to be in range.\n+\n+#       ifndef __GC\n+          static void _S_unref(_RopeRep* __t)\n+          {\n+              _RopeRep::_S_unref(__t);\n+          }\n+          static void _S_ref(_RopeRep* __t)\n+          {\n+              _RopeRep::_S_ref(__t);\n+          }\n+#       else /* __GC */\n+          static void _S_unref(_RopeRep*) {}\n+          static void _S_ref(_RopeRep*) {}\n+#       endif\n+\n+\n+#       ifdef __GC\n+            typedef _Rope_RopeRep<_CharT,_Alloc>* _Self_destruct_ptr;\n+#       else\n+            typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;\n+#       endif\n+\n+        // _Result is counted in refcount.\n+        static _RopeRep* _S_substring(_RopeRep* __base,\n+                                    size_t __start, size_t __endp1);\n+\n+        static _RopeRep* _S_concat_char_iter(_RopeRep* __r,\n+                                          const _CharT* __iter, size_t __slen);\n+                // Concatenate rope and char ptr, copying __s.\n+                // Should really take an arbitrary iterator.\n+                // Result is counted in refcount.\n+        static _RopeRep* _S_destr_concat_char_iter(_RopeRep* __r,\n+                                          const _CharT* __iter, size_t __slen)\n+                // As above, but one reference to __r is about to be\n+                // destroyed.  Thus the pieces may be recycled if all\n+                // relevant reference counts are 1.\n+#           ifdef __GC\n+                // We can't really do anything since refcounts are unavailable.\n+                { return _S_concat_char_iter(__r, __iter, __slen); }\n+#           else\n+                ;\n+#           endif\n+\n+        static _RopeRep* _S_concat(_RopeRep* __left, _RopeRep* __right);\n+                // General concatenation on _RopeRep.  _Result\n+                // has refcount of 1.  Adjusts argument refcounts.\n+\n+   public:\n+        void apply_to_pieces( size_t __begin, size_t __end,\n+                              _Rope_char_consumer<_CharT>& __c) const {\n+            _S_apply_to_pieces(__c, this->_M_tree_ptr, __begin, __end);\n+        }\n+\n+\n+   protected:\n+\n+        static size_t _S_rounded_up_size(size_t __n) {\n+            return _RopeLeaf::_S_rounded_up_size(__n);\n+        }\n+\n+        static size_t _S_allocated_capacity(size_t __n) {\n+            if (_S_is_basic_char_type((_CharT*)0)) {\n+                return _S_rounded_up_size(__n) - 1;\n+            } else {\n+                return _S_rounded_up_size(__n);\n+            }\n+        }\n+                \n+        // Allocate and construct a RopeLeaf using the supplied allocator\n+        // Takes ownership of s instead of copying.\n+        static _RopeLeaf* _S_new_RopeLeaf(__GC_CONST _CharT *__s,\n+                                          size_t __size, allocator_type __a)\n+        {\n+            _RopeLeaf* __space = typename _Base::_LAllocator(__a).allocate(1);\n+            return new(__space) _RopeLeaf(__s, __size, __a);\n+        }\n+\n+        static _RopeConcatenation* _S_new_RopeConcatenation(\n+                        _RopeRep* __left, _RopeRep* __right,\n+                        allocator_type __a)\n+        {\n+            _RopeConcatenation* __space = typename _Base::_CAllocator(__a).allocate(1);\n+            return new(__space) _RopeConcatenation(__left, __right, __a);\n+        }\n+\n+        static _RopeFunction* _S_new_RopeFunction(char_producer<_CharT>* __f,\n+                size_t __size, bool __d, allocator_type __a)\n+        {\n+            _RopeFunction* __space = typename _Base::_FAllocator(__a).allocate(1);\n+            return new(__space) _RopeFunction(__f, __size, __d, __a);\n+        }\n+\n+        static _RopeSubstring* _S_new_RopeSubstring(\n+                _Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,\n+                size_t __l, allocator_type __a)\n+        {\n+            _RopeSubstring* __space = typename _Base::_SAllocator(__a).allocate(1);\n+            return new(__space) _RopeSubstring(__b, __s, __l, __a);\n+        }\n+\n+          static\n+          _RopeLeaf* _S_RopeLeaf_from_unowned_char_ptr(const _CharT *__s,\n+                       size_t __size, allocator_type __a)\n+#         define __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __size, __a) \\\n+                _S_RopeLeaf_from_unowned_char_ptr(__s, __size, __a)     \n+        {\n+            if (0 == __size) return 0;\n+            _CharT* __buf = __a.allocate(_S_rounded_up_size(__size));\n+\n+            uninitialized_copy_n(__s, __size, __buf);\n+            _S_cond_store_eos(__buf[__size]);\n+            try {\n+              return _S_new_RopeLeaf(__buf, __size, __a);\n+            }\n+            catch(...)\n+\t      {\n+\t\t_RopeRep::__STL_FREE_STRING(__buf, __size, __a);\n+\t\t__throw_exception_again;\n+\t      }\n+        }\n+            \n+\n+        // Concatenation of nonempty strings.\n+        // Always builds a concatenation node.\n+        // Rebalances if the result is too deep.\n+        // Result has refcount 1.\n+        // Does not increment left and right ref counts even though\n+        // they are referenced.\n+        static _RopeRep*\n+        _S_tree_concat(_RopeRep* __left, _RopeRep* __right);\n+\n+        // Concatenation helper functions\n+        static _RopeLeaf*\n+        _S_leaf_concat_char_iter(_RopeLeaf* __r,\n+                                 const _CharT* __iter, size_t __slen);\n+                // Concatenate by copying leaf.\n+                // should take an arbitrary iterator\n+                // result has refcount 1.\n+#       ifndef __GC\n+          static _RopeLeaf* _S_destr_leaf_concat_char_iter\n+                        (_RopeLeaf* __r, const _CharT* __iter, size_t __slen);\n+          // A version that potentially clobbers __r if __r->_M_ref_count == 1.\n+#       endif\n+\n+        private:\n+\n+        static size_t _S_char_ptr_len(const _CharT* __s);\n+                        // slightly generalized strlen\n+\n+        rope(_RopeRep* __t, const allocator_type& __a = allocator_type())\n+          : _Base(__t,__a) { }\n+\n+\n+        // Copy __r to the _CharT buffer.\n+        // Returns __buffer + __r->_M_size.\n+        // Assumes that buffer is uninitialized.\n+        static _CharT* _S_flatten(_RopeRep* __r, _CharT* __buffer);\n+\n+        // Again, with explicit starting position and length.\n+        // Assumes that buffer is uninitialized.\n+        static _CharT* _S_flatten(_RopeRep* __r,\n+                                  size_t __start, size_t __len,\n+                                  _CharT* __buffer);\n+\n+        static const unsigned long \n+          _S_min_len[_RopeRep::_S_max_rope_depth + 1];\n+\n+        static bool _S_is_balanced(_RopeRep* __r)\n+                { return (__r->_M_size >= _S_min_len[__r->_M_depth]); }\n+\n+        static bool _S_is_almost_balanced(_RopeRep* __r)\n+                { return (__r->_M_depth == 0 ||\n+                          __r->_M_size >= _S_min_len[__r->_M_depth - 1]); }\n+\n+        static bool _S_is_roughly_balanced(_RopeRep* __r)\n+                { return (__r->_M_depth <= 1 ||\n+                          __r->_M_size >= _S_min_len[__r->_M_depth - 2]); }\n+\n+        // Assumes the result is not empty.\n+        static _RopeRep* _S_concat_and_set_balanced(_RopeRep* __left,\n+                                                     _RopeRep* __right)\n+        {\n+            _RopeRep* __result = _S_concat(__left, __right);\n+            if (_S_is_balanced(__result)) __result->_M_is_balanced = true;\n+            return __result;\n+        }\n+\n+        // The basic rebalancing operation.  Logically copies the\n+        // rope.  The result has refcount of 1.  The client will\n+        // usually decrement the reference count of __r.\n+        // The result is within height 2 of balanced by the above\n+        // definition.\n+        static _RopeRep* _S_balance(_RopeRep* __r);\n+\n+        // Add all unbalanced subtrees to the forest of balanceed trees.\n+        // Used only by balance.\n+        static void _S_add_to_forest(_RopeRep*__r, _RopeRep** __forest);\n+        \n+        // Add __r to forest, assuming __r is already balanced.\n+        static void _S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest);\n+\n+        // Print to stdout, exposing structure\n+        static void _S_dump(_RopeRep* __r, int __indent = 0);\n+\n+        // Return -1, 0, or 1 if __x < __y, __x == __y, or __x > __y resp.\n+        static int _S_compare(const _RopeRep* __x, const _RopeRep* __y);\n+\n+   public:\n+        bool empty() const { return 0 == this->_M_tree_ptr; }\n+\n+        // Comparison member function.  This is public only for those\n+        // clients that need a ternary comparison.  Others\n+        // should use the comparison operators below.\n+        int compare(const rope& __y) const {\n+            return _S_compare(this->_M_tree_ptr, __y._M_tree_ptr);\n+        }\n+\n+        rope(const _CharT* __s, const allocator_type& __a = allocator_type())\n+        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, _S_char_ptr_len(__s),\n+                                                 __a),__a)\n+        { }\n+\n+        rope(const _CharT* __s, size_t __len,\n+             const allocator_type& __a = allocator_type())\n+        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __len, __a), __a)\n+        { }\n+\n+        // Should perhaps be templatized with respect to the iterator type\n+        // and use Sequence_buffer.  (It should perhaps use sequence_buffer\n+        // even now.)\n+        rope(const _CharT *__s, const _CharT *__e,\n+             const allocator_type& __a = allocator_type())\n+        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __e - __s, __a), __a)\n+        { }\n+\n+        rope(const const_iterator& __s, const const_iterator& __e,\n+             const allocator_type& __a = allocator_type())\n+        : _Base(_S_substring(__s._M_root, __s._M_current_pos,\n+                             __e._M_current_pos), __a)\n+        { }\n+\n+        rope(const iterator& __s, const iterator& __e,\n+             const allocator_type& __a = allocator_type())\n+        : _Base(_S_substring(__s._M_root, __s._M_current_pos,\n+                             __e._M_current_pos), __a)\n+        { }\n+\n+        rope(_CharT __c, const allocator_type& __a = allocator_type())\n+        : _Base(__a)\n+        {\n+            _CharT* __buf = _Data_allocate(_S_rounded_up_size(1));\n+\n+            std::_Construct(__buf, __c);\n+            try {\n+                this->_M_tree_ptr = _S_new_RopeLeaf(__buf, 1, __a);\n+            }\n+            catch(...)\n+\t      {\n+\t\t_RopeRep::__STL_FREE_STRING(__buf, 1, __a);\n+\t\t__throw_exception_again;\n+\t      }\n+        }\n+\n+        rope(size_t __n, _CharT __c,\n+             const allocator_type& __a = allocator_type());\n+\n+        rope(const allocator_type& __a = allocator_type())\n+        : _Base(0, __a) {}\n+\n+        // Construct a rope from a function that can compute its members\n+        rope(char_producer<_CharT> *__fn, size_t __len, bool __delete_fn,\n+             const allocator_type& __a = allocator_type())\n+            : _Base(__a)\n+        {\n+            this->_M_tree_ptr = (0 == __len) ?\n+               0 : _S_new_RopeFunction(__fn, __len, __delete_fn, __a);\n+        }\n+\n+        rope(const rope& __x, const allocator_type& __a = allocator_type())\n+        : _Base(__x._M_tree_ptr, __a)\n+        {\n+            _S_ref(this->_M_tree_ptr);\n+        }\n+\n+        ~rope()\n+        {\n+            _S_unref(this->_M_tree_ptr);\n+        }\n+\n+        rope& operator=(const rope& __x)\n+        {\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr = __x._M_tree_ptr;\n+            _S_ref(this->_M_tree_ptr);\n+            _S_unref(__old);\n+            return(*this);\n+        }\n+\n+        void clear()\n+        {\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = 0;\n+        }\n+\n+        void push_back(_CharT __x)\n+        {\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr\n+\t      = _S_destr_concat_char_iter(this->_M_tree_ptr, &__x, 1);\n+            _S_unref(__old);\n+        }\n+\n+        void pop_back()\n+        {\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr = \n+              _S_substring(this->_M_tree_ptr,\n+\t\t\t   0,\n+\t\t\t   this->_M_tree_ptr->_M_size - 1);\n+            _S_unref(__old);\n+        }\n+\n+        _CharT back() const\n+        {\n+            return _S_fetch(this->_M_tree_ptr, this->_M_tree_ptr->_M_size - 1);\n+        }\n+\n+        void push_front(_CharT __x)\n+        {\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            _RopeRep* __left =\n+              __STL_ROPE_FROM_UNOWNED_CHAR_PTR(&__x, 1, get_allocator());\n+            try {\n+              this->_M_tree_ptr = _S_concat(__left, this->_M_tree_ptr);\n+              _S_unref(__old);\n+              _S_unref(__left);\n+            }\n+            catch(...)\n+\t      {\n+\t\t_S_unref(__left);\n+\t\t__throw_exception_again;\n+\t      }\n+        }\n+\n+        void pop_front()\n+        {\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr\n+\t      = _S_substring(this->_M_tree_ptr, 1, this->_M_tree_ptr->_M_size);\n+            _S_unref(__old);\n+        }\n+\n+        _CharT front() const\n+        {\n+            return _S_fetch(this->_M_tree_ptr, 0);\n+        }\n+\n+        void balance()\n+        {\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr = _S_balance(this->_M_tree_ptr);\n+            _S_unref(__old);\n+        }\n+\n+        void copy(_CharT* __buffer) const {\n+            _Destroy(__buffer, __buffer + size());\n+            _S_flatten(this->_M_tree_ptr, __buffer);\n+        }\n+\n+        // This is the copy function from the standard, but\n+        // with the arguments reordered to make it consistent with the\n+        // rest of the interface.\n+        // Note that this guaranteed not to compile if the draft standard\n+        // order is assumed.\n+        size_type copy(size_type __pos, size_type __n, _CharT* __buffer) const \n+        {\n+            size_t __size = size();\n+            size_t __len = (__pos + __n > __size? __size - __pos : __n);\n+\n+            _Destroy(__buffer, __buffer + __len);\n+            _S_flatten(this->_M_tree_ptr, __pos, __len, __buffer);\n+            return __len;\n+        }\n+\n+        // Print to stdout, exposing structure.  May be useful for\n+        // performance debugging.\n+        void dump() {\n+            _S_dump(this->_M_tree_ptr);\n+        }\n+\n+        // Convert to 0 terminated string in new allocated memory.\n+        // Embedded 0s in the input do not terminate the copy.\n+        const _CharT* c_str() const;\n+\n+        // As above, but lso use the flattened representation as the\n+        // the new rope representation.\n+        const _CharT* replace_with_c_str();\n+\n+        // Reclaim memory for the c_str generated flattened string.\n+        // Intentionally undocumented, since it's hard to say when this\n+        // is safe for multiple threads.\n+        void delete_c_str () {\n+            if (0 == this->_M_tree_ptr) return;\n+            if (_RopeRep::_S_leaf == this->_M_tree_ptr->_M_tag && \n+                ((_RopeLeaf*)this->_M_tree_ptr)->_M_data == \n+                      this->_M_tree_ptr->_M_c_string) {\n+                // Representation shared\n+                return;\n+            }\n+#           ifndef __GC\n+              this->_M_tree_ptr->_M_free_c_string();\n+#           endif\n+            this->_M_tree_ptr->_M_c_string = 0;\n+        }\n+\n+        _CharT operator[] (size_type __pos) const {\n+            return _S_fetch(this->_M_tree_ptr, __pos);\n+        }\n+\n+        _CharT at(size_type __pos) const {\n+           // if (__pos >= size()) throw out_of_range;  // XXX\n+           return (*this)[__pos];\n+        }\n+\n+        const_iterator begin() const {\n+            return(const_iterator(this->_M_tree_ptr, 0));\n+        }\n+\n+        // An easy way to get a const iterator from a non-const container.\n+        const_iterator const_begin() const {\n+            return(const_iterator(this->_M_tree_ptr, 0));\n+        }\n+\n+        const_iterator end() const {\n+            return(const_iterator(this->_M_tree_ptr, size()));\n+        }\n+\n+        const_iterator const_end() const {\n+            return(const_iterator(this->_M_tree_ptr, size()));\n+        }\n+\n+        size_type size() const { \n+            return(0 == this->_M_tree_ptr? 0 : this->_M_tree_ptr->_M_size);\n+        }\n+\n+        size_type length() const {\n+            return size();\n+        }\n+\n+        size_type max_size() const {\n+            return _S_min_len[_RopeRep::_S_max_rope_depth-1] - 1;\n+            //  Guarantees that the result can be sufficirntly\n+            //  balanced.  Longer ropes will probably still work,\n+            //  but it's harder to make guarantees.\n+        }\n+\n+        typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+\n+        const_reverse_iterator rbegin() const {\n+            return const_reverse_iterator(end());\n+        }\n+\n+        const_reverse_iterator const_rbegin() const {\n+            return const_reverse_iterator(end());\n+        }\n+\n+        const_reverse_iterator rend() const {\n+            return const_reverse_iterator(begin());\n+        }\n+\n+        const_reverse_iterator const_rend() const {\n+            return const_reverse_iterator(begin());\n+        }\n+\n+        template<class _CharT2, class _Alloc2>\n+        friend rope<_CharT2,_Alloc2>\n+        operator+ (const rope<_CharT2,_Alloc2>& __left,\n+                   const rope<_CharT2,_Alloc2>& __right);\n+        \n+        template<class _CharT2, class _Alloc2>\n+        friend rope<_CharT2,_Alloc2>\n+        operator+ (const rope<_CharT2,_Alloc2>& __left,\n+                   const _CharT2* __right);\n+        \n+        template<class _CharT2, class _Alloc2>\n+        friend rope<_CharT2,_Alloc2>\n+        operator+ (const rope<_CharT2,_Alloc2>& __left, _CharT2 __right);\n+        // The symmetric cases are intentionally omitted, since they're presumed\n+        // to be less common, and we don't handle them as well.\n+\n+        // The following should really be templatized.\n+        // The first argument should be an input iterator or\n+        // forward iterator with value_type _CharT.\n+        rope& append(const _CharT* __iter, size_t __n) {\n+            _RopeRep* __result = \n+              _S_destr_concat_char_iter(this->_M_tree_ptr, __iter, __n);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+            return *this;\n+        }\n+\n+        rope& append(const _CharT* __c_string) {\n+            size_t __len = _S_char_ptr_len(__c_string);\n+            append(__c_string, __len);\n+            return(*this);\n+        }\n+\n+        rope& append(const _CharT* __s, const _CharT* __e) {\n+            _RopeRep* __result =\n+                _S_destr_concat_char_iter(this->_M_tree_ptr, __s, __e - __s);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+            return *this;\n+        }\n+\n+        rope& append(const_iterator __s, const_iterator __e) {\n+            _Self_destruct_ptr __appendee(_S_substring(\n+              __s._M_root, __s._M_current_pos, __e._M_current_pos));\n+            _RopeRep* __result = \n+              _S_concat(this->_M_tree_ptr, (_RopeRep*)__appendee);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+            return *this;\n+        }\n+\n+        rope& append(_CharT __c) {\n+            _RopeRep* __result = \n+              _S_destr_concat_char_iter(this->_M_tree_ptr, &__c, 1);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+            return *this;\n+        }\n+\n+        rope& append() { return append(_CharT()); }  // XXX why?\n+\n+        rope& append(const rope& __y) {\n+            _RopeRep* __result = _S_concat(this->_M_tree_ptr, __y._M_tree_ptr);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+            return *this;\n+        }\n+\n+        rope& append(size_t __n, _CharT __c) {\n+            rope<_CharT,_Alloc> __last(__n, __c);\n+            return append(__last);\n+        }\n+\n+        void swap(rope& __b) {\n+            _RopeRep* __tmp = this->_M_tree_ptr;\n+            this->_M_tree_ptr = __b._M_tree_ptr;\n+            __b._M_tree_ptr = __tmp;\n+        }\n+\n+\n+    protected:\n+        // Result is included in refcount.\n+        static _RopeRep* replace(_RopeRep* __old, size_t __pos1,\n+                                  size_t __pos2, _RopeRep* __r) {\n+            if (0 == __old) { _S_ref(__r); return __r; }\n+            _Self_destruct_ptr __left(\n+              _S_substring(__old, 0, __pos1));\n+            _Self_destruct_ptr __right(\n+              _S_substring(__old, __pos2, __old->_M_size));\n+            _RopeRep* __result;\n+\n+            if (0 == __r) {\n+                __result = _S_concat(__left, __right);\n+            } else {\n+                _Self_destruct_ptr __left_result(_S_concat(__left, __r));\n+                __result = _S_concat(__left_result, __right);\n+            }\n+            return __result;\n+        }\n+\n+    public:\n+        void insert(size_t __p, const rope& __r) {\n+            _RopeRep* __result = \n+              replace(this->_M_tree_ptr, __p, __p, __r._M_tree_ptr);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+        }\n+\n+        void insert(size_t __p, size_t __n, _CharT __c) {\n+            rope<_CharT,_Alloc> __r(__n,__c);\n+            insert(__p, __r);\n+        }\n+\n+        void insert(size_t __p, const _CharT* __i, size_t __n) {\n+            _Self_destruct_ptr __left(_S_substring(this->_M_tree_ptr, 0, __p));\n+            _Self_destruct_ptr __right(_S_substring(this->_M_tree_ptr,\n+\t\t\t\t\t\t    __p, size()));\n+            _Self_destruct_ptr __left_result(\n+              _S_concat_char_iter(__left, __i, __n));\n+                // _S_ destr_concat_char_iter should be safe here.\n+                // But as it stands it's probably not a win, since __left\n+                // is likely to have additional references.\n+            _RopeRep* __result = _S_concat(__left_result, __right);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+        }\n+\n+        void insert(size_t __p, const _CharT* __c_string) {\n+            insert(__p, __c_string, _S_char_ptr_len(__c_string));\n+        }\n+\n+        void insert(size_t __p, _CharT __c) {\n+            insert(__p, &__c, 1);\n+        }\n+\n+        void insert(size_t __p) {\n+            _CharT __c = _CharT();\n+            insert(__p, &__c, 1);\n+        }\n+\n+        void insert(size_t __p, const _CharT* __i, const _CharT* __j) {\n+            rope __r(__i, __j);\n+            insert(__p, __r);\n+        }\n+\n+        void insert(size_t __p, const const_iterator& __i,\n+                              const const_iterator& __j) {\n+            rope __r(__i, __j);\n+            insert(__p, __r);\n+        }\n+\n+        void insert(size_t __p, const iterator& __i,\n+                              const iterator& __j) {\n+            rope __r(__i, __j);\n+            insert(__p, __r);\n+        }\n+\n+        // (position, length) versions of replace operations:\n+\n+        void replace(size_t __p, size_t __n, const rope& __r) {\n+            _RopeRep* __result = \n+              replace(this->_M_tree_ptr, __p, __p + __n, __r._M_tree_ptr);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+        }\n+\n+        void replace(size_t __p, size_t __n, \n+                     const _CharT* __i, size_t __i_len) {\n+            rope __r(__i, __i_len);\n+            replace(__p, __n, __r);\n+        }\n+\n+        void replace(size_t __p, size_t __n, _CharT __c) {\n+            rope __r(__c);\n+            replace(__p, __n, __r);\n+        }\n+\n+        void replace(size_t __p, size_t __n, const _CharT* __c_string) {\n+            rope __r(__c_string);\n+            replace(__p, __n, __r);\n+        }\n+\n+        void replace(size_t __p, size_t __n, \n+                     const _CharT* __i, const _CharT* __j) {\n+            rope __r(__i, __j);\n+            replace(__p, __n, __r);\n+        }\n+\n+        void replace(size_t __p, size_t __n,\n+                     const const_iterator& __i, const const_iterator& __j) {\n+            rope __r(__i, __j);\n+            replace(__p, __n, __r);\n+        }\n+\n+        void replace(size_t __p, size_t __n,\n+                     const iterator& __i, const iterator& __j) {\n+            rope __r(__i, __j);\n+            replace(__p, __n, __r);\n+        }\n+\n+        // Single character variants:\n+        void replace(size_t __p, _CharT __c) {\n+            iterator __i(this, __p);\n+            *__i = __c;\n+        }\n+\n+        void replace(size_t __p, const rope& __r) {\n+            replace(__p, 1, __r);\n+        }\n+\n+        void replace(size_t __p, const _CharT* __i, size_t __i_len) {\n+            replace(__p, 1, __i, __i_len);\n+        }\n+\n+        void replace(size_t __p, const _CharT* __c_string) {\n+            replace(__p, 1, __c_string);\n+        }\n+\n+        void replace(size_t __p, const _CharT* __i, const _CharT* __j) {\n+            replace(__p, 1, __i, __j);\n+        }\n+\n+        void replace(size_t __p, const const_iterator& __i,\n+                               const const_iterator& __j) {\n+            replace(__p, 1, __i, __j);\n+        }\n+\n+        void replace(size_t __p, const iterator& __i,\n+                               const iterator& __j) {\n+            replace(__p, 1, __i, __j);\n+        }\n+\n+        // Erase, (position, size) variant.\n+        void erase(size_t __p, size_t __n) {\n+            _RopeRep* __result = replace(this->_M_tree_ptr, __p, __p + __n, 0);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n+        }\n+\n+        // Erase, single character\n+        void erase(size_t __p) {\n+            erase(__p, __p + 1);\n+        }\n+\n+        // Insert, iterator variants.  \n+        iterator insert(const iterator& __p, const rope& __r)\n+                { insert(__p.index(), __r); return __p; }\n+        iterator insert(const iterator& __p, size_t __n, _CharT __c)\n+                { insert(__p.index(), __n, __c); return __p; }\n+        iterator insert(const iterator& __p, _CharT __c) \n+                { insert(__p.index(), __c); return __p; }\n+        iterator insert(const iterator& __p ) \n+                { insert(__p.index()); return __p; }\n+        iterator insert(const iterator& __p, const _CharT* c_string) \n+                { insert(__p.index(), c_string); return __p; }\n+        iterator insert(const iterator& __p, const _CharT* __i, size_t __n)\n+                { insert(__p.index(), __i, __n); return __p; }\n+        iterator insert(const iterator& __p, const _CharT* __i, \n+                        const _CharT* __j)\n+                { insert(__p.index(), __i, __j);  return __p; }\n+        iterator insert(const iterator& __p,\n+                        const const_iterator& __i, const const_iterator& __j)\n+                { insert(__p.index(), __i, __j); return __p; }\n+        iterator insert(const iterator& __p,\n+                        const iterator& __i, const iterator& __j)\n+                { insert(__p.index(), __i, __j); return __p; }\n+\n+        // Replace, range variants.\n+        void replace(const iterator& __p, const iterator& __q,\n+                     const rope& __r)\n+                { replace(__p.index(), __q.index() - __p.index(), __r); }\n+        void replace(const iterator& __p, const iterator& __q, _CharT __c)\n+                { replace(__p.index(), __q.index() - __p.index(), __c); }\n+        void replace(const iterator& __p, const iterator& __q,\n+                     const _CharT* __c_string)\n+                { replace(__p.index(), __q.index() - __p.index(), __c_string); }\n+        void replace(const iterator& __p, const iterator& __q,\n+                     const _CharT* __i, size_t __n)\n+                { replace(__p.index(), __q.index() - __p.index(), __i, __n); }\n+        void replace(const iterator& __p, const iterator& __q,\n+                     const _CharT* __i, const _CharT* __j)\n+                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }\n+        void replace(const iterator& __p, const iterator& __q,\n+                     const const_iterator& __i, const const_iterator& __j)\n+                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }\n+        void replace(const iterator& __p, const iterator& __q,\n+                     const iterator& __i, const iterator& __j)\n+                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }\n+\n+        // Replace, iterator variants.\n+        void replace(const iterator& __p, const rope& __r)\n+                { replace(__p.index(), __r); }\n+        void replace(const iterator& __p, _CharT __c)\n+                { replace(__p.index(), __c); }\n+        void replace(const iterator& __p, const _CharT* __c_string)\n+                { replace(__p.index(), __c_string); }\n+        void replace(const iterator& __p, const _CharT* __i, size_t __n)\n+                { replace(__p.index(), __i, __n); }\n+        void replace(const iterator& __p, const _CharT* __i, const _CharT* __j)\n+                { replace(__p.index(), __i, __j); }\n+        void replace(const iterator& __p, const_iterator __i, \n+                     const_iterator __j)\n+                { replace(__p.index(), __i, __j); }\n+        void replace(const iterator& __p, iterator __i, iterator __j)\n+                { replace(__p.index(), __i, __j); }\n+\n+        // Iterator and range variants of erase\n+        iterator erase(const iterator& __p, const iterator& __q) {\n+            size_t __p_index = __p.index();\n+            erase(__p_index, __q.index() - __p_index);\n+            return iterator(this, __p_index);\n+        }\n+        iterator erase(const iterator& __p) {\n+            size_t __p_index = __p.index();\n+            erase(__p_index, 1);\n+            return iterator(this, __p_index);\n+        }\n+\n+        rope substr(size_t __start, size_t __len = 1) const {\n+            return rope<_CharT,_Alloc>(\n+                        _S_substring(this->_M_tree_ptr,\n+\t\t\t\t     __start,\n+\t\t\t\t     __start + __len));\n+        }\n+\n+        rope substr(iterator __start, iterator __end) const {\n+            return rope<_CharT,_Alloc>(\n+                _S_substring(this->_M_tree_ptr,\n+\t\t\t     __start.index(),\n+\t\t\t     __end.index()));\n+        }\n+        \n+        rope substr(iterator __start) const {\n+            size_t __pos = __start.index();\n+            return rope<_CharT,_Alloc>(\n+                        _S_substring(this->_M_tree_ptr, __pos, __pos + 1));\n+        }\n+        \n+        rope substr(const_iterator __start, const_iterator __end) const {\n+            // This might eventually take advantage of the cache in the\n+            // iterator.\n+            return rope<_CharT,_Alloc>(\n+              _S_substring(this->_M_tree_ptr, __start.index(), __end.index()));\n+        }\n+\n+        rope<_CharT,_Alloc> substr(const_iterator __start) {\n+            size_t __pos = __start.index();\n+            return rope<_CharT,_Alloc>(\n+              _S_substring(this->_M_tree_ptr, __pos, __pos + 1));\n+        }\n+\n+        static const size_type npos;\n+\n+        size_type find(_CharT __c, size_type __pos = 0) const;\n+        size_type find(const _CharT* __s, size_type __pos = 0) const {\n+            size_type __result_pos;\n+            const_iterator __result =\n+\t      std::search(const_begin() + __pos, const_end(),\n+\t\t\t  __s, __s + _S_char_ptr_len(__s));\n+            __result_pos = __result.index();\n+#           ifndef __STL_OLD_ROPE_SEMANTICS\n+                if (__result_pos == size()) __result_pos = npos;\n+#           endif\n+            return __result_pos;\n+        }\n+\n+        iterator mutable_begin() {\n+            return(iterator(this, 0));\n+        }\n+\n+        iterator mutable_end() {\n+            return(iterator(this, size()));\n+        }\n+\n+        typedef reverse_iterator<iterator> reverse_iterator;\n+\n+        reverse_iterator mutable_rbegin() {\n+            return reverse_iterator(mutable_end());\n+        }\n+\n+        reverse_iterator mutable_rend() {\n+            return reverse_iterator(mutable_begin());\n+        }\n+\n+        reference mutable_reference_at(size_type __pos) {\n+            return reference(this, __pos);\n+        }\n+\n+#       ifdef __STD_STUFF\n+            reference operator[] (size_type __pos) {\n+                return _char_ref_proxy(this, __pos);\n+            }\n+\n+            reference at(size_type __pos) {\n+                // if (__pos >= size()) throw out_of_range;  // XXX\n+                return (*this)[__pos];\n+            }\n+\n+            void resize(size_type __n, _CharT __c) {}\n+            void resize(size_type __n) {}\n+            void reserve(size_type __res_arg = 0) {}\n+            size_type capacity() const {\n+                return max_size();\n+            }\n+\n+          // Stuff below this line is dangerous because it's error prone.\n+          // I would really like to get rid of it.\n+            // copy function with funny arg ordering.\n+              size_type copy(_CharT* __buffer, size_type __n, \n+                             size_type __pos = 0) const {\n+                return copy(__pos, __n, __buffer);\n+              }\n+\n+            iterator end() { return mutable_end(); }\n+\n+            iterator begin() { return mutable_begin(); }\n+\n+            reverse_iterator rend() { return mutable_rend(); }\n+\n+            reverse_iterator rbegin() { return mutable_rbegin(); }\n+\n+#       else\n+\n+            const_iterator end() { return const_end(); }\n+\n+            const_iterator begin() { return const_begin(); }\n+\n+            const_reverse_iterator rend() { return const_rend(); }\n+  \n+            const_reverse_iterator rbegin() { return const_rbegin(); }\n+\n+#       endif\n+        \n+};\n+\n+template <class _CharT, class _Alloc>\n+const typename rope<_CharT, _Alloc>::size_type rope<_CharT, _Alloc>::npos =\n+                        (size_type)(-1);\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator== (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n+  return (__x._M_current_pos == __y._M_current_pos && \n+          __x._M_root == __y._M_root);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator< (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+                       const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n+  return (__x._M_current_pos < __y._M_current_pos);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator!= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n+  return !(__x == __y);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator> (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+                       const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n+  return __y < __x;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator<= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n+  return !(__y < __x);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator>= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n+  return !(__x < __y);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline ptrdiff_t operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x,\n+                           const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n+  return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline _Rope_const_iterator<_CharT,_Alloc>\n+operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {\n+  return _Rope_const_iterator<_CharT,_Alloc>(\n+            __x._M_root, __x._M_current_pos - __n);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline _Rope_const_iterator<_CharT,_Alloc>\n+operator+(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {\n+  return _Rope_const_iterator<_CharT,_Alloc>(\n+           __x._M_root, __x._M_current_pos + __n);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline _Rope_const_iterator<_CharT,_Alloc>\n+operator+(ptrdiff_t __n, const _Rope_const_iterator<_CharT,_Alloc>& __x) {\n+  return _Rope_const_iterator<_CharT,_Alloc>(\n+           __x._M_root, __x._M_current_pos + __n);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator== (const _Rope_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n+  return (__x._M_current_pos == __y._M_current_pos && \n+          __x._M_root_rope == __y._M_root_rope);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator< (const _Rope_iterator<_CharT,_Alloc>& __x,\n+                       const _Rope_iterator<_CharT,_Alloc>& __y) {\n+  return (__x._M_current_pos < __y._M_current_pos);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator!= (const _Rope_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n+  return !(__x == __y);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator> (const _Rope_iterator<_CharT,_Alloc>& __x,\n+                       const _Rope_iterator<_CharT,_Alloc>& __y) {\n+  return __y < __x;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator<= (const _Rope_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n+  return !(__y < __x);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator>= (const _Rope_iterator<_CharT,_Alloc>& __x,\n+                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n+  return !(__x < __y);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline ptrdiff_t operator-(const _Rope_iterator<_CharT,_Alloc>& __x,\n+                           const _Rope_iterator<_CharT,_Alloc>& __y) {\n+  return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline _Rope_iterator<_CharT,_Alloc>\n+operator-(const _Rope_iterator<_CharT,_Alloc>& __x,\n+          ptrdiff_t __n) {\n+  return _Rope_iterator<_CharT,_Alloc>(\n+    __x._M_root_rope, __x._M_current_pos - __n);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline _Rope_iterator<_CharT,_Alloc>\n+operator+(const _Rope_iterator<_CharT,_Alloc>& __x,\n+          ptrdiff_t __n) {\n+  return _Rope_iterator<_CharT,_Alloc>(\n+    __x._M_root_rope, __x._M_current_pos + __n);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline _Rope_iterator<_CharT,_Alloc>\n+operator+(ptrdiff_t __n, const _Rope_iterator<_CharT,_Alloc>& __x) {\n+  return _Rope_iterator<_CharT,_Alloc>(\n+    __x._M_root_rope, __x._M_current_pos + __n);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline\n+rope<_CharT,_Alloc>\n+operator+ (const rope<_CharT,_Alloc>& __left,\n+           const rope<_CharT,_Alloc>& __right)\n+{\n+    return rope<_CharT,_Alloc>(\n+      rope<_CharT,_Alloc>::_S_concat(__left._M_tree_ptr, __right._M_tree_ptr));\n+    // Inlining this should make it possible to keep __left and\n+    // __right in registers.\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline\n+rope<_CharT,_Alloc>&\n+operator+= (rope<_CharT,_Alloc>& __left, \n+      const rope<_CharT,_Alloc>& __right)\n+{\n+    __left.append(__right);\n+    return __left;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline\n+rope<_CharT,_Alloc>\n+operator+ (const rope<_CharT,_Alloc>& __left,\n+           const _CharT* __right) {\n+    size_t __rlen = rope<_CharT,_Alloc>::_S_char_ptr_len(__right);\n+    return rope<_CharT,_Alloc>(\n+      rope<_CharT,_Alloc>::_S_concat_char_iter(\n+        __left._M_tree_ptr, __right, __rlen)); \n+}\n+\n+template <class _CharT, class _Alloc>\n+inline\n+rope<_CharT,_Alloc>&\n+operator+= (rope<_CharT,_Alloc>& __left,\n+            const _CharT* __right) {\n+    __left.append(__right);\n+    return __left;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline\n+rope<_CharT,_Alloc>\n+operator+ (const rope<_CharT,_Alloc>& __left, _CharT __right) {\n+    return rope<_CharT,_Alloc>(\n+      rope<_CharT,_Alloc>::_S_concat_char_iter(\n+        __left._M_tree_ptr, &__right, 1));\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline\n+rope<_CharT,_Alloc>&\n+operator+= (rope<_CharT,_Alloc>& __left, _CharT __right) {\n+    __left.append(__right);\n+    return __left;\n+}\n+\n+template <class _CharT, class _Alloc>\n+bool\n+operator< (const rope<_CharT,_Alloc>& __left, \n+           const rope<_CharT,_Alloc>& __right) {\n+    return __left.compare(__right) < 0;\n+}\n+        \n+template <class _CharT, class _Alloc>\n+bool\n+operator== (const rope<_CharT,_Alloc>& __left, \n+            const rope<_CharT,_Alloc>& __right) {\n+    return __left.compare(__right) == 0;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n+                        const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {\n+        return (__x._M_pos == __y._M_pos && __x._M_root == __y._M_root);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool\n+operator!= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n+  return !(__x == __y);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool\n+operator> (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n+  return __y < __x;\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool\n+operator<= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n+  return !(__y < __x);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool\n+operator>= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n+  return !(__x < __y);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline bool operator!= (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n+                        const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {\n+  return !(__x == __y);\n+}\n+\n+template<class _CharT, class _Traits, class _Alloc>\n+std::basic_ostream<_CharT, _Traits>& operator<<\n+                                        (std::basic_ostream<_CharT, _Traits>& __o,\n+                                         const rope<_CharT, _Alloc>& __r);\n+\n+typedef rope<char> crope;\n+typedef rope<wchar_t> wrope;\n+\n+inline crope::reference __mutable_reference_at(crope& __c, size_t __i)\n+{\n+    return __c.mutable_reference_at(__i);\n+}\n+\n+inline wrope::reference __mutable_reference_at(wrope& __c, size_t __i)\n+{\n+    return __c.mutable_reference_at(__i);\n+}\n+\n+template <class _CharT, class _Alloc>\n+inline void swap(rope<_CharT,_Alloc>& __x, rope<_CharT,_Alloc>& __y) {\n+  __x.swap(__y);\n+}\n+\n+// Hash functions should probably be revisited later:\n+template<> struct hash<crope>\n+{\n+  size_t operator()(const crope& __str) const\n+  {\n+    size_t __size = __str.size();\n+\n+    if (0 == __size) return 0;\n+    return 13*__str[0] + 5*__str[__size - 1] + __size;\n+  }\n+};\n+\n+\n+template<> struct hash<wrope>\n+{\n+  size_t operator()(const wrope& __str) const\n+  {\n+    size_t __size = __str.size();\n+\n+    if (0 == __size) return 0;\n+    return 13*__str[0] + 5*__str[__size - 1] + __size;\n+  }\n+};\n+\n+} // namespace __gnu_cxx\n+\n+# include <ext/ropeimpl.h>\n+\n+#endif"}, {"sha": "104b640989c44720ed597adb37cab89177f8cbd6", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -55,13 +55,13 @@\n \n namespace __gnu_cxx\n {\n-using std::size_t;\n-using std::printf;\n-using std::basic_ostream;  \n-using std::__throw_length_error;\n-using std::__alloc;\n-using std::_Destroy;\n-using std::uninitialized_fill_n;\n+  using std::size_t;\n+  using std::printf;\n+  using std::basic_ostream;  \n+  using std::__throw_length_error;\n+  using std::__alloc;\n+  using std::_Destroy;\n+  using std::uninitialized_fill_n;\n \n // Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n // if necessary.  Assumes _M_path_end[leaf_index] and leaf_pos are correct."}, {"sha": "9c2cce12473a40c462443fd6b8d638c7232486b4", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -47,8 +47,8 @@\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef __SGI_STL_INTERNAL_SLIST_H\n-#define __SGI_STL_INTERNAL_SLIST_H\n+#ifndef _SLIST\n+#define _SLIST 1\n \n #include <bits/stl_algobase.h>\n #include <bits/stl_alloc.h>\n@@ -950,8 +950,4 @@ public:\n \n } // namespace std\n \n-#endif /* __SGI_STL_INTERNAL_SLIST_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif "}, {"sha": "43ef34dec721dd3464c1e868f97ce1b3f69d3831", "filename": "libstdc++-v3/include/ext/stdio_filebuf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -31,8 +31,8 @@\n  *  This file is a GNU extension to the Standard C++ Library.\n  */\n \n-#ifndef _EXT_STDIO_FILEBUF\n-#define _EXT_STDIO_FILEBUF\n+#ifndef _STDIO_FILEBUF_H\n+#define _STDIO_FILEBUF_H 1\n \n #pragma GCC system_header\n "}, {"sha": "136391c1ea3a03a976f4290d45e1a5a809e7d0c7", "filename": "libstdc++-v3/include/ext/stdio_sync_filebuf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_sync_filebuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2acb86f5b67be421dbd9b8d90238f26c3b42448/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_sync_filebuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_sync_filebuf.h?ref=b2acb86f5b67be421dbd9b8d90238f26c3b42448", "patch": "@@ -31,8 +31,8 @@\n  *  This file is a GNU extension to the Standard C++ Library.\n  */\n \n-#ifndef _EXT_STDIO_SYNC_FILEBUF\n-#define _EXT_STDIO_SYNC_FILEBUF\n+#ifndef _STDIO_SYNC_FILEBUF_H\n+#define _STDIO_SYNC_FILEBUF_H 1\n \n #pragma GCC system_header\n "}, {"sha": "c8ada9ca76602ccb0901a6b62b58cf341a0e400b", "filename": "libstdc++-v3/include/ext/stl_rope.h", "status": "removed", "additions": 0, "deletions": 2526, "changes": 2526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744f6f0984e3b00f2dc1d451087543526e1cc672/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744f6f0984e3b00f2dc1d451087543526e1cc672/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h?ref=744f6f0984e3b00f2dc1d451087543526e1cc672", "patch": "@@ -1,2526 +0,0 @@\n-// SGI's rope implementation -*- C++ -*-\n-\n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1997-1998\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/** @file ext/stl_rope.h\n- *  This file is a GNU extension to the Standard C++ Library (possibly\n- *  containing extensions from the HP/SGI STL subset).  You should only\n- *  include this header if you are using GCC 3 or later.\n- */\n-\n-// rope<_CharT,_Alloc> is a sequence of _CharT.\n-// Ropes appear to be mutable, but update operations\n-// really copy enough of the data structure to leave the original\n-// valid.  Thus ropes can be logically copied by just copying\n-// a pointer value.\n-\n-#ifndef __SGI_STL_INTERNAL_ROPE_H\n-# define __SGI_STL_INTERNAL_ROPE_H\n-\n-# ifdef __GC\n-#   define __GC_CONST const\n-# else\n-#   include <bits/stl_threads.h>\n-#   define __GC_CONST   // constant except for deallocation\n-# endif\n-\n-#include <ext/memory> // For uninitialized_copy_n\n-\n-namespace __gnu_cxx\n-{\n-using std::size_t;\n-using std::ptrdiff_t;\n-using std::allocator;\n-using std::iterator;\n-using std::reverse_iterator;\n-using std::_Alloc_traits;\n-using std::_Destroy;\n-using std::_Refcount_Base;\n-\n-// The _S_eos function is used for those functions that\n-// convert to/from C-like strings to detect the end of the string.\n-\n-// The end-of-C-string character.\n-// This is what the draft standard says it should be.\n-template <class _CharT>\n-inline _CharT _S_eos(_CharT*) { return _CharT(); }\n-\n-// Test for basic character types.\n-// For basic character types leaves having a trailing eos.\n-template <class _CharT>\n-inline bool _S_is_basic_char_type(_CharT*) { return false; }\n-template <class _CharT>\n-inline bool _S_is_one_byte_char_type(_CharT*) { return false; }\n-\n-inline bool _S_is_basic_char_type(char*) { return true; }\n-inline bool _S_is_one_byte_char_type(char*) { return true; }\n-inline bool _S_is_basic_char_type(wchar_t*) { return true; }\n-\n-// Store an eos iff _CharT is a basic character type.\n-// Do not reference _S_eos if it isn't.\n-template <class _CharT>\n-inline void _S_cond_store_eos(_CharT&) {}\n-\n-inline void _S_cond_store_eos(char& __c) { __c = 0; }\n-inline void _S_cond_store_eos(wchar_t& __c) { __c = 0; }\n-\n-// char_producers are logically functions that generate a section of\n-// a string.  These can be convereted to ropes.  The resulting rope\n-// invokes the char_producer on demand.  This allows, for example,\n-// files to be viewed as ropes without reading the entire file.\n-template <class _CharT>\n-class char_producer {\n-    public:\n-        virtual ~char_producer() {};\n-        virtual void operator()(size_t __start_pos, size_t __len, \n-                                _CharT* __buffer) = 0;\n-        // Buffer should really be an arbitrary output iterator.\n-        // That way we could flatten directly into an ostream, etc.\n-        // This is thoroughly impossible, since iterator types don't\n-        // have runtime descriptions.\n-};\n-\n-// Sequence buffers:\n-//\n-// Sequence must provide an append operation that appends an\n-// array to the sequence.  Sequence buffers are useful only if\n-// appending an entire array is cheaper than appending element by element.\n-// This is true for many string representations.\n-// This should  perhaps inherit from ostream<sequence::value_type>\n-// and be implemented correspondingly, so that they can be used\n-// for formatted.  For the sake of portability, we don't do this yet.\n-//\n-// For now, sequence buffers behave as output iterators.  But they also\n-// behave a little like basic_ostringstream<sequence::value_type> and a\n-// little like containers.\n-\n-template<class _Sequence, size_t _Buf_sz = 100>\n-class sequence_buffer : public iterator<std::output_iterator_tag,void,void,void,void>\n-{\n-    public:\n-        typedef typename _Sequence::value_type value_type;\n-    protected:\n-        _Sequence* _M_prefix;\n-        value_type _M_buffer[_Buf_sz];\n-        size_t     _M_buf_count;\n-    public:\n-        void flush() {\n-            _M_prefix->append(_M_buffer, _M_buffer + _M_buf_count);\n-            _M_buf_count = 0;\n-        }\n-        ~sequence_buffer() { flush(); }\n-        sequence_buffer() : _M_prefix(0), _M_buf_count(0) {}\n-        sequence_buffer(const sequence_buffer& __x) {\n-            _M_prefix = __x._M_prefix;\n-            _M_buf_count = __x._M_buf_count;\n-            copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);\n-        }\n-        sequence_buffer(sequence_buffer& __x) {\n-            __x.flush();\n-            _M_prefix = __x._M_prefix;\n-            _M_buf_count = 0;\n-        }\n-        sequence_buffer(_Sequence& __s) : _M_prefix(&__s), _M_buf_count(0) {}\n-        sequence_buffer& operator= (sequence_buffer& __x) {\n-            __x.flush();\n-            _M_prefix = __x._M_prefix;\n-            _M_buf_count = 0;\n-            return *this;\n-        }\n-        sequence_buffer& operator= (const sequence_buffer& __x) {\n-            _M_prefix = __x._M_prefix;\n-            _M_buf_count = __x._M_buf_count;\n-            copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);\n-            return *this;\n-        }\n-        void push_back(value_type __x)\n-        {\n-            if (_M_buf_count < _Buf_sz) {\n-                _M_buffer[_M_buf_count] = __x;\n-                ++_M_buf_count;\n-            } else {\n-                flush();\n-                _M_buffer[0] = __x;\n-                _M_buf_count = 1;\n-            }\n-        }\n-        void append(value_type* __s, size_t __len)\n-        {\n-            if (__len + _M_buf_count <= _Buf_sz) {\n-                size_t __i = _M_buf_count;\n-                size_t __j = 0;\n-                for (; __j < __len; __i++, __j++) {\n-                    _M_buffer[__i] = __s[__j];\n-                }\n-                _M_buf_count += __len;\n-            } else if (0 == _M_buf_count) {\n-                _M_prefix->append(__s, __s + __len);\n-            } else {\n-                flush();\n-                append(__s, __len);\n-            }\n-        }\n-        sequence_buffer& write(value_type* __s, size_t __len)\n-        {\n-            append(__s, __len);\n-            return *this;\n-        }\n-        sequence_buffer& put(value_type __x)\n-        {\n-            push_back(__x);\n-            return *this;\n-        }\n-        sequence_buffer& operator=(const value_type& __rhs)\n-        {\n-            push_back(__rhs);\n-            return *this;\n-        }\n-        sequence_buffer& operator*() { return *this; }\n-        sequence_buffer& operator++() { return *this; }\n-        sequence_buffer& operator++(int) { return *this; }\n-};\n-\n-// The following should be treated as private, at least for now.\n-template<class _CharT>\n-class _Rope_char_consumer {\n-    public:\n-        // If we had member templates, these should not be virtual.\n-        // For now we need to use run-time parametrization where\n-        // compile-time would do.  Hence this should all be private\n-        // for now.\n-        // The symmetry with char_producer is accidental and temporary.\n-        virtual ~_Rope_char_consumer() {};\n-        virtual bool operator()(const _CharT* __buffer, size_t __len) = 0;\n-};\n-\n-// First a lot of forward declarations.  The standard seems to require\n-// much stricter \"declaration before use\" than many of the implementations\n-// that preceded it.\n-template<class _CharT, class _Alloc=allocator<_CharT> > class rope;\n-template<class _CharT, class _Alloc> struct _Rope_RopeConcatenation;\n-template<class _CharT, class _Alloc> struct _Rope_RopeLeaf;\n-template<class _CharT, class _Alloc> struct _Rope_RopeFunction;\n-template<class _CharT, class _Alloc> struct _Rope_RopeSubstring;\n-template<class _CharT, class _Alloc> class _Rope_iterator;\n-template<class _CharT, class _Alloc> class _Rope_const_iterator;\n-template<class _CharT, class _Alloc> class _Rope_char_ref_proxy;\n-template<class _CharT, class _Alloc> class _Rope_char_ptr_proxy;\n-\n-template<class _CharT, class _Alloc>\n-bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n-                 const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y);\n-\n-template<class _CharT, class _Alloc>\n-_Rope_const_iterator<_CharT,_Alloc> operator-\n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-\n-template<class _CharT, class _Alloc>\n-_Rope_const_iterator<_CharT,_Alloc> operator+\n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-\n-template<class _CharT, class _Alloc>\n-_Rope_const_iterator<_CharT,_Alloc> operator+\n-        (ptrdiff_t __n,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __x);\n-\n-template<class _CharT, class _Alloc>\n-bool operator== \n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n-\n-template<class _CharT, class _Alloc>\n-bool operator< \n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n-\n-template<class _CharT, class _Alloc>\n-ptrdiff_t operator- \n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n-\n-template<class _CharT, class _Alloc>\n-_Rope_iterator<_CharT,_Alloc> operator-\n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-\n-template<class _CharT, class _Alloc>\n-_Rope_iterator<_CharT,_Alloc> operator+\n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-\n-template<class _CharT, class _Alloc>\n-_Rope_iterator<_CharT,_Alloc> operator+\n-        (ptrdiff_t __n,\n-         const _Rope_iterator<_CharT,_Alloc>& __x);\n-\n-template<class _CharT, class _Alloc>\n-bool operator== \n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_iterator<_CharT,_Alloc>& __y);\n-\n-template<class _CharT, class _Alloc>\n-bool operator< \n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_iterator<_CharT,_Alloc>& __y);\n-\n-template<class _CharT, class _Alloc>\n-ptrdiff_t operator- \n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_iterator<_CharT,_Alloc>& __y);\n-\n-template<class _CharT, class _Alloc>\n-rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n-                               const rope<_CharT,_Alloc>& __right);\n-        \n-template<class _CharT, class _Alloc>\n-rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n-                               const _CharT* __right);\n-        \n-template<class _CharT, class _Alloc>\n-rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n-                               _CharT __right);\n-        \n-// Some helpers, so we can use power on ropes.\n-// See below for why this isn't local to the implementation.\n-\n-// This uses a nonstandard refcount convention.\n-// The result has refcount 0.\n-template<class _CharT, class _Alloc>\n-struct _Rope_Concat_fn\n-       : public std::binary_function<rope<_CharT,_Alloc>, rope<_CharT,_Alloc>,\n-                                     rope<_CharT,_Alloc> > {\n-        rope<_CharT,_Alloc> operator() (const rope<_CharT,_Alloc>& __x,\n-                                const rope<_CharT,_Alloc>& __y) {\n-                    return __x + __y;\n-        }\n-};\n-\n-template <class _CharT, class _Alloc>\n-inline\n-rope<_CharT,_Alloc>\n-identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n-{\n-    return rope<_CharT,_Alloc>();\n-}\n-\n-\n-//\n-// What follows should really be local to rope.  Unfortunately,\n-// that doesn't work, since it makes it impossible to define generic\n-// equality on rope iterators.  According to the draft standard, the\n-// template parameters for such an equality operator cannot be inferred\n-// from the occurrence of a member class as a parameter.\n-// (SGI compilers in fact allow this, but the __result wouldn't be\n-// portable.)\n-// Similarly, some of the static member functions are member functions\n-// only to avoid polluting the global namespace, and to circumvent\n-// restrictions on type inference for template functions.\n-//\n-\n-//\n-// The internal data structure for representing a rope.  This is\n-// private to the implementation.  A rope is really just a pointer\n-// to one of these.\n-//\n-// A few basic functions for manipulating this data structure\n-// are members of _RopeRep.  Most of the more complex algorithms\n-// are implemented as rope members.\n-//\n-// Some of the static member functions of _RopeRep have identically\n-// named functions in rope that simply invoke the _RopeRep versions.\n-//\n-// A macro to introduce various allocation and deallocation functions\n-// These need to be defined differently depending on whether or not\n-// we are using standard conforming allocators, and whether the allocator\n-// instances have real state.  Thus this macro is invoked repeatedly\n-// with different definitions of __ROPE_DEFINE_ALLOC.\n-// __ROPE_DEFINE_ALLOC(type,name) defines \n-//   type * name_allocate(size_t) and\n-//   void name_deallocate(tipe *, size_t)\n-// Both functions may or may not be static.\n-\n-#define __ROPE_DEFINE_ALLOCS(__a) \\\n-        __ROPE_DEFINE_ALLOC(_CharT,_Data) /* character data */ \\\n-        typedef _Rope_RopeConcatenation<_CharT,__a> __C; \\\n-        __ROPE_DEFINE_ALLOC(__C,_C) \\\n-        typedef _Rope_RopeLeaf<_CharT,__a> __L; \\\n-        __ROPE_DEFINE_ALLOC(__L,_L) \\\n-        typedef _Rope_RopeFunction<_CharT,__a> __F; \\\n-        __ROPE_DEFINE_ALLOC(__F,_F) \\\n-        typedef _Rope_RopeSubstring<_CharT,__a> __S; \\\n-        __ROPE_DEFINE_ALLOC(__S,_S)\n-\n-//  Internal rope nodes potentially store a copy of the allocator\n-//  instance used to allocate them.  This is mostly redundant.\n-//  But the alternative would be to pass allocator instances around\n-//  in some form to nearly all internal functions, since any pointer\n-//  assignment may result in a zero reference count and thus require\n-//  deallocation.\n-//  The _Rope_rep_base class encapsulates\n-//  the differences between SGI-style allocators and standard-conforming\n-//  allocators.\n-\n-#define __STATIC_IF_SGI_ALLOC  /* not static */\n-\n-// Base class for ordinary allocators.\n-template <class _CharT, class _Allocator, bool _IsStatic>\n-class _Rope_rep_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n-  _Rope_rep_alloc_base(size_t __size, const allocator_type& __a)\n-        : _M_size(__size), _M_data_allocator(__a) {}\n-  size_t _M_size;       // This is here only to avoid wasting space\n-                // for an otherwise empty base class.\n-\n-  \n-protected:\n-    allocator_type _M_data_allocator;\n-\n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n-        /*static*/ _Tp * __name##_allocate(size_t __n) \\\n-          { return __name##Allocator(_M_data_allocator).allocate(__n); } \\\n-        void __name##_deallocate(_Tp* __p, size_t __n) \\\n-          { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator);\n-# undef __ROPE_DEFINE_ALLOC\n-};\n-\n-// Specialization for allocators that have the property that we don't\n-//  actually have to store an allocator object.  \n-template <class _CharT, class _Allocator>\n-class _Rope_rep_alloc_base<_CharT,_Allocator,true> {\n-public:\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-  _Rope_rep_alloc_base(size_t __size, const allocator_type&)\n-                : _M_size(__size) {}\n-  size_t _M_size;\n-  \n-protected:\n-\n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n-        static _Tp* __name##_allocate(size_t __n) \\\n-                { return __name##Alloc::allocate(__n); } \\\n-        void __name##_deallocate(_Tp *__p, size_t __n) \\\n-                { __name##Alloc::deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator);\n-# undef __ROPE_DEFINE_ALLOC\n-};\n-\n-template <class _CharT, class _Alloc>\n-struct _Rope_rep_base\n-  : public _Rope_rep_alloc_base<_CharT,_Alloc,\n-                                _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-{\n-  typedef _Rope_rep_alloc_base<_CharT,_Alloc,\n-                               _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-  _Rope_rep_base(size_t __size, const allocator_type& __a)\n-    : _Base(__size, __a) {}\n-};    \n-\n-\n-template<class _CharT, class _Alloc>\n-struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n-# ifndef __GC\n-    , _Refcount_Base\n-# endif\n-{\n-    public:\n-    enum { _S_max_rope_depth = 45 };\n-    enum _Tag {_S_leaf, _S_concat, _S_substringfn, _S_function};\n-    _Tag _M_tag:8;\n-    bool _M_is_balanced:8;\n-    unsigned char _M_depth;\n-    __GC_CONST _CharT* _M_c_string;\n-    __gthread_mutex_t _M_c_string_lock;\n-                        /* Flattened version of string, if needed.  */\n-                        /* typically 0.                             */\n-                        /* If it's not 0, then the memory is owned  */\n-                        /* by this node.                            */\n-                        /* In the case of a leaf, this may point to */\n-                        /* the same memory as the data field.       */\n-    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-                        allocator_type;\n-    _Rope_RopeRep(_Tag __t, int __d, bool __b, size_t __size,\n-                  allocator_type __a)\n-        : _Rope_rep_base<_CharT,_Alloc>(__size, __a),\n-#         ifndef __GC\n-          _Refcount_Base(1),\n-#         endif\n-          _M_tag(__t), _M_is_balanced(__b), _M_depth(__d), _M_c_string(0)\n-#ifdef __GTHREAD_MUTEX_INIT\n-    {\n-\t// Do not copy a POSIX/gthr mutex once in use.  However, bits are bits.\n-\t__gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n-\t_M_c_string_lock = __tmp;\n-    }\n-#else\n-    { __GTHREAD_MUTEX_INIT_FUNCTION (&_M_c_string_lock); }\n-#endif\n-#   ifdef __GC\n-        void _M_incr () {}\n-#   endif\n-        static void _S_free_string(__GC_CONST _CharT*, size_t __len,\n-                                   allocator_type __a);\n-#       define __STL_FREE_STRING(__s, __l, __a) _S_free_string(__s, __l, __a);\n-                        // Deallocate data section of a leaf.\n-                        // This shouldn't be a member function.\n-                        // But its hard to do anything else at the\n-                        // moment, because it's templatized w.r.t.\n-                        // an allocator.\n-                        // Does nothing if __GC is defined.\n-#   ifndef __GC\n-          void _M_free_c_string();\n-          void _M_free_tree();\n-                        // Deallocate t. Assumes t is not 0.\n-          void _M_unref_nonnil()\n-          {\n-              if (0 == _M_decr()) _M_free_tree();\n-          }\n-          void _M_ref_nonnil()\n-          {\n-              _M_incr();\n-          }\n-          static void _S_unref(_Rope_RopeRep* __t)\n-          {\n-              if (0 != __t) {\n-                  __t->_M_unref_nonnil();\n-              }\n-          }\n-          static void _S_ref(_Rope_RopeRep* __t)\n-          {\n-              if (0 != __t) __t->_M_incr();\n-          }\n-          static void _S_free_if_unref(_Rope_RopeRep* __t)\n-          {\n-              if (0 != __t && 0 == __t->_M_ref_count) __t->_M_free_tree();\n-          }\n-#   else /* __GC */\n-          void _M_unref_nonnil() {}\n-          void _M_ref_nonnil() {}\n-          static void _S_unref(_Rope_RopeRep*) {}\n-          static void _S_ref(_Rope_RopeRep*) {}\n-          static void _S_free_if_unref(_Rope_RopeRep*) {}\n-#   endif\n-\n-};\n-\n-template<class _CharT, class _Alloc>\n-struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {\n-  public:\n-    // Apparently needed by VC++\n-    // The data fields of leaves are allocated with some\n-    // extra space, to accommodate future growth and for basic\n-    // character types, to hold a trailing eos character.\n-    enum { _S_alloc_granularity = 8 };\n-    static size_t _S_rounded_up_size(size_t __n) {\n-        size_t __size_with_eos;\n-             \n-        if (_S_is_basic_char_type((_CharT*)0)) {\n-            __size_with_eos = __n + 1;\n-        } else {\n-            __size_with_eos = __n;\n-        }\n-#       ifdef __GC\n-           return __size_with_eos;\n-#       else\n-           // Allow slop for in-place expansion.\n-           return (__size_with_eos + _S_alloc_granularity-1)\n-                        &~ (_S_alloc_granularity-1);\n-#       endif\n-    }\n-    __GC_CONST _CharT* _M_data; /* Not necessarily 0 terminated. */\n-                                /* The allocated size is         */\n-                                /* _S_rounded_up_size(size), except */\n-                                /* in the GC case, in which it   */\n-                                /* doesn't matter.               */\n-    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-                        allocator_type;\n-    _Rope_RopeLeaf(__GC_CONST _CharT* __d, size_t __size, allocator_type __a)\n-        : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_leaf,\n-\t\t\t\t       0, true, __size, __a),\n-          _M_data(__d)\n-        {\n-        if (_S_is_basic_char_type((_CharT *)0)) {\n-            // already eos terminated.\n-            this->_M_c_string = __d;\n-        }\n-    }\n-        // The constructor assumes that d has been allocated with\n-        // the proper allocator and the properly padded size.\n-        // In contrast, the destructor deallocates the data:\n-# ifndef __GC\n-    ~_Rope_RopeLeaf() {\n-        if (_M_data != this->_M_c_string) {\n-            _M_free_c_string();\n-        }\n-        __STL_FREE_STRING(_M_data, this->_M_size, get_allocator());\n-    }\n-# endif\n-};\n-\n-template<class _CharT, class _Alloc>\n-struct _Rope_RopeConcatenation : public _Rope_RopeRep<_CharT,_Alloc> {\n-  public:\n-    _Rope_RopeRep<_CharT,_Alloc>* _M_left;\n-    _Rope_RopeRep<_CharT,_Alloc>* _M_right;\n-    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-                        allocator_type;\n-    _Rope_RopeConcatenation(_Rope_RopeRep<_CharT,_Alloc>* __l,\n-                             _Rope_RopeRep<_CharT,_Alloc>* __r,\n-                             allocator_type __a)\n-\n-      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_concat,\n-                                     std::max(__l->_M_depth, __r->_M_depth) + 1,\n-                                     false,\n-                                     __l->_M_size + __r->_M_size, __a),\n-        _M_left(__l), _M_right(__r)\n-      {}\n-# ifndef __GC\n-    ~_Rope_RopeConcatenation() {\n-        _M_free_c_string();\n-        _M_left->_M_unref_nonnil();\n-        _M_right->_M_unref_nonnil();\n-    }\n-# endif\n-};\n-\n-template<class _CharT, class _Alloc>\n-struct _Rope_RopeFunction : public _Rope_RopeRep<_CharT,_Alloc> {\n-  public:\n-    char_producer<_CharT>* _M_fn;\n-#   ifndef __GC\n-      bool _M_delete_when_done; // Char_producer is owned by the\n-                                // rope and should be explicitly\n-                                // deleted when the rope becomes\n-                                // inaccessible.\n-#   else\n-      // In the GC case, we either register the rope for\n-      // finalization, or not.  Thus the field is unnecessary;\n-      // the information is stored in the collector data structures.\n-      // We do need a finalization procedure to be invoked by the\n-      // collector.\n-      static void _S_fn_finalization_proc(void * __tree, void *) {\n-        delete ((_Rope_RopeFunction *)__tree) -> _M_fn;\n-      }\n-#   endif\n-    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-                                        allocator_type;\n-    _Rope_RopeFunction(char_producer<_CharT>* __f, size_t __size,\n-                        bool __d, allocator_type __a)\n-      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_function,\n-\t\t\t\t     0, true, __size, __a)\n-      , _M_fn(__f)\n-#       ifndef __GC\n-      , _M_delete_when_done(__d)\n-#       endif\n-    {\n-#       ifdef __GC\n-            if (__d) {\n-                GC_REGISTER_FINALIZER(\n-                  this, _Rope_RopeFunction::_S_fn_finalization_proc, 0, 0, 0);\n-            }\n-#       endif\n-    }\n-# ifndef __GC\n-    ~_Rope_RopeFunction() {\n-          _M_free_c_string();\n-          if (_M_delete_when_done) {\n-              delete _M_fn;\n-          }\n-    }\n-# endif\n-};\n-// Substring results are usually represented using just\n-// concatenation nodes.  But in the case of very long flat ropes\n-// or ropes with a functional representation that isn't practical.\n-// In that case, we represent the __result as a special case of\n-// RopeFunction, whose char_producer points back to the rope itself.\n-// In all cases except repeated substring operations and\n-// deallocation, we treat the __result as a RopeFunction.\n-template<class _CharT, class _Alloc>\n-struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n-                             public char_producer<_CharT> {\n-  public:\n-    // XXX this whole class should be rewritten.\n-    _Rope_RopeRep<_CharT,_Alloc>* _M_base;      // not 0\n-    size_t _M_start;\n-    virtual void operator()(size_t __start_pos, size_t __req_len,\n-                            _CharT* __buffer) {\n-        switch(_M_base->_M_tag) {\n-            case _Rope_RopeFunction<_CharT,_Alloc>::_S_function:\n-            case _Rope_RopeFunction<_CharT,_Alloc>::_S_substringfn:\n-              {\n-                char_producer<_CharT>* __fn =\n-                        ((_Rope_RopeFunction<_CharT,_Alloc>*)_M_base)->_M_fn;\n-                (*__fn)(__start_pos + _M_start, __req_len, __buffer);\n-              }\n-              break;\n-            case _Rope_RopeFunction<_CharT,_Alloc>::_S_leaf:\n-              {\n-                __GC_CONST _CharT* __s =\n-                        ((_Rope_RopeLeaf<_CharT,_Alloc>*)_M_base)->_M_data;\n-                uninitialized_copy_n(__s + __start_pos + _M_start, __req_len,\n-                                     __buffer);\n-              }\n-              break;\n-            default:\n-\t      break;\n-        }\n-    }\n-    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-        allocator_type;\n-    _Rope_RopeSubstring(_Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,\n-                          size_t __l, allocator_type __a)\n-      : _Rope_RopeFunction<_CharT,_Alloc>(this, __l, false, __a),\n-        char_producer<_CharT>(),\n-        _M_base(__b),\n-        _M_start(__s)\n-    {\n-#       ifndef __GC\n-            _M_base->_M_ref_nonnil();\n-#       endif\n-        this->_M_tag = _Rope_RopeFunction<_CharT,_Alloc>::_S_substringfn;\n-    }\n-    virtual ~_Rope_RopeSubstring()\n-      { \n-#       ifndef __GC\n-          _M_base->_M_unref_nonnil();\n-          // _M_free_c_string();  -- done by parent class\n-#       endif\n-      }\n-};\n-\n-\n-// Self-destructing pointers to Rope_rep.\n-// These are not conventional smart pointers.  Their\n-// only purpose in life is to ensure that unref is called\n-// on the pointer either at normal exit or if an exception\n-// is raised.  It is the caller's responsibility to\n-// adjust reference counts when these pointers are initialized\n-// or assigned to.  (This convention significantly reduces\n-// the number of potentially expensive reference count\n-// updates.)\n-#ifndef __GC\n-  template<class _CharT, class _Alloc>\n-  struct _Rope_self_destruct_ptr {\n-    _Rope_RopeRep<_CharT,_Alloc>* _M_ptr;\n-    ~_Rope_self_destruct_ptr() \n-      { _Rope_RopeRep<_CharT,_Alloc>::_S_unref(_M_ptr); }\n-#ifdef __EXCEPTIONS\n-        _Rope_self_destruct_ptr() : _M_ptr(0) {};\n-#else\n-        _Rope_self_destruct_ptr() {};\n-#endif\n-    _Rope_self_destruct_ptr(_Rope_RopeRep<_CharT,_Alloc>* __p) : _M_ptr(__p) {}\n-    _Rope_RopeRep<_CharT,_Alloc>& operator*() { return *_M_ptr; }\n-    _Rope_RopeRep<_CharT,_Alloc>* operator->() { return _M_ptr; }\n-    operator _Rope_RopeRep<_CharT,_Alloc>*() { return _M_ptr; }\n-    _Rope_self_destruct_ptr& operator= (_Rope_RopeRep<_CharT,_Alloc>* __x)\n-        { _M_ptr = __x; return *this; }\n-  };\n-#endif\n-\n-// Dereferencing a nonconst iterator has to return something\n-// that behaves almost like a reference.  It's not possible to\n-// return an actual reference since assignment requires extra\n-// work.  And we would get into the same problems as with the\n-// CD2 version of basic_string.\n-template<class _CharT, class _Alloc>\n-class _Rope_char_ref_proxy {\n-    friend class rope<_CharT,_Alloc>;\n-    friend class _Rope_iterator<_CharT,_Alloc>;\n-    friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;\n-#   ifdef __GC\n-        typedef _Rope_RopeRep<_CharT,_Alloc>* _Self_destruct_ptr;\n-#   else\n-        typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;\n-#   endif\n-    typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n-    typedef rope<_CharT,_Alloc> _My_rope;\n-    size_t _M_pos;\n-    _CharT _M_current;\n-    bool _M_current_valid;\n-    _My_rope* _M_root;     // The whole rope.\n-  public:\n-    _Rope_char_ref_proxy(_My_rope* __r, size_t __p)\n-      :  _M_pos(__p), _M_current_valid(false), _M_root(__r) {}\n-    _Rope_char_ref_proxy(const _Rope_char_ref_proxy& __x)\n-      : _M_pos(__x._M_pos), _M_current_valid(false), _M_root(__x._M_root) {}\n-        // Don't preserve cache if the reference can outlive the\n-        // expression.  We claim that's not possible without calling\n-        // a copy constructor or generating reference to a proxy\n-        // reference.  We declare the latter to have undefined semantics.\n-    _Rope_char_ref_proxy(_My_rope* __r, size_t __p, _CharT __c)\n-      : _M_pos(__p), _M_current(__c), _M_current_valid(true), _M_root(__r) {}\n-    inline operator _CharT () const;\n-    _Rope_char_ref_proxy& operator= (_CharT __c);\n-    _Rope_char_ptr_proxy<_CharT,_Alloc> operator& () const;\n-    _Rope_char_ref_proxy& operator= (const _Rope_char_ref_proxy& __c) {\n-        return operator=((_CharT)__c); \n-    }\n-};\n-\n-template<class _CharT, class __Alloc>\n-inline void swap(_Rope_char_ref_proxy <_CharT, __Alloc > __a,\n-                 _Rope_char_ref_proxy <_CharT, __Alloc > __b) {\n-    _CharT __tmp = __a;\n-    __a = __b;\n-    __b = __tmp;\n-}\n-\n-template<class _CharT, class _Alloc>\n-class _Rope_char_ptr_proxy {\n-    // XXX this class should be rewritten.\n-    friend class _Rope_char_ref_proxy<_CharT,_Alloc>;\n-    size_t _M_pos;\n-    rope<_CharT,_Alloc>* _M_root;     // The whole rope.\n-  public:\n-    _Rope_char_ptr_proxy(const _Rope_char_ref_proxy<_CharT,_Alloc>& __x) \n-      : _M_pos(__x._M_pos), _M_root(__x._M_root) {}\n-    _Rope_char_ptr_proxy(const _Rope_char_ptr_proxy& __x)\n-      : _M_pos(__x._M_pos), _M_root(__x._M_root) {}\n-    _Rope_char_ptr_proxy() {}\n-    _Rope_char_ptr_proxy(_CharT* __x) : _M_root(0), _M_pos(0) {\n-    }\n-    _Rope_char_ptr_proxy& \n-    operator= (const _Rope_char_ptr_proxy& __x) {\n-        _M_pos = __x._M_pos;\n-        _M_root = __x._M_root;\n-        return *this;\n-    }\n-    template<class _CharT2, class _Alloc2>\n-    friend bool operator== (const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __x,\n-                            const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __y);\n-    _Rope_char_ref_proxy<_CharT,_Alloc> operator*() const {\n-        return _Rope_char_ref_proxy<_CharT,_Alloc>(_M_root, _M_pos);\n-    }\n-};\n-\n-\n-// Rope iterators:\n-// Unlike in the C version, we cache only part of the stack\n-// for rope iterators, since they must be efficiently copyable.\n-// When we run out of cache, we have to reconstruct the iterator\n-// value.\n-// Pointers from iterators are not included in reference counts.\n-// Iterators are assumed to be thread private.  Ropes can\n-// be shared.\n-\n-template<class _CharT, class _Alloc>\n-class _Rope_iterator_base\n-  : public iterator<std::random_access_iterator_tag, _CharT>\n-{\n-    friend class rope<_CharT,_Alloc>;\n-  public:\n-    typedef _Alloc _allocator_type; // used in _Rope_rotate, VC++ workaround\n-    typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n-        // Borland doesn't want this to be protected.\n-  protected:\n-    enum { _S_path_cache_len = 4 }; // Must be <= 9.\n-    enum { _S_iterator_buf_len = 15 };\n-    size_t _M_current_pos;\n-    _RopeRep* _M_root;     // The whole rope.\n-    size_t _M_leaf_pos;    // Starting position for current leaf\n-    __GC_CONST _CharT* _M_buf_start;\n-                        // Buffer possibly\n-                        // containing current char.\n-    __GC_CONST _CharT* _M_buf_ptr;\n-                        // Pointer to current char in buffer.\n-                        // != 0 ==> buffer valid.\n-    __GC_CONST _CharT* _M_buf_end;\n-                        // One past __last valid char in buffer.\n-    // What follows is the path cache.  We go out of our\n-    // way to make this compact.\n-    // Path_end contains the bottom section of the path from\n-    // the root to the current leaf.\n-    const _RopeRep* _M_path_end[_S_path_cache_len];\n-    int _M_leaf_index;     // Last valid __pos in path_end;\n-                        // _M_path_end[0] ... _M_path_end[leaf_index-1]\n-                        // point to concatenation nodes.\n-    unsigned char _M_path_directions;\n-                          // (path_directions >> __i) & 1 is 1\n-                          // iff we got from _M_path_end[leaf_index - __i - 1]\n-                          // to _M_path_end[leaf_index - __i] by going to the\n-                          // __right. Assumes path_cache_len <= 9.\n-    _CharT _M_tmp_buf[_S_iterator_buf_len];\n-                        // Short buffer for surrounding chars.\n-                        // This is useful primarily for \n-                        // RopeFunctions.  We put the buffer\n-                        // here to avoid locking in the\n-                        // multithreaded case.\n-    // The cached path is generally assumed to be valid\n-    // only if the buffer is valid.\n-    static void _S_setbuf(_Rope_iterator_base& __x);\n-                                        // Set buffer contents given\n-                                        // path cache.\n-    static void _S_setcache(_Rope_iterator_base& __x);\n-                                        // Set buffer contents and\n-                                        // path cache.\n-    static void _S_setcache_for_incr(_Rope_iterator_base& __x);\n-                                        // As above, but assumes path\n-                                        // cache is valid for previous posn.\n-    _Rope_iterator_base() {}\n-    _Rope_iterator_base(_RopeRep* __root, size_t __pos)\n-      : _M_current_pos(__pos), _M_root(__root), _M_buf_ptr(0) {}\n-    void _M_incr(size_t __n);\n-    void _M_decr(size_t __n);\n-  public:\n-    size_t index() const { return _M_current_pos; }\n-    _Rope_iterator_base(const _Rope_iterator_base& __x) {\n-        if (0 != __x._M_buf_ptr) {\n-            *this = __x;\n-        } else {\n-            _M_current_pos = __x._M_current_pos;\n-            _M_root = __x._M_root;\n-            _M_buf_ptr = 0;\n-        }\n-    }\n-};\n-\n-template<class _CharT, class _Alloc> class _Rope_iterator;\n-\n-template<class _CharT, class _Alloc>\n-class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n-    friend class rope<_CharT,_Alloc>;\n-  protected:\n-      typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n-      // The one from the base class may not be directly visible.\n-    _Rope_const_iterator(const _RopeRep* __root, size_t __pos):\n-                   _Rope_iterator_base<_CharT,_Alloc>(\n-                     const_cast<_RopeRep*>(__root), __pos)\n-                   // Only nonconst iterators modify root ref count\n-    {}\n-  public:\n-    typedef _CharT reference;   // Really a value.  Returning a reference\n-                                // Would be a mess, since it would have\n-                                // to be included in refcount.\n-    typedef const _CharT* pointer;\n-\n-  public:\n-    _Rope_const_iterator() {};\n-    _Rope_const_iterator(const _Rope_const_iterator& __x) :\n-                                _Rope_iterator_base<_CharT,_Alloc>(__x) { }\n-    _Rope_const_iterator(const _Rope_iterator<_CharT,_Alloc>& __x);\n-    _Rope_const_iterator(const rope<_CharT,_Alloc>& __r, size_t __pos) :\n-        _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos) {}\n-    _Rope_const_iterator& operator= (const _Rope_const_iterator& __x) {\n-        if (0 != __x._M_buf_ptr) {\n-            *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;\n-        } else {\n-            this->_M_current_pos = __x._M_current_pos;\n-            this->_M_root = __x._M_root;\n-            this->_M_buf_ptr = 0;\n-        }\n-        return(*this);\n-    }\n-    reference operator*() {\n-        if (0 == this->_M_buf_ptr) _S_setcache(*this);\n-        return *this->_M_buf_ptr;\n-    }\n-    _Rope_const_iterator& operator++() {\n-        __GC_CONST _CharT* __next;\n-        if (0 != this->_M_buf_ptr\n-\t    && (__next = this->_M_buf_ptr + 1) < this->_M_buf_end) {\n-            this->_M_buf_ptr = __next;\n-            ++this->_M_current_pos;\n-        } else {\n-            _M_incr(1);\n-        }\n-        return *this;\n-    }\n-    _Rope_const_iterator& operator+=(ptrdiff_t __n) {\n-        if (__n >= 0) {\n-            _M_incr(__n);\n-        } else {\n-            _M_decr(-__n);\n-        }\n-        return *this;\n-    }\n-    _Rope_const_iterator& operator--() {\n-        _M_decr(1);\n-        return *this;\n-    }\n-    _Rope_const_iterator& operator-=(ptrdiff_t __n) {\n-        if (__n >= 0) {\n-            _M_decr(__n);\n-        } else {\n-            _M_incr(-__n);\n-        }\n-        return *this;\n-    }\n-    _Rope_const_iterator operator++(int) {\n-        size_t __old_pos = this->_M_current_pos;\n-        _M_incr(1);\n-        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);\n-        // This makes a subsequent dereference expensive.\n-        // Perhaps we should instead copy the iterator\n-        // if it has a valid cache?\n-    }\n-    _Rope_const_iterator operator--(int) {\n-        size_t __old_pos = this->_M_current_pos;\n-        _M_decr(1);\n-        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);\n-    }\n-    template<class _CharT2, class _Alloc2>\n-    friend _Rope_const_iterator<_CharT2,_Alloc2> operator-\n-        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n-         ptrdiff_t __n);\n-    template<class _CharT2, class _Alloc2>\n-    friend _Rope_const_iterator<_CharT2,_Alloc2> operator+\n-        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n-         ptrdiff_t __n);\n-    template<class _CharT2, class _Alloc2>\n-    friend _Rope_const_iterator<_CharT2,_Alloc2> operator+\n-        (ptrdiff_t __n,\n-         const _Rope_const_iterator<_CharT2,_Alloc2>& __x);\n-    reference operator[](size_t __n) {\n-        return rope<_CharT,_Alloc>::_S_fetch(this->_M_root,\n-\t\t\t\t\t     this->_M_current_pos + __n);\n-    }\n-\n-    template<class _CharT2, class _Alloc2>\n-    friend bool operator==\n-        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n-         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n-    template<class _CharT2, class _Alloc2>\n-    friend bool operator< \n-        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n-         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n-    template<class _CharT2, class _Alloc2>\n-    friend ptrdiff_t operator-\n-        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n-         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n-};\n-\n-template<class _CharT, class _Alloc>\n-class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n-    friend class rope<_CharT,_Alloc>;\n-  protected:\n-    typedef typename _Rope_iterator_base<_CharT,_Alloc>::_RopeRep _RopeRep;\n-    rope<_CharT,_Alloc>* _M_root_rope;\n-        // root is treated as a cached version of this,\n-        // and is used to detect changes to the underlying\n-        // rope.\n-        // Root is included in the reference count.\n-        // This is necessary so that we can detect changes reliably.\n-        // Unfortunately, it requires careful bookkeeping for the\n-        // nonGC case.\n-    _Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos)\n-      : _Rope_iterator_base<_CharT,_Alloc>(__r->_M_tree_ptr, __pos),\n-        _M_root_rope(__r) \n-      { _RopeRep::_S_ref(this->_M_root);\n-        if (!(__r -> empty()))_S_setcache(*this); }\n-\n-    void _M_check();\n-  public:\n-    typedef _Rope_char_ref_proxy<_CharT,_Alloc>  reference;\n-    typedef _Rope_char_ref_proxy<_CharT,_Alloc>* pointer;\n-\n-  public:\n-    rope<_CharT,_Alloc>& container() { return *_M_root_rope; }\n-    _Rope_iterator() {\n-        this->_M_root = 0;  // Needed for reference counting.\n-    };\n-    _Rope_iterator(const _Rope_iterator& __x) :\n-        _Rope_iterator_base<_CharT,_Alloc>(__x) {\n-        _M_root_rope = __x._M_root_rope;\n-        _RopeRep::_S_ref(this->_M_root);\n-    }\n-    _Rope_iterator(rope<_CharT,_Alloc>& __r, size_t __pos);\n-    ~_Rope_iterator() {\n-        _RopeRep::_S_unref(this->_M_root);\n-    }\n-    _Rope_iterator& operator= (const _Rope_iterator& __x) {\n-        _RopeRep* __old = this->_M_root;\n-\n-        _RopeRep::_S_ref(__x._M_root);\n-        if (0 != __x._M_buf_ptr) {\n-            _M_root_rope = __x._M_root_rope;\n-            *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;\n-        } else {\n-\t    this->_M_current_pos = __x._M_current_pos;\n-            this->_M_root = __x._M_root;\n-            _M_root_rope = __x._M_root_rope;\n-            this->_M_buf_ptr = 0;\n-        }\n-        _RopeRep::_S_unref(__old);\n-        return(*this);\n-    }\n-    reference operator*() {\n-        _M_check();\n-        if (0 == this->_M_buf_ptr) {\n-            return _Rope_char_ref_proxy<_CharT,_Alloc>(\n-               _M_root_rope, this->_M_current_pos);\n-        } else {\n-            return _Rope_char_ref_proxy<_CharT,_Alloc>(\n-               _M_root_rope, this->_M_current_pos, *this->_M_buf_ptr);\n-        }\n-    }\n-    _Rope_iterator& operator++() {\n-        _M_incr(1);\n-        return *this;\n-    }\n-    _Rope_iterator& operator+=(ptrdiff_t __n) {\n-        if (__n >= 0) {\n-            _M_incr(__n);\n-        } else {\n-            _M_decr(-__n);\n-        }\n-        return *this;\n-    }\n-    _Rope_iterator& operator--() {\n-        _M_decr(1);\n-        return *this;\n-    }\n-    _Rope_iterator& operator-=(ptrdiff_t __n) {\n-        if (__n >= 0) {\n-            _M_decr(__n);\n-        } else {\n-            _M_incr(-__n);\n-        }\n-        return *this;\n-    }\n-    _Rope_iterator operator++(int) {\n-        size_t __old_pos = this->_M_current_pos;\n-        _M_incr(1);\n-        return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);\n-    }\n-    _Rope_iterator operator--(int) {\n-        size_t __old_pos = this->_M_current_pos;\n-        _M_decr(1);\n-        return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);\n-    }\n-    reference operator[](ptrdiff_t __n) {\n-        return _Rope_char_ref_proxy<_CharT,_Alloc>(\n-          _M_root_rope, this->_M_current_pos + __n);\n-    }\n-\n-    template<class _CharT2, class _Alloc2>\n-    friend bool operator==\n-        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n-         const _Rope_iterator<_CharT2,_Alloc2>& __y);\n-    template<class _CharT2, class _Alloc2>\n-    friend bool operator<\n-        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n-         const _Rope_iterator<_CharT2,_Alloc2>& __y);\n-    template<class _CharT2, class _Alloc2>\n-    friend ptrdiff_t operator-\n-        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n-         const _Rope_iterator<_CharT2,_Alloc2>& __y);\n-    template<class _CharT2, class _Alloc2>\n-    friend _Rope_iterator<_CharT2,_Alloc2> operator-\n-        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n-         ptrdiff_t __n);\n-    template<class _CharT2, class _Alloc2>\n-    friend _Rope_iterator<_CharT2,_Alloc2> operator+\n-        (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n-         ptrdiff_t __n);\n-    template<class _CharT2, class _Alloc2>\n-    friend _Rope_iterator<_CharT2,_Alloc2> operator+\n-        (ptrdiff_t __n,\n-         const _Rope_iterator<_CharT2,_Alloc2>& __x);\n-};\n-\n-//  The rope base class encapsulates\n-//  the differences between SGI-style allocators and standard-conforming\n-//  allocators.\n-\n-// Base class for ordinary allocators.\n-template <class _CharT, class _Allocator, bool _IsStatic>\n-class _Rope_alloc_base {\n-public:\n-  typedef _Rope_RopeRep<_CharT,_Allocator> _RopeRep;\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n-  _Rope_alloc_base(_RopeRep *__t, const allocator_type& __a)\n-        : _M_tree_ptr(__t), _M_data_allocator(__a) {}\n-  _Rope_alloc_base(const allocator_type& __a)\n-        : _M_data_allocator(__a) {}\n-  \n-protected:\n-  // The only data members of a rope:\n-    allocator_type _M_data_allocator;\n-    _RopeRep* _M_tree_ptr;\n-\n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n-        _Tp* __name##_allocate(size_t __n) const \\\n-          { return __name##Allocator(_M_data_allocator).allocate(__n); } \\\n-        void __name##_deallocate(_Tp *__p, size_t __n) const \\\n-                { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator)\n-# undef __ROPE_DEFINE_ALLOC\n-};\n-\n-// Specialization for allocators that have the property that we don't\n-//  actually have to store an allocator object.  \n-template <class _CharT, class _Allocator>\n-class _Rope_alloc_base<_CharT,_Allocator,true> {\n-public:\n-  typedef _Rope_RopeRep<_CharT,_Allocator> _RopeRep;\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-  _Rope_alloc_base(_RopeRep *__t, const allocator_type&)\n-                : _M_tree_ptr(__t) {}\n-  _Rope_alloc_base(const allocator_type&) {}\n-  \n-protected:\n-  // The only data member of a rope:\n-    _RopeRep *_M_tree_ptr;\n-\n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n-        static _Tp* __name##_allocate(size_t __n) \\\n-          { return __name##Alloc::allocate(__n); } \\\n-        static void __name##_deallocate(_Tp *__p, size_t __n) \\\n-          { __name##Alloc::deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator)\n-# undef __ROPE_DEFINE_ALLOC\n-};\n-\n-template <class _CharT, class _Alloc>\n-struct _Rope_base \n-  : public _Rope_alloc_base<_CharT,_Alloc,\n-                            _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-{\n-  typedef _Rope_alloc_base<_CharT,_Alloc,\n-                            _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-  typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n-        // The one in _Base may not be visible due to template rules.\n-  _Rope_base(_RopeRep* __t, const allocator_type& __a) : _Base(__t, __a) {}\n-  _Rope_base(const allocator_type& __a) : _Base(__a) {}\n-};    \n-\n-\n-/**\n- *  This is an SGI extension.\n- *  @ingroup SGIextensions\n- *  @doctodo\n-*/\n-template <class _CharT, class _Alloc>\n-class rope : public _Rope_base<_CharT,_Alloc> {\n-    public:\n-        typedef _CharT value_type;\n-        typedef ptrdiff_t difference_type;\n-        typedef size_t size_type;\n-        typedef _CharT const_reference;\n-        typedef const _CharT* const_pointer;\n-        typedef _Rope_iterator<_CharT,_Alloc> iterator;\n-        typedef _Rope_const_iterator<_CharT,_Alloc> const_iterator;\n-        typedef _Rope_char_ref_proxy<_CharT,_Alloc> reference;\n-        typedef _Rope_char_ptr_proxy<_CharT,_Alloc> pointer;\n-\n-        friend class _Rope_iterator<_CharT,_Alloc>;\n-        friend class _Rope_const_iterator<_CharT,_Alloc>;\n-        friend struct _Rope_RopeRep<_CharT,_Alloc>;\n-        friend class _Rope_iterator_base<_CharT,_Alloc>;\n-        friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;\n-        friend class _Rope_char_ref_proxy<_CharT,_Alloc>;\n-        friend struct _Rope_RopeSubstring<_CharT,_Alloc>;\n-\n-    protected:\n-        typedef _Rope_base<_CharT,_Alloc> _Base;\n-        typedef typename _Base::allocator_type allocator_type;\n-        using _Base::_M_tree_ptr;\n-        typedef __GC_CONST _CharT* _Cstrptr;\n-\n-        static _CharT _S_empty_c_str[1];\n-\n-        static bool _S_is0(_CharT __c) { return __c == _S_eos((_CharT*)0); }\n-        enum { _S_copy_max = 23 };\n-                // For strings shorter than _S_copy_max, we copy to\n-                // concatenate.\n-\n-        typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n-        typedef _Rope_RopeConcatenation<_CharT,_Alloc> _RopeConcatenation;\n-        typedef _Rope_RopeLeaf<_CharT,_Alloc> _RopeLeaf;\n-        typedef _Rope_RopeFunction<_CharT,_Alloc> _RopeFunction;\n-        typedef _Rope_RopeSubstring<_CharT,_Alloc> _RopeSubstring;\n-\n-        // Retrieve a character at the indicated position.\n-        static _CharT _S_fetch(_RopeRep* __r, size_type __pos);\n-\n-#       ifndef __GC\n-            // Obtain a pointer to the character at the indicated position.\n-            // The pointer can be used to change the character.\n-            // If such a pointer cannot be produced, as is frequently the\n-            // case, 0 is returned instead.\n-            // (Returns nonzero only if all nodes in the path have a refcount\n-            // of 1.)\n-            static _CharT* _S_fetch_ptr(_RopeRep* __r, size_type __pos);\n-#       endif\n-\n-        static bool _S_apply_to_pieces(\n-                                // should be template parameter\n-                                _Rope_char_consumer<_CharT>& __c,\n-                                const _RopeRep* __r,\n-                                size_t __begin, size_t __end);\n-                                // begin and end are assumed to be in range.\n-\n-#       ifndef __GC\n-          static void _S_unref(_RopeRep* __t)\n-          {\n-              _RopeRep::_S_unref(__t);\n-          }\n-          static void _S_ref(_RopeRep* __t)\n-          {\n-              _RopeRep::_S_ref(__t);\n-          }\n-#       else /* __GC */\n-          static void _S_unref(_RopeRep*) {}\n-          static void _S_ref(_RopeRep*) {}\n-#       endif\n-\n-\n-#       ifdef __GC\n-            typedef _Rope_RopeRep<_CharT,_Alloc>* _Self_destruct_ptr;\n-#       else\n-            typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;\n-#       endif\n-\n-        // _Result is counted in refcount.\n-        static _RopeRep* _S_substring(_RopeRep* __base,\n-                                    size_t __start, size_t __endp1);\n-\n-        static _RopeRep* _S_concat_char_iter(_RopeRep* __r,\n-                                          const _CharT* __iter, size_t __slen);\n-                // Concatenate rope and char ptr, copying __s.\n-                // Should really take an arbitrary iterator.\n-                // Result is counted in refcount.\n-        static _RopeRep* _S_destr_concat_char_iter(_RopeRep* __r,\n-                                          const _CharT* __iter, size_t __slen)\n-                // As above, but one reference to __r is about to be\n-                // destroyed.  Thus the pieces may be recycled if all\n-                // relevant reference counts are 1.\n-#           ifdef __GC\n-                // We can't really do anything since refcounts are unavailable.\n-                { return _S_concat_char_iter(__r, __iter, __slen); }\n-#           else\n-                ;\n-#           endif\n-\n-        static _RopeRep* _S_concat(_RopeRep* __left, _RopeRep* __right);\n-                // General concatenation on _RopeRep.  _Result\n-                // has refcount of 1.  Adjusts argument refcounts.\n-\n-   public:\n-        void apply_to_pieces( size_t __begin, size_t __end,\n-                              _Rope_char_consumer<_CharT>& __c) const {\n-            _S_apply_to_pieces(__c, this->_M_tree_ptr, __begin, __end);\n-        }\n-\n-\n-   protected:\n-\n-        static size_t _S_rounded_up_size(size_t __n) {\n-            return _RopeLeaf::_S_rounded_up_size(__n);\n-        }\n-\n-        static size_t _S_allocated_capacity(size_t __n) {\n-            if (_S_is_basic_char_type((_CharT*)0)) {\n-                return _S_rounded_up_size(__n) - 1;\n-            } else {\n-                return _S_rounded_up_size(__n);\n-            }\n-        }\n-                \n-        // Allocate and construct a RopeLeaf using the supplied allocator\n-        // Takes ownership of s instead of copying.\n-        static _RopeLeaf* _S_new_RopeLeaf(__GC_CONST _CharT *__s,\n-                                          size_t __size, allocator_type __a)\n-        {\n-            _RopeLeaf* __space = typename _Base::_LAllocator(__a).allocate(1);\n-            return new(__space) _RopeLeaf(__s, __size, __a);\n-        }\n-\n-        static _RopeConcatenation* _S_new_RopeConcatenation(\n-                        _RopeRep* __left, _RopeRep* __right,\n-                        allocator_type __a)\n-        {\n-            _RopeConcatenation* __space = typename _Base::_CAllocator(__a).allocate(1);\n-            return new(__space) _RopeConcatenation(__left, __right, __a);\n-        }\n-\n-        static _RopeFunction* _S_new_RopeFunction(char_producer<_CharT>* __f,\n-                size_t __size, bool __d, allocator_type __a)\n-        {\n-            _RopeFunction* __space = typename _Base::_FAllocator(__a).allocate(1);\n-            return new(__space) _RopeFunction(__f, __size, __d, __a);\n-        }\n-\n-        static _RopeSubstring* _S_new_RopeSubstring(\n-                _Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,\n-                size_t __l, allocator_type __a)\n-        {\n-            _RopeSubstring* __space = typename _Base::_SAllocator(__a).allocate(1);\n-            return new(__space) _RopeSubstring(__b, __s, __l, __a);\n-        }\n-\n-          static\n-          _RopeLeaf* _S_RopeLeaf_from_unowned_char_ptr(const _CharT *__s,\n-                       size_t __size, allocator_type __a)\n-#         define __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __size, __a) \\\n-                _S_RopeLeaf_from_unowned_char_ptr(__s, __size, __a)     \n-        {\n-            if (0 == __size) return 0;\n-            _CharT* __buf = __a.allocate(_S_rounded_up_size(__size));\n-\n-            uninitialized_copy_n(__s, __size, __buf);\n-            _S_cond_store_eos(__buf[__size]);\n-            try {\n-              return _S_new_RopeLeaf(__buf, __size, __a);\n-            }\n-            catch(...)\n-\t      {\n-\t\t_RopeRep::__STL_FREE_STRING(__buf, __size, __a);\n-\t\t__throw_exception_again;\n-\t      }\n-        }\n-            \n-\n-        // Concatenation of nonempty strings.\n-        // Always builds a concatenation node.\n-        // Rebalances if the result is too deep.\n-        // Result has refcount 1.\n-        // Does not increment left and right ref counts even though\n-        // they are referenced.\n-        static _RopeRep*\n-        _S_tree_concat(_RopeRep* __left, _RopeRep* __right);\n-\n-        // Concatenation helper functions\n-        static _RopeLeaf*\n-        _S_leaf_concat_char_iter(_RopeLeaf* __r,\n-                                 const _CharT* __iter, size_t __slen);\n-                // Concatenate by copying leaf.\n-                // should take an arbitrary iterator\n-                // result has refcount 1.\n-#       ifndef __GC\n-          static _RopeLeaf* _S_destr_leaf_concat_char_iter\n-                        (_RopeLeaf* __r, const _CharT* __iter, size_t __slen);\n-          // A version that potentially clobbers __r if __r->_M_ref_count == 1.\n-#       endif\n-\n-        private:\n-\n-        static size_t _S_char_ptr_len(const _CharT* __s);\n-                        // slightly generalized strlen\n-\n-        rope(_RopeRep* __t, const allocator_type& __a = allocator_type())\n-          : _Base(__t,__a) { }\n-\n-\n-        // Copy __r to the _CharT buffer.\n-        // Returns __buffer + __r->_M_size.\n-        // Assumes that buffer is uninitialized.\n-        static _CharT* _S_flatten(_RopeRep* __r, _CharT* __buffer);\n-\n-        // Again, with explicit starting position and length.\n-        // Assumes that buffer is uninitialized.\n-        static _CharT* _S_flatten(_RopeRep* __r,\n-                                  size_t __start, size_t __len,\n-                                  _CharT* __buffer);\n-\n-        static const unsigned long \n-          _S_min_len[_RopeRep::_S_max_rope_depth + 1];\n-\n-        static bool _S_is_balanced(_RopeRep* __r)\n-                { return (__r->_M_size >= _S_min_len[__r->_M_depth]); }\n-\n-        static bool _S_is_almost_balanced(_RopeRep* __r)\n-                { return (__r->_M_depth == 0 ||\n-                          __r->_M_size >= _S_min_len[__r->_M_depth - 1]); }\n-\n-        static bool _S_is_roughly_balanced(_RopeRep* __r)\n-                { return (__r->_M_depth <= 1 ||\n-                          __r->_M_size >= _S_min_len[__r->_M_depth - 2]); }\n-\n-        // Assumes the result is not empty.\n-        static _RopeRep* _S_concat_and_set_balanced(_RopeRep* __left,\n-                                                     _RopeRep* __right)\n-        {\n-            _RopeRep* __result = _S_concat(__left, __right);\n-            if (_S_is_balanced(__result)) __result->_M_is_balanced = true;\n-            return __result;\n-        }\n-\n-        // The basic rebalancing operation.  Logically copies the\n-        // rope.  The result has refcount of 1.  The client will\n-        // usually decrement the reference count of __r.\n-        // The result is within height 2 of balanced by the above\n-        // definition.\n-        static _RopeRep* _S_balance(_RopeRep* __r);\n-\n-        // Add all unbalanced subtrees to the forest of balanceed trees.\n-        // Used only by balance.\n-        static void _S_add_to_forest(_RopeRep*__r, _RopeRep** __forest);\n-        \n-        // Add __r to forest, assuming __r is already balanced.\n-        static void _S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest);\n-\n-        // Print to stdout, exposing structure\n-        static void _S_dump(_RopeRep* __r, int __indent = 0);\n-\n-        // Return -1, 0, or 1 if __x < __y, __x == __y, or __x > __y resp.\n-        static int _S_compare(const _RopeRep* __x, const _RopeRep* __y);\n-\n-   public:\n-        bool empty() const { return 0 == this->_M_tree_ptr; }\n-\n-        // Comparison member function.  This is public only for those\n-        // clients that need a ternary comparison.  Others\n-        // should use the comparison operators below.\n-        int compare(const rope& __y) const {\n-            return _S_compare(this->_M_tree_ptr, __y._M_tree_ptr);\n-        }\n-\n-        rope(const _CharT* __s, const allocator_type& __a = allocator_type())\n-        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, _S_char_ptr_len(__s),\n-                                                 __a),__a)\n-        { }\n-\n-        rope(const _CharT* __s, size_t __len,\n-             const allocator_type& __a = allocator_type())\n-        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __len, __a), __a)\n-        { }\n-\n-        // Should perhaps be templatized with respect to the iterator type\n-        // and use Sequence_buffer.  (It should perhaps use sequence_buffer\n-        // even now.)\n-        rope(const _CharT *__s, const _CharT *__e,\n-             const allocator_type& __a = allocator_type())\n-        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __e - __s, __a), __a)\n-        { }\n-\n-        rope(const const_iterator& __s, const const_iterator& __e,\n-             const allocator_type& __a = allocator_type())\n-        : _Base(_S_substring(__s._M_root, __s._M_current_pos,\n-                             __e._M_current_pos), __a)\n-        { }\n-\n-        rope(const iterator& __s, const iterator& __e,\n-             const allocator_type& __a = allocator_type())\n-        : _Base(_S_substring(__s._M_root, __s._M_current_pos,\n-                             __e._M_current_pos), __a)\n-        { }\n-\n-        rope(_CharT __c, const allocator_type& __a = allocator_type())\n-        : _Base(__a)\n-        {\n-            _CharT* __buf = _Data_allocate(_S_rounded_up_size(1));\n-\n-            std::_Construct(__buf, __c);\n-            try {\n-                this->_M_tree_ptr = _S_new_RopeLeaf(__buf, 1, __a);\n-            }\n-            catch(...)\n-\t      {\n-\t\t_RopeRep::__STL_FREE_STRING(__buf, 1, __a);\n-\t\t__throw_exception_again;\n-\t      }\n-        }\n-\n-        rope(size_t __n, _CharT __c,\n-             const allocator_type& __a = allocator_type());\n-\n-        rope(const allocator_type& __a = allocator_type())\n-        : _Base(0, __a) {}\n-\n-        // Construct a rope from a function that can compute its members\n-        rope(char_producer<_CharT> *__fn, size_t __len, bool __delete_fn,\n-             const allocator_type& __a = allocator_type())\n-            : _Base(__a)\n-        {\n-            this->_M_tree_ptr = (0 == __len) ?\n-               0 : _S_new_RopeFunction(__fn, __len, __delete_fn, __a);\n-        }\n-\n-        rope(const rope& __x, const allocator_type& __a = allocator_type())\n-        : _Base(__x._M_tree_ptr, __a)\n-        {\n-            _S_ref(this->_M_tree_ptr);\n-        }\n-\n-        ~rope()\n-        {\n-            _S_unref(this->_M_tree_ptr);\n-        }\n-\n-        rope& operator=(const rope& __x)\n-        {\n-            _RopeRep* __old = this->_M_tree_ptr;\n-            this->_M_tree_ptr = __x._M_tree_ptr;\n-            _S_ref(this->_M_tree_ptr);\n-            _S_unref(__old);\n-            return(*this);\n-        }\n-\n-        void clear()\n-        {\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = 0;\n-        }\n-\n-        void push_back(_CharT __x)\n-        {\n-            _RopeRep* __old = this->_M_tree_ptr;\n-            this->_M_tree_ptr\n-\t      = _S_destr_concat_char_iter(this->_M_tree_ptr, &__x, 1);\n-            _S_unref(__old);\n-        }\n-\n-        void pop_back()\n-        {\n-            _RopeRep* __old = this->_M_tree_ptr;\n-            this->_M_tree_ptr = \n-              _S_substring(this->_M_tree_ptr,\n-\t\t\t   0,\n-\t\t\t   this->_M_tree_ptr->_M_size - 1);\n-            _S_unref(__old);\n-        }\n-\n-        _CharT back() const\n-        {\n-            return _S_fetch(this->_M_tree_ptr, this->_M_tree_ptr->_M_size - 1);\n-        }\n-\n-        void push_front(_CharT __x)\n-        {\n-            _RopeRep* __old = this->_M_tree_ptr;\n-            _RopeRep* __left =\n-              __STL_ROPE_FROM_UNOWNED_CHAR_PTR(&__x, 1, get_allocator());\n-            try {\n-              this->_M_tree_ptr = _S_concat(__left, this->_M_tree_ptr);\n-              _S_unref(__old);\n-              _S_unref(__left);\n-            }\n-            catch(...)\n-\t      {\n-\t\t_S_unref(__left);\n-\t\t__throw_exception_again;\n-\t      }\n-        }\n-\n-        void pop_front()\n-        {\n-            _RopeRep* __old = this->_M_tree_ptr;\n-            this->_M_tree_ptr\n-\t      = _S_substring(this->_M_tree_ptr, 1, this->_M_tree_ptr->_M_size);\n-            _S_unref(__old);\n-        }\n-\n-        _CharT front() const\n-        {\n-            return _S_fetch(this->_M_tree_ptr, 0);\n-        }\n-\n-        void balance()\n-        {\n-            _RopeRep* __old = this->_M_tree_ptr;\n-            this->_M_tree_ptr = _S_balance(this->_M_tree_ptr);\n-            _S_unref(__old);\n-        }\n-\n-        void copy(_CharT* __buffer) const {\n-            _Destroy(__buffer, __buffer + size());\n-            _S_flatten(this->_M_tree_ptr, __buffer);\n-        }\n-\n-        // This is the copy function from the standard, but\n-        // with the arguments reordered to make it consistent with the\n-        // rest of the interface.\n-        // Note that this guaranteed not to compile if the draft standard\n-        // order is assumed.\n-        size_type copy(size_type __pos, size_type __n, _CharT* __buffer) const \n-        {\n-            size_t __size = size();\n-            size_t __len = (__pos + __n > __size? __size - __pos : __n);\n-\n-            _Destroy(__buffer, __buffer + __len);\n-            _S_flatten(this->_M_tree_ptr, __pos, __len, __buffer);\n-            return __len;\n-        }\n-\n-        // Print to stdout, exposing structure.  May be useful for\n-        // performance debugging.\n-        void dump() {\n-            _S_dump(this->_M_tree_ptr);\n-        }\n-\n-        // Convert to 0 terminated string in new allocated memory.\n-        // Embedded 0s in the input do not terminate the copy.\n-        const _CharT* c_str() const;\n-\n-        // As above, but lso use the flattened representation as the\n-        // the new rope representation.\n-        const _CharT* replace_with_c_str();\n-\n-        // Reclaim memory for the c_str generated flattened string.\n-        // Intentionally undocumented, since it's hard to say when this\n-        // is safe for multiple threads.\n-        void delete_c_str () {\n-            if (0 == this->_M_tree_ptr) return;\n-            if (_RopeRep::_S_leaf == this->_M_tree_ptr->_M_tag && \n-                ((_RopeLeaf*)this->_M_tree_ptr)->_M_data == \n-                      this->_M_tree_ptr->_M_c_string) {\n-                // Representation shared\n-                return;\n-            }\n-#           ifndef __GC\n-              this->_M_tree_ptr->_M_free_c_string();\n-#           endif\n-            this->_M_tree_ptr->_M_c_string = 0;\n-        }\n-\n-        _CharT operator[] (size_type __pos) const {\n-            return _S_fetch(this->_M_tree_ptr, __pos);\n-        }\n-\n-        _CharT at(size_type __pos) const {\n-           // if (__pos >= size()) throw out_of_range;  // XXX\n-           return (*this)[__pos];\n-        }\n-\n-        const_iterator begin() const {\n-            return(const_iterator(this->_M_tree_ptr, 0));\n-        }\n-\n-        // An easy way to get a const iterator from a non-const container.\n-        const_iterator const_begin() const {\n-            return(const_iterator(this->_M_tree_ptr, 0));\n-        }\n-\n-        const_iterator end() const {\n-            return(const_iterator(this->_M_tree_ptr, size()));\n-        }\n-\n-        const_iterator const_end() const {\n-            return(const_iterator(this->_M_tree_ptr, size()));\n-        }\n-\n-        size_type size() const { \n-            return(0 == this->_M_tree_ptr? 0 : this->_M_tree_ptr->_M_size);\n-        }\n-\n-        size_type length() const {\n-            return size();\n-        }\n-\n-        size_type max_size() const {\n-            return _S_min_len[_RopeRep::_S_max_rope_depth-1] - 1;\n-            //  Guarantees that the result can be sufficirntly\n-            //  balanced.  Longer ropes will probably still work,\n-            //  but it's harder to make guarantees.\n-        }\n-\n-        typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-\n-        const_reverse_iterator rbegin() const {\n-            return const_reverse_iterator(end());\n-        }\n-\n-        const_reverse_iterator const_rbegin() const {\n-            return const_reverse_iterator(end());\n-        }\n-\n-        const_reverse_iterator rend() const {\n-            return const_reverse_iterator(begin());\n-        }\n-\n-        const_reverse_iterator const_rend() const {\n-            return const_reverse_iterator(begin());\n-        }\n-\n-        template<class _CharT2, class _Alloc2>\n-        friend rope<_CharT2,_Alloc2>\n-        operator+ (const rope<_CharT2,_Alloc2>& __left,\n-                   const rope<_CharT2,_Alloc2>& __right);\n-        \n-        template<class _CharT2, class _Alloc2>\n-        friend rope<_CharT2,_Alloc2>\n-        operator+ (const rope<_CharT2,_Alloc2>& __left,\n-                   const _CharT2* __right);\n-        \n-        template<class _CharT2, class _Alloc2>\n-        friend rope<_CharT2,_Alloc2>\n-        operator+ (const rope<_CharT2,_Alloc2>& __left, _CharT2 __right);\n-        // The symmetric cases are intentionally omitted, since they're presumed\n-        // to be less common, and we don't handle them as well.\n-\n-        // The following should really be templatized.\n-        // The first argument should be an input iterator or\n-        // forward iterator with value_type _CharT.\n-        rope& append(const _CharT* __iter, size_t __n) {\n-            _RopeRep* __result = \n-              _S_destr_concat_char_iter(this->_M_tree_ptr, __iter, __n);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-            return *this;\n-        }\n-\n-        rope& append(const _CharT* __c_string) {\n-            size_t __len = _S_char_ptr_len(__c_string);\n-            append(__c_string, __len);\n-            return(*this);\n-        }\n-\n-        rope& append(const _CharT* __s, const _CharT* __e) {\n-            _RopeRep* __result =\n-                _S_destr_concat_char_iter(this->_M_tree_ptr, __s, __e - __s);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-            return *this;\n-        }\n-\n-        rope& append(const_iterator __s, const_iterator __e) {\n-            _Self_destruct_ptr __appendee(_S_substring(\n-              __s._M_root, __s._M_current_pos, __e._M_current_pos));\n-            _RopeRep* __result = \n-              _S_concat(this->_M_tree_ptr, (_RopeRep*)__appendee);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-            return *this;\n-        }\n-\n-        rope& append(_CharT __c) {\n-            _RopeRep* __result = \n-              _S_destr_concat_char_iter(this->_M_tree_ptr, &__c, 1);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-            return *this;\n-        }\n-\n-        rope& append() { return append(_CharT()); }  // XXX why?\n-\n-        rope& append(const rope& __y) {\n-            _RopeRep* __result = _S_concat(this->_M_tree_ptr, __y._M_tree_ptr);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-            return *this;\n-        }\n-\n-        rope& append(size_t __n, _CharT __c) {\n-            rope<_CharT,_Alloc> __last(__n, __c);\n-            return append(__last);\n-        }\n-\n-        void swap(rope& __b) {\n-            _RopeRep* __tmp = this->_M_tree_ptr;\n-            this->_M_tree_ptr = __b._M_tree_ptr;\n-            __b._M_tree_ptr = __tmp;\n-        }\n-\n-\n-    protected:\n-        // Result is included in refcount.\n-        static _RopeRep* replace(_RopeRep* __old, size_t __pos1,\n-                                  size_t __pos2, _RopeRep* __r) {\n-            if (0 == __old) { _S_ref(__r); return __r; }\n-            _Self_destruct_ptr __left(\n-              _S_substring(__old, 0, __pos1));\n-            _Self_destruct_ptr __right(\n-              _S_substring(__old, __pos2, __old->_M_size));\n-            _RopeRep* __result;\n-\n-            if (0 == __r) {\n-                __result = _S_concat(__left, __right);\n-            } else {\n-                _Self_destruct_ptr __left_result(_S_concat(__left, __r));\n-                __result = _S_concat(__left_result, __right);\n-            }\n-            return __result;\n-        }\n-\n-    public:\n-        void insert(size_t __p, const rope& __r) {\n-            _RopeRep* __result = \n-              replace(this->_M_tree_ptr, __p, __p, __r._M_tree_ptr);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-        }\n-\n-        void insert(size_t __p, size_t __n, _CharT __c) {\n-            rope<_CharT,_Alloc> __r(__n,__c);\n-            insert(__p, __r);\n-        }\n-\n-        void insert(size_t __p, const _CharT* __i, size_t __n) {\n-            _Self_destruct_ptr __left(_S_substring(this->_M_tree_ptr, 0, __p));\n-            _Self_destruct_ptr __right(_S_substring(this->_M_tree_ptr,\n-\t\t\t\t\t\t    __p, size()));\n-            _Self_destruct_ptr __left_result(\n-              _S_concat_char_iter(__left, __i, __n));\n-                // _S_ destr_concat_char_iter should be safe here.\n-                // But as it stands it's probably not a win, since __left\n-                // is likely to have additional references.\n-            _RopeRep* __result = _S_concat(__left_result, __right);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-        }\n-\n-        void insert(size_t __p, const _CharT* __c_string) {\n-            insert(__p, __c_string, _S_char_ptr_len(__c_string));\n-        }\n-\n-        void insert(size_t __p, _CharT __c) {\n-            insert(__p, &__c, 1);\n-        }\n-\n-        void insert(size_t __p) {\n-            _CharT __c = _CharT();\n-            insert(__p, &__c, 1);\n-        }\n-\n-        void insert(size_t __p, const _CharT* __i, const _CharT* __j) {\n-            rope __r(__i, __j);\n-            insert(__p, __r);\n-        }\n-\n-        void insert(size_t __p, const const_iterator& __i,\n-                              const const_iterator& __j) {\n-            rope __r(__i, __j);\n-            insert(__p, __r);\n-        }\n-\n-        void insert(size_t __p, const iterator& __i,\n-                              const iterator& __j) {\n-            rope __r(__i, __j);\n-            insert(__p, __r);\n-        }\n-\n-        // (position, length) versions of replace operations:\n-\n-        void replace(size_t __p, size_t __n, const rope& __r) {\n-            _RopeRep* __result = \n-              replace(this->_M_tree_ptr, __p, __p + __n, __r._M_tree_ptr);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-        }\n-\n-        void replace(size_t __p, size_t __n, \n-                     const _CharT* __i, size_t __i_len) {\n-            rope __r(__i, __i_len);\n-            replace(__p, __n, __r);\n-        }\n-\n-        void replace(size_t __p, size_t __n, _CharT __c) {\n-            rope __r(__c);\n-            replace(__p, __n, __r);\n-        }\n-\n-        void replace(size_t __p, size_t __n, const _CharT* __c_string) {\n-            rope __r(__c_string);\n-            replace(__p, __n, __r);\n-        }\n-\n-        void replace(size_t __p, size_t __n, \n-                     const _CharT* __i, const _CharT* __j) {\n-            rope __r(__i, __j);\n-            replace(__p, __n, __r);\n-        }\n-\n-        void replace(size_t __p, size_t __n,\n-                     const const_iterator& __i, const const_iterator& __j) {\n-            rope __r(__i, __j);\n-            replace(__p, __n, __r);\n-        }\n-\n-        void replace(size_t __p, size_t __n,\n-                     const iterator& __i, const iterator& __j) {\n-            rope __r(__i, __j);\n-            replace(__p, __n, __r);\n-        }\n-\n-        // Single character variants:\n-        void replace(size_t __p, _CharT __c) {\n-            iterator __i(this, __p);\n-            *__i = __c;\n-        }\n-\n-        void replace(size_t __p, const rope& __r) {\n-            replace(__p, 1, __r);\n-        }\n-\n-        void replace(size_t __p, const _CharT* __i, size_t __i_len) {\n-            replace(__p, 1, __i, __i_len);\n-        }\n-\n-        void replace(size_t __p, const _CharT* __c_string) {\n-            replace(__p, 1, __c_string);\n-        }\n-\n-        void replace(size_t __p, const _CharT* __i, const _CharT* __j) {\n-            replace(__p, 1, __i, __j);\n-        }\n-\n-        void replace(size_t __p, const const_iterator& __i,\n-                               const const_iterator& __j) {\n-            replace(__p, 1, __i, __j);\n-        }\n-\n-        void replace(size_t __p, const iterator& __i,\n-                               const iterator& __j) {\n-            replace(__p, 1, __i, __j);\n-        }\n-\n-        // Erase, (position, size) variant.\n-        void erase(size_t __p, size_t __n) {\n-            _RopeRep* __result = replace(this->_M_tree_ptr, __p, __p + __n, 0);\n-            _S_unref(this->_M_tree_ptr);\n-            this->_M_tree_ptr = __result;\n-        }\n-\n-        // Erase, single character\n-        void erase(size_t __p) {\n-            erase(__p, __p + 1);\n-        }\n-\n-        // Insert, iterator variants.  \n-        iterator insert(const iterator& __p, const rope& __r)\n-                { insert(__p.index(), __r); return __p; }\n-        iterator insert(const iterator& __p, size_t __n, _CharT __c)\n-                { insert(__p.index(), __n, __c); return __p; }\n-        iterator insert(const iterator& __p, _CharT __c) \n-                { insert(__p.index(), __c); return __p; }\n-        iterator insert(const iterator& __p ) \n-                { insert(__p.index()); return __p; }\n-        iterator insert(const iterator& __p, const _CharT* c_string) \n-                { insert(__p.index(), c_string); return __p; }\n-        iterator insert(const iterator& __p, const _CharT* __i, size_t __n)\n-                { insert(__p.index(), __i, __n); return __p; }\n-        iterator insert(const iterator& __p, const _CharT* __i, \n-                        const _CharT* __j)\n-                { insert(__p.index(), __i, __j);  return __p; }\n-        iterator insert(const iterator& __p,\n-                        const const_iterator& __i, const const_iterator& __j)\n-                { insert(__p.index(), __i, __j); return __p; }\n-        iterator insert(const iterator& __p,\n-                        const iterator& __i, const iterator& __j)\n-                { insert(__p.index(), __i, __j); return __p; }\n-\n-        // Replace, range variants.\n-        void replace(const iterator& __p, const iterator& __q,\n-                     const rope& __r)\n-                { replace(__p.index(), __q.index() - __p.index(), __r); }\n-        void replace(const iterator& __p, const iterator& __q, _CharT __c)\n-                { replace(__p.index(), __q.index() - __p.index(), __c); }\n-        void replace(const iterator& __p, const iterator& __q,\n-                     const _CharT* __c_string)\n-                { replace(__p.index(), __q.index() - __p.index(), __c_string); }\n-        void replace(const iterator& __p, const iterator& __q,\n-                     const _CharT* __i, size_t __n)\n-                { replace(__p.index(), __q.index() - __p.index(), __i, __n); }\n-        void replace(const iterator& __p, const iterator& __q,\n-                     const _CharT* __i, const _CharT* __j)\n-                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }\n-        void replace(const iterator& __p, const iterator& __q,\n-                     const const_iterator& __i, const const_iterator& __j)\n-                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }\n-        void replace(const iterator& __p, const iterator& __q,\n-                     const iterator& __i, const iterator& __j)\n-                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }\n-\n-        // Replace, iterator variants.\n-        void replace(const iterator& __p, const rope& __r)\n-                { replace(__p.index(), __r); }\n-        void replace(const iterator& __p, _CharT __c)\n-                { replace(__p.index(), __c); }\n-        void replace(const iterator& __p, const _CharT* __c_string)\n-                { replace(__p.index(), __c_string); }\n-        void replace(const iterator& __p, const _CharT* __i, size_t __n)\n-                { replace(__p.index(), __i, __n); }\n-        void replace(const iterator& __p, const _CharT* __i, const _CharT* __j)\n-                { replace(__p.index(), __i, __j); }\n-        void replace(const iterator& __p, const_iterator __i, \n-                     const_iterator __j)\n-                { replace(__p.index(), __i, __j); }\n-        void replace(const iterator& __p, iterator __i, iterator __j)\n-                { replace(__p.index(), __i, __j); }\n-\n-        // Iterator and range variants of erase\n-        iterator erase(const iterator& __p, const iterator& __q) {\n-            size_t __p_index = __p.index();\n-            erase(__p_index, __q.index() - __p_index);\n-            return iterator(this, __p_index);\n-        }\n-        iterator erase(const iterator& __p) {\n-            size_t __p_index = __p.index();\n-            erase(__p_index, 1);\n-            return iterator(this, __p_index);\n-        }\n-\n-        rope substr(size_t __start, size_t __len = 1) const {\n-            return rope<_CharT,_Alloc>(\n-                        _S_substring(this->_M_tree_ptr,\n-\t\t\t\t     __start,\n-\t\t\t\t     __start + __len));\n-        }\n-\n-        rope substr(iterator __start, iterator __end) const {\n-            return rope<_CharT,_Alloc>(\n-                _S_substring(this->_M_tree_ptr,\n-\t\t\t     __start.index(),\n-\t\t\t     __end.index()));\n-        }\n-        \n-        rope substr(iterator __start) const {\n-            size_t __pos = __start.index();\n-            return rope<_CharT,_Alloc>(\n-                        _S_substring(this->_M_tree_ptr, __pos, __pos + 1));\n-        }\n-        \n-        rope substr(const_iterator __start, const_iterator __end) const {\n-            // This might eventually take advantage of the cache in the\n-            // iterator.\n-            return rope<_CharT,_Alloc>(\n-              _S_substring(this->_M_tree_ptr, __start.index(), __end.index()));\n-        }\n-\n-        rope<_CharT,_Alloc> substr(const_iterator __start) {\n-            size_t __pos = __start.index();\n-            return rope<_CharT,_Alloc>(\n-              _S_substring(this->_M_tree_ptr, __pos, __pos + 1));\n-        }\n-\n-        static const size_type npos;\n-\n-        size_type find(_CharT __c, size_type __pos = 0) const;\n-        size_type find(const _CharT* __s, size_type __pos = 0) const {\n-            size_type __result_pos;\n-            const_iterator __result =\n-\t      std::search(const_begin() + __pos, const_end(),\n-\t\t\t  __s, __s + _S_char_ptr_len(__s));\n-            __result_pos = __result.index();\n-#           ifndef __STL_OLD_ROPE_SEMANTICS\n-                if (__result_pos == size()) __result_pos = npos;\n-#           endif\n-            return __result_pos;\n-        }\n-\n-        iterator mutable_begin() {\n-            return(iterator(this, 0));\n-        }\n-\n-        iterator mutable_end() {\n-            return(iterator(this, size()));\n-        }\n-\n-        typedef reverse_iterator<iterator> reverse_iterator;\n-\n-        reverse_iterator mutable_rbegin() {\n-            return reverse_iterator(mutable_end());\n-        }\n-\n-        reverse_iterator mutable_rend() {\n-            return reverse_iterator(mutable_begin());\n-        }\n-\n-        reference mutable_reference_at(size_type __pos) {\n-            return reference(this, __pos);\n-        }\n-\n-#       ifdef __STD_STUFF\n-            reference operator[] (size_type __pos) {\n-                return _char_ref_proxy(this, __pos);\n-            }\n-\n-            reference at(size_type __pos) {\n-                // if (__pos >= size()) throw out_of_range;  // XXX\n-                return (*this)[__pos];\n-            }\n-\n-            void resize(size_type __n, _CharT __c) {}\n-            void resize(size_type __n) {}\n-            void reserve(size_type __res_arg = 0) {}\n-            size_type capacity() const {\n-                return max_size();\n-            }\n-\n-          // Stuff below this line is dangerous because it's error prone.\n-          // I would really like to get rid of it.\n-            // copy function with funny arg ordering.\n-              size_type copy(_CharT* __buffer, size_type __n, \n-                             size_type __pos = 0) const {\n-                return copy(__pos, __n, __buffer);\n-              }\n-\n-            iterator end() { return mutable_end(); }\n-\n-            iterator begin() { return mutable_begin(); }\n-\n-            reverse_iterator rend() { return mutable_rend(); }\n-\n-            reverse_iterator rbegin() { return mutable_rbegin(); }\n-\n-#       else\n-\n-            const_iterator end() { return const_end(); }\n-\n-            const_iterator begin() { return const_begin(); }\n-\n-            const_reverse_iterator rend() { return const_rend(); }\n-  \n-            const_reverse_iterator rbegin() { return const_rbegin(); }\n-\n-#       endif\n-        \n-};\n-\n-template <class _CharT, class _Alloc>\n-const typename rope<_CharT, _Alloc>::size_type rope<_CharT, _Alloc>::npos =\n-                        (size_type)(-1);\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator== (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return (__x._M_current_pos == __y._M_current_pos && \n-          __x._M_root == __y._M_root);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator< (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-                       const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return (__x._M_current_pos < __y._M_current_pos);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator!= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator> (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-                       const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator<= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator>= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline ptrdiff_t operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-                           const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_const_iterator<_CharT,_Alloc>\n-operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {\n-  return _Rope_const_iterator<_CharT,_Alloc>(\n-            __x._M_root, __x._M_current_pos - __n);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_const_iterator<_CharT,_Alloc>\n-operator+(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {\n-  return _Rope_const_iterator<_CharT,_Alloc>(\n-           __x._M_root, __x._M_current_pos + __n);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_const_iterator<_CharT,_Alloc>\n-operator+(ptrdiff_t __n, const _Rope_const_iterator<_CharT,_Alloc>& __x) {\n-  return _Rope_const_iterator<_CharT,_Alloc>(\n-           __x._M_root, __x._M_current_pos + __n);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator== (const _Rope_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return (__x._M_current_pos == __y._M_current_pos && \n-          __x._M_root_rope == __y._M_root_rope);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator< (const _Rope_iterator<_CharT,_Alloc>& __x,\n-                       const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return (__x._M_current_pos < __y._M_current_pos);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator!= (const _Rope_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator> (const _Rope_iterator<_CharT,_Alloc>& __x,\n-                       const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator<= (const _Rope_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator>= (const _Rope_iterator<_CharT,_Alloc>& __x,\n-                        const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline ptrdiff_t operator-(const _Rope_iterator<_CharT,_Alloc>& __x,\n-                           const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_iterator<_CharT,_Alloc>\n-operator-(const _Rope_iterator<_CharT,_Alloc>& __x,\n-          ptrdiff_t __n) {\n-  return _Rope_iterator<_CharT,_Alloc>(\n-    __x._M_root_rope, __x._M_current_pos - __n);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_iterator<_CharT,_Alloc>\n-operator+(const _Rope_iterator<_CharT,_Alloc>& __x,\n-          ptrdiff_t __n) {\n-  return _Rope_iterator<_CharT,_Alloc>(\n-    __x._M_root_rope, __x._M_current_pos + __n);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_iterator<_CharT,_Alloc>\n-operator+(ptrdiff_t __n, const _Rope_iterator<_CharT,_Alloc>& __x) {\n-  return _Rope_iterator<_CharT,_Alloc>(\n-    __x._M_root_rope, __x._M_current_pos + __n);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline\n-rope<_CharT,_Alloc>\n-operator+ (const rope<_CharT,_Alloc>& __left,\n-           const rope<_CharT,_Alloc>& __right)\n-{\n-    return rope<_CharT,_Alloc>(\n-      rope<_CharT,_Alloc>::_S_concat(__left._M_tree_ptr, __right._M_tree_ptr));\n-    // Inlining this should make it possible to keep __left and\n-    // __right in registers.\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline\n-rope<_CharT,_Alloc>&\n-operator+= (rope<_CharT,_Alloc>& __left, \n-      const rope<_CharT,_Alloc>& __right)\n-{\n-    __left.append(__right);\n-    return __left;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline\n-rope<_CharT,_Alloc>\n-operator+ (const rope<_CharT,_Alloc>& __left,\n-           const _CharT* __right) {\n-    size_t __rlen = rope<_CharT,_Alloc>::_S_char_ptr_len(__right);\n-    return rope<_CharT,_Alloc>(\n-      rope<_CharT,_Alloc>::_S_concat_char_iter(\n-        __left._M_tree_ptr, __right, __rlen)); \n-}\n-\n-template <class _CharT, class _Alloc>\n-inline\n-rope<_CharT,_Alloc>&\n-operator+= (rope<_CharT,_Alloc>& __left,\n-            const _CharT* __right) {\n-    __left.append(__right);\n-    return __left;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline\n-rope<_CharT,_Alloc>\n-operator+ (const rope<_CharT,_Alloc>& __left, _CharT __right) {\n-    return rope<_CharT,_Alloc>(\n-      rope<_CharT,_Alloc>::_S_concat_char_iter(\n-        __left._M_tree_ptr, &__right, 1));\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline\n-rope<_CharT,_Alloc>&\n-operator+= (rope<_CharT,_Alloc>& __left, _CharT __right) {\n-    __left.append(__right);\n-    return __left;\n-}\n-\n-template <class _CharT, class _Alloc>\n-bool\n-operator< (const rope<_CharT,_Alloc>& __left, \n-           const rope<_CharT,_Alloc>& __right) {\n-    return __left.compare(__right) < 0;\n-}\n-        \n-template <class _CharT, class _Alloc>\n-bool\n-operator== (const rope<_CharT,_Alloc>& __left, \n-            const rope<_CharT,_Alloc>& __right) {\n-    return __left.compare(__right) == 0;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n-                        const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {\n-        return (__x._M_pos == __y._M_pos && __x._M_root == __y._M_root);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool\n-operator!= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool\n-operator> (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool\n-operator<= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool\n-operator>= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline bool operator!= (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n-                        const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template<class _CharT, class _Traits, class _Alloc>\n-std::basic_ostream<_CharT, _Traits>& operator<<\n-                                        (std::basic_ostream<_CharT, _Traits>& __o,\n-                                         const rope<_CharT, _Alloc>& __r);\n-\n-typedef rope<char> crope;\n-typedef rope<wchar_t> wrope;\n-\n-inline crope::reference __mutable_reference_at(crope& __c, size_t __i)\n-{\n-    return __c.mutable_reference_at(__i);\n-}\n-\n-inline wrope::reference __mutable_reference_at(wrope& __c, size_t __i)\n-{\n-    return __c.mutable_reference_at(__i);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline void swap(rope<_CharT,_Alloc>& __x, rope<_CharT,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n-\n-// Hash functions should probably be revisited later:\n-template<> struct hash<crope>\n-{\n-  size_t operator()(const crope& __str) const\n-  {\n-    size_t __size = __str.size();\n-\n-    if (0 == __size) return 0;\n-    return 13*__str[0] + 5*__str[__size - 1] + __size;\n-  }\n-};\n-\n-\n-template<> struct hash<wrope>\n-{\n-  size_t operator()(const wrope& __str) const\n-  {\n-    size_t __size = __str.size();\n-\n-    if (0 == __size) return 0;\n-    return 13*__str[0] + 5*__str[__size - 1] + __size;\n-  }\n-};\n-\n-} // namespace __gnu_cxx\n-\n-# include <ext/ropeimpl.h>\n-\n-# endif /* __SGI_STL_INTERNAL_ROPE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}]}