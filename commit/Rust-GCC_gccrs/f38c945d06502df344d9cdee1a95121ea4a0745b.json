{"sha": "f38c945d06502df344d9cdee1a95121ea4a0745b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4Yzk0NWQwNjUwMmRmMzQ0ZDljZGVlMWE5NTEyMWVhNGEwNzQ1Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:41:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:41:04Z"}, "message": "Provide first full implementation.\n\nFrom-SVN: r108310", "tree": {"sha": "4429aeaf0943e42eb44b38e5b2b6a6579fc53b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4429aeaf0943e42eb44b38e5b2b6a6579fc53b81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f38c945d06502df344d9cdee1a95121ea4a0745b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38c945d06502df344d9cdee1a95121ea4a0745b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f38c945d06502df344d9cdee1a95121ea4a0745b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38c945d06502df344d9cdee1a95121ea4a0745b/comments", "author": null, "committer": null, "parents": [{"sha": "aedc2c2ba7c059470ad6b054614b58f81dab51b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aedc2c2ba7c059470ad6b054614b58f81dab51b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aedc2c2ba7c059470ad6b054614b58f81dab51b5"}], "stats": {"total": 272, "additions": 253, "deletions": 19}, "files": [{"sha": "5f7de0955bf44cdc933a6422b8d4945a55f8a447", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 253, "deletions": 19, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38c945d06502df344d9cdee1a95121ea4a0745b/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38c945d06502df344d9cdee1a95121ea4a0745b/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=f38c945d06502df344d9cdee1a95121ea4a0745b", "patch": "@@ -30,28 +30,146 @@\n -- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n --                                                                          --\n ------------------------------------------------------------------------------\n---  Dummy implementation.\n+\n+with System.Parameters;\n+with System.CRTL;\n+with System.IO;\n \n package body System.Stack_Usage is\n+   use System.Storage_Elements;\n+   use System;\n+   use System.IO;\n \n-   --------------------\n-   -- Compute_Result --\n-   --------------------\n+   procedure Output_Result (Result_Id : Natural; Result : Task_Result);\n \n-   procedure Compute_Result (Analyzer : in out Stack_Analyzer) is\n-      pragma Unreferenced (Analyzer);\n+   function Report_Result (Analyzer : Stack_Analyzer) return Natural;\n+\n+   function Inner_Than\n+     (A1 : Stack_Address;\n+      A2 : Stack_Address) return Boolean;\n+   pragma Inline (Inner_Than);\n+   --  Return True if, according to the direction of the stack growth, A1 is\n+   --  inner than A2. Inlined to reduce the size of the stack used by the\n+   --  instrumentation code.\n+\n+   ----------------\n+   -- Inner_Than --\n+   ----------------\n+\n+   function Inner_Than\n+     (A1 : Stack_Address;\n+      A2 : Stack_Address) return Boolean\n+   is\n    begin\n-      null;\n-   end Compute_Result;\n+      if System.Parameters.Stack_Grows_Down then\n+         return A1 > A2;\n+      else\n+         return A2 > A1;\n+      end if;\n+   end Inner_Than;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   --  Add comments to this procedure ???\n+   --  Other subprograms also need more comment in code???\n+\n+   procedure Initialize (Buffer_Size : Natural) is\n+      Bottom_Of_Stack : aliased Integer;\n+\n+      Stack_Size_Chars : System.Address;\n+   begin\n+      Result_Array := new Result_Array_Type (1 .. Buffer_Size);\n+      Result_Array.all :=\n+        (others =>\n+           (Task_Name =>\n+              (others => ASCII.NUL),\n+            Measure => 0,\n+            Max_Size => 0));\n+\n+      Is_Enabled := True;\n+\n+      Stack_Size_Chars := System.CRTL.getenv (\"GNAT_STACK_LIMIT\" & ASCII.NUL);\n+\n+      --  If variable GNAT_STACK_LIMIT is set, then we will take care of the\n+      --  environment task, using GNAT_STASK_LIMIT as the size of the stack.\n+      --  It doens't make sens to process the stack when no bound is set (e.g.\n+      --  limit is typically up to 4 GB).\n+\n+      if Stack_Size_Chars /= Null_Address then\n+         declare\n+            Stack_Size : Integer;\n+\n+         begin\n+            Stack_Size := System.CRTL.atoi (Stack_Size_Chars) * 1024;\n+\n+            Initialize_Analyzer (Environment_Task_Analyzer,\n+                                 \"ENVIRONMENT TASK\",\n+                                 Stack_Size,\n+                                 System.Storage_Elements.To_Integer\n+                                   (Bottom_Of_Stack'Address));\n+\n+            Fill_Stack (Environment_Task_Analyzer);\n+\n+            Compute_Environment_Task := True;\n+         end;\n+\n+      --  GNAT_STACK_LIMIT not set\n+\n+      else\n+         Compute_Environment_Task := False;\n+      end if;\n+   end Initialize;\n \n    ----------------\n    -- Fill_Stack --\n    ----------------\n \n    procedure Fill_Stack (Analyzer : in out Stack_Analyzer) is\n-      pragma Unreferenced (Analyzer);\n+\n+      --  Change the local variables and parameters of this function with\n+      --  super-extra care. The more the stack frame size of this function is\n+      --  big, the more an \"instrumentation threshold at writing\" error is\n+      --  likely to happen.\n+\n+      type Word_32_Arr is\n+        array (1 .. Analyzer.Size / (Word_32_Size / Byte_Size)) of Word_32;\n+      pragma Pack (Word_32_Arr);\n+\n+      package Arr_Addr is\n+        new System.Address_To_Access_Conversions (Word_32_Arr);\n+\n+      Arr : aliased Word_32_Arr;\n+\n    begin\n-      null;\n+      for J in Word_32_Arr'Range loop\n+         Arr (J) := Analyzer.Pattern;\n+      end loop;\n+      Analyzer.Array_Address := Arr_Addr.To_Address (Arr'Access);\n+      Analyzer.Inner_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n+      Analyzer.Outer_Pattern_Mark :=\n+        To_Stack_Address (Arr (Word_32_Arr'Last)'Address);\n+\n+      if Inner_Than (Analyzer.Outer_Pattern_Mark,\n+                     Analyzer.Inner_Pattern_Mark) then\n+         Analyzer.Inner_Pattern_Mark := Analyzer.Outer_Pattern_Mark;\n+         Analyzer.Outer_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n+         Analyzer.First_Is_Outermost := True;\n+      else\n+         Analyzer.First_Is_Outermost := False;\n+      end if;\n+\n+      --  If Arr has been packed, the following assertion must be true (we add\n+      --  the size of the element whose address is:\n+      --\n+      --    Min (Analyzer.Inner_Pattern_Mark, Analyzer.Outer_Pattern_Mark)):\n+\n+      pragma Assert\n+        (Analyzer.Size =\n+           Stack_Size\n+             (Analyzer.Outer_Pattern_Mark, Analyzer.Inner_Pattern_Mark) +\n+           Word_32_Size / Byte_Size);\n    end Fill_Stack;\n \n    -------------------------\n@@ -65,32 +183,148 @@ package body System.Stack_Usage is\n       Bottom    : Stack_Address;\n       Pattern   : Word_32 := 16#DEAD_BEEF#)\n    is\n-      pragma Unreferenced (Analyzer);\n-      pragma Unreferenced (Task_Name);\n-      pragma Unreferenced (Size);\n-      pragma Unreferenced (Pattern);\n-      pragma Unreferenced (Bottom);\n    begin\n-      null;\n+      Analyzer.Bottom_Of_Stack := Bottom;\n+      Analyzer.Size := Size;\n+      Analyzer.Pattern := Pattern;\n+      Analyzer.Result_Id := Next_Id;\n+\n+      Analyzer.Task_Name := (others => ' ');\n+\n+      if Task_Name'Length <= Task_Name_Length then\n+         Analyzer.Task_Name (1 .. Task_Name_Length) := Task_Name;\n+      else\n+         Analyzer.Task_Name :=\n+           Task_Name (Task_Name'First ..\n+                        Task_Name'First + Task_Name_Length - 1);\n+      end if;\n+\n+      if Next_Id in Result_Array'Range then\n+         Result_Array (Analyzer.Result_Id).Task_Name := Analyzer.Task_Name;\n+      end if;\n+\n+      Result_Array (Analyzer.Result_Id).Max_Size := Size;\n+      Next_Id := Next_Id + 1;\n    end Initialize_Analyzer;\n \n+   ----------------\n+   -- Stack_Size --\n+   ----------------\n+\n+   function Stack_Size\n+     (SP_Low  : Stack_Address;\n+      SP_High : Stack_Address) return Natural\n+   is\n+   begin\n+      if SP_Low > SP_High then\n+         return Natural (SP_Low - SP_High + 4);\n+      else\n+         return Natural (SP_High - SP_Low + 4);\n+      end if;\n+   end Stack_Size;\n+\n+   --------------------\n+   -- Compute_Result --\n+   --------------------\n+\n+   procedure Compute_Result (Analyzer : in out Stack_Analyzer) is\n+\n+      --  Change the local variables and parameters of this function with\n+      --  super-extra care. The larger the stack frame size of this function\n+      --  is, the more an \"instrumentation threshold at reading\" error is\n+      --  likely to happen.\n+\n+      type Word_32_Arr is\n+        array (1 .. Analyzer.Size / (Word_32_Size / Byte_Size)) of Word_32;\n+      pragma Pack (Word_32_Arr);\n+\n+      package Arr_Addr is\n+        new System.Address_To_Access_Conversions (Word_32_Arr);\n+\n+      Arr_Access : Arr_Addr.Object_Pointer;\n+\n+   begin\n+      Arr_Access := Arr_Addr.To_Pointer (Analyzer.Array_Address);\n+      Analyzer.Outermost_Touched_Mark := Analyzer.Inner_Pattern_Mark;\n+\n+      for J in Word_32_Arr'Range loop\n+         if Arr_Access (J) /= Analyzer.Pattern then\n+            Analyzer.Outermost_Touched_Mark :=\n+              To_Stack_Address (Arr_Access (J)'Address);\n+\n+            if Analyzer.First_Is_Outermost then\n+               exit;\n+            end if;\n+         end if;\n+      end loop;\n+   end Compute_Result;\n+\n+   ---------------------\n+   --  Output_Result --\n+   ---------------------\n+\n+   procedure Output_Result (Result_Id : Natural; Result : Task_Result) is\n+   begin\n+      Set_Output (Standard_Error);\n+      Put (Natural'Image (Result_Id));\n+      Put (\" | \");\n+      Put (Result.Task_Name);\n+      Put (\" | \");\n+      Put (Natural'Image (Result.Max_Size));\n+      Put (\" | \");\n+      Put (Natural'Image (Result.Measure));\n+      New_Line;\n+   end Output_Result;\n+\n    ---------------------\n    --  Output_Results --\n    ---------------------\n \n    procedure Output_Results is\n    begin\n-      null;\n+      if Compute_Environment_Task then\n+         Compute_Result (Environment_Task_Analyzer);\n+         Report_Result (Environment_Task_Analyzer);\n+      end if;\n+\n+      Set_Output (Standard_Error);\n+      Put (\"INDEX | TASK NAME | STACK SIZE | MAX USAGE\");\n+      New_Line;\n+\n+      for J in Result_Array'Range loop\n+         exit when J >= Next_Id;\n+\n+         Output_Result (J, Result_Array (J));\n+      end loop;\n    end Output_Results;\n \n    -------------------\n    -- Report_Result --\n    -------------------\n \n    procedure Report_Result (Analyzer : Stack_Analyzer) is\n-      pragma Unreferenced (Analyzer);\n    begin\n-      null;\n+      if Analyzer.Result_Id in Result_Array'Range then\n+         Result_Array (Analyzer.Result_Id).Measure := Report_Result (Analyzer);\n+      else\n+         Output_Result\n+           (Analyzer.Result_Id,\n+            (Task_Name => Analyzer.Task_Name,\n+             Max_Size  => Analyzer.Size,\n+             Measure   => Report_Result (Analyzer)));\n+      end if;\n+   end Report_Result;\n+\n+   function Report_Result (Analyzer : Stack_Analyzer) return Natural is\n+   begin\n+      if Analyzer.Outermost_Touched_Mark = Analyzer.Inner_Pattern_Mark then\n+         return Stack_Size (Analyzer.Inner_Pattern_Mark,\n+                            Analyzer.Bottom_Of_Stack);\n+\n+      else\n+         return Stack_Size (Analyzer.Outermost_Touched_Mark,\n+                            Analyzer.Bottom_Of_Stack);\n+      end if;\n    end Report_Result;\n \n end System.Stack_Usage;"}]}