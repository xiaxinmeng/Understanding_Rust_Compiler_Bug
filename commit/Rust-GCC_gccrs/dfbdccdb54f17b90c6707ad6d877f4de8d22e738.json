{"sha": "dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiZGNjZGI1NGYxN2I5MGM2NzA3YWQ2ZDg3N2Y0ZGU4ZDIyZTczOA==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-05-14T21:42:32Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-05-14T21:42:32Z"}, "message": "rs6000.c (logical_operand): Rewrite to take MODE into account.\n\n* config/rs6000/rs6000.c (logical_operand): Rewrite to take MODE\ninto account.\n(logical_u_operand): Delete.\n(non_logical_cint_operand): Rewrite to take MODE into account.\n(non_logical_u_cint_operand): Delete.\n(boolean_operator): New function.\n(print_operand): Add new %q operand.\n* config/rs6000/rs6000.h (PREDICATE_CODES): Add boolean_operator,\nremove logical_u_operand and non_logical_u_cint_operand,\nupdate logical_operand and non_logical_cint_operand.\n* config/rs6000/rs6000.md: Rewrite the patterns for performing\nlogical operations to use %q.\n\nFrom-SVN: r33899", "tree": {"sha": "a386e45b66d2d12cce45d0ca5e3fc0eba38d17d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a386e45b66d2d12cce45d0ca5e3fc0eba38d17d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/comments", "author": null, "committer": null, "parents": [{"sha": "f176e826a0833cf5b4cc81430cdda9b980aae9de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f176e826a0833cf5b4cc81430cdda9b980aae9de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f176e826a0833cf5b4cc81430cdda9b980aae9de"}], "stats": {"total": 1210, "additions": 334, "deletions": 876}, "files": [{"sha": "f9c8770b264de796ab6e2d9a06b5c95a4f0490ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "patch": "@@ -1,5 +1,18 @@\n 2000-05-14  Geoffrey Keating  <geoffk@cygnus.com>\n \n+\t* config/rs6000/rs6000.c (logical_operand): Rewrite to take MODE \n+\tinto account.\n+\t(logical_u_operand): Delete.\n+\t(non_logical_cint_operand): Rewrite to take MODE into account.\n+\t(non_logical_u_cint_operand): Delete.\n+\t(boolean_operator): New function.\n+\t(print_operand): Add new %q operand.\n+\t* config/rs6000/rs6000.h (PREDICATE_CODES): Add boolean_operator,\n+\tremove logical_u_operand and non_logical_u_cint_operand,\n+\tupdate logical_operand and non_logical_cint_operand.\n+\t* config/rs6000/rs6000.md: Rewrite the patterns for performing\n+\tlogical operations to use %q.\n+\n \t* config/rs6000/rs6000.md (movsi): Don't modify RTL in-place.\n \t(movdi): Make similar to movsi.\n \t* config/rs6000/rs6000.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): There"}, {"sha": "46415ea560a68c782ae3acc1f2c5ec58d732aeb3", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "patch": "@@ -75,6 +75,7 @@ extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int branch_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int scc_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int trap_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n extern int includes_lshift_p PARAMS ((rtx, rtx));\n extern int includes_rshift_p PARAMS ((rtx, rtx));\n extern int registers_ok_for_quad_peep PARAMS ((rtx, rtx));"}, {"sha": "700064d014574ca198251b08469cbd279482b7b7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 63, "deletions": 70, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "patch": "@@ -949,43 +949,22 @@ logical_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  return (gpc_reg_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-#if HOST_BITS_PER_WIDE_INT != 32\n-\t      && INTVAL (op) > 0\n-\t      && INTVAL (op) < ((HOST_WIDE_INT) 1 << 32)\n-#endif\n-\t      && ((INTVAL (op) & GET_MODE_MASK (mode)\n-\t\t   & (~ (HOST_WIDE_INT) 0xffff)) == 0\n-\t\t  || (INTVAL (op) & GET_MODE_MASK (mode)\n-\t\t      & (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) == 0)));\n-}\n-\n-/* Return 1 if the operand is a non-special register or a 32-bit constant\n-   that can be used as the operand of an OR or XOR insn on the RS/6000.  */\n-\n-int\n-logical_u_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  return (gpc_reg_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && INTVAL (op) > 0\n-#if HOST_BITS_PER_WIDE_INT != 32\n-\t      && INTVAL (op) < ((HOST_WIDE_INT) 1 << 32)\n-#endif\n-\t      && ((INTVAL (op) & GET_MODE_MASK (mode)\n-\t\t   & (~ (HOST_WIDE_INT) 0xffff)) == 0\n-\t\t  || (INTVAL (op) & GET_MODE_MASK (mode)\n-\t\t      & (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) == 0))\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n+  if (gpc_reg_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      unsigned HOST_WIDE_INT cval = INTVAL (op) & GET_MODE_MASK (mode);\n+      return ((cval & (~ (HOST_WIDE_INT) 0xffff)) == 0\n+\t      || (cval & (~ (HOST_WIDE_INT) 0xffff0000u)) == 0);\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      return (CONST_DOUBLE_HIGH (op) == 0\n \t      && ((CONST_DOUBLE_LOW (op)\n-\t\t   & (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) == 0))\n-#endif\n-      );\n+\t\t   & (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) == 0));\n+    }\n+  else\n+    return 0;\n }\n \n /* Return 1 if C is a constant that is not a logical operand (as\n@@ -996,40 +975,8 @@ non_logical_cint_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  return (GET_CODE (op) == CONST_INT\n-#if HOST_BITS_PER_WIDE_INT != 32\n-\t  && INTVAL (op) < ((HOST_WIDE_INT) 1 << 32)\n-#endif\n-\t  && (INTVAL (op) & GET_MODE_MASK (mode) &\n-\t      (~ (HOST_WIDE_INT) 0xffff)) != 0\n-\t  && (INTVAL (op) & GET_MODE_MASK (mode) &\n-\t      (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) != 0);\n-}\n-\n-/* Return 1 if C is an unsigned 32-bit constant that is not a\n-   logical operand (as above).  */\n-\n-int\n-non_logical_u_cint_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && INTVAL (op) > 0\n-#if HOST_BITS_PER_WIDE_INT != 32\n-\t   && INTVAL (op) < ((HOST_WIDE_INT) 1 << 32)\n-#endif\n-\t   && (INTVAL (op) & GET_MODE_MASK (mode)\n-\t       & (~ (HOST_WIDE_INT) 0xffff)) != 0\n-\t   && (INTVAL (op) & GET_MODE_MASK (mode)\n-\t       & (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) != 0)\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && (CONST_DOUBLE_LOW (op) & (~ (HOST_WIDE_INT) 0xffff)) != 0\n-\t      && (CONST_DOUBLE_LOW (op)\n-\t\t  & (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) != 0));\n-#endif\n+  return ((GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n+\t  && ! logical_operand (op, mode));\n }\n \n /* Return 1 if C is a constant that can be encoded in a 32-bit mask on the\n@@ -2963,6 +2910,15 @@ trap_comparison_operator (op, mode)\n   return (GET_RTX_CLASS (GET_CODE (op)) == '<'\n           || GET_CODE (op) == EQ || GET_CODE (op) == NE);\n }\n+\n+int\n+boolean_operator (op, mode)\n+    rtx op;\n+    enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  return (code == AND || code == IOR || code == XOR);\n+}\n \f\n /* Return 1 if ANDOP is a mask that has no bits on that are not in the\n    mask required to convert the result of a rotate insn into a shift\n@@ -3630,6 +3586,43 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", REGNO (XEXP (x, 0)));\n       return;\n \n+    case 'q':\n+      /* This outputs the logical code corresponding to a boolean\n+\t expression.  The expression may have one or both operands\n+\t negated (if one, only the first one).  */\n+      {\n+\tint neg, op;\n+\tconst char *const *t;\n+\tconst char *s;\n+\tenum rtx_code code = GET_CODE (x);\n+\tstatic const char * const tbl[3][3] = {\n+\t  { \"and\", \"andc\", \"nor\" },\n+\t  { \"or\", \"orc\", \"nand\" },\n+\t  { \"xor\", \"eqv\", \"xor\" } };\n+\n+\tif (code == AND)\n+\t  t = tbl[0];\n+\telse if (code == IOR)\n+\t  t = tbl[1];\n+\telse if (code == XOR)\n+\t  t = tbl[2];\n+\telse\n+\t  output_operand_lossage (\"invalid %%q value\");\n+\n+\tif (GET_CODE (XEXP (x, 0)) != NOT)\n+\t  s = t[0];\n+\telse\n+\t  {\n+\t    if (GET_CODE (XEXP (x, 1)) == NOT)\n+\t      s = t[2];\n+\t    else\n+\t      s = t[1];\n+\t  }\n+\t\n+\tfputs (s, file);\n+      }\n+      return;\n+\n     case 'R':\n       /* X is a CR register.  Print the mask for `mtcrf'.  */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))"}, {"sha": "c2fbb331da2b63ef4b05eb5ee8ceaf0d1774343e", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "patch": "@@ -2726,10 +2726,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"and64_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-  {\"logical_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n-  {\"logical_u_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}}, \\\n-  {\"non_logical_cint_operand\", {CONST_INT}},\t\t\t\\\n-  {\"non_logical_u_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\\\n+  {\"logical_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n+  {\"non_logical_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\\\n   {\"count_register_operand\", {REG}},\t\t\t\t\\\n@@ -2748,7 +2746,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"scc_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n \t\t\t       GT, LEU, LTU, GEU, GTU}},\t\\\n   {\"trap_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n-\t\t\t\tGT, LEU, LTU, GEU, GTU}},\n+\t\t\t\tGT, LEU, LTU, GEU, GTU}},\t\\\n+  {\"boolean_operator\", {AND, IOR, XOR}},\n \n /* uncomment for disabling the corresponding default options */\n /* #define  MACHINE_no_sched_interblock */"}, {"sha": "f58e6a1ead59dc9e882dfe471a6a4e0a5eed8f1f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 253, "deletions": 801, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbdccdb54f17b90c6707ad6d877f4de8d22e738/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dfbdccdb54f17b90c6707ad6d877f4de8d22e738", "patch": "@@ -2540,6 +2540,11 @@\n   [(set_attr \"type\" \"idiv\")])\n \f\n ;; Logical instructions\n+;; The logical instructions are mostly combined by using match_operator,\n+;; but the plain AND insns are somewhat different because there is no\n+;; plain 'andi' (only 'andi.'), no plain 'andis', and there are all\n+;; those rotate-and-mask operations.  Thus, the AND insns come first.\n+\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n \t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n@@ -2655,92 +2660,6 @@\n     }\n }\")\n \n-(define_insn \"*iorsi3_internal1\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,L\")))]\n-  \"\"\n-  \"@\n-   or %0,%1,%2\n-   {oril|ori} %0,%1,%b2\n-   {oriu|oris} %0,%1,%u2\"\n-  [(set_attr \"length\" \"4,4,4\")])\n-\n-(define_insn \"*iorsi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r\"))]\n-  \"! TARGET_POWERPC64\"\n-  \"@\n-   or. %3,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(ior:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*iorsi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"! TARGET_POWERPC64\"\n-  \"@\n-   or. %0,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (match_dup 1) (match_dup 2)))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(ior:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-;; Split an IOR that we can't do in one insn into two insns, each of which\n-;; does one 16-bit part.  This is used by combine.\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"non_logical_cint_operand\" \"\")))]\n-  \"\"\n-  [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))\n-   (set (match_dup 0) (ior:SI (match_dup 0) (match_dup 4)))]\n-\"\n-{\n-  operands[3] = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-}\")\n-\n (define_expand \"xorsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n@@ -2762,419 +2681,224 @@\n     }\n }\")\n \n-(define_insn \"*xorsi3_internal1\"\n+(define_insn \"*boolsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,L\")))]\n+\t(match_operator:SI 3 \"boolean_operator\"\n+\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n+\t  (match_operand:SI 2 \"logical_operand\" \"r,K,L\")]))]\n   \"\"\n   \"@\n-   xor %0,%1,%2\n-   {xoril|xori} %0,%1,%b2\n-   {xoriu|xoris} %0,%1,%u2\"\n-  [(set_attr \"length\" \"4,4,4\")])\n+   %q3 %0,%1,%2\n+   {%q3il|%q3i} %0,%1,%b2\n+   {%q3iu|%q3is} %0,%1,%u2\")\n \n-(define_insn \"*xorsi3_internal2\"\n+(define_insn \"*boolsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=r,r\"))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   xor. %3,%1,%2\n+   %q4. %3,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:SI 3 \"\"))]\n   \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(xor:SI (match_dup 1)\n-\t\t(match_dup 2)))\n+  [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*xorsi3_internal3\"\n+(define_insn \"*boolsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(xor:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n+\t(match_dup 4))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   xor. %0,%1,%2\n+   %q4. %0,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(xor:SI (match_dup 1) (match_dup 2)))]\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(match_dup 4))]\n   \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(xor:SI (match_dup 1)\n-\t\t(match_dup 2)))\n+  [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n \n-;; Split an XOR that we can't do in one insn into two insns, each of which\n-;; does one 16-bit part.  This is used by combine.\n+;; Split an logical operation that we can't do in one insn into two insns, \n+;; each of which does one 16-bit part.  This is used by combine.\n \n (define_split\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-        (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-                (match_operand:SI 2 \"non_logical_cint_operand\" \"\")))]\n+\t(match_operator:SI 3 \"boolean_operator\"\n+\t [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:SI 2 \"non_logical_cint_operand\" \"\")]))]\n   \"\"\n-  [(set (match_dup 0) (xor:SI (match_dup 1) (match_dup 3)))\n-   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 4)))]\n+  [(set (match_dup 0) (match_dup 4))\n+   (set (match_dup 0) (match_dup 5))]\n \"\n {\n-  operands[3] = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+  rtx i;\n+  i = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n+  operands[4] = gen_rtx (GET_CODE (operands[3]), SImode,\n+\t\t\t operands[1], i);\n+  i = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+  operands[5] = gen_rtx (GET_CODE (operands[3]), SImode,\n+\t\t\t operands[0], i);\n }\")\n \n-(define_insn \"*eqvsi3_internal1\"\n+(define_insn \"*boolcsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n-   \"\"\n-   \"eqv %0,%1,%2\")\n-\n-(define_insn \"*eqvsi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r\"))]\n-   \"! TARGET_POWERPC64\"\n-   \"@\n-    eqv. %3,%1,%2\n-    #\"\n-   [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(not:SI (xor:SI (match_dup 1)\n-\t\t\t(match_dup 2))))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*eqvsi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(not:SI (xor:SI (match_dup 1) (match_dup 2))))]\n-   \"! TARGET_POWERPC64\"\n-   \"@\n-    eqv. %0,%1,%2\n-    #\"\n-   [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t    (match_operand:SI 2 \"reg_or_short_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(not:SI (xor:SI (match_dup 1)\n-\t\t\t(match_dup 2))))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(not:SI (xor:SI (match_dup 1)\n-\t\t\t(match_dup 2))))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*andcsi3_internal1\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))]\n+\t(match_operator:SI 3 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (match_operand:SI 2 \"logical_operand\" \"r\")]))]\n   \"\"\n-  \"andc %0,%2,%1\")\n+  \"%q3 %0,%2,%1\")\n \n-(define_insn \"*andcsi3_internal2\"\n+(define_insn \"*boolcsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=r,r\"))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   andc. %3,%2,%1\n+   %q4. %3,%2,%1\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:SI 3 \"\"))]\n   \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(match_dup 2)))\n+  [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*andcsi3_internal3\"\n+(define_insn \"*boolcsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(match_dup 2)))]\n-  \"! TARGET_POWERPC64\"\n-  \"@\n-   andc. %0,%2,%1\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(match_dup 2)))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*iorcsi3_internal1\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"orc %0,%2,%1\")\n-\n-(define_insn \"*iorcsi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r\"))]\n+\t(match_dup 4))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   orc. %3,%2,%1\n+   %q4. %0,%2,%1\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(ior:SI (not:SI (match_dup 1))\n-\t\t(match_dup 2)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*iorcsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:SI (not:SI (match_dup 1)) (match_dup 2)))]\n-  \"! TARGET_POWERPC64\"\n-  \"@\n-   orc. %0,%2,%1\n-   #\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (not:SI (match_dup 1))\n-\t\t(match_dup 2)))]\n+\t(match_dup 4))]\n   \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(ior:SI (not:SI (match_dup 1))\n-\t\t(match_dup 2)))\n+  [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*nandsi3_internal1\"\n+(define_insn \"*boolccsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t(not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n+\t(match_operator:SI 3 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (not:SI (match_operand:SI 2 \"logical_operand\" \"r\"))]))]\n   \"\"\n-  \"nand %0,%1,%2\")\n+  \"%q3 %0,%1,%2\")\n \n-(define_insn \"*nandsi3_internal2\"\n+(define_insn \"*boolccsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n+\t  (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))])\n+\t (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=r,r\"))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   nand. %3,%1,%2\n+   %q4. %3,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))])\n+\t (const_int 0)))\n    (clobber (match_scratch:SI 3 \"\"))]\n   \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(ior:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))\n+  [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*nandsi3_internal3\"\n+(define_insn \"*boolccsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))])\n+\t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))]\n-  \"! TARGET_POWERPC64\"\n-  \"@\n-   nand. %0,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(ior:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*norsi3_internal1\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t(not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n-  \"\"\n-  \"nor %0,%1,%2\")\n-\n-(define_insn \"*norsi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r\"))]\n+\t(match_dup 4))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   nor. %3,%1,%2\n+   %q4. %0,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*norsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n+\t [(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))])\n+\t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))]\n-  \"! TARGET_POWERPC64\"\n-  \"@\n-   nor. %0,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))]\n+\t(match_dup 4))]\n   \"! TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:SI (not:SI (match_dup 1))\n-\t\t(not:SI (match_dup 2))))\n+  [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n@@ -7336,574 +7060,302 @@\n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_u_cint_operand\" \"\")))]\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n   \"TARGET_POWERPC64\"\n   \"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && ! logical_u_operand (operands[2], DImode))\n+  if (non_logical_cint_operand (operands[2], DImode))\n     {\n-      HOST_WIDE_INT value = INTVAL (operands[2]);\n-      rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n-\t\t ? operands[0] : gen_reg_rtx (DImode));\n-\n-      emit_insn (gen_iordi3 (tmp, operands[1],\n-\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-      emit_insn (gen_iordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n-      DONE;\n-    }\n-  else if (GET_CODE (operands[2]) == CONST_DOUBLE\n-      && ! logical_u_operand (operands[2], DImode))\n-    {\n-      HOST_WIDE_INT value = CONST_DOUBLE_LOW (operands[2]);\n+      HOST_WIDE_INT value;\n       rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (DImode));\n \n-      emit_insn (gen_iordi3 (tmp, operands[1],\n-\t\t\t     immed_double_const (value\n-\t\t\t\t\t\t & (~ (HOST_WIDE_INT) 0xffff),\n-\t\t\t\t\t         0, DImode)));\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+        {\n+          value = INTVAL (operands[2]);\n+\t  emit_insn (gen_iordi3 (tmp, operands[1],\n+\t\t\t\t GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n+\t}\n+      else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+        {\n+\t  value = CONST_DOUBLE_LOW (operands[2]);\n+\t  emit_insn (gen_iordi3 (tmp, operands[1],\n+\t\t\t\t immed_double_const (value\n+\t\t\t\t\t\t     & (~ (HOST_WIDE_INT) 0xffff),\n+\t\t\t\t\t\t     0, DImode)));\n+\t}\n       emit_insn (gen_iordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n }\")\n \n-(define_insn \"*iordi3_internal1\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:DI 2 \"logical_u_operand\" \"r,K,JF\")))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   or %0,%1,%2\n-   ori %0,%1,%b2\n-   oris %0,%1,%u2\")\n-\n-(define_insn \"*iordi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r\"))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   or. %3,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(ior:DI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*iordi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   or. %0,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(ior:DI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-;; Split an IOR that we can't do in one insn into two insns, each of which\n-;; does one 16-bit part.  This is used by combine.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"non_logical_u_cint_operand\" \"\")))]\n-  \"TARGET_POWERPC64\"\n-  [(set (match_dup 0) (ior:DI (match_dup 1) (match_dup 3)))\n-   (set (match_dup 0) (ior:DI (match_dup 0) (match_dup 4)))]\n-\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-    {\n-      HOST_WIDE_INT value = CONST_DOUBLE_LOW (operands[2]);\n-      operands[3] = immed_double_const (value & (~ (HOST_WIDE_INT) 0xffff),\n-\t\t\t\t\t0, DImode);\n-      operands[4] = GEN_INT (value & 0xffff);\n-    }\n-  else\n-    {\n-      operands[3] = GEN_INT (INTVAL (operands[2])\n-\t\t\t     & (~ (HOST_WIDE_INT) 0xffff));\n-      operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-    }\n-}\")\n-\n (define_expand \"xordi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_u_cint_operand\" \"\")))]\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n   \"TARGET_POWERPC64\"\n   \"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && ! logical_u_operand (operands[2], DImode))\n+  if (non_logical_cint_operand (operands[2], DImode))\n     {\n-      HOST_WIDE_INT value = INTVAL (operands[2]);\n-      rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n-\t\t ? operands[0] : gen_reg_rtx (DImode));\n-\n-      emit_insn (gen_xordi3 (tmp, operands[1],\n-\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-      emit_insn (gen_xordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n-      DONE;\n-    }\n-  else if (GET_CODE (operands[2]) == CONST_DOUBLE\n-      && ! logical_u_operand (operands[2], DImode))\n-    {\n-      HOST_WIDE_INT value = CONST_DOUBLE_LOW (operands[2]);\n+      HOST_WIDE_INT value;\n       rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (DImode));\n \n-      emit_insn (gen_xordi3 (tmp, operands[1],\n-\t\t\t     immed_double_const (value\n-\t\t\t\t\t\t & (~ (HOST_WIDE_INT) 0xffff),\n-\t\t\t\t\t         0, DImode)));\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+        {\n+          value = INTVAL (operands[2]);\n+\t  emit_insn (gen_xordi3 (tmp, operands[1],\n+\t\t\t\t GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n+\t}\n+      else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+        {\n+\t  value = CONST_DOUBLE_LOW (operands[2]);\n+\t  emit_insn (gen_xordi3 (tmp, operands[1],\n+\t\t\t\t immed_double_const (value\n+\t\t\t\t\t\t     & (~ (HOST_WIDE_INT) 0xffff),\n+\t\t\t\t\t\t     0, DImode)));\n+\t}\n       emit_insn (gen_xordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n }\")\n \n-(define_insn \"*xordi3_internal1\"\n+(define_insn \"*booldi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:DI 2 \"logical_u_operand\" \"r,K,JF\")))]\n+\t(match_operator:DI 3 \"boolean_operator\"\n+\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n+\t  (match_operand:DI 2 \"logical_operand\" \"r,K,JF\")]))]\n   \"TARGET_POWERPC64\"\n   \"@\n-   xor %0,%1,%2\n-   xori %0,%1,%b2\n-   xoris %0,%1,%u2\")\n+   %q3 %0,%1,%2\n+   %q3i %0,%1,%b2\n+   %q3is %0,%1,%u2\")\n \n-(define_insn \"*xordi3_internal2\"\n+(define_insn \"*booldi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:DI 3 \"=r,r\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n-   xor. %3,%1,%2\n+   %q4. %3,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:DI 3 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(xor:DI (match_dup 1) (match_dup 2)))\n+  [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*xordi3_internal3\"\n+(define_insn \"*booldi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(xor:DI (match_dup 1) (match_dup 2)))]\n+\t(match_dup 4))]\n   \"TARGET_POWERPC64\"\n   \"@\n-   xor. %0,%1,%2\n+   %q4. %0,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(xor:DI (match_dup 1) (match_dup 2)))]\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(match_dup 4))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(xor:DI (match_dup 1) (match_dup 2)))\n+  [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n \n-;; Split an XOR that we can't do in one insn into two insns, each of which\n-;; does one 16-bit part.  This is used by combine.\n+;; Split an logical operation that we can't do in one insn into two insns, \n+;; each of which does one 16-bit part.  This is used by combine.\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-        (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-                (match_operand:DI 2 \"non_logical_u_cint_operand\" \"\")))]\n+\t(match_operator:DI 3 \"boolean_operator\"\n+\t [(match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:DI 2 \"non_logical_cint_operand\" \"\")]))]\n   \"TARGET_POWERPC64\"\n-  [(set (match_dup 0) (xor:DI (match_dup 1) (match_dup 3)))\n-   (set (match_dup 0) (xor:DI (match_dup 0) (match_dup 4)))]\n+  [(set (match_dup 0) (match_dup 4))\n+   (set (match_dup 0) (match_dup 5))]\n \"\n {\n+  rtx i3,i4;\n+  \n   if (GET_CODE (operands[2]) == CONST_DOUBLE)\n     {\n       HOST_WIDE_INT value = CONST_DOUBLE_LOW (operands[2]);\n-      operands[3] = immed_double_const (value & (~ (HOST_WIDE_INT) 0xffff),\n+      i3 = immed_double_const (value & (~ (HOST_WIDE_INT) 0xffff),\n \t\t\t\t\t0, DImode);\n-      operands[4] = GEN_INT (value & 0xffff);\n+      i4 = GEN_INT (value & 0xffff);\n     }\n   else\n     {\n-      operands[3] = GEN_INT (INTVAL (operands[2])\n+      i3 = GEN_INT (INTVAL (operands[2])\n \t\t\t     & (~ (HOST_WIDE_INT) 0xffff));\n-      operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+      i4 = GEN_INT (INTVAL (operands[2]) & 0xffff);\n     }\n+  operands[4] = gen_rtx (GET_CODE (operands[3]), DImode,\n+\t\t\t operands[1], i3);\n+  operands[5] = gen_rtx (GET_CODE (operands[3]), DImode,\n+\t\t\t operands[0], i4);\n }\")\n \n-(define_insn \"*eqvdi3_internal1\"\n+(define_insn \"*boolcdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n-   \"TARGET_POWERPC64\"\n-   \"eqv %0,%1,%2\")\n-\n-(define_insn \"*eqvdi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r\"))]\n-   \"TARGET_POWERPC64\"\n-   \"@\n-    eqv. %3,%1,%2\n-    #\"\n-   [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))]\n-   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(not:DI (xor:DI (match_dup 1) (match_dup 2))))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*eqvdi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(not:DI (xor:DI (match_dup 1) (match_dup 2))))]\n-   \"TARGET_POWERPC64\"\n-   \"@\n-    eqv. %0,%1,%2\n-    #\"\n-   [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(not:DI (xor:DI (match_dup 1) (match_dup 2))))]\n-   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(not:DI (xor:DI (match_dup 1) (match_dup 2))))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*andcdi3_internal1\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+\t(match_operator:DI 3 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (match_operand:DI 2 \"logical_operand\" \"r\")]))]\n   \"TARGET_POWERPC64\"\n-  \"andc %0,%2,%1\")\n+  \"%q3 %0,%1,%2\")\n \n-(define_insn \"*andcdi3_internal2\"\n+(define_insn \"*boolcdi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\"))\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:DI 3 \"=r,r\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n-   andc. %3,%2,%1\n+   %q4. %3,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r\")])\n+\t (const_int 0)))\n    (clobber (match_scratch:DI 3 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(and:DI (not:DI (match_dup 1)) (match_dup 2)))\n+  [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*andcdi3_internal3\"\n+(define_insn \"*boolcdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:DI (not:DI (match_dup 1)) (match_dup 2)))]\n+\t(match_dup 4))]\n   \"TARGET_POWERPC64\"\n   \"@\n-   andc. %0,%2,%1\n+   %q4. %0,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (not:DI (match_dup 1)) (match_dup 2)))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:DI (not:DI (match_dup 1)) (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*iorcdi3_internal1\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_POWERPC64\"\n-  \"orc %0,%2,%1\")\n-\n-(define_insn \"*iorcdi3_inernal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r\"))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   orc. %3,%2,%1\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(ior:DI (not:DI (match_dup 1)) (match_dup 2)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*iorcdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n+\t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:DI (not:DI (match_dup 1)) (match_dup 2)))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   orc. %0,%2,%1\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:DI (not:DI (match_dup 1)) (match_dup 2)))]\n+\t(match_dup 4))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(ior:DI (not:DI (match_dup 1)) (match_dup 2)))\n+  [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*nanddi3_internal1\"\n+(define_insn \"*boolccdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t(not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n+\t(match_operator:DI 3 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (not:DI (match_operand:DI 2 \"logical_operand\" \"r\"))]))]\n   \"TARGET_POWERPC64\"\n-  \"nand %0,%1,%2\")\n+  \"%q3 %0,%1,%2\")\n \n-(define_insn \"*nanddi3_internal2\"\n+(define_insn \"*boolccdi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\"))\n+\t  (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))])\n+\t (const_int 0)))\n    (clobber (match_scratch:DI 3 \"=r,r\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n-   nand. %3,%1,%2\n+   %q4. %3,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t  (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))])\n+\t (const_int 0)))\n    (clobber (match_scratch:DI 3 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(ior:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))\n+  [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*nanddi3_internal3\"\n+(define_insn \"*boolccdi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))])\n+\t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   nand. %0,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(ior:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*nordi3_internal1\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t(not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n-  \"TARGET_POWERPC64\"\n-  \"nor %0,%1,%2\")\n-\n-(define_insn \"*nordi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r\"))]\n+\t(match_dup 4))]\n   \"TARGET_POWERPC64\"\n   \"@\n-   nor. %3,%1,%2\n+   %q4. %0,%1,%2\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(and:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*nordi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")))\n-\t\t    (const_int 0)))\n+\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n+\t [(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\"))\n+\t  (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))])\n+\t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   nor. %0,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,8\")])\n-\f\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"\")))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))]\n+\t(match_dup 4))]\n   \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))\n+  [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n-\n+\f\n ;; Now define ways of moving data around.\n \n ;; Elf specific ways of loading addresses for non-PIC code."}]}