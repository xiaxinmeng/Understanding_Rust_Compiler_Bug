{"sha": "eb172681f75b5ff4196bf4e670826a7f442eb90c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIxNzI2ODFmNzViNWZmNDE5NmJmNGU2NzA4MjZhN2Y0NDJlYjkwYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-10-11T16:11:35Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-10-11T16:11:35Z"}, "message": "re PR middle-end/17657 (ICE in expand_case)\n\n\n\tPR middle-end/17657\n\t* stmt.c (add_case_node): Add additional type argument.  Declare\n\tas static to match prototype.  Convert the upper and lower bounds\n\tto the specified index type.  Optimize away case ranges/values\n\tthat are outside the index type's bounds.  Truncate case ranges\n\tthat span the index type's bounds.\n\t(expand_case): Avoid unnessary computation and memory allocation\n\twhen index type is error_mark_node.  Pass index_type as required\n\tby change to add_case_node API.  No need to convert case range\n\tbounds to index_type, this is now done by add_case_node.\n\n\t* gcc.dg/switch-4.c: New test case.\n\nFrom-SVN: r88881", "tree": {"sha": "fe3cbc69dccdda01ae79f78ed7e383ab4f17b65e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe3cbc69dccdda01ae79f78ed7e383ab4f17b65e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb172681f75b5ff4196bf4e670826a7f442eb90c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb172681f75b5ff4196bf4e670826a7f442eb90c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb172681f75b5ff4196bf4e670826a7f442eb90c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb172681f75b5ff4196bf4e670826a7f442eb90c/comments", "author": null, "committer": null, "parents": [{"sha": "539ed333f6e84709a56649827401a1b1b6ceb374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539ed333f6e84709a56649827401a1b1b6ceb374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539ed333f6e84709a56649827401a1b1b6ceb374"}], "stats": {"total": 146, "additions": 110, "deletions": 36}, "files": [{"sha": "947f65619e2e5aeaf9bf1e9dee43d5bee3afd01c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb172681f75b5ff4196bf4e670826a7f442eb90c", "patch": "@@ -1,3 +1,16 @@\n+2004-10-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/17657\n+\t* stmt.c (add_case_node): Add additional type argument.  Declare\n+\tas static to match prototype.  Convert the upper and lower bounds\n+\tto the specified index type.  Optimize away case ranges/values \n+\tthat are outside the index type's bounds.  Truncate case ranges\n+\tthat span the index type's bounds.\n+\t(expand_case): Avoid unnessary computation and memory allocation\n+\twhen index type is error_mark_node.  Pass index_type as required\n+\tby change to add_case_node API.  No need to convert case range\n+\tbounds to index_type, this is now done by add_case_node.\n+\n 2004-10-11  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390-protos.h (s390_offset_p): Add prototype."}, {"sha": "5560dbc5b2dfa7a8c0b2718e72574e84128a7286", "filename": "gcc/stmt.c", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=eb172681f75b5ff4196bf4e670826a7f442eb90c", "patch": "@@ -122,7 +122,8 @@ static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n static void emit_case_nodes (rtx, case_node_ptr, rtx, tree);\n-static struct case_node *add_case_node (struct case_node *, tree, tree, tree);\n+static struct case_node *add_case_node (struct case_node *, tree,\n+\t\t\t\t\ttree, tree, tree);\n \n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n@@ -2115,19 +2116,55 @@ expand_anon_union_decl (tree decl, tree cleanup ATTRIBUTE_UNUSED,\n /* Do the insertion of a case label into case_list.  The labels are\n    fed to us in descending order from the sorted vector of case labels used\n    in the tree part of the middle end.  So the list we construct is\n-   sorted in ascending order.  */\n+   sorted in ascending order.  The bounds on the case range, LOW and HIGH,\n+   are converted to case's index type TYPE.  */\n \n-struct case_node *\n-add_case_node (struct case_node *head, tree low, tree high, tree label)\n+static struct case_node *\n+add_case_node (struct case_node *head, tree type, tree low, tree high,\n+\t       tree label)\n {\n+  tree min_value, max_value;\n   struct case_node *r;\n \n+  gcc_assert (TREE_CODE (low) == INTEGER_CST);\n+  gcc_assert (!high || TREE_CODE (high) == INTEGER_CST);\n+\n+  min_value = TYPE_MIN_VALUE (type);\n+  max_value = TYPE_MAX_VALUE (type);\n+\n   /* If there's no HIGH value, then this is not a case range; it's\n      just a simple case label.  But that's just a degenerate case\n      range.\n      If the bounds are equal, turn this into the one-value case.  */\n   if (!high || tree_int_cst_equal (low, high))\n-    high = low;\n+    {\n+      /* If the simple case value is unreachable, ignore it.  */\n+      if (tree_int_cst_compare (low, min_value) < 0\n+\t  || tree_int_cst_compare (low, max_value) > 0)\n+\treturn head;\n+      low = fold_convert (type, low);\n+      high = low;\n+    }\n+  else\n+    {\n+      /* If the entire case range is unreachable, ignore it.  */\n+      if (tree_int_cst_compare (high, min_value) < 0\n+\t  || tree_int_cst_compare (low, max_value) > 0)\n+\treturn head;\n+\n+      /* If the lower bound is less than the index type's minimum\n+\t value, truncate the range bounds.  */\n+      if (tree_int_cst_compare (low, min_value) < 0)\n+\tlow = min_value;\n+      low = fold_convert (type, low);\n+\n+      /* If the upper bound is greater than the index type's maximum\n+\t value, truncate the range bounds.  */\n+      if (tree_int_cst_compare (high, max_value) > 0)\n+\thigh = max_value;\n+      high = fold_convert (type, high);\n+    }\n+\n \n   /* Add this label to the chain.  */\n   r = ggc_alloc (sizeof (struct case_node));\n@@ -2307,7 +2344,7 @@ expand_case (tree exp)\n   rtx table_label;\n   int ncases;\n   rtx *labelvec;\n-  int i;\n+  int i, fail;\n   rtx before_case, end, lab;\n \n   tree vec = SWITCH_LABELS (exp);\n@@ -2332,34 +2369,36 @@ expand_case (tree exp)\n   gcc_assert (!SWITCH_BODY (exp));\n   gcc_assert (SWITCH_LABELS (exp));\n \n-  for (i = TREE_VEC_LENGTH (vec); --i >= 0; )\n-    {\n-      tree elt = TREE_VEC_ELT (vec, i);\n-\n-      /* Handle default labels specially.  */\n-      if (!CASE_HIGH (elt) && !CASE_LOW (elt))\n-\t{\n-\t  gcc_assert (!default_label_decl);\n-\t  default_label_decl = CASE_LABEL (elt);\n-        }\n-      else\n-        case_list = add_case_node (case_list, CASE_LOW (elt), CASE_HIGH (elt),\n-\t\t\t\t   CASE_LABEL (elt));\n-    }\n-\n   do_pending_stack_adjust ();\n \n-  /* Make sure start points to something that won't need any transformation\n-     before the end of this function.  */\n-  if (!NOTE_P (get_last_insn ()))\n-    emit_note (NOTE_INSN_DELETED);\n-\n-  start = get_last_insn ();\n-\n   /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n   if (index_type != error_mark_node)\n     {\n-      int fail;\n+      for (i = TREE_VEC_LENGTH (vec); --i >= 0; )\n+\t{\n+\t  tree elt = TREE_VEC_ELT (vec, i);\n+\n+\t  /* Handle default labels specially.  */\n+\t  if (!CASE_HIGH (elt) && !CASE_LOW (elt))\n+\t    {\n+\t      gcc_assert (!default_label_decl);\n+\t      default_label_decl = CASE_LABEL (elt);\n+\t    }\n+\t  else\n+\t    case_list = add_case_node (case_list, index_type,\n+\t\t\t\t       CASE_LOW (elt), CASE_HIGH (elt),\n+\t\t\t\t       CASE_LABEL (elt));\n+\t}\n+\n+\n+      /* Make sure start points to something that won't need any\n+\t transformation before the end of this function.  */\n+      start = get_last_insn ();\n+      if (! NOTE_P (start))\n+\t{\n+\t  emit_note (NOTE_INSN_DELETED);\n+\t  start = get_last_insn ();\n+\t}\n \n       /* If we don't have a default-label, create one here,\n \t after the body of the switch.  */\n@@ -2380,13 +2419,6 @@ expand_case (tree exp)\n       count = 0;\n       for (n = case_list; n; n = n->right)\n \t{\n-\t  /* Check low and high label values are integers.  */\n-\t  gcc_assert (TREE_CODE (n->low) == INTEGER_CST);\n-\t  gcc_assert (TREE_CODE (n->high) == INTEGER_CST);\n-\n-\t  n->low = convert (index_type, n->low);\n-\t  n->high = convert (index_type, n->high);\n-\n \t  /* Count the elements and track the largest and smallest\n \t     of them (treating them as signed even if they are not).  */\n \t  if (count++ == 0)"}, {"sha": "44270aa93e29f3ee7865cf72731d147f997e1e00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb172681f75b5ff4196bf4e670826a7f442eb90c", "patch": "@@ -1,3 +1,8 @@\n+2004-10-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/17657\n+\t* gcc.dg/switch-4.c: New test case.\n+\n 2004-10-11  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.c-torture/execute/20041011-1.c: New test."}, {"sha": "f2d85300d90ffdfc164230307e023ba4ec307f2b", "filename": "gcc/testsuite/gcc.dg/switch-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb172681f75b5ff4196bf4e670826a7f442eb90c/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-4.c?ref=eb172681f75b5ff4196bf4e670826a7f442eb90c", "patch": "@@ -0,0 +1,24 @@\n+/* PR middle-end/17657 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+extern signed char foo(int);\n+\n+void bar (void)\n+{\n+  signed char tmp = foo (0);\n+  int t1 = tmp;\n+  switch (t1)\n+    {\n+    case 1: foo (1); break;\n+    case 2: foo (2); break;\n+    case 3: foo (3); break;\n+    case 4: foo (4); break;\n+    case 5: foo (5); break;\n+    case 6: foo (6); break;\n+    case 7: foo (7); break;\n+    case 255: foo (8); break;\n+    default: break;\n+    }\n+}\n+"}]}