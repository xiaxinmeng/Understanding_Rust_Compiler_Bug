{"sha": "eb11dba2b47beb01a873eb234ed98e30049e0bbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIxMWRiYTJiNDdiZWIwMWE4NzNlYjIzNGVkOThlMzAwNDllMGJiZg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-12T22:47:15Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-12T22:47:15Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh.md: Add splits for inverted compare and branch\n\topportunities.\n\t(*cmpeqsi_t): New insn.\n\t(cmpgtsi_t, cmpgesi_t): Swap r and N alternatives.\n\t(cmpgeusi_t): Use satisfies_constraint_Z.  Emit sett insn in\n\treplacement insn list and not in the preparation statements.\n\t(clrt, sett): Add mt_group attribute.\n\n\tPR target/51244\n\t* gcc.target/sh/pr51244-7.c: New.\n\t* gcc.target/sh/pr51244-8.c: New.\n\t* gcc.target/sh/pr51244-9.c: New.\n\t* gcc.target/sh/pr51244-10.c: New.\n\nFrom-SVN: r190331", "tree": {"sha": "94d55263957ec8e75d55f8db163f435cfce79511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94d55263957ec8e75d55f8db163f435cfce79511"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb11dba2b47beb01a873eb234ed98e30049e0bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb11dba2b47beb01a873eb234ed98e30049e0bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb11dba2b47beb01a873eb234ed98e30049e0bbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb11dba2b47beb01a873eb234ed98e30049e0bbf/comments", "author": null, "committer": null, "parents": [{"sha": "3722862e60b5b82c9ac41ad172bbf0e8e8be54ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3722862e60b5b82c9ac41ad172bbf0e8e8be54ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3722862e60b5b82c9ac41ad172bbf0e8e8be54ee"}], "stats": {"total": 281, "additions": 258, "deletions": 23}, "files": [{"sha": "c327437dc000a4e2dc55c6d8663defd68b1011b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb11dba2b47beb01a873eb234ed98e30049e0bbf", "patch": "@@ -1,3 +1,14 @@\n+2012-08-12  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh.md: Add splits for inverted compare and branch\n+\topportunities.\n+\t(*cmpeqsi_t): New insn.\n+\t(cmpgtsi_t, cmpgesi_t): Swap r and N alternatives.\n+\t(cmpgeusi_t): Use satisfies_constraint_Z.  Emit sett insn in\n+\treplacement insn list and not in the preparation statements.\n+\t(clrt, sett): Add mt_group attribute.\n+\n 2012-08-12 Marc Glisse <marc.glisse@inria.fr>\n \n \tPR middle-end/54193"}, {"sha": "8af99f8e49e60d2de39dc06fca9830d7b4a8f022", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 124, "deletions": 23, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=eb11dba2b47beb01a873eb234ed98e30049e0bbf", "patch": "@@ -742,12 +742,6 @@\n }\n   [(set_attr \"type\" \"mt_group\")])\n \n-;; ??? Perhaps should only accept reg/constant if the register is reg 0.\n-;; That would still allow reload to create cmpi instructions, but would\n-;; perhaps allow forcing the constant into a register when that is better.\n-;; Probably should use r0 for mem/imm compares, but force constant into a\n-;; register for pseudo/imm compares.\n-\n (define_insn \"cmpeqsi_t\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,z,r\")\n@@ -759,24 +753,40 @@\n \tcmp/eq\t%1,%0\"\n    [(set_attr \"type\" \"mt_group\")])\n \n+;; FIXME: For some reason, on SH4A and SH2A combine fails to simplify this\n+;; pattern by itself.  What this actually does is:\n+;;\tx == 0: (1 >> 0-0) & 1 = 1\n+;;\tx != 0: (1 >> 0-x) & 1 = 0\n+;; Without this the test pr51244-8.c fails on SH2A and SH4A.\n+(define_insn_and_split \"*cmpeqsi_t\"\n+  [(set (reg:SI T_REG)\n+\t(and:SI (lshiftrt:SI\n+\t\t  (const_int 1)\n+\t\t  (neg:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")))\n+\t\t(const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (eq:SI (match_dup 0) (const_int 0)))])\n+\n (define_insn \"cmpgtsi_t\"\n   [(set (reg:SI T_REG)\n \t(gt:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,r\")\n-\t       (match_operand:SI 1 \"arith_reg_or_0_operand\" \"r,N\")))]\n+\t       (match_operand:SI 1 \"arith_reg_or_0_operand\" \"N,r\")))]\n   \"TARGET_SH1\"\n   \"@\n-\tcmp/gt\t%1,%0\n-\tcmp/pl\t%0\"\n+\tcmp/pl\t%0\n+\tcmp/gt\t%1,%0\"\n    [(set_attr \"type\" \"mt_group\")])\n \n (define_insn \"cmpgesi_t\"\n   [(set (reg:SI T_REG)\n \t(ge:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,r\")\n-\t       (match_operand:SI 1 \"arith_reg_or_0_operand\" \"r,N\")))]\n+\t       (match_operand:SI 1 \"arith_reg_or_0_operand\" \"N,r\")))]\n   \"TARGET_SH1\"\n   \"@\n-\tcmp/ge\t%1,%0\n-\tcmp/pz\t%0\"\n+\tcmp/pz\t%0\n+\tcmp/ge\t%1,%0\"\n    [(set_attr \"type\" \"mt_group\")])\n \n ;; FIXME: This is actually wrong.  There is no way to literally move a\n@@ -815,6 +825,99 @@\n   DONE;\n })\n \n+;; Combine patterns to invert compare and branch operations for which we\n+;; don't have actual comparison insns.  These patterns are used in cases\n+;; which appear after the initial cbranchsi expansion, which also does\n+;; some condition inversion.\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t\t  (match_operand:SI 1 \"arith_reg_or_0_operand\" \"\"))\n+\t\t      (label_ref (match_operand 2))\n+\t\t      (pc)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (eq:SI (match_dup 0) (match_dup 1)))\n+   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n+\t\t\t   (pc)))])\n+\n+;; FIXME: Similar to the *cmpeqsi_t pattern above, for some reason, on SH4A\n+;; and SH2A combine fails to simplify this pattern by itself.\n+;; What this actually does is:\n+;;\tx == 0: (1 >> 0-0) & 1 = 1\n+;;\tx != 0: (1 >> 0-x) & 1 = 0\n+;; Without this the test pr51244-8.c fails on SH2A and SH4A.\n+(define_split\n+  [(set (pc)\n+\t(if_then_else\n+\t  (eq (and:SI (lshiftrt:SI\n+\t\t\t(const_int 1)\n+\t\t\t(neg:SI (match_operand:SI 0 \"arith_reg_operand\" \"\")))\n+\t\t      (const_int 1))\n+\t      (const_int 0))\n+\t  (label_ref (match_operand 2))\n+\t  (pc)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (eq:SI (match_dup 0) (const_int 0)))\n+   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n+\t\t\t   (pc)))])\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (le (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t\t  (match_operand:SI 1 \"arith_reg_or_0_operand\" \"\"))\n+\t\t      (label_ref (match_operand 2))\n+\t\t      (pc)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (gt:SI (match_dup 0) (match_dup 1)))\n+   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n+\t\t\t   (pc)))])\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (lt (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t\t  (match_operand:SI 1 \"arith_reg_or_0_operand\" \"\"))\n+\t\t      (label_ref (match_operand 2))\n+\t\t      (pc)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (ge:SI (match_dup 0) (match_dup 1)))\n+   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n+\t\t\t   (pc)))])\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (leu (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t\t   (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n+\t\t      (label_ref (match_operand 2))\n+\t\t      (pc)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (gtu:SI (match_dup 0) (match_dup 1)))\n+   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n+\t\t\t   (pc)))])\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (ltu (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t\t   (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n+\t\t      (label_ref (match_operand 2))\n+\t\t      (pc)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (geu:SI (match_dup 0) (match_dup 1)))\n+   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n+\t\t\t   (pc)))])\n+\n ;; -------------------------------------------------------------------------\n ;; SImode unsigned integer comparisons\n ;; -------------------------------------------------------------------------\n@@ -825,21 +928,18 @@\n \t\t(match_operand:SI 1 \"arith_reg_or_0_operand\" \"rN\")))]\n   \"TARGET_SH1\"\n   \"cmp/hs\t%1,%0\"\n-  \"&& operands[1] == CONST0_RTX (SImode)\"\n-  [(pc)]\n-{\n-  emit_insn (gen_sett ());\n-  DONE;\n-}\n-   [(set_attr \"type\" \"mt_group\")])\n+  \"&& satisfies_constraint_Z (operands[0])\"\n+  [(set (reg:SI T_REG) (const_int 1))]\n+  \"\"\n+  [(set_attr \"type\" \"mt_group\")])\n \n (define_insn \"cmpgtusi_t\"\n   [(set (reg:SI T_REG)\n \t(gtu:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n \t\t(match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"cmp/hi\t%1,%0\"\n-   [(set_attr \"type\" \"mt_group\")])\n+  [(set_attr \"type\" \"mt_group\")])\n \n \f\n ;; -------------------------------------------------------------------------\n@@ -5132,13 +5232,14 @@ label:\n (define_insn \"clrt\"\n   [(set (reg:SI T_REG) (const_int 0))]\n   \"TARGET_SH1\"\n-  \"clrt\")\n+  \"clrt\"\n+  [(set_attr \"type\" \"mt_group\")])\n \n (define_insn \"sett\"\n   [(set (reg:SI T_REG) (const_int 1))]\n   \"TARGET_SH1\"\n-  \"sett\")\n-\n+  \"sett\"\n+  [(set_attr \"type\" \"mt_group\")])\n \n ;; Use the combine pass to transform sequences such as\n ;;\tmov\tr5,r0"}, {"sha": "f8b52217b2b23e80ddbed6a791477812855d2aba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb11dba2b47beb01a873eb234ed98e30049e0bbf", "patch": "@@ -1,3 +1,11 @@\n+2012-08-12  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* gcc.target/sh/pr51244-7.c: New.\n+\t* gcc.target/sh/pr51244-8.c: New.\n+\t* gcc.target/sh/pr51244-9.c: New.\n+\t* gcc.target/sh/pr51244-10.c: New.\n+\n 2012-08-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* gcc.target/sh/pr50749-sf-postinc-1.c: Skip for -m3.  Don't skip for"}, {"sha": "20f052eeddaf03532a14691452f28fc27d495f0c", "filename": "gcc/testsuite/gcc.target/sh/pr51244-10.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-10.c?ref=eb11dba2b47beb01a873eb234ed98e30049e0bbf", "patch": "@@ -0,0 +1,27 @@\n+/* Check that compare-branch is inverted properly.\n+   In this case the improved bit test is a side effect of compare-branch\n+   inversion patterns, even though the branch condition does not get\n+   inverted here.\n+   Example:\n+\tmov.b\t@(14,r9),r0\t->\tmov.b\t@(14,r9),r0\n+\tshll\tr0\t\t\tcmp/pz\tr0\n+\tsubc\tr0,r0\t\t\tbt\t.L192\n+\tand\t#1,r0\n+\ttst\tr0,r0\n+\tbt\t.L195\n+*/\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"shll|subc|and\" } } */\n+int\n+test_00 (int* p)\n+{\n+  int nr = 15;\n+  volatile char* addr = (volatile char*)&p[1];\n+\n+  if ((addr[(nr >> 3) ^ 7] & (1 << (nr & 7))) == 0)\n+    return 40;\n+  else\n+    return 50;\n+}"}, {"sha": "e7e3ac1385c1e4960afe1c4300a36b5d3363e795", "filename": "gcc/testsuite/gcc.target/sh/pr51244-7.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-7.c?ref=eb11dba2b47beb01a873eb234ed98e30049e0bbf", "patch": "@@ -0,0 +1,26 @@\n+/* Check that compare-branch is inverted properly.\n+   Example:\n+\tclrt\t\t->\tclrt\n+\tsubc\tr0,r6\t\tsubc\tr0,r6\n+\tmov\tr3,r7\t\tmov\tr3,r7\n+\tsubc\tr1,r7\t\tsubc\tr1,r7\n+\tmov\t#0,r1\t\ttst\tr7,r7\n+\tcmp/hi\tr1,r7\t\tbf\t.L111\n+\tbt\t.L111\t\tbra\t.L197\n+\tbra\t.L197\n+\tnop\n+*/\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"cmp/hi\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\t#0\" } } */\n+\n+int other_func (long long);\n+int\n+test_00 (unsigned long long a, unsigned long long b)\n+{\n+  if ((a - b) > 0xFFFFFFFFLL)\n+    return other_func (a - b);\n+  return 20;\n+}"}, {"sha": "9d95ae3f87ae2da04e7fb2bd1b6ff20a60d215d9", "filename": "gcc/testsuite/gcc.target/sh/pr51244-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-8.c?ref=eb11dba2b47beb01a873eb234ed98e30049e0bbf", "patch": "@@ -0,0 +1,27 @@\n+/* Check that compare-branch is inverted properly.\n+   Example:\n+\tmov\t#1,r0\t->\ttst\tr8,r8\n+\tneg\tr8,r1\t\tbt\t.L47\n+\tshad\tr1,r0\n+\ttst\t#1,r0\n+\tbf\t.L47\n+*/\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"shad|neg\" } } */\n+\n+int test_01_00 (int*, void*);\n+int\n+test_01 (int* m, void* v)\n+{\n+  unsigned long n = (unsigned long)v - 1;\n+\n+  if (!n)\n+    return 50;\n+  \n+  if (1 & (1 << n))\t/* if n == 0: 1 & (1 << 0) -> true  */\n+    return 60;\t\t\n+  else\t\t\t/* if n != 0: 1 & (1 << n) -> false  */\n+    return -8;\n+}"}, {"sha": "13639bdc87d0a6777fe3ef8ba3bb1275a242c9a7", "filename": "gcc/testsuite/gcc.target/sh/pr51244-9.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb11dba2b47beb01a873eb234ed98e30049e0bbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-9.c?ref=eb11dba2b47beb01a873eb234ed98e30049e0bbf", "patch": "@@ -0,0 +1,35 @@\n+/* Check that compare-branch is inverted properly.\n+   Example:\n+\tmov.w\t.L566,r2\t->\tmov.w\t.L566,r2\n+\tadd\tr11,r2\t\t\tadd\tr11,r2\n+\tmov.l\t@(12,r2),r7\t\tmov.l\t@(8,r2),r5\n+\tmov.l\t@(8,r2),r5\t\tmov.l\t@(12,r2),r2\n+\tmov\t#0,r2\t\t\ttst\tr2,r2\n+\tcmp/hi\tr2,r7\t\t\tbt\t.L534\n+\tbf\t.L534\n+*/\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\t#0\" } } */\n+static inline unsigned int\n+test_03_00 (unsigned int x)\n+{\n+  /* Return unassigned value on purpose.  */\n+  unsigned int res;\n+  return res;\n+}\n+\n+struct S\n+{\n+  unsigned int a;\n+  unsigned int b;\n+};\n+\n+int test_03 (struct S* i)\n+{\n+ if ((i->a != 2 && i->a != 3) || i->a > test_03_00 (i->b))\n+   return -5;\n+\n+ return -55;\n+}"}]}