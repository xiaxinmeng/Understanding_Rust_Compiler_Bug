{"sha": "c3ff2812ae4ff647356577388e327cdf937fbf27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNmZjI4MTJhZTRmZjY0NzM1NjU3NzM4OGUzMjdjZGY5MzdmYmYyNw==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2015-07-14T23:32:06Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2015-07-14T23:32:06Z"}, "message": "nios2-protos.h (nios2_expand_return): Declare.\n\n2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Cesar Philippidis  <cesar@codesourcery.com>\n\t    Chung-Lin Tang  <cltang@codesourcery.com>\n\n\tgcc/\n\t* config/nios2/nios2-protos.h (nios2_expand_return): Declare.\n\t* config/nios2/nios2.c (struct GTY (()) machine_function): Add\n\tcallee_save_reg_size and uses_anonymous_args fields.\n\t(nios2_compute_frame_layout): Update for CDX push.n/pop.n usage.\n\t(nios2_create_cfa_notes): New function.\n\t(nios2_adjust_stack): New function for adjusting stack.\n\t(nios2_expand_prologue): Update for CDX push.n/pop.n usage.\n\tUse nios2_adjust_stack.\n\t(nios2_expand_epilogue): Likewise.\n\t(nios2_expand_return): New function.\n\t(nios2_can_use_return_insn): Update for CDX pop.n usage.\n\t(nios2_setup_incoming_varargs): Set uses_anonymous_args flag.\n\tIf TARGET_HAS_CDX, defer pushing regs to nios2_expand_prologue.\n\t* config/nios2/nios2.md (return): Use nios2_expand_return.\n\nCo-Authored-By: Cesar Philippidis <cesar@codesourcery.com>\nCo-Authored-By: Chung-Lin Tang <cltang@codesourcery.com>\n\nFrom-SVN: r225799", "tree": {"sha": "0fdd4b81c0074bc4217be797cfd211bb7133c251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fdd4b81c0074bc4217be797cfd211bb7133c251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3ff2812ae4ff647356577388e327cdf937fbf27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ff2812ae4ff647356577388e327cdf937fbf27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3ff2812ae4ff647356577388e327cdf937fbf27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ff2812ae4ff647356577388e327cdf937fbf27/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa32db37e435d17e473f9089021fb1d8b888a37d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa32db37e435d17e473f9089021fb1d8b888a37d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa32db37e435d17e473f9089021fb1d8b888a37d"}], "stats": {"total": 456, "additions": 382, "deletions": 74}, "files": [{"sha": "43d9b3c1f9ec50ca2e896f84c4e6c907a80d2443", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3ff2812ae4ff647356577388e327cdf937fbf27", "patch": "@@ -1,3 +1,22 @@\n+2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* config/nios2/nios2-protos.h (nios2_expand_return): Declare.\n+\t* config/nios2/nios2.c (struct GTY (()) machine_function): Add\n+\tcallee_save_reg_size and uses_anonymous_args fields.\n+\t(nios2_compute_frame_layout): Update for CDX push.n/pop.n usage.\n+\t(nios2_create_cfa_notes): New function.\n+\t(nios2_adjust_stack): New function for adjusting stack.\n+\t(nios2_expand_prologue): Update for CDX push.n/pop.n usage.\n+\tUse nios2_adjust_stack.\n+\t(nios2_expand_epilogue): Likewise.\n+\t(nios2_expand_return): New function.\n+\t(nios2_can_use_return_insn): Update for CDX pop.n usage.\n+\t(nios2_setup_incoming_varargs): Set uses_anonymous_args flag.\n+\tIf TARGET_HAS_CDX, defer pushing regs to nios2_expand_prologue.\n+\t* config/nios2/nios2.md (return): Use nios2_expand_return.\n+\n 2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>"}, {"sha": "897a23fdc2a257f02f90768d36138886ddccd023", "filename": "gcc/config/nios2/nios2-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h?ref=c3ff2812ae4ff647356577388e327cdf937fbf27", "patch": "@@ -26,6 +26,7 @@ extern int nios2_initial_elimination_offset (int, int);\n extern int nios2_can_use_return_insn (void);\n extern void nios2_expand_prologue (void);\n extern void nios2_expand_epilogue (bool);\n+extern bool nios2_expand_return (void);\n extern void nios2_function_profiler (FILE *, int);\n \n #ifdef RTX_CODE"}, {"sha": "2d7c4a2169fc5911c28b5e7cd4ea9966105bebd3", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 358, "deletions": 73, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=c3ff2812ae4ff647356577388e327cdf937fbf27", "patch": "@@ -95,10 +95,14 @@ struct GTY (()) machine_function\n   int args_size;\n   /* Number of bytes needed to store registers in frame.  */\n   int save_reg_size;\n+  /* Number of bytes used to store callee-saved registers.  */\n+  int callee_save_reg_size;\n   /* Offset from new stack pointer to store registers.  */\n   int save_regs_offset;\n   /* Offset from save_regs_offset to store frame pointer register.  */\n   int fp_save_offset;\n+  /* != 0 if function has a variable argument list.  */\n+  int uses_anonymous_args;\n   /* != 0 if frame layout already calculated.  */\n   int initialized;\n };\n@@ -378,14 +382,11 @@ nios2_compute_frame_layout (void)\n   int var_size;\n   int out_args_size;\n   int save_reg_size;\n+  int callee_save_reg_size;\n \n   if (cfun->machine->initialized)\n     return cfun->machine->total_size;\n   \n-  var_size = NIOS2_STACK_ALIGN (get_frame_size ());\n-  out_args_size = NIOS2_STACK_ALIGN (crtl->outgoing_args_size);\n-  total_size = var_size + out_args_size;\n-\n   /* Calculate space needed for gp registers.  */\n   save_reg_size = 0;\n   for (regno = 0; regno <= LAST_GP_REG; regno++)\n@@ -395,6 +396,37 @@ nios2_compute_frame_layout (void)\n \tsave_reg_size += 4;\n       }\n \n+  /* If we are saving any callee-save register, then assume\n+     push.n/pop.n should be used. Make sure RA is saved, and\n+     contiguous registers starting from r16-- are all saved.  */\n+  if (TARGET_HAS_CDX && save_reg_size != 0)\n+    {\n+      if ((save_mask & (1 << RA_REGNO)) == 0)\n+\t{\n+\t  save_mask |= 1 << RA_REGNO;\n+\t  save_reg_size += 4;\n+\t}\n+\n+      for (regno = 23; regno >= 16; regno--)\n+\tif ((save_mask & (1 << regno)) != 0)\n+\t  {\n+\t    /* Starting from highest numbered callee-saved\n+\t       register that is used, make sure all regs down\n+\t       to r16 is saved, to maintain contiguous range\n+\t       for push.n/pop.n.  */\n+\t    unsigned int i;\n+\t    for (i = regno - 1; i >= 16; i--)\n+\t      if ((save_mask & (1 << i)) == 0)\n+\t\t{\n+\t\t  save_mask |= 1 << i;\n+\t\t  save_reg_size += 4;\n+\t\t}\n+\t    break;\n+\t  }\n+    }\n+\n+  callee_save_reg_size = save_reg_size;\n+\n   /* If we call eh_return, we need to save the EH data registers.  */\n   if (crtl->calls_eh_return)\n     {\n@@ -420,6 +452,10 @@ nios2_compute_frame_layout (void)\n       cfun->machine->fp_save_offset = fp_save_offset;\n     }\n \n+  var_size = NIOS2_STACK_ALIGN (get_frame_size ());\n+  out_args_size = NIOS2_STACK_ALIGN (crtl->outgoing_args_size);\n+  total_size = var_size + out_args_size;\n+\n   save_reg_size = NIOS2_STACK_ALIGN (save_reg_size);\n   total_size += save_reg_size;\n   total_size += NIOS2_STACK_ALIGN (crtl->args.pretend_args_size);\n@@ -430,6 +466,7 @@ nios2_compute_frame_layout (void)\n   cfun->machine->var_size = var_size;\n   cfun->machine->args_size = out_args_size;\n   cfun->machine->save_reg_size = save_reg_size;\n+  cfun->machine->callee_save_reg_size = callee_save_reg_size;\n   cfun->machine->initialized = reload_completed;\n   cfun->machine->save_regs_offset = out_args_size + var_size;\n \n@@ -477,6 +514,38 @@ base_reg_adjustment_p (rtx set, rtx *base_reg, rtx *offset)\n   return false;\n }\n \n+/* Does the CFA note work for push/pop prologue/epilogue instructions.  */\n+static void\n+nios2_create_cfa_notes (rtx_insn *insn, bool epilogue_p)\n+{\n+  int i = 0;\n+  rtx base_reg, offset, elt, pat = PATTERN (insn);\n+  if (epilogue_p)\n+    {\n+      elt = XVECEXP (pat, 0, 0);\n+      if (GET_CODE (elt) == RETURN)\n+\ti++;\n+      elt = XVECEXP (pat, 0, i);\n+      if (base_reg_adjustment_p (elt, &base_reg, &offset))\n+\t{\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA, copy_rtx (elt));\n+\t  i++;\n+\t}\n+      for (; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  elt = SET_DEST (XVECEXP (pat, 0, i));\n+\t  gcc_assert (REG_P (elt));\n+\t  add_reg_note (insn, REG_CFA_RESTORE, elt);\n+\t}\n+    }\n+  else\n+    {\n+      /* Tag each of the prologue sets.  */\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\tRTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n+    }\n+}\n+\n /* Temp regno used inside prologue/epilogue.  */\n #define TEMP_REG_NUM 8\n \n@@ -534,6 +603,39 @@ nios2_emit_add_constant (rtx reg, HOST_WIDE_INT immed)\n   return insn;\n }\n \n+static rtx_insn *\n+nios2_adjust_stack (int sp_adjust, bool epilogue_p)\n+{\n+  enum reg_note note_kind = REG_NOTE_MAX;\n+  rtx_insn *insn = NULL;\n+  if (sp_adjust)\n+    {\n+      if (SMALL_INT (sp_adjust))\n+\tinsn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t\t gen_int_mode (sp_adjust, Pmode)));\n+      else\n+\t{\n+\t  rtx tmp = gen_rtx_REG (Pmode, TEMP_REG_NUM);\n+\t  emit_move_insn (tmp, gen_int_mode (sp_adjust, Pmode));\n+\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx, tmp));\n+\t  /* Attach a note indicating what happened.  */\n+\t  if (!epilogue_p)\n+\t    note_kind = REG_FRAME_RELATED_EXPR;\n+\t}\n+      if (epilogue_p)\n+\tnote_kind = REG_CFA_ADJUST_CFA;\n+      if (note_kind != REG_NOTE_MAX)\n+\t{\n+\t  rtx cfa_adj = gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t    sp_adjust));\n+\t  add_reg_note (insn, note_kind, cfa_adj);\n+\t}\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  return insn;\n+}\n+\n void\n nios2_expand_prologue (void)\n {\n@@ -548,26 +650,105 @@ nios2_expand_prologue (void)\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = total_frame_size;\n \n-  /* Decrement the stack pointer.  */\n-  if (!SMALL_INT (total_frame_size))\n+  /* When R2 CDX push.n/stwm is available, arrange for stack frame to be built\n+     using them.  */\n+  if (TARGET_HAS_CDX\n+      && (cfun->machine->save_reg_size != 0\n+\t  || cfun->machine->uses_anonymous_args))\n+    {\n+      unsigned int regmask = cfun->machine->save_mask;\n+      unsigned int callee_save_regs = regmask & 0xffff0000;\n+      unsigned int caller_save_regs = regmask & 0x0000ffff;\n+      int push_immed = 0;\n+      int pretend_args_size = NIOS2_STACK_ALIGN (crtl->args.pretend_args_size);\n+      rtx stack_mem =\n+\tgen_frame_mem (SImode, plus_constant (Pmode, stack_pointer_rtx, -4));\n+\n+      /* Check that there is room for the entire stack frame before doing\n+\t any SP adjustments or pushes.  */\n+      if (crtl->limit_stack)\n+\tnios2_emit_stack_limit_check (total_frame_size);\n+\n+      if (pretend_args_size)\n+\t{\n+\t  if (cfun->machine->uses_anonymous_args)\n+\t    {\n+\t      /* Emit a stwm to push copy of argument registers onto\n+\t         the stack for va_arg processing.  */\n+\t      unsigned int r, mask = 0, n = pretend_args_size / 4;\n+\t      for (r = LAST_ARG_REGNO - n + 1; r <= LAST_ARG_REGNO; r++)\n+\t\tmask |= (1 << r);\n+\t      insn = emit_insn (nios2_ldst_parallel\n+\t\t\t\t(false, false, false, stack_mem,\n+\t\t\t\t -pretend_args_size, mask, false));\n+\t      /* Tag first SP adjustment as frame-related.  */\n+\t      RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 0)) = 1;\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t  else\n+\t    nios2_adjust_stack (-pretend_args_size, false);\n+\t}\n+      if (callee_save_regs)\n+\t{\n+\t  /* Emit a push.n to save registers and optionally allocate\n+\t     push_immed extra bytes on the stack.  */\n+\t  int sp_adjust;\n+\t  if (caller_save_regs)\n+\t    /* Can't allocate extra stack space yet.  */\n+\t    push_immed = 0;\n+\t  else if (cfun->machine->save_regs_offset <= 60)\n+\t    /* Stack adjustment fits entirely in the push.n.  */\n+\t    push_immed = cfun->machine->save_regs_offset;\n+\t  else if (frame_pointer_needed\n+\t\t   && cfun->machine->fp_save_offset == 0)\n+\t    /* Deferring the entire stack adjustment until later\n+\t       allows us to use a mov.n instead of a 32-bit addi\n+\t       instruction to set the frame pointer.  */\n+\t    push_immed = 0;\n+\t  else\n+\t    /* Splitting the stack adjustment between the push.n\n+\t       and an explicit adjustment makes it more likely that\n+\t       we can use spdeci.n for the explicit part.  */\n+\t    push_immed = 60;\n+\t  sp_adjust = -(cfun->machine->callee_save_reg_size + push_immed);\n+\t  insn = emit_insn (nios2_ldst_parallel (false, false, false,\n+\t\t\t\t\t\t stack_mem, sp_adjust,\n+\t\t\t\t\t\t callee_save_regs, false));\n+\t  nios2_create_cfa_notes (insn, false);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      if (caller_save_regs)\n+\t{\n+\t  /* Emit a stwm to save the EH data regs, r4-r7.  */\n+\t  int caller_save_size = (cfun->machine->save_reg_size\n+\t\t\t\t  - cfun->machine->callee_save_reg_size);\n+\t  gcc_assert ((caller_save_regs & ~0xf0) == 0);\n+\t  insn = emit_insn (nios2_ldst_parallel\n+\t\t\t    (false, false, false, stack_mem,\n+\t\t\t     -caller_save_size, caller_save_regs, false));\n+\t  nios2_create_cfa_notes (insn, false);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      save_regs_base = push_immed;\n+      sp_offset = -(cfun->machine->save_regs_offset - push_immed);\n+    }\n+  /* The non-CDX cases decrement the stack pointer, to prepare for individual\n+     register saves to the stack.  */\n+  else if (!SMALL_INT (total_frame_size))\n     {\n       /* We need an intermediary point, this will point at the spill block.  */\n-      insn = emit_insn\n-\t(gen_add2_insn (stack_pointer_rtx,\n-\t\t\tgen_int_mode (cfun->machine->save_regs_offset\n-\t\t\t\t      - total_frame_size, Pmode)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      nios2_adjust_stack (cfun->machine->save_regs_offset - total_frame_size,\n+\t\t\t  false);\n       save_regs_base = 0;\n       sp_offset = -cfun->machine->save_regs_offset;\n       if (crtl->limit_stack)\n \tnios2_emit_stack_limit_check (cfun->machine->save_regs_offset);\n     }\n   else if (total_frame_size)\n     {\n-      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n-\t\t\t\t       gen_int_mode (-total_frame_size,\n-\t\t\t\t\t\t     Pmode)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      nios2_adjust_stack (-total_frame_size, false);\n       save_regs_base = cfun->machine->save_regs_offset;\n       sp_offset = 0;\n       if (crtl->limit_stack)\n@@ -576,41 +757,34 @@ nios2_expand_prologue (void)\n   else\n     save_regs_base = sp_offset = 0;\n \n-  save_offset = save_regs_base + cfun->machine->save_reg_size;\n+  /* Save the registers individually in the non-CDX case.  */\n+  if (!TARGET_HAS_CDX)\n+    {\n+      save_offset = save_regs_base + cfun->machine->save_reg_size;\n \n-  for (regno = LAST_GP_REG; regno > 0; regno--)\n-    if (cfun->machine->save_mask & (1 << regno))\n-      {\n-\tsave_offset -= 4;\n-\tsave_reg (regno, save_offset);\n-      }\n+      for (regno = LAST_GP_REG; regno > 0; regno--)\n+\tif (cfun->machine->save_mask & (1 << regno))\n+\t  {\n+\t    save_offset -= 4;\n+\t    save_reg (regno, save_offset);\n+\t  }\n+    }\n \n+  /* Set the hard frame pointer.  */\n   if (frame_pointer_needed)\n     {\n       int fp_save_offset = save_regs_base + cfun->machine->fp_save_offset;\n-      insn = emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       gen_int_mode (fp_save_offset, Pmode)));\n+      insn =\n+\t(fp_save_offset == 0\n+\t ? emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx)\n+\t : emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     gen_int_mode (fp_save_offset, Pmode))));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  if (sp_offset)\n-    {\n-      rtx sp_adjust\n-\t= gen_rtx_SET (stack_pointer_rtx,\n-\t\t       plus_constant (Pmode, stack_pointer_rtx, sp_offset));\n-      if (SMALL_INT (sp_offset))\n-\tinsn = emit_insn (sp_adjust);\n-      else\n-\t{\n-\t  rtx tmp = gen_rtx_REG (Pmode, TEMP_REG_NUM);\n-\t  emit_move_insn (tmp, gen_int_mode (sp_offset, Pmode));\n-\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx, tmp));\n-\t  /* Attach the sp_adjust as a note indicating what happened.  */\n-\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, sp_adjust);\n-\t}\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n+  /* Allocate sp_offset more bytes in the stack frame.  */\n+  nios2_adjust_stack (sp_offset, false);\n \n   /* Load the PIC register if needed.  */\n   if (crtl->uses_pic_offset_table)\n@@ -643,9 +817,12 @@ nios2_expand_epilogue (bool sibcall_p)\n   if (frame_pointer_needed)\n     {\n       /* Recover the stack pointer.  */\n-      insn = emit_insn (gen_add3_insn\n-\t\t\t(stack_pointer_rtx, hard_frame_pointer_rtx,\n-\t\t\t gen_int_mode (-cfun->machine->fp_save_offset, Pmode)));\n+      insn =\n+\t(cfun->machine->fp_save_offset == 0\n+\t ? emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx)\n+\t : emit_insn (gen_add3_insn\n+\t\t      (stack_pointer_rtx, hard_frame_pointer_rtx,\n+\t\t       gen_int_mode (-cfun->machine->fp_save_offset, Pmode))));\n       cfa_adj = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t       (total_frame_size\n \t\t\t\t- cfun->machine->save_regs_offset));\n@@ -657,15 +834,7 @@ nios2_expand_epilogue (bool sibcall_p)\n     }\n   else if (!SMALL_INT (total_frame_size))\n     {\n-      rtx tmp = gen_rtx_REG (Pmode, TEMP_REG_NUM);\n-      emit_move_insn (tmp, gen_int_mode (cfun->machine->save_regs_offset,\n-\t\t\t\t\t Pmode));\n-      insn = emit_insn (gen_add2_insn (stack_pointer_rtx, tmp));\n-      cfa_adj = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t    cfun->machine->save_regs_offset));\n-      add_reg_note (insn, REG_CFA_ADJUST_CFA, cfa_adj);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      nios2_adjust_stack (cfun->machine->save_regs_offset, true);\n       save_offset = 0;\n       sp_adjust = total_frame_size - cfun->machine->save_regs_offset;\n     }\n@@ -674,25 +843,93 @@ nios2_expand_epilogue (bool sibcall_p)\n       save_offset = cfun->machine->save_regs_offset;\n       sp_adjust = total_frame_size;\n     }\n-  \n-  save_offset += cfun->machine->save_reg_size;\n \n-  for (regno = LAST_GP_REG; regno > 0; regno--)\n-    if (cfun->machine->save_mask & (1 << regno))\n-      {\n-\tsave_offset -= 4;\n-\trestore_reg (regno, save_offset);\n-      }\n+  if (!TARGET_HAS_CDX)\n+    {\n+      /* Generate individual register restores.  */\n+      save_offset += cfun->machine->save_reg_size;\n \n-  if (sp_adjust)\n+      for (regno = LAST_GP_REG; regno > 0; regno--)\n+\tif (cfun->machine->save_mask & (1 << regno))\n+\t  {\n+\t    save_offset -= 4;\n+\t    restore_reg (regno, save_offset);\n+\t  }\n+      nios2_adjust_stack (sp_adjust, true);\n+    }\n+  else if (cfun->machine->save_reg_size == 0)\n     {\n-      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n-\t\t\t\t       gen_int_mode (sp_adjust, Pmode)));\n-      cfa_adj = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t    sp_adjust));\n-      add_reg_note (insn, REG_CFA_ADJUST_CFA, cfa_adj);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      /* Nothing to restore, just recover the stack position.  */\n+      nios2_adjust_stack (sp_adjust, true);\n+    }\n+  else\n+    {\n+      /* Emit CDX pop.n/ldwm to restore registers and optionally return.  */\n+      unsigned int regmask = cfun->machine->save_mask;\n+      unsigned int callee_save_regs = regmask & 0xffff0000;\n+      unsigned int caller_save_regs = regmask & 0x0000ffff;\n+      int callee_save_size = cfun->machine->callee_save_reg_size;\n+      int caller_save_size = cfun->machine->save_reg_size - callee_save_size;\n+      int pretend_args_size = NIOS2_STACK_ALIGN (crtl->args.pretend_args_size);\n+      bool ret_p = (!pretend_args_size && !crtl->calls_eh_return\n+\t\t    && !sibcall_p);\n+\n+      if (!ret_p || caller_save_size > 0)\n+\tsp_adjust = save_offset;\n+      else\n+\tsp_adjust = (save_offset > 60 ? save_offset - 60 : 0);\n+\n+      save_offset -= sp_adjust;\n+\n+      nios2_adjust_stack (sp_adjust, true);\n+\n+      if (caller_save_regs)\n+\t{\n+\t  /* Emit a ldwm to restore EH data regs.  */\n+\t  rtx stack_mem = gen_frame_mem (SImode, stack_pointer_rtx);\n+\t  insn = emit_insn (nios2_ldst_parallel\n+\t\t\t    (true, true, true, stack_mem,\n+\t\t\t     caller_save_size, caller_save_regs, false));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  nios2_create_cfa_notes (insn, true);\n+\t}\n+\n+      if (callee_save_regs)\n+\t{\n+\t  int sp_adjust = save_offset + callee_save_size;\n+\t  rtx stack_mem;\n+\t  if (ret_p)\n+\t    {\n+\t      /* Emit a pop.n to restore regs and return.  */\n+\t      stack_mem =\n+\t\tgen_frame_mem (SImode,\n+\t\t\t       gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     gen_int_mode (sp_adjust - 4,\n+\t\t\t\t\t\t\t   Pmode)));\n+\t      insn =\n+\t\temit_jump_insn (nios2_ldst_parallel (true, false, false,\n+\t\t\t\t\t\t     stack_mem, sp_adjust,\n+\t\t\t\t\t\t     callee_save_regs, ret_p));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      /* No need to attach CFA notes since we cannot step over\n+\t\t a return.  */\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If no return, we have to use the ldwm form.  */\n+\t      stack_mem = gen_frame_mem (SImode, stack_pointer_rtx);\n+\t      insn =\n+\t\temit_insn (nios2_ldst_parallel (true, true, true,\n+\t\t\t\t\t\tstack_mem, sp_adjust,\n+\t\t\t\t\t\tcallee_save_regs, ret_p));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      nios2_create_cfa_notes (insn, true);\n+\t    }\n+\t}\n+\n+      if (pretend_args_size)\n+\tnios2_adjust_stack (pretend_args_size, true);\n     }\n \n   /* Add in the __builtin_eh_return stack adjustment.  */\n@@ -703,6 +940,37 @@ nios2_expand_epilogue (bool sibcall_p)\n     emit_jump_insn (gen_simple_return ());\n }\n \n+bool\n+nios2_expand_return (void)\n+{\n+  /* If CDX is available, generate a pop.n instruction to do both\n+     the stack pop and return.  */\n+  if (TARGET_HAS_CDX)\n+    {\n+      int total_frame_size = nios2_compute_frame_layout ();\n+      int sp_adjust = (cfun->machine->save_regs_offset\n+\t\t       + cfun->machine->callee_save_reg_size);\n+      gcc_assert (sp_adjust == total_frame_size);\n+      if (sp_adjust != 0)\n+\t{\n+\t  rtx mem =\n+\t    gen_frame_mem (SImode,\n+\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t  sp_adjust - 4, false));\n+\t  rtx_insn *insn =\n+\t    emit_jump_insn (nios2_ldst_parallel (true, false, false,\n+\t\t\t\t\t\t mem, sp_adjust,\n+\t\t\t\t\t\t cfun->machine->save_mask,\n+\t\t\t\t\t\t true));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  /* No need to create CFA notes since we can't step over\n+\t     a return.  */\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n    back to a previous frame.  */\n rtx\n@@ -874,10 +1142,24 @@ nios2_initial_elimination_offset (int from, int to)\n int\n nios2_can_use_return_insn (void)\n {\n+  int total_frame_size;\n+\n   if (!reload_completed || crtl->profile)\n     return 0;\n \n-  return nios2_compute_frame_layout () == 0;\n+  total_frame_size = nios2_compute_frame_layout ();\n+\n+  /* If CDX is available, check if we can return using a\n+     single pop.n instruction.  */\n+  if (TARGET_HAS_CDX\n+      && !frame_pointer_needed\n+      && cfun->machine->save_regs_offset <= 60\n+      && (cfun->machine->save_mask & 0x80000000) != 0\n+      && (cfun->machine->save_mask & 0xffff) == 0\n+      && crtl->args.pretend_args_size == 0)\n+    return true;\n+\n+  return total_frame_size == 0;\n }\n \n \f\n@@ -2785,12 +3067,15 @@ nios2_setup_incoming_varargs (cumulative_args_t cum_v,\n   int regs_to_push;\n   int pret_size;\n \n+  cfun->machine->uses_anonymous_args = 1;\n   local_cum = *cum;\n-  nios2_function_arg_advance (local_cum_v, mode, type, 1);\n+  nios2_function_arg_advance (local_cum_v, mode, type, true);\n \n   regs_to_push = NUM_ARG_REGS - local_cum.regs_used;\n \n-  if (!second_time && regs_to_push > 0)\n+  /* If we can use CDX stwm to push the arguments on the stack,\n+     nios2_expand_prologue will do that instead.  */\n+  if (!TARGET_HAS_CDX && !second_time && regs_to_push > 0)\n     {\n       rtx ptr = virtual_incoming_args_rtx;\n       rtx mem = gen_rtx_MEM (BLKmode, ptr);"}, {"sha": "23f236d85cbe5aaccfadcfe620727653594fbee7", "filename": "gcc/config/nios2/nios2.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2Fconfig%2Fnios2%2Fnios2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ff2812ae4ff647356577388e327cdf937fbf27/gcc%2Fconfig%2Fnios2%2Fnios2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.md?ref=c3ff2812ae4ff647356577388e327cdf937fbf27", "patch": "@@ -746,7 +746,10 @@\n (define_expand \"return\"\n   [(simple_return)]\n   \"nios2_can_use_return_insn ()\"\n-  \"\")\n+{\n+  if (nios2_expand_return ())\n+    DONE;\n+})\n \n (define_insn \"simple_return\"\n   [(simple_return)]"}]}