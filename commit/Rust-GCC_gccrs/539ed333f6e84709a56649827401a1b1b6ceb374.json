{"sha": "539ed333f6e84709a56649827401a1b1b6ceb374", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5ZWQzMzNmNmU4NDcwOWE1NjY0OTgyNzQwMWExYjFiNmNlYjM3NA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-11T15:38:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-11T15:38:23Z"}, "message": "cp-tree.h (SAME_BINFO_TYPE_P): New.\n\n\t* cp-tree.h (SAME_BINFO_TYPE_P): New.\n\t* class.c (build_base_path): Use SAME_BINFO_TYPE_P to compare\n\tbinfo types.\n\t(convert_to_base_statically, determine_primary_bases,\n\tupdate_vtable_entry_for_fn, dfs_modify_vtables, build_vtt_inits,\n\tdfs_build_secondary_vptr_vtt_inits, build_ctor_vtbl_group,\n\taccumulate_vtbl_inits, dfs_accumulate_vtbl_inits,\n\tbuild_vtbl_initializer, add_vcall_offset_vtbl_entries_1): Likewise.\n\t* init.c (expand_member_init): Likewise.\n\t* search.c (lookup_base_r, dynamic_cast_base_recurse,\n\tbinfo_via_virtual, copied_binfo, binfo_for_vbase,\n\toriginal_binfo): Likewise.\n\t* tree.c (copy_binfo): Likewise.\n\nFrom-SVN: r88880", "tree": {"sha": "1f8b6634cbb2de2c26f1f0daaa4ca85261477f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f8b6634cbb2de2c26f1f0daaa4ca85261477f1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/539ed333f6e84709a56649827401a1b1b6ceb374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539ed333f6e84709a56649827401a1b1b6ceb374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539ed333f6e84709a56649827401a1b1b6ceb374", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539ed333f6e84709a56649827401a1b1b6ceb374/comments", "author": null, "committer": null, "parents": [{"sha": "19b63d8ecd5c81353990274b249fced229e89e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b63d8ecd5c81353990274b249fced229e89e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b63d8ecd5c81353990274b249fced229e89e24"}], "stats": {"total": 88, "additions": 57, "deletions": 31}, "files": [{"sha": "576985d39cfd1d7cd8db8c79d42de54adb4a4f14", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=539ed333f6e84709a56649827401a1b1b6ceb374", "patch": "@@ -1,3 +1,19 @@\n+2004-10-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (SAME_BINFO_TYPE_P): New.\n+\t* class.c (build_base_path): Use SAME_BINFO_TYPE_P to compare\n+\tbinfo types.\n+\t(convert_to_base_statically, determine_primary_bases,\n+\tupdate_vtable_entry_for_fn, dfs_modify_vtables, build_vtt_inits,\n+\tdfs_build_secondary_vptr_vtt_inits, build_ctor_vtbl_group,\n+\taccumulate_vtbl_inits, dfs_accumulate_vtbl_inits,\n+\tbuild_vtbl_initializer, add_vcall_offset_vtbl_entries_1): Likewise.\n+\t* init.c (expand_member_init): Likewise.\n+\t* search.c (lookup_base_r, dynamic_cast_base_recurse,\n+\tbinfo_via_virtual, copied_binfo, binfo_for_vbase,\n+\toriginal_binfo): Likewise.\n+\t* tree.c (copy_binfo): Likewise.\n+\n 2004-10-11  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* semantics.c: Fix comment typos."}, {"sha": "5bcec30b516ec264b6658bcf0ecbc81a51e8c97b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=539ed333f6e84709a56649827401a1b1b6ceb374", "patch": "@@ -259,11 +259,10 @@ build_base_path (enum tree_code code,\n   if (want_pointer)\n     probe = TYPE_MAIN_VARIANT (TREE_TYPE (probe));\n \n-  gcc_assert (code == MINUS_EXPR\n-\t      ? same_type_p (BINFO_TYPE (binfo), probe)\n-\t      : code == PLUS_EXPR\n-\t      ? same_type_p (BINFO_TYPE (d_binfo), probe)\n-\t      : false);\n+  gcc_assert ((code == MINUS_EXPR\n+\t       && SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), probe))\n+\t      || (code == PLUS_EXPR\n+\t\t  && SAME_BINFO_TYPE_P (BINFO_TYPE (d_binfo), probe)));\n   \n   if (binfo == d_binfo)\n     /* Nothing to do.  */\n@@ -445,8 +444,8 @@ convert_to_base (tree object, tree type, bool check_access)\n   return build_base_path (PLUS_EXPR, object, binfo, /*nonnull=*/1);\n }\n \n-/* EXPR is an expression with class type.  BASE is a base class (a\n-   BINFO) of that class type.  Returns EXPR, converted to the BASE\n+/* EXPR is an expression with unqualified class type.  BASE is a base\n+   binfo of that class type.  Returns EXPR, converted to the BASE\n    type.  This function assumes that EXPR is the most derived class;\n    therefore virtual bases can be found at their static offsets.  */\n \n@@ -456,7 +455,7 @@ convert_to_base_statically (tree expr, tree base)\n   tree expr_type;\n \n   expr_type = TREE_TYPE (expr);\n-  if (!same_type_p (expr_type, BINFO_TYPE (base)))\n+  if (!SAME_BINFO_TYPE_P (BINFO_TYPE (base), expr_type))\n     {\n       tree pointer_type;\n \n@@ -1276,7 +1275,8 @@ determine_primary_bases (tree t)\n \t  tree parent_primary = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (parent));\n \t  \n \t  if (parent_primary\n-\t      && BINFO_TYPE (base_binfo) == BINFO_TYPE (parent_primary))\n+\t      && SAME_BINFO_TYPE_P (BINFO_TYPE (base_binfo),\n+\t\t\t\t    BINFO_TYPE (parent_primary)))\n \t    /* We are the primary binfo.  */\n \t    BINFO_PRIMARY_P (base_binfo) = 1;\n \t}\n@@ -2062,8 +2062,8 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n     {\n       /* If we find the final overrider, then we can stop\n \t walking.  */\n-      if (same_type_p (BINFO_TYPE (b), \n-\t\t       BINFO_TYPE (TREE_VALUE (overrider))))\n+      if (SAME_BINFO_TYPE_P (BINFO_TYPE (b),\n+\t\t\t     BINFO_TYPE (TREE_VALUE (overrider))))\n \tbreak;\n \n       /* If we find a virtual base, and we haven't yet found the\n@@ -2153,7 +2153,8 @@ dfs_modify_vtables (tree binfo, void* data)\n       /* Similarly, a base without a vtable needs no modification.  */\n       && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo))\n       /* Don't do the primary vtable, if it's new.  */\n-      && (BINFO_TYPE (binfo) != t || CLASSTYPE_HAS_PRIMARY_BASE_P (t)))\n+      && (!SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), t)\n+\t  || CLASSTYPE_HAS_PRIMARY_BASE_P (t)))\n     {\n       tree virtuals;\n       tree old_virtuals;\n@@ -6697,7 +6698,7 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n   tree init;\n   tree secondary_vptrs;\n   secondary_vptr_vtt_init_data data;\n-  int top_level_p = same_type_p (TREE_TYPE (binfo), t);\n+  int top_level_p = SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), t);\n \n   /* We only need VTTs for subobjects with virtual bases.  */\n   if (!CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)))\n@@ -6783,7 +6784,7 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data_)\n \n   /* We're only interested in proper subobjects of the type being\n      constructed.  */\n-  if (same_type_p (BINFO_TYPE (binfo), data->type_being_constructed))\n+  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), data->type_being_constructed))\n     return NULL_TREE;\n \n   /* We're only interested in bases with virtual bases or reachable\n@@ -6869,7 +6870,7 @@ build_ctor_vtbl_group (tree binfo, tree t)\n   if (IDENTIFIER_GLOBAL_VALUE (id))\n     return;\n \n-  gcc_assert (!same_type_p (BINFO_TYPE (binfo), t));\n+  gcc_assert (!SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), t));\n   /* Build a version of VTBL (with the wrong type) for use in\n      constructing the addresses of secondary vtables in the\n      construction vtable group.  */\n@@ -6925,9 +6926,9 @@ accumulate_vtbl_inits (tree binfo,\n {\n   int i;\n   tree base_binfo;\n-  int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n+  int ctor_vtbl_p = !SAME_BINFO_TYPE_P (BINFO_TYPE (rtti_binfo), t);\n \n-  gcc_assert (same_type_p (BINFO_TYPE (binfo), BINFO_TYPE (orig_binfo)));\n+  gcc_assert (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), BINFO_TYPE (orig_binfo)));\n \n   /* If it doesn't have a vptr, we don't do anything.  */\n   if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n@@ -6975,7 +6976,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n {\n   tree inits = NULL_TREE;\n   tree vtbl = NULL_TREE;\n-  int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n+  int ctor_vtbl_p = !SAME_BINFO_TYPE_P (BINFO_TYPE (rtti_binfo), t);\n \n   if (ctor_vtbl_p\n       && BINFO_VIRTUAL_P (orig_binfo) && BINFO_PRIMARY_P (orig_binfo))\n@@ -7109,8 +7110,8 @@ build_vtbl_initializer (tree binfo,\n   vid.derived = t;\n   vid.rtti_binfo = rtti_binfo;\n   vid.last_init = &vid.inits;\n-  vid.primary_vtbl_p = (binfo == TYPE_BINFO (t));\n-  vid.ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n+  vid.primary_vtbl_p = SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), t);\n+  vid.ctor_vtbl_p = !SAME_BINFO_TYPE_P (BINFO_TYPE (rtti_binfo), t);\n   vid.generate_vcall_entries = true;\n   /* The first vbase or vcall offset is at index -3 in the vtable.  */\n   vid.index = ssize_int(-3 * TARGET_VTABLE_DATA_ENTRY_DISTANCE);\n@@ -7523,7 +7524,7 @@ add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n \t  /* When processing BINFO, we only want to generate vcall slots for\n \t     function slots introduced in BINFO.  So don't try to generate\n \t     one if the function isn't even defined in BINFO.  */\n-\t  if (!same_type_p (DECL_CONTEXT (orig_fn), BINFO_TYPE (binfo)))\n+\t  if (!SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), DECL_CONTEXT (orig_fn)))\n \t    continue;\n \n \t  add_vcall_offset (orig_fn, binfo, vid);"}, {"sha": "6c5d6aadfb69e04c53d10ce6286f332250147e6f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=539ed333f6e84709a56649827401a1b1b6ceb374", "patch": "@@ -1370,6 +1370,14 @@ struct lang_type GTY(())\n    have this flag set.  */\n #define BINFO_NEW_VTABLE_MARKED(B) (BINFO_FLAG_2 (B))\n \n+/* Compare a BINFO_TYPE with another type for equality.  For a binfo,\n+   this is functionally equivalent to using same_type_p, but\n+   measurably faster.  At least one of the arguments must be a\n+   BINFO_TYPE.  The other can be a BINFO_TYPE or a regular type.  If\n+   BINFO_TYPE(T) ever stops being the main variant of the class the\n+   binfo is for, this macro must change.  */\n+#define SAME_BINFO_TYPE_P(A, B) ((A) == (B))\n+\n /* Any subobject that needs a new vtable must have a vptr and must not\n    be a non-virtual primary base (since it would then use the vtable from a\n    derived class and never become non-primary.)  */"}, {"sha": "48297b9a26eb01c09f12b188b50c4b9ec7e33dfc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=539ed333f6e84709a56649827401a1b1b6ceb374", "patch": "@@ -979,7 +979,7 @@ expand_member_init (tree name)\n \n       /* Look for a direct base.  */\n       for (i = 0; BINFO_BASE_ITERATE (class_binfo, i, direct_binfo); ++i)\n-\tif (same_type_p (basetype, BINFO_TYPE (direct_binfo)))\n+\tif (SAME_BINFO_TYPE_P (BINFO_TYPE (direct_binfo), basetype))\n \t  break;\n \n       /* Look for a virtual base -- unless the direct base is itself"}, {"sha": "b54d9992580e63eb74d7ec5be795751fddbf215e", "filename": "gcc/cp/search.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=539ed333f6e84709a56649827401a1b1b6ceb374", "patch": "@@ -90,7 +90,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n   tree base_binfo;\n   base_kind found = bk_not_base;\n   \n-  if (same_type_p (BINFO_TYPE (binfo), base))\n+  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), base))\n     {\n       /* We have found a base. Check against what we have found\n          already.  */\n@@ -279,7 +279,7 @@ dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n   int i;\n   int worst = -2;\n   \n-  if (BINFO_TYPE (binfo) == subtype)\n+  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), subtype))\n     {\n       if (is_via_virtual)\n         return -1;\n@@ -2346,7 +2346,7 @@ binfo_from_vbase (tree binfo)\n tree\n binfo_via_virtual (tree binfo, tree limit)\n {\n-  for (; binfo && (!limit || !same_type_p (BINFO_TYPE (binfo), limit));\n+  for (; binfo && !SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), limit);\n        binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {\n       if (BINFO_VIRTUAL_P (binfo))\n@@ -2382,15 +2382,15 @@ copied_binfo (tree binfo, tree here)\n       \n       cbinfo = copied_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n       for (ix = 0; BINFO_BASE_ITERATE (cbinfo, ix, base_binfo); ix++)\n-\tif (BINFO_TYPE (base_binfo) == BINFO_TYPE (binfo))\n+\tif (SAME_BINFO_TYPE_P (BINFO_TYPE (base_binfo), BINFO_TYPE (binfo)))\n \t  {\n \t    result = base_binfo;\n \t    break;\n \t  }\n     }\n   else\n     {\n-      gcc_assert (BINFO_TYPE (here) == BINFO_TYPE (binfo));\n+      gcc_assert (SAME_BINFO_TYPE_P (BINFO_TYPE (here), BINFO_TYPE (binfo)));\n       result = here;\n     }\n \n@@ -2407,7 +2407,7 @@ binfo_for_vbase (tree base, tree t)\n   \n   for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n        VEC_iterate (tree, vbases, ix, binfo); ix++)\n-    if (BINFO_TYPE (binfo) == base)\n+    if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), base))\n       return binfo;\n   return NULL;\n }\n@@ -2422,7 +2422,7 @@ original_binfo (tree binfo, tree here)\n {\n   tree result = NULL;\n   \n-  if (BINFO_TYPE (binfo) == BINFO_TYPE (here))\n+  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), BINFO_TYPE (here)))\n     result = here;\n   else if (BINFO_VIRTUAL_P (binfo))\n     result = (CLASSTYPE_VBASECLASSES (BINFO_TYPE (here))\n@@ -2439,7 +2439,8 @@ original_binfo (tree binfo, tree here)\n \t  tree base_binfo;\n \t  \n \t  for (ix = 0; (base_binfo = BINFO_BASE_BINFO (base_binfos, ix)); ix++)\n-\t    if (BINFO_TYPE (base_binfo) == BINFO_TYPE (binfo))\n+\t    if (SAME_BINFO_TYPE_P (BINFO_TYPE (base_binfo),\n+\t\t\t\t   BINFO_TYPE (binfo)))\n \t      {\n \t\tresult = base_binfo;\n \t\tbreak;"}, {"sha": "b4ced9bc22cd37bdbb004b0ddac64003bc8b6530", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ed333f6e84709a56649827401a1b1b6ceb374/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=539ed333f6e84709a56649827401a1b1b6ceb374", "patch": "@@ -611,7 +611,7 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n       tree base_binfo;\n \n       gcc_assert (!BINFO_DEPENDENT_BASE_P (binfo));\n-      gcc_assert (type == BINFO_TYPE (binfo));\n+      gcc_assert (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), type));\n \n       BINFO_OFFSET (new_binfo) = BINFO_OFFSET (binfo);\n       BINFO_VIRTUALS (new_binfo) = BINFO_VIRTUALS (binfo);"}]}