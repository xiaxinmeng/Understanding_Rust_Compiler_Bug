{"sha": "92a16bbe7661a7b5a14e3c6b1644492aa529486f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJhMTZiYmU3NjYxYTdiNWExNGUzYzZiMTY0NDQ5MmFhNTI5NDg2Zg==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-09-05T03:07:14Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-09-05T03:07:14Z"}, "message": "cp-demangle.c (demangle_nv_offset): New function.\n\n\t* cp-demangle.c (demangle_nv_offset): New function.\n\t(demangle_v_offset): Likewise.\n\t(demangle_call_offset): Likewise.\n\t(demangle_special_name): Update thunk demangling to comply with\n\tABI changes.\n\nFrom-SVN: r36150", "tree": {"sha": "7621c43c24052e3f4a47f4d284b5fc36f08215eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7621c43c24052e3f4a47f4d284b5fc36f08215eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92a16bbe7661a7b5a14e3c6b1644492aa529486f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a16bbe7661a7b5a14e3c6b1644492aa529486f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a16bbe7661a7b5a14e3c6b1644492aa529486f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a16bbe7661a7b5a14e3c6b1644492aa529486f/comments", "author": null, "committer": null, "parents": [{"sha": "a1281f45033c96419e4a6feab46fbd1f308d26ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1281f45033c96419e4a6feab46fbd1f308d26ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1281f45033c96419e4a6feab46fbd1f308d26ff"}], "stats": {"total": 220, "additions": 169, "deletions": 51}, "files": [{"sha": "0a474a31d9053b00738292e95bdaf1e8da2a16b8", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a16bbe7661a7b5a14e3c6b1644492aa529486f/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a16bbe7661a7b5a14e3c6b1644492aa529486f/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=92a16bbe7661a7b5a14e3c6b1644492aa529486f", "patch": "@@ -1,3 +1,11 @@\n+2000-09-04  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* cp-demangle.c (demangle_nv_offset): New function.\n+\t(demangle_v_offset): Likewise.\n+\t(demangle_call_offset): Likewise.\n+\t(demangle_special_name): Update thunk demangling to comply with\n+\tABI changes.\n+\t\n 2000-09-03  Alex Samuel  <samuel@codesourcery.com>\n \n \t* cp-demangle.c (ANONYMOUS_NAMESPACE_PREFIX): New macro."}, {"sha": "b4e55ee05972cbb8f9d7266b370d9c6e658c73bd", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 161, "deletions": 51, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a16bbe7661a7b5a14e3c6b1644492aa529486f/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a16bbe7661a7b5a14e3c6b1644492aa529486f/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=92a16bbe7661a7b5a14e3c6b1644492aa529486f", "patch": "@@ -816,6 +816,12 @@ static status_t demangle_identifier\n   PARAMS ((demangling_t, int, dyn_string_t));\n static status_t demangle_operator_name\n   PARAMS ((demangling_t, int, int *));\n+static status_t demangle_nv_offset\n+  PARAMS ((demangling_t));\n+static status_t demangle_v_offset\n+  PARAMS ((demangling_t));\n+static status_t demangle_call_offset\n+  PARAMS ((demangling_t));\n static status_t demangle_special_name\n   PARAMS ((demangling_t));\n static status_t demangle_ctor_dtor_name\n@@ -1569,19 +1575,154 @@ demangle_operator_name (dm, short_name, num_args)\n     }\n }\n \n+/* Demangles and omits an <nv-offset>.\n+\n+    <nv-offset> ::= <offset number>   # non-virtual base override  */\n+\n+static status_t\n+demangle_nv_offset (dm)\n+     demangling_t dm;\n+{\n+  dyn_string_t number;\n+  status_t status = STATUS_OK;\n+\n+  DEMANGLE_TRACE (\"h-offset\", dm);\n+\n+  /* Demangle the offset.  */\n+  number = dyn_string_new (4);\n+  if (number == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+  demangle_number_literally (dm, number, 10, 1);\n+\n+  /* Don't display the offset unless in verbose mode.  */\n+  if (flag_verbose)\n+    {\n+      status = result_append (dm, \" [nv:\");\n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_append_string (dm, number);\n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_append_char (dm, ']');\n+    }\n+\n+  /* Clean up.  */\n+  dyn_string_delete (number);\n+  RETURN_IF_ERROR (status);\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <v-offset>. \n+\n+    <v-offset>  ::= <offset number> _ <virtual offset number>\n+\t\t\t# virtual base override, with vcall offset  */\n+\n+static status_t\n+demangle_v_offset (dm)\n+     demangling_t dm;\n+{\n+  dyn_string_t number;\n+  status_t status = STATUS_OK;\n+\n+  DEMANGLE_TRACE (\"v-offset\", dm);\n+\n+  /* Demangle the offset.  */\n+  number = dyn_string_new (4);\n+  if (number == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+  demangle_number_literally (dm, number, 10, 1);\n+\n+  /* Don't display the offset unless in verbose mode.  */\n+  if (flag_verbose)\n+    {\n+      status = result_append (dm, \" [v:\");\n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_append_string (dm, number);\n+      if (STATUS_NO_ERROR (status))\n+\tresult_append_char (dm, ',');\n+    }\n+  dyn_string_delete (number);\n+  RETURN_IF_ERROR (status);\n+\n+  /* Demangle the separator.  */\n+  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+\n+  /* Demangle the vcall offset.  */\n+  number = dyn_string_new (4);\n+  if (number == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+  demangle_number_literally (dm, number, 10, 1);\n+\n+  /* Don't display the vcall offset unless in verbose mode.  */\n+  if (flag_verbose)\n+    {\n+      status = result_append_string (dm, number);\n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_append_char (dm, ']');\n+    }\n+  dyn_string_delete (number);\n+  RETURN_IF_ERROR (status);\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <call-offset>.\n+\n+    <call-offset> ::= h <nv-offset> _\n+\t\t  ::= v <v-offset> _  */\n+\n+static status_t\n+demangle_call_offset (dm)\n+     demangling_t dm;\n+{\n+  DEMANGLE_TRACE (\"call-offset\", dm);\n+\n+  switch (peek_char (dm))\n+    {\n+    case 'h':\n+      advance_char (dm);\n+      /* Demangle the offset.  */\n+      RETURN_IF_ERROR (demangle_nv_offset (dm));\n+      /* Demangle the separator.  */\n+      RETURN_IF_ERROR (demangle_char (dm, '_'));\n+      break;\n+\n+    case 'v':\n+      advance_char (dm);\n+      /* Demangle the offset.  */\n+      RETURN_IF_ERROR (demangle_v_offset (dm));\n+      /* Demangle the separator.  */\n+      RETURN_IF_ERROR (demangle_char (dm, '_'));\n+      break;\n+\n+    default:\n+      return \"Unrecognized <call-offset>.\";\n+    }\n+\n+  return STATUS_OK;\n+}\n+\n /* Demangles and emits a <special-name>.  \n \n     <special-name> ::= GV <object name>   # Guard variable\n-                   ::= Th[n] <offset number> _ <base name> <base encoding>\n-                                          # non-virtual base override thunk\n-                   ::= Tv[n] <offset number> _ <vcall offset number> \n-                         _ <base encoding>\n-                                          # virtual base override thunk\n                    ::= TV <type>          # virtual table\n                    ::= TT <type>          # VTT\n                    ::= TI <type>          # typeinfo structure\n \t\t   ::= TS <type>          # typeinfo name  \n \n+   Other relevant productions include thunks:\n+\n+    <special-name> ::= T <call-offset> <base encoding>\n+ \t\t\t # base is the nominal target function of thunk\n+\n+    <special-name> ::= Tc <call-offset> <call-offset> <base encoding>\n+\t\t\t # base is the nominal target function of thunk\n+\t\t\t # first call-offset is 'this' adjustment\n+\t\t\t # second call-offset is result adjustment\n+\n+   where\n+\n+    <call-offset>  ::= h <nv-offset> _\n+\t\t   ::= v <v-offset> _\n+\n    Also demangles the special g++ manglings,\n \n     <special-name> ::= CT <type> <offset number> _ <base type>\n@@ -1662,20 +1803,7 @@ demangle_special_name (dm)\n \t  /* Non-virtual thunk.  */\n \t  advance_char (dm);\n \t  RETURN_IF_ERROR (result_append (dm, \"non-virtual thunk\"));\n-\t  /* Demangle and emit the offset.  */\n-\t  number = dyn_string_new (4);\n-\t  if (number == NULL)\n-\t    return STATUS_ALLOCATION_FAILED;\n-\t  demangle_number_literally (dm, number, 10, 1);\n-\t  /* Don't display the offset unless in verbose mode.  */\n-\t  if (flag_verbose)\n-\t    {\n-\t      status = result_append_char (dm, ' ');\n-\t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = result_append_string (dm, number);\n-\t    }\n-\t  dyn_string_delete (number);\n-\t  RETURN_IF_ERROR (status);\n+\t  RETURN_IF_ERROR (demangle_nv_offset (dm));\n \t  /* Demangle the separator.  */\n \t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t  /* Demangle and emit the target name and function type.  */\n@@ -1686,41 +1814,23 @@ demangle_special_name (dm)\n \tcase 'v':\n \t  /* Virtual thunk.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"virtual thunk \"));\n-\t  /* Demangle and emit the offset.  */\n-\t  number = dyn_string_new (4);\n-\t  if (number == NULL)\n-\t    return STATUS_ALLOCATION_FAILED;\n-\t  demangle_number_literally (dm, number, 10, 1);\n-\t  /* Don't display the offset unless in verbose mode.  */\n-\t  if (flag_verbose)\n-\t    {\n-\t      status = result_append_string (dm, number);\n-\t      if (STATUS_NO_ERROR (status))\n-\t\tresult_append_char (dm, ' ');\n-\t    }\n-\t  dyn_string_delete (number);\n-\t  RETURN_IF_ERROR (status);\n-\t  /* Demangle the separator.  */\n-\t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n-\t  /* Demangle and emit the vcall offset.  */\n-\t  number = dyn_string_new (4);\n-\t  if (number == NULL)\n-\t    return STATUS_ALLOCATION_FAILED;\n-\t  demangle_number_literally (dm, number, 10, 1);\n-\t  /* Don't display the vcall offset unless in verbose mode.  */\n-\t  if (flag_verbose)\n-\t    {\n-\t      status = result_append_string (dm, number);\n-\t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = result_append_char (dm, ' ');\n-\t    }\n-\t  dyn_string_delete (number);\n-\t  RETURN_IF_ERROR (status);\n+\t  RETURN_IF_ERROR (result_append (dm, \"virtual thunk\"));\n+\t  RETURN_IF_ERROR (demangle_v_offset (dm));\n \t  /* Demangle the separator.  */\n \t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t  /* Demangle and emit the target function.  */\n-\t  RETURN_IF_ERROR (result_append (dm, \"to \"));\n+\t  RETURN_IF_ERROR (result_append (dm, \" to \"));\n+\t  RETURN_IF_ERROR (demangle_encoding (dm));\n+\t  break;\n+\n+\tcase 'c':\n+\t  /* Covariant return thunk.  */\n+\t  advance_char (dm);\n+\t  RETURN_IF_ERROR (result_append (dm, \"covariant return thunk\"));\n+\t  RETURN_IF_ERROR (demangle_call_offset (dm));\n+\t  RETURN_IF_ERROR (demangle_call_offset (dm));\n+\t  /* Demangle and emit the target function.  */\n+\t  RETURN_IF_ERROR (result_append (dm, \" to \"));\n \t  RETURN_IF_ERROR (demangle_encoding (dm));\n \t  break;\n "}]}