{"sha": "5e351e96076332aa8c42848701b59923468eae98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUzNTFlOTYwNzYzMzJhYThjNDI4NDg3MDFiNTk5MjM0NjhlYWU5OA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2013-09-02T14:25:40Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2013-09-02T14:25:40Z"}, "message": "Split all the structures, enums, typedefs and some fundamental declarations from tree.h into tree-core.h.\n\nSplit all the structures, enums, typedefs and some fundamental\ndeclarations from tree.h into tree-core.h.  Everything else stays in\ntree.h for now.\n\nAs we convert gimple files, we'll move declarations out of tree.h into\nother headers and rewrite missing functions in the new gimple API.\n\n\t* Makefile.in (TREE_CORE_H): Define.\n\t(TREE_H): Use.\n\t(GTFILES): Add tree-core.h.\n\t* builtins.c (built_in_class_names): Use BUILT_IN_LAST to\n\tsize the array.\n\t* tree-core.h: New file.\n\tMove all data structures, enum, typedefs, global\n\tdeclarations and constants from ...\n\t* tree.h: ... here.\n\nFrom-SVN: r202172", "tree": {"sha": "feb689d5e1c96eaae4403f83eb30baf282acee3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feb689d5e1c96eaae4403f83eb30baf282acee3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e351e96076332aa8c42848701b59923468eae98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e351e96076332aa8c42848701b59923468eae98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e351e96076332aa8c42848701b59923468eae98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e351e96076332aa8c42848701b59923468eae98/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63fdb7bee70641e7d9a9704d51c8b70a62d31c24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fdb7bee70641e7d9a9704d51c8b70a62d31c24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63fdb7bee70641e7d9a9704d51c8b70a62d31c24"}], "stats": {"total": 3415, "additions": 1710, "deletions": 1705}, "files": [{"sha": "94e9992725320cf5e88f87697984856c50b31d60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e351e96076332aa8c42848701b59923468eae98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e351e96076332aa8c42848701b59923468eae98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e351e96076332aa8c42848701b59923468eae98", "patch": "@@ -67,6 +67,18 @@\n \t* config/darwin.h (LINK_COMMAND_SPEC_A): Revise sanitizer specs to\n \tinclude sanitize(undefined).\n \n+2013-08-31  Diego Novillo  <dnovillo@google.com>\n+\n+\t* Makefile.in (TREE_CORE_H): Define.\n+\t(TREE_H): Use.\n+\t(GTFILES): Add tree-core.h.\n+\t* builtins.c (built_in_class_names): Use BUILT_IN_LAST to\n+\tsize the array.\n+\t* tree-core.h: New file.\n+\tMove all data structures, enum, typedefs, global\n+\tdeclarations and constants from ...\n+\t* tree.h: ... here.\n+\n 2013-08-31  Jan Hubicka  <jh@suse.cz>\n \n \t* bulitins.c (expand_builtin): Do not early exit for gcov"}, {"sha": "77166d6c39252d4d007a472d1c5ad85190eeaa3e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e351e96076332aa8c42848701b59923468eae98/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e351e96076332aa8c42848701b59923468eae98/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5e351e96076332aa8c42848701b59923468eae98", "patch": "@@ -872,11 +872,13 @@ BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n \tgtm-builtins.def sanitizer.def cilkplus.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n-TREE_H = coretypes.h tree.h all-tree.def tree.def c-family/c-common.def \\\n-\t$(lang_tree_files) $(MACHMODE_H) tree-check.h $(BUILTINS_DEF) \\\n-\t$(INPUT_H) statistics.h $(VEC_H) treestruct.def $(HASHTAB_H) \\\n+TREE_CORE_H = tree-core.h coretypes.h all-tree.def tree.def \\\n+\tc-family/c-common.def $(lang_tree_files) $(MACHMODE_H) \\\n+\t$(BUILTINS_DEF) $(INPUT_H) statistics.h \\\n+\t$(VEC_H) treestruct.def $(HASHTAB_H) \\\n \tdouble-int.h alias.h $(SYMTAB_H) $(FLAGS_H) \\\n \t$(REAL_H) $(FIXED_VALUE_H)\n+TREE_H = tree.h $(TREE_CORE_H)  tree-check.h\n REGSET_H = regset.h $(BITMAP_H) hard-reg-set.h\n BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) \\\n \tcfg-flags.def cfghooks.h\n@@ -3795,7 +3797,8 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n   $(srcdir)/alias.h $(srcdir)/coverage.c $(srcdir)/rtl.h \\\n-  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n+  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/tree-core.h \\\n+  $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\\n   $(srcdir)/output.h $(srcdir)/cfgloop.h \\"}, {"sha": "bb44a7f9b0106e2bd7411de87c1761aa67ce824f", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e351e96076332aa8c42848701b59923468eae98/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e351e96076332aa8c42848701b59923468eae98/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5e351e96076332aa8c42848701b59923468eae98", "patch": "@@ -62,7 +62,7 @@ struct target_builtins *this_target_builtins = &default_target_builtins;\n #endif\n \n /* Define the names of the builtin function types and codes.  */\n-const char *const built_in_class_names[4]\n+const char *const built_in_class_names[BUILT_IN_LAST]\n   = {\"NOT_BUILT_IN\", \"BUILT_IN_FRONTEND\", \"BUILT_IN_MD\", \"BUILT_IN_NORMAL\"};\n \n #define DEF_BUILTIN(X, N, C, T, LT, B, F, NA, AT, IM, COND) #X,"}, {"sha": "57d5e9c681738d2ed61d2dacc87eda927c46e0ef", "filename": "gcc/tree-core.h", "status": "added", "additions": 1688, "deletions": 0, "changes": 1688, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e351e96076332aa8c42848701b59923468eae98/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e351e96076332aa8c42848701b59923468eae98/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=5e351e96076332aa8c42848701b59923468eae98", "patch": "@@ -0,0 +1,1688 @@\n+/* Core data structures for the 'tree' type.\n+   Copyright (C) 1989-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_CORE_H\n+#define GCC_TREE_CORE_H\n+\n+#include \"hashtab.h\"\n+#include \"machmode.h\"\n+#include \"input.h\"\n+#include \"statistics.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"real.h\"\n+#include \"fixed-value.h\"\n+#include \"alias.h\"\n+#include \"flags.h\"\n+#include \"symtab.h\"\n+\n+/* This file contains all the data structures that define the 'tree' type.\n+   There are no accessor macros nor functions in this file. Only the\n+   basic data structures, extern declarations and type definitions.  */\n+\n+/*---------------------------------------------------------------------------\n+   Forward type declarations.  Mostly to avoid including unnecessary headers\n+---------------------------------------------------------------------------*/\n+struct function;\n+struct real_value;\n+struct fixed_value;\n+struct ptr_info_def;\n+struct die_struct;\n+struct pointer_set_t;\n+\n+\n+/*---------------------------------------------------------------------------\n+                              #defined constants\n+---------------------------------------------------------------------------*/\n+/* Nonzero if this is a call to a function whose return value depends\n+   solely on its arguments, has no side effects, and does not read\n+   global memory.  This corresponds to TREE_READONLY for function\n+   decls.  */\n+#define ECF_CONST\t\t  (1 << 0)\n+\n+/* Nonzero if this is a call to \"pure\" function (like const function,\n+   but may read memory.  This corresponds to DECL_PURE_P for function\n+   decls.  */\n+#define ECF_PURE\t\t  (1 << 1)\n+\n+/* Nonzero if this is ECF_CONST or ECF_PURE but cannot be proven to no\n+   infinite loop.  This corresponds to DECL_LOOPING_CONST_OR_PURE_P\n+   for function decls.*/\n+#define ECF_LOOPING_CONST_OR_PURE (1 << 2)\n+\n+/* Nonzero if this call will never return.  */\n+#define ECF_NORETURN\t\t  (1 << 3)\n+\n+/* Nonzero if this is a call to malloc or a related function.  */\n+#define ECF_MALLOC\t\t  (1 << 4)\n+\n+/* Nonzero if it is plausible that this is a call to alloca.  */\n+#define ECF_MAY_BE_ALLOCA\t  (1 << 5)\n+\n+/* Nonzero if this is a call to a function that won't throw an exception.  */\n+#define ECF_NOTHROW\t\t  (1 << 6)\n+\n+/* Nonzero if this is a call to setjmp or a related function.  */\n+#define ECF_RETURNS_TWICE\t  (1 << 7)\n+\n+/* Nonzero if this call replaces the current stack frame.  */\n+#define ECF_SIBCALL\t\t  (1 << 8)\n+\n+/* Function does not read or write memory (but may have side effects, so\n+   it does not necessarily fit ECF_CONST).  */\n+#define ECF_NOVOPS\t\t  (1 << 9)\n+\n+/* The function does not lead to calls within current function unit.  */\n+#define ECF_LEAF\t\t  (1 << 10)\n+\n+/* Nonzero if this call does not affect transactions.  */\n+#define ECF_TM_PURE\t\t  (1 << 11)\n+\n+/* Nonzero if this call is into the transaction runtime library.  */\n+#define ECF_TM_BUILTIN\t\t  (1 << 12)\n+\n+/* Call argument flags.  */\n+/* Nonzero if the argument is not dereferenced recursively, thus only\n+   directly reachable memory is read or written.  */\n+#define EAF_DIRECT\t\t(1 << 0)\n+\n+/* Nonzero if memory reached by the argument is not clobbered.  */\n+#define EAF_NOCLOBBER\t\t(1 << 1)\n+\n+/* Nonzero if the argument does not escape.  */\n+#define EAF_NOESCAPE\t\t(1 << 2)\n+\n+/* Nonzero if the argument is not used by the function.  */\n+#define EAF_UNUSED\t\t(1 << 3)\n+\n+/* Call return flags.  */\n+/* Mask for the argument number that is returned.  Lower two bits of\n+   the return flags, encodes argument slots zero to three.  */\n+#define ERF_RETURN_ARG_MASK\t(3)\n+\n+/* Nonzero if the return value is equal to the argument number\n+   flags & ERF_RETURN_ARG_MASK.  */\n+#define ERF_RETURNS_ARG\t\t(1 << 2)\n+\n+/* Nonzero if the return value does not alias with anything.  Functions\n+   with the malloc attribute have this set on their return value.  */\n+#define ERF_NOALIAS\t\t(1 << 3)\n+\n+\n+/*---------------------------------------------------------------------------\n+                                  Enumerations\n+---------------------------------------------------------------------------*/\n+/* Codes of tree nodes.  */\n+#define DEFTREECODE(SYM, STRING, TYPE, NARGS)   SYM,\n+#define END_OF_BASE_TREE_CODES LAST_AND_UNUSED_TREE_CODE,\n+\n+enum tree_code {\n+#include \"all-tree.def\"\n+MAX_TREE_CODES\n+};\n+\n+#undef DEFTREECODE\n+#undef END_OF_BASE_TREE_CODES\n+\n+/* Number of language-independent tree codes.  */\n+#define NUM_TREE_CODES \\\n+  ((int) LAST_AND_UNUSED_TREE_CODE)\n+\n+#define CODE_CONTAINS_STRUCT(CODE, STRUCT) \\\n+  (tree_contains_struct[(CODE)][(STRUCT)])\n+\n+\n+/* Classify which part of the compiler has defined a given builtin function.\n+   Note that we assume below that this is no more than two bits.  */\n+enum built_in_class {\n+  NOT_BUILT_IN = 0,\n+  BUILT_IN_FRONTEND,\n+  BUILT_IN_MD,\n+  BUILT_IN_NORMAL\n+};\n+\n+/* Last marker used for LTO stremaing of built_in_class.  We can not add it\n+   to the enum since we need the enumb to fit in 2 bits.  */\n+#define BUILT_IN_LAST (BUILT_IN_NORMAL + 1)\n+\n+/* Codes that identify the various built in functions\n+   so that expand_call can identify them quickly.  */\n+#define DEF_BUILTIN(ENUM, N, C, T, LT, B, F, NA, AT, IM, COND) ENUM,\n+enum built_in_function {\n+#include \"builtins.def\"\n+\n+  /* Complex division routines in libgcc.  These are done via builtins\n+     because emit_library_call_value can't handle complex values.  */\n+  BUILT_IN_COMPLEX_MUL_MIN,\n+  BUILT_IN_COMPLEX_MUL_MAX\n+    = BUILT_IN_COMPLEX_MUL_MIN\n+      + MAX_MODE_COMPLEX_FLOAT\n+      - MIN_MODE_COMPLEX_FLOAT,\n+\n+  BUILT_IN_COMPLEX_DIV_MIN,\n+  BUILT_IN_COMPLEX_DIV_MAX\n+    = BUILT_IN_COMPLEX_DIV_MIN\n+      + MAX_MODE_COMPLEX_FLOAT\n+      - MIN_MODE_COMPLEX_FLOAT,\n+\n+  /* Upper bound on non-language-specific builtins.  */\n+  END_BUILTINS\n+};\n+#undef DEF_BUILTIN\n+\n+/* Tree code classes.  Each tree_code has an associated code class\n+   represented by a TREE_CODE_CLASS.  */\n+enum tree_code_class {\n+  tcc_exceptional, /* An exceptional code (fits no category).  */\n+  tcc_constant,    /* A constant.  */\n+  /* Order of tcc_type and tcc_declaration is important.  */\n+  tcc_type,        /* A type object code.  */\n+  tcc_declaration, /* A declaration (also serving as variable refs).  */\n+  tcc_reference,   /* A reference to storage.  */\n+  tcc_comparison,  /* A comparison expression.  */\n+  tcc_unary,       /* A unary arithmetic expression.  */\n+  tcc_binary,      /* A binary arithmetic expression.  */\n+  tcc_statement,   /* A statement expression, which have side effects\n+\t\t      but usually no interesting value.  */\n+  tcc_vl_exp,      /* A function call or other expression with a\n+\t\t      variable-length operand vector.  */\n+  tcc_expression   /* Any other expression.  */\n+};\n+\n+/* OMP_CLAUSE codes.  Do not reorder, as this is used to index into\n+   the tables omp_clause_num_ops and omp_clause_code_name.  */\n+enum omp_clause_code {\n+  /* Clause zero is special-cased inside the parser\n+     (c_parser_omp_variable_list).  */\n+  OMP_CLAUSE_ERROR = 0,\n+\n+  /* OpenMP clause: private (variable_list).  */\n+  OMP_CLAUSE_PRIVATE,\n+\n+  /* OpenMP clause: shared (variable_list).  */\n+  OMP_CLAUSE_SHARED,\n+\n+  /* OpenMP clause: firstprivate (variable_list).  */\n+  OMP_CLAUSE_FIRSTPRIVATE,\n+\n+  /* OpenMP clause: lastprivate (variable_list).  */\n+  OMP_CLAUSE_LASTPRIVATE,\n+\n+  /* OpenMP clause: reduction (operator:variable_list).\n+     OMP_CLAUSE_REDUCTION_CODE: The tree_code of the operator.\n+     Operand 1: OMP_CLAUSE_REDUCTION_INIT: Stmt-list to initialize the var.\n+     Operand 2: OMP_CLAUSE_REDUCTION_MERGE: Stmt-list to merge private var\n+                into the shared one.\n+     Operand 3: OMP_CLAUSE_REDUCTION_PLACEHOLDER: A dummy VAR_DECL\n+                placeholder used in OMP_CLAUSE_REDUCTION_{INIT,MERGE}.  */\n+  OMP_CLAUSE_REDUCTION,\n+\n+  /* OpenMP clause: copyin (variable_list).  */\n+  OMP_CLAUSE_COPYIN,\n+\n+  /* OpenMP clause: copyprivate (variable_list).  */\n+  OMP_CLAUSE_COPYPRIVATE,\n+\n+  /* OpenMP clause: linear (variable-list[:linear-step]).  */\n+  OMP_CLAUSE_LINEAR,\n+\n+  /* OpenMP clause: uniform (argument-list).  */\n+  OMP_CLAUSE_UNIFORM,\n+\n+  /* OpenMP clause: if (scalar-expression).  */\n+  OMP_CLAUSE_IF,\n+\n+  /* OpenMP clause: num_threads (integer-expression).  */\n+  OMP_CLAUSE_NUM_THREADS,\n+\n+  /* OpenMP clause: schedule.  */\n+  OMP_CLAUSE_SCHEDULE,\n+\n+  /* OpenMP clause: nowait.  */\n+  OMP_CLAUSE_NOWAIT,\n+\n+  /* OpenMP clause: ordered.  */\n+  OMP_CLAUSE_ORDERED,\n+\n+  /* OpenMP clause: default.  */\n+  OMP_CLAUSE_DEFAULT,\n+\n+  /* OpenMP clause: collapse (constant-integer-expression).  */\n+  OMP_CLAUSE_COLLAPSE,\n+\n+  /* OpenMP clause: untied.  */\n+  OMP_CLAUSE_UNTIED,\n+\n+  /* OpenMP clause: final (scalar-expression).  */\n+  OMP_CLAUSE_FINAL,\n+\n+  /* OpenMP clause: mergeable.  */\n+  OMP_CLAUSE_MERGEABLE,\n+\n+  /* OpenMP clause: safelen (constant-integer-expression).  */\n+  OMP_CLAUSE_SAFELEN,\n+\n+  /* Internally used only clause, holding SIMD uid.  */\n+  OMP_CLAUSE__SIMDUID_\n+};\n+\n+#undef DEFTREESTRUCT\n+#define DEFTREESTRUCT(ENUM, NAME) ENUM,\n+enum tree_node_structure_enum {\n+#include \"treestruct.def\"\n+  LAST_TS_ENUM\n+};\n+#undef DEFTREESTRUCT\n+\n+enum omp_clause_schedule_kind {\n+  OMP_CLAUSE_SCHEDULE_STATIC,\n+  OMP_CLAUSE_SCHEDULE_DYNAMIC,\n+  OMP_CLAUSE_SCHEDULE_GUIDED,\n+  OMP_CLAUSE_SCHEDULE_AUTO,\n+  OMP_CLAUSE_SCHEDULE_RUNTIME\n+};\n+\n+enum omp_clause_default_kind {\n+  OMP_CLAUSE_DEFAULT_UNSPECIFIED,\n+  OMP_CLAUSE_DEFAULT_SHARED,\n+  OMP_CLAUSE_DEFAULT_NONE,\n+  OMP_CLAUSE_DEFAULT_PRIVATE,\n+  OMP_CLAUSE_DEFAULT_FIRSTPRIVATE\n+};\n+\n+/* There is a TYPE_QUAL value for each type qualifier.  They can be\n+   combined by bitwise-or to form the complete set of qualifiers for a\n+   type.  */\n+enum cv_qualifier {\n+  TYPE_UNQUALIFIED   = 0x0,\n+  TYPE_QUAL_CONST    = 0x1,\n+  TYPE_QUAL_VOLATILE = 0x2,\n+  TYPE_QUAL_RESTRICT = 0x4\n+};\n+\n+/* Enumerate visibility settings.  */\n+#ifndef SYMBOL_VISIBILITY_DEFINED\n+#define SYMBOL_VISIBILITY_DEFINED\n+enum symbol_visibility {\n+  VISIBILITY_DEFAULT,\n+  VISIBILITY_PROTECTED,\n+  VISIBILITY_HIDDEN,\n+  VISIBILITY_INTERNAL\n+};\n+#endif  // SYMBOL_VISIBILITY_DEFINED\n+\n+/* Standard named or nameless data types of the C compiler.  */\n+enum tree_index {\n+  TI_ERROR_MARK,\n+  TI_INTQI_TYPE,\n+  TI_INTHI_TYPE,\n+  TI_INTSI_TYPE,\n+  TI_INTDI_TYPE,\n+  TI_INTTI_TYPE,\n+\n+  TI_UINTQI_TYPE,\n+  TI_UINTHI_TYPE,\n+  TI_UINTSI_TYPE,\n+  TI_UINTDI_TYPE,\n+  TI_UINTTI_TYPE,\n+\n+  TI_UINT16_TYPE,\n+  TI_UINT32_TYPE,\n+  TI_UINT64_TYPE,\n+\n+  TI_INTEGER_ZERO,\n+  TI_INTEGER_ONE,\n+  TI_INTEGER_THREE,\n+  TI_INTEGER_MINUS_ONE,\n+  TI_NULL_POINTER,\n+\n+  TI_SIZE_ZERO,\n+  TI_SIZE_ONE,\n+\n+  TI_BITSIZE_ZERO,\n+  TI_BITSIZE_ONE,\n+  TI_BITSIZE_UNIT,\n+\n+  TI_PUBLIC,\n+  TI_PROTECTED,\n+  TI_PRIVATE,\n+\n+  TI_BOOLEAN_FALSE,\n+  TI_BOOLEAN_TRUE,\n+\n+  TI_COMPLEX_INTEGER_TYPE,\n+  TI_COMPLEX_FLOAT_TYPE,\n+  TI_COMPLEX_DOUBLE_TYPE,\n+  TI_COMPLEX_LONG_DOUBLE_TYPE,\n+\n+  TI_FLOAT_TYPE,\n+  TI_DOUBLE_TYPE,\n+  TI_LONG_DOUBLE_TYPE,\n+\n+  TI_FLOAT_PTR_TYPE,\n+  TI_DOUBLE_PTR_TYPE,\n+  TI_LONG_DOUBLE_PTR_TYPE,\n+  TI_INTEGER_PTR_TYPE,\n+\n+  TI_VOID_TYPE,\n+  TI_PTR_TYPE,\n+  TI_CONST_PTR_TYPE,\n+  TI_SIZE_TYPE,\n+  TI_PID_TYPE,\n+  TI_PTRDIFF_TYPE,\n+  TI_VA_LIST_TYPE,\n+  TI_VA_LIST_GPR_COUNTER_FIELD,\n+  TI_VA_LIST_FPR_COUNTER_FIELD,\n+  TI_BOOLEAN_TYPE,\n+  TI_FILEPTR_TYPE,\n+  TI_POINTER_SIZED_TYPE,\n+\n+  TI_DFLOAT32_TYPE,\n+  TI_DFLOAT64_TYPE,\n+  TI_DFLOAT128_TYPE,\n+  TI_DFLOAT32_PTR_TYPE,\n+  TI_DFLOAT64_PTR_TYPE,\n+  TI_DFLOAT128_PTR_TYPE,\n+\n+  TI_VOID_LIST_NODE,\n+\n+  TI_MAIN_IDENTIFIER,\n+\n+  TI_SAT_SFRACT_TYPE,\n+  TI_SAT_FRACT_TYPE,\n+  TI_SAT_LFRACT_TYPE,\n+  TI_SAT_LLFRACT_TYPE,\n+  TI_SAT_USFRACT_TYPE,\n+  TI_SAT_UFRACT_TYPE,\n+  TI_SAT_ULFRACT_TYPE,\n+  TI_SAT_ULLFRACT_TYPE,\n+  TI_SFRACT_TYPE,\n+  TI_FRACT_TYPE,\n+  TI_LFRACT_TYPE,\n+  TI_LLFRACT_TYPE,\n+  TI_USFRACT_TYPE,\n+  TI_UFRACT_TYPE,\n+  TI_ULFRACT_TYPE,\n+  TI_ULLFRACT_TYPE,\n+  TI_SAT_SACCUM_TYPE,\n+  TI_SAT_ACCUM_TYPE,\n+  TI_SAT_LACCUM_TYPE,\n+  TI_SAT_LLACCUM_TYPE,\n+  TI_SAT_USACCUM_TYPE,\n+  TI_SAT_UACCUM_TYPE,\n+  TI_SAT_ULACCUM_TYPE,\n+  TI_SAT_ULLACCUM_TYPE,\n+  TI_SACCUM_TYPE,\n+  TI_ACCUM_TYPE,\n+  TI_LACCUM_TYPE,\n+  TI_LLACCUM_TYPE,\n+  TI_USACCUM_TYPE,\n+  TI_UACCUM_TYPE,\n+  TI_ULACCUM_TYPE,\n+  TI_ULLACCUM_TYPE,\n+  TI_QQ_TYPE,\n+  TI_HQ_TYPE,\n+  TI_SQ_TYPE,\n+  TI_DQ_TYPE,\n+  TI_TQ_TYPE,\n+  TI_UQQ_TYPE,\n+  TI_UHQ_TYPE,\n+  TI_USQ_TYPE,\n+  TI_UDQ_TYPE,\n+  TI_UTQ_TYPE,\n+  TI_SAT_QQ_TYPE,\n+  TI_SAT_HQ_TYPE,\n+  TI_SAT_SQ_TYPE,\n+  TI_SAT_DQ_TYPE,\n+  TI_SAT_TQ_TYPE,\n+  TI_SAT_UQQ_TYPE,\n+  TI_SAT_UHQ_TYPE,\n+  TI_SAT_USQ_TYPE,\n+  TI_SAT_UDQ_TYPE,\n+  TI_SAT_UTQ_TYPE,\n+  TI_HA_TYPE,\n+  TI_SA_TYPE,\n+  TI_DA_TYPE,\n+  TI_TA_TYPE,\n+  TI_UHA_TYPE,\n+  TI_USA_TYPE,\n+  TI_UDA_TYPE,\n+  TI_UTA_TYPE,\n+  TI_SAT_HA_TYPE,\n+  TI_SAT_SA_TYPE,\n+  TI_SAT_DA_TYPE,\n+  TI_SAT_TA_TYPE,\n+  TI_SAT_UHA_TYPE,\n+  TI_SAT_USA_TYPE,\n+  TI_SAT_UDA_TYPE,\n+  TI_SAT_UTA_TYPE,\n+\n+  TI_OPTIMIZATION_DEFAULT,\n+  TI_OPTIMIZATION_CURRENT,\n+  TI_TARGET_OPTION_DEFAULT,\n+  TI_TARGET_OPTION_CURRENT,\n+  TI_CURRENT_TARGET_PRAGMA,\n+  TI_CURRENT_OPTIMIZE_PRAGMA,\n+\n+  TI_MAX\n+};\n+\n+/* An enumeration of the standard C integer types.  These must be\n+   ordered so that shorter types appear before longer ones, and so\n+   that signed types appear before unsigned ones, for the correct\n+   functioning of interpret_integer() in c-lex.c.  */\n+enum integer_type_kind {\n+  itk_char,\n+  itk_signed_char,\n+  itk_unsigned_char,\n+  itk_short,\n+  itk_unsigned_short,\n+  itk_int,\n+  itk_unsigned_int,\n+  itk_long,\n+  itk_unsigned_long,\n+  itk_long_long,\n+  itk_unsigned_long_long,\n+  itk_int128,\n+  itk_unsigned_int128,\n+  itk_none\n+};\n+\n+/* A pointer-to-function member type looks like:\n+\n+     struct {\n+       __P __pfn;\n+       ptrdiff_t __delta;\n+     };\n+\n+   If __pfn is NULL, it is a NULL pointer-to-member-function.\n+\n+   (Because the vtable is always the first thing in the object, we\n+   don't need its offset.)  If the function is virtual, then PFN is\n+   one plus twice the index into the vtable; otherwise, it is just a\n+   pointer to the function.\n+\n+   Unfortunately, using the lowest bit of PFN doesn't work in\n+   architectures that don't impose alignment requirements on function\n+   addresses, or that use the lowest bit to tell one ISA from another,\n+   for example.  For such architectures, we use the lowest bit of\n+   DELTA instead of the lowest bit of the PFN, and DELTA will be\n+   multiplied by 2.  */\n+enum ptrmemfunc_vbit_where_t {\n+  ptrmemfunc_vbit_in_pfn,\n+  ptrmemfunc_vbit_in_delta\n+};\n+\n+/* Flags that may be passed in the third argument of decl_attributes, and\n+   to handler functions for attributes.  */\n+enum attribute_flags {\n+  /* The type passed in is the type of a DECL, and any attributes that\n+     should be passed in again to be applied to the DECL rather than the\n+     type should be returned.  */\n+  ATTR_FLAG_DECL_NEXT = 1,\n+  /* The type passed in is a function return type, and any attributes that\n+     should be passed in again to be applied to the function type rather\n+     than the return type should be returned.  */\n+  ATTR_FLAG_FUNCTION_NEXT = 2,\n+  /* The type passed in is an array element type, and any attributes that\n+     should be passed in again to be applied to the array type rather\n+     than the element type should be returned.  */\n+  ATTR_FLAG_ARRAY_NEXT = 4,\n+  /* The type passed in is a structure, union or enumeration type being\n+     created, and should be modified in place.  */\n+  ATTR_FLAG_TYPE_IN_PLACE = 8,\n+  /* The attributes are being applied by default to a library function whose\n+     name indicates known behavior, and should be silently ignored if they\n+     are not in fact compatible with the function type.  */\n+  ATTR_FLAG_BUILT_IN = 16,\n+  /* A given attribute has been parsed as a C++-11 attribute.  */\n+  ATTR_FLAG_CXX11 = 32\n+};\n+\n+/* Types used to represent sizes.  */\n+enum size_type_kind {\n+  stk_sizetype,\t\t/* Normal representation of sizes in bytes.  */\n+  stk_ssizetype,\t/* Signed representation of sizes in bytes.  */\n+  stk_bitsizetype,\t/* Normal representation of sizes in bits.  */\n+  stk_sbitsizetype,\t/* Signed representation of sizes in bits.  */\n+  stk_type_kind_last\n+};\n+\n+enum operand_equal_flag {\n+  OEP_ONLY_CONST = 1,\n+  OEP_PURE_SAME = 2,\n+  OEP_CONSTANT_ADDRESS_OF = 4\n+};\n+\n+/* Enum and arrays used for tree allocation stats.\n+   Keep in sync with tree.c:tree_node_kind_names.  */\n+enum tree_node_kind {\n+  d_kind,\n+  t_kind,\n+  b_kind,\n+  s_kind,\n+  r_kind,\n+  e_kind,\n+  c_kind,\n+  id_kind,\n+  vec_kind,\n+  binfo_kind,\n+  ssa_name_kind,\n+  constr_kind,\n+  x_kind,\n+  lang_decl,\n+  lang_type,\n+  omp_clause_kind,\n+  all_kinds\n+};\n+\n+\n+/*---------------------------------------------------------------------------\n+                                Type definitions\n+---------------------------------------------------------------------------*/\n+/* When processing aliases at the symbol table level, we need the\n+   declaration of target. For this reason we need to queue aliases and\n+   process them after all declarations has been produced.  */\n+typedef struct GTY(()) alias_pair {\n+  tree decl;\n+  tree target;\n+} alias_pair;\n+\n+/* An initialization priority.  */\n+typedef unsigned short priority_type;\n+\n+/* The type of a callback function for walking over tree structure.  */\n+typedef tree (*walk_tree_fn) (tree *, int *, void *);\n+\n+/* The type of a callback function that represents a custom walk_tree.  */\n+typedef tree (*walk_tree_lh) (tree *, int *, tree (*) (tree *, int *, void *),\n+\t\t\t      void *, struct pointer_set_t*);\n+\n+\n+/*---------------------------------------------------------------------------\n+                              Main data structures\n+---------------------------------------------------------------------------*/\n+/* A tree node can represent a data type, a variable, an expression\n+   or a statement.  Each node has a TREE_CODE which says what kind of\n+   thing it represents.  Some common codes are:\n+   INTEGER_TYPE -- represents a type of integers.\n+   ARRAY_TYPE -- represents a type of pointer.\n+   VAR_DECL -- represents a declared variable.\n+   INTEGER_CST -- represents a constant integer value.\n+   PLUS_EXPR -- represents a sum (an expression).\n+\n+   As for the contents of a tree node: there are some fields\n+   that all nodes share.  Each TREE_CODE has various special-purpose\n+   fields as well.  The fields of a node are never accessed directly,\n+   always through accessor macros.  */\n+\n+/* Every kind of tree node starts with this structure,\n+   so all nodes have these fields.\n+\n+   See the accessor macros, defined below, for documentation of the\n+   fields, and the table below which connects the fields and the\n+   accessor macros.  */\n+\n+struct GTY(()) tree_base {\n+  ENUM_BITFIELD(tree_code) code : 16;\n+\n+  unsigned side_effects_flag : 1;\n+  unsigned constant_flag : 1;\n+  unsigned addressable_flag : 1;\n+  unsigned volatile_flag : 1;\n+  unsigned readonly_flag : 1;\n+  unsigned asm_written_flag: 1;\n+  unsigned nowarning_flag : 1;\n+  unsigned visited : 1;\n+\n+  unsigned used_flag : 1;\n+  unsigned nothrow_flag : 1;\n+  unsigned static_flag : 1;\n+  unsigned public_flag : 1;\n+  unsigned private_flag : 1;\n+  unsigned protected_flag : 1;\n+  unsigned deprecated_flag : 1;\n+  unsigned default_def_flag : 1;\n+\n+  union {\n+    /* The bits in the following structure should only be used with\n+       accessor macros that constrain inputs with tree checking.  */\n+    struct {\n+      unsigned lang_flag_0 : 1;\n+      unsigned lang_flag_1 : 1;\n+      unsigned lang_flag_2 : 1;\n+      unsigned lang_flag_3 : 1;\n+      unsigned lang_flag_4 : 1;\n+      unsigned lang_flag_5 : 1;\n+      unsigned lang_flag_6 : 1;\n+      unsigned saturating_flag : 1;\n+\n+      unsigned unsigned_flag : 1;\n+      unsigned packed_flag : 1;\n+      unsigned user_align : 1;\n+      unsigned nameless_flag : 1;\n+      unsigned spare0 : 4;\n+\n+      unsigned spare1 : 8;\n+\n+      /* This field is only used with TREE_TYPE nodes; the only reason it is\n+\t present in tree_base instead of tree_type is to save space.  The size\n+\t of the field must be large enough to hold addr_space_t values.  */\n+      unsigned address_space : 8;\n+    } bits;\n+    /* The following fields are present in tree_base to save space.  The\n+       nodes using them do not require any of the flags above and so can\n+       make better use of the 4-byte sized word.  */\n+    /* VEC length.  This field is only used with TREE_VEC.  */\n+    int length;\n+    /* SSA version number.  This field is only used with SSA_NAME.  */\n+    unsigned int version;\n+  } GTY((skip(\"\"))) u;\n+};\n+\n+/* The following table lists the uses of each of the above flags and\n+   for which types of nodes they are defined.\n+\n+   addressable_flag:\n+\n+       TREE_ADDRESSABLE in\n+           VAR_DECL, PARM_DECL, RESULT_DECL, FUNCTION_DECL, LABEL_DECL\n+           SSA_NAME\n+           all types\n+           CONSTRUCTOR, IDENTIFIER_NODE\n+           STMT_EXPR\n+\n+       CALL_EXPR_TAILCALL in\n+           CALL_EXPR\n+\n+       CASE_LOW_SEEN in\n+           CASE_LABEL_EXPR\n+\n+       PREDICT_EXPR_OUTCOME in\n+\t   PREDICT_EXPR\n+\n+   static_flag:\n+\n+       TREE_STATIC in\n+           VAR_DECL, FUNCTION_DECL\n+           CONSTRUCTOR\n+\n+       TREE_NO_TRAMPOLINE in\n+           ADDR_EXPR\n+\n+       BINFO_VIRTUAL_P in\n+           TREE_BINFO\n+\n+       TREE_SYMBOL_REFERENCED in\n+           IDENTIFIER_NODE\n+\n+       CLEANUP_EH_ONLY in\n+           TARGET_EXPR, WITH_CLEANUP_EXPR\n+\n+       TRY_CATCH_IS_CLEANUP in\n+           TRY_CATCH_EXPR\n+\n+       ASM_INPUT_P in\n+           ASM_EXPR\n+\n+       TYPE_REF_CAN_ALIAS_ALL in\n+           POINTER_TYPE, REFERENCE_TYPE\n+\n+       CASE_HIGH_SEEN in\n+           CASE_LABEL_EXPR\n+\n+       ENUM_IS_SCOPED in\n+\t   ENUMERAL_TYPE\n+\n+       TRANSACTION_EXPR_OUTER in\n+\t   TRANSACTION_EXPR\n+\n+   public_flag:\n+\n+       TREE_OVERFLOW in\n+           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n+\n+       TREE_PUBLIC in\n+           VAR_DECL, FUNCTION_DECL\n+           IDENTIFIER_NODE\n+\n+       ASM_VOLATILE_P in\n+           ASM_EXPR\n+\n+       CALL_EXPR_VA_ARG_PACK in\n+           CALL_EXPR\n+\n+       TYPE_CACHED_VALUES_P in\n+           all types\n+\n+       SAVE_EXPR_RESOLVED_P in\n+           SAVE_EXPR\n+\n+       OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE in\n+           OMP_CLAUSE_LASTPRIVATE\n+\n+       OMP_CLAUSE_PRIVATE_DEBUG in\n+           OMP_CLAUSE_PRIVATE\n+\n+       TRANSACTION_EXPR_RELAXED in\n+\t   TRANSACTION_EXPR\n+\n+   private_flag:\n+\n+       TREE_PRIVATE in\n+           all decls\n+\n+       CALL_EXPR_RETURN_SLOT_OPT in\n+           CALL_EXPR\n+\n+       OMP_SECTION_LAST in\n+           OMP_SECTION\n+\n+       OMP_PARALLEL_COMBINED in\n+           OMP_PARALLEL\n+\n+       OMP_CLAUSE_PRIVATE_OUTER_REF in\n+\t   OMP_CLAUSE_PRIVATE\n+\n+       TYPE_REF_IS_RVALUE in\n+\t   REFERENCE_TYPE\n+\n+       ENUM_IS_OPAQUE in\n+\t   ENUMERAL_TYPE\n+\n+   protected_flag:\n+\n+       TREE_PROTECTED in\n+           BLOCK\n+           all decls\n+\n+       CALL_FROM_THUNK_P and\n+       CALL_ALLOCA_FOR_VAR_P in\n+           CALL_EXPR\n+\n+   side_effects_flag:\n+\n+       TREE_SIDE_EFFECTS in\n+           all expressions\n+           all decls\n+           all constants\n+\n+       FORCED_LABEL in\n+           LABEL_DECL\n+\n+   volatile_flag:\n+\n+       TREE_THIS_VOLATILE in\n+           all expressions\n+           all decls\n+\n+       TYPE_VOLATILE in\n+           all types\n+\n+   readonly_flag:\n+\n+       TREE_READONLY in\n+           all expressions\n+           all decls\n+\n+       TYPE_READONLY in\n+           all types\n+\n+   constant_flag:\n+\n+       TREE_CONSTANT in\n+           all expressions\n+           all decls\n+           all constants\n+\n+       TYPE_SIZES_GIMPLIFIED in\n+           all types\n+\n+   unsigned_flag:\n+\n+       TYPE_UNSIGNED in\n+           all types\n+\n+       DECL_UNSIGNED in\n+           all decls\n+\n+   asm_written_flag:\n+\n+       TREE_ASM_WRITTEN in\n+           VAR_DECL, FUNCTION_DECL, TYPE_DECL\n+           RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE\n+           BLOCK, STRING_CST\n+\n+       SSA_NAME_OCCURS_IN_ABNORMAL_PHI in\n+           SSA_NAME\n+\n+   used_flag:\n+\n+       TREE_USED in\n+           all expressions\n+           all decls\n+           IDENTIFIER_NODE\n+\n+   nothrow_flag:\n+\n+       TREE_NOTHROW in\n+           CALL_EXPR\n+           FUNCTION_DECL\n+\n+       TYPE_ALIGN_OK in\n+           all types\n+\n+       TREE_THIS_NOTRAP in\n+          INDIRECT_REF, MEM_REF, TARGET_MEM_REF, ARRAY_REF, ARRAY_RANGE_REF\n+\n+       SSA_NAME_IN_FREELIST in\n+          SSA_NAME\n+\n+   deprecated_flag:\n+\n+       TREE_DEPRECATED in\n+           all decls\n+\t   all types\n+\n+       IDENTIFIER_TRANSPARENT_ALIAS in\n+           IDENTIFIER_NODE\n+\n+   visited:\n+\n+       TREE_VISITED in\n+           all trees (used liberally by many passes)\n+\n+   saturating_flag:\n+\n+       TYPE_SATURATING in\n+           all types\n+\n+       VAR_DECL_IS_VIRTUAL_OPERAND in\n+\t   VAR_DECL\n+\n+   nowarning_flag:\n+\n+       TREE_NO_WARNING in\n+           all expressions\n+           all decls\n+\n+       TYPE_ARTIFICIAL in\n+           all types\n+\n+   default_def_flag:\n+\n+       TYPE_VECTOR_OPAQUE in\n+\t   VECTOR_TYPE\n+\n+       SSA_NAME_IS_DEFAULT_DEF in\n+           SSA_NAME\n+\n+       DECL_NONLOCAL_FRAME in\n+\t   VAR_DECL\n+*/\n+\n+struct GTY(()) tree_typed {\n+  struct tree_base base;\n+  tree type;\n+};\n+\n+struct GTY(()) tree_common {\n+  struct tree_typed typed;\n+  tree chain;\n+};\n+\n+struct GTY(()) tree_int_cst {\n+  struct tree_typed typed;\n+  double_int int_cst;\n+};\n+\n+\n+struct GTY(()) tree_real_cst {\n+  struct tree_typed typed;\n+  struct real_value * real_cst_ptr;\n+};\n+\n+struct GTY(()) tree_fixed_cst {\n+  struct tree_typed typed;\n+  struct fixed_value * fixed_cst_ptr;\n+};\n+\n+struct GTY(()) tree_string {\n+  struct tree_typed typed;\n+  int length;\n+  char str[1];\n+};\n+\n+struct GTY(()) tree_complex {\n+  struct tree_typed typed;\n+  tree real;\n+  tree imag;\n+};\n+\n+struct GTY(()) tree_vector {\n+  struct tree_typed typed;\n+  tree GTY ((length (\"TYPE_VECTOR_SUBPARTS (TREE_TYPE ((tree)&%h))\"))) elts[1];\n+};\n+\n+struct GTY(()) tree_identifier {\n+  struct tree_common common;\n+  struct ht_identifier id;\n+};\n+\n+struct GTY(()) tree_list {\n+  struct tree_common common;\n+  tree purpose;\n+  tree value;\n+};\n+\n+struct GTY(()) tree_vec {\n+  struct tree_common common;\n+  tree GTY ((length (\"TREE_VEC_LENGTH ((tree)&%h)\"))) a[1];\n+};\n+\n+/* A single element of a CONSTRUCTOR. VALUE holds the actual value of the\n+   element. INDEX can optionally design the position of VALUE: in arrays,\n+   it is the index where VALUE has to be placed; in structures, it is the\n+   FIELD_DECL of the member.  */\n+typedef struct GTY(()) constructor_elt_d {\n+  tree index;\n+  tree value;\n+} constructor_elt;\n+\n+struct GTY(()) tree_constructor {\n+  struct tree_typed typed;\n+  vec<constructor_elt, va_gc> *elts;\n+};\n+\n+struct GTY(()) tree_exp {\n+  struct tree_typed typed;\n+  location_t locus;\n+  tree GTY ((special (\"tree_exp\"),\n+\t     desc (\"TREE_CODE ((tree) &%0)\")))\n+    operands[1];\n+};\n+\n+/* Immediate use linking structure.  This structure is used for maintaining\n+   a doubly linked list of uses of an SSA_NAME.  */\n+typedef struct GTY(()) ssa_use_operand_d {\n+  struct ssa_use_operand_d* GTY((skip(\"\"))) prev;\n+  struct ssa_use_operand_d* GTY((skip(\"\"))) next;\n+  /* Immediate uses for a given SSA name are maintained as a cyclic\n+     list.  To recognize the root of this list, the location field\n+     needs to point to the original SSA name.  Since statements and\n+     SSA names are of different data types, we need this union.  See\n+     the explanation in struct immediate_use_iterator_d.  */\n+  union { gimple stmt; tree ssa_name; } GTY((skip(\"\"))) loc;\n+  tree *GTY((skip(\"\"))) use;\n+} ssa_use_operand_t;\n+\n+struct GTY(()) tree_ssa_name {\n+  struct tree_typed typed;\n+\n+  /* _DECL wrapped by this SSA name.  */\n+  tree var;\n+\n+  /* Statement that defines this SSA name.  */\n+  gimple def_stmt;\n+\n+  /* Pointer attributes used for alias analysis.  */\n+  struct ptr_info_def *ptr_info;\n+\n+  /* Immediate uses list for this SSA_NAME.  */\n+  struct ssa_use_operand_d imm_uses;\n+};\n+\n+struct GTY(()) phi_arg_d {\n+  /* imm_use MUST be the first element in struct because we do some\n+     pointer arithmetic with it.  See phi_arg_index_from_use.  */\n+  struct ssa_use_operand_d imm_use;\n+  tree def;\n+  location_t locus;\n+};\n+\n+struct GTY(()) tree_omp_clause {\n+  struct tree_common common;\n+  location_t locus;\n+  enum omp_clause_code code;\n+  union omp_clause_subcode {\n+    enum omp_clause_default_kind  default_kind;\n+    enum omp_clause_schedule_kind schedule_kind;\n+    enum tree_code                reduction_code;\n+  } GTY ((skip)) subcode;\n+\n+  /* The gimplification of OMP_CLAUSE_REDUCTION_{INIT,MERGE} for omp-low's\n+     usage.  */\n+  gimple_seq gimple_reduction_init;\n+  gimple_seq gimple_reduction_merge;\n+\n+  tree GTY ((length (\"omp_clause_num_ops[OMP_CLAUSE_CODE ((tree)&%h)]\")))\n+    ops[1];\n+};\n+\n+struct GTY(()) tree_block {\n+  struct tree_base base;\n+  tree chain;\n+\n+  unsigned abstract_flag : 1;\n+  unsigned block_num : 31;\n+\n+  location_t locus;\n+\n+  tree vars;\n+  vec<tree, va_gc> *nonlocalized_vars;\n+\n+  tree subblocks;\n+  tree supercontext;\n+  tree abstract_origin;\n+  tree fragment_origin;\n+  tree fragment_chain;\n+};\n+\n+struct GTY(()) tree_type_common {\n+  struct tree_common common;\n+  tree size;\n+  tree size_unit;\n+  tree attributes;\n+  unsigned int uid;\n+\n+  unsigned int precision : 10;\n+  unsigned no_force_blk_flag : 1;\n+  unsigned needs_constructing_flag : 1;\n+  unsigned transparent_aggr_flag : 1;\n+  unsigned restrict_flag : 1;\n+  unsigned contains_placeholder_bits : 2;\n+\n+  ENUM_BITFIELD(machine_mode) mode : 8;\n+\n+  unsigned string_flag : 1;\n+  unsigned lang_flag_0 : 1;\n+  unsigned lang_flag_1 : 1;\n+  unsigned lang_flag_2 : 1;\n+  unsigned lang_flag_3 : 1;\n+  unsigned lang_flag_4 : 1;\n+  unsigned lang_flag_5 : 1;\n+  unsigned lang_flag_6 : 1;\n+\n+  unsigned int align;\n+  alias_set_type alias_set;\n+  tree pointer_to;\n+  tree reference_to;\n+  union tree_type_symtab {\n+    int GTY ((tag (\"TYPE_SYMTAB_IS_ADDRESS\"))) address;\n+    const char * GTY ((tag (\"TYPE_SYMTAB_IS_POINTER\"))) pointer;\n+    struct die_struct * GTY ((tag (\"TYPE_SYMTAB_IS_DIE\"))) die;\n+  } GTY ((desc (\"debug_hooks->tree_type_symtab_field\"))) symtab;\n+  tree name;\n+  tree next_variant;\n+  tree main_variant;\n+  tree context;\n+  tree canonical;\n+};\n+\n+struct GTY(()) tree_type_with_lang_specific {\n+  struct tree_type_common common;\n+  /* Points to a structure whose details depend on the language in use.  */\n+  struct lang_type *lang_specific;\n+};\n+\n+struct GTY(()) tree_type_non_common {\n+  struct tree_type_with_lang_specific with_lang_specific;\n+  tree values;\n+  tree minval;\n+  tree maxval;\n+  tree binfo;\n+};\n+\n+struct GTY (()) tree_binfo {\n+  struct tree_common common;\n+\n+  tree offset;\n+  tree vtable;\n+  tree virtuals;\n+  tree vptr_field;\n+  vec<tree, va_gc> *base_accesses;\n+  tree inheritance;\n+\n+  tree vtt_subvtt;\n+  tree vtt_vptr;\n+\n+  vec<tree, va_gc> base_binfos;\n+};\n+\n+struct GTY(()) tree_decl_minimal {\n+  struct tree_common common;\n+  location_t locus;\n+  unsigned int uid;\n+  tree name;\n+  tree context;\n+};\n+\n+struct GTY(()) tree_decl_common {\n+  struct tree_decl_minimal common;\n+  tree size;\n+\n+  ENUM_BITFIELD(machine_mode) mode : 8;\n+\n+  unsigned nonlocal_flag : 1;\n+  unsigned virtual_flag : 1;\n+  unsigned ignored_flag : 1;\n+  unsigned abstract_flag : 1;\n+  unsigned artificial_flag : 1;\n+  unsigned preserve_flag: 1;\n+  unsigned debug_expr_is_from : 1;\n+\n+  unsigned lang_flag_0 : 1;\n+  unsigned lang_flag_1 : 1;\n+  unsigned lang_flag_2 : 1;\n+  unsigned lang_flag_3 : 1;\n+  unsigned lang_flag_4 : 1;\n+  unsigned lang_flag_5 : 1;\n+  unsigned lang_flag_6 : 1;\n+  unsigned lang_flag_7 : 1;\n+  unsigned lang_flag_8 : 1;\n+\n+  /* In LABEL_DECL, this is DECL_ERROR_ISSUED.\n+     In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */\n+  unsigned decl_flag_0 : 1;\n+  /* In FIELD_DECL, this is DECL_BIT_FIELD\n+     In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL.\n+     In TYPE_DECL, this is TYPE_DECL_SUPPRESS_DEBUG.  */\n+  unsigned decl_flag_1 : 1;\n+  /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P\n+     In VAR_DECL, PARM_DECL and RESULT_DECL, this is\n+     DECL_HAS_VALUE_EXPR_P.  */\n+  unsigned decl_flag_2 : 1;\n+  /* 1 bit unused.  */\n+  unsigned decl_flag_3 : 1;\n+  /* Logically, these two would go in a theoretical base shared by var and\n+     parm decl. */\n+  unsigned gimple_reg_flag : 1;\n+  /* In VAR_DECL, PARM_DECL and RESULT_DECL, this is DECL_BY_REFERENCE.  */\n+  unsigned decl_by_reference_flag : 1;\n+  /* In a VAR_DECL and PARM_DECL, this is DECL_READ_P.  */\n+  unsigned decl_read_flag : 1;\n+  /* In a VAR_DECL or RESULT_DECL, this is DECL_NONSHAREABLE.  */\n+  unsigned decl_nonshareable_flag : 1;\n+\n+  /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */\n+  unsigned int off_align : 8;\n+\n+  /* 24 bits unused.  */\n+\n+  /* DECL_ALIGN.  It should have the same size as TYPE_ALIGN.  */\n+  unsigned int align;\n+\n+  /* UID for points-to sets, stable over copying from inlining.  */\n+  unsigned int pt_uid;\n+\n+  tree size_unit;\n+  tree initial;\n+  tree attributes;\n+  tree abstract_origin;\n+\n+  /* Points to a structure whose details depend on the language in use.  */\n+  struct lang_decl *lang_specific;\n+};\n+\n+struct GTY(()) tree_decl_with_rtl {\n+  struct tree_decl_common common;\n+  rtx rtl;\n+};\n+\n+struct GTY(()) tree_field_decl {\n+  struct tree_decl_common common;\n+\n+  tree offset;\n+  tree bit_field_type;\n+  tree qualifier;\n+  tree bit_offset;\n+  tree fcontext;\n+};\n+\n+struct GTY(()) tree_label_decl {\n+  struct tree_decl_with_rtl common;\n+  int label_decl_uid;\n+  int eh_landing_pad_nr;\n+};\n+\n+struct GTY(()) tree_result_decl {\n+  struct tree_decl_with_rtl common;\n+};\n+\n+struct GTY(()) tree_const_decl {\n+  struct tree_decl_common common;\n+};\n+\n+struct GTY(()) tree_parm_decl {\n+  struct tree_decl_with_rtl common;\n+  rtx incoming_rtl;\n+};\n+\n+struct GTY(()) tree_decl_with_vis {\n+ struct tree_decl_with_rtl common;\n+ tree assembler_name;\n+ tree section_name;\n+ tree comdat_group;\n+\n+ /* Belong to VAR_DECL exclusively.  */\n+ unsigned defer_output : 1;\n+ unsigned hard_register : 1;\n+ unsigned common_flag : 1;\n+ unsigned in_text_section : 1;\n+ unsigned in_constant_pool : 1;\n+ unsigned dllimport_flag : 1;\n+ /* Don't belong to VAR_DECL exclusively.  */\n+ unsigned weak_flag : 1;\n+ /* When SECTION_NAME is implied by -ffunction-section.  */\n+ unsigned implicit_section_name_p : 1;\n+\n+ unsigned seen_in_bind_expr : 1;\n+ unsigned comdat_flag : 1;\n+ ENUM_BITFIELD(symbol_visibility) visibility : 2;\n+ unsigned visibility_specified : 1;\n+ /* Belongs to VAR_DECL exclusively.  */\n+ ENUM_BITFIELD(tls_model) tls_model : 3;\n+\n+ /* Belong to FUNCTION_DECL exclusively.  */\n+ unsigned init_priority_p : 1;\n+ /* Used by C++ only.  Might become a generic decl flag.  */\n+ unsigned shadowed_for_var_p : 1;\n+ /* Belong to FUNCTION_DECL exclusively.  */\n+ unsigned cxx_constructor : 1;\n+ /* Belong to FUNCTION_DECL exclusively.  */\n+ unsigned cxx_destructor : 1;\n+ /* Belong to FUNCTION_DECL exclusively.  */\n+ unsigned final : 1;\n+ /* 11 unused bits. */\n+};\n+\n+struct GTY(()) tree_var_decl {\n+  struct tree_decl_with_vis common;\n+};\n+\n+struct GTY(()) tree_decl_non_common {\n+  struct tree_decl_with_vis common;\n+  /* C++ uses this in namespaces.  */\n+  tree saved_tree;\n+  /* C++ uses this in templates.  */\n+  tree arguments;\n+  /* Almost all FE's use this.  */\n+  tree result;\n+  /* C++ uses this in namespaces and function_decls.  */\n+  tree vindex;\n+};\n+\n+struct GTY(()) tree_function_decl {\n+  struct tree_decl_non_common common;\n+\n+  struct function *f;\n+\n+  /* The personality function. Used for stack unwinding. */\n+  tree personality;\n+\n+  /* Function specific options that are used by this function.  */\n+  tree function_specific_target;\t/* target options */\n+  tree function_specific_optimization;\t/* optimization options */\n+\n+  /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n+     DECL_FUNCTION_CODE.  Otherwise unused.\n+     ???  The bitfield needs to be able to hold all target function\n+\t  codes as well.  */\n+  ENUM_BITFIELD(built_in_function) function_code : 11;\n+  ENUM_BITFIELD(built_in_class) built_in_class : 2;\n+\n+  unsigned static_ctor_flag : 1;\n+  unsigned static_dtor_flag : 1;\n+  unsigned uninlinable : 1;\n+\n+  unsigned possibly_inlined : 1;\n+  unsigned novops_flag : 1;\n+  unsigned returns_twice_flag : 1;\n+  unsigned malloc_flag : 1;\n+  unsigned operator_new_flag : 1;\n+  unsigned declared_inline_flag : 1;\n+  unsigned regdecl_flag : 1;\n+  unsigned no_inline_warning_flag : 1;\n+\n+  unsigned no_instrument_function_entry_exit : 1;\n+  unsigned no_limit_stack : 1;\n+  unsigned disregard_inline_limits : 1;\n+  unsigned pure_flag : 1;\n+  unsigned looping_const_or_pure_flag : 1;\n+  unsigned has_debug_args_flag : 1;\n+  unsigned tm_clone_flag : 1;\n+  unsigned versioned_function : 1;\n+  /* No bits left.  */\n+};\n+\n+struct GTY(()) tree_translation_unit_decl {\n+  struct tree_decl_common common;\n+  /* Source language of this translation unit.  Used for DWARF output.  */\n+  const char * GTY((skip(\"\"))) language;\n+  /* TODO: Non-optimization used to build this translation unit.  */\n+  /* TODO: Root of a partial DWARF tree for global types and decls.  */\n+};\n+\n+struct GTY(()) tree_type_decl {\n+  struct tree_decl_non_common common;\n+\n+};\n+\n+struct GTY ((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) tree_statement_list_node\n+ {\n+  struct tree_statement_list_node *prev;\n+  struct tree_statement_list_node *next;\n+  tree stmt;\n+};\n+\n+struct GTY(()) tree_statement_list\n+ {\n+  struct tree_typed typed;\n+  struct tree_statement_list_node *head;\n+  struct tree_statement_list_node *tail;\n+};\n+\n+struct GTY(()) tree_optimization_option {\n+  struct tree_common common;\n+\n+  /* The optimization options used by the user.  */\n+  struct cl_optimization opts;\n+\n+  /* Target optabs for this set of optimization options.  This is of\n+     type `struct target_optabs *'.  */\n+  unsigned char *GTY ((atomic)) optabs;\n+\n+  /* The value of this_target_optabs against which the optabs above were\n+     generated.  */\n+  struct target_optabs *GTY ((skip)) base_optabs;\n+};\n+\n+struct GTY(()) tree_target_option {\n+  struct tree_common common;\n+\n+  /* The optimization options used by the user.  */\n+  struct cl_target_option opts;\n+};\n+\n+/* Define the overall contents of a tree node.\n+   It may be any of the structures declared above\n+   for various types of node.  */\n+union GTY ((ptr_alias (union lang_tree_node),\n+\t    desc (\"tree_node_structure (&%h)\"), variable_size)) tree_node {\n+  struct tree_base GTY ((tag (\"TS_BASE\"))) base;\n+  struct tree_typed GTY ((tag (\"TS_TYPED\"))) typed;\n+  struct tree_common GTY ((tag (\"TS_COMMON\"))) common;\n+  struct tree_int_cst GTY ((tag (\"TS_INT_CST\"))) int_cst;\n+  struct tree_real_cst GTY ((tag (\"TS_REAL_CST\"))) real_cst;\n+  struct tree_fixed_cst GTY ((tag (\"TS_FIXED_CST\"))) fixed_cst;\n+  struct tree_vector GTY ((tag (\"TS_VECTOR\"))) vector;\n+  struct tree_string GTY ((tag (\"TS_STRING\"))) string;\n+  struct tree_complex GTY ((tag (\"TS_COMPLEX\"))) complex;\n+  struct tree_identifier GTY ((tag (\"TS_IDENTIFIER\"))) identifier;\n+  struct tree_decl_minimal GTY((tag (\"TS_DECL_MINIMAL\"))) decl_minimal;\n+  struct tree_decl_common GTY ((tag (\"TS_DECL_COMMON\"))) decl_common;\n+  struct tree_decl_with_rtl GTY ((tag (\"TS_DECL_WRTL\"))) decl_with_rtl;\n+  struct tree_decl_non_common  GTY ((tag (\"TS_DECL_NON_COMMON\")))\n+    decl_non_common;\n+  struct tree_parm_decl  GTY  ((tag (\"TS_PARM_DECL\"))) parm_decl;\n+  struct tree_decl_with_vis GTY ((tag (\"TS_DECL_WITH_VIS\"))) decl_with_vis;\n+  struct tree_var_decl GTY ((tag (\"TS_VAR_DECL\"))) var_decl;\n+  struct tree_field_decl GTY ((tag (\"TS_FIELD_DECL\"))) field_decl;\n+  struct tree_label_decl GTY ((tag (\"TS_LABEL_DECL\"))) label_decl;\n+  struct tree_result_decl GTY ((tag (\"TS_RESULT_DECL\"))) result_decl;\n+  struct tree_const_decl GTY ((tag (\"TS_CONST_DECL\"))) const_decl;\n+  struct tree_type_decl GTY ((tag (\"TS_TYPE_DECL\"))) type_decl;\n+  struct tree_function_decl GTY ((tag (\"TS_FUNCTION_DECL\"))) function_decl;\n+  struct tree_translation_unit_decl GTY ((tag (\"TS_TRANSLATION_UNIT_DECL\")))\n+    translation_unit_decl;\n+  struct tree_type_common GTY ((tag (\"TS_TYPE_COMMON\"))) type_common;\n+  struct tree_type_with_lang_specific GTY ((tag (\"TS_TYPE_WITH_LANG_SPECIFIC\")))\n+    type_with_lang_specific;\n+  struct tree_type_non_common GTY ((tag (\"TS_TYPE_NON_COMMON\")))\n+    type_non_common;\n+  struct tree_list GTY ((tag (\"TS_LIST\"))) list;\n+  struct tree_vec GTY ((tag (\"TS_VEC\"))) vec;\n+  struct tree_exp GTY ((tag (\"TS_EXP\"))) exp;\n+  struct tree_ssa_name GTY ((tag (\"TS_SSA_NAME\"))) ssa_name;\n+  struct tree_block GTY ((tag (\"TS_BLOCK\"))) block;\n+  struct tree_binfo GTY ((tag (\"TS_BINFO\"))) binfo;\n+  struct tree_statement_list GTY ((tag (\"TS_STATEMENT_LIST\"))) stmt_list;\n+  struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n+  struct tree_omp_clause GTY ((tag (\"TS_OMP_CLAUSE\"))) omp_clause;\n+  struct tree_optimization_option GTY ((tag (\"TS_OPTIMIZATION\"))) optimization;\n+  struct tree_target_option GTY ((tag (\"TS_TARGET_OPTION\"))) target_option;\n+};\n+\n+/* Structure describing an attribute and a function to handle it.  */\n+struct attribute_spec {\n+  /* The name of the attribute (without any leading or trailing __),\n+     or NULL to mark the end of a table of attributes.  */\n+  const char *name;\n+  /* The minimum length of the list of arguments of the attribute.  */\n+  int min_length;\n+  /* The maximum length of the list of arguments of the attribute\n+     (-1 for no maximum).  */\n+  int max_length;\n+  /* Whether this attribute requires a DECL.  If it does, it will be passed\n+     from types of DECLs, function return types and array element types to\n+     the DECLs, function types and array types respectively; but when\n+     applied to a type in any other circumstances, it will be ignored with\n+     a warning.  (If greater control is desired for a given attribute,\n+     this should be false, and the flags argument to the handler may be\n+     used to gain greater control in that case.)  */\n+  bool decl_required;\n+  /* Whether this attribute requires a type.  If it does, it will be passed\n+     from a DECL to the type of that DECL.  */\n+  bool type_required;\n+  /* Whether this attribute requires a function (or method) type.  If it does,\n+     it will be passed from a function pointer type to the target type,\n+     and from a function return type (which is not itself a function\n+     pointer type) to the function type.  */\n+  bool function_type_required;\n+  /* Function to handle this attribute.  NODE points to the node to which\n+     the attribute is to be applied.  If a DECL, it should be modified in\n+     place; if a TYPE, a copy should be created.  NAME is the name of the\n+     attribute (possibly with leading or trailing __).  ARGS is the TREE_LIST\n+     of the arguments (which may be NULL).  FLAGS gives further information\n+     about the context of the attribute.  Afterwards, the attributes will\n+     be added to the DECL_ATTRIBUTES or TYPE_ATTRIBUTES, as appropriate,\n+     unless *NO_ADD_ATTRS is set to true (which should be done on error,\n+     as well as in any other cases when the attributes should not be added\n+     to the DECL or TYPE).  Depending on FLAGS, any attributes to be\n+     applied to another type or DECL later may be returned;\n+     otherwise the return value should be NULL_TREE.  This pointer may be\n+     NULL if no special handling is required beyond the checks implied\n+     by the rest of this structure.  */\n+  tree (*handler) (tree *node, tree name, tree args,\n+\t\t   int flags, bool *no_add_attrs);\n+  /* Specifies if attribute affects type's identity.  */\n+  bool affects_type_identity;\n+};\n+\n+/* These functions allow a front-end to perform a manual layout of a\n+   RECORD_TYPE.  (For instance, if the placement of subsequent fields\n+   depends on the placement of fields so far.)  Begin by calling\n+   start_record_layout.  Then, call place_field for each of the\n+   fields.  Then, call finish_record_layout.  See layout_type for the\n+   default way in which these functions are used.  */\n+typedef struct record_layout_info_s {\n+  /* The RECORD_TYPE that we are laying out.  */\n+  tree t;\n+  /* The offset into the record so far, in bytes, not including bits in\n+     BITPOS.  */\n+  tree offset;\n+  /* The last known alignment of SIZE.  */\n+  unsigned int offset_align;\n+  /* The bit position within the last OFFSET_ALIGN bits, in bits.  */\n+  tree bitpos;\n+  /* The alignment of the record so far, in bits.  */\n+  unsigned int record_align;\n+  /* The alignment of the record so far, ignoring #pragma pack and\n+     __attribute__ ((packed)), in bits.  */\n+  unsigned int unpacked_align;\n+  /* The previous field laid out.  */\n+  tree prev_field;\n+  /* The static variables (i.e., class variables, as opposed to\n+     instance variables) encountered in T.  */\n+  vec<tree, va_gc> *pending_statics;\n+  /* Bits remaining in the current alignment group */\n+  int remaining_in_alignment;\n+  /* True if we've seen a packed field that didn't have normal\n+     alignment anyway.  */\n+  int packed_maybe_necessary;\n+} *record_layout_info;\n+\n+/* Iterator for going through the function arguments.  */\n+struct function_args_iterator {\n+  tree next;\t\t\t/* TREE_LIST pointing to the next argument */\n+};\n+\n+/* Structures to map from a tree to another tree.  */\n+struct GTY(()) tree_map_base {\n+  tree from;\n+};\n+\n+struct GTY(()) tree_map {\n+  struct tree_map_base base;\n+  unsigned int hash;\n+  tree to;\n+};\n+\n+/* Map from a decl tree to another tree.  */\n+struct GTY(()) tree_decl_map {\n+  struct tree_map_base base;\n+  tree to;\n+};\n+\n+/* Map from a tree to an int.  */\n+struct GTY(()) tree_int_map {\n+  struct tree_map_base base;\n+  unsigned int to;\n+};\n+\n+/* Map from a tree to initialization/finalization priorities.  */\n+struct GTY(()) tree_priority_map {\n+  struct tree_map_base base;\n+  priority_type init;\n+  priority_type fini;\n+};\n+\n+/* Map from a decl tree to a tree vector.  */\n+struct GTY(()) tree_vec_map {\n+  struct tree_map_base base;\n+  vec<tree, va_gc> *to;\n+};\n+\n+/* Abstract iterators for CALL_EXPRs.  These static inline definitions\n+   have to go towards the end of tree.h so that union tree_node is fully\n+   defined by this point.  */\n+\n+/* Structure containing iterator state.  */\n+struct call_expr_arg_iterator {\n+  tree t;\t/* the call_expr */\n+  int n;\t/* argument count */\n+  int i;\t/* next argument index */\n+};\n+\n+struct const_call_expr_arg_iterator {\n+  const_tree t;\t/* the call_expr */\n+  int n;\t/* argument count */\n+  int i;\t/* next argument index */\n+};\n+\n+/* The builtin_info structure holds the FUNCTION_DECL of the standard builtin\n+   function, and a flag that says if the function is available implicitly, or\n+   whether the user has to code explicit calls to __builtin_<xxx>.  */\n+struct GTY(()) builtin_info_type {\n+  tree decl[(int)END_BUILTINS];\n+  bool implicit_p[(int)END_BUILTINS];\n+};\n+\n+\n+/*---------------------------------------------------------------------------\n+                                Global variables\n+---------------------------------------------------------------------------*/\n+/* Matrix describing the structures contained in a given tree code.  */\n+extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n+\n+/* Class of tree given its code.  */\n+extern const enum tree_code_class tree_code_type[];\n+\n+/* Each tree code class has an associated string representation.\n+   These must correspond to the tree_code_class entries.  */\n+extern const char *const tree_code_class_strings[];\n+\n+/* Number of argument-words in each kind of tree-node.  */\n+extern const unsigned char tree_code_length[];\n+\n+/* Names of tree components.  */\n+extern const char *const tree_code_name[];\n+\n+/* Vector of all alias pairs for global symbols.  */\n+extern GTY(()) vec<alias_pair, va_gc> *alias_pairs;\n+\n+/* Names of all the built_in classes.  */\n+extern const char *const built_in_class_names[BUILT_IN_LAST];\n+\n+/* Names of all the built_in functions.  */\n+extern const char * built_in_names[(int) END_BUILTINS];\n+\n+/* Number of operands and names for each OMP_CLAUSE node.  */\n+extern unsigned const char omp_clause_num_ops[];\n+extern const char * const omp_clause_code_name[];\n+\n+/* A vector of all translation-units.  */\n+extern GTY (()) vec<tree, va_gc> *all_translation_units;\n+\n+/* Vector of standard trees used by the C compiler.  */\n+extern GTY(()) tree global_trees[TI_MAX];\n+\n+/* The standard C integer types.  Use integer_type_kind to index into\n+   this array.  */\n+extern GTY(()) tree integer_types[itk_none];\n+\n+/* Types used to represent sizes.  */\n+extern GTY(()) tree sizetype_tab[(int) stk_type_kind_last];\n+\n+/* Arrays for keeping track of tree node statistics.  */\n+extern int tree_node_counts[];\n+extern int tree_node_sizes[];\n+\n+/* True if we are in gimple form and the actions of the folders need to\n+   be restricted.  False if we are not in gimple form and folding is not\n+   restricted to creating gimple expressions.  */\n+extern bool in_gimple_form;\n+\n+/* Functional interface to the builtin functions.  */\n+extern GTY(()) builtin_info_type builtin_info;\n+\n+/* If nonzero, an upper limit on alignment of structure fields, in bits,  */\n+extern unsigned int maximum_field_alignment;\n+\n+/* Nonzero means lvalues are limited to those valid in pedantic ANSI C.\n+   Zero means allow extended lvalues.  */\n+extern int pedantic_lvalues;\n+\n+/* Points to the FUNCTION_DECL of the function whose body we are reading.  */\n+extern GTY(()) tree current_function_decl;\n+\n+/* Nonzero means a FUNC_BEGIN label was emitted.  */\n+extern GTY(()) const char * current_function_func_begin_label;\n+\n+#endif  // GCC_TREE_CORE_H"}, {"sha": "718d8f45276885f54e3b72320b66e09cdeb1e2b9", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1700, "changes": 1702, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e351e96076332aa8c42848701b59923468eae98/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e351e96076332aa8c42848701b59923468eae98/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5e351e96076332aa8c42848701b59923468eae98", "patch": "@@ -20,32 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_H\n #define GCC_TREE_H\n \n-#include \"hashtab.h\"\n-#include \"machmode.h\"\n-#include \"input.h\"\n-#include \"statistics.h\"\n-#include \"vec.h\"\n-#include \"double-int.h\"\n-#include \"real.h\"\n-#include \"fixed-value.h\"\n-#include \"alias.h\"\n-#include \"flags.h\"\n-\n-/* Codes of tree nodes */\n-\n-#define DEFTREECODE(SYM, STRING, TYPE, NARGS)   SYM,\n-#define END_OF_BASE_TREE_CODES LAST_AND_UNUSED_TREE_CODE,\n-\n-enum tree_code {\n-#include \"all-tree.def\"\n-MAX_TREE_CODES\n-};\n-\n-#undef DEFTREECODE\n-#undef END_OF_BASE_TREE_CODES\n-\n-extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n-#define CODE_CONTAINS_STRUCT(CODE, STRUCT) (tree_contains_struct[(CODE)][(STRUCT)])\n+#include \"tree-core.h\"\n \n /* Macros for initializing `tree_contains_struct'.  */\n #define MARK_TS_BASE(C)\t\t\t\t\t\\\n@@ -107,42 +82,12 @@ extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n     tree_contains_struct[C][TS_DECL_NON_COMMON] = 1;\t\\\n   } while (0)\n \n-/* Number of language-independent tree codes.  */\n-#define NUM_TREE_CODES ((int) LAST_AND_UNUSED_TREE_CODE)\n-\n-/* Tree code classes.  */\n-\n-/* Each tree_code has an associated code class represented by a\n-   TREE_CODE_CLASS.  */\n-\n-enum tree_code_class {\n-  tcc_exceptional, /* An exceptional code (fits no category).  */\n-  tcc_constant,    /* A constant.  */\n-  /* Order of tcc_type and tcc_declaration is important.  */\n-  tcc_type,        /* A type object code.  */\n-  tcc_declaration, /* A declaration (also serving as variable refs).  */\n-  tcc_reference,   /* A reference to storage.  */\n-  tcc_comparison,  /* A comparison expression.  */\n-  tcc_unary,       /* A unary arithmetic expression.  */\n-  tcc_binary,      /* A binary arithmetic expression.  */\n-  tcc_statement,   /* A statement expression, which have side effects\n-\t\t      but usually no interesting value.  */\n-  tcc_vl_exp,      /* A function call or other expression with a\n-\t\t      variable-length operand vector.  */\n-  tcc_expression   /* Any other expression.  */\n-};\n-\n-/* Each tree code class has an associated string representation.\n-   These must correspond to the tree_code_class entries.  */\n-\n-extern const char *const tree_code_class_strings[];\n \n /* Returns the string representing CLASS.  */\n \n #define TREE_CODE_CLASS_STRING(CLASS)\\\n         tree_code_class_strings[(int) (CLASS)]\n \n-extern const enum tree_code_class tree_code_type[];\n #define TREE_CODE_CLASS(CODE)\ttree_code_type[(int) (CODE)]\n \n /* Nonzero if CODE represents an exceptional code.  */\n@@ -231,76 +176,8 @@ extern const enum tree_code_class tree_code_type[];\n \n #define EXPR_P(NODE) IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))\n \n-/* Number of argument-words in each kind of tree-node.  */\n-\n-extern const unsigned char tree_code_length[];\n #define TREE_CODE_LENGTH(CODE)\ttree_code_length[(int) (CODE)]\n \n-/* Names of tree components.  */\n-\n-extern const char *const tree_code_name[];\n-\n-/* When procesing aliases on symtab level, we need the declaration of target.\n-   For this reason we need to queue aliases and process them after all declarations\n-   has been produced.  */\n-\n-typedef struct GTY(()) alias_pair\n-{\n-  tree decl;\n-  tree target;  \n-} alias_pair;\n-\n-/* Define gc'd vector type.  */\n-\n-extern GTY(()) vec<alias_pair, va_gc> *alias_pairs;\n-\n-\f\n-/* Classify which part of the compiler has defined a given builtin function.\n-   Note that we assume below that this is no more than two bits.  */\n-enum built_in_class\n-{\n-  NOT_BUILT_IN = 0,\n-  BUILT_IN_FRONTEND,\n-  BUILT_IN_MD,\n-  BUILT_IN_NORMAL\n-};\n-\n-/* Last marker used for LTO stremaing of built_in_class.  We can not add it\n-   to the enum since we need the enumb to fit in 2 bits.  */\n-#define BUILT_IN_LAST (BUILT_IN_NORMAL + 1)\n-\n-/* Names for the above.  */\n-extern const char *const built_in_class_names[4];\n-\n-/* Codes that identify the various built in functions\n-   so that expand_call can identify them quickly.  */\n-\n-#define DEF_BUILTIN(ENUM, N, C, T, LT, B, F, NA, AT, IM, COND) ENUM,\n-enum built_in_function\n-{\n-#include \"builtins.def\"\n-\n-  /* Complex division routines in libgcc.  These are done via builtins\n-     because emit_library_call_value can't handle complex values.  */\n-  BUILT_IN_COMPLEX_MUL_MIN,\n-  BUILT_IN_COMPLEX_MUL_MAX\n-    = BUILT_IN_COMPLEX_MUL_MIN\n-      + MAX_MODE_COMPLEX_FLOAT\n-      - MIN_MODE_COMPLEX_FLOAT,\n-\n-  BUILT_IN_COMPLEX_DIV_MIN,\n-  BUILT_IN_COMPLEX_DIV_MAX\n-    = BUILT_IN_COMPLEX_DIV_MIN\n-      + MAX_MODE_COMPLEX_FLOAT\n-      - MIN_MODE_COMPLEX_FLOAT,\n-\n-  /* Upper bound on non-language-specific builtins.  */\n-  END_BUILTINS\n-};\n-#undef DEF_BUILTIN\n-\n-/* Names for the above.  */\n-extern const char * built_in_names[(int) END_BUILTINS];\n \n /* Helper macros for math builtins.  */\n \n@@ -323,438 +200,6 @@ extern const char * built_in_names[(int) END_BUILTINS];\n #define CASE_FLT_FN(FN) case FN: case FN##F: case FN##L\n #define CASE_FLT_FN_REENT(FN) case FN##_R: case FN##F_R: case FN##L_R\n #define CASE_INT_FN(FN) case FN: case FN##L: case FN##LL: case FN##IMAX\n-\f\n-/* In an OMP_CLAUSE node.  */\n-\n-/* Number of operands and names for each clause.  */\n-extern unsigned const char omp_clause_num_ops[];\n-extern const char * const omp_clause_code_name[];\n-\n-/* Clause codes.  Do not reorder, as this is used to index into the tables\n-   omp_clause_num_ops and omp_clause_code_name.  */\n-enum omp_clause_code\n-{\n-  /* Clause zero is special-cased inside the parser\n-     (c_parser_omp_variable_list).  */\n-  OMP_CLAUSE_ERROR = 0,\n-\n-  /* OpenMP clause: private (variable_list).  */\n-  OMP_CLAUSE_PRIVATE,\n-\n-  /* OpenMP clause: shared (variable_list).  */\n-  OMP_CLAUSE_SHARED,\n-\n-  /* OpenMP clause: firstprivate (variable_list).  */\n-  OMP_CLAUSE_FIRSTPRIVATE,\n-\n-  /* OpenMP clause: lastprivate (variable_list).  */\n-  OMP_CLAUSE_LASTPRIVATE,\n-\n-  /* OpenMP clause: reduction (operator:variable_list).\n-     OMP_CLAUSE_REDUCTION_CODE: The tree_code of the operator.\n-     Operand 1: OMP_CLAUSE_REDUCTION_INIT: Stmt-list to initialize the var.\n-     Operand 2: OMP_CLAUSE_REDUCTION_MERGE: Stmt-list to merge private var\n-                into the shared one.\n-     Operand 3: OMP_CLAUSE_REDUCTION_PLACEHOLDER: A dummy VAR_DECL\n-                placeholder used in OMP_CLAUSE_REDUCTION_{INIT,MERGE}.  */\n-  OMP_CLAUSE_REDUCTION,\n-\n-  /* OpenMP clause: copyin (variable_list).  */\n-  OMP_CLAUSE_COPYIN,\n-\n-  /* OpenMP clause: copyprivate (variable_list).  */\n-  OMP_CLAUSE_COPYPRIVATE,\n-\n-  /* OpenMP clause: linear (variable-list[:linear-step]).  */\n-  OMP_CLAUSE_LINEAR,\n-\n-  /* OpenMP clause: uniform (argument-list).  */\n-  OMP_CLAUSE_UNIFORM,\n-\n-  /* OpenMP clause: if (scalar-expression).  */\n-  OMP_CLAUSE_IF,\n-\n-  /* OpenMP clause: num_threads (integer-expression).  */\n-  OMP_CLAUSE_NUM_THREADS,\n-\n-  /* OpenMP clause: schedule.  */\n-  OMP_CLAUSE_SCHEDULE,\n-\n-  /* OpenMP clause: nowait.  */\n-  OMP_CLAUSE_NOWAIT,\n-\n-  /* OpenMP clause: ordered.  */\n-  OMP_CLAUSE_ORDERED,\n-\n-  /* OpenMP clause: default.  */\n-  OMP_CLAUSE_DEFAULT,\n-\n-  /* OpenMP clause: collapse (constant-integer-expression).  */\n-  OMP_CLAUSE_COLLAPSE,\n-\n-  /* OpenMP clause: untied.  */\n-  OMP_CLAUSE_UNTIED,\n-\n-  /* OpenMP clause: final (scalar-expression).  */\n-  OMP_CLAUSE_FINAL,\n-\n-  /* OpenMP clause: mergeable.  */\n-  OMP_CLAUSE_MERGEABLE,\n-\n-  /* OpenMP clause: safelen (constant-integer-expression).  */\n-  OMP_CLAUSE_SAFELEN,\n-\n-  /* Internally used only clause, holding SIMD uid.  */\n-  OMP_CLAUSE__SIMDUID_\n-};\n-\f\n-/* The definition of tree nodes fills the next several pages.  */\n-\n-/* A tree node can represent a data type, a variable, an expression\n-   or a statement.  Each node has a TREE_CODE which says what kind of\n-   thing it represents.  Some common codes are:\n-   INTEGER_TYPE -- represents a type of integers.\n-   ARRAY_TYPE -- represents a type of pointer.\n-   VAR_DECL -- represents a declared variable.\n-   INTEGER_CST -- represents a constant integer value.\n-   PLUS_EXPR -- represents a sum (an expression).\n-\n-   As for the contents of a tree node: there are some fields\n-   that all nodes share.  Each TREE_CODE has various special-purpose\n-   fields as well.  The fields of a node are never accessed directly,\n-   always through accessor macros.  */\n-\n-/* Every kind of tree node starts with this structure,\n-   so all nodes have these fields.\n-\n-   See the accessor macros, defined below, for documentation of the\n-   fields, and the table below which connects the fields and the\n-   accessor macros.  */\n-\n-struct GTY(()) tree_base {\n-  ENUM_BITFIELD(tree_code) code : 16;\n-\n-  unsigned side_effects_flag : 1;\n-  unsigned constant_flag : 1;\n-  unsigned addressable_flag : 1;\n-  unsigned volatile_flag : 1;\n-  unsigned readonly_flag : 1;\n-  unsigned asm_written_flag: 1;\n-  unsigned nowarning_flag : 1;\n-  unsigned visited : 1;\n-\n-  unsigned used_flag : 1;\n-  unsigned nothrow_flag : 1;\n-  unsigned static_flag : 1;\n-  unsigned public_flag : 1;\n-  unsigned private_flag : 1;\n-  unsigned protected_flag : 1;\n-  unsigned deprecated_flag : 1;\n-  unsigned default_def_flag : 1;\n-\n-  union {\n-    /* The bits in the following structure should only be used with\n-       accessor macros that constrain inputs with tree checking.  */\n-    struct {\n-      unsigned lang_flag_0 : 1;\n-      unsigned lang_flag_1 : 1;\n-      unsigned lang_flag_2 : 1;\n-      unsigned lang_flag_3 : 1;\n-      unsigned lang_flag_4 : 1;\n-      unsigned lang_flag_5 : 1;\n-      unsigned lang_flag_6 : 1;\n-      unsigned saturating_flag : 1;\n-\n-      unsigned unsigned_flag : 1;\n-      unsigned packed_flag : 1;\n-      unsigned user_align : 1;\n-      unsigned nameless_flag : 1;\n-      unsigned spare0 : 4;\n-\n-      unsigned spare1 : 8;\n-\n-      /* This field is only used with TREE_TYPE nodes; the only reason it is\n-\t present in tree_base instead of tree_type is to save space.  The size\n-\t of the field must be large enough to hold addr_space_t values.  */\n-      unsigned address_space : 8;\n-    } bits;\n-    /* The following fields are present in tree_base to save space.  The\n-       nodes using them do not require any of the flags above and so can\n-       make better use of the 4-byte sized word.  */\n-    /* VEC length.  This field is only used with TREE_VEC.  */\n-    int length;\n-    /* SSA version number.  This field is only used with SSA_NAME.  */\n-    unsigned int version;\n-  } GTY((skip(\"\"))) u;\n-};\n-\n-/* The following table lists the uses of each of the above flags and\n-   for which types of nodes they are defined.\n-\n-   addressable_flag:\n-\n-       TREE_ADDRESSABLE in\n-           VAR_DECL, PARM_DECL, RESULT_DECL, FUNCTION_DECL, LABEL_DECL\n-           SSA_NAME\n-           all types\n-           CONSTRUCTOR, IDENTIFIER_NODE\n-           STMT_EXPR\n-\n-       CALL_EXPR_TAILCALL in\n-           CALL_EXPR\n-\n-       CASE_LOW_SEEN in\n-           CASE_LABEL_EXPR\n-\n-       PREDICT_EXPR_OUTCOME in\n-\t   PREDICT_EXPR\n-\n-   static_flag:\n-\n-       TREE_STATIC in\n-           VAR_DECL, FUNCTION_DECL\n-           CONSTRUCTOR\n-\n-       TREE_NO_TRAMPOLINE in\n-           ADDR_EXPR\n-\n-       BINFO_VIRTUAL_P in\n-           TREE_BINFO\n-\n-       TREE_SYMBOL_REFERENCED in\n-           IDENTIFIER_NODE\n-\n-       CLEANUP_EH_ONLY in\n-           TARGET_EXPR, WITH_CLEANUP_EXPR\n-\n-       TRY_CATCH_IS_CLEANUP in\n-           TRY_CATCH_EXPR\n-\n-       ASM_INPUT_P in\n-           ASM_EXPR\n-\n-       TYPE_REF_CAN_ALIAS_ALL in\n-           POINTER_TYPE, REFERENCE_TYPE\n-\n-       CASE_HIGH_SEEN in\n-           CASE_LABEL_EXPR\n-\n-       ENUM_IS_SCOPED in\n-\t   ENUMERAL_TYPE\n-\n-       TRANSACTION_EXPR_OUTER in\n-\t   TRANSACTION_EXPR\n-\n-   public_flag:\n-\n-       TREE_OVERFLOW in\n-           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n-\n-       TREE_PUBLIC in\n-           VAR_DECL, FUNCTION_DECL\n-           IDENTIFIER_NODE\n-\n-       ASM_VOLATILE_P in\n-           ASM_EXPR\n-\n-       CALL_EXPR_VA_ARG_PACK in\n-           CALL_EXPR\n-\n-       TYPE_CACHED_VALUES_P in\n-           all types\n-\n-       SAVE_EXPR_RESOLVED_P in\n-           SAVE_EXPR\n-\n-       OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE in\n-           OMP_CLAUSE_LASTPRIVATE\n-\n-       OMP_CLAUSE_PRIVATE_DEBUG in\n-           OMP_CLAUSE_PRIVATE\n-\n-       OMP_CLAUSE_LINEAR_NO_COPYIN in\n-\t   OMP_CLAUSE_LINEAR\n-\n-       TRANSACTION_EXPR_RELAXED in\n-\t   TRANSACTION_EXPR\n-\n-   private_flag:\n-\n-       TREE_PRIVATE in\n-           all decls\n-\n-       CALL_EXPR_RETURN_SLOT_OPT in\n-           CALL_EXPR\n-\n-       OMP_SECTION_LAST in\n-           OMP_SECTION\n-\n-       OMP_PARALLEL_COMBINED in\n-           OMP_PARALLEL\n-\n-       OMP_CLAUSE_PRIVATE_OUTER_REF in\n-\t   OMP_CLAUSE_PRIVATE\n-\n-       OMP_CLAUSE_LINEAR_NO_COPYOUT in\n-\t   OMP_CLAUSE_LINEAR\n-\n-       TYPE_REF_IS_RVALUE in\n-\t   REFERENCE_TYPE\n-\n-       ENUM_IS_OPAQUE in\n-\t   ENUMERAL_TYPE\n-\n-   protected_flag:\n-\n-       TREE_PROTECTED in\n-           BLOCK\n-           all decls\n-\n-       CALL_FROM_THUNK_P and\n-       CALL_ALLOCA_FOR_VAR_P in\n-           CALL_EXPR\n-\n-   side_effects_flag:\n-\n-       TREE_SIDE_EFFECTS in\n-           all expressions\n-           all decls\n-           all constants\n-\n-       FORCED_LABEL in\n-           LABEL_DECL\n-\n-   volatile_flag:\n-\n-       TREE_THIS_VOLATILE in\n-           all expressions\n-           all decls\n-\n-       TYPE_VOLATILE in\n-           all types\n-\n-   readonly_flag:\n-\n-       TREE_READONLY in\n-           all expressions\n-           all decls\n-\n-       TYPE_READONLY in\n-           all types\n-\n-   constant_flag:\n-\n-       TREE_CONSTANT in\n-           all expressions\n-           all decls\n-           all constants\n-\n-       TYPE_SIZES_GIMPLIFIED in\n-           all types\n-\n-   unsigned_flag:\n-\n-       TYPE_UNSIGNED in\n-           all types\n-\n-       DECL_UNSIGNED in\n-           all decls\n-\n-   asm_written_flag:\n-\n-       TREE_ASM_WRITTEN in\n-           VAR_DECL, FUNCTION_DECL, TYPE_DECL\n-           RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE\n-           BLOCK, STRING_CST\n-\n-       SSA_NAME_OCCURS_IN_ABNORMAL_PHI in\n-           SSA_NAME\n-\n-   used_flag:\n-\n-       TREE_USED in\n-           all expressions\n-           all decls\n-           IDENTIFIER_NODE\n-\n-   nothrow_flag:\n-\n-       TREE_NOTHROW in\n-           CALL_EXPR\n-           FUNCTION_DECL\n-\n-       TYPE_ALIGN_OK in\n-           all types\n-\n-       TREE_THIS_NOTRAP in\n-          INDIRECT_REF, MEM_REF, TARGET_MEM_REF, ARRAY_REF, ARRAY_RANGE_REF\n-\n-       SSA_NAME_IN_FREELIST in\n-          SSA_NAME\n-\n-   deprecated_flag:\n-\n-       TREE_DEPRECATED in\n-           all decls\n-\t   all types\n-\n-       IDENTIFIER_TRANSPARENT_ALIAS in\n-           IDENTIFIER_NODE\n-\n-   visited:\n-\n-       TREE_VISITED in\n-           all trees (used liberally by many passes)\n-\n-   saturating_flag:\n-\n-       TYPE_SATURATING in\n-           all types\n-\n-       VAR_DECL_IS_VIRTUAL_OPERAND in\n-\t   VAR_DECL\n-\n-   nowarning_flag:\n-\n-       TREE_NO_WARNING in\n-           all expressions\n-           all decls\n-\n-       TYPE_ARTIFICIAL in\n-           all types\n-\n-   default_def_flag:\n-\n-       TYPE_VECTOR_OPAQUE in\n-\t   VECTOR_TYPE\n-\n-       SSA_NAME_IS_DEFAULT_DEF in\n-           SSA_NAME\n-\n-       DECL_NONLOCAL_FRAME in\n-\t   VAR_DECL\n-\n-       TYPE_FINAL_P in\n-\t   RECORD_TYPE, UNION_TYPE and QUAL_UNION_TYPE\n-*/\n-\n-struct GTY(()) tree_typed {\n-  struct tree_base base;\n-  tree type;\n-};\n-\n-struct GTY(()) tree_common {\n-  struct tree_typed typed;\n-  tree chain;\n-};\n-\n-#undef DEFTREESTRUCT\n-#define DEFTREESTRUCT(ENUM, NAME) ENUM,\n-enum tree_node_structure_enum {\n-#include \"treestruct.def\"\n-  LAST_TS_ENUM\n-};\n-#undef DEFTREESTRUCT\n \n /* Define accessors for the fields that all tree nodes have\n    (though some fields are not used for all kinds of nodes).  */\n@@ -1439,70 +884,28 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \t== (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n        && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n \n-struct GTY(()) tree_int_cst {\n-  struct tree_typed typed;\n-  double_int int_cst;\n-};\n-\n-/* In a REAL_CST node.  struct real_value is an opaque entity, with\n-   manipulators defined in real.h.  We don't want tree.h depending on\n-   real.h and transitively on tm.h.  */\n-struct real_value;\n-\n #define TREE_REAL_CST_PTR(NODE) (REAL_CST_CHECK (NODE)->real_cst.real_cst_ptr)\n #define TREE_REAL_CST(NODE) (*TREE_REAL_CST_PTR (NODE))\n \n-struct GTY(()) tree_real_cst {\n-  struct tree_typed typed;\n-  struct real_value * real_cst_ptr;\n-};\n-\n-/* In a FIXED_CST node.  */\n-struct fixed_value;\n-\n #define TREE_FIXED_CST_PTR(NODE) \\\n   (FIXED_CST_CHECK (NODE)->fixed_cst.fixed_cst_ptr)\n #define TREE_FIXED_CST(NODE) (*TREE_FIXED_CST_PTR (NODE))\n \n-struct GTY(()) tree_fixed_cst {\n-  struct tree_typed typed;\n-  struct fixed_value * fixed_cst_ptr;\n-};\n-\n /* In a STRING_CST */\n /* In C terms, this is sizeof, not strlen.  */\n #define TREE_STRING_LENGTH(NODE) (STRING_CST_CHECK (NODE)->string.length)\n #define TREE_STRING_POINTER(NODE) \\\n   ((const char *)(STRING_CST_CHECK (NODE)->string.str))\n \n-struct GTY(()) tree_string {\n-  struct tree_typed typed;\n-  int length;\n-  char str[1];\n-};\n-\n /* In a COMPLEX_CST node.  */\n #define TREE_REALPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.real)\n #define TREE_IMAGPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.imag)\n \n-struct GTY(()) tree_complex {\n-  struct tree_typed typed;\n-  tree real;\n-  tree imag;\n-};\n-\n /* In a VECTOR_CST node.  */\n #define VECTOR_CST_NELTS(NODE) (TYPE_VECTOR_SUBPARTS (TREE_TYPE (NODE)))\n #define VECTOR_CST_ELTS(NODE) (VECTOR_CST_CHECK (NODE)->vector.elts)\n #define VECTOR_CST_ELT(NODE,IDX) (VECTOR_CST_CHECK (NODE)->vector.elts[IDX])\n \n-struct GTY(()) tree_vector {\n-  struct tree_typed typed;\n-  tree GTY ((length (\"TYPE_VECTOR_SUBPARTS (TREE_TYPE ((tree)&%h))\"))) elts[1];\n-};\n-\f\n-#include \"symtab.h\"\n-\n /* Define fields and accessors for some special-purpose tree nodes.  */\n \n #define IDENTIFIER_LENGTH(NODE) \\\n@@ -1519,33 +922,17 @@ struct GTY(()) tree_vector {\n   ((tree) ((char *) (NODE) - sizeof (struct tree_common)))\n #define GCC_IDENT_TO_HT_IDENT(NODE) (&((struct tree_identifier *) (NODE))->id)\n \n-struct GTY(()) tree_identifier {\n-  struct tree_common common;\n-  struct ht_identifier id;\n-};\n-\n /* In a TREE_LIST node.  */\n #define TREE_PURPOSE(NODE) (TREE_LIST_CHECK (NODE)->list.purpose)\n #define TREE_VALUE(NODE) (TREE_LIST_CHECK (NODE)->list.value)\n \n-struct GTY(()) tree_list {\n-  struct tree_common common;\n-  tree purpose;\n-  tree value;\n-};\n-\n /* In a TREE_VEC node.  */\n #define TREE_VEC_LENGTH(NODE) (TREE_VEC_CHECK (NODE)->base.u.length)\n #define TREE_VEC_END(NODE) \\\n   ((void) TREE_VEC_CHECK (NODE), &((NODE)->vec.a[(NODE)->vec.base.u.length]))\n \n #define TREE_VEC_ELT(NODE,I) TREE_VEC_ELT_CHECK (NODE, I)\n \n-struct GTY(()) tree_vec {\n-  struct tree_common common;\n-  tree GTY ((length (\"TREE_VEC_LENGTH ((tree)&%h)\"))) a[1];\n-};\n-\n /* In a CONSTRUCTOR node.  */\n #define CONSTRUCTOR_ELTS(NODE) (CONSTRUCTOR_CHECK (NODE)->constructor.elts)\n #define CONSTRUCTOR_ELT(NODE,IDX) \\\n@@ -1594,21 +981,6 @@ struct GTY(()) tree_vec {\n #define TREE_CLOBBER_P(NODE) \\\n   (TREE_CODE (NODE) == CONSTRUCTOR && TREE_THIS_VOLATILE (NODE))\n \n-/* A single element of a CONSTRUCTOR. VALUE holds the actual value of the\n-   element. INDEX can optionally design the position of VALUE: in arrays,\n-   it is the index where VALUE has to be placed; in structures, it is the\n-   FIELD_DECL of the member.  */\n-typedef struct GTY(()) constructor_elt_d {\n-  tree index;\n-  tree value;\n-} constructor_elt;\n-\n-\n-struct GTY(()) tree_constructor {\n-  struct tree_typed typed;\n-  vec<constructor_elt, va_gc> *elts;\n-};\n-\n /* Define fields and accessors for some nodes that represent expressions.  */\n \n /* Nonzero if NODE is an empty statement (NOP_EXPR <0>).  */\n@@ -1907,38 +1279,12 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE__SIMDUID__DECL(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__SIMDUID_), 0)\n \n-enum omp_clause_schedule_kind\n-{\n-  OMP_CLAUSE_SCHEDULE_STATIC,\n-  OMP_CLAUSE_SCHEDULE_DYNAMIC,\n-  OMP_CLAUSE_SCHEDULE_GUIDED,\n-  OMP_CLAUSE_SCHEDULE_AUTO,\n-  OMP_CLAUSE_SCHEDULE_RUNTIME\n-};\n-\n #define OMP_CLAUSE_SCHEDULE_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE)->omp_clause.subcode.schedule_kind)\n \n-enum omp_clause_default_kind\n-{\n-  OMP_CLAUSE_DEFAULT_UNSPECIFIED,\n-  OMP_CLAUSE_DEFAULT_SHARED,\n-  OMP_CLAUSE_DEFAULT_NONE,\n-  OMP_CLAUSE_DEFAULT_PRIVATE,\n-  OMP_CLAUSE_DEFAULT_FIRSTPRIVATE\n-};\n-\n #define OMP_CLAUSE_DEFAULT_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEFAULT)->omp_clause.subcode.default_kind)\n \n-struct GTY(()) tree_exp {\n-  struct tree_typed typed;\n-  location_t locus;\n-  tree GTY ((special (\"tree_exp\"),\n-\t     desc (\"TREE_CODE ((tree) &%0)\")))\n-    operands[1];\n-};\n-\f\n /* SSA_NAME accessors.  */\n \n /* Returns the IDENTIFIER_NODE giving the SSA name a name or NULL_TREE\n@@ -1992,51 +1338,9 @@ struct GTY(()) tree_exp {\n #define SSA_NAME_PTR_INFO(N) \\\n     SSA_NAME_CHECK (N)->ssa_name.ptr_info\n \n-/* Defined in tree-flow.h.  */\n-struct ptr_info_def;\n-\n-/* Immediate use linking structure.  This structure is used for maintaining\n-   a doubly linked list of uses of an SSA_NAME.  */\n-typedef struct GTY(()) ssa_use_operand_d {\n-  struct ssa_use_operand_d* GTY((skip(\"\"))) prev;\n-  struct ssa_use_operand_d* GTY((skip(\"\"))) next;\n-  /* Immediate uses for a given SSA name are maintained as a cyclic\n-     list.  To recognize the root of this list, the location field\n-     needs to point to the original SSA name.  Since statements and\n-     SSA names are of different data types, we need this union.  See\n-     the explanation in struct immediate_use_iterator_d.  */\n-  union { gimple stmt; tree ssa_name; } GTY((skip(\"\"))) loc;\n-  tree *GTY((skip(\"\"))) use;\n-} ssa_use_operand_t;\n-\n /* Return the immediate_use information for an SSA_NAME. */\n #define SSA_NAME_IMM_USE_NODE(NODE) SSA_NAME_CHECK (NODE)->ssa_name.imm_uses\n \n-struct GTY(()) tree_ssa_name {\n-  struct tree_typed typed;\n-\n-  /* _DECL wrapped by this SSA name.  */\n-  tree var;\n-\n-  /* Statement that defines this SSA name.  */\n-  gimple def_stmt;\n-\n-  /* Pointer attributes used for alias analysis.  */\n-  struct ptr_info_def *ptr_info;\n-\n-  /* Immediate uses list for this SSA_NAME.  */\n-  struct ssa_use_operand_d imm_uses;\n-};\n-\f\n-struct GTY(()) phi_arg_d {\n-  /* imm_use MUST be the first element in struct because we do some\n-     pointer arithmetic with it.  See phi_arg_index_from_use.  */\n-  struct ssa_use_operand_d imm_use;\n-  tree def;\n-  location_t locus;\n-};\n-\n-\f\n #define OMP_CLAUSE_CODE(NODE)\t\t\t\t\t\\\n \t(OMP_CLAUSE_CHECK (NODE))->omp_clause.code\n \n@@ -2049,25 +1353,6 @@ struct GTY(()) phi_arg_d {\n #define OMP_CLAUSE_OPERAND(NODE, I)\t\t\t\t\\\n \tOMP_CLAUSE_ELT_CHECK (NODE, I)\n \n-struct GTY(()) tree_omp_clause {\n-  struct tree_common common;\n-  location_t locus;\n-  enum omp_clause_code code;\n-  union omp_clause_subcode {\n-    enum omp_clause_default_kind  default_kind;\n-    enum omp_clause_schedule_kind schedule_kind;\n-    enum tree_code                reduction_code;\n-  } GTY ((skip)) subcode;\n-\n-  /* The gimplification of OMP_CLAUSE_REDUCTION_{INIT,MERGE} for omp-low's\n-     usage.  */\n-  gimple_seq gimple_reduction_init;\n-  gimple_seq gimple_reduction_merge;\n-\n-  tree GTY ((length (\"omp_clause_num_ops[OMP_CLAUSE_CODE ((tree)&%h)]\"))) ops[1];\n-};\n-\f\n-\n /* In a BLOCK node.  */\n #define BLOCK_VARS(NODE) (BLOCK_CHECK (NODE)->block.vars)\n #define BLOCK_NONLOCALIZED_VARS(NODE) \\\n@@ -2120,25 +1405,6 @@ struct GTY(()) tree_omp_clause {\n \n #define BLOCK_SOURCE_LOCATION(NODE) (BLOCK_CHECK (NODE)->block.locus)\n \n-struct GTY(()) tree_block {\n-  struct tree_base base;\n-  tree chain;\n-\n-  unsigned abstract_flag : 1;\n-  unsigned block_num : 31;\n-\n-  location_t locus;\n-\n-  tree vars;\n-  vec<tree, va_gc> *nonlocalized_vars;\n-\n-  tree subblocks;\n-  tree supercontext;\n-  tree abstract_origin;\n-  tree fragment_origin;\n-  tree fragment_chain;\n-};\n-\f\n /* Define fields and accessors for nodes representing data types.  */\n \n /* See tree.def for documentation of the use of these fields.\n@@ -2258,17 +1524,6 @@ extern enum machine_mode vector_type_mode (const_tree);\n /* The address space the type is in.  */\n #define TYPE_ADDR_SPACE(NODE) (TYPE_CHECK (NODE)->base.u.bits.address_space)\n \n-/* There is a TYPE_QUAL value for each type qualifier.  They can be\n-   combined by bitwise-or to form the complete set of qualifiers for a\n-   type.  */\n-enum cv_qualifier\n-  {\n-    TYPE_UNQUALIFIED   = 0x0,\n-    TYPE_QUAL_CONST    = 0x1,\n-    TYPE_QUAL_VOLATILE = 0x2,\n-    TYPE_QUAL_RESTRICT = 0x4\n-  };\n-\n /* Encode/decode the named memory support as part of the qualifier.  If more\n    than 8 qualifiers are added, these macros need to be adjusted.  */\n #define ENCODE_QUAL_ADDR_SPACE(NUM) ((NUM & 0xFF) << 8)\n@@ -2388,58 +1643,9 @@ enum cv_qualifier\n #define TYPE_SYMTAB_IS_POINTER (1)\n #define TYPE_SYMTAB_IS_DIE (2)\n \n-struct die_struct;\n-\n-struct GTY(()) tree_type_common {\n-  struct tree_common common;\n-  tree size;\n-  tree size_unit;\n-  tree attributes;\n-  unsigned int uid;\n-\n-  unsigned int precision : 10;\n-  unsigned no_force_blk_flag : 1;\n-  unsigned needs_constructing_flag : 1;\n-  unsigned transparent_aggr_flag : 1;\n-  unsigned restrict_flag : 1;\n-  unsigned contains_placeholder_bits : 2;\n-\n-  ENUM_BITFIELD(machine_mode) mode : 8;\n-\n-  unsigned string_flag : 1;\n-  unsigned lang_flag_0 : 1;\n-  unsigned lang_flag_1 : 1;\n-  unsigned lang_flag_2 : 1;\n-  unsigned lang_flag_3 : 1;\n-  unsigned lang_flag_4 : 1;\n-  unsigned lang_flag_5 : 1;\n-  unsigned lang_flag_6 : 1;\n-\n-  unsigned int align;\n-  alias_set_type alias_set;\n-  tree pointer_to;\n-  tree reference_to;\n-  union tree_type_symtab {\n-    int GTY ((tag (\"TYPE_SYMTAB_IS_ADDRESS\"))) address;\n-    const char * GTY ((tag (\"TYPE_SYMTAB_IS_POINTER\"))) pointer;\n-    struct die_struct * GTY ((tag (\"TYPE_SYMTAB_IS_DIE\"))) die;\n-  } GTY ((desc (\"debug_hooks->tree_type_symtab_field\"))) symtab;\n-  tree name;\n-  tree next_variant;\n-  tree main_variant;\n-  tree context;\n-  tree canonical;\n-};\n-\n #define TYPE_LANG_SPECIFIC(NODE) \\\n   (TYPE_CHECK (NODE)->type_with_lang_specific.lang_specific)\n \n-struct GTY(()) tree_type_with_lang_specific {\n-  struct tree_type_common common;\n-  /* Points to a structure whose details depend on the language in use.  */\n-  struct lang_type *lang_specific;\n-};\n-\n #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type_non_common.values)\n #define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type_non_common.values)\n #define TYPE_FIELDS(NODE) \\\n@@ -2482,14 +1688,6 @@ struct GTY(()) tree_type_with_lang_specific {\n #define TYPE_LANG_SLOT_1(NODE) \\\n   (NOT_RECORD_OR_UNION_CHECK(NODE)->type_non_common.binfo)\n \n-struct GTY(()) tree_type_non_common {\n-  struct tree_type_with_lang_specific with_lang_specific;\n-  tree values;\n-  tree minval;\n-  tree maxval;\n-  tree binfo;\n-};\n-\f\n /* Define accessor macros for information about type inheritance\n    and basetypes.\n \n@@ -2593,23 +1791,7 @@ struct GTY(()) tree_type_non_common {\n #define BINFO_INHERITANCE_CHAIN(NODE) \\\n \t(TREE_BINFO_CHECK(NODE)->binfo.inheritance)\n \n-struct GTY (()) tree_binfo {\n-  struct tree_common common;\n \n-  tree offset;\n-  tree vtable;\n-  tree virtuals;\n-  tree vptr_field;\n-  vec<tree, va_gc> *base_accesses;\n-  tree inheritance;\n-\n-  tree vtt_subvtt;\n-  tree vtt_vptr;\n-\n-  vec<tree, va_gc> base_binfos;\n-};\n-\n-\f\n /* Define fields and accessors for nodes representing declared names.  */\n \n /* Nonzero if DECL represents an SSA name or a variable that can possibly\n@@ -2621,21 +1803,6 @@ struct GTY (()) tree_binfo {\n \t || TREE_CODE (DECL) == SSA_NAME)\n \n \n-\n-/* Enumerate visibility settings.  */\n-#ifndef SYMBOL_VISIBILITY_DEFINED\n-#define SYMBOL_VISIBILITY_DEFINED\n-enum symbol_visibility\n-{\n-  VISIBILITY_DEFAULT,\n-  VISIBILITY_PROTECTED,\n-  VISIBILITY_HIDDEN,\n-  VISIBILITY_INTERNAL\n-};\n-#endif\n-\n-struct function;\n-\n #define DECL_CHAIN(NODE) (TREE_CHAIN (DECL_MINIMAL_CHECK (NODE)))\n \n /* This is the name of the object as written by the user.\n@@ -2690,15 +1857,6 @@ struct function;\n /* If nonzero, decl's name shouldn't be emitted into debug info.  */\n #define DECL_NAMELESS(NODE) (DECL_MINIMAL_CHECK (NODE)->base.u.bits.nameless_flag)\n \n-struct GTY(()) tree_decl_minimal {\n-  struct tree_common common;\n-  location_t locus;\n-  unsigned int uid;\n-  tree name;\n-  tree context;\n-};\n-\n-\n /* For any sort of a ..._DECL node, this points to the original (abstract)\n    decl node which this decl is an inlined/cloned instance of, or else it\n    is NULL indicating that this decl is not an instance of some other decl.\n@@ -2856,72 +2014,6 @@ struct GTY(()) tree_decl_minimal {\n #define DECL_GIMPLE_REG_P(DECL) \\\n   DECL_COMMON_CHECK (DECL)->decl_common.gimple_reg_flag\n \n-struct GTY(()) tree_decl_common {\n-  struct tree_decl_minimal common;\n-  tree size;\n-\n-  ENUM_BITFIELD(machine_mode) mode : 8;\n-\n-  unsigned nonlocal_flag : 1;\n-  unsigned virtual_flag : 1;\n-  unsigned ignored_flag : 1;\n-  unsigned abstract_flag : 1;\n-  unsigned artificial_flag : 1;\n-  unsigned preserve_flag: 1;\n-  unsigned debug_expr_is_from : 1;\n-\n-  unsigned lang_flag_0 : 1;\n-  unsigned lang_flag_1 : 1;\n-  unsigned lang_flag_2 : 1;\n-  unsigned lang_flag_3 : 1;\n-  unsigned lang_flag_4 : 1;\n-  unsigned lang_flag_5 : 1;\n-  unsigned lang_flag_6 : 1;\n-  unsigned lang_flag_7 : 1;\n-  unsigned lang_flag_8 : 1;\n-\n-  /* In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */\n-  unsigned decl_flag_0 : 1;\n-  /* In FIELD_DECL, this is DECL_BIT_FIELD\n-     In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL.\n-     In TYPE_DECL, this is TYPE_DECL_SUPPRESS_DEBUG.  */\n-  unsigned decl_flag_1 : 1;\n-  /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P\n-     In VAR_DECL, PARM_DECL and RESULT_DECL, this is\n-     DECL_HAS_VALUE_EXPR_P.  */\n-  unsigned decl_flag_2 : 1;\n-  /* 1 bit unused.  */\n-  unsigned decl_flag_3 : 1;\n-  /* Logically, these two would go in a theoretical base shared by var and\n-     parm decl. */\n-  unsigned gimple_reg_flag : 1;\n-  /* In VAR_DECL, PARM_DECL and RESULT_DECL, this is DECL_BY_REFERENCE.  */\n-  unsigned decl_by_reference_flag : 1;\n-  /* In a VAR_DECL and PARM_DECL, this is DECL_READ_P.  */\n-  unsigned decl_read_flag : 1;\n-  /* In a VAR_DECL or RESULT_DECL, this is DECL_NONSHAREABLE.  */\n-  unsigned decl_nonshareable_flag : 1;\n-\n-  /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */\n-  unsigned int off_align : 8;\n-\n-  /* 24 bits unused.  */\n-\n-  /* DECL_ALIGN.  It should have the same size as TYPE_ALIGN.  */\n-  unsigned int align;\n-\n-  /* UID for points-to sets, stable over copying from inlining.  */\n-  unsigned int pt_uid;\n-\n-  tree size_unit;\n-  tree initial;\n-  tree attributes;\n-  tree abstract_origin;\n-\n-  /* Points to a structure whose details depend on the language in use.  */\n-  struct lang_decl *lang_specific;\n-};\n-\n extern tree decl_value_expr_lookup (tree);\n extern void decl_value_expr_insert (tree, tree);\n \n@@ -2978,11 +2070,6 @@ extern void decl_value_expr_insert (tree, tree);\n /* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.  */\n #define DECL_REGISTER(NODE) (DECL_WRTL_CHECK (NODE)->decl_common.decl_flag_0)\n \n-struct GTY(()) tree_decl_with_rtl {\n-  struct tree_decl_common common;\n-  rtx rtl;\n-};\n-\n /* In a FIELD_DECL, this is the field position, counting in bytes, of the\n    DECL_OFFSET_ALIGN-bit-sized word containing the bit closest to the beginning\n    of the structure.  */\n@@ -3051,16 +2138,6 @@ struct GTY(()) tree_decl_with_rtl {\n #define DECL_NONADDRESSABLE_P(NODE) \\\n   (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_2)\n \n-struct GTY(()) tree_field_decl {\n-  struct tree_decl_common common;\n-\n-  tree offset;\n-  tree bit_field_type;\n-  tree qualifier;\n-  tree bit_offset;\n-  tree fcontext;\n-};\n-\n /* A numeric unique identifier for a LABEL_DECL.  The UID allocation is\n    dense, unique within any one function, and may be used to index arrays.\n    If the value is -1, then no UID has been assigned.  */\n@@ -3072,20 +2149,6 @@ struct GTY(()) tree_field_decl {\n #define EH_LANDING_PAD_NR(NODE) \\\n   (LABEL_DECL_CHECK (NODE)->label_decl.eh_landing_pad_nr)\n \n-struct GTY(()) tree_label_decl {\n-  struct tree_decl_with_rtl common;\n-  int label_decl_uid;\n-  int eh_landing_pad_nr;\n-};\n-\n-struct GTY(()) tree_result_decl {\n-  struct tree_decl_with_rtl common;\n-};\n-\n-struct GTY(()) tree_const_decl {\n-  struct tree_decl_common common;\n-};\n-\n /* For a PARM_DECL, records the data type used to pass the argument,\n    which may be different from the type seen in the program.  */\n #define DECL_ARG_TYPE(NODE) (PARM_DECL_CHECK (NODE)->decl_common.initial)\n@@ -3095,12 +2158,6 @@ struct GTY(()) tree_const_decl {\n #define DECL_INCOMING_RTL(NODE) \\\n   (PARM_DECL_CHECK (NODE)->parm_decl.incoming_rtl)\n \n-struct GTY(()) tree_parm_decl {\n-  struct tree_decl_with_rtl common;\n-  rtx incoming_rtl;\n-};\n-\n-\n /* Nonzero for a given ..._DECL node means that no warnings should be\n    generated just because this node is unused.  */\n #define DECL_IN_SYSTEM_HEADER(NODE) \\\n@@ -3233,46 +2290,9 @@ struct GTY(()) tree_parm_decl {\n #define DECL_HAS_IMPLICIT_SECTION_NAME_P(NODE) \\\n   (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.implicit_section_name_p)\n \n-struct GTY(()) tree_decl_with_vis {\n- struct tree_decl_with_rtl common;\n- tree assembler_name;\n- tree section_name;\n- tree comdat_group;\n-\n- /* Belong to VAR_DECL exclusively.  */\n- unsigned defer_output : 1;\n- unsigned hard_register : 1;\n- unsigned common_flag : 1;\n- unsigned in_text_section : 1;\n- unsigned in_constant_pool : 1;\n- unsigned dllimport_flag : 1;\n- /* Don't belong to VAR_DECL exclusively.  */\n- unsigned weak_flag : 1;\n- /* When SECTION_NAME is implied by -ffunction-section.  */\n- unsigned implicit_section_name_p : 1;\n-\n- unsigned seen_in_bind_expr : 1;\n- unsigned comdat_flag : 1;\n- ENUM_BITFIELD(symbol_visibility) visibility : 2;\n- unsigned visibility_specified : 1;\n- /* Belongs to VAR_DECL exclusively.  */\n- ENUM_BITFIELD(tls_model) tls_model : 3;\n-\n- /* Belong to FUNCTION_DECL exclusively.  */\n- unsigned init_priority_p : 1;\n- /* Used by C++ only.  Might become a generic decl flag.  */\n- unsigned shadowed_for_var_p : 1;\n- /* Belong to FUNCTION_DECL exclusively.  */\n- unsigned cxx_constructor : 1;\n- /* Belong to FUNCTION_DECL exclusively.  */\n- unsigned cxx_destructor : 1;\n- /* Belong to FUNCTION_DECL exclusively.  */\n- unsigned final : 1;\n- /* 11 unused bits. */\n-};\n-\n extern tree decl_debug_expr_lookup (tree);\n extern void decl_debug_expr_insert (tree, tree);\n+\n /* For VAR_DECL, this is set to an expression that it was split from.  */\n #define DECL_HAS_DEBUG_EXPR_P(NODE) \\\n   (VAR_DECL_CHECK (NODE)->decl_common.debug_expr_is_from)\n@@ -3282,9 +2302,6 @@ extern void decl_debug_expr_insert (tree, tree);\n #define SET_DECL_DEBUG_EXPR(NODE, VAL) \\\n   (decl_debug_expr_insert (VAR_DECL_CHECK (NODE), VAL))\n \n-/* An initialization priority.  */\n-typedef unsigned short priority_type;\n-\n extern priority_type decl_init_priority_lookup (tree);\n extern priority_type decl_fini_priority_lookup (tree);\n extern void decl_init_priority_insert (tree, priority_type);\n@@ -3324,11 +2341,6 @@ extern void decl_fini_priority_insert (tree, priority_type);\n #define DECL_NONLOCAL_FRAME(NODE)  \\\n   (VAR_DECL_CHECK (NODE)->base.default_def_flag)\n \n-struct GTY(()) tree_var_decl {\n-  struct tree_decl_with_vis common;\n-};\n-\n-\n /* This field is used to reference anything in decl.result and is meant only\n    for use by the garbage collector.  */\n #define DECL_RESULT_FLD(NODE) \\\n@@ -3345,19 +2357,6 @@ struct GTY(()) tree_var_decl {\n #define DECL_VINDEX(NODE) \\\n   (DECL_NON_COMMON_CHECK (NODE)->decl_non_common.vindex)\n \n-struct GTY(())\n- tree_decl_non_common {\n-  struct tree_decl_with_vis common;\n-  /* C++ uses this in namespaces.  */\n-  tree saved_tree;\n-  /* C++ uses this in templates.  */\n-  tree arguments;\n-  /* Almost all FE's use this.  */\n-  tree result;\n-  /* C++ uses this in namespaces and function_decls.  */\n-  tree vindex;\n-};\n-\n /* In FUNCTION_DECL, holds the decl for the return value.  */\n #define DECL_RESULT(NODE) (FUNCTION_DECL_CHECK (NODE)->decl_non_common.result)\n \n@@ -3540,66 +2539,12 @@ extern vec<tree, va_gc> **decl_debug_args_insert (tree);\n    FUNCTION_DECL from non_common, or inherit non_common from FUNCTION_DECL,\n    which seemed a bit strange.  */\n \n-struct GTY(()) tree_function_decl {\n-  struct tree_decl_non_common common;\n-\n-  struct function *f;\n-\n-  /* The personality function. Used for stack unwinding. */\n-  tree personality;\n-\n-  /* Function specific options that are used by this function.  */\n-  tree function_specific_target;\t/* target options */\n-  tree function_specific_optimization;\t/* optimization options */\n-\n-  /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n-     DECL_FUNCTION_CODE.  Otherwise unused.\n-     ???  The bitfield needs to be able to hold all target function\n-\t  codes as well.  */\n-  ENUM_BITFIELD(built_in_function) function_code : 11;\n-  ENUM_BITFIELD(built_in_class) built_in_class : 2;\n-\n-  unsigned static_ctor_flag : 1;\n-  unsigned static_dtor_flag : 1;\n-  unsigned uninlinable : 1;\n-\n-  unsigned possibly_inlined : 1;\n-  unsigned novops_flag : 1;\n-  unsigned returns_twice_flag : 1;\n-  unsigned malloc_flag : 1;\n-  unsigned operator_new_flag : 1;\n-  unsigned declared_inline_flag : 1;\n-  unsigned regdecl_flag : 1;\n-  unsigned no_inline_warning_flag : 1;\n-\n-  unsigned no_instrument_function_entry_exit : 1;\n-  unsigned no_limit_stack : 1;\n-  unsigned disregard_inline_limits : 1;\n-  unsigned pure_flag : 1;\n-  unsigned looping_const_or_pure_flag : 1;\n-  unsigned has_debug_args_flag : 1;\n-  unsigned tm_clone_flag : 1;\n-  unsigned versioned_function : 1;\n-  /* No bits left.  */\n-};\n-\n /* The source language of the translation-unit.  */\n #define TRANSLATION_UNIT_LANGUAGE(NODE) \\\n   (TRANSLATION_UNIT_DECL_CHECK (NODE)->translation_unit_decl.language)\n \n /* TRANSLATION_UNIT_DECL inherits from DECL_MINIMAL.  */\n \n-struct GTY(()) tree_translation_unit_decl {\n-  struct tree_decl_common common;\n-  /* Source language of this translation unit.  Used for DWARF output.  */\n-  const char * GTY((skip(\"\"))) language;\n-  /* TODO: Non-optimization used to build this translation unit.  */\n-  /* TODO: Root of a partial DWARF tree for global types and decls.  */\n-};\n-\n-/* A vector of all translation-units.  */\n-extern GTY (()) vec<tree, va_gc> *all_translation_units;\n-\n /* For a TYPE_DECL, holds the \"original\" type.  (TREE_TYPE has the copy.) */\n #define DECL_ORIGINAL_TYPE(NODE) \\\n   (TYPE_DECL_CHECK (NODE)->decl_non_common.result)\n@@ -3615,11 +2560,6 @@ extern GTY (()) vec<tree, va_gc> *all_translation_units;\n #define IMPORTED_DECL_ASSOCIATED_DECL(NODE) \\\n (DECL_INITIAL (IMPORTED_DECL_CHECK (NODE)))\n \n-struct GTY(()) tree_type_decl {\n-  struct tree_decl_non_common common;\n-\n-};\n-\f\n /* A STATEMENT_LIST chains statements together in GENERIC and GIMPLE.\n    To reduce overhead, the nodes containing the statements are not trees.\n    This avoids the overhead of tree_common on all linked list elements.\n@@ -3631,38 +2571,6 @@ struct GTY(()) tree_type_decl {\n #define STATEMENT_LIST_TAIL(NODE) \\\n   (STATEMENT_LIST_CHECK (NODE)->stmt_list.tail)\n \n-struct GTY ((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) tree_statement_list_node\n- {\n-  struct tree_statement_list_node *prev;\n-  struct tree_statement_list_node *next;\n-  tree stmt;\n-};\n-\n-struct GTY(()) tree_statement_list\n- {\n-  struct tree_typed typed;\n-  struct tree_statement_list_node *head;\n-  struct tree_statement_list_node *tail;\n-};\n-\n-\n-/* Optimization options used by a function.  */\n-\n-struct GTY(()) tree_optimization_option {\n-  struct tree_common common;\n-\n-  /* The optimization options used by the user.  */\n-  struct cl_optimization opts;\n-\n-  /* Target optabs for this set of optimization options.  This is of\n-     type `struct target_optabs *'.  */\n-  unsigned char *GTY ((atomic)) optabs;\n-\n-  /* The value of this_target_optabs against which the optabs above were\n-     generated.  */\n-  struct target_optabs *GTY ((skip)) base_optabs;\n-};\n-\n #define TREE_OPTIMIZATION(NODE) \\\n   (&OPTIMIZATION_NODE_CHECK (NODE)->optimization.opts)\n \n@@ -3677,71 +2585,12 @@ extern tree build_optimization_node (void);\n \n extern void init_tree_optimization_optabs (tree);\n \n-/* Target options used by a function.  */\n-\n-struct GTY(()) tree_target_option {\n-  struct tree_common common;\n-\n-  /* The optimization options used by the user.  */\n-  struct cl_target_option opts;\n-};\n-\n #define TREE_TARGET_OPTION(NODE) \\\n   (&TARGET_OPTION_NODE_CHECK (NODE)->target_option.opts)\n \n /* Return a tree node that encapsulates the current target options.  */\n extern tree build_target_option_node (void);\n \n-\f\n-/* Define the overall contents of a tree node.\n-   It may be any of the structures declared above\n-   for various types of node.  */\n-\n-union GTY ((ptr_alias (union lang_tree_node),\n-\t    desc (\"tree_node_structure (&%h)\"), variable_size)) tree_node {\n-  struct tree_base GTY ((tag (\"TS_BASE\"))) base;\n-  struct tree_typed GTY ((tag (\"TS_TYPED\"))) typed;\n-  struct tree_common GTY ((tag (\"TS_COMMON\"))) common;\n-  struct tree_int_cst GTY ((tag (\"TS_INT_CST\"))) int_cst;\n-  struct tree_real_cst GTY ((tag (\"TS_REAL_CST\"))) real_cst;\n-  struct tree_fixed_cst GTY ((tag (\"TS_FIXED_CST\"))) fixed_cst;\n-  struct tree_vector GTY ((tag (\"TS_VECTOR\"))) vector;\n-  struct tree_string GTY ((tag (\"TS_STRING\"))) string;\n-  struct tree_complex GTY ((tag (\"TS_COMPLEX\"))) complex;\n-  struct tree_identifier GTY ((tag (\"TS_IDENTIFIER\"))) identifier;\n-  struct tree_decl_minimal GTY((tag (\"TS_DECL_MINIMAL\"))) decl_minimal;\n-  struct tree_decl_common GTY ((tag (\"TS_DECL_COMMON\"))) decl_common;\n-  struct tree_decl_with_rtl GTY ((tag (\"TS_DECL_WRTL\"))) decl_with_rtl;\n-  struct tree_decl_non_common  GTY ((tag (\"TS_DECL_NON_COMMON\"))) decl_non_common;\n-  struct tree_parm_decl  GTY  ((tag (\"TS_PARM_DECL\"))) parm_decl;\n-  struct tree_decl_with_vis GTY ((tag (\"TS_DECL_WITH_VIS\"))) decl_with_vis;\n-  struct tree_var_decl GTY ((tag (\"TS_VAR_DECL\"))) var_decl;\n-  struct tree_field_decl GTY ((tag (\"TS_FIELD_DECL\"))) field_decl;\n-  struct tree_label_decl GTY ((tag (\"TS_LABEL_DECL\"))) label_decl;\n-  struct tree_result_decl GTY ((tag (\"TS_RESULT_DECL\"))) result_decl;\n-  struct tree_const_decl GTY ((tag (\"TS_CONST_DECL\"))) const_decl;\n-  struct tree_type_decl GTY ((tag (\"TS_TYPE_DECL\"))) type_decl;\n-  struct tree_function_decl GTY ((tag (\"TS_FUNCTION_DECL\"))) function_decl;\n-  struct tree_translation_unit_decl GTY ((tag (\"TS_TRANSLATION_UNIT_DECL\")))\n-    translation_unit_decl;\n-  struct tree_type_common GTY ((tag (\"TS_TYPE_COMMON\"))) type_common;\n-  struct tree_type_with_lang_specific GTY ((tag (\"TS_TYPE_WITH_LANG_SPECIFIC\")))\n-    type_with_lang_specific;\n-  struct tree_type_non_common GTY ((tag (\"TS_TYPE_NON_COMMON\")))\n-    type_non_common;\n-  struct tree_list GTY ((tag (\"TS_LIST\"))) list;\n-  struct tree_vec GTY ((tag (\"TS_VEC\"))) vec;\n-  struct tree_exp GTY ((tag (\"TS_EXP\"))) exp;\n-  struct tree_ssa_name GTY ((tag (\"TS_SSA_NAME\"))) ssa_name;\n-  struct tree_block GTY ((tag (\"TS_BLOCK\"))) block;\n-  struct tree_binfo GTY ((tag (\"TS_BINFO\"))) binfo;\n-  struct tree_statement_list GTY ((tag (\"TS_STATEMENT_LIST\"))) stmt_list;\n-  struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n-  struct tree_omp_clause GTY ((tag (\"TS_OMP_CLAUSE\"))) omp_clause;\n-  struct tree_optimization_option GTY ((tag (\"TS_OPTIMIZATION\"))) optimization;\n-  struct tree_target_option GTY ((tag (\"TS_TARGET_OPTION\"))) target_option;\n-};\n-\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n inline tree\n@@ -4221,167 +3070,6 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n \n #endif\n \n-\f\n-/* Standard named or nameless data types of the C compiler.  */\n-\n-enum tree_index\n-{\n-  TI_ERROR_MARK,\n-  TI_INTQI_TYPE,\n-  TI_INTHI_TYPE,\n-  TI_INTSI_TYPE,\n-  TI_INTDI_TYPE,\n-  TI_INTTI_TYPE,\n-\n-  TI_UINTQI_TYPE,\n-  TI_UINTHI_TYPE,\n-  TI_UINTSI_TYPE,\n-  TI_UINTDI_TYPE,\n-  TI_UINTTI_TYPE,\n-\n-  TI_UINT16_TYPE,\n-  TI_UINT32_TYPE,\n-  TI_UINT64_TYPE,\n-\n-  TI_INTEGER_ZERO,\n-  TI_INTEGER_ONE,\n-  TI_INTEGER_THREE,\n-  TI_INTEGER_MINUS_ONE,\n-  TI_NULL_POINTER,\n-\n-  TI_SIZE_ZERO,\n-  TI_SIZE_ONE,\n-\n-  TI_BITSIZE_ZERO,\n-  TI_BITSIZE_ONE,\n-  TI_BITSIZE_UNIT,\n-\n-  TI_PUBLIC,\n-  TI_PROTECTED,\n-  TI_PRIVATE,\n-\n-  TI_BOOLEAN_FALSE,\n-  TI_BOOLEAN_TRUE,\n-\n-  TI_COMPLEX_INTEGER_TYPE,\n-  TI_COMPLEX_FLOAT_TYPE,\n-  TI_COMPLEX_DOUBLE_TYPE,\n-  TI_COMPLEX_LONG_DOUBLE_TYPE,\n-\n-  TI_FLOAT_TYPE,\n-  TI_DOUBLE_TYPE,\n-  TI_LONG_DOUBLE_TYPE,\n-\n-  TI_FLOAT_PTR_TYPE,\n-  TI_DOUBLE_PTR_TYPE,\n-  TI_LONG_DOUBLE_PTR_TYPE,\n-  TI_INTEGER_PTR_TYPE,\n-\n-  TI_VOID_TYPE,\n-  TI_PTR_TYPE,\n-  TI_CONST_PTR_TYPE,\n-  TI_SIZE_TYPE,\n-  TI_PID_TYPE,\n-  TI_PTRDIFF_TYPE,\n-  TI_VA_LIST_TYPE,\n-  TI_VA_LIST_GPR_COUNTER_FIELD,\n-  TI_VA_LIST_FPR_COUNTER_FIELD,\n-  TI_BOOLEAN_TYPE,\n-  TI_FILEPTR_TYPE,\n-  TI_POINTER_SIZED_TYPE,\n-\n-  TI_DFLOAT32_TYPE,\n-  TI_DFLOAT64_TYPE,\n-  TI_DFLOAT128_TYPE,\n-  TI_DFLOAT32_PTR_TYPE,\n-  TI_DFLOAT64_PTR_TYPE,\n-  TI_DFLOAT128_PTR_TYPE,\n-\n-  TI_VOID_LIST_NODE,\n-\n-  TI_MAIN_IDENTIFIER,\n-\n-  TI_SAT_SFRACT_TYPE,\n-  TI_SAT_FRACT_TYPE,\n-  TI_SAT_LFRACT_TYPE,\n-  TI_SAT_LLFRACT_TYPE,\n-  TI_SAT_USFRACT_TYPE,\n-  TI_SAT_UFRACT_TYPE,\n-  TI_SAT_ULFRACT_TYPE,\n-  TI_SAT_ULLFRACT_TYPE,\n-  TI_SFRACT_TYPE,\n-  TI_FRACT_TYPE,\n-  TI_LFRACT_TYPE,\n-  TI_LLFRACT_TYPE,\n-  TI_USFRACT_TYPE,\n-  TI_UFRACT_TYPE,\n-  TI_ULFRACT_TYPE,\n-  TI_ULLFRACT_TYPE,\n-  TI_SAT_SACCUM_TYPE,\n-  TI_SAT_ACCUM_TYPE,\n-  TI_SAT_LACCUM_TYPE,\n-  TI_SAT_LLACCUM_TYPE,\n-  TI_SAT_USACCUM_TYPE,\n-  TI_SAT_UACCUM_TYPE,\n-  TI_SAT_ULACCUM_TYPE,\n-  TI_SAT_ULLACCUM_TYPE,\n-  TI_SACCUM_TYPE,\n-  TI_ACCUM_TYPE,\n-  TI_LACCUM_TYPE,\n-  TI_LLACCUM_TYPE,\n-  TI_USACCUM_TYPE,\n-  TI_UACCUM_TYPE,\n-  TI_ULACCUM_TYPE,\n-  TI_ULLACCUM_TYPE,\n-  TI_QQ_TYPE,\n-  TI_HQ_TYPE,\n-  TI_SQ_TYPE,\n-  TI_DQ_TYPE,\n-  TI_TQ_TYPE,\n-  TI_UQQ_TYPE,\n-  TI_UHQ_TYPE,\n-  TI_USQ_TYPE,\n-  TI_UDQ_TYPE,\n-  TI_UTQ_TYPE,\n-  TI_SAT_QQ_TYPE,\n-  TI_SAT_HQ_TYPE,\n-  TI_SAT_SQ_TYPE,\n-  TI_SAT_DQ_TYPE,\n-  TI_SAT_TQ_TYPE,\n-  TI_SAT_UQQ_TYPE,\n-  TI_SAT_UHQ_TYPE,\n-  TI_SAT_USQ_TYPE,\n-  TI_SAT_UDQ_TYPE,\n-  TI_SAT_UTQ_TYPE,\n-  TI_HA_TYPE,\n-  TI_SA_TYPE,\n-  TI_DA_TYPE,\n-  TI_TA_TYPE,\n-  TI_UHA_TYPE,\n-  TI_USA_TYPE,\n-  TI_UDA_TYPE,\n-  TI_UTA_TYPE,\n-  TI_SAT_HA_TYPE,\n-  TI_SAT_SA_TYPE,\n-  TI_SAT_DA_TYPE,\n-  TI_SAT_TA_TYPE,\n-  TI_SAT_UHA_TYPE,\n-  TI_SAT_USA_TYPE,\n-  TI_SAT_UDA_TYPE,\n-  TI_SAT_UTA_TYPE,\n-\n-  TI_OPTIMIZATION_DEFAULT,\n-  TI_OPTIMIZATION_CURRENT,\n-  TI_TARGET_OPTION_DEFAULT,\n-  TI_TARGET_OPTION_CURRENT,\n-  TI_CURRENT_TARGET_PRAGMA,\n-  TI_CURRENT_OPTIMIZE_PRAGMA,\n-\n-  TI_MAX\n-};\n-\n-extern GTY(()) tree global_trees[TI_MAX];\n-\n #define error_mark_node\t\t\tglobal_trees[TI_ERROR_MARK]\n \n #define intQI_type_node\t\t\tglobal_trees[TI_INTQI_TYPE]\n@@ -4562,34 +3250,6 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define current_target_pragma\t\tglobal_trees[TI_CURRENT_TARGET_PRAGMA]\n #define current_optimize_pragma\t\tglobal_trees[TI_CURRENT_OPTIMIZE_PRAGMA]\n \n-/* An enumeration of the standard C integer types.  These must be\n-   ordered so that shorter types appear before longer ones, and so\n-   that signed types appear before unsigned ones, for the correct\n-   functioning of interpret_integer() in c-lex.c.  */\n-enum integer_type_kind\n-{\n-  itk_char,\n-  itk_signed_char,\n-  itk_unsigned_char,\n-  itk_short,\n-  itk_unsigned_short,\n-  itk_int,\n-  itk_unsigned_int,\n-  itk_long,\n-  itk_unsigned_long,\n-  itk_long_long,\n-  itk_unsigned_long_long,\n-  itk_int128,\n-  itk_unsigned_int128,\n-  itk_none\n-};\n-\n-typedef enum integer_type_kind integer_type_kind;\n-\n-/* The standard C integer types.  Use integer_type_kind to index into\n-   this array.  */\n-extern GTY(()) tree integer_types[itk_none];\n-\n #define char_type_node\t\t\tinteger_types[itk_char]\n #define signed_char_type_node\t\tinteger_types[itk_signed_char]\n #define unsigned_char_type_node\t\tinteger_types[itk_unsigned_char]\n@@ -4603,34 +3263,7 @@ extern GTY(()) tree integer_types[itk_none];\n #define long_long_unsigned_type_node\tinteger_types[itk_unsigned_long_long]\n #define int128_integer_type_node\tinteger_types[itk_int128]\n #define int128_unsigned_type_node\tinteger_types[itk_unsigned_int128]\n-\f\n-/* A pointer-to-function member type looks like:\n-\n-     struct {\n-       __P __pfn;\n-       ptrdiff_t __delta;\n-     };\n \n-   If __pfn is NULL, it is a NULL pointer-to-member-function.\n-\n-   (Because the vtable is always the first thing in the object, we\n-   don't need its offset.)  If the function is virtual, then PFN is\n-   one plus twice the index into the vtable; otherwise, it is just a\n-   pointer to the function.\n-\n-   Unfortunately, using the lowest bit of PFN doesn't work in\n-   architectures that don't impose alignment requirements on function\n-   addresses, or that use the lowest bit to tell one ISA from another,\n-   for example.  For such architectures, we use the lowest bit of\n-   DELTA instead of the lowest bit of the PFN, and DELTA will be\n-   multiplied by 2.  */\n-\n-enum ptrmemfunc_vbit_where_t\n-{\n-  ptrmemfunc_vbit_in_pfn,\n-  ptrmemfunc_vbit_in_delta\n-};\n-\f\n #define NULL_TREE (tree) NULL\n \n /* True if NODE is an erroneous expression.  */\n@@ -4987,82 +3620,7 @@ extern tree build_type_attribute_qual_variant (tree, tree, int);\n    warning to be generated).  */\n extern int comp_type_attributes (const_tree, const_tree);\n \n-/* Structure describing an attribute and a function to handle it.  */\n-struct attribute_spec\n-{\n-  /* The name of the attribute (without any leading or trailing __),\n-     or NULL to mark the end of a table of attributes.  */\n-  const char *name;\n-  /* The minimum length of the list of arguments of the attribute.  */\n-  int min_length;\n-  /* The maximum length of the list of arguments of the attribute\n-     (-1 for no maximum).  */\n-  int max_length;\n-  /* Whether this attribute requires a DECL.  If it does, it will be passed\n-     from types of DECLs, function return types and array element types to\n-     the DECLs, function types and array types respectively; but when\n-     applied to a type in any other circumstances, it will be ignored with\n-     a warning.  (If greater control is desired for a given attribute,\n-     this should be false, and the flags argument to the handler may be\n-     used to gain greater control in that case.)  */\n-  bool decl_required;\n-  /* Whether this attribute requires a type.  If it does, it will be passed\n-     from a DECL to the type of that DECL.  */\n-  bool type_required;\n-  /* Whether this attribute requires a function (or method) type.  If it does,\n-     it will be passed from a function pointer type to the target type,\n-     and from a function return type (which is not itself a function\n-     pointer type) to the function type.  */\n-  bool function_type_required;\n-  /* Function to handle this attribute.  NODE points to the node to which\n-     the attribute is to be applied.  If a DECL, it should be modified in\n-     place; if a TYPE, a copy should be created.  NAME is the name of the\n-     attribute (possibly with leading or trailing __).  ARGS is the TREE_LIST\n-     of the arguments (which may be NULL).  FLAGS gives further information\n-     about the context of the attribute.  Afterwards, the attributes will\n-     be added to the DECL_ATTRIBUTES or TYPE_ATTRIBUTES, as appropriate,\n-     unless *NO_ADD_ATTRS is set to true (which should be done on error,\n-     as well as in any other cases when the attributes should not be added\n-     to the DECL or TYPE).  Depending on FLAGS, any attributes to be\n-     applied to another type or DECL later may be returned;\n-     otherwise the return value should be NULL_TREE.  This pointer may be\n-     NULL if no special handling is required beyond the checks implied\n-     by the rest of this structure.  */\n-  tree (*handler) (tree *node, tree name, tree args,\n-\t\t   int flags, bool *no_add_attrs);\n-  /* Specifies if attribute affects type's identity.  */\n-  bool affects_type_identity;\n-};\n-\n-/* Flags that may be passed in the third argument of decl_attributes, and\n-   to handler functions for attributes.  */\n-enum attribute_flags\n-{\n-  /* The type passed in is the type of a DECL, and any attributes that\n-     should be passed in again to be applied to the DECL rather than the\n-     type should be returned.  */\n-  ATTR_FLAG_DECL_NEXT = 1,\n-  /* The type passed in is a function return type, and any attributes that\n-     should be passed in again to be applied to the function type rather\n-     than the return type should be returned.  */\n-  ATTR_FLAG_FUNCTION_NEXT = 2,\n-  /* The type passed in is an array element type, and any attributes that\n-     should be passed in again to be applied to the array type rather\n-     than the element type should be returned.  */\n-  ATTR_FLAG_ARRAY_NEXT = 4,\n-  /* The type passed in is a structure, union or enumeration type being\n-     created, and should be modified in place.  */\n-  ATTR_FLAG_TYPE_IN_PLACE = 8,\n-  /* The attributes are being applied by default to a library function whose\n-     name indicates known behavior, and should be silently ignored if they\n-     are not in fact compatible with the function type.  */\n-  ATTR_FLAG_BUILT_IN = 16,\n-  /* A given attribute has been parsed as a C++-11 attribute.  */\n-  ATTR_FLAG_CXX11 = 32\n-};\n-\n /* Default versions of target-overridable functions.  */\n-\n extern tree merge_decl_attributes (tree, tree);\n extern tree merge_type_attributes (tree, tree);\n \n@@ -5177,41 +3735,6 @@ extern void finish_builtin_struct (tree, const char *,\n \n extern void layout_type (tree);\n \n-/* These functions allow a front-end to perform a manual layout of a\n-   RECORD_TYPE.  (For instance, if the placement of subsequent fields\n-   depends on the placement of fields so far.)  Begin by calling\n-   start_record_layout.  Then, call place_field for each of the\n-   fields.  Then, call finish_record_layout.  See layout_type for the\n-   default way in which these functions are used.  */\n-\n-typedef struct record_layout_info_s\n-{\n-  /* The RECORD_TYPE that we are laying out.  */\n-  tree t;\n-  /* The offset into the record so far, in bytes, not including bits in\n-     BITPOS.  */\n-  tree offset;\n-  /* The last known alignment of SIZE.  */\n-  unsigned int offset_align;\n-  /* The bit position within the last OFFSET_ALIGN bits, in bits.  */\n-  tree bitpos;\n-  /* The alignment of the record so far, in bits.  */\n-  unsigned int record_align;\n-  /* The alignment of the record so far, ignoring #pragma pack and\n-     __attribute__ ((packed)), in bits.  */\n-  unsigned int unpacked_align;\n-  /* The previous field laid out.  */\n-  tree prev_field;\n-  /* The static variables (i.e., class variables, as opposed to\n-     instance variables) encountered in T.  */\n-  vec<tree, va_gc> *pending_statics;\n-  /* Bits remaining in the current alignment group */\n-  int remaining_in_alignment;\n-  /* True if we've seen a packed field that didn't have normal\n-     alignment anyway.  */\n-  int packed_maybe_necessary;\n-} *record_layout_info;\n-\n extern record_layout_info start_record_layout (tree);\n extern tree bit_from_pos (tree, tree);\n extern tree byte_from_pos (tree, tree);\n@@ -5271,20 +3794,6 @@ extern HOST_WIDE_INT int_bit_position (const_tree);\n extern tree byte_position (const_tree);\n extern HOST_WIDE_INT int_byte_position (const_tree);\n \n-/* Define data structures, macros, and functions for handling sizes\n-   and the various types used to represent sizes.  */\n-\n-enum size_type_kind\n-{\n-  stk_sizetype,\t\t/* Normal representation of sizes in bytes.  */\n-  stk_ssizetype,\t/* Signed representation of sizes in bytes.  */\n-  stk_bitsizetype,\t/* Normal representation of sizes in bits.  */\n-  stk_sbitsizetype,\t/* Signed representation of sizes in bits.  */\n-  stk_type_kind_last\n-};\n-\n-extern GTY(()) tree sizetype_tab[(int) stk_type_kind_last];\n-\n #define sizetype sizetype_tab[(int) stk_sizetype]\n #define bitsizetype sizetype_tab[(int) stk_bitsizetype]\n #define ssizetype sizetype_tab[(int) stk_ssizetype]\n@@ -5316,9 +3825,6 @@ extern void finalize_size_functions (void);\n    + (BITS_PER_UNIT > 8) + (BITS_PER_UNIT > 16) + (BITS_PER_UNIT > 32) \\\n    + (BITS_PER_UNIT > 64) + (BITS_PER_UNIT > 128) + (BITS_PER_UNIT > 256))\n \n-/* If nonzero, an upper limit on alignment of structure fields, in bits,  */\n-extern unsigned int maximum_field_alignment;\n-\n /* Concatenate two lists (chains of TREE_LIST nodes) X and Y\n    by making the last node in X point to Y.\n    Returns X, except if X is 0 returns Y.  */\n@@ -5593,25 +4099,6 @@ extern tree decl_type_context (const_tree);\n \n /* Return 1 if EXPR is the real constant zero.  */\n extern int real_zerop (const_tree);\n-\f\n-/* Declare commonly used variables for tree structure.  */\n-\n-/* Nonzero means lvalues are limited to those valid in pedantic ANSI C.\n-   Zero means allow extended lvalues.  */\n-\n-extern int pedantic_lvalues;\n-\n-/* Points to the FUNCTION_DECL of the function whose body we are reading.  */\n-\n-extern GTY(()) tree current_function_decl;\n-\n-/* Nonzero means a FUNC_BEGIN label was emitted.  */\n-extern GTY(()) const char * current_function_func_begin_label;\n-\f\n-/* Iterator for going through the function arguments.  */\n-typedef struct {\n-  tree next;\t\t\t/* TREE_LIST pointing to the next argument */\n-} function_args_iterator;\n \n /* Initialize the iterator I with arguments from function FNDECL  */\n \n@@ -5817,14 +4304,6 @@ extern void fold_undefer_overflow_warnings (bool, const_gimple, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n extern bool fold_deferring_overflow_warnings_p (void);\n extern tree fold_fma (location_t, tree, tree, tree, tree);\n-\n-enum operand_equal_flag\n-{\n-  OEP_ONLY_CONST = 1,\n-  OEP_PURE_SAME = 2,\n-  OEP_CONSTANT_ADDRESS_OF = 4\n-};\n-\n extern int operand_equal_p (const_tree, const_tree, unsigned int);\n extern int multiple_of_p (tree, const_tree, const_tree);\n #define omit_one_operand(T1,T2,T3)\\\n@@ -6109,70 +4588,10 @@ extern bool debug_find_tree (tree, tree);\n extern tree build_duplicate_type (tree);\n \n /* In calls.c */\n-\n-/* Nonzero if this is a call to a function whose return value depends\n-   solely on its arguments, has no side effects, and does not read\n-   global memory.  This corresponds to TREE_READONLY for function\n-   decls.  */\n-#define ECF_CONST\t\t  (1 << 0)\n-/* Nonzero if this is a call to \"pure\" function (like const function,\n-   but may read memory.  This corresponds to DECL_PURE_P for function\n-   decls.  */\n-#define ECF_PURE\t\t  (1 << 1)\n-/* Nonzero if this is ECF_CONST or ECF_PURE but cannot be proven to no\n-   infinite loop.  This corresponds to DECL_LOOPING_CONST_OR_PURE_P\n-   for function decls.*/\n-#define ECF_LOOPING_CONST_OR_PURE (1 << 2)\n-/* Nonzero if this call will never return.  */\n-#define ECF_NORETURN\t\t  (1 << 3)\n-/* Nonzero if this is a call to malloc or a related function.  */\n-#define ECF_MALLOC\t\t  (1 << 4)\n-/* Nonzero if it is plausible that this is a call to alloca.  */\n-#define ECF_MAY_BE_ALLOCA\t  (1 << 5)\n-/* Nonzero if this is a call to a function that won't throw an exception.  */\n-#define ECF_NOTHROW\t\t  (1 << 6)\n-/* Nonzero if this is a call to setjmp or a related function.  */\n-#define ECF_RETURNS_TWICE\t  (1 << 7)\n-/* Nonzero if this call replaces the current stack frame.  */\n-#define ECF_SIBCALL\t\t  (1 << 8)\n-/* Function does not read or write memory (but may have side effects, so\n-   it does not necessarily fit ECF_CONST).  */\n-#define ECF_NOVOPS\t\t  (1 << 9)\n-/* The function does not lead to calls within current function unit.  */\n-#define ECF_LEAF\t\t  (1 << 10)\n-/* Nonzero if this call does not affect transactions.  */\n-#define ECF_TM_PURE\t\t  (1 << 11)\n-/* Nonzero if this call is into the transaction runtime library.  */\n-#define ECF_TM_BUILTIN\t\t  (1 << 12)\n-\n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);\n extern void set_call_expr_flags (tree, int);\n \n-/* Call argument flags.  */\n-\n-/* Nonzero if the argument is not dereferenced recursively, thus only\n-   directly reachable memory is read or written.  */\n-#define EAF_DIRECT\t\t(1 << 0)\n-/* Nonzero if memory reached by the argument is not clobbered.  */\n-#define EAF_NOCLOBBER\t\t(1 << 1)\n-/* Nonzero if the argument does not escape.  */\n-#define EAF_NOESCAPE\t\t(1 << 2)\n-/* Nonzero if the argument is not used by the function.  */\n-#define EAF_UNUSED\t\t(1 << 3)\n-\n-/* Call return flags.  */\n-\n-/* Mask for the argument number that is returned.  Lower two bits of\n-   the return flags, encodes argument slots zero to three.  */\n-#define ERF_RETURN_ARG_MASK\t(3)\n-/* Nonzero if the return value is equal to the argument number\n-   flags & ERF_RETURN_ARG_MASK.  */\n-#define ERF_RETURNS_ARG\t\t(1 << 2)\n-/* Nonzero if the return value does not alias with anything.  Functions\n-   with the malloc attribute have this set on their return value.  */\n-#define ERF_NOALIAS\t\t(1 << 3)\n-\n extern int setjmp_call_p (const_tree);\n extern bool gimple_alloca_call_p (const_gimple);\n extern bool alloca_call_p (const_tree);\n@@ -6273,19 +4692,6 @@ extern tree tree_overlaps_hard_reg_set (tree, HARD_REG_SET *);\n \f\n /* In tree-inline.c  */\n \n-/* The type of a set of already-visited pointers.  Functions for creating\n-   and manipulating it are declared in pointer-set.h */\n-struct pointer_set_t;\n-\n-/* The type of a callback function for walking over tree structure.  */\n-\n-typedef tree (*walk_tree_fn) (tree *, int *, void *);\n-\n-/* The type of a callback function that represents a custom walk_tree.  */\n-\n-typedef tree (*walk_tree_lh) (tree *, int *, tree (*) (tree *, int *, void *),\n-\t\t\t      void *, struct pointer_set_t*);\n-\n extern tree walk_tree_1 (tree*, walk_tree_fn, void*, struct pointer_set_t*,\n \t\t\t walk_tree_lh);\n extern tree walk_tree_without_duplicates_1 (tree*, walk_tree_fn, void*,\n@@ -6300,106 +4706,33 @@ extern tree walk_tree_without_duplicates_1 (tree*, walk_tree_fn, void*,\n \n extern void set_decl_rtl (tree, rtx);\n extern void set_decl_incoming_rtl (tree, rtx, bool);\n-\f\n-/* Enum and arrays used for tree allocation stats.\n-   Keep in sync with tree.c:tree_node_kind_names.  */\n-typedef enum\n-{\n-  d_kind,\n-  t_kind,\n-  b_kind,\n-  s_kind,\n-  r_kind,\n-  e_kind,\n-  c_kind,\n-  id_kind,\n-  vec_kind,\n-  binfo_kind,\n-  ssa_name_kind,\n-  constr_kind,\n-  x_kind,\n-  lang_decl,\n-  lang_type,\n-  omp_clause_kind,\n-  all_kinds\n-} tree_node_kind;\n-\n-extern int tree_node_counts[];\n-extern int tree_node_sizes[];\n-\n-/* True if we are in gimple form and the actions of the folders need to\n-   be restricted.  False if we are not in gimple form and folding is not\n-   restricted to creating gimple expressions.  */\n-extern bool in_gimple_form;\n \n /* In gimple.c.  */\n extern tree get_base_address (tree t);\n extern void mark_addressable (tree);\n \n /* In tree.c.  */\n-\n-struct GTY(()) tree_map_base {\n-  tree from;\n-};\n-\n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);\n extern bool list_equal_p (const_tree, const_tree);\n \n-/* Map from a tree to another tree.  */\n-\n-struct GTY(()) tree_map {\n-  struct tree_map_base base;\n-  unsigned int hash;\n-  tree to;\n-};\n-\n #define tree_map_eq tree_map_base_eq\n extern unsigned int tree_map_hash (const void *);\n #define tree_map_marked_p tree_map_base_marked_p\n \n-/* Map from a decl tree to another tree.  */\n-\n-struct GTY(()) tree_decl_map {\n-  struct tree_map_base base;\n-  tree to;\n-};\n-\n #define tree_decl_map_eq tree_map_base_eq\n extern unsigned int tree_decl_map_hash (const void *);\n #define tree_decl_map_marked_p tree_map_base_marked_p\n \n-/* Map from a tree to an int.  */\n-\n-struct GTY(()) tree_int_map {\n-  struct tree_map_base base;\n-  unsigned int to;\n-};\n-\n #define tree_int_map_eq tree_map_base_eq\n #define tree_int_map_hash tree_map_base_hash\n #define tree_int_map_marked_p tree_map_base_marked_p\n \n-/* Map from a tree to initialization/finalization priorities.  */\n-\n-struct GTY(()) tree_priority_map {\n-  struct tree_map_base base;\n-  priority_type init;\n-  priority_type fini;\n-};\n-\n #define tree_priority_map_eq tree_map_base_eq\n #define tree_priority_map_hash tree_map_base_hash\n #define tree_priority_map_marked_p tree_map_base_marked_p\n \n-/* Map from a decl tree to a tree vector.  */\n-\n-struct GTY(()) tree_vec_map {\n-  struct tree_map_base base;\n-  vec<tree, va_gc> *to;\n-};\n-\n #define tree_vec_map_eq tree_map_base_eq\n #define tree_vec_map_hash tree_decl_map_hash\n #define tree_vec_map_marked_p tree_map_base_marked_p\n@@ -6452,23 +4785,6 @@ is_tm_safe_or_pure (const_tree x)\n \n void init_inline_once (void);\n \n-/* Abstract iterators for CALL_EXPRs.  These static inline definitions\n-   have to go towards the end of tree.h so that union tree_node is fully\n-   defined by this point.  */\n-\n-/* Structure containing iterator state.  */\n-typedef struct call_expr_arg_iterator_d {\n-  tree t;\t/* the call_expr */\n-  int n;\t/* argument count */\n-  int i;\t/* next argument index */\n-} call_expr_arg_iterator;\n-\n-typedef struct const_call_expr_arg_iterator_d {\n-  const_tree t;\t/* the call_expr */\n-  int n;\t/* argument count */\n-  int i;\t/* next argument index */\n-} const_call_expr_arg_iterator;\n-\n /* Initialize the abstract argument list iterator object ITER with the\n    arguments from CALL_EXPR node EXP.  */\n static inline void\n@@ -6566,20 +4882,6 @@ extern bool block_may_fallthru (const_tree);\n /* In vtable-verify.c.  */\n extern void save_vtable_map_decl (tree);\n \n-\f\n-/* Functional interface to the builtin functions.  */\n-\n-/* The builtin_info structure holds the FUNCTION_DECL of the standard builtin\n-   function, and a flag that says if the function is available implicitly, or\n-   whether the user has to code explicit calls to __builtin_<xxx>.  */\n-\n-typedef struct GTY(()) builtin_info_type_d {\n-  tree decl[(int)END_BUILTINS];\n-  bool implicit_p[(int)END_BUILTINS];\n-} builtin_info_type;\n-\n-extern GTY(()) builtin_info_type builtin_info;\n-\n /* Valid builtin number.  */\n #define BUILTIN_VALID_P(FNCODE) \\\n   (IN_RANGE ((int)FNCODE, ((int)BUILT_IN_NONE) + 1, ((int) END_BUILTINS) - 1))"}]}