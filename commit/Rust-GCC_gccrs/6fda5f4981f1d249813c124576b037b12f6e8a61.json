{"sha": "6fda5f4981f1d249813c124576b037b12f6e8a61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZkYTVmNDk4MWYxZDI0OTgxM2MxMjQ1NzZiMDM3YjEyZjZlOGE2MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-05T23:50:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-05T23:50:41Z"}, "message": "Use vec instead of raw array for built-in candidates.\n\nMy operator<=> patch wants to split up build_new_op_1, which makes using a\ntree array as well as the vec inconvenient.  build_new_op_1 already has a\nvec, and build_conditional_expr_1 can release its vec right away, so this\ndoesn't increase garbage at all.\n\n\t* call.c (build_builtin_candidate): Take args in a vec.\n\t(add_builtin_candidate, add_builtin_candidates): Likewise.\n\t(build_conditional_expr_1, build_new_op_1): Adjust.\n\nFrom-SVN: r277863", "tree": {"sha": "3222d58ac3ec63e30e42e02feb37a35e98bad514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3222d58ac3ec63e30e42e02feb37a35e98bad514"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fda5f4981f1d249813c124576b037b12f6e8a61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fda5f4981f1d249813c124576b037b12f6e8a61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fda5f4981f1d249813c124576b037b12f6e8a61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fda5f4981f1d249813c124576b037b12f6e8a61/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72"}], "stats": {"total": 73, "additions": 33, "deletions": 40}, "files": [{"sha": "2085319bbc996fda0d16165383e820120be16fec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fda5f4981f1d249813c124576b037b12f6e8a61/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fda5f4981f1d249813c124576b037b12f6e8a61/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6fda5f4981f1d249813c124576b037b12f6e8a61", "patch": "@@ -1,3 +1,10 @@\n+2019-11-04  Jason Merrill  <jason@redhat.com>\n+\n+\tUse vec instead of raw array for built-in candidates.\n+\t* call.c (build_builtin_candidate): Take args in a vec.\n+\t(add_builtin_candidate, add_builtin_candidates): Likewise.\n+\t(build_conditional_expr_1, build_new_op_1): Adjust.\n+\n 2019-11-04  Jason Merrill  <jason@redhat.com>\n \n \t* constexpr.c (explain_invalid_constexpr_fn): Show location of fn."}, {"sha": "2a1da3cc4e1ece2a89dc065084475a07d835513d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fda5f4981f1d249813c124576b037b12f6e8a61/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fda5f4981f1d249813c124576b037b12f6e8a61/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6fda5f4981f1d249813c124576b037b12f6e8a61", "patch": "@@ -182,16 +182,7 @@ static struct z_candidate *add_template_candidate\n static struct z_candidate *add_template_candidate_real\n \t(struct z_candidate **, tree, tree, tree, tree, const vec<tree, va_gc> *,\n \t tree, tree, tree, int, tree, unification_kind_t, tsubst_flags_t);\n-static void add_builtin_candidates\n-\t(struct z_candidate **, enum tree_code, enum tree_code,\n-\t tree, tree *, int, tsubst_flags_t);\n-static void add_builtin_candidate\n-\t(struct z_candidate **, enum tree_code, enum tree_code,\n-\t tree, tree, tree, tree *, tree *, int, tsubst_flags_t);\n static bool is_complete (tree);\n-static void build_builtin_candidate\n-\t(struct z_candidate **, tree, tree, tree, tree *, tree *,\n-\t int, tsubst_flags_t);\n static struct z_candidate *add_conv_candidate\n \t(struct z_candidate **, tree, tree, const vec<tree, va_gc> *, tree,\n \t tree, tsubst_flags_t);\n@@ -2512,20 +2503,20 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n \n static void\n build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n-\t\t\t tree type1, tree type2, tree *args, tree *argtypes,\n-\t\t\t int flags, tsubst_flags_t complain)\n+\t\t\t tree type1, tree type2, const vec<tree,va_gc> &args,\n+\t\t\t tree *argtypes, int flags, tsubst_flags_t complain)\n {\n   conversion *t;\n   conversion **convs;\n   size_t num_convs;\n-  int viable = 1, i;\n+  int viable = 1;\n   tree types[2];\n   struct rejection_reason *reason = NULL;\n \n   types[0] = type1;\n   types[1] = type2;\n \n-  num_convs =  args[2] ? 3 : (args[1] ? 2 : 1);\n+  num_convs = args.length ();\n   convs = alloc_conversions (num_convs);\n \n   /* TRUTH_*_EXPR do \"contextual conversion to bool\", which means explicit\n@@ -2536,11 +2527,8 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n   if (type1 != boolean_type_node)\n     flags |= LOOKUP_ONLYCONVERTING;\n \n-  for (i = 0; i < 2; ++i)\n+  for (unsigned i = 0; i < 2 && i < num_convs; ++i)\n     {\n-      if (! args[i])\n-\tbreak;\n-\n       t = implicit_conversion (types[i], argtypes[i], args[i],\n \t\t\t       /*c_cast_p=*/false, flags, complain);\n       if (! t)\n@@ -2562,7 +2550,7 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n     }\n \n   /* For COND_EXPR we rearranged the arguments; undo that now.  */\n-  if (args[2])\n+  if (num_convs == 3)\n     {\n       convs[2] = convs[1];\n       convs[1] = convs[0];\n@@ -2623,8 +2611,8 @@ promoted_arithmetic_type_p (tree type)\n static void\n add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t\t       enum tree_code code2, tree fnname, tree type1,\n-\t\t       tree type2, tree *args, tree *argtypes, int flags,\n-\t\t       tsubst_flags_t complain)\n+\t\t       tree type2, vec<tree,va_gc> &args, tree *argtypes,\n+\t\t       int flags, tsubst_flags_t complain)\n {\n   switch (code)\n     {\n@@ -3083,18 +3071,21 @@ type_decays_to (tree type)\n \n static void\n add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n-\t\t\tenum tree_code code2, tree fnname, tree *args,\n+\t\t\tenum tree_code code2, tree fnname,\n+\t\t\tvec<tree, va_gc> *argv,\n \t\t\tint flags, tsubst_flags_t complain)\n {\n-  int ref1, i;\n+  int ref1;\n   int enum_p = 0;\n   tree type, argtypes[3], t;\n   /* TYPES[i] is the set of possible builtin-operator parameter types\n      we will consider for the Ith argument.  */\n   vec<tree, va_gc> *types[2];\n   unsigned ix;\n+  vec<tree, va_gc> &args = *argv;\n+  unsigned len = args.length ();\n \n-  for (i = 0; i < 3; ++i)\n+  for (unsigned i = 0; i < len; ++i)\n     {\n       if (args[i])\n \targtypes[i] = unlowered_expr_type (args[i]);\n@@ -3157,11 +3148,11 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n   types[0] = make_tree_vector ();\n   types[1] = make_tree_vector ();\n \n-  for (i = 0; i < 2; ++i)\n+  if (len == 3)\n+    len = 2;\n+  for (unsigned i = 0; i < len; ++i)\n     {\n-      if (! args[i])\n-\t;\n-      else if (MAYBE_CLASS_TYPE_P (argtypes[i]))\n+      if (MAYBE_CLASS_TYPE_P (argtypes[i]))\n \t{\n \t  tree convs;\n \n@@ -5397,16 +5388,16 @@ build_conditional_expr_1 (const op_location_t &loc,\n   if (!same_type_p (arg2_type, arg3_type)\n       && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n     {\n-      tree args[3];\n+      releasing_vec args;\n       conversion *conv;\n       bool any_viable_p;\n \n       /* Rearrange the arguments so that add_builtin_candidate only has\n \t to know about two args.  In build_builtin_candidate, the\n \t arguments are unscrambled.  */\n-      args[0] = arg2;\n-      args[1] = arg3;\n-      args[2] = arg1;\n+      args->quick_push (arg2);\n+      args->quick_push (arg3);\n+      args->quick_push (arg1);\n       add_builtin_candidates (&candidates,\n \t\t\t      COND_EXPR,\n \t\t\t      NOP_EXPR,\n@@ -5816,7 +5807,6 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n {\n   struct z_candidate *candidates = 0, *cand;\n   vec<tree, va_gc> *arglist;\n-  tree args[3];\n   tree result = NULL_TREE;\n   bool result_valid_p = false;\n   enum tree_code code2 = NOP_EXPR;\n@@ -5929,10 +5919,6 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t\t      flags, &candidates, complain);\n     }\n \n-  args[0] = arg1;\n-  args[1] = arg2;\n-  args[2] = NULL_TREE;\n-\n   /* Add class-member operators to the candidate set.  */\n   if (CLASS_TYPE_P (arg1_type))\n     {\n@@ -5952,7 +5938,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t\t\tBASELINK_ACCESS_BINFO (fns),\n \t\t\tflags, &candidates, complain);\n     }\n-  /* Per 13.3.1.2/3, 2nd bullet, if no operand has a class type, then\n+  /* Per [over.match.oper]3.2, if no operand has a class type, then\n      only non-member functions that have type T1 or reference to\n      cv-qualified-opt T1 for the first argument, if the first argument\n      has an enumeration type, or T2 or reference to cv-qualified-opt\n@@ -5978,9 +5964,9 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \n \t      if (TYPE_REF_P (parmtype))\n \t\tparmtype = TREE_TYPE (parmtype);\n-\t      if (TREE_CODE (unlowered_expr_type (args[i])) == ENUMERAL_TYPE\n+\t      if (TREE_CODE (unlowered_expr_type ((*arglist)[i])) == ENUMERAL_TYPE\n \t\t  && (same_type_ignoring_top_level_qualifiers_p\n-\t\t      (unlowered_expr_type (args[i]), parmtype)))\n+\t\t      (unlowered_expr_type ((*arglist)[i]), parmtype)))\n \t\tbreak;\n \n \t      parmlist = TREE_CHAIN (parmlist);\n@@ -5996,7 +5982,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t}\n     }\n \n-  add_builtin_candidates (&candidates, code, code2, fnname, args,\n+  add_builtin_candidates (&candidates, code, code2, fnname, arglist,\n \t\t\t  flags, complain);\n \n   switch (code)"}]}