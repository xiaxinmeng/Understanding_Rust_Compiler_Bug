{"sha": "aa4936945e79262bad9152c984cadb387d342fb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0OTM2OTQ1ZTc5MjYyYmFkOTE1MmM5ODRjYWRiMzg3ZDM0MmZiNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-06-14T15:53:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-06-14T15:53:38Z"}, "message": "re PR bootstrap/44426 (gcc 4.5.0 requires c9x compiler to build)\n\n\tPR bootstrap/44426\n\t* tree.h (build_call_expr): Don't define as vararg macro, instead\n\tadd a prototype.\n\t* builtins.c (build_call_nofold): Remove.\n\t(expand_builtin_int_roundingfn, expand_builtin_pow,\n\texpand_builtin_mempcpy_args, expand_builtin_stpcpy,\n\texpand_builtin_memset_args, expand_builtin_strcmp,\n\texpand_builtin_strncmp, expand_builtin_memory_chk): Use\n\tbuild_call_nofold_loc instead of build_call_nofold.\n\t(build_call_expr): New function.\n\nFrom-SVN: r160754", "tree": {"sha": "91a5d9bb63c37b00e41718726e4713eb049e5990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91a5d9bb63c37b00e41718726e4713eb049e5990"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4936945e79262bad9152c984cadb387d342fb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4936945e79262bad9152c984cadb387d342fb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4936945e79262bad9152c984cadb387d342fb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4936945e79262bad9152c984cadb387d342fb6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ab7d796d82889397ac6b74477be99fc5ee76831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab7d796d82889397ac6b74477be99fc5ee76831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ab7d796d82889397ac6b74477be99fc5ee76831"}], "stats": {"total": 65, "additions": 50, "deletions": 15}, "files": [{"sha": "8dc51e6e3cdef63233cf2b98cc9c668d5a5a3205", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4936945e79262bad9152c984cadb387d342fb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4936945e79262bad9152c984cadb387d342fb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa4936945e79262bad9152c984cadb387d342fb6", "patch": "@@ -1,5 +1,16 @@\n 2010-06-14  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR bootstrap/44426\n+\t* tree.h (build_call_expr): Don't define as vararg macro, instead\n+\tadd a prototype.\n+\t* builtins.c (build_call_nofold): Remove.\n+\t(expand_builtin_int_roundingfn, expand_builtin_pow,\n+\texpand_builtin_mempcpy_args, expand_builtin_stpcpy,\n+\texpand_builtin_memset_args, expand_builtin_strcmp,\n+\texpand_builtin_strncmp, expand_builtin_memory_chk): Use\n+\tbuild_call_nofold_loc instead of build_call_nofold.\n+\t(build_call_expr): New function.\n+\n \tPR tree-optimization/44508\n \t* tree-ssa-propagate.h (substitute_and_fold): Add DO_DCE\n \targument."}, {"sha": "35e8e25241d88126ff2ab0766aa319a75fd09906", "filename": "gcc/builtins.c", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4936945e79262bad9152c984cadb387d342fb6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4936945e79262bad9152c984cadb387d342fb6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=aa4936945e79262bad9152c984cadb387d342fb6", "patch": "@@ -2521,8 +2521,6 @@ build_call_nofold_loc (location_t loc, tree fndecl, int n, ...)\n   SET_EXPR_LOCATION (fn, loc);\n   return fn;\n }\n-#define build_call_nofold(...) \\\n-  build_call_nofold_loc (UNKNOWN_LOCATION, __VA_ARGS__)\n \n /* Expand a call to one of the builtin rounding functions gcc defines\n    as an extension (lfloor and lceil).  As these are gcc extensions we\n@@ -2640,7 +2638,7 @@ expand_builtin_int_roundingfn (tree exp, rtx target)\n       fallback_fndecl = build_fn_decl (name, fntype);\n     }\n \n-  exp = build_call_nofold (fallback_fndecl, 1, arg);\n+  exp = build_call_nofold_loc (EXPR_LOCATION (exp), fallback_fndecl, 1, arg);\n \n   tmp = expand_normal (exp);\n \n@@ -3085,7 +3083,8 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n \t\t  && (optab_handler (sqrt_optab, mode)->insn_code\n \t\t      != CODE_FOR_nothing))))\n \t{\n-\t  tree call_expr = build_call_nofold (fn, 1, narg0);\n+\t  tree call_expr = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 1,\n+\t\t\t\t\t\t  narg0);\n \t  /* Use expand_expr in case the newly built call expression\n \t     was folded to a non-call.  */\n \t  op = expand_expr (call_expr, subtarget, mode, EXPAND_NORMAL);\n@@ -3137,7 +3136,8 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n \t       && powi_cost (n/3) <= POWI_MAX_MULTS)\n \t      || n == 1))\n \t{\n-\t  tree call_expr = build_call_nofold (fn, 1,narg0);\n+\t  tree call_expr = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 1,\n+\t\t\t\t\t\t  narg0);\n \t  op = expand_builtin (call_expr, NULL_RTX, subtarget, mode, 0);\n \t  if (abs (n) % 3 == 2)\n \t    op = expand_simple_binop (mode, MULT, op, op, op,\n@@ -3471,7 +3471,8 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n   if (target == const0_rtx && implicit_built_in_decls[BUILT_IN_MEMCPY])\n     {\n       tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-      tree result = build_call_nofold (fn, 3, dest, src, len);\n+      tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n+\t\t\t\t\t   dest, src, len);\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n   else\n@@ -3652,7 +3653,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n   if (target == const0_rtx && implicit_built_in_decls[BUILT_IN_STRCPY])\n     {\n       tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n-      tree result = build_call_nofold (fn, 2, dst, src);\n+      tree result = build_call_nofold_loc (loc, fn, 2, dst, src);\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n   else\n@@ -3955,9 +3956,11 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   fndecl = get_callee_fndecl (orig_exp);\n   fcode = DECL_FUNCTION_CODE (fndecl);\n   if (fcode == BUILT_IN_MEMSET)\n-    fn = build_call_nofold (fndecl, 3, dest, val, len);\n+    fn = build_call_nofold_loc (EXPR_LOCATION (orig_exp), fndecl, 3,\n+\t\t\t\tdest, val, len);\n   else if (fcode == BUILT_IN_BZERO)\n-    fn = build_call_nofold (fndecl, 2, dest, len);\n+    fn = build_call_nofold_loc (EXPR_LOCATION (orig_exp), fndecl, 2,\n+\t\t\t\tdest, len);\n   else\n     gcc_unreachable ();\n   gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n@@ -4230,7 +4233,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n     do_libcall:\n #endif\n       fndecl = get_callee_fndecl (exp);\n-      fn = build_call_nofold (fndecl, 2, arg1, arg2);\n+      fn = build_call_nofold_loc (EXPR_LOCATION (exp), fndecl, 2, arg1, arg2);\n       gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n       CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n       return expand_call (fn, target, target == const0_rtx);\n@@ -4352,7 +4355,8 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n     /* Expand the library call ourselves using a stabilized argument\n        list to avoid re-evaluating the function's arguments twice.  */\n     fndecl = get_callee_fndecl (exp);\n-    fn = build_call_nofold (fndecl, 3, arg1, arg2, len);\n+    fn = build_call_nofold_loc (EXPR_LOCATION (exp), fndecl, 3,\n+\t\t\t\targ1, arg2, len);\n     gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n     CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n     return expand_call (fn, target, target == const0_rtx);\n@@ -10758,6 +10762,26 @@ build_call_expr_loc (location_t loc, tree fndecl, int n, ...)\n   return fold_builtin_call_array (loc, TREE_TYPE (fntype), fn, n, argarray);\n }\n \n+/* Like build_call_expr_loc (UNKNOWN_LOCATION, ...).  Duplicated because\n+   varargs macros aren't supported by all bootstrap compilers.  */\n+\n+tree\n+build_call_expr (tree fndecl, int n, ...)\n+{\n+  va_list ap;\n+  tree fntype = TREE_TYPE (fndecl);\n+  tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n+  tree *argarray = (tree *) alloca (n * sizeof (tree));\n+  int i;\n+\n+  va_start (ap, n);\n+  for (i = 0; i < n; i++)\n+    argarray[i] = va_arg (ap, tree);\n+  va_end (ap);\n+  return fold_builtin_call_array (UNKNOWN_LOCATION, TREE_TYPE (fntype),\n+\t\t\t\t  fn, n, argarray);\n+}\n+\n /* Construct a CALL_EXPR with type TYPE with FN as the function expression.\n    N arguments are passed in the array ARGARRAY.  */\n \n@@ -11848,7 +11872,7 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n       if (! fn)\n \treturn NULL_RTX;\n \n-      fn = build_call_nofold (fn, 3, dest, src, len);\n+      fn = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 3, dest, src, len);\n       gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n       CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n       return expand_expr (fn, target, mode, EXPAND_NORMAL);\n@@ -11896,7 +11920,8 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n \t      tree fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n \t      if (!fn)\n \t\treturn NULL_RTX;\n-\t      fn = build_call_nofold (fn, 4, dest, src, len, size);\n+\t      fn = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 4,\n+\t\t\t\t\t  dest, src, len, size);\n \t      gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n \t      CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n \t      return expand_expr (fn, target, mode, EXPAND_NORMAL);"}, {"sha": "1a2ac3a06f020e1211114b8be1687ffee6a3b11d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4936945e79262bad9152c984cadb387d342fb6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4936945e79262bad9152c984cadb387d342fb6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=aa4936945e79262bad9152c984cadb387d342fb6", "patch": "@@ -5017,9 +5017,8 @@ extern bool fold_builtin_next_arg (tree, bool);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree build_function_call_expr (location_t, tree, tree);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n-#define build_call_expr(...)\\\n-   build_call_expr_loc (UNKNOWN_LOCATION, __VA_ARGS__)\n extern tree build_call_expr_loc (location_t, tree, int, ...);\n+extern tree build_call_expr (tree, int, ...);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree c_strlen (tree, int);\n extern tree std_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);"}]}