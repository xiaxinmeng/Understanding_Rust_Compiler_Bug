{"sha": "02889d23ee3b02854dff203dd87b9a25e30b61b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4ODlkMjNlZTNiMDI4NTRkZmYyMDNkZDg3YjlhMjVlMzBiNjFiNA==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2017-02-09T13:46:20Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2017-02-09T13:46:20Z"}, "message": "gimplify.c (gimplify_scan_omp_clauses): No special handling for OMP_CLAUSE_TILE.\n\n2017-02-09  Nathan Sidwell  <nathan@codesourcery.com>\n\t    Cesar Philippidis  <cesar@codesourcery.com>\n\t    Joseph Myers  <joseph@codesourcery.com>\n\t    Chung-Lin Tang  <cltang@codesourcery.com>\n\n\tgcc/\n\t* gimplify.c (gimplify_scan_omp_clauses): No special handling for\n\tOMP_CLAUSE_TILE.\n\t(gimplify_adjust_omp_clauses): Don't delete TILE.\n\t(gimplify_omp_for): Deal with TILE.\n\t* internal-fn.c (expand_GOACC_TILE): New function.\n\t* internal-fn.def (GOACC_DIM_POS): Comment may be overly conservative.\n\t(GOACC_TILE): New.\n\t* omp-expand.c (struct oacc_collapse): Add tile and outer fields.\n\t(expand_oacc_collapse_init): Add LOC paramter.  Initialize tile\n\telement fields.\n\t(expand_oacc_collapse_vars): Add INNER parm, adjust for tiling,\n\tavoid DIV for outermost collapse var.\n\t(expand_oacc_for): Insert tile element loop as needed.  Adjust.\n\tRemove out of date comments, fix whitespace.\n\t* omp-general.c (omp_extract_for_data): Deal with tiling.\n\t* omp-general.h (enum oacc_loop_flags): Add OLF_TILE flag,\n\tadjust OLF_DIM_BASE value.\n\t(struct omp_for_data): Add tiling field.\n\t* omp-low.c (scan_sharing_clauses): Allow OMP_CLAUSE_TILE.\n\t(lower_oacc_head_mark): Add OLF_TILE as appropriate.  Ensure 2 levels\n\tfor auto loops.  Remove default auto determining, moved to\n\toacc_loop_fixed_partitions.\n\t* omp-offload.c (struct oacc_loop): Change 'ifns' to vector of call\n\tstmts, add e_mask field.\n\t(oacc_dim_call): New function, abstracted out from oacc_thread_numbers.\n\t(oacc_thread_numbers): Use oacc_dim_call.\n\t(oacc_xform_tile): New.\n\t(new_oacc_loop_raw): Initialize e_mask, adjust for ifns vector.\n\t(finish_oacc_loop): Adjust for ifns vector.\n\t(oacc_loop_discover_walk): Append loop abstraction sites to list,\n\tadd case for GOACC_TILE fns.\n\t(oacc_loop_xform_loop): Delete.\n\t(oacc_loop_process): Iterate over call list directly, and add\n\thandling for GOACC_TILE fns.\n\t(oacc_loop_fixed_partitions): Determine default auto, deal with TILE,\n\tdump partitioning.\n\t(oacc_loop_auto_partitions): Add outer_assign parm. Assign all but\n\tvector partitioning to outer loops.  Assign 2 partitions to loops\n\twhen available. Add TILE handling.\n\t(oacc_loop_partition): Adjust oacc_loop_auto_partitions call.\n\t(execite_oacc_device_lower): Process GOACC_TILE fns, ignore unknown specs.\n\t* tree-nested.c (convert_nonlocal_omp_clauses): Allow OMP_CLAUSE_TILE.\n\t* tree.c (omp_clause_num_ops): Adjust TILE ops.\n\t* tree.h (OMP_CLAUSE_TILE_ITERVAR, OMP_CLAUSE_TILE_COUNT): New.\n\n\tgcc/c/\n\t* c-parser.c (c_parser_omp_clause_collapse): Disallow tile.\n\t(c_parser_oacc_clause_tile): Disallow collapse. Fix parsing and\n\tsemantic checking.\n\t* c-parser.c (c_parser_omp_for_loop): Accept tiling constructs.\n\n\tgcc/cp/\n\t* parser.c (cp_parser_oacc_clause_tile): Disallow collapse.  Fix\n\tparsing.  Parse constant expression. Remove semantic checking.\n\t(cp_parser_omp_clause_collapse): Disallow tile.\n\t(cp_parser_omp_for_loop): Deal with tile clause.  Don't emit a parse\n\terror about missing for after already emitting one.  Use more\n\tconventional for idiom for unbounded loop.\n\t* pt.c (tsubst_omp_clauses): Handle OMP_CLAUSE_TILE.\n\t* semantics.c (finish_omp_clauses): Correct TILE semantic check.\n\t(finish_omp_for): Deal with tile clause.\n\n\tgcc/fortran/\n\t* openmp.c (resolve_omp_clauses): Error on directives\n\tcontaining both tile and collapse clauses.\n\t(resolve_oacc_loop_blocks): Represent '*' tile arguments as zero.\n\t* trans-openmp.c (gfc_trans_omp_do): Lower tiled loops like\n\tcollapsed loops.\n\n\tgcc/testsuite/\n\t* c-c++-common/goacc/combined-directives.c: Remove xfail.\n\t* c-c++-common/goacc/loop-auto-1.c: Adjust and add additional case.\n\t* c-c++-common/goacc/loop-auto-2.c: New.\n\t* c-c++-common/goacc/tile.c: Include stdbool, fix expected errors.\n\t* c-c++-common/goacc/tile-2.c: New.\n\t* g++.dg/goacc/template.C: Test tile subst.  Adjust erroneous uses.\n\t* g++.dg/goacc/tile-1.C: New, check tile subst.\n\t* gcc.dg/goacc/loop-processing-1.c: Adjust dg-final pattern.\n\t* gfortran.dg/goacc/combined-directives.f90: Remove xfail.\n\t* gfortran.dg/goacc/tile-1.f90: New test.\n\t* gfortran.dg/goacc/tile-2.f90: New test.\n\t* gfortran.dg/goacc/tile-lowering.f95: New test.\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/tile-1.c: New.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-auto-1.c: Adjust and\n\tadd additional case.\n\t* testsuite/libgomp.oacc-c-c++-common/vprop.c: XFAIL under\n\t\"openacc_nvidia_accel_selected\".\n\t* libgomp.oacc-fortran/nested-function-1.f90 (test2):\n\tAdd num_workers(8) clause.\n\nFrom-SVN: r245300", "tree": {"sha": "a62233f5023008dd44b52a218e6c0fd79f1116fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a62233f5023008dd44b52a218e6c0fd79f1116fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02889d23ee3b02854dff203dd87b9a25e30b61b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02889d23ee3b02854dff203dd87b9a25e30b61b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02889d23ee3b02854dff203dd87b9a25e30b61b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02889d23ee3b02854dff203dd87b9a25e30b61b4/comments", "author": null, "committer": null, "parents": [{"sha": "19e30111ee94b4d0a87f0f900ad168bd74340510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e30111ee94b4d0a87f0f900ad168bd74340510", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19e30111ee94b4d0a87f0f900ad168bd74340510"}], "stats": {"total": 2170, "additions": 1872, "deletions": 298}, "files": [{"sha": "7228afcbc6f6fddf54db5ffabf36759d6ce95c09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,3 +1,51 @@\n+2017-02-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* gimplify.c (gimplify_scan_omp_clauses): No special handling for\n+\tOMP_CLAUSE_TILE.\n+\t(gimplify_adjust_omp_clauses): Don't delete TILE.\n+\t(gimplify_omp_for): Deal with TILE.\n+\t* internal-fn.c (expand_GOACC_TILE): New function.\n+\t* internal-fn.def (GOACC_DIM_POS): Comment may be overly conservative.\n+\t(GOACC_TILE): New.\n+\t* omp-expand.c (struct oacc_collapse): Add tile and outer fields.\n+\t(expand_oacc_collapse_init): Add LOC paramter.  Initialize tile\n+\telement fields.\n+\t(expand_oacc_collapse_vars): Add INNER parm, adjust for tiling,\n+\tavoid DIV for outermost collapse var.\n+\t(expand_oacc_for): Insert tile element loop as needed.  Adjust.\n+\tRemove out of date comments, fix whitespace.\n+\t* omp-general.c (omp_extract_for_data): Deal with tiling.\n+\t* omp-general.h (enum oacc_loop_flags): Add OLF_TILE flag,\n+\tadjust OLF_DIM_BASE value.\n+\t(struct omp_for_data): Add tiling field.\n+\t* omp-low.c (scan_sharing_clauses): Allow OMP_CLAUSE_TILE.\n+\t(lower_oacc_head_mark): Add OLF_TILE as appropriate.  Ensure 2 levels\n+\tfor auto loops.  Remove default auto determining, moved to\n+\toacc_loop_fixed_partitions.\n+\t* omp-offload.c (struct oacc_loop): Change 'ifns' to vector of call\n+\tstmts, add e_mask field.\n+\t(oacc_dim_call): New function, abstracted out from oacc_thread_numbers.\n+\t(oacc_thread_numbers): Use oacc_dim_call.\n+\t(oacc_xform_tile): New.\n+\t(new_oacc_loop_raw): Initialize e_mask, adjust for ifns vector.\n+\t(finish_oacc_loop): Adjust for ifns vector.\n+\t(oacc_loop_discover_walk): Append loop abstraction sites to list,\n+\tadd case for GOACC_TILE fns.\n+\t(oacc_loop_xform_loop): Delete.\n+\t(oacc_loop_process): Iterate over call list directly, and add\n+\thandling for GOACC_TILE fns.\n+\t(oacc_loop_fixed_partitions): Determine default auto, deal with TILE,\n+\tdump partitioning.\n+\t(oacc_loop_auto_partitions): Add outer_assign parm. Assign all but\n+\tvector partitioning to outer loops.  Assign 2 partitions to loops\n+\twhen available. Add TILE handling.\n+\t(oacc_loop_partition): Adjust oacc_loop_auto_partitions call.\n+\t(execite_oacc_device_lower): Process GOACC_TILE fns, ignore unknown specs.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses): Allow OMP_CLAUSE_TILE.\n+\t* tree.c (omp_clause_num_ops): Adjust TILE ops.\n+\t* tree.h (OMP_CLAUSE_TILE_ITERVAR, OMP_CLAUSE_TILE_COUNT): New.\n+\n 2017-02-09  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* configure.ac (ACX_BUGURL): Update."}, {"sha": "c05721df7eccdeb0576c2437d95afbe87871a149", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,3 +1,11 @@\n+2016-02-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* c-parser.c (c_parser_omp_clause_collapse): Disallow tile.\n+\t(c_parser_oacc_clause_tile): Disallow collapse. Fix parsing and\n+\tsemantic checking.\n+\t* c-parser.c (c_parser_omp_for_loop): Accept tiling constructs.\n+\n 2017-02-07  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-parser.c (c_parser_gimple_expr_list): Simplify."}, {"sha": "6e83728b577a0b4759b1bc77134a3c45391c0b93", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -11023,6 +11023,7 @@ c_parser_omp_clause_collapse (c_parser *parser, tree list)\n   location_t loc;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_TILE, \"tile\");\n \n   loc = c_parser_peek_token (parser)->location;\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n@@ -11933,27 +11934,31 @@ static tree\n c_parser_oacc_clause_tile (c_parser *parser, tree list)\n {\n   tree c, expr = error_mark_node;\n-  location_t loc, expr_loc;\n+  location_t loc;\n   tree tile = NULL_TREE;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_TILE, \"tile\");\n+  check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\");\n \n   loc = c_parser_peek_token (parser)->location;\n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return list;\n \n   do\n     {\n+      if (tile && !c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n+\treturn list;\n+\n       if (c_parser_next_token_is (parser, CPP_MULT)\n \t  && (c_parser_peek_2nd_token (parser)->type == CPP_COMMA\n \t      || c_parser_peek_2nd_token (parser)->type == CPP_CLOSE_PAREN))\n \t{\n \t  c_parser_consume_token (parser);\n-\t  expr = integer_minus_one_node;\n+\t  expr = integer_zero_node;\n \t}\n       else\n \t{\n-\t  expr_loc = c_parser_peek_token (parser)->location;\n+\t  location_t expr_loc = c_parser_peek_token (parser)->location;\n \t  c_expr cexpr = c_parser_expr_no_commas (parser, NULL);\n \t  cexpr = convert_lvalue_to_rvalue (expr_loc, cexpr, false, true);\n \t  expr = cexpr.value;\n@@ -11965,28 +11970,19 @@ c_parser_oacc_clause_tile (c_parser *parser, tree list)\n \t      return list;\n \t    }\n \n-\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n-\t    {\n-\t      c_parser_error (parser, \"%<tile%> value must be integral\");\n-\t      return list;\n-\t    }\n-\n \t  expr = c_fully_fold (expr, false, NULL);\n \n-\t  /* Attempt to statically determine when expr isn't positive.  */\n-\t  c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, expr,\n-\t\t\t       build_int_cst (TREE_TYPE (expr), 0));\n-\t  protected_set_expr_location (c, expr_loc);\n-\t  if (c == boolean_true_node)\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+\t      || !tree_fits_shwi_p (expr)\n+\t      || tree_to_shwi (expr) <= 0)\n \t    {\n-\t      warning_at (expr_loc, 0,\"%<tile%> value must be positive\");\n-\t      expr = integer_one_node;\n+\t      error_at (expr_loc, \"%<tile%> argument needs positive\"\n+\t\t\t\" integral constant\");\n+\t      expr = integer_zero_node;\n \t    }\n \t}\n \n       tile = tree_cons (NULL_TREE, expr, tile);\n-      if (c_parser_next_token_is (parser, CPP_COMMA))\n-\tc_parser_consume_token (parser);\n     }\n   while (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN));\n \n@@ -14910,11 +14906,17 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   bool fail = false, open_brace_parsed = false;\n   int i, collapse = 1, ordered = 0, count, nbraces = 0;\n   location_t for_loc;\n+  bool tiling = false;\n   vec<tree, va_gc> *for_block = make_tree_vector ();\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n       collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (cl));\n+    else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_TILE)\n+      {\n+\ttiling = true;\n+\tcollapse = list_length (OMP_CLAUSE_TILE_LIST (cl));\n+      }\n     else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_ORDERED\n \t     && OMP_CLAUSE_ORDERED_EXPR (cl))\n       {\n@@ -14944,7 +14946,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t  pc = &OMP_CLAUSE_CHAIN (*pc);\n     }\n \n-  gcc_assert (collapse >= 1 && ordered >= 0);\n+  gcc_assert (tiling || (collapse >= 1 && ordered >= 0));\n   count = ordered ? ordered : collapse;\n \n   declv = make_tree_vec (count);"}, {"sha": "291dcddcde17af81633b14040630d01a96e8d2bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,3 +1,16 @@\n+2016-02-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* parser.c (cp_parser_oacc_clause_tile): Disallow collapse.  Fix\n+\tparsing.  Parse constant expression. Remove semantic checking.\n+\t(cp_parser_omp_clause_collapse): Disallow tile.\n+\t(cp_parser_omp_for_loop): Deal with tile clause.  Don't emit a parse\n+\terror about missing for after already emitting one.  Use more\n+\tconventional for idiom for unbounded loop.\n+\t* pt.c (tsubst_omp_clauses): Handle OMP_CLAUSE_TILE.\n+\t* semantics.c (finish_omp_clauses): Correct TILE semantic check.\n+\t(finish_omp_for): Deal with tile clause.\n+\n 2017-02-07  Nathan Sidwell  <nathan@acm.org>\n \n \t* method.c (synthesized_method_base_walk): New.  Broken out of ..."}, {"sha": "41b08e1a7a30eedff870b7b5972f8dde23e51fae", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -31274,30 +31274,33 @@ cp_parser_oacc_clause_tile (cp_parser *parser, location_t clause_loc, tree list)\n   tree c, expr = error_mark_node;\n   tree tile = NULL_TREE;\n \n+  /* Collapse and tile are mutually exclusive.  (The spec doesn't say\n+     so, but the spec authors never considered such a case and have\n+     differing opinions on what it might mean, including 'not\n+     allowed'.)  */\n   check_no_duplicate_clause (list, OMP_CLAUSE_TILE, \"tile\", clause_loc);\n+  check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\",\n+\t\t\t     clause_loc);\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n   do\n     {\n+      if (tile && !cp_parser_require (parser, CPP_COMMA, RT_COMMA))\n+\treturn list;\n+      \n       if (cp_lexer_next_token_is (parser->lexer, CPP_MULT)\n \t  && (cp_lexer_nth_token_is (parser->lexer, 2, CPP_COMMA)\n \t      || cp_lexer_nth_token_is (parser->lexer, 2, CPP_CLOSE_PAREN)))\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  expr = integer_minus_one_node;\n+\t  expr = integer_zero_node;\n \t}\n       else\n-\texpr = cp_parser_assignment_expression (parser, NULL, false, false);\n-\n-      if (expr == error_mark_node)\n-\treturn list;\n+\texpr = cp_parser_constant_expression (parser);\n \n       tile = tree_cons (NULL_TREE, expr, tile);\n-\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\tcp_lexer_consume_token (parser->lexer);\n     }\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN));\n \n@@ -31410,6 +31413,7 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location\n     }\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\", location);\n+  check_no_duplicate_clause (list, OMP_CLAUSE_TILE, \"tile\", location);\n   c = build_omp_clause (loc, OMP_CLAUSE_COLLAPSE);\n   OMP_CLAUSE_CHAIN (c) = list;\n   OMP_CLAUSE_COLLAPSE_EXPR (c) = num;\n@@ -34416,10 +34420,16 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n   int i, collapse = 1, ordered = 0, count, nbraces = 0;\n   vec<tree, va_gc> *for_block = make_tree_vector ();\n   auto_vec<tree, 4> orig_inits;\n+  bool tiling = false;\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n       collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (cl));\n+    else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_TILE)\n+      {\n+\ttiling = true;\n+\tcollapse = list_length (OMP_CLAUSE_TILE_LIST (cl));\n+      }\n     else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_ORDERED\n \t     && OMP_CLAUSE_ORDERED_EXPR (cl))\n       {\n@@ -34449,7 +34459,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t  pc = &OMP_CLAUSE_CHAIN (*pc);\n     }\n \n-  gcc_assert (collapse >= 1 && ordered >= 0);\n+  gcc_assert (tiling || (collapse >= 1 && ordered >= 0));\n   count = ordered ? ordered : collapse;\n \n   declv = make_tree_vec (count);\n@@ -34468,13 +34478,15 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       if (code != CILK_FOR\n \t  && !cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n \t{\n-\t  cp_parser_error (parser, \"for statement expected\");\n+\t  if (!collapse_err)\n+\t    cp_parser_error (parser, \"for statement expected\");\n \t  return NULL;\n \t}\n       if (code == CILK_FOR\n \t  && !cp_lexer_next_token_is_keyword (parser->lexer, RID_CILK_FOR))\n \t{\n-\t  cp_parser_error (parser, \"_Cilk_for statement expected\");\n+\t  if (!collapse_err)\n+\t    cp_parser_error (parser, \"_Cilk_for statement expected\");\n \t  return NULL;\n \t}\n       loc = cp_lexer_consume_token (parser->lexer)->location;\n@@ -34634,7 +34646,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t nested.  Hopefully the final version clarifies this.\n \t For now handle (multiple) {'s and empty statements.  */\n       cp_parser_parse_tentatively (parser);\n-      do\n+      for (;;)\n \t{\n \t  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n \t    break;\n@@ -34649,14 +34661,13 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t  else\n \t    {\n \t      loc = cp_lexer_peek_token (parser->lexer)->location;\n-\t      error_at (loc, \"not enough collapsed for loops\");\n+\t      error_at (loc, \"not enough for loops to collapse\");\n \t      collapse_err = true;\n \t      cp_parser_abort_tentative_parse (parser);\n \t      declv = NULL_TREE;\n \t      break;\n \t    }\n \t}\n-      while (1);\n \n       if (declv)\n \t{"}, {"sha": "8863c281ad7cac5d57fff8da3f02b64c2057bee9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -15078,6 +15078,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl);\n \t  break;\n+\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n@@ -15172,19 +15173,6 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n \t  break;\n-\tcase OMP_CLAUSE_TILE:\n-\t  {\n-\t    tree lnc, loc;\n-\t    for (lnc = OMP_CLAUSE_TILE_LIST (nc),\n-\t\t   loc = OMP_CLAUSE_TILE_LIST (oc);\n-\t\t loc;\n-\t\t loc = TREE_CHAIN (loc), lnc = TREE_CHAIN (lnc))\n-\t      {\n-\t\tTREE_VALUE (lnc) = tsubst_expr (TREE_VALUE (loc), args,\n-\t\t\t\t\t\tcomplain, in_decl, false);\n-\t      }\n-\t  }\n-\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "e9fc4aa27977b61492e773d38ddee90e5cfb0b12", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -7099,22 +7099,25 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      else if (!type_dependent_expression_p (t)\n \t\t       && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t\t{\n-\t\t  error (\"%<tile%> value must be integral\");\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<tile%> argument needs integral type\");\n \t\t  remove = true;\n \t\t}\n \t      else\n \t\t{\n \t\t  t = mark_rvalue_use (t);\n \t\t  if (!processing_template_decl)\n \t\t    {\n+\t\t      /* Zero is used to indicate '*', we permit you\n+\t\t\t to get there via an ICE of value zero.  */\n \t\t      t = maybe_constant_value (t);\n-\t\t      if (TREE_CODE (t) == INTEGER_CST\n-\t\t\t  && tree_int_cst_sgn (t) != 1\n-\t\t\t  && t != integer_minus_one_node)\n+\t\t      if (!tree_fits_shwi_p (t)\n+\t\t\t  || tree_to_shwi (t) < 0)\n \t\t\t{\n-\t\t\t  warning_at (OMP_CLAUSE_LOCATION (c), 0,\n-\t\t\t\t      \"%<tile%> value must be positive\");\n-\t\t\t  t = integer_one_node;\n+\t\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t    \"%<tile%> argument needs positive \"\n+\t\t\t\t    \"integral constant\");\n+\t\t\t  remove = true;\n \t\t\t}\n \t\t    }\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n@@ -8013,11 +8016,19 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (incrv));\n   if (TREE_VEC_LENGTH (declv) > 1)\n     {\n-      tree c = omp_find_clause (clauses, OMP_CLAUSE_COLLAPSE);\n+      tree c;\n+\n+      c = omp_find_clause (clauses, OMP_CLAUSE_TILE);\n       if (c)\n-\tcollapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (c));\n-      if (collapse != TREE_VEC_LENGTH (declv))\n-\tordered = TREE_VEC_LENGTH (declv);\n+\tcollapse = list_length (OMP_CLAUSE_TILE_LIST (c));\n+      else\n+\t{\n+\t  c = omp_find_clause (clauses, OMP_CLAUSE_COLLAPSE);\n+\t  if (c)\n+\t    collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (c));\n+\t  if (collapse != TREE_VEC_LENGTH (declv))\n+\t    ordered = TREE_VEC_LENGTH (declv);\n+\t}\n     }\n   for (i = 0; i < TREE_VEC_LENGTH (declv); i++)\n     {"}, {"sha": "3488f01e7cdaa54bebbe8e342ddd1e2410f0eda1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,3 +1,12 @@\n+2017-02-09  Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* openmp.c (resolve_omp_clauses): Error on directives\n+\tcontaining both tile and collapse clauses.\n+\t(resolve_oacc_loop_blocks): Represent '*' tile arguments as zero.\n+\t* trans-openmp.c (gfc_trans_omp_do): Lower tiled loops like\n+\tcollapsed loops.\n+\n 2017-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* trans-types.c\t(gfc_get_int_kind_from_width_isofortranen):  Choose"}, {"sha": "3ca23493251f281c31726219a9b96a7da44078de", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -4754,6 +4754,8 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n     if (omp_clauses->wait_list)\n       for (el = omp_clauses->wait_list; el; el = el->next)\n \tresolve_scalar_int_expr (el->expr, \"WAIT\");\n+  if (omp_clauses->collapse && omp_clauses->tile_list)\n+    gfc_error (\"Incompatible use of TILE and COLLAPSE at %L\", &code->loc);\n   if (omp_clauses->depend_source && code->op != EXEC_OMP_ORDERED)\n     gfc_error (\"SOURCE dependence type only allowed \"\n \t       \"on ORDERED directive at %L\", &code->loc);\n@@ -5900,11 +5902,11 @@ resolve_oacc_loop_blocks (gfc_code *code)\n \t  if (el->expr == NULL)\n \t    {\n \t      /* NULL expressions are used to represent '*' arguments.\n-\t\t Convert those to a -1 expressions.  */\n+\t\t Convert those to a 0 expressions.  */\n \t      el->expr = gfc_get_constant_expr (BT_INTEGER,\n \t\t\t\t\t\tgfc_default_integer_kind,\n \t\t\t\t\t\t&code->loc);\n-\t      mpz_set_si (el->expr->value.integer, -1);\n+\t      mpz_set_si (el->expr->value.integer, 0);\n \t    }\n \t  else\n \t    {"}, {"sha": "662036f514db105c685deacc1a4da19b88b037d9", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -3488,6 +3488,17 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n   dovar_init *di;\n   unsigned ix;\n   vec<tree, va_heap, vl_embed> *saved_doacross_steps = doacross_steps;\n+  gfc_expr_list *tile = do_clauses ? do_clauses->tile_list : clauses->tile_list;\n+\n+  /* Both collapsed and tiled loops are lowered the same way.  In\n+     OpenACC, those clauses are not compatible, so prioritize the tile\n+     clause, if present.  */\n+  if (tile)\n+    {\n+      collapse = 0;\n+      for (gfc_expr_list *el = tile; el; el = el->next)\n+\tcollapse++;\n+    }\n \n   doacross_steps = NULL;\n   if (clauses->orderedc)"}, {"sha": "dd73fc258e59ea2e04e961f8967460c580768831", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -8340,20 +8340,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    remove = true;\n \t  break;\n \n-\tcase OMP_CLAUSE_TILE:\n-\t  for (tree list = OMP_CLAUSE_TILE_LIST (c); !remove && list;\n-\t       list = TREE_CHAIN (list))\n-\t    {\n-\t      if (gimplify_expr (&TREE_VALUE (list), pre_p, NULL,\n-\t\t\t\t is_gimple_val, fb_rvalue) == GS_ERROR)\n-\t\tremove = true;\n-\t    }\n-\t  break;\n-\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n \tcase OMP_CLAUSE_INDEPENDENT:\n@@ -9122,13 +9113,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_VECTOR:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n-\t  break;\n-\n \tcase OMP_CLAUSE_TILE:\n-\t  /* We're not yet making use of the information provided by OpenACC\n-\t     tile clauses.  Discard these here, to simplify later middle end\n-\t     processing.  */\n-\t  remove = true;\n \t  break;\n \n \tdefault:\n@@ -9583,10 +9568,13 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t\t\t\t\t (OMP_FOR_INIT (for_stmt))\n \t\t\t\t\t       * 2);\n     }\n-  int collapse = 1;\n+  int collapse = 1, tile = 0;\n   c = omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_COLLAPSE);\n   if (c)\n     collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (c));\n+  c = omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_TILE);\n+  if (c)\n+    tile = list_length (OMP_CLAUSE_TILE_LIST (c));\n   for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n     {\n       t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n@@ -10000,7 +9988,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  OMP_CLAUSE_LINEAR_STEP (c2) = OMP_CLAUSE_LINEAR_STEP (c);\n \t}\n \n-      if ((var != decl || collapse > 1) && orig_for_stmt == for_stmt)\n+      if ((var != decl || collapse > 1 || tile) && orig_for_stmt == for_stmt)\n \t{\n \t  for (c = OMP_FOR_CLAUSES (for_stmt); c ; c = OMP_CLAUSE_CHAIN (c))\n \t    if (((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE"}, {"sha": "1ccc803631af9f0a9fe39142818e678a3ad7e314", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -2479,6 +2479,14 @@ expand_GOACC_REDUCTION (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* This is expanded by oacc_device_lower pass.  */\n+\n+static void\n+expand_GOACC_TILE (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Set errno to EDOM.  */\n \n static void"}, {"sha": "9f682322c871cc4e6b26246589223ff1bdfd19d8", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -187,7 +187,7 @@ DEF_INTERNAL_FN (PHI, 0, NULL)\n    dimension.  DIM_POS is pure (and not const) so that it isn't\n    thought to clobber memory and can be gcse'd within a single\n    parallel region, but not across FORK/JOIN boundaries.  They take a\n-   single INTEGER_CST argument.  */\n+   single INTEGER_CST argument.  This might be overly conservative.  */\n DEF_INTERNAL_FN (GOACC_DIM_SIZE, ECF_CONST | ECF_NOTHROW | ECF_LEAF, \".\")\n DEF_INTERNAL_FN (GOACC_DIM_POS, ECF_PURE | ECF_NOTHROW | ECF_LEAF, \".\")\n \n@@ -197,6 +197,10 @@ DEF_INTERNAL_FN (GOACC_LOOP, ECF_PURE | ECF_NOTHROW, NULL)\n /* OpenACC reduction abstraction.  See internal-fn.h  for usage.  */\n DEF_INTERNAL_FN (GOACC_REDUCTION, ECF_NOTHROW | ECF_LEAF, NULL)\n \n+/* Openacc tile abstraction. Describes the spans of the element loop.\n+   GOACC_TILE (num-loops, loop-no, tile-arg, tile-mask, element-mask).  */\n+DEF_INTERNAL_FN (GOACC_TILE, ECF_NOTHROW | ECF_LEAF, NULL)\n+\n /* Set errno to EDOM, if GCC knows how to do that directly for the\n    current target.  */\n DEF_INTERNAL_FN (SET_EDOM, ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "55e54e4dbf81792536e372cdcdee36ac89ab7493", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 191, "deletions": 33, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1409,7 +1409,9 @@ struct oacc_collapse\n {\n   tree base;  /* Base value.  */\n   tree iters; /* Number of steps.  */\n-  tree step;  /* step size.  */\n+  tree step;  /* Step size.  */\n+  tree tile;  /* Tile increment (if tiled).  */\n+  tree outer; /* Tile iterator var. */\n };\n \n /* Helper for expand_oacc_for.  Determine collapsed loop information.\n@@ -1419,15 +1421,20 @@ struct oacc_collapse\n static tree\n expand_oacc_collapse_init (const struct omp_for_data *fd,\n \t\t\t   gimple_stmt_iterator *gsi,\n-\t\t\t   oacc_collapse *counts, tree bound_type)\n+\t\t\t   oacc_collapse *counts, tree bound_type,\n+\t\t\t   location_t loc)\n {\n+  tree tiling = fd->tiling;\n   tree total = build_int_cst (bound_type, 1);\n   int ix;\n \n   gcc_assert (integer_onep (fd->loop.step));\n   gcc_assert (integer_zerop (fd->loop.n1));\n \n-  for (ix = 0; ix != fd->collapse; ix++)\n+  /* When tiling, the first operand of the tile clause applies to the\n+     innermost loop, and we work outwards from there.  Seems\n+     backwards, but whatever.  */\n+  for (ix = fd->collapse; ix--;)\n     {\n       const omp_for_data_loop *loop = &fd->loops[ix];\n \n@@ -1442,6 +1449,30 @@ expand_oacc_collapse_init (const struct omp_for_data *fd,\n       if (POINTER_TYPE_P (diff_type) || TYPE_UNSIGNED (diff_type))\n \tdiff_type = signed_type_for (diff_type);\n \n+      if (tiling)\n+\t{\n+\t  tree num = build_int_cst (integer_type_node, fd->collapse);\n+\t  tree loop_no = build_int_cst (integer_type_node, ix);\n+\t  tree tile = TREE_VALUE (tiling);\n+\t  gcall *call\n+\t    = gimple_build_call_internal (IFN_GOACC_TILE, 5, num, loop_no, tile,\n+\t\t\t\t\t  /* gwv-outer=*/integer_zero_node,\n+\t\t\t\t\t  /* gwv-inner=*/integer_zero_node);\n+\n+\t  counts[ix].outer = create_tmp_var (iter_type, \".outer\");\n+\t  counts[ix].tile = create_tmp_var (diff_type, \".tile\");\n+\t  gimple_call_set_lhs (call, counts[ix].tile);\n+\t  gimple_set_location (call, loc);\n+\t  gsi_insert_before (gsi, call, GSI_SAME_STMT);\n+\n+\t  tiling = TREE_CHAIN (tiling);\n+\t}\n+      else\n+\t{\n+\t  counts[ix].tile = NULL;\n+\t  counts[ix].outer = loop->v;\n+\t}\n+\n       tree b = loop->n1;\n       tree e = loop->n2;\n       tree s = loop->step;\n@@ -1495,13 +1526,14 @@ expand_oacc_collapse_init (const struct omp_for_data *fd,\n   return total;\n }\n \n-/* Emit initializers for collapsed loop members.  IVAR is the outer\n+/* Emit initializers for collapsed loop members.  INNER is true if\n+   this is for the element loop of a TILE.  IVAR is the outer\n    loop iteration variable, from which collapsed loop iteration values\n    are  calculated.  COUNTS array has been initialized by\n    expand_oacc_collapse_inits.  */\n \n static void\n-expand_oacc_collapse_vars (const struct omp_for_data *fd,\n+expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,\n \t\t\t   gimple_stmt_iterator *gsi,\n \t\t\t   const oacc_collapse *counts, tree ivar)\n {\n@@ -1513,7 +1545,8 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd,\n     {\n       const omp_for_data_loop *loop = &fd->loops[ix];\n       const oacc_collapse *collapse = &counts[ix];\n-      tree iter_type = TREE_TYPE (loop->v);\n+      tree v = inner ? loop->v : collapse->outer;\n+      tree iter_type = TREE_TYPE (v);\n       tree diff_type = TREE_TYPE (collapse->step);\n       tree plus_type = iter_type;\n       enum tree_code plus_code = PLUS_EXPR;\n@@ -1525,24 +1558,25 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd,\n \t  plus_type = sizetype;\n \t}\n \n-      expr = fold_build2 (TRUNC_MOD_EXPR, ivar_type, ivar,\n-\t\t\t  fold_convert (ivar_type, collapse->iters));\n+      expr = ivar;\n+      if (ix)\n+\t{\n+\t  tree mod = fold_convert (ivar_type, collapse->iters);\n+\t  ivar = fold_build2 (TRUNC_DIV_EXPR, ivar_type, expr, mod);\n+\t  expr = fold_build2 (TRUNC_MOD_EXPR, ivar_type, expr, mod);\n+\t  ivar = force_gimple_operand_gsi (gsi, ivar, true, NULL_TREE,\n+\t\t\t\t\t   true, GSI_SAME_STMT);\n+\t}\n+\n       expr = fold_build2 (MULT_EXPR, diff_type, fold_convert (diff_type, expr),\n \t\t\t  collapse->step);\n-      expr = fold_build2 (plus_code, iter_type, collapse->base,\n+      expr = fold_build2 (plus_code, iter_type,\n+\t\t\t  inner ? collapse->outer : collapse->base,\n \t\t\t  fold_convert (plus_type, expr));\n       expr = force_gimple_operand_gsi (gsi, expr, false, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n-      gassign *ass = gimple_build_assign (loop->v, expr);\n+      gassign *ass = gimple_build_assign (v, expr);\n       gsi_insert_before (gsi, ass, GSI_SAME_STMT);\n-\n-      if (ix)\n-\t{\n-\t  expr = fold_build2 (TRUNC_DIV_EXPR, ivar_type, ivar,\n-\t\t\t      fold_convert (ivar_type, collapse->iters));\n-\t  ivar = force_gimple_operand_gsi (gsi, expr, true, NULL_TREE,\n-\t\t\t\t\t   true, GSI_SAME_STMT);\n-\t}\n     }\n }\n \n@@ -5230,7 +5264,8 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n    where LTGT is < or >.  We may have a specified chunking size, CHUNKING\n    (constant 0 for no chunking) and we will have a GWV partitioning\n    mask, specifying dimensions over which the loop is to be\n-   partitioned (see note below).  We generate code that looks like:\n+   partitioned (see note below).  We generate code that looks like\n+   (this ignores tiling):\n \n    <entry_bb> [incoming FALL->body, BRANCH->exit]\n      typedef signedintify (typeof (V)) T;  // underlying signed integral type\n@@ -5260,11 +5295,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n    <exit_bb> [incoming]\n      V = B + ((range -/+ 1) / S +/- 1) * S [*]\n \n-   [*] Needed if V live at end of loop\n-\n-   Note: CHUNKING & GWV mask are specified explicitly here.  This is a\n-   transition, and will be specified by a more general mechanism shortly.\n- */\n+   [*] Needed if V live at end of loop.  */\n \n static void\n expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n@@ -5327,9 +5358,16 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n   tree step = create_tmp_var (diff_type, \".step\");\n   bool up = cond_code == LT_EXPR;\n   tree dir = build_int_cst (diff_type, up ? +1 : -1);\n-  bool chunking = !gimple_in_ssa_p (cfun);;\n+  bool chunking = !gimple_in_ssa_p (cfun);\n   bool negating;\n \n+  /* Tiling vars.  */\n+  tree tile_size = NULL_TREE;\n+  tree element_s = NULL_TREE;\n+  tree e_bound = NULL_TREE, e_offset = NULL_TREE, e_step = NULL_TREE;\n+  basic_block elem_body_bb = NULL;\n+  basic_block elem_cont_bb = NULL;\n+\n   /* SSA instances.  */\n   tree offset_incr = NULL_TREE;\n   tree offset_init = NULL_TREE;\n@@ -5360,11 +5398,12 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n       gwv = build_int_cst (integer_type_node, GOMP_DIM_MASK (GOMP_DIM_GANG));\n     }\n \n-  if (fd->collapse > 1)\n+  if (fd->collapse > 1 || fd->tiling)\n     {\n+      gcc_assert (!gimple_in_ssa_p (cfun) && up);\n       counts = XALLOCAVEC (struct oacc_collapse, fd->collapse);\n       tree total = expand_oacc_collapse_init (fd, &gsi, counts,\n-\t\t\t\t\t      TREE_TYPE (fd->loop.n2));\n+\t\t\t\t\t      TREE_TYPE (fd->loop.n2), loc);\n \n       if (SSA_VAR_P (fd->loop.n2))\n \t{\n@@ -5373,7 +5412,6 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n \t  ass = gimple_build_assign (fd->loop.n2, total);\n \t  gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n \t}\n-\n     }\n \n   tree b = fd->loop.n1;\n@@ -5397,6 +5435,29 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n   expr = fold_convert (diff_type, chunk_size);\n   chunk_size = force_gimple_operand_gsi (&gsi, expr, true,\n \t\t\t\t\t NULL_TREE, true, GSI_SAME_STMT);\n+\n+  if (fd->tiling)\n+    {\n+      /* Determine the tile size and element step,\n+\t modify the outer loop step size.  */\n+      tile_size = create_tmp_var (diff_type, \".tile_size\");\n+      expr = build_int_cst (diff_type, 1);\n+      for (int ix = 0; ix < fd->collapse; ix++)\n+\texpr = fold_build2 (MULT_EXPR, diff_type, counts[ix].tile, expr);\n+      expr = force_gimple_operand_gsi (&gsi, expr, true,\n+\t\t\t\t       NULL_TREE, true, GSI_SAME_STMT);\n+      ass = gimple_build_assign (tile_size, expr);\n+      gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n+\n+      element_s = create_tmp_var (diff_type, \".element_s\");\n+      ass = gimple_build_assign (element_s, s);\n+      gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n+\n+      expr = fold_build2 (MULT_EXPR, diff_type, s, tile_size);\n+      s = force_gimple_operand_gsi (&gsi, expr, true,\n+\t\t\t\t    NULL_TREE, true, GSI_SAME_STMT);\n+    }\n+\n   /* Determine the range, avoiding possible unsigned->signed overflow.  */\n   negating = !up && TYPE_UNSIGNED (iter_type);\n   expr = fold_build2 (MINUS_EXPR, plus_type,\n@@ -5501,8 +5562,72 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n \t\t\t\t       true, GSI_SAME_STMT);\n       ass = gimple_build_assign (v, expr);\n       gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n-      if (fd->collapse > 1)\n-\texpand_oacc_collapse_vars (fd, &gsi, counts, v);\n+\n+      if (fd->collapse > 1 || fd->tiling)\n+\texpand_oacc_collapse_vars (fd, false, &gsi, counts, v);\n+\n+      if (fd->tiling)\n+\t{\n+\t  /* Determine the range of the element loop -- usually simply\n+\t     the tile_size, but could be smaller if the final\n+\t     iteration of the outer loop is a partial tile.  */\n+\t  tree e_range = create_tmp_var (diff_type, \".e_range\");\n+\n+\t  expr = build2 (MIN_EXPR, diff_type,\n+\t\t\t build2 (MINUS_EXPR, diff_type, bound, offset),\n+\t\t\t build2 (MULT_EXPR, diff_type, tile_size,\n+\t\t\t\t element_s));\n+\t  expr = force_gimple_operand_gsi (&gsi, expr, false, NULL_TREE,\n+\t\t\t\t\t   true, GSI_SAME_STMT);\n+\t  ass = gimple_build_assign (e_range, expr);\n+\t  gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n+\n+\t  /* Determine bound, offset & step of inner loop. */\n+\t  e_bound = create_tmp_var (diff_type, \".e_bound\");\n+\t  e_offset = create_tmp_var (diff_type, \".e_offset\");\n+\t  e_step = create_tmp_var (diff_type, \".e_step\");\n+\n+\t  /* Mark these as element loops.  */\n+\t  tree t, e_gwv = integer_minus_one_node;\n+\t  tree chunk = build_int_cst (diff_type, 0); /* Never chunked.  */\n+\n+\t  t = build_int_cst (integer_type_node, IFN_GOACC_LOOP_OFFSET);\n+\t  call = gimple_build_call_internal (IFN_GOACC_LOOP, 7, t, dir, e_range,\n+\t\t\t\t\t     element_s, chunk, e_gwv, chunk);\n+\t  gimple_call_set_lhs (call, e_offset);\n+\t  gimple_set_location (call, loc);\n+\t  gsi_insert_before (&gsi, call, GSI_SAME_STMT);\n+\n+\t  t = build_int_cst (integer_type_node, IFN_GOACC_LOOP_BOUND);\n+\t  call = gimple_build_call_internal (IFN_GOACC_LOOP, 7, t, dir, e_range,\n+\t\t\t\t\t     element_s, chunk, e_gwv, e_offset);\n+\t  gimple_call_set_lhs (call, e_bound);\n+\t  gimple_set_location (call, loc);\n+\t  gsi_insert_before (&gsi, call, GSI_SAME_STMT);\n+\n+\t  t = build_int_cst (integer_type_node, IFN_GOACC_LOOP_STEP);\n+\t  call = gimple_build_call_internal (IFN_GOACC_LOOP, 6, t, dir, e_range,\n+\t\t\t\t\t     element_s, chunk, e_gwv);\n+\t  gimple_call_set_lhs (call, e_step);\n+\t  gimple_set_location (call, loc);\n+\t  gsi_insert_before (&gsi, call, GSI_SAME_STMT);\n+\n+\t  /* Add test and split block.  */\n+\t  expr = build2 (cond_code, boolean_type_node, e_offset, e_bound);\n+\t  stmt = gimple_build_cond_empty (expr);\n+\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  split = split_block (body_bb, stmt);\n+\t  elem_body_bb = split->dest;\n+\t  if (cont_bb == body_bb)\n+\t    cont_bb = elem_body_bb;\n+\t  body_bb = split->src;\n+\n+\t  split->flags ^= EDGE_FALLTHRU | EDGE_TRUE_VALUE;\n+\n+\t  /* Initialize the user's loop vars.  */\n+\t  gsi = gsi_start_bb (elem_body_bb);\n+\t  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset);\n+\t}\n     }\n \n   /* Loop increment goes into cont_bb.  If this is not a loop, we\n@@ -5516,10 +5641,34 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n       gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n       loc = gimple_location (cont_stmt);\n \n+      if (fd->tiling)\n+\t{\n+\t  /* Insert element loop increment and test.  */\n+\t  expr = build2 (PLUS_EXPR, diff_type, e_offset, e_step);\n+\t  expr = force_gimple_operand_gsi (&gsi, expr, false, NULL_TREE,\n+\t\t\t\t\t   true, GSI_SAME_STMT);\n+\t  ass = gimple_build_assign (e_offset, expr);\n+\t  gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n+\t  expr = build2 (cond_code, boolean_type_node, e_offset, e_bound);\n+\n+\t  stmt = gimple_build_cond_empty (expr);\n+\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  split = split_block (cont_bb, stmt);\n+\t  elem_cont_bb = split->src;\n+\t  cont_bb = split->dest;\n+\n+\t  split->flags ^= EDGE_FALLTHRU | EDGE_FALSE_VALUE;\n+\t  make_edge (elem_cont_bb, elem_body_bb, EDGE_TRUE_VALUE);\n+\n+\t  make_edge (body_bb, cont_bb, EDGE_FALSE_VALUE);\n+\n+\t  gsi = gsi_for_stmt (cont_stmt);\n+\t}\n+\n       /* Increment offset.  */\n       if (gimple_in_ssa_p (cfun))\n-\texpr= build2 (plus_code, iter_type, offset,\n-\t\t      fold_convert (plus_type, step));\n+\texpr = build2 (plus_code, iter_type, offset,\n+\t\t       fold_convert (plus_type, step));\n       else\n \texpr = build2 (PLUS_EXPR, diff_type, offset, step);\n       expr = force_gimple_operand_gsi (&gsi, expr, false, NULL_TREE,\n@@ -5592,7 +5741,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n \n   if (cont_bb)\n     {\n-      /* We now have one or two nested loops.  Update the loop\n+      /* We now have one, two or three nested loops.  Update the loop\n \t structures.  */\n       struct loop *parent = entry_bb->loop_father;\n       struct loop *body = body_bb->loop_father;\n@@ -5619,6 +5768,15 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n \t  body_loop->header = body_bb;\n \t  body_loop->latch = cont_bb;\n \t  add_loop (body_loop, parent);\n+\n+\t  if (fd->tiling)\n+\t    {\n+\t      /* Insert tiling's element loop.  */\n+\t      struct loop *inner_loop = alloc_loop ();\n+\t      inner_loop->header = elem_body_bb;\n+\t      inner_loop->latch = elem_cont_bb;\n+\t      add_loop (inner_loop, body_loop);\n+\t    }\n \t}\n     }\n }"}, {"sha": "3f9aec8d6a7dc9329ab823098e5ca954a9a3278f", "filename": "gcc/omp-general.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -133,13 +133,9 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \n   fd->for_stmt = for_stmt;\n   fd->pre = NULL;\n-  if (gimple_omp_for_collapse (for_stmt) > 1)\n-    fd->loops = loops;\n-  else\n-    fd->loops = &fd->loop;\n-\n   fd->have_nowait = distribute || simd;\n   fd->have_ordered = false;\n+  fd->tiling = NULL_TREE;\n   fd->collapse = 1;\n   fd->ordered = 0;\n   fd->sched_kind = OMP_CLAUSE_SCHEDULE_STATIC;\n@@ -184,9 +180,22 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t    collapse_count = &OMP_CLAUSE_COLLAPSE_COUNT (t);\n \t  }\n \tbreak;\n+      case OMP_CLAUSE_TILE:\n+\tfd->tiling = OMP_CLAUSE_TILE_LIST (t);\n+\tfd->collapse = list_length (fd->tiling);\n+\tgcc_assert (fd->collapse);\n+\tcollapse_iter = &OMP_CLAUSE_TILE_ITERVAR (t);\n+\tcollapse_count = &OMP_CLAUSE_TILE_COUNT (t);\n+\tbreak;\n       default:\n \tbreak;\n       }\n+\n+  if (fd->collapse > 1 || fd->tiling)\n+    fd->loops = loops;\n+  else\n+    fd->loops = &fd->loop;\n+\n   if (fd->ordered && fd->collapse == 1 && loops != NULL)\n     {\n       fd->loops = loops;\n@@ -205,7 +214,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n       fd->sched_kind = OMP_CLAUSE_SCHEDULE_STATIC;\n       gcc_assert (fd->chunk_size == NULL);\n     }\n-  gcc_assert (fd->collapse == 1 || collapse_iter != NULL);\n+  gcc_assert ((fd->collapse == 1 && !fd->tiling) || collapse_iter != NULL);\n   if (taskloop)\n     fd->sched_kind = OMP_CLAUSE_SCHEDULE_RUNTIME;\n   if (fd->sched_kind == OMP_CLAUSE_SCHEDULE_RUNTIME)\n@@ -223,7 +232,10 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   int cnt = fd->ordered ? fd->ordered : fd->collapse;\n   for (i = 0; i < cnt; i++)\n     {\n-      if (i == 0 && fd->collapse == 1 && (fd->ordered == 0 || loops == NULL))\n+      if (i == 0\n+\t  && fd->collapse == 1\n+\t  && !fd->tiling\n+\t  && (fd->ordered == 0 || loops == NULL))\n \tloop = &fd->loop;\n       else if (loops != NULL)\n \tloop = loops + i;\n@@ -252,7 +264,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t  || (fd->sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n \t      && !fd->have_ordered))\n \t{\n-\t  if (fd->collapse == 1)\n+\t  if (fd->collapse == 1 && !fd->tiling)\n \t    iter_type = TREE_TYPE (loop->v);\n \t  else if (i == 0\n \t\t   || TYPE_PRECISION (iter_type)\n@@ -383,7 +395,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t*collapse_count = create_tmp_var (iter_type, \".count\");\n     }\n \n-  if (fd->collapse > 1 || (fd->ordered && loops))\n+  if (fd->collapse > 1 || fd->tiling || (fd->ordered && loops))\n     {\n       fd->loop.v = *collapse_iter;\n       fd->loop.n1 = build_int_cst (TREE_TYPE (fd->loop.v), 0);"}, {"sha": "3cf7fcec41fb76137c62ed465941e81810f140f1", "filename": "gcc/omp-general.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -31,9 +31,10 @@ enum oacc_loop_flags {\n   OLF_AUTO\t= 1u << 1,\t/* Compiler chooses axes.  */\n   OLF_INDEPENDENT = 1u << 2,\t/* Iterations are known independent.  */\n   OLF_GANG_STATIC = 1u << 3,\t/* Gang partitioning is static (has op). */\n-\n+  OLF_TILE\t= 1u << 4,\t/* Tiled loop. */\n+  \n   /* Explicitly specified loop axes.  */\n-  OLF_DIM_BASE = 4,\n+  OLF_DIM_BASE = 5,\n   OLF_DIM_GANG   = 1u << (OLF_DIM_BASE + GOMP_DIM_GANG),\n   OLF_DIM_WORKER = 1u << (OLF_DIM_BASE + GOMP_DIM_WORKER),\n   OLF_DIM_VECTOR = 1u << (OLF_DIM_BASE + GOMP_DIM_VECTOR),\n@@ -58,7 +59,8 @@ struct omp_for_data\n   tree chunk_size;\n   gomp_for *for_stmt;\n   tree pre, iter_type;\n-  int collapse;\n+  tree tiling;  /* Tiling values (if non null).  */\n+  int collapse;  /* Collapsed loops, 1 for a non-collapsed loop.  */\n   int ordered;\n   bool have_nowait, have_ordered, simd_schedule;\n   unsigned char sched_modifiers;"}, {"sha": "35df02c70a4ad8dcdc81b25d459fc9b274451a33", "filename": "gcc/omp-low.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1330,6 +1330,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n+\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE__SIMT_:\n \t  break;\n \n@@ -1340,7 +1341,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \t    install_var_local (decl, ctx);\n \t  break;\n \n-\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE__CACHE_:\n \tdefault:\n \t  gcc_unreachable ();\n@@ -1501,11 +1501,11 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n+\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE__GRIDDIM_:\n \tcase OMP_CLAUSE__SIMT_:\n \t  break;\n \n-\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE__CACHE_:\n \tdefault:\n \t  gcc_unreachable ();\n@@ -5610,6 +5610,10 @@ lower_oacc_head_mark (location_t loc, tree ddvar, tree clauses,\n \t  tag |= OLF_INDEPENDENT;\n \t  break;\n \n+\tcase OMP_CLAUSE_TILE:\n+\t  tag |= OLF_TILE;\n+\t  break;\n+\n \tdefault:\n \t  continue;\n \t}\n@@ -5627,14 +5631,20 @@ lower_oacc_head_mark (location_t loc, tree ddvar, tree clauses,\n   if (!tgt || is_oacc_parallel (tgt))\n     tag |= OLF_INDEPENDENT;\n \n-  /* A loop lacking SEQ, GANG, WORKER and/or VECTOR is implicitly AUTO.  */\n-  if (!(tag & (((GOMP_DIM_MASK (GOMP_DIM_MAX) - 1) << OLF_DIM_BASE)\n-\t       | OLF_SEQ)))\n-      tag |= OLF_AUTO;\n+  if (tag & OLF_TILE)\n+    /* Tiling could use all 3 levels.  */ \n+    levels = 3;\n+  else\n+    {\n+      /* A loop lacking SEQ, GANG, WORKER and/or VECTOR could be AUTO.\n+\t Ensure at least one level, or 2 for possible auto\n+\t partitioning */\n+      bool maybe_auto = !(tag & (((GOMP_DIM_MASK (GOMP_DIM_MAX) - 1)\n+\t\t\t\t  << OLF_DIM_BASE) | OLF_SEQ));\n \n-  /* Ensure at least one level.  */\n-  if (!levels)\n-    levels++;\n+      if (levels < 1u + maybe_auto)\n+\tlevels = 1u + maybe_auto;\n+    }\n \n   args.quick_push (build_int_cst (integer_type_node, levels));\n   args.quick_push (build_int_cst (integer_type_node, tag));"}, {"sha": "e4ce48cb8e5e1b7dcc7774a4983b0f2a03ec5666", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 243, "deletions": 103, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -67,9 +67,10 @@ struct oacc_loop\n   tree routine;  /* Pseudo-loop enclosing a routine.  */\n \n   unsigned mask;   /* Partitioning mask.  */\n+  unsigned e_mask; /* Partitioning of element loops (when tiling).  */\n   unsigned inner;  /* Partitioning of inner loops.  */\n   unsigned flags;  /* Partitioning flags.  */\n-  unsigned ifns;   /* Contained loop abstraction functions.  */\n+  vec<gcall *> ifns;  /* Contained loop abstraction functions.  */\n   tree chunk_size; /* Chunk size.  */\n   gcall *head_end; /* Final marker of head sequence.  */\n };\n@@ -217,6 +218,23 @@ omp_finish_file (void)\n     }\n }\n \n+/* Call dim_pos (POS == true) or dim_size (POS == false) builtins for\n+   axis DIM.  Return a tmp var holding the result.  */\n+\n+static tree\n+oacc_dim_call (bool pos, int dim, gimple_seq *seq)\n+{\n+  tree arg = build_int_cst (unsigned_type_node, dim);\n+  tree size = create_tmp_var (integer_type_node);\n+  enum internal_fn fn = pos ? IFN_GOACC_DIM_POS : IFN_GOACC_DIM_SIZE;\n+  gimple *call = gimple_build_call_internal (fn, 1, arg);\n+\n+  gimple_call_set_lhs (call, size);\n+  gimple_seq_add_stmt (seq, call);\n+\n+  return size;\n+}\n+\n /* Find the number of threads (POS = false), or thread number (POS =\n    true) for an OpenACC region partitioned as MASK.  Setup code\n    required for the calculation is added to SEQ.  */\n@@ -231,29 +249,17 @@ oacc_thread_numbers (bool pos, int mask, gimple_seq *seq)\n   for (ix = GOMP_DIM_GANG; ix != GOMP_DIM_MAX; ix++)\n     if (GOMP_DIM_MASK (ix) & mask)\n       {\n-\ttree arg = build_int_cst (unsigned_type_node, ix);\n-\n \tif (res)\n \t  {\n \t    /* We had an outer index, so scale that by the size of\n \t       this dimension.  */\n-\t    tree n = create_tmp_var (integer_type_node);\n-\t    gimple *call\n-\t      = gimple_build_call_internal (IFN_GOACC_DIM_SIZE, 1, arg);\n-\n-\t    gimple_call_set_lhs (call, n);\n-\t    gimple_seq_add_stmt (seq, call);\n+\t    tree n = oacc_dim_call (false, ix, seq);\n \t    res = fold_build2 (MULT_EXPR, integer_type_node, res, n);\n \t  }\n \tif (pos)\n \t  {\n \t    /* Determine index in this dimension.  */\n-\t    tree id = create_tmp_var (integer_type_node);\n-\t    gimple *call = gimple_build_call_internal\n-\t      (IFN_GOACC_DIM_POS, 1, arg);\n-\n-\t    gimple_call_set_lhs (call, id);\n-\t    gimple_seq_add_stmt (seq, call);\n+\t    tree id = oacc_dim_call (true, ix, seq);\n \t    if (res)\n \t      res = fold_build2 (PLUS_EXPR, integer_type_node, res, id);\n \t    else\n@@ -452,6 +458,85 @@ oacc_xform_loop (gcall *call)\n   gsi_replace_with_seq (&gsi, seq, true);\n }\n \n+/* Transform a GOACC_TILE call.  Determines the element loop span for\n+   the specified loop of the nest.  This is 1 if we're not tiling.\n+   \n+   GOACC_TILE (collapse_count, loop_no, tile_arg, gwv_tile, gwv_element);  */\n+\n+static void\n+oacc_xform_tile (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  unsigned collapse = tree_to_uhwi (gimple_call_arg (call, 0));\n+  /* Inner loops have higher loop_nos.  */\n+  unsigned loop_no = tree_to_uhwi (gimple_call_arg (call, 1));\n+  tree tile_size = gimple_call_arg (call, 2);\n+  unsigned e_mask = tree_to_uhwi (gimple_call_arg (call, 4));\n+  tree lhs = gimple_call_lhs (call);\n+  tree type = TREE_TYPE (lhs);\n+  gimple_seq seq = NULL;\n+  tree span = build_int_cst (type, 1);\n+\n+  gcc_assert (!(e_mask\n+\t\t& ~(GOMP_DIM_MASK (GOMP_DIM_VECTOR)\n+\t\t    | GOMP_DIM_MASK (GOMP_DIM_WORKER))));\n+  push_gimplify_context (!seen_error ());\n+\n+#ifndef ACCEL_COMPILER\n+  /* Partitioning disabled on host compilers.  */\n+  e_mask = 0;\n+#endif\n+  if (!e_mask)\n+    /* Not paritioning.  */\n+    span = integer_one_node;\n+  else if (!integer_zerop (tile_size))\n+    /* User explicitly specified size.  */\n+    span = tile_size;\n+  else\n+    {\n+      /* Pick a size based on the paritioning of the element loop and\n+\t the number of loop nests.  */\n+      tree first_size = NULL_TREE;\n+      tree second_size = NULL_TREE;\n+\n+      if (e_mask & GOMP_DIM_MASK (GOMP_DIM_VECTOR))\n+\tfirst_size = oacc_dim_call (false, GOMP_DIM_VECTOR, &seq);\n+      if (e_mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n+\tsecond_size = oacc_dim_call (false, GOMP_DIM_WORKER, &seq);\n+\n+      if (!first_size)\n+\t{\n+\t  first_size = second_size;\n+\t  second_size = NULL_TREE;\n+\t}\n+\n+      if (loop_no + 1 == collapse)\n+\t{\n+\t  span = first_size;\n+\t  if (!loop_no && second_size)\n+\t    span = fold_build2 (MULT_EXPR, TREE_TYPE (span),\n+\t\t\t\tspan, second_size);\n+\t}\n+      else if (loop_no + 2 == collapse)\n+\tspan = second_size;\n+      else\n+\tspan = NULL_TREE;\n+\n+      if (!span)\n+\t/* There's no obvious element size for this loop.  Options\n+\t   are 1, first_size or some non-unity constant (32 is my\n+\t   favourite).   We should gather some statistics.  */\n+\tspan = first_size;\n+    }\n+\n+  span = fold_convert (type, span);\n+  gimplify_assign (lhs, span, &seq);\n+\n+  pop_gimplify_context (NULL);\n+\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n /* Default partitioned and minimum partitioned dimensions.  */\n \n static int oacc_default_dims[GOMP_DIM_MAX];\n@@ -610,8 +695,7 @@ new_oacc_loop_raw (oacc_loop *parent, location_t loc)\n   memset (loop->tails, 0, sizeof (loop->tails));\n   loop->routine = NULL_TREE;\n \n-  loop->mask = loop->flags = loop->inner = 0;\n-  loop->ifns = 0;\n+  loop->mask = loop->e_mask = loop->flags = loop->inner = 0;\n   loop->chunk_size = 0;\n   loop->head_end = NULL;\n \n@@ -674,7 +758,7 @@ static oacc_loop *\n finish_oacc_loop (oacc_loop *loop)\n {\n   /* If the loop has been collapsed, don't partition it.  */\n-  if (!loop->ifns)\n+  if (loop->ifns.is_empty ())\n     loop->mask = loop->flags = 0;\n   return loop->parent;\n }\n@@ -810,9 +894,10 @@ oacc_loop_discover_walk (oacc_loop *loop, basic_block bb)\n \t  break;\n \n \tcase IFN_GOACC_LOOP:\n-\t  /* Count the goacc loop abstraction fns, to determine if the\n-\t     loop was collapsed already.  */\n-\t  loop->ifns++;\n+\tcase IFN_GOACC_TILE:\n+\t  /* Record the abstraction function, so we can manipulate it\n+\t     later.  */\n+\t  loop->ifns.safe_push (call);\n \t  break;\n \n \tcase IFN_UNIQUE:\n@@ -947,51 +1032,6 @@ oacc_loop_xform_head_tail (gcall *from, int level)\n     }\n }\n \n-/* Transform the IFN_GOACC_LOOP internal functions by providing the\n-   determined partitioning mask and chunking argument.  END_MARKER\n-   points at the end IFN_HEAD_TAIL call intgroducing the loop.  IFNS\n-   is the number of IFN_GOACC_LOOP calls for the loop.  MASK_ARG is\n-   the replacement partitioning mask and CHUNK_ARG is the replacement\n-   chunking arg.  */\n-\n-static void\n-oacc_loop_xform_loop (gcall *end_marker, unsigned ifns,\n-\t\t      tree mask_arg, tree chunk_arg)\n-{\n-  gimple_stmt_iterator gsi = gsi_for_stmt (end_marker);\n-\n-  gcc_checking_assert (ifns);\n-  for (;;)\n-    {\n-      for (; !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\n-\t  if (!is_gimple_call (stmt))\n-\t    continue;\n-\n-\t  gcall *call = as_a <gcall *> (stmt);\n-\n-\t  if (!gimple_call_internal_p (call))\n-\t    continue;\n-\n-\t  if (gimple_call_internal_fn (call) != IFN_GOACC_LOOP)\n-\t    continue;\n-\n-\t  *gimple_call_arg_ptr (call, 5) = mask_arg;\n-\t  *gimple_call_arg_ptr (call, 4) = chunk_arg;\n-\t  ifns--;\n-\t  if (!ifns)\n-\t    return;\n-\t}\n-\n-      /* The LOOP_BOUND ifn could be in the single successor\n-\t block.  */\n-      basic_block bb = single_succ (gsi_bb (gsi));\n-      gsi = gsi_start_bb (bb);\n-    }\n-}\n-\n /* Process the discovered OpenACC loops, setting the correct\n    partitioning level etc.  */\n \n@@ -1004,13 +1044,34 @@ oacc_loop_process (oacc_loop *loop)\n   if (loop->mask && !loop->routine)\n     {\n       int ix;\n-      unsigned mask = loop->mask;\n-      unsigned dim = GOMP_DIM_GANG;\n-      tree mask_arg = build_int_cst (unsigned_type_node, mask);\n+      tree mask_arg = build_int_cst (unsigned_type_node, loop->mask);\n+      tree e_mask_arg = build_int_cst (unsigned_type_node, loop->e_mask);\n       tree chunk_arg = loop->chunk_size;\n+      gcall *call;\n+      \n+      for (ix = 0; loop->ifns.iterate (ix, &call); ix++)\n+\tswitch (gimple_call_internal_fn (call))\n+\t  {\n+\t  case IFN_GOACC_LOOP:\n+\t    {\n+\t      bool is_e = gimple_call_arg (call, 5) == integer_minus_one_node;\n+\t      gimple_call_set_arg (call, 5, is_e ? e_mask_arg : mask_arg);\n+\t      if (!is_e)\n+\t\tgimple_call_set_arg (call, 4, chunk_arg);\n+\t    }\n+\t    break;\n \n-      oacc_loop_xform_loop (loop->head_end, loop->ifns, mask_arg, chunk_arg);\n+\t  case IFN_GOACC_TILE:\n+\t    gimple_call_set_arg (call, 3, mask_arg);\n+\t    gimple_call_set_arg (call, 4, e_mask_arg);\n+\t    break;\n \n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\n+      unsigned dim = GOMP_DIM_GANG;\n+      unsigned mask = loop->mask | loop->e_mask;\n       for (ix = 0; ix != GOMP_DIM_MAX && mask; ix++)\n \t{\n \t  while (!(GOMP_DIM_MASK (dim) & mask))\n@@ -1050,10 +1111,16 @@ oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n     {\n       bool auto_par = (loop->flags & OLF_AUTO) != 0;\n       bool seq_par = (loop->flags & OLF_SEQ) != 0;\n-\n+      bool tiling = (loop->flags & OLF_TILE) != 0;\n+      \n       this_mask = ((loop->flags >> OLF_DIM_BASE)\n \t\t   & (GOMP_DIM_MASK (GOMP_DIM_MAX) - 1));\n \n+      /* Apply auto partitioning if this is a non-partitioned regular\n+\t loop, or (no more than) single axis tiled loop.  */\n+      bool maybe_auto\n+\t= !seq_par && this_mask == (tiling ? this_mask & -this_mask : 0);\n+\n       if ((this_mask != 0) + auto_par + seq_par > 1)\n \t{\n \t  if (noisy)\n@@ -1062,7 +1129,7 @@ oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n \t\t      ? \"%<seq%> overrides other OpenACC loop specifiers\"\n \t\t      : \"%<auto%> conflicts with other OpenACC loop \"\n \t\t      \"specifiers\");\n-\t  auto_par = false;\n+\t  maybe_auto = false;\n \t  loop->flags &= ~OLF_AUTO;\n \t  if (seq_par)\n \t    {\n@@ -1071,15 +1138,19 @@ oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n \t      this_mask = 0;\n \t    }\n \t}\n-      if (auto_par && (loop->flags & OLF_INDEPENDENT))\n-\tmask_all |= GOMP_DIM_MASK (GOMP_DIM_MAX);\n+\n+      if (maybe_auto && (loop->flags & OLF_INDEPENDENT))\n+\t{\n+\t  loop->flags |= OLF_AUTO;\n+\t  mask_all |= GOMP_DIM_MASK (GOMP_DIM_MAX);\n+\t}\n     }\n \n   if (this_mask & outer_mask)\n     {\n       const oacc_loop *outer;\n       for (outer = loop->parent; outer; outer = outer->parent)\n-\tif (outer->mask & this_mask)\n+\tif ((outer->mask | outer->e_mask) & this_mask)\n \t  break;\n \n       if (noisy)\n@@ -1125,13 +1196,33 @@ oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n \t}\n     }\n \n-  loop->mask = this_mask;\n   mask_all |= this_mask;\n \n+  if (loop->flags & OLF_TILE)\n+    {\n+      /* When tiling, vector goes to the element loop, and failing\n+\t that we put worker there.  The std doesn't contemplate\n+\t specifying all three.  We choose to put worker and vector on\n+\t the element loops in that case.  */\n+      unsigned this_e_mask = this_mask & GOMP_DIM_MASK (GOMP_DIM_VECTOR);\n+      if (!this_e_mask || this_mask & GOMP_DIM_MASK (GOMP_DIM_GANG))\n+\tthis_e_mask |= this_mask & GOMP_DIM_MASK (GOMP_DIM_WORKER);\n+\n+      loop->e_mask = this_e_mask;\n+      this_mask ^= this_e_mask;\n+    }\n+\n+  loop->mask = this_mask;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Loop %s:%d user specified %d & %d\\n\",\n+\t     LOCATION_FILE (loop->loc), LOCATION_LINE (loop->loc),\n+\t     loop->mask, loop->e_mask);\n+\n   if (loop->child)\n     {\n-      loop->inner = oacc_loop_fixed_partitions (loop->child,\n-\t\t\t\t\t\touter_mask | this_mask);\n+      unsigned tmp_mask = outer_mask | this_mask | loop->e_mask;\n+      loop->inner = oacc_loop_fixed_partitions (loop->child, tmp_mask);\n       mask_all |= loop->inner;\n     }\n \n@@ -1143,44 +1234,68 @@ oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n \n /* Walk the OpenACC loop heirarchy to assign auto-partitioned loops.\n    OUTER_MASK is the partitioning this loop is contained within.\n+   OUTER_ASSIGN is true if an outer loop is being auto-partitioned.\n    Return the cumulative partitioning used by this loop, siblings and\n    children.  */\n \n static unsigned\n-oacc_loop_auto_partitions (oacc_loop *loop, unsigned outer_mask)\n+oacc_loop_auto_partitions (oacc_loop *loop, unsigned outer_mask,\n+\t\t\t   bool outer_assign)\n {\n   bool assign = (loop->flags & OLF_AUTO) && (loop->flags & OLF_INDEPENDENT);\n   bool noisy = true;\n+  bool tiling = loop->flags & OLF_TILE;\n \n #ifdef ACCEL_COMPILER\n   /* When device_type is supported, we want the device compiler to be\n      noisy, if the loop parameters are device_type-specific.  */\n   noisy = false;\n #endif\n \n-  if (assign && outer_mask < GOMP_DIM_MASK (GOMP_DIM_MAX - 1))\n+  if (assign && (!outer_assign | loop->inner))\n     {\n-      /* Allocate the outermost loop at the outermost available\n-\t level.  */\n-      unsigned this_mask = outer_mask + 1;\n+      /* Allocate outermost and non-innermost loops at the outermost\n+\t non-innermost available level.  */\n+      unsigned this_mask = GOMP_DIM_MASK (GOMP_DIM_GANG);\n+\n+      /* Find the first outermost available partition. */\n+      while (this_mask <= outer_mask)\n+\tthis_mask <<= 1;\n+      \n+      /* Grab two axes if tiling, and we've not assigned anything  */\n+      if (tiling && !(loop->mask | loop->e_mask))\n+\tthis_mask |= this_mask << 1;\n+\n+      /* Prohibit the innermost partitioning at the moment.  */\n+      this_mask &= GOMP_DIM_MASK (GOMP_DIM_MAX - 1) - 1;\n+\n+      /* Don't use any dimension explicitly claimed by an inner loop. */\n+      this_mask &= ~loop->inner;\n+\n+      if (tiling && !loop->e_mask)\n+\t{\n+\t  /* If we got two axes, allocate the inner one to the element\n+\t     loop.  */\n+\t  loop->e_mask = this_mask & (this_mask << 1);\n+\t  this_mask ^= loop->e_mask;\n+\t}\n \n-      if (!(this_mask & loop->inner))\n-\tloop->mask = this_mask;\n+      loop->mask |= this_mask;\n     }\n \n   if (loop->child)\n     {\n-      unsigned child_mask = outer_mask | loop->mask;\n-\n-      if (loop->mask || assign)\n-\tchild_mask |= GOMP_DIM_MASK (GOMP_DIM_MAX);\n-\n-      loop->inner = oacc_loop_auto_partitions (loop->child, child_mask);\n+      unsigned tmp_mask = outer_mask | loop->mask | loop->e_mask;\n+      loop->inner = oacc_loop_auto_partitions (loop->child, tmp_mask,\n+\t\t\t\t\t       outer_assign | assign);\n     }\n \n-  if (assign && !loop->mask)\n+  if (assign && (!loop->mask || (tiling && !loop->e_mask) || !outer_assign))\n     {\n-      /* Allocate the loop at the innermost available level.  */\n+      /* Allocate the loop at the innermost available level.  Note\n+\t that we do this even if we already assigned this loop the\n+\t outermost available level above.  That way we'll partition\n+\t this along 2 axes, if they are available.  */\n       unsigned this_mask = 0;\n \n       /* Determine the outermost partitioning used within this loop.  */\n@@ -1193,24 +1308,44 @@ oacc_loop_auto_partitions (oacc_loop *loop, unsigned outer_mask)\n       /* And avoid picking one use by an outer loop.  */\n       this_mask &= ~outer_mask;\n \n-      if (!this_mask && noisy)\n-\twarning_at (loop->loc, 0,\n-\t\t    \"insufficient partitioning available to parallelize loop\");\n+      /* If tiling and we failed completely above, grab the next one\n+\t too.  Making sure it doesn't hit an outer loop.  */\n+      if (tiling)\n+\t{\n+\t  this_mask &= ~(loop->e_mask | loop->mask);\n+\t  unsigned tile_mask = ((this_mask >> 1)\n+\t\t\t\t& ~(outer_mask | loop->e_mask | loop->mask));\n+\n+\t  if (tile_mask || loop->mask)\n+\t    {\n+\t      loop->e_mask |= this_mask;\n+\t      this_mask = tile_mask;\n+\t    }\n+\t  if (!loop->e_mask && noisy)\n+\t    warning_at (loop->loc, 0,\n+\t\t\t\"insufficient partitioning available\"\n+\t\t\t\" to parallelize element loop\");\n+\t}\n \n-      loop->mask = this_mask;\n+      loop->mask |= this_mask;\n+      if (!loop->mask && noisy)\n+\twarning_at (loop->loc, 0,\n+\t\t    \"insufficient partitioning available\"\n+\t\t    \" to parallelize%s loop\", tiling ? \" tile\" : \"\");\n     }\n \n   if (assign && dump_file)\n-    fprintf (dump_file, \"Auto loop %s:%d assigned %d\\n\",\n+    fprintf (dump_file, \"Auto loop %s:%d assigned %d & %d\\n\",\n \t     LOCATION_FILE (loop->loc), LOCATION_LINE (loop->loc),\n-\t     loop->mask);\n+\t     loop->mask, loop->e_mask);\n \n   unsigned inner_mask = 0;\n \n   if (loop->sibling)\n-    inner_mask |= oacc_loop_auto_partitions (loop->sibling, outer_mask);\n+    inner_mask |= oacc_loop_auto_partitions (loop->sibling,\n+\t\t\t\t\t     outer_mask, outer_assign);\n \n-  inner_mask |= loop->inner | loop->mask;\n+  inner_mask |= loop->inner | loop->mask | loop->e_mask;\n \n   return inner_mask;\n }\n@@ -1226,7 +1361,7 @@ oacc_loop_partition (oacc_loop *loop, unsigned outer_mask)\n   if (mask_all & GOMP_DIM_MASK (GOMP_DIM_MAX))\n     {\n       mask_all ^= GOMP_DIM_MASK (GOMP_DIM_MAX);\n-      mask_all |= oacc_loop_auto_partitions (loop, outer_mask);\n+      mask_all |= oacc_loop_auto_partitions (loop, outer_mask, false);\n     }\n   return mask_all;\n }\n@@ -1376,6 +1511,11 @@ execute_oacc_device_lower ()\n \t  {\n \t  default: break;\n \n+\t  case IFN_GOACC_TILE:\n+\t    oacc_xform_tile (call);\n+\t    rescan = true;\n+\t    break;\n+\t    \n \t  case IFN_GOACC_LOOP:\n \t    oacc_xform_loop (call);\n \t    rescan = true;\n@@ -1403,7 +1543,7 @@ execute_oacc_device_lower ()\n \t      switch (kind)\n \t\t{\n \t\tdefault:\n-\t\t  gcc_unreachable ();\n+\t\t  break;\n \n \t\tcase IFN_UNIQUE_OACC_FORK:\n \t\tcase IFN_UNIQUE_OACC_JOIN:"}, {"sha": "95c0bfc5c7e08e1c337939f3efa8e9727cdf6e32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,3 +1,21 @@\n+2017-02-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* c-c++-common/goacc/combined-directives.c: Remove xfail.\n+\t* c-c++-common/goacc/loop-auto-1.c: Adjust and add additional case.\n+\t* c-c++-common/goacc/loop-auto-2.c: New.\n+\t* c-c++-common/goacc/tile.c: Include stdbool, fix expected errors.\n+\t* c-c++-common/goacc/tile-2.c: New.\n+\t* g++.dg/goacc/template.C: Test tile subst.  Adjust erroneous uses.\n+\t* g++.dg/goacc/tile-1.C: New, check tile subst.\n+\t* gcc.dg/goacc/loop-processing-1.c: Adjust dg-final pattern.\n+\t* gfortran.dg/goacc/combined-directives.f90: Remove xfail.\n+\t* gfortran.dg/goacc/tile-1.f90: New test.\n+\t* gfortran.dg/goacc/tile-2.f90: New test.\n+\t* gfortran.dg/goacc/tile-lowering.f95: New test.\n+\n 2017-02-09  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69823"}, {"sha": "c2a3c57b48b83432c1bf000d279a2d09a8f2f57a", "filename": "gcc/testsuite/c-c++-common/goacc/combined-directives.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-directives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-directives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-directives.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -111,7 +111,6 @@ test ()\n // { dg-final { scan-tree-dump-times \"acc loop vector\" 2 \"gimple\" } }\n // { dg-final { scan-tree-dump-times \"acc loop seq\" 2 \"gimple\" } }\n // { dg-final { scan-tree-dump-times \"acc loop auto\" 2 \"gimple\" } }\n-// XFAILed: OpenACC tile clauses are discarded during gimplification.\n-// { dg-final { scan-tree-dump-times \"acc loop tile.2, 3\" 2 \"gimple\" { xfail *-*-* } } }\n+// { dg-final { scan-tree-dump-times \"acc loop tile.2, 3\" 2 \"gimple\" } }\n // { dg-final { scan-tree-dump-times \"acc loop independent private.i\" 2 \"gimple\" } }\n // { dg-final { scan-tree-dump-times \"private.z\" 2 \"gimple\" } }"}, {"sha": "124befc400222e1c9ceca1ca669abca418842c13", "filename": "gcc/testsuite/c-c++-common/goacc/loop-auto-1.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-1.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -74,6 +74,21 @@ void Foo ()\n \t    for (int kx = 0; kx < 10; kx++) {}\n \t  }\n       }\n+\n+#pragma acc loop auto\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\t    for (int kx = 0; kx < 10; kx++)\n+\t      {\n+#pragma acc loop auto\n+\t\tfor (int lx = 0; lx < 10; lx++) {}\n+\t      }\n+\t  }\n+      }\n   }\n }\n \n@@ -214,10 +229,10 @@ void Vector (void)\n #pragma acc loop auto\n     for (int ix = 0; ix < 10; ix++) {}\n \n-#pragma acc loop auto\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n     for (int ix = 0; ix < 10; ix++)\n       {\n-#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+#pragma acc loop auto\n \tfor (int jx = 0; jx < 10; jx++) {}\n       }\n }"}, {"sha": "af3f0bddf2cbb8e4f189bd23e127b8008d84ba09", "filename": "gcc/testsuite/c-c++-common/goacc/loop-auto-2.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-2.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -0,0 +1,107 @@\n+\n+// Tile parititioning\n+\n+void Ok ()\n+{\n+#pragma acc parallel num_gangs (10) num_workers(32) vector_length(32)\n+  {\n+    \n+#pragma acc loop tile(*) gang vector\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+      }\n+\n+#pragma acc loop tile(*)\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+      }\n+\n+#pragma acc loop tile(*) gang\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+\t#pragma acc loop vector\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  ;\n+      }\n+\n+#pragma acc loop tile(*)\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+\t#pragma acc loop vector\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  ;\n+      }\n+\n+#pragma acc loop gang\n+    for (int jx = 0; jx < 10; jx++)\n+      {\n+#pragma acc loop tile(*) vector\n+\tfor (int ix = 0; ix < 10; ix++)\n+\t  {\n+\t  }\n+\n+#pragma acc loop tile(*)\n+\tfor (int ix = 0; ix < 10; ix++)\n+\t  {\n+\t  }\n+      }\n+\n+#pragma acc loop tile(*) worker\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+\t#pragma acc loop vector\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  ;\n+      }\n+  }\n+}\n+\n+void Bad ()\n+{\n+#pragma acc parallel num_gangs (10) num_workers(32) vector_length(32)\n+  {\n+    \n+#pragma acc loop tile(*) gang vector /* { dg-message \"containing loop\" } */\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop vector /* { dg-error \"uses same\" } */\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  ;\n+      }\n+\n+#pragma acc loop tile(*) gang vector\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+\t#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  ;\n+      }\n+\n+#pragma acc loop tile(*) auto /* { dg-warning \"insufficient partitioning\" } */\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+\t#pragma acc loop worker\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  ;\n+      }\n+\n+#pragma acc loop worker /* { dg-message \"containing loop\" } */\n+    for (int jx = 0; jx < 10; jx++)\n+      {\n+#pragma acc loop tile(*) gang vector /* { dg-error \"incorrectly nested\" } */\n+\tfor (int ix = 0; ix < 10; ix++)\n+\t  {\n+\t  }\n+\n+#pragma acc loop tile(*) vector /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int ix = 0; ix < 10; ix++)\n+\t  {\n+\t  }\n+\n+#pragma acc loop tile(*) /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int ix = 0; ix < 10; ix++)\n+\t  {\n+\t  }\n+      }\n+  }\n+}"}, {"sha": "c8b240d225b940302c46ff1a544d83dc7876cd9f", "filename": "gcc/testsuite/c-c++-common/goacc/tile-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile-2.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -0,0 +1,21 @@\n+int main ()\n+{\n+#pragma acc parallel\n+  {\n+#pragma acc loop tile (*,*)\n+    for (int ix = 0; ix < 30; ix++)\n+      ; /* { dg-error \"not enough\" } */\n+\n+#pragma acc loop tile (*,*)\n+    for (int ix = 0; ix < 30; ix++)\n+      for (int jx = 0; jx < ix; jx++) /* { dg-error \"condition expression\" } */\n+\t;\n+    \n+#pragma acc loop tile (*)\n+    for (int ix = 0; ix < 30; ix++)\n+      for (int jx = 0; jx < ix; jx++) /* OK */\n+\t;\n+    \n+  }\n+  return 0;\n+}"}, {"sha": "f10535a69e5b42f4e0eb16603a0d7a6eea9c76a2", "filename": "gcc/testsuite/c-c++-common/goacc/tile.c", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,7 +1,9 @@\n+#include <stdbool.h>\n+\n int\n main ()\n {\n-  int i, *a, b;\n+  int i, j, k, *a, b;\n \n #pragma acc parallel loop tile (10)\n   for (i = 0; i < 100; i++)\n@@ -13,11 +15,14 @@ main ()\n \n #pragma acc parallel loop tile (10, *)\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      ;\n \n-#pragma acc parallel loop tile (10, *, i)\n+#pragma acc parallel loop tile (10, *, i) // { dg-error \"\" }\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      for (k = 0; k < 100; k++)\n+\t;\n \n #pragma acc parallel loop tile // { dg-error \"expected '\\\\\\('\" }\n   for (i = 0; i < 100; i++)\n@@ -35,45 +40,52 @@ main ()\n   for (i = 0; i < 100; i++)\n     ;\n \n-#pragma acc parallel loop tile (1.1) // { dg-error \"'tile' value must be integral\" }\n+#pragma acc parallel loop tile (1.1) // { dg-error \"'tile' argument needs\" }\n   for (i = 0; i < 100; i++)\n     ;\n \n-#pragma acc parallel loop tile (-3) // { dg-warning \"'tile' value must be positive\" }\n+#pragma acc parallel loop tile (-3) // { dg-error \"'tile' argument needs\" }\n   for (i = 0; i < 100; i++)\n     ;\n \n-#pragma acc parallel loop tile (10,-3) // { dg-warning \"'tile' value must be positive\" }\n+#pragma acc parallel loop tile (10,-3) // { dg-error \"'tile' argument needs\" }\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      ;\n \n-#pragma acc parallel loop tile (-100,10,5) // { dg-warning \"'tile' value must be positive\" }\n+#pragma acc parallel loop tile (-100,10,5) // { dg-error \"'tile' argument needs\" }\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      for (k = 0; k < 100; k++)\n+\t;\n \n-#pragma acc parallel loop tile (1,2.0,true) // { dg-error \"\" }\n+#pragma acc parallel loop tile (1,true)\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      ;\n \n-#pragma acc parallel loop tile (*a, 1)\n+#pragma acc parallel loop tile (*a, 1) // { dg-error \"\" }\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      ;\n \n-#pragma acc parallel loop tile (1, *a, b)\n+#pragma acc parallel loop tile (1, b) // { dg-error \"\" }\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      ;\n \n-#pragma acc parallel loop tile (b, 1, *a)\n+#pragma acc parallel loop tile (b, 1) // { dg-error \"\" }\n   for (i = 0; i < 100; i++)\n-    ;\n+    for (j = 0; j < 100; j++)\n+      ;\n \n   return 0;\n }\n \n \n void par (void)\n {\n-  int i, j;\n+  int i, j, k;\n \n #pragma acc parallel\n   {\n@@ -95,22 +107,22 @@ void par (void)\n \tfor (j = 1; j < 10; j++)\n \t  { }\n       }\n-#pragma acc loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+#pragma acc loop tile(-2)  // { dg-error \"'tile' argument needs\" }\n     for (i = 1; i < 10; i++)\n       { }\n-#pragma acc loop tile(i)\n+#pragma acc loop tile(i)  // { dg-error \"\" }\n     for (i = 1; i < 10; i++)\n       { }\n #pragma acc loop tile(2, 2, 1)\n     for (i = 1; i < 3; i++)\n       {\n \tfor (j = 4; j < 6; j++)\n-\t  { }\n+\t  for (k = 0; k< 100; k++);\n       } \n #pragma acc loop tile(2, 2)\n     for (i = 1; i < 5; i+=2)\n       {\n-\tfor (j = i + 1; j < 7; j+=i)\n+\tfor (j = i + 1; j < 7; j+=i) // { dg-error \"initializer expression\" }\n \t  { }\n       }\n #pragma acc loop vector tile(*) \n@@ -156,24 +168,21 @@ void p3 (void)\n       for (j = 1; j < 10; j++)\n \t{ }\n     }\n-#pragma acc parallel loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+#pragma acc parallel loop tile(-2)   // { dg-error \"'tile' argument needs\" }\n   for (i = 1; i < 10; i++)\n     { }\n-#pragma acc parallel loop tile(i)\n+#pragma acc parallel loop tile(i)   // { dg-error \"\" }\n   for (i = 1; i < 10; i++)\n     { }\n #pragma acc parallel loop tile(2, 2, 1)\n   for (i = 1; i < 3; i++)\n-    {\n-      for (j = 4; j < 6; j++)\n-        { }\n-    }    \n+    for (j = 4; j < 6; j++)\n+      for (int k = 1 ; k < 2; k++)\n+\t;\n #pragma acc parallel loop tile(2, 2)\n   for (i = 1; i < 5; i+=2)\n-    {\n-      for (j = i + 1; j < 7; j++)\n-        { }\n-    }\n+    for (j = i + 1; j < 7; j++) // { dg-error \"initializer expression\" }\n+      { }\n #pragma acc parallel loop vector tile(*) \n   for (i = 0; i < 10; i++)\n     { }\n@@ -227,22 +236,23 @@ kern (void)\n #pragma acc loop tile(*, 1) \n     for (i = 0; i < 10; i++)\n       {\n-\tfor (j = 0; j < 10; i++)\n+\tfor (j = 0; j < 10; i++) /* { dg-error \"increment expression\" } */\n \t  { }\n       }\n-#pragma acc loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+#pragma acc loop tile(-2) // { dg-error \"'tile' argument needs\" }\n     for (i = 0; i < 10; i++)\n       { }\n-#pragma acc loop tile(i)\n+#pragma acc loop tile(i) // { dg-error \"\" }\n     for (i = 0; i < 10; i++)\n       { }\n #pragma acc loop tile(2, 2, 1)\n     for (i = 2; i < 4; i++)\n-      for (i = 4; i < 6; i++)\n+      for (j = 4; j < 6; j++)\n+\tfor (int k = 4; k < 6; k++)\n \t{ }\n #pragma acc loop tile(2, 2)\n     for (i = 1; i < 5; i+=2)\n-      for (j = i+1; j < 7; i++)\n+      for (j = i+1; j < 7; j++) /* { dg-error \"initializer expression\" } */\n \t{ }\n #pragma acc loop vector tile(*) \n     for (i = 0; i < 10; i++)\n@@ -288,22 +298,21 @@ void k3 (void)\n       for (j = 1; j < 10; j++)\n \t{ }\n     }\n-#pragma acc kernels loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+#pragma acc kernels loop tile(-2) // { dg-error \"'tile' argument needs\" }\n   for (i = 1; i < 10; i++)\n     { }\n-#pragma acc kernels loop tile(i)\n+#pragma acc kernels loop tile(i) // { dg-error \"\" }\n   for (i = 1; i < 10; i++)\n     { }\n #pragma acc kernels loop tile(2, 2, 1)\n   for (i = 1; i < 3; i++)\n-    {\n-      for (j = 4; j < 6; j++)\n-\t{ }\n-    }    \n+    for (j = 4; j < 6; j++)\n+      for (int k = 1; k < 7; k++)\n+\t;\n #pragma acc kernels loop tile(2, 2)\n   for (i = 1; i < 5; i++)\n     {\n-      for (j = i + 1; j < 7; j += i)\n+      for (j = i + 1; j < 7; j += i) /* { dg-error \"initializer expression\" } */\n \t{ }\n     }\n #pragma acc kernels loop vector tile(*) "}, {"sha": "74f40d8922e736ce42411849e3f754bff8f959d5", "filename": "gcc/testsuite/g++.dg/goacc/template.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftemplate.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftemplate.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftemplate.C?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -5,7 +5,7 @@ accDouble(int val)\n   return val * 2;\n }\n \n-template<typename T> T\n+template<typename T, int I> T\n oacc_parallel_copy (T a)\n {\n   T b = 0;\n@@ -36,7 +36,7 @@ oacc_parallel_copy (T a)\n       for (int j = 0; j < 5; j++)\n \tb = a;\n \n-#pragma acc loop auto tile (a, 3)\n+#pragma acc loop auto tile (I, 3)\n     for (int i = 0; i < a; i++)\n       for (int j = 0; j < 5; j++)\n \tb = a;\n@@ -135,7 +135,7 @@ oacc_kernels_copy (T a)\n int\n main ()\n {\n-  int b = oacc_parallel_copy<int> (5);\n+  int b = oacc_parallel_copy<int, 4> (5);\n   int c = oacc_kernels_copy<int> (5);\n \n   return b + c;"}, {"sha": "27c53835d3631fb990b7385285e50ebb67b264d7", "filename": "gcc/testsuite/g++.dg/goacc/tile-1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftile-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftile-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftile-1.C?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -0,0 +1,16 @@\n+/*  of tile erroneously clobbered the template, resulting\n+    in missing errors and other fun.  */\n+\n+template <int I>\n+void Foo ()\n+{\n+#pragma acc parallel loop tile(I) // { dg-error \"\" }\n+  for (int ix = 0; ix < 10; ix++)\n+    ;\n+}\n+\n+int main ()\n+{\n+  Foo<1> ();  // OK\n+  Foo<-1> (); // error\n+}"}, {"sha": "07f56a25329cf1619c3cdc37975761c69bb550e7", "filename": "gcc/testsuite/gcc.dg/goacc/loop-processing-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Floop-processing-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Floop-processing-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Floop-processing-1.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -15,4 +15,4 @@ void vector_1 (int *ary, int size)\n   }\n }\n \n-/* { dg-final { scan-tree-dump {OpenACC loops.*Loop 0\\(0\\).*Loop 14\\(1\\).*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 1, 20\\);.*Head-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 1, 20\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_FORK, \\.data_dep\\.[0-9_]+, 0\\);.*Tail-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_TAIL_MARK, \\.data_dep\\.[0-9_]+, 1\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_JOIN, \\.data_dep\\.[0-9_]+, 0\\);.*Loop 6\\(4\\).*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 1, 6\\);.*Head-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 1, 6\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_FORK, \\.data_dep\\.[0-9_]+, 2\\);.*Tail-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_TAIL_MARK, \\.data_dep\\.[0-9_]+, 1\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_JOIN, \\.data_dep\\.[0-9_]+, 2\\);} \"oaccdevlow\" } } */\n+/* { dg-final { scan-tree-dump {OpenACC loops.*Loop 0\\(0\\).*Loop 24\\(1\\).*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 1, 36\\);.*Head-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 1, 36\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_FORK, \\.data_dep\\.[0-9_]+, 0\\);.*Tail-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_TAIL_MARK, \\.data_dep\\.[0-9_]+, 1\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_JOIN, \\.data_dep\\.[0-9_]+, 0\\);.*Loop 6\\(6\\).*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 2, 6\\);.*Head-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, 0, 2, 6\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_FORK, \\.data_dep\\.[0-9_]+, 1\\);.*Head-1:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_HEAD_MARK, \\.data_dep\\.[0-9_]+, 1\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_FORK, \\.data_dep\\.[0-9_]+, 2\\);.*Tail-1:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_TAIL_MARK, \\.data_dep\\.[0-9_]+, 2\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_JOIN, \\.data_dep\\.[0-9_]+, 2\\);.*Tail-0:.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_TAIL_MARK, \\.data_dep\\.[0-9_]+, 1\\);.*\\.data_dep\\.[0-9_]+ = UNIQUE \\(OACC_JOIN, \\.data_dep\\.[0-9_]+, 1\\);} \"oaccdevlow\" } } */"}, {"sha": "42a447ad06bff8238048deb124cc020ff13c8447", "filename": "gcc/testsuite/gfortran.dg/goacc/combined-directives.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcombined-directives.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcombined-directives.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcombined-directives.f90?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -143,8 +143,7 @@ end subroutine test\n ! { dg-final { scan-tree-dump-times \"acc loop private.i. private.j. vector\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"acc loop private.i. private.j. seq\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"acc loop private.i. private.j. auto\" 2 \"gimple\" } }\n-! XFAILed: OpenACC tile clauses are discarded during gimplification.\n-! { dg-final { scan-tree-dump-times \"acc loop private.i. private.j. tile.2, 3\" 2 \"gimple\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"acc loop private.i. private.j. tile.2, 3\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"acc loop private.i. independent\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"private.z\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"omp target oacc_\\[^ \\]+ map.force_tofrom:y\" 2 \"gimple\" } }"}, {"sha": "3dbabda0342ea6e9719dfb0b5bc8ee0aa0f3ef82", "filename": "gcc/testsuite/gfortran.dg/goacc/tile-1.f90", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-1.f90?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -0,0 +1,339 @@\n+subroutine parloop\n+  integer, parameter :: n = 100\n+  integer i, j, k, a\n+\n+  !$acc parallel loop tile(10)\n+  do i = 1, n\n+  end do\n+  \n+  !$acc parallel loop tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc parallel loop tile(10, *)\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+ \n+  !$acc parallel loop tile(10, *, i) ! { dg-error \"\" }\n+  do i = 1, n\n+     do j = 1, n\n+        do k = 1, n\n+        end do\n+     end do\n+  end do \n+\n+  !$acc parallel loop tile ! { dg-error \"Unclassifiable\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc parallel loop tile() ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc parallel loop tile(,1) ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc parallel loop tile(,,) ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc parallel loop tile(1.1) ! { dg-error \"requires a scalar INTEGER\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc parallel loop tile(-3) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc parallel loop tile(10, -3) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile(-100, 10, 5) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+     do j = 1, n\n+        do k = 1, n\n+        end do\n+     end do\n+  end do \n+\n+  !$acc parallel loop tile(10, .true.) ! { dg-error \"requires a scalar\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile(1, a) ! { dg-error \"constant expression\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile(a, 1) ! { dg-error \"constant expression\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile(2, 3) collapse (2) ! { dg-error \"Incompatible use\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+end subroutine parloop\n+\n+subroutine par\n+  integer, parameter :: n = 100\n+  integer i, j, k\n+\n+  !$acc parallel\n+  !$acc loop tile ! { dg-error \"Unclassifiable\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile() ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(1)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(2)\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc loop tile(-2) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(i) ! { dg-error \"constant expression\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(2, 2, 1)\n+  do i = 1, n\n+     do j = 1, n\n+        do k = 1, n\n+        end do\n+     end do\n+  end do \n+\n+  !$acc parallel loop tile(2, 2)\n+  do i = 1, n\n+     do j = i+1, n, j ! { dg-error \"rectangular iteration space\" }\n+     end do\n+  end do\n+\n+  !$acc loop vector tile(*)\n+  do i = 1, n\n+  end do\n+  \n+  !$acc loop worker tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop gang tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop vector gang tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop vector worker tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop gang worker tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(2, 3) collapse (2) ! { dg-error \"Incompatible use\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+  !$acc end parallel\n+end subroutine par\n+\n+subroutine kern\n+  integer, parameter :: n = 100\n+  integer i, j, k\n+\n+  !$acc kernels\n+  !$acc loop tile  ! { dg-error \"Unclassifiable\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile() ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(1)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(2)\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc loop tile(-2) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(i) ! { dg-error \"constant expression\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(2, 2, 1)\n+  do i = 1, n\n+     do j = 1, n\n+        do k = 1, n\n+        end do\n+     end do\n+  end do \n+\n+  !$acc parallel loop tile(2, 2)\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc loop vector tile(*)\n+  do i = 1, n\n+  end do\n+  \n+  !$acc loop worker tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop gang tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop vector gang tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop vector worker tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop gang worker tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc loop tile(2, 3) collapse (2) ! { dg-error \"Incompatible use\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+  !$acc end kernels\n+end subroutine kern\n+\n+subroutine kernsloop\n+  integer, parameter :: n = 100\n+  integer i, j, k, a\n+\n+  !$acc kernels loop tile(10)\n+  do i = 1, n\n+  end do\n+  \n+  !$acc kernels loop tile(*)\n+  do i = 1, n\n+  end do\n+\n+  !$acc kernels loop tile(10, *)\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+ \n+  !$acc kernels loop tile(10, *, i) ! { dg-error \"\" }\n+  do i = 1, n\n+     do j = 1, n\n+        do k = 1, n\n+        end do\n+     end do\n+  end do \n+\n+  !$acc kernels loop tile ! { dg-error \"Unclassifiable\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc kernels loop tile() ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc kernels loop tile(,1) ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc kernels loop tile(,,) ! { dg-error \"Syntax error\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc kernels loop tile(1.1) ! { dg-error \"requires a scalar INTEGER\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc kernels loop tile(-3) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+  end do\n+\n+  !$acc kernels loop tile(10, -3) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile(-100, 10, 5) ! { dg-warning \"must be positive\" }\n+  do i = 1, n\n+     do j = 1, n\n+        do k = 1, n\n+        end do\n+     end do\n+  end do \n+\n+  !$acc kernels loop tile(10, .true.) ! { dg-error \"requires a scalar\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile(1, a) ! { dg-error \"constant expression\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile(a, 1) ! { dg-error \"constant expression\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile(2, 3) collapse (2) ! { dg-error \"Incompatible use\" }\n+  do i = 1, n\n+     do j = 1, n\n+     end do\n+  end do\n+end subroutine kernsloop"}, {"sha": "c56754380cc9ab17cc1bbb462a058a61a6aa258e", "filename": "gcc/testsuite/gfortran.dg/goacc/tile-2.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-2.f90?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -0,0 +1,21 @@\n+subroutine par\n+  integer ix, jx\n+\n+  !$acc parallel\n+  !$acc loop tile (*,*) ! { dg-error \"not enough DO loops for tiled\" }\n+  do ix = 1, 30\n+  end do\n+\n+  !$acc loop tile (*,*)\n+  do ix = 1, 30\n+     do jx = 1, ix ! { dg-error \"tiled loops don.t form rectangular\" }\n+     end do\n+  end do\n+\n+  !$acc loop tile (*)\n+  do ix = 1, 30\n+     do jx = 1, ix\n+     end do\n+  end do\n+  !$acc end parallel\n+end subroutine par"}, {"sha": "1cb8b9cc512f4a6f8c393116e00dc8d5adddf454", "filename": "gcc/testsuite/gfortran.dg/goacc/tile-lowering.f95", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-lowering.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-lowering.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ftile-lowering.f95?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -0,0 +1,292 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+subroutine par\n+  integer i, j, k\n+\n+  !$acc parallel\n+  !$acc loop tile (1)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc loop tile (*)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc loop tile (1,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (*,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (*,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc loop tile (*,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,*,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,2,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+end subroutine par\n+\n+subroutine kerns\n+  integer i, j, k\n+\n+  !$acc kernels\n+  !$acc loop tile (1)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc loop tile (*)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc loop tile (1,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (*,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (*,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc loop tile (*,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,*,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc loop tile (1,2,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+  !$acc end kernels\n+end subroutine kerns\n+\n+subroutine parloop\n+  integer i, j, k\n+\n+  !$acc parallel loop tile (1)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc parallel loop tile (*)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc parallel loop tile (1,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile (*,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile (1,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile (*,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile (1,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile (*,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile (1,*,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc parallel loop tile (1,2,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+end subroutine parloop\n+\n+subroutine kernloop\n+  integer i, j, k\n+\n+  !$acc kernels loop tile (1)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc kernels loop tile (*)\n+  do i = 1, 10\n+  end do\n+\n+  !$acc kernels loop tile (1,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile (*,2)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile (1,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile (*,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile (1,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile (*,2,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile (1,*,3)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+\n+  !$acc kernels loop tile (1,2,*)\n+  do i = 1, 10\n+     do j = 1, 10\n+        do k = 1, 10\n+        end do\n+     end do\n+  end do\n+end subroutine kernloop\n+\n+\n+! { dg-final { scan-tree-dump-times \"tile\\\\(1\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(0\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(1, 2\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(0, 2\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(1, 0\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(0, 0\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(1, 2, 3\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(0, 2, 3\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(1, 0, 3\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"tile\\\\(1, 2, 0\\\\)\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(\" 88 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"while \\\\(\" 0 \"original\" } }"}, {"sha": "4a25025ef8f13bc5e52035062fa7e6dbdb7a9695", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1274,6 +1274,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n@@ -1286,8 +1287,6 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_AUTO:\n \t  break;\n \n-\t  /* OpenACC tile clauses are discarded during gimplification.  */\n-\tcase OMP_CLAUSE_TILE:\n \t  /* The following clause belongs to the OpenACC cache directive, which\n \t     is discarded during gimplification.  */\n \tcase OMP_CLAUSE__CACHE_:\n@@ -1982,6 +1981,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n@@ -1994,8 +1994,6 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_AUTO:\n \t  break;\n \n-\t  /* OpenACC tile clauses are discarded during gimplification.  */\n-\tcase OMP_CLAUSE_TILE:\n \t  /* The following clause belongs to the OpenACC cache directive, which\n \t     is discarded during gimplification.  */\n \tcase OMP_CLAUSE__CACHE_:"}, {"sha": "3e63415e673eadeca286bfff9786e729e2e83373", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -328,7 +328,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_NUM_GANGS  */\n   1, /* OMP_CLAUSE_NUM_WORKERS  */\n   1, /* OMP_CLAUSE_VECTOR_LENGTH  */\n-  1, /* OMP_CLAUSE_TILE  */\n+  3, /* OMP_CLAUSE_TILE  */\n   2, /* OMP_CLAUSE__GRIDDIM_  */\n };\n "}, {"sha": "3b12509e7df7eb5e51d72eab7e15250c08d3569b", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1654,6 +1654,10 @@ extern void protected_set_expr_location (tree, location_t);\n \n #define OMP_CLAUSE_TILE_LIST(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 0)\n+#define OMP_CLAUSE_TILE_ITERVAR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 1)\n+#define OMP_CLAUSE_TILE_COUNT(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 2)\n \n #define OMP_CLAUSE__GRIDDIM__DIMENSION(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_)\\"}, {"sha": "132f9d732e9841fa7b2191c85207cc81239f4e21", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,3 +1,14 @@\n+2017-02-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* testsuite/libgomp.oacc-c-c++-common/tile-1.c: New.\n+\t* testsuite/libgomp.oacc-c-c++-common/loop-auto-1.c: Adjust and\n+\tadd additional case.\n+\t* testsuite/libgomp.oacc-c-c++-common/vprop.c: XFAIL under\n+\t\"openacc_nvidia_accel_selected\".\n+\t* libgomp.oacc-fortran/nested-function-1.f90 (test2):\n+\tAdd num_workers(8) clause.\n+\n 2017-02-08  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* testsuite/libgomp.oacc-c-c++-common/loop-dim-default.c: Skip on"}, {"sha": "863b6b38c34ba028797558e2626fadaeb0cd45b1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-auto-1.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-auto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-auto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-auto-1.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -112,7 +112,7 @@ int vector_1 (int *ary, int size)\n \tary[ix] = place ();\n   }\n \n-  return check (ary, size, 0, 0, 1);\n+  return check (ary, size, 0, 1, 1);\n }\n \n int vector_2 (int *ary, int size)\n@@ -196,10 +196,24 @@ int gang_3 (int *ary, int size)\n \tary[ix + jx * 64] = place ();\n   }\n \n+  return check (ary, size, 1, 1, 1);\n+}\n+\n+int gang_4 (int *ary, int size)\n+{\n+  clear (ary, size);\n+  \n+#pragma acc parallel vector_length(32) copy(ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop auto\n+    for (int jx = 0; jx <  size; jx++)\n+      ary[jx] = place ();\n+  }\n+\n   return check (ary, size, 1, 0, 1);\n }\n \n-#define N (32*32*32)\n+#define N (32*32*32*2)\n int main ()\n {\n   int ondev = 0;\n@@ -227,6 +241,8 @@ int main ()\n     return 1;\n   if (gang_3 (ary,  N))\n     return 1;\n+  if (gang_4 (ary,  N))\n+    return 1;\n \n   return 0;\n }"}, {"sha": "8dcb956c59fb3257ae6150a41e2952ce207f93e7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/tile-1.c", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ftile-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ftile-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ftile-1.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -0,0 +1,281 @@\n+/* This code uses nvptx inline assembly guarded with acc_on_device, which is\n+   not optimized away at -O0, and then confuses the target assembler.\n+   { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+/* { dg-additional-options \"-fopenacc-dim=32\" } */\n+\n+#include <stdio.h>\n+#include <openacc.h>\n+\n+static int check (const int *ary, int size, int gp, int wp, int vp)\n+{\n+  int exit = 0;\n+  int ix;\n+  int gangs[32], workers[32], vectors[32];\n+\n+  for (ix = 0; ix < 32; ix++)\n+    gangs[ix] = workers[ix] = vectors[ix] = 0;\n+  \n+  for (ix = 0; ix < size; ix++)\n+    {\n+      vectors[ary[ix] & 0xff]++;\n+      workers[(ary[ix] >> 8) & 0xff]++;\n+      gangs[(ary[ix] >> 16) & 0xff]++;\n+    }\n+\n+  for (ix = 0; ix < 32; ix++)\n+    {\n+      if (gp)\n+\t{\n+\t  int expect = gangs[0];\n+\t  if (gangs[ix] != expect)\n+\t    {\n+\t      exit = 1;\n+\t      printf (\"gang %d not used %d times\\n\", ix, expect);\n+\t    }\n+\t}\n+      else if (ix && gangs[ix])\n+\t{\n+\t  exit = 1;\n+\t  printf (\"gang %d unexpectedly used\\n\", ix);\n+\t}\n+\n+      if (wp)\n+\t{\n+\t  int expect = workers[0];\n+\t  if (workers[ix] != expect)\n+\t    {\n+\t      exit = 1;\n+\t      printf (\"worker %d not used %d times\\n\", ix, expect);\n+\t    }\n+\t}\n+      else if (ix && workers[ix])\n+\t{\n+\t  exit = 1;\n+\t  printf (\"worker %d unexpectedly used\\n\", ix);\n+\t}\n+\n+      if (vp)\n+\t{\n+\t  int expect = vectors[0];\n+\t  if (vectors[ix] != expect)\n+\t    {\n+\t      exit = 1;\n+\t      printf (\"vector %d not used %d times\\n\", ix, expect);\n+\t    }\n+\t}\n+      else if (ix && vectors[ix])\n+\t{\n+\t  exit = 1;\n+\t  printf (\"vector %d unexpectedly used\\n\", ix);\n+\t}\n+      \n+    }\n+  return exit;\n+}\n+\n+#pragma acc routine seq\n+static int __attribute__((noinline)) place ()\n+{\n+  int r = 0;\n+\n+  if (acc_on_device (acc_device_nvidia))\n+    {\n+      int g = 0, w = 0, v = 0;\n+\n+      __asm__ volatile (\"mov.u32 %0,%%ctaid.x;\" : \"=r\" (g));\n+      __asm__ volatile (\"mov.u32 %0,%%tid.y;\" : \"=r\" (w));\n+      __asm__ volatile (\"mov.u32 %0,%%tid.x;\" : \"=r\" (v));\n+      r = (g << 16) | (w << 8) | v;\n+    }\n+  return r;\n+}\n+\n+static void clear (int *ary, int size)\n+{\n+  int ix;\n+\n+  for (ix = 0; ix < size; ix++)\n+    ary[ix] = -1;\n+}\n+\n+int gang_vector_1 (int *ary, int size)\n+{\n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_gangs (32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(128) gang vector\n+    for (int jx = 0; jx < size; jx++)\n+      ary[jx] = place ();\n+  }\n+\n+  return check (ary, size, 1, 0, 1);\n+}\n+\n+int gang_vector_2a (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+  \n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_gangs (32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(64, 64) gang vector\n+    for (int jx = 0; jx < size / 256; jx++)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx * 256 + ix] = place ();\n+  }\n+\n+  return check (ary, size, 1, 0, 1);\n+}\n+\n+int gang_vector_2b (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+  \n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_gangs (32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(64, 64) gang vector\n+    for (int jx = 0; jx < size; jx += 256)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx + ix] = place ();\n+  }\n+\n+  return check (ary, size, 1, 0, 1);\n+}\n+\n+int worker_vector_2a (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+\n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_workers (32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(64, 64) worker vector\n+    for (int jx = 0; jx < size / 256; jx++)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx * 256 + ix] = place ();\n+  }\n+\n+  return check (ary, size, 0, 1, 1);\n+}\n+\n+int worker_vector_2b (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+\n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_workers (32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(64, 64) worker vector\n+    for (int jx = 0; jx < size; jx += 256)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx + ix] = place ();\n+  }\n+\n+  return check (ary, size, 0, 1, 1);\n+}\n+\n+int gang_worker_vector_2a (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_workers (32) num_gangs(32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(32, 32)\n+    for (int jx = 0; jx < size / 256; jx++)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx * 256 + ix] = place ();\n+  }\n+\n+  return check (ary, size, 1, 1, 1);\n+}\n+\n+int gang_worker_vector_2b (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_workers (32) num_gangs(32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(32, 32)\n+    for (int jx = 0; jx < size; jx += 256)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx + ix] = place ();\n+  }\n+\n+  return check (ary, size, 1, 1, 1);\n+}\n+\n+int gang_worker_vector_star_2a (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+\n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_workers (32) num_gangs(32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(*, *)\n+    for (int jx = 0; jx < size / 256; jx++)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx * 256 + ix] = place ();\n+  }\n+\n+  return check (ary, size, 1, 1, 1);\n+}\n+\n+int gang_worker_vector_star_2b (int *ary, int size)\n+{\n+  if (size % 256)\n+    return 1;\n+\n+  clear (ary, size);\n+#pragma acc parallel vector_length(32) num_workers (32) num_gangs(32) copy (ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop tile(*, *)\n+    for (int jx = 0; jx < size; jx +=256)\n+      for (int ix = 0; ix < 256; ix++)\n+\tary[jx + ix] = place ();\n+  }\n+\n+  return check (ary, size, 1, 1, 1);\n+}\n+\n+#define N (32*32*32*8)\n+int main ()\n+{\n+  int ondev = 0;\n+\n+#pragma acc parallel copy(ondev)\n+  {\n+    ondev = acc_on_device (acc_device_not_host);\n+  }\n+  if (!ondev)\n+    return 0;\n+  \n+  int ary[N];\n+  if (gang_vector_1 (ary, N))\n+    return 1;\n+  if (gang_vector_2a (ary, N))\n+    return 1;\n+  if (worker_vector_2a (ary, N))\n+    return 1;\n+  if (gang_worker_vector_2a (ary, N))\n+    return 1;\n+  if (gang_worker_vector_star_2a (ary, N))\n+    return 1;\n+  if (gang_vector_2b (ary, N))\n+    return 1;\n+  if (worker_vector_2b (ary, N))\n+    return 1;\n+  if (gang_worker_vector_2b (ary, N))\n+    return 1;\n+  if (gang_worker_vector_star_2b (ary, N))\n+    return 1;\n+  return 0;\n+}"}, {"sha": "c2bce8286d43bb07d5582765fc4dcb955d4626f8", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/vprop.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fvprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fvprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fvprop.c?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"PR78266\" { openacc_nvidia_accel_selected } { \"*\" } { \"\" } } */\n+\n #include <assert.h>\n \n #define test(type)\t\t\t\t\\"}, {"sha": "c4af1992a05d56664f5783bb2df8d026e49c9ecc", "filename": "libgomp/testsuite/libgomp.oacc-fortran/nested-function-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fnested-function-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02889d23ee3b02854dff203dd87b9a25e30b61b4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fnested-function-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fnested-function-1.f90?ref=02889d23ee3b02854dff203dd87b9a25e30b61b4", "patch": "@@ -33,7 +33,7 @@ end subroutine test1\n   subroutine test2\n     integer :: a(3,3,3), k, kk, kkk, l, ll, lll\n     a = 0\n-    !$acc parallel\n+    !$acc parallel num_workers(8)\n     ! Use \"gang(static:1)\" here and below to effectively turn gang-redundant\n     ! execution mode into something like gang-single.\n     !$acc loop gang(static:1) collapse(1)"}]}