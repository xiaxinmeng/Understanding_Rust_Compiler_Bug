{"sha": "8b7e9dba2bc921c24994129bb9231caa176d6da5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI3ZTlkYmEyYmM5MjFjMjQ5OTQxMjliYjkyMzFjYWExNzZkNmRhNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-18T15:50:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-18T15:50:03Z"}, "message": "Move computation of SLP_TREE_NUMBER_OF_VEC_STMTS\n\nPreviously SLP_TREE_NUMBER_OF_VEC_STMTS was calculated while scheduling\nan SLP tree after analysis, but sometimes it can be useful to know the\nvalue during analysis too.  This patch moves the calculation to\nvect_slp_analyze_node_operations instead.\n\n2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_slp_analyze_operations): Replace parameters\n\twith a vec_info *.\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Update call\n\taccordingly.\n\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Add vec_info *\n\tparameter.  Set SLP_TREE_NUMBER_OF_VEC_STMTS here rather than in\n\tvect_schedule_slp_instance.\n\t(vect_slp_analyze_operations): Replace parameters with a vec_info *.\n\tUpdate call to vect_slp_analyze_node_operations.  Simplify return\n\tvalue.\n\t(vect_slp_analyze_bb_1): Update call accordingly.\n\t(vect_schedule_slp_instance): Remove vectorization_factor parameter.\n\tDon't calculate SLP_TREE_NUMBER_OF_VEC_STMTS here.\n\t(vect_schedule_slp): Update call accordingly.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252935", "tree": {"sha": "cf06fcaf6fcd2e2e9469de9c64d0f878f8b8231a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf06fcaf6fcd2e2e9469de9c64d0f878f8b8231a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b7e9dba2bc921c24994129bb9231caa176d6da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7e9dba2bc921c24994129bb9231caa176d6da5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b7e9dba2bc921c24994129bb9231caa176d6da5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7e9dba2bc921c24994129bb9231caa176d6da5/comments", "author": null, "committer": null, "parents": [{"sha": "ac8936b4677fa10b676e5b12aa682b9d2d42c1e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8936b4677fa10b676e5b12aa682b9d2d42c1e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8936b4677fa10b676e5b12aa682b9d2d42c1e5"}], "stats": {"total": 115, "additions": 66, "deletions": 49}, "files": [{"sha": "cca1a2513df19300093f09db843747f94273d00b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b7e9dba2bc921c24994129bb9231caa176d6da5", "patch": "@@ -1,3 +1,22 @@\n+2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (vect_slp_analyze_operations): Replace parameters\n+\twith a vec_info *.\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Update call\n+\taccordingly.\n+\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Add vec_info *\n+\tparameter.  Set SLP_TREE_NUMBER_OF_VEC_STMTS here rather than in\n+\tvect_schedule_slp_instance.\n+\t(vect_slp_analyze_operations): Replace parameters with a vec_info *.\n+\tUpdate call to vect_slp_analyze_node_operations.  Simplify return\n+\tvalue.\n+\t(vect_slp_analyze_bb_1): Update call accordingly.\n+\t(vect_schedule_slp_instance): Remove vectorization_factor parameter.\n+\tDon't calculate SLP_TREE_NUMBER_OF_VEC_STMTS here.\n+\t(vect_schedule_slp): Update call accordingly.\n+\n 2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "bf49e26e2a67ca168cece33f42052789b4705bcc", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=8b7e9dba2bc921c24994129bb9231caa176d6da5", "patch": "@@ -2031,8 +2031,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t remove unsupported SLP instances which makes the above\n \t SLP kind detection invalid.  */\n       unsigned old_size = LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length ();\n-      vect_slp_analyze_operations (LOOP_VINFO_SLP_INSTANCES (loop_vinfo),\n-\t\t\t\t   LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n+      vect_slp_analyze_operations (loop_vinfo);\n       if (LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length () != old_size)\n \tgoto again;\n     }"}, {"sha": "5e40a3741809ab5ff182fc5e4585111727860461", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=8b7e9dba2bc921c24994129bb9231caa176d6da5", "patch": "@@ -2525,11 +2525,14 @@ _bb_vec_info::~_bb_vec_info ()\n }\n \n \n-/* Analyze statements contained in SLP tree node after recursively analyzing\n-   the subtree. Return TRUE if the operations are supported.  */\n+/* Analyze statements contained in SLP tree NODE after recursively analyzing\n+   the subtree.  NODE_INSTANCE contains NODE and VINFO contains INSTANCE.\n+\n+   Return true if the operations are supported.  */\n \n static bool\n-vect_slp_analyze_node_operations (slp_tree node, slp_instance node_instance)\n+vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n+\t\t\t\t  slp_instance node_instance)\n {\n   bool dummy;\n   int i, j;\n@@ -2540,7 +2543,7 @@ vect_slp_analyze_node_operations (slp_tree node, slp_instance node_instance)\n     return true;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (!vect_slp_analyze_node_operations (child, node_instance))\n+    if (!vect_slp_analyze_node_operations (vinfo, child, node_instance))\n       return false;\n \n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n@@ -2592,6 +2595,29 @@ vect_slp_analyze_node_operations (slp_tree node, slp_instance node_instance)\n \tSTMT_VINFO_VECTYPE (vinfo_for_stmt (sstmt)) = vectype;\n     }\n \n+  /* Calculate the number of vector statements to be created for the\n+     scalar stmts in this node.  For SLP reductions it is equal to the\n+     number of vector statements in the children (which has already been\n+     calculated by the recursive call).  Otherwise it is the number of\n+     scalar elements in one scalar iteration (GROUP_SIZE) multiplied by\n+     VF divided by the number of elements in a vector.  */\n+  if (GROUP_FIRST_ELEMENT (stmt_info)\n+      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n+      = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_CHILDREN (node)[0]);\n+  else\n+    {\n+      int vf;\n+      if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n+\tvf = loop_vinfo->vectorization_factor;\n+      else\n+\tvf = 1;\n+      unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (node_instance);\n+      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n+\t= vf * group_size / TYPE_VECTOR_SUBPARTS (vectype);\n+    }\n+\n   /* Push SLP node def-type to stmt operands.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n@@ -2610,11 +2636,11 @@ vect_slp_analyze_node_operations (slp_tree node, slp_instance node_instance)\n }\n \n \n-/* Analyze statements in SLP instances of the basic block.  Return TRUE if the\n+/* Analyze statements in SLP instances of VINFO.  Return true if the\n    operations are supported. */\n \n bool\n-vect_slp_analyze_operations (vec<slp_instance> slp_instances, void *data)\n+vect_slp_analyze_operations (vec_info *vinfo)\n {\n   slp_instance instance;\n   int i;\n@@ -2623,9 +2649,10 @@ vect_slp_analyze_operations (vec<slp_instance> slp_instances, void *data)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_slp_analyze_operations ===\\n\");\n \n-  for (i = 0; slp_instances.iterate (i, &instance); )\n+  for (i = 0; vinfo->slp_instances.iterate (i, &instance); )\n     {\n-      if (!vect_slp_analyze_node_operations (SLP_INSTANCE_TREE (instance),\n+      if (!vect_slp_analyze_node_operations (vinfo,\n+\t\t\t\t\t     SLP_INSTANCE_TREE (instance),\n \t\t\t\t\t     instance))\n         {\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2634,20 +2661,17 @@ vect_slp_analyze_operations (vec<slp_instance> slp_instances, void *data)\n \t\t\t    SLP_TREE_SCALAR_STMTS\n \t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n \t  vect_free_slp_instance (instance);\n-          slp_instances.ordered_remove (i);\n+          vinfo->slp_instances.ordered_remove (i);\n \t}\n       else\n \t{\n \t  /* Compute the costs of the SLP instance.  */\n-\t  vect_analyze_slp_cost (instance, data);\n+\t  vect_analyze_slp_cost (instance, vinfo->target_cost_data);\n \t  i++;\n \t}\n     }\n \n-  if (!slp_instances.length ())\n-    return false;\n-\n-  return true;\n+  return !vinfo->slp_instances.is_empty ();\n }\n \n \n@@ -2921,8 +2945,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n-  if (!vect_slp_analyze_operations (BB_VINFO_SLP_INSTANCES (bb_vinfo),\n-\t\t\t\t    BB_VINFO_TARGET_COST_DATA (bb_vinfo)))\n+  if (!vect_slp_analyze_operations (bb_vinfo))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3676,14 +3699,13 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n /* Vectorize SLP instance tree in postorder.  */\n \n static bool\n-vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n-                            unsigned int vectorization_factor)\n+vect_schedule_slp_instance (slp_tree node, slp_instance instance)\n {\n   gimple *stmt;\n   bool grouped_store, is_store;\n   gimple_stmt_iterator si;\n   stmt_vec_info stmt_info;\n-  unsigned int vec_stmts_size, nunits, group_size;\n+  unsigned int group_size;\n   tree vectype;\n   int i, j;\n   slp_tree child;\n@@ -3692,7 +3714,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n     return false;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_schedule_slp_instance (child, instance, vectorization_factor);\n+    vect_schedule_slp_instance (child, instance);\n \n   /* Push SLP node def-type to stmts.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n@@ -3705,27 +3727,10 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \n   /* VECTYPE is the type of the destination.  */\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (vectype);\n   group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n \n-  /* For each SLP instance calculate number of vector stmts to be created\n-     for the scalar stmts in each node of the SLP tree.  Number of vector\n-     elements in one vector iteration is the number of scalar elements in\n-     one scalar iteration (GROUP_SIZE) multiplied by VF divided by vector\n-     size.\n-     Unless this is a SLP reduction in which case the number of vector\n-     stmts is equal to the number of vector stmts of the children.  */\n-  if (GROUP_FIRST_ELEMENT (stmt_info)\n-      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    vec_stmts_size = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_CHILDREN (node)[0]);\n-  else\n-    vec_stmts_size = (vectorization_factor * group_size) / nunits;\n-\n   if (!SLP_TREE_VEC_STMTS (node).exists ())\n-    {\n-      SLP_TREE_VEC_STMTS (node).create (vec_stmts_size);\n-      SLP_TREE_NUMBER_OF_VEC_STMTS (node) = vec_stmts_size;\n-    }\n+    SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n \n   if (dump_enabled_p ())\n     {\n@@ -3874,20 +3879,15 @@ vect_schedule_slp (vec_info *vinfo)\n {\n   vec<slp_instance> slp_instances;\n   slp_instance instance;\n-  unsigned int i, vf;\n+  unsigned int i;\n   bool is_store = false;\n \n   slp_instances = vinfo->slp_instances;\n-  if (is_a <loop_vec_info> (vinfo))\n-    vf = as_a <loop_vec_info> (vinfo)->vectorization_factor;\n-  else\n-    vf = 1;\n-\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       /* Schedule the tree of INSTANCE.  */\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n-                                             instance, vf);\n+                                             instance);\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"vectorizing stmts using SLP.\\n\");"}, {"sha": "d6753ff4eeaa550fb1555a9459b81552256e215e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7e9dba2bc921c24994129bb9231caa176d6da5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=8b7e9dba2bc921c24994129bb9231caa176d6da5", "patch": "@@ -1246,8 +1246,7 @@ extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n                                           gimple_stmt_iterator *, int,\n                                           slp_instance, bool, unsigned *);\n-extern bool vect_slp_analyze_operations (vec<slp_instance> slp_instances,\n-\t\t\t\t\t void *);\n+extern bool vect_slp_analyze_operations (vec_info *);\n extern bool vect_schedule_slp (vec_info *);\n extern bool vect_analyze_slp (vec_info *, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);"}]}