{"sha": "3ba0afac60e80851c01541364d8991667809cec0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JhMGFmYWM2MGU4MDg1MWMwMTU0MTM2NGQ4OTkxNjY3ODA5Y2VjMA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-09-29T18:16:12Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-10-11T12:38:29Z"}, "message": "Objective-C, Darwin : Update message call codegen.\n\nPlatform compilers based on LLVM do not use the objc_sendMsg_fixit\nand friends for newer editions of the OS (runtimes for Arm64 do not even\nhave those entries).\n\nWe need to arrange to allow for this codegen on modern Darwin.\n\nThe _fixit versions are needed for some OS versions (at least, up to\n10.6) since the super2 call is not implemented there.  It does not\nseem worth making the codegen more fine-grained at present.\n\nOther parts of the codegen need to be made conditional on either the\nruntime version or the linker capabilities.\n\ngcc/objc/ChangeLog:\n\n\t* objc-next-runtime-abi-02.c (TAG_MSGSENDSUPER): Revised\n\tspelling.\n\t(TAG_MSGSENDID): Likewise.\n\t(TAG_MSGSENDSUPER_STRET): Likewise.\n\t(TAG_MSGSENDID_STRET): Likewise.\n\t(FIXUP_NEEDED): Likewise.\n\t(TAG_FIXUP): New.\n\t(next_runtime_02_initialize): Adjust message calls to use\n\tfixup variants only when required.\n\t(next_runtime_abi_02_get_arg_type_list_base): Correct\n\tindent.\n\t(build_v2_build_objc_method_call): New.\n\t(build_v2_objc_method_fixup_call): Split out from ...\n\t(next_runtime_abi_02_build_objc_method_call): ... here.\n\tArrange to adjust the call on the basis of the target\n\truntime.", "tree": {"sha": "675129c31e9eb11d53a9bbc4a4642f5e48cc1683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/675129c31e9eb11d53a9bbc4a4642f5e48cc1683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ba0afac60e80851c01541364d8991667809cec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba0afac60e80851c01541364d8991667809cec0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba0afac60e80851c01541364d8991667809cec0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba0afac60e80851c01541364d8991667809cec0/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75d4d7bc697dd1853e89a93e6c4fa1db9a709bc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d4d7bc697dd1853e89a93e6c4fa1db9a709bc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d4d7bc697dd1853e89a93e6c4fa1db9a709bc0"}], "stats": {"total": 233, "additions": 187, "deletions": 46}, "files": [{"sha": "0c7a600c5974b5b507221adc9eff079814063152", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 187, "deletions": 46, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba0afac60e80851c01541364d8991667809cec0/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba0afac60e80851c01541364d8991667809cec0/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=3ba0afac60e80851c01541364d8991667809cec0", "patch": "@@ -63,9 +63,15 @@ along with GCC; see the file COPYING3.  If not see\n #define TAG_GETMETACLASS\t\"objc_getMetaClass\"\n \n #define TAG_MSGSEND\t\t\"objc_msgSend\"\n-#define TAG_MSGSENDSUPER\t\"objc_msgSendSuper\"\n+#define TAG_MSGSENDID\t\t\"objc_msgSendId\"\n+#define TAG_MSGSENDSUPER\t\"objc_msgSendSuper2\"\n #define TAG_MSGSEND_STRET\t\"objc_msgSend_stret\"\n-#define TAG_MSGSENDSUPER_STRET\t\"objc_msgSendSuper_stret\"\n+#define TAG_MSGSENDID_STRET\t\"objc_msgSendId_stret\"\n+#define TAG_MSGSENDSUPER_STRET\t\"objc_msgSendSuper2_stret\"\n+\n+#define FIXUP_NEEDED\t\t100600\n+#define TAG_FIXUP\t\t\"_fixup\"\n+\n \n #define TAG_NEXT_EHVTABLE_NAME\t\"objc_ehtype_vtable\"\n #define TAG_V2_EH_TYPE\t\t\"objc_ehtype_t\"\n@@ -386,32 +392,43 @@ static void next_runtime_02_initialize (void)\n   build_v2_protocol_template ();\n   build_v2_category_template ();\n \n-  /* id objc_msgSend_fixup_rtp (id, struct message_ref_t*, ...); */\n-  type = build_varargs_function_type_list (objc_object_type,\n-\t\t\t\t\t\t   objc_object_type,\n-\t\t\t\t\t\t   objc_v2_selector_type,\n-\t\t\t\t\t\t   NULL_TREE);\n-  umsg_fixup_decl =  add_builtin_function (\"objc_msgSend_fixup\",\n-\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n+  bool fixup_p = flag_next_runtime < FIXUP_NEEDED;\n+  if (fixup_p)\n+    {\n+      /* id objc_msgSend_fixup_rtp (id, struct message_ref_t*, ...); */\n+      type = build_varargs_function_type_list (objc_object_type,\n+\t\t\t\t\t       objc_object_type,\n+\t\t\t\t\t       objc_v2_selector_type,\n+\t\t\t\t\t       NULL_TREE);\n+    }\n+  else\n+    {\n+      /* id objc_msgSendXXXX (id, SEL, ...); */\n+      type = build_varargs_function_type_list (objc_object_type,\n+\t\t\t\t\t       objc_object_type,\n+\t\t\t\t\t       objc_selector_type,\n+\t\t\t\t\t       NULL_TREE);\n+    }\n+  const char *fnam = fixup_p ? TAG_MSGSEND TAG_FIXUP : TAG_MSGSEND;\n+  umsg_fixup_decl =  add_builtin_function (fnam, type, 0, NOT_BUILT_IN,\n \t\t\t\t\t   NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_fixup_decl) = 0;\n \n   /* id objc_msgSend_stret_fixup_rtp (id, struct message_ref_t*, ...); */\n-  umsg_stret_fixup_decl = add_builtin_function (\"objc_msgSend_stret_fixup\",\n-\t\t\t\t\t\ttype, 0, NOT_BUILT_IN,\n+  fnam = fixup_p ? TAG_MSGSEND_STRET TAG_FIXUP : TAG_MSGSEND_STRET;\n+  umsg_stret_fixup_decl = add_builtin_function (fnam, type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\tNULL, NULL_TREE);\n   TREE_NOTHROW (umsg_stret_fixup_decl) = 0;\n \n   /* id objc_msgSendId_fixup_rtp (id, struct message_ref_t*, ...); */\n-  umsg_id_fixup_decl = add_builtin_function (\"objc_msgSendId_fixup\",\n-\t\t\t\t\t     type, 0, NOT_BUILT_IN,\n+  fnam = fixup_p ? TAG_MSGSENDID TAG_FIXUP : TAG_MSGSENDID;\n+  umsg_id_fixup_decl = add_builtin_function (fnam, type, 0, NOT_BUILT_IN,\n \t\t\t\t\t     NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_id_fixup_decl) = 0;\n \n-  /* id objc_msgSendId_stret_fixup_rtp\n-\t\t\t(id, struct message_ref_t*, ...); */\n-  umsg_id_stret_fixup_decl = add_builtin_function (\"objc_msgSendId_stret_fixup\",\n-\t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n+  /* id objc_msgSendId_stret_fixup_rtp (id, struct message_ref_t*, ...); */\n+  fnam = fixup_p ? TAG_MSGSENDID_STRET TAG_FIXUP : TAG_MSGSENDID_STRET;\n+  umsg_id_stret_fixup_decl = add_builtin_function (fnam, type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t   NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_id_stret_fixup_decl) = 0;\n \n@@ -421,17 +438,17 @@ static void next_runtime_02_initialize (void)\n \t\t\t\t\t   objc_super_type,\n \t\t\t\t\t   objc_v2_super_selector_type,\n \t\t\t\t\t   NULL_TREE);\n-  umsg_id_super2_fixup_decl = add_builtin_function (\"objc_msgSendSuper2_fixup\",\n-\t\t\t\t\t\t    type, 0, NOT_BUILT_IN,\n+  fnam = fixup_p ? TAG_MSGSENDSUPER TAG_FIXUP : TAG_MSGSENDSUPER;\n+  umsg_id_super2_fixup_decl = add_builtin_function (fnam, type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t    NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_id_super2_fixup_decl) = 0;\n \n   /* id objc_msgSendSuper2_stret_fixup_rtp\n \t\t\t(struct objc_super *, struct message_ref_t*, ...); */\n-  umsg_id_super2_stret_fixup_decl =\n-\t\t\tadd_builtin_function (\"objc_msgSendSuper2_stret_fixup\",\n-\t\t\t\t\t      type, 0, NOT_BUILT_IN,\n-\t\t\t\t\t      NULL, NULL_TREE);\n+  fnam = fixup_p ? TAG_MSGSENDSUPER_STRET TAG_FIXUP : TAG_MSGSENDSUPER_STRET;\n+  umsg_id_super2_stret_fixup_decl = add_builtin_function (fnam, type, 0,\n+\t\t\t\t\t\t\t  NOT_BUILT_IN,  NULL,\n+\t\t\t\t\t\t\t  NULL_TREE);\n   TREE_NOTHROW (umsg_id_super2_stret_fixup_decl) = 0;\n \n   /* Present in the library, but unused by the FE.  */\n@@ -1134,10 +1151,12 @@ next_runtime_abi_02_get_arg_type_list_base (vec<tree, va_gc> **argtypes,\n     receiver_type = objc_object_type;\n \n   vec_safe_push (*argtypes, receiver_type);\n-  /* Selector type - will eventually change to `int'.  */\n-  vec_safe_push (*argtypes,\n-\t\t superflag ? objc_v2_super_selector_type\n-\t\t           : objc_v2_selector_type);\n+  if (flag_next_runtime < FIXUP_NEEDED)\n+    /* Selector type - will eventually change to `int'.  */\n+    vec_safe_push (*argtypes, superflag ? objc_v2_super_selector_type\n+\t\t\t\t\t: objc_v2_selector_type);\n+  else\n+    vec_safe_push (*argtypes, objc_selector_type);\n }\n \n /* TODO: Merge this with the message refs.  */\n@@ -1589,10 +1608,9 @@ objc_copy_to_temp_side_effect_params (tree fntype, tree values)\n    (*_msg.messenger) (receiver, &_msg, ...) */\n \n static tree\n-build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n-\t\t\t\t tree lookup_object, tree selector,\n-\t\t\t\t tree method_params,\n-\t\t\t\t bool check_for_nil)\n+build_v2_objc_method_fixup_call (int super_flag, tree method_prototype,\n+\t\t\t\ttree lookup_object, tree selector,\n+\t\t\t\ttree method_params, bool check_for_nil)\n {\n   tree ret_val;\n   tree sender, rcv_p, t;\n@@ -1672,6 +1690,118 @@ build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n   return ret_val;\n }\n \n+static tree\n+build_v2_build_objc_method_call (int super, tree method_prototype,\n+\t\t\t\t tree lookup_object, tree selector,\n+\t\t\t\t tree method_params, location_t loc,\n+\t\t\t\t bool check_for_nil, bool rx_is_id)\n+{\n+  tree sender, sender_cast, method, t;\n+  tree rcv_p = (super ? objc_super_type : objc_object_type);\n+  vec<tree, va_gc> *parms;\n+  unsigned nparm = (method_params ? list_length (method_params) : 0);\n+\n+  /* If a prototype for the method to be called exists, then cast\n+     the sender's return type and arguments to match that of the method.\n+     Otherwise, leave sender as is.  */\n+  tree ret_type\n+    = (method_prototype\n+       ? TREE_VALUE (TREE_TYPE (method_prototype))\n+       : objc_object_type);\n+  tree ftype = build_function_type_for_method (ret_type, method_prototype,\n+\t\t\t\t\t       METHOD_REF, super);\n+\n+  if (method_prototype && METHOD_TYPE_ATTRIBUTES (method_prototype))\n+    ftype = build_type_attribute_variant (ftype,\n+\t\t\t\t\t  METHOD_TYPE_ATTRIBUTES\n+\t\t\t\t\t  (method_prototype));\n+\n+  sender_cast = build_pointer_type (ftype);\n+\n+  lookup_object = build_c_cast (loc, rcv_p, lookup_object);\n+\n+  /* Use SAVE_EXPR to avoid evaluating the receiver twice.  */\n+  lookup_object = save_expr (lookup_object);\n+\n+  /* Param list + 2 slots for object and selector.  */\n+  vec_alloc (parms, nparm + 2);\n+\n+  /* If we are returning a struct in memory, and the address\n+     of that memory location is passed as a hidden first\n+     argument, then change which messenger entry point this\n+     expr will call.  NB: Note that sender_cast remains\n+     unchanged (it already has a struct return type).  */\n+  if (!targetm.calls.struct_value_rtx (0, 0)\n+      && (TREE_CODE (ret_type) == RECORD_TYPE\n+\t  || TREE_CODE (ret_type) == UNION_TYPE)\n+      && targetm.calls.return_in_memory (ret_type, 0))\n+    {\n+      if (super)\n+\tsender = umsg_id_super2_stret_fixup_decl;\n+      else\n+\tsender = rx_is_id ? umsg_id_stret_fixup_decl\n+\t\t\t  : umsg_stret_fixup_decl;\n+    }\n+  else\n+    {\n+      if (super)\n+\tsender = umsg_id_super2_fixup_decl;\n+      else\n+\tsender = rx_is_id ? umsg_id_fixup_decl\n+\t\t\t  : umsg_fixup_decl;\n+    }\n+\n+  method = build_fold_addr_expr_loc (loc, sender);\n+\n+  /* Pass the object to the method.  */\n+  parms->quick_push (lookup_object);\n+  /* Pass the selector to the method.  */\n+  parms->quick_push (selector);\n+  /* Now append the remainder of the parms.  */\n+  if (nparm)\n+    for (; method_params; method_params = TREE_CHAIN (method_params))\n+      parms->quick_push (TREE_VALUE (method_params));\n+\n+  /* Build an obj_type_ref, with the correct cast for the method call.  */\n+  t = build3 (OBJ_TYPE_REF, sender_cast, method,\n+\t\t\t    lookup_object, size_zero_node);\n+  tree ret_val = build_function_call_vec (loc, vNULL, t, parms, NULL);\n+  vec_free (parms);\n+  if (check_for_nil)\n+    {\n+      /* receiver != nil ? ret_val : 0 */\n+      tree ftree;\n+      tree ifexp;\n+\n+      if (TREE_CODE (ret_type) == RECORD_TYPE\n+\t  || TREE_CODE (ret_type) == UNION_TYPE)\n+\t{\n+\t  vec<constructor_elt, va_gc> *rtt = NULL;\n+\t  /* ??? CHECKME. hmmm..... think we need something more\n+\t     here.  */\n+\t  CONSTRUCTOR_APPEND_ELT (rtt, NULL_TREE, NULL_TREE);\n+\t  ftree = objc_build_constructor (ret_type, rtt);\n+\t}\n+      else\n+\tftree = fold_convert (ret_type, integer_zero_node);\n+\n+      ifexp = build_binary_op (loc, NE_EXPR,\n+\t\t\t       lookup_object,\n+\t\t\t       fold_convert (rcv_p, integer_zero_node), 1);\n+\n+#ifdef OBJCPLUS\n+      ret_val = build_conditional_expr (loc, ifexp, ret_val, ftree,\n+\t\t\t\t\ttf_warning_or_error);\n+#else\n+     /* ??? CHECKME.   */\n+      ret_val = build_conditional_expr (loc, ifexp, 1,\n+\t\t\t\t\tret_val, NULL_TREE, loc,\n+\t\t\t\t\tftree, NULL_TREE, loc);\n+#endif\n+    }\n+  return ret_val;\n+}\n+\n static tree\n next_runtime_abi_02_build_objc_method_call (location_t loc,\n \t\t\t\t\t    tree method_prototype,\n@@ -1681,27 +1811,38 @@ next_runtime_abi_02_build_objc_method_call (location_t loc,\n \t\t\t\t\t    tree method_params,\n \t\t\t\t\t    int super)\n {\n-  tree ret_type, selector;\n-  tree message_func_decl;\n-  bool check_for_nil = flag_objc_nilcheck;\n-\n-  ret_type = method_prototype\n-\t     ? TREE_VALUE (TREE_TYPE (method_prototype))\n-\t     : objc_object_type;\n-\n   /* Do we need to check for nil receivers ? */\n   /* For now, message sent to classes need no nil check.  In the\n       future, class declaration marked as weak_import must be nil\n       checked.  */\n+  bool check_for_nil = flag_objc_nilcheck;\n   if (super\n       || (TREE_CODE (receiver) == VAR_DECL\n \t  && TREE_TYPE (receiver) == objc_class_type))\n     check_for_nil = false;\n \n+  if (flag_next_runtime >= FIXUP_NEEDED)\n+    {\n+      tree selector\n+\t= next_runtime_abi_02_build_selector_reference (loc, sel_name,\n+\t\t\t\t\t\t    method_prototype);\n+      return build_v2_build_objc_method_call (super, method_prototype,\n+\t\t\t\t\t      receiver, selector,\n+\t\t\t\t\t      method_params, loc,\n+\t\t\t\t\t      check_for_nil,\n+\t\t\t\t\t      objc_is_id (rtype));\n+    }\n+\n+  /* else we have to build a pair of the function and selector.  */\n+  tree message_func_decl;\n+  tree  ret_type = method_prototype\n+\t     ? TREE_VALUE (TREE_TYPE (method_prototype))\n+\t     : objc_object_type;\n+\n   if (!targetm.calls.struct_value_rtx (0, 0)\n-          && (TREE_CODE (ret_type) == RECORD_TYPE\n-\t      || TREE_CODE (ret_type) == UNION_TYPE)\n-          && targetm.calls.return_in_memory (ret_type, 0))\n+      && (TREE_CODE (ret_type) == RECORD_TYPE\n+\t  || TREE_CODE (ret_type) == UNION_TYPE)\n+      && targetm.calls.return_in_memory (ret_type, 0))\n     {\n       if (super)\n \tmessage_func_decl = umsg_id_super2_stret_fixup_decl;\n@@ -1720,7 +1861,7 @@ next_runtime_abi_02_build_objc_method_call (location_t loc,\n \t\t\t    : umsg_fixup_decl;\n     }\n \n-  selector = build_v2_selector_messenger_reference (sel_name,\n+  tree selector = build_v2_selector_messenger_reference (sel_name,\n \t\t\t\t\t\t      message_func_decl);\n \n   /* selector = &_msg; */\n@@ -1731,9 +1872,9 @@ next_runtime_abi_02_build_objc_method_call (location_t loc,\n \t\t\t   selector);\n \n   /* (*_msg.messenger) (receiver, &_msg, ...); */\n-  return build_v2_build_objc_method_call (super, method_prototype,\n-\t\t\t\t\t  receiver, selector,\n-\t\t\t\t\t  method_params, check_for_nil);\n+  return build_v2_objc_method_fixup_call (super, method_prototype, receiver,\n+\t\t\t\t\t  selector, method_params,\n+\t\t\t\t\t  check_for_nil);\n }\n \n /* NOTE --- Constant String Class Stuff --- */"}]}