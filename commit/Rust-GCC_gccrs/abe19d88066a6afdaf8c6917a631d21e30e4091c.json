{"sha": "abe19d88066a6afdaf8c6917a631d21e30e4091c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlMTlkODgwNjZhNmFmZGFmOGM2OTE3YTYzMWQyMWUzMGU0MDkxYw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-06-23T09:30:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-23T09:30:59Z"}, "message": "prj-conf.ads, [...]: New files part of the project manager.\n\n2009-06-23  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-conf.ads, prj-conf.adb: New files part of the project manager.\n\nFrom-SVN: r148835", "tree": {"sha": "e3a126bf326b9b39704593163279da9adcebd89e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3a126bf326b9b39704593163279da9adcebd89e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abe19d88066a6afdaf8c6917a631d21e30e4091c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe19d88066a6afdaf8c6917a631d21e30e4091c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe19d88066a6afdaf8c6917a631d21e30e4091c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe19d88066a6afdaf8c6917a631d21e30e4091c/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af268547dec49c0356f622369582fe2e2d112586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af268547dec49c0356f622369582fe2e2d112586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af268547dec49c0356f622369582fe2e2d112586"}], "stats": {"total": 1204, "additions": 1204, "deletions": 0}, "files": [{"sha": "baef841cf7b6fe22dae9340fa651580c9e801acc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe19d88066a6afdaf8c6917a631d21e30e4091c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe19d88066a6afdaf8c6917a631d21e30e4091c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=abe19d88066a6afdaf8c6917a631d21e30e4091c", "patch": "@@ -1,3 +1,7 @@\n+2009-06-23  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-conf.ads, prj-conf.adb: New files part of the project manager.\n+\n 2009-06-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Derive_Subprogram): If the inherited subprogram is a"}, {"sha": "8ae9f7973cdf9ab03ed0dea2667c9c4f2de016aa", "filename": "gcc/ada/prj-conf.adb", "status": "added", "additions": 1060, "deletions": 0, "changes": 1060, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe19d88066a6afdaf8c6917a631d21e30e4091c/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe19d88066a6afdaf8c6917a631d21e30e4091c/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=abe19d88066a6afdaf8c6917a631d21e30e4091c", "patch": "@@ -0,0 +1,1060 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P R J . C O N F                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006-2009, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Directories;  use Ada.Directories;\n+with GNAT.HTable;      use GNAT.HTable;\n+with Makeutl;          use Makeutl;\n+with Opt;              use Opt;\n+with Osint;            use Osint;\n+with Output;           use Output;\n+with Prj.Err;          use Prj.Err;\n+with Prj.Part;\n+with Prj.Proc;         use Prj.Proc;\n+with Prj.Tree;         use Prj.Tree;\n+with Prj.Util;         use Prj.Util;\n+with Prj;              use Prj;\n+with Sinput.P;\n+with Snames;           use Snames;\n+with System.Case_Util; use System.Case_Util;\n+with System;\n+\n+package body Prj.Conf is\n+\n+   Auto_Cgpr : constant String := \"auto.cgpr\";\n+\n+   Default_Name : constant String := \"default.cgpr\";\n+   --  Default configuration file that will be used if found\n+\n+   Config_Project_Env_Var : constant String := \"GPR_CONFIG\";\n+   --  Name of the environment variable that provides the name of the\n+   --  configuration file to use.\n+\n+   Gprconfig_Name : constant String := \"gprconfig\";\n+\n+   package RTS_Languages is new GNAT.HTable.Simple_HTable\n+     (Header_Num => Prj.Header_Num,\n+      Element    => Name_Id,\n+      No_Element => No_Name,\n+      Key        => Name_Id,\n+      Hash       => Prj.Hash,\n+      Equal      => \"=\");\n+   --  Stores the runtime names for the various languages. This is in general\n+   --  set from a --RTS command line option.\n+\n+   procedure Add_Attributes\n+     (Project_Tree : Project_Tree_Ref;\n+      Conf_Decl    : Declarations;\n+      User_Decl    : in out Declarations);\n+   --  Process the attributes in the config declarations.\n+   --  For single string values, if the attribute is not declared in the user\n+   --  declarations, declare it with the value in the config declarations.\n+   --  For string list values, prepend the value in the user declarations with\n+   --  the value in the config declarations.\n+\n+   function Locate_Config_File (Name : String) return String_Access;\n+   --  Search for Name in the config files directory. Return full path if\n+   --  found, or null otherwise\n+\n+   function Check_Target\n+     (Config_File  : Prj.Project_Id;\n+      Autoconf_Specified : Boolean;\n+      Project_Tree : Prj.Project_Tree_Ref;\n+      Target       : String := \"\") return Boolean;\n+   --  Check that the config file's target matches Target.\n+   --  Target should be set to the empty string when the user did not specify\n+   --  a target.\n+   --  If the target in the configuration file is invalid, this function will\n+   --  call Osint.Fail to report a fatal error message and stop the program.\n+   --  Autoconf_Specified should be set to True if the user has used --autoconf\n+\n+   --------------------\n+   -- Add_Attributes --\n+   --------------------\n+\n+   procedure Add_Attributes\n+     (Project_Tree : Project_Tree_Ref;\n+      Conf_Decl    : Declarations;\n+      User_Decl    : in out Declarations)\n+   is\n+      Conf_Attr_Id       : Variable_Id;\n+      Conf_Attr          : Variable;\n+      Conf_Array_Id      : Array_Id;\n+      Conf_Array         : Array_Data;\n+      Conf_Array_Elem_Id : Array_Element_Id;\n+      Conf_Array_Elem    : Array_Element;\n+      Conf_List          : String_List_Id;\n+      Conf_List_Elem     : String_Element;\n+\n+      User_Attr_Id       : Variable_Id;\n+      User_Attr          : Variable;\n+      User_Array_Id      : Array_Id;\n+      User_Array         : Array_Data;\n+      User_Array_Elem_Id : Array_Element_Id;\n+      User_Array_Elem    : Array_Element;\n+\n+   begin\n+      Conf_Attr_Id := Conf_Decl.Attributes;\n+      User_Attr_Id := User_Decl.Attributes;\n+\n+      while Conf_Attr_Id /= No_Variable loop\n+         Conf_Attr :=\n+           Project_Tree.Variable_Elements.Table (Conf_Attr_Id);\n+         User_Attr :=\n+           Project_Tree.Variable_Elements.Table (User_Attr_Id);\n+\n+         if not Conf_Attr.Value.Default then\n+            if User_Attr.Value.Default then\n+\n+               --  No attribute declared in user project file: just copy the\n+               --  value of the configuration attribute.\n+\n+               User_Attr.Value := Conf_Attr.Value;\n+               Project_Tree.Variable_Elements.Table (User_Attr_Id) :=\n+                 User_Attr;\n+\n+            elsif User_Attr.Value.Kind = List and then\n+            Conf_Attr.Value.Values /= Nil_String\n+            then\n+\n+               --  List attribute declared in both the user project and the\n+               --  configuration project: prepend the user list with the\n+               --  configuration list.\n+\n+               declare\n+                  Conf_List : String_List_Id :=\n+                    Conf_Attr.Value.Values;\n+                  Conf_Elem : String_Element;\n+                  User_List : constant String_List_Id :=\n+                    User_Attr.Value.Values;\n+                  New_List : String_List_Id;\n+                  New_Elem : String_Element;\n+\n+               begin\n+\n+                  --  Create new list\n+\n+                  String_Element_Table.Increment_Last\n+                    (Project_Tree.String_Elements);\n+                  New_List := String_Element_Table.Last\n+                    (Project_Tree.String_Elements);\n+\n+                  --  Value of attribute is new list\n+\n+                  User_Attr.Value.Values := New_List;\n+                  Project_Tree.Variable_Elements.Table (User_Attr_Id) :=\n+                    User_Attr;\n+\n+                  loop\n+\n+                     --  Get each element of configuration list\n+\n+                     Conf_Elem :=\n+                       Project_Tree.String_Elements.Table (Conf_List);\n+                     New_Elem := Conf_Elem;\n+                     Conf_List := Conf_Elem.Next;\n+\n+                     if Conf_List = Nil_String then\n+\n+                        --  If it is the last element in the list, connect to\n+                        --  first element of user list, and we are done.\n+\n+                        New_Elem.Next := User_List;\n+                        Project_Tree.String_Elements.Table\n+                          (New_List) := New_Elem;\n+                        exit;\n+\n+                     else\n+\n+                        --  If it is not the last element in the list, add to\n+                        --  new list.\n+\n+                        String_Element_Table.Increment_Last\n+                          (Project_Tree.String_Elements);\n+                        New_Elem.Next :=\n+                          String_Element_Table.Last\n+                            (Project_Tree.String_Elements);\n+                        Project_Tree.String_Elements.Table\n+                          (New_List) := New_Elem;\n+                        New_List := New_Elem.Next;\n+                     end if;\n+                  end loop;\n+               end;\n+            end if;\n+         end if;\n+\n+         Conf_Attr_Id := Conf_Attr.Next;\n+         User_Attr_Id := User_Attr.Next;\n+      end loop;\n+\n+      Conf_Array_Id := Conf_Decl.Arrays;\n+      while Conf_Array_Id /= No_Array loop\n+         Conf_Array := Project_Tree.Arrays.Table (Conf_Array_Id);\n+\n+         User_Array_Id := User_Decl.Arrays;\n+         while User_Array_Id /= No_Array loop\n+            User_Array := Project_Tree.Arrays.Table (User_Array_Id);\n+            exit when User_Array.Name = Conf_Array.Name;\n+            User_Array_Id := User_Array.Next;\n+         end loop;\n+\n+         --  If this associative array does not exist in the user project file,\n+         --  do a shallow copy of the full associative array.\n+\n+         if User_Array_Id = No_Array then\n+            Array_Table.Increment_Last (Project_Tree.Arrays);\n+            User_Array := Conf_Array;\n+            User_Array.Next := User_Decl.Arrays;\n+            User_Decl.Arrays := Array_Table.Last (Project_Tree.Arrays);\n+            Project_Tree.Arrays.Table (User_Decl.Arrays) := User_Array;\n+\n+         else\n+            --  Otherwise, check each array element\n+\n+            Conf_Array_Elem_Id := Conf_Array.Value;\n+            while Conf_Array_Elem_Id /= No_Array_Element loop\n+               Conf_Array_Elem :=\n+                 Project_Tree.Array_Elements.Table (Conf_Array_Elem_Id);\n+\n+               User_Array_Elem_Id := User_Array.Value;\n+               while User_Array_Elem_Id /= No_Array_Element loop\n+                  User_Array_Elem :=\n+                    Project_Tree.Array_Elements.Table (User_Array_Elem_Id);\n+                  exit when User_Array_Elem.Index = Conf_Array_Elem.Index;\n+                  User_Array_Elem_Id := User_Array_Elem.Next;\n+               end loop;\n+\n+               --  If the array element does not exist in the user array,\n+               --  insert a shallow copy of the conf array element in the\n+               --  user array.\n+\n+               if User_Array_Elem_Id = No_Array_Element then\n+                  Array_Element_Table.Increment_Last\n+                    (Project_Tree.Array_Elements);\n+                  User_Array_Elem := Conf_Array_Elem;\n+                  User_Array_Elem.Next := User_Array.Value;\n+                  User_Array.Value :=\n+                    Array_Element_Table.Last (Project_Tree.Array_Elements);\n+                  Project_Tree.Array_Elements.Table (User_Array.Value) :=\n+                    User_Array_Elem;\n+                  Project_Tree.Arrays.Table (User_Array_Id) := User_Array;\n+\n+               --  Otherwise, if the value is a string list, prepend the\n+               --  user array element with the conf array element value.\n+\n+               elsif Conf_Array_Elem.Value.Kind = List then\n+                  Conf_List := Conf_Array_Elem.Value.Values;\n+\n+                  if Conf_List /= Nil_String then\n+                     declare\n+                        Link : constant String_List_Id :=\n+                                 User_Array_Elem.Value.Values;\n+                        Previous : String_List_Id := Nil_String;\n+                        Next     : String_List_Id;\n+                     begin\n+                        loop\n+                           Conf_List_Elem :=\n+                             Project_Tree.String_Elements.Table\n+                               (Conf_List);\n+                           String_Element_Table.Increment_Last\n+                             (Project_Tree.String_Elements);\n+                           Next :=\n+                             String_Element_Table.Last\n+                               (Project_Tree.String_Elements);\n+                           Project_Tree.String_Elements.Table (Next) :=\n+                             Conf_List_Elem;\n+\n+                           if Previous = Nil_String then\n+                              User_Array_Elem.Value.Values := Next;\n+                              Project_Tree.Array_Elements.Table\n+                                (User_Array_Elem_Id) := User_Array_Elem;\n+\n+                           else\n+                              Project_Tree.String_Elements.Table\n+                                (Previous).Next := Next;\n+                           end if;\n+\n+                           Previous := Next;\n+\n+                           Conf_List := Conf_List_Elem.Next;\n+\n+                           if Conf_List = Nil_String then\n+                              Project_Tree.String_Elements.Table\n+                                (Previous).Next := Link;\n+                              exit;\n+                           end if;\n+                        end loop;\n+                     end;\n+                  end if;\n+               end if;\n+\n+               Conf_Array_Elem_Id := Conf_Array_Elem.Next;\n+            end loop;\n+         end if;\n+\n+         Conf_Array_Id := Conf_Array.Next;\n+      end loop;\n+   end Add_Attributes;\n+\n+   ------------------------\n+   -- Locate_Config_File --\n+   ------------------------\n+\n+   function Locate_Config_File (Name : String) return String_Access is\n+      Prefix_Path : constant String := Executable_Prefix_Path;\n+   begin\n+      if Prefix_Path'Length /= 0 then\n+         return Locate_Regular_File\n+           (Name,\n+            \".\" & Path_Separator &\n+            Prefix_Path & \"share\" & Directory_Separator & \"gpr\");\n+\n+      else\n+         return Locate_Regular_File (Name, \".\");\n+      end if;\n+   end Locate_Config_File;\n+\n+   ------------------\n+   -- Check_Target --\n+   ------------------\n+\n+   function Check_Target\n+     (Config_File  : Project_Id;\n+      Autoconf_Specified : Boolean;\n+      Project_Tree : Prj.Project_Tree_Ref;\n+      Target       : String := \"\") return Boolean\n+   is\n+      Variable   : constant Variable_Value :=\n+        Value_Of (Name_Target, Config_File.Decl.Attributes, Project_Tree);\n+      Tgt_Name : Name_Id := No_Name;\n+      OK       : Boolean;\n+   begin\n+      if Variable /= Nil_Variable_Value and then not Variable.Default then\n+         Tgt_Name := Variable.Value;\n+      end if;\n+\n+      if Target = \"\" then\n+         OK := not Autoconf_Specified or Tgt_Name = No_Name;\n+      else\n+         OK := Tgt_Name /= No_Name\n+           and then Target = Get_Name_String (Tgt_Name);\n+      end if;\n+\n+      if not OK then\n+         if Autoconf_Specified then\n+            if Verbose_Mode then\n+               Write_Line (\"inconsistent targets, performing autoconf\");\n+            end if;\n+\n+            return False;\n+\n+         else\n+            if Tgt_Name /= No_Name then\n+               Osint.Fail (\"invalid target name \"\"\" &\n+                           Get_Name_String (Tgt_Name) &\n+                           \"\"\" in configuration\");\n+\n+            else\n+               Osint.Fail (\"no target specified in configuration file\");\n+            end if;\n+         end if;\n+      end if;\n+\n+      return True;\n+   end Check_Target;\n+\n+   --------------------------------------\n+   -- Get_Or_Create_Configuration_File --\n+   --------------------------------------\n+\n+   procedure Get_Or_Create_Configuration_File\n+     (Project                    : Project_Id;\n+      Project_Tree               : Project_Tree_Ref;\n+      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n+      Allow_Automatic_Generation : Boolean;\n+      Config_File_Name           : String := \"\";\n+      Autoconf_Specified         : Boolean;\n+      Target_Name                : String := \"\";\n+      Normalized_Hostname        : String;\n+      Packages_To_Check          : String_List_Access := null;\n+      Config                     : out Prj.Project_Id;\n+      Config_File_Path           : out String_Access;\n+      Automatically_Generated    : out Boolean)\n+   is\n+      function Default_File_Name return String;\n+      --  Return the name of the default config file that should be tested\n+\n+      procedure Do_Autoconf;\n+      --  Generate a new config file through gprconfig\n+\n+      function Get_Config_Switches return Argument_List_Access;\n+      --  Return the --config switches to use for gprconfig\n+\n+      function Might_Have_Sources (Project : Project_Id) return Boolean;\n+      --  True if the specified project might have sources (ie the user has not\n+      --  explicitly specified it. We haven't checked the file system, nor do\n+      --  we need to at this stage.\n+\n+      -----------------------\n+      -- Default_File_Name --\n+      -----------------------\n+\n+      function Default_File_Name return String is\n+         Ada_RTS : constant String := Runtime_Name_For (Name_Ada);\n+         Tmp : String_Access;\n+      begin\n+         if Target_Name /= \"\" then\n+            if Ada_RTS /= \"\" then\n+               return Target_Name & '-' & Ada_RTS\n+                 & Config_Project_File_Extension;\n+            else\n+               return Target_Name & Config_Project_File_Extension;\n+            end if;\n+\n+         elsif Ada_RTS /= \"\" then\n+            return Ada_RTS & Config_Project_File_Extension;\n+\n+         else\n+            Tmp := Getenv (Config_Project_Env_Var);\n+\n+            declare\n+               T : constant String := Tmp.all;\n+            begin\n+               Free (Tmp);\n+\n+               if T'Length = 0 then\n+                  return Default_Name;\n+               else\n+                  return T;\n+               end if;\n+            end;\n+         end if;\n+      end Default_File_Name;\n+\n+      ------------------------\n+      -- Might_Have_Sources --\n+      ------------------------\n+\n+      function Might_Have_Sources (Project : Project_Id) return Boolean is\n+         Variable : Variable_Value;\n+      begin\n+         Variable :=\n+           Value_Of\n+             (Name_Source_Dirs,\n+              Project.Decl.Attributes,\n+              Project_Tree);\n+\n+         if Variable = Nil_Variable_Value\n+           or else Variable.Default\n+           or else Variable.Values /= Nil_String\n+         then\n+            Variable :=\n+              Value_Of\n+                (Name_Source_Files,\n+                 Project.Decl.Attributes,\n+                 Project_Tree);\n+            return Variable = Nil_Variable_Value\n+              or else Variable.Default\n+              or else Variable.Values /= Nil_String;\n+         else\n+            return False;\n+         end if;\n+      end Might_Have_Sources;\n+\n+      -------------------------\n+      -- Get_Config_Switches --\n+      -------------------------\n+\n+      function Get_Config_Switches return Argument_List_Access is\n+         package Language_Htable is new GNAT.HTable.Simple_HTable\n+           (Header_Num => Prj.Header_Num,\n+            Element    => Name_Id,\n+            No_Element => No_Name,\n+            Key        => Name_Id,\n+            Hash       => Prj.Hash,\n+            Equal      => \"=\");\n+         --  Hash table to keep the languages used in the project tree\n+\n+         IDE      : constant Package_Id :=\n+           Value_Of\n+             (Name_Ide,\n+              Project.Decl.Packages,\n+              Project_Tree);\n+\n+         Prj_Iter : Project_List;\n+         List     : String_List_Id;\n+         Elem     : String_Element;\n+         Lang     : Name_Id;\n+         Variable : Variable_Value;\n+         Name     : Name_Id;\n+         Count    : Natural;\n+         Result   : Argument_List_Access;\n+\n+      begin\n+         Prj_Iter := Project_Tree.Projects;\n+         while Prj_Iter /= null loop\n+            if Might_Have_Sources (Prj_Iter.Project) then\n+               Variable :=\n+                 Value_Of\n+                   (Name_Languages,\n+                    Prj_Iter.Project.Decl.Attributes,\n+                    Project_Tree);\n+\n+               if Variable = Nil_Variable_Value\n+                 or else Variable.Default\n+               then\n+                  --  Languages is not declared. If it is not an extending\n+                  --  project, check for Default_Language\n+\n+                  if Prj_Iter.Project.Extends = No_Project then\n+                     Variable :=\n+                       Value_Of\n+                         (Name_Default_Language,\n+                          Prj_Iter.Project.Decl.Attributes,\n+                          Project_Tree);\n+\n+                     if Variable /= Nil_Variable_Value and then\n+                       not Variable.Default\n+                     then\n+                        Get_Name_String (Variable.Value);\n+                        To_Lower (Name_Buffer (1 .. Name_Len));\n+                        Lang := Name_Find;\n+                        Language_Htable.Set (Lang, Lang);\n+\n+                     else\n+                        --  If no language is declared, default to Ada\n+\n+                        Language_Htable.Set (Name_Ada, Name_Ada);\n+                     end if;\n+                  end if;\n+\n+               elsif Variable.Values /= Nil_String then\n+\n+                  --  Attribute Languages is declared with a non empty\n+                  --  list: put all the languages in Language_HTable.\n+\n+                  List := Variable.Values;\n+                  while List /= Nil_String loop\n+                     Elem := Project_Tree.String_Elements.Table (List);\n+\n+                     Get_Name_String (Elem.Value);\n+                     To_Lower (Name_Buffer (1 .. Name_Len));\n+                     Lang := Name_Find;\n+                     Language_Htable.Set (Lang, Lang);\n+\n+                     List := Elem.Next;\n+                  end loop;\n+               end if;\n+            end if;\n+\n+            Prj_Iter := Prj_Iter.Next;\n+         end loop;\n+\n+         Name  := Language_Htable.Get_First;\n+         Count := 0;\n+\n+         while Name /= No_Name loop\n+            Count := Count + 1;\n+            Name := Language_Htable.Get_Next;\n+         end loop;\n+\n+         Result := new String_List (1 .. Count);\n+         Count  := 1;\n+         Name   := Language_Htable.Get_First;\n+\n+         while Name /= No_Name loop\n+            --  Check if IDE'Compiler_Command is declared for the language.\n+            --  If it is, use its value to invoke gprconfig.\n+\n+            Variable :=\n+              Value_Of\n+                (Name,\n+                 Attribute_Or_Array_Name => Name_Compiler_Command,\n+                 In_Package              => IDE,\n+                 In_Tree                 => Project_Tree,\n+                 Force_Lower_Case_Index  => True);\n+\n+            declare\n+               Config_Command : constant String :=\n+                 \"--config=\" & Get_Name_String (Name);\n+\n+               Runtime_Name   : constant String :=\n+                 Runtime_Name_For (Name);\n+\n+            begin\n+               if Variable = Nil_Variable_Value\n+                 or else Length_Of_Name (Variable.Value) = 0\n+               then\n+                  Result (Count) :=\n+                    new String'(Config_Command & \",,\" & Runtime_Name);\n+\n+               else\n+                  declare\n+                     Compiler_Command : constant String :=\n+                       Get_Name_String (Variable.Value);\n+\n+                  begin\n+                     if Is_Absolute_Path (Compiler_Command) then\n+                        Result (Count) :=\n+                          new String'\n+                            (Config_Command & \",,\" & Runtime_Name & \",\" &\n+                             Containing_Directory (Compiler_Command) & \",\" &\n+                             Simple_Name (Compiler_Command));\n+                     else\n+                        Result (Count) :=\n+                          new String'\n+                            (Config_Command & \",,\" & Runtime_Name & \",,\" &\n+                             Compiler_Command);\n+                     end if;\n+                  end;\n+               end if;\n+            end;\n+\n+            Count := Count + 1;\n+            Name  := Language_Htable.Get_Next;\n+         end loop;\n+\n+         return Result;\n+      end Get_Config_Switches;\n+\n+      -----------------\n+      -- Do_Autoconf --\n+      -----------------\n+\n+      procedure Do_Autoconf is\n+         Obj_Dir : constant Variable_Value :=\n+           Value_Of (Name_Object_Dir, Project.Decl.Attributes, Project_Tree);\n+\n+         Gprconfig_Path  : String_Access;\n+         Success         : Boolean;\n+      begin\n+         Gprconfig_Path := Locate_Exec_On_Path (Gprconfig_Name);\n+\n+         if Gprconfig_Path = null then\n+            Fail (\"could not locate gprconfig for auto-configuration\");\n+         end if;\n+\n+         --  First, find the object directory of the user's project\n+\n+         if Obj_Dir = Nil_Variable_Value or else Obj_Dir.Default then\n+            Get_Name_String (Project.Directory.Name);\n+\n+         else\n+            if Is_Absolute_Path (Get_Name_String (Obj_Dir.Value)) then\n+               Get_Name_String (Obj_Dir.Value);\n+\n+            else\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer\n+                 (Get_Name_String (Project.Directory.Name));\n+               Add_Char_To_Name_Buffer (Directory_Separator);\n+               Add_Str_To_Name_Buffer (Get_Name_String (Obj_Dir.Value));\n+            end if;\n+         end if;\n+\n+         if Subdirs /= null then\n+            Add_Char_To_Name_Buffer (Directory_Separator);\n+            Add_Str_To_Name_Buffer (Subdirs.all);\n+         end if;\n+\n+         for J in 1 .. Name_Len loop\n+            if Name_Buffer (J) = '/' then\n+               Name_Buffer (J) := Directory_Separator;\n+            end if;\n+         end loop;\n+\n+         declare\n+            Obj_Dir  : constant String := Name_Buffer (1 .. Name_Len);\n+            Switches : Argument_List_Access := Get_Config_Switches;\n+            Args     : Argument_List (1 .. 5);\n+            Arg_Last : Positive;\n+\n+         begin\n+            --  Check if the object directory exists. If Setup_Projects is True\n+            --  (-p) and directory does not exist, attempt to create it.\n+            --  Otherwise, if directory does not exist, fail without calling\n+            --  gprconfig.\n+\n+            if not Is_Directory (Obj_Dir)\n+              and then (Setup_Projects or Subdirs /= null)\n+            then\n+               begin\n+                  Create_Path (Obj_Dir);\n+\n+                  if not Quiet_Output then\n+                     Write_Str (\"object directory \"\"\");\n+                     Write_Str (Obj_Dir);\n+                     Write_Line (\"\"\" created\");\n+                  end if;\n+\n+               exception\n+                  when others =>\n+                     Fail (\"could not create object directory \" & Obj_Dir);\n+               end;\n+            end if;\n+\n+            if not Is_Directory (Obj_Dir) then\n+               Fail (\"object directory \" & Obj_Dir & \" does not exist\");\n+            end if;\n+\n+            --  Invoke gprconfig\n+\n+            Args (1) := new String'(\"--batch\");\n+            Args (2) := new String'(\"-o\");\n+\n+            --  If no config file was specified, set the auto.cgpr one\n+\n+            if Config_File_Name = \"\" then\n+               Args (3) := new String'\n+                 (Obj_Dir & Directory_Separator & Auto_Cgpr);\n+            else\n+               Args (3) := new String'(Config_File_Name);\n+            end if;\n+\n+            if Target_Name = \"\" then\n+               Args (4) := new String'(\"--target=\" & Normalized_Hostname);\n+            else\n+               Args (4) := new String'(\"--target=\" & Target_Name);\n+            end if;\n+\n+            Arg_Last := 4;\n+\n+            if not Verbose_Mode then\n+               Arg_Last := Arg_Last + 1;\n+               Args (Arg_Last) := new String'(\"-q\");\n+            end if;\n+\n+            if Verbose_Mode then\n+               Write_Str (Gprconfig_Name);\n+\n+               for J in 1 .. Arg_Last loop\n+                  Write_Char (' ');\n+                  Write_Str (Args (J).all);\n+               end loop;\n+\n+               for J in Switches'Range loop\n+                  Write_Char (' ');\n+                  Write_Str (Switches (J).all);\n+               end loop;\n+\n+               Write_Eol;\n+\n+            elsif not Quiet_Output then\n+               Write_Str (\"creating \");\n+               Write_Str (Simple_Name (Args (3).all));\n+               Write_Eol;\n+            end if;\n+\n+            Spawn (Gprconfig_Path.all, Args (1 .. Arg_Last) & Switches.all,\n+                   Success);\n+\n+            Free (Switches);\n+\n+            Config_File_Path := Locate_Config_File (Args (3).all);\n+\n+            if Config_File_Path = null then\n+               Fail (\"could not create \" & Args (3).all);\n+            end if;\n+\n+            for F in Args'Range loop\n+               Free (Args (F));\n+            end loop;\n+         end;\n+      end Do_Autoconf;\n+\n+      Success             : Boolean;\n+      Config_Project_Node : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      Free (Config_File_Path);\n+\n+      if Config_File_Name /= \"\" then\n+         Config_File_Path := Locate_Config_File (Config_File_Name);\n+      else\n+         Config_File_Path := Locate_Config_File (Default_File_Name);\n+      end if;\n+\n+      if Config_File_Path = null then\n+         if (not Allow_Automatic_Generation) and then\n+            Config_File_Name /= \"\"\n+         then\n+            Osint.Fail\n+              (\"could not locate main configuration project \" &\n+               Config_File_Name);\n+         end if;\n+      end if;\n+\n+      Automatically_Generated :=\n+        Allow_Automatic_Generation and then Config_File_Path = null;\n+\n+      <<Process_Config_File>>\n+\n+      if Automatically_Generated then\n+         Do_Autoconf;\n+      end if;\n+\n+      --  Parse the configuration file\n+\n+      if Verbose_Mode then\n+         Write_Str  (\"Checking configuration \");\n+         Write_Line (Config_File_Path.all);\n+      end if;\n+\n+      Prj.Part.Parse\n+        (In_Tree                => Project_Node_Tree,\n+         Project                => Config_Project_Node,\n+         Project_File_Name      => Config_File_Path.all,\n+         Always_Errout_Finalize => False,\n+         Packages_To_Check      => Packages_To_Check,\n+         Current_Directory      => Current_Directory,\n+         Is_Config_File         => True);\n+\n+      if Config_Project_Node /= Empty_Node then\n+         Prj.Proc.Process_Project_Tree_Phase_1\n+           (In_Tree                => Project_Tree,\n+            Project                => Config,\n+            Success                => Success,\n+            From_Project_Node      => Config_Project_Node,\n+            From_Project_Node_Tree => Project_Node_Tree,\n+            Report_Error           => null,\n+            Reset_Tree             => False);\n+      end if;\n+\n+      if Config_Project_Node = Empty_Node\n+        or else Config = No_Project\n+      then\n+         Osint.Fail\n+           (\"processing of configuration project \"\"\" &\n+            Config_File_Path.all & \"\"\" failed\");\n+      end if;\n+\n+      --  Check that the target of the configuration file is the one the user\n+      --  specified on the command line. We do not need to check that when in\n+      --  auto-conf mode, since the appropriate target was passed to gprconfig.\n+\n+      if not Automatically_Generated\n+        and not Check_Target\n+          (Config, Autoconf_Specified, Project_Tree, Target_Name)\n+      then\n+         Automatically_Generated := True;\n+         goto Process_Config_File;\n+      end if;\n+   end Get_Or_Create_Configuration_File;\n+\n+   ------------------------------------\n+   -- Parse_Project_And_Apply_Config --\n+   ------------------------------------\n+\n+   procedure Parse_Project_And_Apply_Config\n+     (Main_Project               : out Prj.Project_Id;\n+      User_Project_Node          : out Prj.Tree.Project_Node_Id;\n+      Config_File_Name           : String := \"\";\n+      Autoconf_Specified         : Boolean;\n+      Project_File_Name          : String;\n+      Project_Tree               : Prj.Project_Tree_Ref;\n+      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n+      Packages_To_Check          : String_List_Access;\n+      Allow_Automatic_Generation : Boolean := True;\n+      Automatically_Generated    : out Boolean;\n+      Config_File_Path           : out String_Access;\n+      Target_Name                : String := \"\";\n+      Normalized_Hostname        : String;\n+      On_Load_Config             : Config_File_Hook := null)\n+   is\n+      Main_Config_Project : Project_Id;\n+      Success : Boolean;\n+\n+   begin\n+      --  Parse the user project tree\n+\n+      Prj.Initialize (Project_Tree);\n+      Prj.Tree.Initialize (Project_Node_Tree);\n+\n+      Main_Project      := No_Project;\n+      Automatically_Generated := False;\n+\n+      Prj.Part.Parse\n+        (In_Tree                => Project_Node_Tree,\n+         Project                => User_Project_Node,\n+         Project_File_Name      => Project_File_Name,\n+         Always_Errout_Finalize => False,\n+         Packages_To_Check      => Packages_To_Check,\n+         Current_Directory      => Current_Directory,\n+         Is_Config_File         => False);\n+\n+      if User_Project_Node = Empty_Node then\n+         User_Project_Node := Empty_Node;\n+         return;\n+      end if;\n+\n+      Process_Project_Tree_Phase_1\n+        (In_Tree                => Project_Tree,\n+         Project                => Main_Project,\n+         Success                => Success,\n+         From_Project_Node      => User_Project_Node,\n+         From_Project_Node_Tree => Project_Node_Tree,\n+         Report_Error           => null);\n+\n+      if not Success then\n+         Main_Project := No_Project;\n+         return;\n+      end if;\n+\n+      --  Find configuration file\n+\n+      Get_Or_Create_Configuration_File\n+        (Config                     => Main_Config_Project,\n+         Project                    => Main_Project,\n+         Project_Tree               => Project_Tree,\n+         Project_Node_Tree          => Project_Node_Tree,\n+         Allow_Automatic_Generation => Allow_Automatic_Generation,\n+         Config_File_Name           => Config_File_Name,\n+         Autoconf_Specified         => Autoconf_Specified,\n+         Target_Name                => Target_Name,\n+         Normalized_Hostname        => Normalized_Hostname,\n+         Packages_To_Check          => Packages_To_Check,\n+         Config_File_Path           => Config_File_Path,\n+         Automatically_Generated    => Automatically_Generated);\n+\n+      if On_Load_Config /= null then\n+         On_Load_Config\n+           (Config_File  => Main_Config_Project,\n+            Project_Tree => Project_Tree);\n+      end if;\n+\n+      Apply_Config_File (Main_Config_Project, Project_Tree);\n+\n+      --  Finish processing the user's project\n+\n+      Sinput.P.Reset_First;\n+\n+      Prj.Proc.Process_Project_Tree_Phase_2\n+        (In_Tree                => Project_Tree,\n+         Project                => Main_Project,\n+         Success                => Success,\n+         From_Project_Node      => User_Project_Node,\n+         From_Project_Node_Tree => Project_Node_Tree,\n+         Report_Error           => null,\n+         Current_Dir            => Current_Directory,\n+         When_No_Sources        => Warning,\n+         Is_Config_File         => False);\n+\n+      if not Success then\n+         Prj.Err.Finalize;\n+         Osint.Fail (\"\"\"\" & Project_File_Name & \"\"\" processing failed\");\n+      end if;\n+   end Parse_Project_And_Apply_Config;\n+\n+   -----------------------\n+   -- Apply_Config_File --\n+   -----------------------\n+\n+   procedure Apply_Config_File\n+     (Config_File  : Prj.Project_Id;\n+      Project_Tree : Prj.Project_Tree_Ref)\n+   is\n+      Conf_Decl    : constant Declarations := Config_File.Decl;\n+      Conf_Pack_Id : Package_Id;\n+      Conf_Pack    : Package_Element;\n+\n+      User_Decl    : Declarations;\n+      User_Pack_Id : Package_Id;\n+      User_Pack    : Package_Element;\n+      Proj         : Project_List;\n+\n+   begin\n+      Proj := Project_Tree.Projects;\n+\n+      while Proj /= null loop\n+         if Proj.Project /= Config_File then\n+            User_Decl := Proj.Project.Decl;\n+            Add_Attributes\n+              (Project_Tree => Project_Tree,\n+               Conf_Decl    => Conf_Decl,\n+               User_Decl    => User_Decl);\n+\n+            Conf_Pack_Id := Conf_Decl.Packages;\n+            while Conf_Pack_Id /= No_Package loop\n+               Conf_Pack := Project_Tree.Packages.Table (Conf_Pack_Id);\n+\n+               User_Pack_Id := User_Decl.Packages;\n+               while User_Pack_Id /= No_Package loop\n+                  User_Pack := Project_Tree.Packages.Table (User_Pack_Id);\n+                  exit when User_Pack.Name = Conf_Pack.Name;\n+                  User_Pack_Id := User_Pack.Next;\n+               end loop;\n+\n+               if User_Pack_Id = No_Package then\n+                  Package_Table.Increment_Last (Project_Tree.Packages);\n+                  User_Pack := Conf_Pack;\n+                  User_Pack.Next := User_Decl.Packages;\n+                  User_Decl.Packages :=\n+                    Package_Table.Last (Project_Tree.Packages);\n+                  Project_Tree.Packages.Table (User_Decl.Packages) :=\n+                    User_Pack;\n+\n+               else\n+                  Add_Attributes\n+                    (Project_Tree => Project_Tree,\n+                     Conf_Decl    => Conf_Pack.Decl,\n+                     User_Decl    => Project_Tree.Packages.Table\n+                       (User_Pack_Id).Decl);\n+               end if;\n+\n+               Conf_Pack_Id := Conf_Pack.Next;\n+            end loop;\n+\n+            Proj.Project.Decl := User_Decl;\n+         end if;\n+\n+         Proj := Proj.Next;\n+      end loop;\n+   end Apply_Config_File;\n+\n+   ---------------------\n+   -- Set_Runtime_For --\n+   ---------------------\n+\n+   procedure Set_Runtime_For (Language : Name_Id; RTS_Name : String) is\n+   begin\n+      Name_Len := RTS_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := RTS_Name;\n+      RTS_Languages.Set (Language, Name_Find);\n+   end Set_Runtime_For;\n+\n+   ----------------------\n+   -- Runtime_Name_For --\n+   ----------------------\n+\n+   function Runtime_Name_For (Language : Name_Id) return String is\n+   begin\n+      if RTS_Languages.Get (Language) /= No_Name then\n+         return Get_Name_String (RTS_Languages.Get (Language));\n+      else\n+         return \"\";\n+      end if;\n+   end Runtime_Name_For;\n+\n+end Prj.Conf;"}, {"sha": "773e3ba680ac17903c4c03bdec0157cff3034061", "filename": "gcc/ada/prj-conf.ads", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe19d88066a6afdaf8c6917a631d21e30e4091c/gcc%2Fada%2Fprj-conf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe19d88066a6afdaf8c6917a631d21e30e4091c/gcc%2Fada%2Fprj-conf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.ads?ref=abe19d88066a6afdaf8c6917a631d21e30e4091c", "patch": "@@ -0,0 +1,140 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . C O N F                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006-2009, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The following package manipulates the configuration files.\n+\n+with Prj.Tree;\n+\n+package Prj.Conf is\n+\n+   type Config_File_Hook is access procedure\n+     (Config_File  : Prj.Project_Id;\n+      Project_Tree : Prj.Project_Tree_Ref);\n+   --  Hook called after the config file has been parsed. This lets the\n+   --  application do last minute changes to it (GPS uses this to add the\n+   --  default naming schemes for instance). At that point, the config file has\n+   --  not been applied to the project yet.\n+\n+   procedure Parse_Project_And_Apply_Config\n+     (Main_Project               : out Prj.Project_Id;\n+      User_Project_Node          : out Prj.Tree.Project_Node_Id;\n+      Config_File_Name           : String := \"\";\n+      Autoconf_Specified         : Boolean;\n+      Project_File_Name          : String;\n+      Project_Tree               : Prj.Project_Tree_Ref;\n+      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n+      Packages_To_Check          : String_List_Access;\n+      Allow_Automatic_Generation : Boolean := True;\n+      Automatically_Generated    : out Boolean;\n+      Config_File_Path           : out String_Access;\n+      Target_Name                : String := \"\";\n+      Normalized_Hostname        : String;\n+      On_Load_Config             : Config_File_Hook := null);\n+   --  Find the main configuration project and parse the project tree rooted at\n+   --  this configuration project.\n+   --  If the processing fails, Main_Project is set to No_Project. If the error\n+   --  happend while parsing the project itself (ie creating the tree),\n+   --  User_Project_Node is also set to Empty_Node\n+   --\n+   --  Autoconf_Specified indicates whether the user has specified --autoconf.\n+   --  If this is the case, the config file might be (re)generated, as\n+   --  appropriate, to match languages and target if the one specified doesn't\n+   --  already match.\n+   --  Normalized_Hostname is the host on which gprbuild is returned,\n+   --  normalized so that we can more easily compare it with what is stored in\n+   --  configuration files. It is used when the target is unspecified, although\n+   --  we need to know the target specified by the user (Target_Name) when\n+   --  computing the name of the default config file that should be used.\n+   --\n+   --  If specified, On_Load_Config is called just after the config file has\n+   --  been created/loaded. You can then modify it before it is later applied\n+   --  to the project itself.\n+\n+   procedure Get_Or_Create_Configuration_File\n+     (Project                    : Prj.Project_Id;\n+      Project_Tree               : Prj.Project_Tree_Ref;\n+      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n+      Allow_Automatic_Generation : Boolean;\n+      Config_File_Name           : String := \"\";\n+      Autoconf_Specified         : Boolean;\n+      Target_Name                : String := \"\";\n+      Normalized_Hostname        : String;\n+      Packages_To_Check          : String_List_Access := null;\n+      Config                     : out Prj.Project_Id;\n+      Config_File_Path           : out String_Access;\n+      Automatically_Generated    : out Boolean);\n+   --  Compute the name of the configuration file that should be used. If no\n+   --  default configuration file is found, a new one will be automatically\n+   --  generated if Allow_Automatic_Generation is true (otherwise an error\n+   --  reported to the user via Osint.Fail).\n+   --  On exit, Configuration_Project_Path is never null (if none could be\n+   --  found, Os.Fail was called and the program exited anyway).\n+   --  The choice and generation of a configuration file depends on several\n+   --  attributes of the user's project file (given by the Project argument),\n+   --  like the list of languages that must be supported. Project must\n+   --  therefore have been partially processed (phase one of the processing\n+   --  only).\n+   --  Config_File_Name should be set to the name of the config file specified\n+   --  by the user (either through gprbuild's --config or --autoconf switches).\n+   --  In the latter case, Autoconf_Specified should be set to true, to\n+   --  indicate that the configuration file can be regenerated to match target\n+   --  and languages. This name can either be an absolute path, or the a base\n+   --  name that will be searched in the default config file directories (which\n+   --  depends on the installation path for the tools).\n+   --  Target_Name is used to chose among several possibilities\n+   --  the configuration file that will be used.\n+   --\n+   --  If a project file could be found, it is automatically parsed and\n+   --  processed (and Packages_To_Check is used to indicate which packages\n+   --  should be processed)\n+\n+   procedure Apply_Config_File\n+     (Config_File  : Prj.Project_Id;\n+      Project_Tree : Prj.Project_Tree_Ref);\n+   --  Apply the configuration file settings to all the projects in the\n+   --  project tree. The Project_Tree must have been parsed first, and\n+   --  processed through the first phase so that all its projects are known.\n+   --\n+   --  Currently, this will add new attributes and packages in the various\n+   --  projects, so that when the second phase of the processing is performed\n+   --  these attributes are automatically taken into account.\n+\n+   --------------\n+   -- Runtimes --\n+   --------------\n+\n+   procedure Set_Runtime_For (Language : Name_Id; RTS_Name : String);\n+   --  Specifies the runtime to use for a specific language. Most of the time\n+   --  this should be used for Ada, but other languages can also specify their\n+   --  own runtime. This is in general specified via the --RTS command line\n+   --  switch, and results in a specific component passed to gprconfig's\n+   --  --config switch then automatically generating a configuration file.\n+\n+   function Runtime_Name_For (Language : Name_Id) return String;\n+   --  Returns the runtime name for a language. Returns an empty string if\n+   --  no runtime was specified for the language using option --RTS.\n+\n+end Prj.Conf;"}]}