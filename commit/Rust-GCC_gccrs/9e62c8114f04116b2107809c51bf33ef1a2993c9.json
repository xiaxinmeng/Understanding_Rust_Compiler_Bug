{"sha": "9e62c8114f04116b2107809c51bf33ef1a2993c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU2MmM4MTE0ZjA0MTE2YjIxMDc4MDljNTFiZjMzZWYxYTI5OTNjOQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-21T17:18:50Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-21T17:18:50Z"}, "message": "cpphash.c (struct arg, [...]): Const-ify strings.\n\n\t* cpphash.c (struct arg, struct arglist): Const-ify strings.\n\t(warn_trad_stringify, duplicate_arg_p): New helper functions.\n\t(collect_expansion): Rewrite to scan over a token list.\n\tRemove -traditional support.\n\t(collect_formal_parameters): Rename to collect_params; rewrite\n\tto scan over a token list.\n\t(_cpp_create_definition): Adjust to scan a token list.\n\t(_cpp_macroexpand): Remove -traditional support.\n\t(_cpp_compare_defs): Whitespace is now canonicalized.\n\t(comp_def_part): Delete function.\n\n\t* cpphash.h: Update prototypes.\n\t* cpplex.c (init_token_list): Don't set lineno if there is no\n\tbuffer.\n\t(pedantic_whitespace): New function.\n\t(_cpp_scan_line): Mark tokens that had hspace before.  Don't\n\tconsume a newline.  Use pedantic_whitespace.\n\t(_cpp_lex_token): Remove support for -traditional macros.\n\t(_cpp_get_define_token): Delete.\n\t(_cpp_get_directive_token): Do the real work here.  Use\n\tpedantic_whitespace.\n\t(_cpp_init_input_buffer): Initialize pfile->directbuf.\n\n\t* cpplib.c (get_macro_name): Delete.\n\t(do_define): Read the entire line into pfile->directbuf, then\n\tfeed the token list to _cpp_create_definition.\n\t* cpplib.h (HSPACE_BEFORE): new define.\n\t(struct cpp_reader): Add a toklist member, \"directbuf\".\n\nFrom-SVN: r33309", "tree": {"sha": "21832fd028eb53eea53190faa67b40ac42811fbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21832fd028eb53eea53190faa67b40ac42811fbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e62c8114f04116b2107809c51bf33ef1a2993c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e62c8114f04116b2107809c51bf33ef1a2993c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e62c8114f04116b2107809c51bf33ef1a2993c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e62c8114f04116b2107809c51bf33ef1a2993c9/comments", "author": null, "committer": null, "parents": [{"sha": "152897b1529264336677bc782f882a5b09041ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152897b1529264336677bc782f882a5b09041ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152897b1529264336677bc782f882a5b09041ac3"}], "stats": {"total": 908, "additions": 396, "deletions": 512}, "files": [{"sha": "f9ef0700408002a8bd5c5d1c9266d128f9bfa8b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e62c8114f04116b2107809c51bf33ef1a2993c9", "patch": "@@ -1,5 +1,34 @@\n 2000-04-21  Zack Weinberg  <zack@wolery.cumb.org>\n \n+\t* cpphash.c (struct arg, struct arglist): Const-ify strings.\n+\t(warn_trad_stringify, duplicate_arg_p): New helper functions.\n+\t(collect_expansion): Rewrite to scan over a token list.\n+\tRemove -traditional support.\n+\t(collect_formal_parameters): Rename to collect_params; rewrite\n+\tto scan over a token list.\n+\t(_cpp_create_definition): Adjust to scan a token list.\n+\t(_cpp_macroexpand): Remove -traditional support.\n+\t(_cpp_compare_defs): Whitespace is now canonicalized.\n+\t(comp_def_part): Delete function.\n+\n+\t* cpphash.h: Update prototypes.\n+\t* cpplex.c (init_token_list): Don't set lineno if there is no\n+\tbuffer.\n+\t(pedantic_whitespace): New function.\n+\t(_cpp_scan_line): Mark tokens that had hspace before.  Don't\n+\tconsume a newline.  Use pedantic_whitespace.\n+\t(_cpp_lex_token): Remove support for -traditional macros.\n+\t(_cpp_get_define_token): Delete.\n+\t(_cpp_get_directive_token): Do the real work here.  Use\n+\tpedantic_whitespace.\n+\t(_cpp_init_input_buffer): Initialize pfile->directbuf.\n+\n+\t* cpplib.c (get_macro_name): Delete.\n+\t(do_define): Read the entire line into pfile->directbuf, then\n+\tfeed the token list to _cpp_create_definition.\n+\t* cpplib.h (HSPACE_BEFORE): new define.\n+\t(struct cpp_reader): Add a toklist member, \"directbuf\".\n+\n \t* predict.c (estimate_probability): New heuristic: if a jump\n \tbranches around a block with no successors, predict it taken.\n \tDisentangle control flow."}, {"sha": "c39ca9f5fa69c5bdfcbed2127aa9259d5e5e3eaf", "filename": "gcc/cpphash.c", "status": "modified", "additions": 266, "deletions": 405, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=9e62c8114f04116b2107809c51bf33ef1a2993c9", "patch": "@@ -36,8 +36,6 @@ static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n static void del_HASHNODE\t  PARAMS ((void *));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n \n-static int comp_def_part\t PARAMS ((int, U_CHAR *, int, U_CHAR *,\n-\t\t\t\t\t  int, int));\n static void push_macro_expansion PARAMS ((cpp_reader *,\n \t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n static int unsafe_chars\t\t PARAMS ((cpp_reader *, int, int));\n@@ -61,21 +59,27 @@ static void special_symbol\t PARAMS ((HASHNODE *, cpp_reader *));\n \n struct arg\n {\n-  U_CHAR *name;\n-  int len;\n+  const U_CHAR *name;\n+  unsigned int len;\n   char rest_arg;\n };\n \n struct arglist\n {\n   U_CHAR *namebuf;\n-  struct arg *argv;\n+  const struct arg *argv;\n   int argc;\n };\n \n \n-static DEFINITION *collect_expansion PARAMS ((cpp_reader *, struct arglist *));\n-static struct arglist *collect_formal_parameters PARAMS ((cpp_reader *));\n+static DEFINITION *collect_expansion PARAMS ((cpp_reader *, cpp_toklist *,\n+\t\t\t\t\t      struct arglist *, unsigned int));\n+static unsigned int collect_params PARAMS ((cpp_reader *, cpp_toklist *,\n+\t\t\t\t\t    struct arglist *));\n+\n+static void warn_trad_stringify\tPARAMS ((cpp_reader *, U_CHAR *, size_t,\n+\t\t\t\t\t unsigned int, const struct arg *));\n+static int duplicate_arg_p PARAMS ((U_CHAR *, U_CHAR *));\n \n /* This structure represents one parsed argument in a macro call.\n    `raw' points to the argument text as written (`raw_length' is its length).\n@@ -275,28 +279,64 @@ macro_cleanup (pbuf, pfile)\n   return 0;\n }\n \n+/* Issue warnings for macro argument names seen inside strings.  */\n+static void\n+warn_trad_stringify (pfile, p, len, argc, argv)\n+     cpp_reader *pfile;\n+     U_CHAR *p;\n+     size_t len;\n+     unsigned int argc;\n+     const struct arg *argv;\n+     \n+{\n+  U_CHAR *limit;\n+  unsigned int i;\n+\n+  limit = p + len;\n+  for (;;)\n+    {\n+      while (p < limit && !is_idstart (*p)) p++;\n+      if (p >= limit)\n+\tbreak;\n+\n+      for (i = 0; i < argc; i++)\n+\tif (!strncmp (p, argv[i].name, argv[i].len)\n+\t    && ! is_idchar (p[argv[i].len]))\n+\t  {\n+\t    cpp_warning (pfile,\n+\t\t\"macro argument \\\"%s\\\" would be stringified in traditional C\",\n+\t\t\t argv[i].name);\n+\t    break;\n+\t  }\n+      p++;\n+      while (p < limit && is_idchar (*p)) p++;\n+      if (p >= limit)\n+\tbreak;\n+    }\n+}\n+\n /* Read a replacement list for a macro, and build the DEFINITION\n-   structure.  ARGLIST specifies the formal parameters to look for in\n-   the text of the definition.  If ARGLIST is null, this is an\n+   structure.  LIST contains the replacement list, beginning at\n+   REPLACEMENT.  ARGLIST specifies the formal parameters to look for\n+   in the text of the definition.  If ARGLIST is null, this is an\n    object-like macro; if it points to an empty arglist, this is a\n-   function-like macro with no arguments.\n-\n-   A good half of this is devoted to supporting -traditional.\n-   Kill me now.  */\n+   function-like macro with no arguments.  */\n \n static DEFINITION *\n-collect_expansion (pfile, arglist)\n+collect_expansion (pfile, list, arglist, replacement)\n      cpp_reader *pfile;\n+     cpp_toklist *list;\n      struct arglist *arglist;\n+     unsigned int replacement;\n {\n   DEFINITION *defn;\n   struct reflist *pat = 0, *endpat = 0;\n   enum cpp_ttype token;\n-  long start, here, last;\n-  int i;\n-  int argc;\n+  long start, last;\n+  unsigned int i;\n+  int j, argc;\n   size_t len;\n-  struct arg *argv;\n+  const struct arg *argv;\n   U_CHAR *tok, *exp;\n   enum { START = 0, NORM, ARG, STRIZE, PASTE } last_token = START;\n \n@@ -311,15 +351,16 @@ collect_expansion (pfile, arglist)\n       argc = 0;\n     }\n \n+  /* We copy the expansion text into the token_buffer, then out to\n+     its proper home.  */\n   last = start = CPP_WRITTEN (pfile);\n-  last -= 2;  /* two extra chars for the leading escape */\n-  for (;;)\n+  CPP_PUTS (pfile, \"\\r \", 2);\n+\n+  for (i = replacement; i < list->tokens_used; i++)\n     {\n-      /* Macro expansion is off, so we are guaranteed not to see POP\n-\t or EOF.  */\n-      here = CPP_WRITTEN (pfile);\n-      token = _cpp_get_define_token (pfile);\n-      tok = pfile->token_buffer + here;\n+      token = list->tokens[i].type;\n+      tok = list->tokens[i].val.name.offset + list->namebuf;\n+      len = list->tokens[i].val.name.len;\n       switch (token)\n \t{\n \tcase CPP_POP:\n@@ -329,90 +370,54 @@ collect_expansion (pfile, arglist)\n \tcase CPP_VSPACE:\n \t  goto done;\n \n-\tcase CPP_HSPACE:\n-\t  if (last_token == STRIZE || last_token == PASTE\n-\t      || last_token == START)\n-\t    CPP_SET_WRITTEN (pfile, here);\n-\t  break;\n-\n \tcase CPP_HASH:\n \t  /* # is not special in object-like macros.  It is special in\n-\t     function-like macros with no args.  (6.10.3.2 para 1.) */\n-\t  if (arglist == NULL)\n-\t    goto norm;\n-\t  /* # is not special immediately after PASTE.\n-\t     (Implied by 6.10.3.3 para 4.)  */\n-\t  if (last_token == PASTE)\n+\t     function-like macros with no args.  (6.10.3.2 para 1.)\n+\t     However, it is not special after PASTE. (Implied by\n+\t     6.10.3.3 para 4.)  */\n+\t  if (arglist == NULL || last_token == PASTE)\n \t    goto norm;\n \t  last_token = STRIZE;\n-\t  CPP_SET_WRITTEN (pfile, here);  /* delete from replacement text */\n \t  break;\n \n \tcase CPP_PASTE:\n-\t  /* If the last token was an argument, discard this token and\n-\t     any hspace between it and the argument's position.  Then\n-\t     mark the arg raw_after.  */\n-\t  if (last_token == ARG)\n-\t    {\n-\t      endpat->raw_after = 1;\n-\t      last_token = PASTE;\n-\t      CPP_SET_WRITTEN (pfile, last);\n-\t      break;\n-\t    }\n-\t  else if (last_token == PASTE)\n+\t  if (last_token == PASTE)\n \t    /* ## ## - the second ## is ordinary.  */\n \t    goto norm;\n \t  else if (last_token == START)\n \t    cpp_error (pfile, \"`##' at start of macro definition\");\n-\t  \n-\t  /* Discard the token and any hspace before it.  */\n-\t  while (is_hspace (pfile->token_buffer[here-1]))\n-\t    here--;\n-\t  CPP_SET_WRITTEN (pfile, here);\n-\n-\t  if (last_token == STRIZE)\n+\t    \n+\t  else if (last_token == ARG)\n+\t    /* If the last token was an argument, mark it raw_after.  */\n+\t    endpat->raw_after = 1;\n+\t  else if (last_token == STRIZE)\n \t    /* Oops - that wasn't a stringify operator.  */\n \t    CPP_PUTC (pfile, '#');\n-\t  last_token = PASTE;\n-\t  break;\n \n-\tcase CPP_COMMENT:\n-\t  /* We must be in -traditional mode.  Pretend this was a\n-\t     token paste, but only if there was no leading or\n-\t     trailing space and it's in the middle of the line.\n-\t     _cpp_lex_token won't return a COMMENT if there was trailing\n-\t     space.  */\n-\t  CPP_SET_WRITTEN (pfile, here);\n-\t  if (last_token == START)\n-\t    break;\n-\t  if (is_hspace (pfile->token_buffer[here-1]))\n-\t    break;\n-\t  if (last_token == ARG)\n-\t    endpat->raw_after = 1;\n \t  last_token = PASTE;\n \t  break;\n \n \tcase CPP_STRING:\n \tcase CPP_CHAR:\n-\t  if (last_token == STRIZE)\n-\t    cpp_error (pfile, \"`#' is not followed by a macro argument name\");\n-\n-\t  if (CPP_TRADITIONAL (pfile) || CPP_WTRADITIONAL (pfile))\n-\t    goto maybe_trad_stringify;\n-\t  else\n-\t    goto norm;\n+\t  if (argc && CPP_WTRADITIONAL (pfile))\n+\t    warn_trad_stringify (pfile, tok, len, argc, argv);\n+\t  goto norm;\n \t  \n \tcase CPP_NAME:\n-\t  for (i = 0; i < argc; i++)\n-\t    if (!strncmp (tok, argv[i].name, argv[i].len)\n-\t\t&& tok + argv[i].len == CPP_PWRITTEN (pfile))\n+\t  for (j = 0; j < argc; j++)\n+\t    if (argv[j].len == len\n+\t\t&& !strncmp (tok, argv[j].name, argv[j].len))\n \t      goto addref;\n \n \t  /* fall through */\n \tdefault:\n \tnorm:\n \t  if (last_token == STRIZE)\n-\t    cpp_error (pfile, \"`#' is not followed by a macro argument name\");\n+\t    cpp_error (pfile, \"# is not followed by a macro argument name\");\n+\t  if (last_token != PASTE && last_token != START\n+\t      && (list->tokens[i].flags & HSPACE_BEFORE))\n+\t    CPP_PUTC (pfile, ' ');\n+\t  CPP_PUTS (pfile, tok, len);\n \t  last_token = NORM;\n \t  break;\n \t}\n@@ -421,85 +426,27 @@ collect_expansion (pfile, arglist)\n     addref:\n       {\n \tstruct reflist *tpat;\n-\t\n+\tif (last_token != PASTE && (list->tokens[i].flags & HSPACE_BEFORE))\n+\t  CPP_PUTC (pfile, ' ');\n+\n \t/* Make a pat node for this arg and add it to the pat list */\n \ttpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n \ttpat->next = NULL;\n \ttpat->raw_before = (last_token == PASTE);\n \ttpat->raw_after = 0;\n \ttpat->stringify = (last_token == STRIZE);\n-\ttpat->rest_args = argv[i].rest_arg;\n-\ttpat->argno = i;\n-\ttpat->nchars = here - last;\n+\ttpat->rest_args = argv[j].rest_arg;\n+\ttpat->argno = j;\n+\ttpat->nchars = CPP_WRITTEN (pfile) - last;\n \n \tif (endpat == NULL)\n \t  pat = tpat;\n \telse\n \t  endpat->next = tpat;\n \tendpat = tpat;\n-\tlast = here;\n+\tlast = CPP_WRITTEN (pfile);\n       }\n-      CPP_SET_WRITTEN (pfile, here);  /* discard arg name */\n       last_token = ARG;\n-      continue;\n-\n-    maybe_trad_stringify:\n-      last_token = NORM;\n-      {\n-\tU_CHAR *base, *p, *limit;\n-\tstruct reflist *tpat;\n-\n-\tbase = p = pfile->token_buffer + here;\n-\tlimit = CPP_PWRITTEN (pfile);\n-\n-\twhile (++p < limit)\n-\t  {\n-\t    if (is_idstart (*p))\n-\t      continue;\n-\t    for (i = 0; i < argc; i++)\n-\t      if (!strncmp (tok, argv[i].name, argv[i].len)\n-\t\t  && ! is_idchar (tok[argv[i].len]))\n-\t\tgoto mts_addref;\n-\t    continue;\n-\n-\t  mts_addref:\n-\t    if (!CPP_TRADITIONAL (pfile))\n-\t      {\n-\t\t/* Must have got here because of -Wtraditional.  */\n-\t\tcpp_warning (pfile,\n-\t     \"macro argument `%.*s' would be stringified with -traditional\",\n-\t\t\t     (int) argv[i].len, argv[i].name);\n-\t\tcontinue;\n-\t      }\n-\t    if (CPP_WTRADITIONAL (pfile))\n-\t      cpp_warning (pfile, \"macro argument `%.*s' is stringified\",\n-\t\t\t     (int) argv[i].len, argv[i].name);\n-\n-\t    /* Remove the argument from the string.  */\n-\t    memmove (p, p + argv[i].len, limit - (p + argv[i].len));\n-\t    limit -= argv[i].len;\n-\t\n-\t    /* Make a pat node for this arg and add it to the pat list */\n-\t    tpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n-\t    tpat->next = NULL;\n-\n-\t    /* Don't attempt to paste this with anything.  */\n-\t    tpat->raw_before = 0;\n-\t    tpat->raw_after = 0;\n-\t    tpat->stringify = 1;\n-\t    tpat->rest_args = argv[i].rest_arg;\n-\t    tpat->argno = i;\n-\t    tpat->nchars = (p - base) + here - last;\n-\n-\t    if (endpat == NULL)\n-\t      pat = tpat;\n-\t    else\n-\t      endpat->next = tpat;\n-\t    endpat = tpat;\n-\t    last = (p - base) + here;\n-\t  }\n-\tCPP_ADJUST_WRITTEN (pfile, CPP_PWRITTEN (pfile) - limit);\n-      }\n     }\n  done:\n \n@@ -508,241 +455,224 @@ collect_expansion (pfile, arglist)\n   else if (last_token == PASTE)\n     cpp_error (pfile, \"`##' at end of macro definition\");\n \n-  if (last_token == START)\n-    {\n-      /* Empty macro definition.  */\n-      exp = (U_CHAR *) xstrdup (\"\\r \\r \");\n-      len = 1;\n-    }\n-  else\n-    {\n-      /* Trim trailing white space from definition.  */\n-      here = CPP_WRITTEN (pfile);\n-      while (here > last && is_hspace (pfile->token_buffer [here-1]))\n-\there--;\n-      CPP_SET_WRITTEN (pfile, here);\n-      len = CPP_WRITTEN (pfile) - start + 1;\n-      /* space for no-concat markers at either end */\n-      exp = (U_CHAR *) xmalloc (len + 4);\n-      exp[0] = '\\r';\n-      exp[1] = ' ';\n-      exp[len + 1] = '\\r';\n-      exp[len + 2] = ' ';\n-      exp[len + 3] = '\\0';\n-      memcpy (&exp[2], pfile->token_buffer + start, len - 1);\n-    }\n-\n+    CPP_PUTS (pfile, \"\\r \", 2);\n+  len = CPP_WRITTEN (pfile) - start;\n   CPP_SET_WRITTEN (pfile, start);\n \n+  exp = (U_CHAR *) xmalloc (len + 1);\n+  memcpy (exp, pfile->token_buffer + start, len);\n+  exp[len] = '\\0';\n+\n   defn = (DEFINITION *) xmalloc (sizeof (DEFINITION));\n-  defn->length = len + 3;\n+  defn->length = len;\n   defn->expansion = exp;\n   defn->pattern = pat;\n-  defn->rest_args = 0;\n+  defn->rest_args = argv && argv[argc - 1].rest_arg;\n   if (arglist)\n     {\n       defn->nargs = argc;\n       defn->argnames = arglist->namebuf;\n       if (argv)\n-\t{\n-\t  defn->rest_args = argv[argc - 1].rest_arg;\n-\t  free (argv);\n-\t}\n-      free (arglist);\n+\tfree ((PTR) argv);\n     }\n   else\n     {\n       defn->nargs = -1;\n       defn->argnames = 0;\n-      defn->rest_args = 0;\n     }\n   return defn;\n }\n \n-static struct arglist *\n-collect_formal_parameters (pfile)\n+/* Is argument NEW, which has just been added to the argument list,\n+   a duplicate of a previous argument name?  */\n+static int\n+duplicate_arg_p (args, new)\n+     U_CHAR *args, *new;\n+{\n+  size_t newlen = strlen (new) + 1;\n+  size_t oldlen;\n+\n+  while (args < new)\n+    {\n+      oldlen = strlen (args) + 1;\n+      if (!memcmp (args, new, MIN (oldlen, newlen)))\n+\treturn 1;\n+      args += oldlen;\n+    }\n+  return 0;\n+}\n+\n+static unsigned int\n+collect_params (pfile, list, arglist)\n      cpp_reader *pfile;\n+     cpp_toklist *list;\n+     struct arglist *arglist;\n {\n-  struct arglist *result = 0;\n   struct arg *argv = 0;\n-  U_CHAR *namebuf = (U_CHAR *) xstrdup (\"\");\n+  U_CHAR *namebuf, *p, *tok;\n+  unsigned int len, argslen;\n+  unsigned int argc, a, i, j;\n \n-  U_CHAR *name, *tok;\n-  size_t argslen = 1;\n-  int len;\n-  int argc = 0;\n-  int i;\n-  enum cpp_ttype token;\n-  long old_written;\n-\n-  old_written = CPP_WRITTEN (pfile);\n-  token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_OPEN_PAREN)\n+  /* The formal parameters list starts at token 1.  */\n+  if (list->tokens[1].type != CPP_OPEN_PAREN)\n     {\n       cpp_ice (pfile, \"first token = %d not %d in collect_formal_parameters\",\n-\t       token, CPP_OPEN_PAREN);\n-      goto invalid;\n+\t       list->tokens[1].type, CPP_OPEN_PAREN);\n+      return 0;\n     }\n \n-  argv = (struct arg *) xmalloc (sizeof (struct arg));\n-  argv[argc].len = 0;\n-  argv[argc].rest_arg = 0;\n-  for (;;)\n-    {\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      token = _cpp_get_directive_token (pfile);\n-      switch (token)\n-\t{\n-\tcase CPP_NAME:\n-\t  tok = pfile->token_buffer + old_written;\n-\t  len = CPP_PWRITTEN (pfile) - tok;\n-\t  if (namebuf\n-\t      && (name = (U_CHAR *) strstr (namebuf, tok))\n-\t      && name[len] == ','\n-\t      && (name == namebuf || name[-1] == ','))\n-\t    {\n-\t      cpp_error (pfile, \"duplicate macro argument name `%s'\", tok);\n-\t      continue;\n-\t    }\n-\t  if (CPP_PEDANTIC (pfile) && CPP_OPTION (pfile, c99)\n-\t      && len == sizeof \"__VA_ARGS__\" - 1\n-\t      && !strncmp (tok, \"__VA_ARGS__\", len))\n-\t    cpp_pedwarn (pfile,\n-\t\"C99 does not permit use of `__VA_ARGS__' as a macro argument name\");\n-\t  namebuf = (U_CHAR *) xrealloc (namebuf, argslen + len + 1);\n-\t  name = &namebuf[argslen - 1];\n-\t  argslen += len + 1;\n-\n-\t  memcpy (name, tok, len);\n-\t  name[len] = ',';\n-\t  name[len+1] = '\\0';\n-\t  argv[argc].len = len;\n-\t  argv[argc].rest_arg = 0;\n-\t  break;\n-\n-\tcase CPP_COMMA:\n-\t  argc++;\n-\t  argv = (struct arg *) xrealloc (argv, (argc + 1)*sizeof(struct arg));\n-\t  argv[argc].len = 0;\n-\t  break;\n-\n-\tcase CPP_CLOSE_PAREN:\n-\t  goto done;\n+  /* Scan once and count the number of parameters; also check for\n+     syntax errors here.  */\n+  argc = 0;\n+  argslen = 0;\n+  for (i = 2; i < list->tokens_used; i++)\n+    switch (list->tokens[i].type)\n+      {\n+      case CPP_NAME:\n+\targslen += list->tokens[i].val.name.len + 1;\n+\targc++;\n+\tbreak;\n+      case CPP_COMMA:\n+\tbreak;\n+      case CPP_CLOSE_PAREN:\n+\tgoto scanned;\n+      case CPP_VSPACE:\n+\tcpp_error_with_line (pfile, list->line, list->tokens[i].col,\n+\t\t\t     \"missing right paren in macro argument list\");\n+\treturn 0;\n \n-\tcase CPP_ELLIPSIS:\n-\t  goto rest_arg;\n+      default:\n+\tcpp_error_with_line (pfile, list->line, list->tokens[i].col,\n+\t\t\t     \"syntax error in #define\");\n+\treturn 0;\n \n-\tcase CPP_VSPACE:\n-\t  cpp_error (pfile, \"missing right paren in macro argument list\");\n-\t  goto invalid;\n+      case CPP_ELLIPSIS:\n+\tif (list->tokens[i-1].type != CPP_NAME)\n+\t  {\n+\t    argslen += sizeof \"__VA_ARGS__\";\n+\t    argc++;\n+\t  }\n+\ti++;\n+\tif (list->tokens[i].type != CPP_CLOSE_PAREN)\n+\t  {\n+\t    cpp_error_with_line (pfile, list->line, list->tokens[i].col,\n+\t\t\t\t \"another parameter follows \\\"...\\\"\");\n+\t    return 0;\n+\t  }\n+\tgoto scanned;\n+      }\n \n-\tdefault:\n-\t  cpp_error (pfile, \"syntax error in #define\");\n-\t  goto invalid;\n-\t}\n-    }\n+  cpp_ice (pfile, \"collect_params: unreachable - i=%d, ntokens=%d, type=%d\",\n+\t   i, list->tokens_used, list->tokens[i-1].type);\n+  return 0;\n \n- rest_arg:\n-  /* There are two possible styles for a vararg macro:\n-     the C99 way:  #define foo(a, ...) a, __VA_ARGS__\n-     the gnu way:  #define foo(a, b...) a, b\n-     The C99 way can be considered a special case of the gnu way.\n-     There are also some constraints to worry about, but we'll handle\n-     those elsewhere.  */\n-  if (argv[argc].len == 0)\n+ scanned:\n+  if (argc == 0)\t/* function-like macro, no arguments */\n     {\n-      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n-\tcpp_pedwarn (pfile, \"C89 does not permit varargs macros\");\n-\n-      len = sizeof \"__VA_ARGS__\" - 1;\n-      namebuf = (U_CHAR *) xrealloc (namebuf, argslen + len + 1);\n-      name = &namebuf[argslen - 1];\n-      argslen += len;\n-      memcpy (name, \"__VA_ARGS__\", len);\n-      argv[argc].len = len;\n+      arglist->argc = 0;\n+      arglist->argv = 0;\n+      arglist->namebuf = 0;\n+      return i + 1;\n     }\n-  else\n-    if (CPP_PEDANTIC (pfile))\n-      cpp_pedwarn (pfile, \"ISO C does not permit named varargs macros\");\n-\n-  argv[argc].rest_arg = 1;\n-  \n-  token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_CLOSE_PAREN)\n+  if (argslen == 0)\n     {\n-      cpp_error (pfile, \"another parameter follows `...'\");\n-      goto invalid;\n+      cpp_ice (pfile, \"collect_params: argc=%d argslen=0\", argc);\n+      return 0;\n     }\n \n- done:\n-  /* Go through argv and fix up the pointers.  */\n-  len = 0;\n-  for (i = 0; i <= argc; i++)\n-    {\n-      argv[i].name = namebuf + len;\n-      len += argv[i].len + 1;\n-      namebuf[len - 1] = '\\0';\n-    }\n+  /* Now allocate space and copy the suckers.  */\n+  argv = (struct arg *) xmalloc (argc * sizeof (struct arg));\n+  namebuf = (U_CHAR *) xmalloc (argslen);\n+  p = namebuf;\n+  a = 0;\n+  for (j = 2; j < i; j++)\n+    switch (list->tokens[j].type)\n+      {\n+      case CPP_NAME:\n+\ttok = list->tokens[j].val.name.offset + list->namebuf;\n+\tlen = list->tokens[j].val.name.len;\n+\tmemcpy (p, tok, len);\n+\tp[len] = '\\0';\n+\tif (duplicate_arg_p (namebuf, p))\n+\t  {\n+\t    cpp_error (pfile, \"duplicate macro argument name \\\"%s\\\"\", tok);\n+\t    a++;\n+\t    break;\n+\t  }\n+\tif (CPP_PEDANTIC (pfile) && CPP_OPTION (pfile, c99)\n+\t    && len == sizeof \"__VA_ARGS__\" - 1\n+\t    && !strcmp (p, \"__VA_ARGS__\"))\n+\t  cpp_pedwarn (pfile,\n+\t\"C99 does not permit use of __VA_ARGS__ as a macro argument name\");\n+\targv[a].len = len;\n+\targv[a].name = p;\n+\targv[a].rest_arg = 0;\n+\tp += len;\n+\ta++;\n+\tbreak;\n \n-  CPP_SET_WRITTEN (pfile, old_written);\n+      case CPP_COMMA:\n+\tbreak;\n \n-  result = (struct arglist *) xmalloc (sizeof (struct arglist));\n-  if (namebuf[0] != '\\0')\n-    {\n-      result->namebuf = namebuf;\n-      result->argc = argc + 1;\n-      result->argv = argv;\n-    }\n-  else\n-    {\n-      free (namebuf);\n-      result->namebuf = 0;\n-      result->argc = 0;\n-      result->argv = 0;\n-    }\n+      case CPP_ELLIPSIS:\n+\tif (list->tokens[j-1].type != CPP_NAME)\n+\t  {\n+\t    if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n+\t      cpp_pedwarn (pfile, \"C89 does not permit varargs macros\");\n \n-  return result;\n+\t    argv[a].len = sizeof \"__VA_ARGS__\" - 1;\n+\t    argv[a].name = p;\n+\t    argv[a].rest_arg = 1;\n+\t    strcpy (p, \"__VA_ARGS__\");\n+\t  }\n+\telse\n+\t  {\n+\t    if (CPP_PEDANTIC (pfile))\n+\t      cpp_pedwarn (pfile,\n+\t\t\t   \"ISO C does not permit named varargs macros\");\n+\t    argv[a-1].rest_arg = 1;\n+\t  }\n+\tbreak;\n \n- invalid:\n-  if (argv)\n-    free (argv);\n-  if (namebuf)\n-    free (namebuf);\n-  return 0;\n+      default:\n+\tcpp_ice (pfile, \"collect_params: impossible token type %d\",\n+\t\t list->tokens[j].type);\n+      }\n+\n+  arglist->argc = argc;\n+  arglist->argv = argv;\n+  arglist->namebuf = namebuf;\n+  return i + 1;\n }\n \n-/* Create a DEFINITION node for a macro.  The reader's point is just\n-   after the macro name.  If FUNLIKE is true, this is a function-like\n-   macro.  */\n+/* Create a DEFINITION node for a macro.  The replacement text\n+   (including formal parameters if present) is in LIST.  If FUNLIKE is\n+   true, this is a function-like macro.  */\n \n DEFINITION *\n-_cpp_create_definition (pfile, funlike)\n+_cpp_create_definition (pfile, list, funlike)\n      cpp_reader *pfile;\n+     cpp_toklist *list;\n      int funlike;\n {\n-  struct arglist *args = 0;\n-  unsigned int line, col;\n-  const char *file;\n+  struct arglist args;\n   DEFINITION *defn;\n-\n-  line = CPP_BUF_LINE (CPP_BUFFER (pfile));\n-  col = CPP_BUF_COL (CPP_BUFFER (pfile));\n-  file = CPP_BUFFER (pfile)->nominal_fname;\n+  int replacement = 1;  /* replacement begins at this token */\n \n   if (funlike)\n     {\n-      args = collect_formal_parameters (pfile);\n-      if (args == 0)\n+      replacement = collect_params (pfile, list, &args);\n+      if (replacement == 0)\n \treturn 0;\n     }\n \n-  defn = collect_expansion (pfile, args);\n+  defn = collect_expansion (pfile, list, funlike ? &args : 0, replacement);\n   if (defn == 0)\n     return 0;\n \n-  defn->line = line;\n-  defn->file = file;\n-  defn->col  = col;\n+  defn->file = CPP_BUFFER (pfile)->nominal_fname;\n+  defn->line = list->line;\n+  defn->col  = list->tokens[0].col;\n   return defn;\n }\n \n@@ -1098,11 +1028,8 @@ _cpp_macroexpand (pfile, hp)\n \t}\n       else if (i < nargs)\n \t{\n-\t  /* traditional C allows foo() if foo wants one argument.  */\n-\t  if (nargs == 1 && i == 0 && CPP_TRADITIONAL (pfile))\n-\t    ;\n \t  /* the rest args token is allowed to absorb 0 tokens */\n-\t  else if (i == nargs - 1 && defn->rest_args)\n+\t  if (i == nargs - 1 && defn->rest_args)\n \t    rest_zero = 1;\n \t  else if (i == 0)\n \t    cpp_error (pfile, \"macro `%s' used without args\", hp->name);\n@@ -1158,8 +1085,7 @@ _cpp_macroexpand (pfile, hp)\n \t\t  int need_space = -1;\n \t\t  i = 0;\n \t\t  arg->stringified = CPP_WRITTEN (pfile);\n-\t\t  if (!CPP_TRADITIONAL (pfile))\n-\t\t    CPP_PUTC (pfile, '\\\"');\t/* insert beginning quote */\n+\t\t  CPP_PUTC (pfile, '\\\"');\t/* insert beginning quote */\n \t\t  for (; i < arglen; i++)\n \t\t    {\n \t\t      c = (ARG_BASE + arg->raw)[i];\n@@ -1214,14 +1140,13 @@ _cpp_macroexpand (pfile, hp)\n \t\t\t  CPP_ADJUST_WRITTEN (pfile, 4);\n \t\t\t}\n \t\t    }\n-\t\t  if (!CPP_TRADITIONAL (pfile))\n-\t\t    CPP_PUTC (pfile, '\\\"');\t/* insert ending quote */\n+\t\t  CPP_PUTC (pfile, '\\\"');\t/* insert ending quote */\n \t\t  arg->stringified_length\n \t\t    = CPP_WRITTEN (pfile) - arg->stringified;\n \t\t}\n \t      xbuf_len += args[ap->argno].stringified_length;\n \t    }\n-\t  else if (ap->raw_before || ap->raw_after || CPP_TRADITIONAL (pfile))\n+\t  else if (ap->raw_before || ap->raw_after)\n \t    /* Add 4 for two \\r-space markers to prevent\n \t       token concatenation.  */\n \t    xbuf_len += args[ap->argno].raw_length + 4;\n@@ -1288,7 +1213,7 @@ _cpp_macroexpand (pfile, hp)\n \t\t      arg->stringified_length);\n \t      totlen += arg->stringified_length;\n \t    }\n-\t  else if (ap->raw_before || ap->raw_after || CPP_TRADITIONAL (pfile))\n+\t  else if (ap->raw_before || ap->raw_after)\n \t    {\n \t      U_CHAR *p1 = ARG_BASE + arg->raw;\n \t      U_CHAR *l1 = p1 + arg->raw_length;\n@@ -1340,7 +1265,6 @@ _cpp_macroexpand (pfile, hp)\n \t    {\n \t      U_CHAR *expanded = ARG_BASE + arg->expanded;\n \t      if (!ap->raw_before && totlen > 0 && arg->expand_length\n-\t\t  && !CPP_TRADITIONAL (pfile)\n \t\t  && unsafe_chars (pfile, xbuf[totlen - 1], expanded[0]))\n \t\t{\n \t\t  xbuf[totlen++] = '\\r';\n@@ -1351,7 +1275,6 @@ _cpp_macroexpand (pfile, hp)\n \t      totlen += arg->expand_length;\n \n \t      if (!ap->raw_after && totlen > 0 && offset < defn->length\n-\t\t  && !CPP_TRADITIONAL (pfile)\n \t\t  && unsafe_chars (pfile, xbuf[totlen - 1], exp[offset]))\n \t\t{\n \t\t  xbuf[totlen++] = '\\r';\n@@ -1394,12 +1317,8 @@ _cpp_macroexpand (pfile, hp)\n   /* Pop the space we've used in the token_buffer for argument expansion.  */\n   CPP_SET_WRITTEN (pfile, old_written);\n \n-  /* Recursive macro use sometimes works traditionally.\n-     #define foo(x,y) bar (x (y,0), y)\n-     foo (foo, baz)  */\n-\n-  if (!CPP_TRADITIONAL (pfile))\n-    hp->type = T_DISABLED;\n+  /* Per C89, a macro cannot be expanded recursively.  */\n+  hp->type = T_DISABLED;\n }\n \n /* Return 1 iff a token ending in C1 followed directly by a token C2\n@@ -1520,12 +1439,11 @@ _cpp_compare_defs (pfile, d1, d2)\n      DEFINITION *d1, *d2;\n {\n   struct reflist *a1, *a2;\n-  U_CHAR *p1 = d1->expansion;\n-  U_CHAR *p2 = d2->expansion;\n-  int first = 1;\n \n   if (d1->nargs != d2->nargs)\n     return 1;\n+  if (strcmp (d1->expansion, d2->expansion))\n+    return 1;\n   if (CPP_PEDANTIC (pfile)\n       && d1->argnames && d2->argnames)\n     {\n@@ -1545,74 +1463,17 @@ _cpp_compare_defs (pfile, d1, d2)\n   for (a1 = d1->pattern, a2 = d2->pattern; a1 && a2;\n        a1 = a1->next, a2 = a2->next)\n     {\n-      if (!((a1->nchars == a2->nchars && !strncmp (p1, p2, a1->nchars))\n-\t    || !comp_def_part (first, p1, a1->nchars, p2, a2->nchars, 0))\n+      if (a1->nchars != a2->nchars\n \t  || a1->argno != a2->argno\n \t  || a1->stringify != a2->stringify\n \t  || a1->raw_before != a2->raw_before\n \t  || a1->raw_after != a2->raw_after)\n \treturn 1;\n-      first = 0;\n-      p1 += a1->nchars;\n-      p2 += a2->nchars;\n     }\n   if (a1 != a2)\n     return 1;\n \n-  return comp_def_part (first, p1, d1->length - (p1 - d1->expansion),\n-\t\t\tp2, d2->length - (p2 - d2->expansion), 1);\n-}\n-\n-/* Return 1 if two parts of two macro definitions are effectively different.\n-   One of the parts starts at BEG1 and has LEN1 chars;\n-   the other has LEN2 chars at BEG2.\n-   Any sequence of whitespace matches any other sequence of whitespace.\n-   FIRST means these parts are the first of a macro definition;\n-    so ignore leading whitespace entirely.\n-   LAST means these parts are the last of a macro definition;\n-    so ignore trailing whitespace entirely.  */\n-\n-static int\n-comp_def_part (first, beg1, len1, beg2, len2, last)\n-     int first;\n-     U_CHAR *beg1, *beg2;\n-     int len1, len2;\n-     int last;\n-{\n-  register U_CHAR *end1 = beg1 + len1;\n-  register U_CHAR *end2 = beg2 + len2;\n-  if (first)\n-    {\n-      while (beg1 != end1 && is_space(*beg1))\n-\tbeg1++;\n-      while (beg2 != end2 && is_space(*beg2))\n-\tbeg2++;\n-    }\n-  if (last)\n-    {\n-      while (beg1 != end1 && is_space(end1[-1]))\n-\tend1--;\n-      while (beg2 != end2 && is_space(end2[-1]))\n-\tend2--;\n-    }\n-  while (beg1 != end1 && beg2 != end2)\n-    {\n-      if (is_space(*beg1) && is_space(*beg2))\n-\t{\n-\t  while (beg1 != end1 && is_space(*beg1))\n-\t    beg1++;\n-\t  while (beg2 != end2 && is_space(*beg2))\n-\t    beg2++;\n-\t}\n-      else if (*beg1 == *beg2)\n-\t{\n-\t  beg1++;\n-\t  beg2++;\n-\t}\n-      else\n-\tbreak;\n-    }\n-  return (beg1 != end1) || (beg2 != end2);\n+  return 0;\n }\n \n /* Dump the definition of macro MACRO on stdout.  The format is suitable"}, {"sha": "2b8a5d1fa1a98b138ad31ddc24796e428bbe7f54", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=9e62c8114f04116b2107809c51bf33ef1a2993c9", "patch": "@@ -272,7 +272,8 @@ extern HASHNODE **_cpp_lookup_slot\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t enum insert_option,\n \t\t\t\t\t\t unsigned long *));\n extern void _cpp_free_definition\tPARAMS ((DEFINITION *));\n-extern DEFINITION *_cpp_create_definition PARAMS ((cpp_reader *, int));\n+extern DEFINITION *_cpp_create_definition PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t   cpp_toklist *, int));\n extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t\t long, DEFINITION *));\n extern int _cpp_compare_defs\t\tPARAMS ((cpp_reader *, DEFINITION *,"}, {"sha": "effb6ca05103c4065e0765fe77b4cd036ac46c86", "filename": "gcc/cpplex.c", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=9e62c8114f04116b2107809c51bf33ef1a2993c9", "patch": "@@ -57,6 +57,8 @@ static void bump_column\t\tPARAMS ((cpp_printer *, unsigned int,\n static void expand_name_space\tPARAMS ((cpp_toklist *));\n static void expand_token_space\tPARAMS ((cpp_toklist *));\n static void init_token_list\tPARAMS ((cpp_reader *, cpp_toklist *, int));\n+static void pedantic_whitespace\tPARAMS ((cpp_reader *, U_CHAR *,\n+\t\t\t\t\t unsigned int));\n \n /* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n \n@@ -474,7 +476,8 @@ init_token_list (pfile, list, recycle)\n       list->namebuf = (unsigned char *) xmalloc (list->name_cap);\n     }\n \n-  list->line = pfile->buffer->lineno;\n+  if (pfile->buffer)\n+    list->line = pfile->buffer->lineno;\n   list->dir_handler = 0;\n   list->dir_flags = 0;\n }\n@@ -490,29 +493,40 @@ _cpp_scan_line (pfile, list)\n   int i, col;\n   long written, len;\n   enum cpp_ttype type;\n+  int space_before;\n \n   init_token_list (pfile, list, 1);\n \n   written = CPP_WRITTEN (pfile);\n   i = 0;\n+  space_before = 0;\n   for (;;)\n     {\n       col = CPP_BUFFER (pfile)->cur - CPP_BUFFER (pfile)->line_base;\n       type = _cpp_lex_token (pfile);\n       len = CPP_WRITTEN (pfile) - written;\n       CPP_SET_WRITTEN (pfile, written);\n       if (type == CPP_HSPACE)\n-\tcontinue;\n+\t{\n+\t  if (CPP_PEDANTIC (pfile))\n+\t    pedantic_whitespace (pfile, pfile->token_buffer + written, len);\n+\t  space_before = 1;\n+\t  continue;\n+\t}\n \n       if (list->tokens_used >= list->tokens_cap)\n \texpand_token_space (list);\n       if (list->name_used + len >= list->name_cap)\n \texpand_name_space (list);\n \n+      if (type == CPP_MACRO)\n+\ttype = CPP_NAME;\n+\n       list->tokens_used++;\n       list->tokens[i].type = type;\n       list->tokens[i].col = col;\n-\n+      list->tokens[i].flags = space_before ? HSPACE_BEFORE : 0;\n+      \n       if (type == CPP_VSPACE)\n \tbreak;\n \n@@ -521,8 +535,12 @@ _cpp_scan_line (pfile, list)\n       memcpy (list->namebuf + list->name_used, CPP_PWRITTEN (pfile), len);\n       list->name_used += len;\n       i++;\n+      space_before = 0;\n     }\n   list->tokens[i].aux =  CPP_BUFFER (pfile)->lineno + 1;\n+\n+  /* XXX Temporary kluge: put back the newline.  */\n+  FORWARD(-1);\n }\n \n \n@@ -1034,14 +1052,8 @@ _cpp_lex_token (pfile)\n \t For -traditional, a comment is equivalent to nothing.  */\n       if (!CPP_OPTION (pfile, discard_comments))\n \treturn CPP_COMMENT;\n-      else if (CPP_TRADITIONAL (pfile)\n-\t       && ! is_space (PEEKC ()))\n-\t{\n-\t  if (pfile->parsing_define_directive)\n-\t    return CPP_COMMENT;\n-\t  else\n-\t    goto get_next;\n-\t}\n+      else if (CPP_TRADITIONAL (pfile))\n+\tgoto get_next;\n       else\n \t{\n \t  CPP_PUTC (pfile, c);\n@@ -1060,7 +1072,7 @@ _cpp_lex_token (pfile)\n \t  return CPP_OTHER;\n \t}\n \n-      if (pfile->parsing_define_directive && ! CPP_TRADITIONAL (pfile))\n+      if (pfile->parsing_define_directive)\n \t{\n \t  c2 = PEEKC ();\n \t  if (c2 == '#')\n@@ -1510,6 +1522,26 @@ maybe_macroexpand (pfile, written)\n   return 1;\n }\n \n+/* Complain about \\v or \\f in a preprocessing directive (constraint\n+   violation, C99 6.10 para 5).  Caller has checked CPP_PEDANTIC.  */\n+static void\n+pedantic_whitespace (pfile, p, len)\n+     cpp_reader *pfile;\n+     U_CHAR *p;\n+     unsigned int len;\n+{\n+  while (len)\n+    {\n+      if (*p == '\\v')\n+\tcpp_pedwarn (pfile, \"vertical tab in preprocessing directive\");\n+      else if (*p == '\\f')\n+\tcpp_pedwarn (pfile, \"form feed in preprocessing directive\");\n+      p++;\n+      len--;\n+    }\n+}\n+\n+\n enum cpp_ttype\n cpp_get_token (pfile)\n      cpp_reader *pfile;\n@@ -1591,14 +1623,10 @@ cpp_get_non_space_token (pfile)\n }\n \n /* Like cpp_get_token, except that it does not execute directives,\n-   does not consume vertical space, and automatically pops off macro\n-   buffers.\n-\n-   XXX This function will exist only till collect_expansion doesn't\n-   need to see whitespace anymore, then it'll be merged with\n-   _cpp_get_directive_token (below).  */\n+   does not consume vertical space, discards horizontal space, and\n+   automatically pops off macro buffers.  */\n enum cpp_ttype\n-_cpp_get_define_token (pfile)\n+_cpp_get_directive_token (pfile)\n      cpp_reader *pfile;\n {\n   long old_written;\n@@ -1620,18 +1648,10 @@ _cpp_get_define_token (pfile)\n \n     case CPP_HSPACE:\n       if (CPP_PEDANTIC (pfile))\n-\t{\n-\t  U_CHAR *p, *limit;\n-\t  p = pfile->token_buffer + old_written;\n-\t  limit = CPP_PWRITTEN (pfile);\n-\t  while (p < limit)\n-\t    {\n-\t      if (*p == '\\v' || *p == '\\f')\n-\t\tcpp_pedwarn (pfile, \"%s in preprocessing directive\",\n-\t\t\t     *p == '\\f' ? \"formfeed\" : \"vertical tab\");\n-\t      p++;\n-\t    }\n-\t}\n+\tpedantic_whitespace (pfile, pfile->token_buffer + old_written,\n+\t\t\t     CPP_WRITTEN (pfile) - old_written);\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      goto get_next;\n       return CPP_HSPACE;\n \n     case CPP_DIRECTIVE:\n@@ -1660,23 +1680,6 @@ _cpp_get_define_token (pfile)\n     }\n }\n \n-/* Just like _cpp_get_define_token except that it discards horizontal\n-   whitespace.  */\n-\n-enum cpp_ttype\n-_cpp_get_directive_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  int old_written = CPP_WRITTEN (pfile);\n-  for (;;)\n-    {\n-      enum cpp_ttype token = _cpp_get_define_token (pfile);\n-      if (token != CPP_COMMENT && token != CPP_HSPACE)\n-\treturn token;\n-      CPP_SET_WRITTEN (pfile, old_written);\n-    }\n-}\n-\n /* Determine the current line and column.  Used only by read_and_prescan. */\n static U_CHAR *\n find_position (start, limit, linep)\n@@ -2008,6 +2011,7 @@ _cpp_init_input_buffer (pfile)\n   U_CHAR *tmp;\n \n   init_chartab ();\n+  init_token_list (pfile, &pfile->directbuf, 0);\n \n   /* Determine the appropriate size for the input buffer.  Normal C\n      source files are smaller than eight K.  */"}, {"sha": "f8815842f58ccaaa0d4fb1366156272a1992b459", "filename": "gcc/cpplib.c", "status": "modified", "additions": 39, "deletions": 57, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=9e62c8114f04116b2107809c51bf33ef1a2993c9", "patch": "@@ -66,7 +66,6 @@ static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n static U_CHAR *detect_if_not_defined\tPARAMS ((cpp_reader *));\n static int consider_directive_while_skipping\n \t\t\t\t\tPARAMS ((cpp_reader *, IF_STACK *));\n-static int get_macro_name\t\tPARAMS ((cpp_reader *));\n \n /* Values for the flags field of the table below.  KANDR and COND\n    directives come from traditional (K&R) C.  The difference is, if we\n@@ -310,36 +309,6 @@ pass_thru_directive (buf, len, pfile, keyword)\n   CPP_PUTS_Q (pfile, buf, len);\n }\n \n-/* Subroutine of do_define: determine the name of the macro to be\n-   defined.  */\n-\n-static int\n-get_macro_name (pfile)\n-     cpp_reader *pfile;\n-{\n-  long here, len;\n-\n-  here = CPP_WRITTEN (pfile);\n-  if (_cpp_get_directive_token (pfile) != CPP_NAME)\n-    {\n-      cpp_error (pfile, \"`#define' must be followed by an identifier\");\n-      goto invalid;\n-    }\n-\n-  len = CPP_WRITTEN (pfile) - here;\n-  if (len == 7 && !strncmp (pfile->token_buffer + here, \"defined\", 7))\n-    {\n-      cpp_error (pfile, \"`defined' is not a legal macro name\");\n-      goto invalid;\n-    }\n-\n-  return len;\n-\n- invalid:\n-  _cpp_skip_rest_of_line (pfile);\n-  return 0;\n-}\n-\n /* Process a #define command.  */\n \n static int\n@@ -348,47 +317,60 @@ do_define (pfile)\n {\n   HASHNODE **slot;\n   DEFINITION *def = 0;\n-  long here;\n   unsigned long hash;\n   int len;\n   int funlike = 0, empty = 0;\n   U_CHAR *sym;\n-  enum cpp_ttype token;\n+  cpp_toklist *list = &pfile->directbuf;\n \n   pfile->no_macro_expand++;\n   pfile->parsing_define_directive++;\n   CPP_OPTION (pfile, discard_comments)++;\n \n-  here = CPP_WRITTEN (pfile);\n-  len = get_macro_name (pfile);\n-  if (len == 0)\n-    goto out;\n+  _cpp_scan_line (pfile, list);\n \n-  /* Copy out the name so we can pop the token buffer.  */\n-  len = CPP_WRITTEN (pfile) - here;\n-  sym = (U_CHAR *) alloca (len + 1);\n-  memcpy (sym, pfile->token_buffer + here, len);\n-  sym[len] = '\\0';\n+  /* First token on the line must be a NAME.  There must be at least\n+     one token (the VSPACE at the end).  */\n+  if (list->tokens[0].type != CPP_NAME)\n+    {\n+      cpp_error_with_line (pfile, list->line, list->tokens[0].col,\n+\t\t\t   \"#define must be followed by an identifier\");\n+      goto out;\n+    }\n+\n+  sym = list->namebuf + list->tokens[0].val.name.offset;\n+  len = list->tokens[0].val.name.len;\n+\n+  /* That NAME is not allowed to be \"defined\".  (Not clear if the\n+     standard requires this.)  */\n+  if (len == 7 && !strncmp (sym, \"defined\", 7))\n+    {\n+      cpp_error_with_line (pfile, list->line, list->tokens[0].col,\n+\t\t\t   \"\\\"defined\\\" is not a legal macro name\");\n+      goto out;\n+    }\n+\n+\n+  if (list->tokens_used == 2 && list->tokens[1].type == CPP_VSPACE)\n+    empty = 0;  /* Empty definition of object-like macro.  */\n \n   /* If the next character, with no intervening whitespace, is '(',\n-     then this is a function-like macro.\n-     XXX Layering violation.  */\n-  CPP_SET_MARK (pfile);\n-  token = _cpp_get_directive_token (pfile);\n-  if (token == CPP_VSPACE)\n-    empty = 0;  /* Empty definition of object like macro.  */\n-  else if (token == CPP_OPEN_PAREN && ADJACENT_TO_MARK (pfile))\n-    funlike = 1;\n-  else if (ADJACENT_TO_MARK (pfile))\n-    /* If this is an object-like macro, C99 requires white space after\n-       the name.  */\n-    cpp_pedwarn (pfile, \"missing white space after `#define %.*s'\", len, sym);\n-  CPP_GOTO_MARK (pfile);\n-  CPP_SET_WRITTEN (pfile, here);\n+     then this is a function-like macro.  Otherwise it is an object-\n+     like macro, and C99 requires whitespace after the name\n+     (6.10.3 para 3).  */\n+  else if (!(list->tokens[1].flags & HSPACE_BEFORE))\n+    {\n+      if (list->tokens[1].type == CPP_OPEN_PAREN)\n+\tfunlike = 1;\n+      else\n+\tcpp_pedwarn (pfile,\n+\t\t     \"The C standard requires whitespace after #define %.*s\",\n+\t\t     len, sym);\n+    }\n \n   if (! empty)\n     {\n-      def = _cpp_create_definition (pfile, funlike);\n+      def = _cpp_create_definition (pfile, list, funlike);\n       if (def == 0)\n \tgoto out;\n     }"}, {"sha": "764d8e6c9e3c6d896a5f7d24a779f028e003ba58", "filename": "gcc/cpplib.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e62c8114f04116b2107809c51bf33ef1a2993c9/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=9e62c8114f04116b2107809c51bf33ef1a2993c9", "patch": "@@ -135,6 +135,9 @@ struct cpp_name\n   unsigned int offset;\t\t/* from list->namebuf */\n };\n \n+/* Per token flags.  */\n+#define HSPACE_BEFORE\t(1 << 0)\t/* token preceded by hspace */\n+\n /* A preprocessing token.\n    This has been carefully packed and should occupy 16 bytes on\n    both 32- and 64-bit hosts.  */\n@@ -146,7 +149,7 @@ struct cpp_token\n #else\n   unsigned char type;\n #endif\n-  unsigned char flags;\t\t\t/* flags - not presently used */\n+  unsigned char flags;\t\t\t/* flags - see above */\n   unsigned int aux;\t\t\t/* hash of a NAME, or something -\n \t\t\t\t\t   see uses in the code */\n   union\n@@ -435,8 +438,12 @@ struct cpp_options\n \n struct cpp_reader\n {\n+  /* Top of buffer stack.  */\n   cpp_buffer *buffer;\n \n+  /* Token list used by get_directive_token.  */\n+  cpp_toklist directbuf;\n+\n   /* A buffer used for both for cpp_get_token's output, and also internally. */\n   unsigned char *token_buffer;\n   /* Allocated size of token_buffer.  CPP_RESERVE allocates space.  */"}]}