{"sha": "051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxZTViYmY2YmE5MWY0MTliNmQzZmY2YTNhNzVlMTdkZDI1MDZkZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-24T03:01:33Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-24T03:01:33Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1259", "tree": {"sha": "7a5defa0aab752a9541304d636e8f8c549561dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a5defa0aab752a9541304d636e8f8c549561dbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd/comments", "author": null, "committer": null, "parents": [{"sha": "819817b9ff2718ba2786f758c6a69639d101948e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819817b9ff2718ba2786f758c6a69639d101948e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819817b9ff2718ba2786f758c6a69639d101948e"}], "stats": {"total": 16, "additions": 10, "deletions": 6}, "files": [{"sha": "9d238dcfdaaf96667bf8c74022f6f7bb8d93098b", "filename": "gcc/input.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd", "patch": "@@ -15,6 +15,10 @@ struct file_stack\n     char *name;\n     struct file_stack *next;\n     int line;\n+    /* This is for front ends that do include processing\n+       internally rather than having a preprocessor do it.\n+       Modula 2 needs this.  */\n+    FILE *fd;\n   };\n \n /* Stack of currently pending input files."}, {"sha": "4bb66054df9bc6cfef36fe1dacb8db9dd733ef78", "filename": "gcc/regclass.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=051e5bbf6ba91f419b6d3ff6a3a75e17dd2506dd", "patch": "@@ -962,12 +962,12 @@ record_address_regs (x, bcost, icost)\n /* Indexed by pseudo register number, gives uid of first insn using the reg\n    (as of the time reg_scan is called).  */\n \n-short *regno_first_uid;\n+int *regno_first_uid;\n \n /* Indexed by pseudo register number, gives uid of last insn using the reg\n    (as of the time reg_scan is called).  */\n \n-short *regno_last_uid;\n+int *regno_last_uid;\n \n /* Record the number of registers we used when we allocated the above two\n    tables.  If we are called again with more than this, we must re-allocate\n@@ -996,15 +996,15 @@ reg_scan (f, nregs, repeat)\n       /* Leave some spare space in case more regs are allocated.  */\n       highest_regno_in_uid_map = nregs + nregs / 20;\n       regno_first_uid\n-\t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n+\t= (int *) oballoc (highest_regno_in_uid_map * sizeof (int));\n       regno_last_uid\n-\t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n+\t= (int *) oballoc (highest_regno_in_uid_map * sizeof (int));\n       reg_n_sets\n \t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n     }\n \n-  bzero (regno_first_uid, highest_regno_in_uid_map * sizeof (short));\n-  bzero (regno_last_uid, highest_regno_in_uid_map * sizeof (short));\n+  bzero (regno_first_uid, highest_regno_in_uid_map * sizeof (int));\n+  bzero (regno_last_uid, highest_regno_in_uid_map * sizeof (int));\n   bzero (reg_n_sets, highest_regno_in_uid_map * sizeof (short));\n \n   max_parallel = 3;"}]}